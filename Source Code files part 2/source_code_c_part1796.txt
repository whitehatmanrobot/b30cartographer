Normal = m_pFloorPlan->pPaintingsLayout[nIndex].vNormal;

                m_pPaintings[nIndex]->OneTimeSceneInit();
                hr = m_pPaintings[nIndex]->SetPainting(m_pMain->GetGlobalTexture(ITEM_FRAME, &fScale), pPaintingTexture, vPaintingLoc, fMaxPaintingWH, FRAMESIZE_X, FRAMESIZE_Y, vPaintingNormal, dwMaxPixelSize);
                pPaintingTexture->Release();
            }
            else
            {
                // This will fail if we can't load our pictures.  This will cause us to come back later when
                // the background thread may have an image.
                SAFE_DELETE(m_pPaintings[nIndex]);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT CTheRoom::_AddWall(BOOL fWithDoor, D3DXVECTOR3 vLocation, D3DXVECTOR3 vWidth, D3DXVECTOR3 vHeight, D3DXVECTOR3 vNormal,
                           float fTotalHeight, float fDoorHeight, float fTotalWidth, float fDoorWidth, float fDoorStart)
{
    HRESULT hr = S_OK;

    C3DObject * pobjNextWall = new C3DObject(m_pMain);
    C3DObject * pobjNextToeGuard = new C3DObject(m_pMain);
    if (pobjNextWall && pobjNextToeGuard && m_pMain)
    {
        if (fWithDoor)
        {
            hr = _AddWallWithDoor(pobjNextWall, pobjNextToeGuard, &m_objFloor, vLocation, vWidth, vHeight, vNormal, fTotalHeight, fDoorHeight, fTotalWidth, fDoorWidth, fDoorStart);
        }
        else
        {
            // Texture Coords
            float fScale = 1.0f;
            CTexture * pTexture = m_pMain->GetGlobalTexture(ITEM_WALLPAPER, &fScale);
            float fTSWallpaperX = (TEXTURESCALE_WALLPAPER * fScale);     // How many repeats per 1 unit.
            float fTSWallpaperY = fTSWallpaperX * pTexture->GetSurfaceRatio();

            D3DXVECTOR3 vSizeNoDoor = ((vWidth * fTotalWidth) + (vHeight * fTotalHeight));
            hr = pobjNextWall->InitPlane(pTexture, m_pMain->GetD3DDevice(), vLocation, vSizeNoDoor, vNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
            if (SUCCEEDED(hr))
            {
                CTexture * pToeGuardTexture = m_pMain->GetGlobalTexture(ITEM_TOEGUARD, &fScale);
                float fTSToeGuardX = (TEXTURESCALE_TOEGUARD * fScale);     // How many repeats per 1 unit.
                float fTSToeGuardY = fTSToeGuardX * pToeGuardTexture->GetSurfaceRatio();

                // Draw ToeGuard
                vLocation += (g_fFudge * vNormal);
                vSizeNoDoor = D3DXVECTOR3(vSizeNoDoor.x, TOEGUARD_HEIGHT, vSizeNoDoor.z);
                hr = pobjNextToeGuard->InitPlane(pToeGuardTexture, m_pMain->GetD3DDevice(), vLocation, vSizeNoDoor, vNormal, 2, 2, fTSToeGuardX, fTSToeGuardY, 0, 0);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = m_objWall1.CombineObject(m_pMain->GetD3DDevice(), pobjNextWall);
            hr = m_objToeGuard1.CombineObject(m_pMain->GetD3DDevice(), pobjNextToeGuard);
        }
    }
    SAFE_DELETE(pobjNextWall);
    SAFE_DELETE(pobjNextToeGuard);

    return hr;
}


HRESULT CTheRoom::_AddWallWithDoor(C3DObject * pobjWall, C3DObject * pobjToeGuard, C3DObject * pobjFloor, D3DXVECTOR3 vLocation, D3DXVECTOR3 vWidth, D3DXVECTOR3 vHeight, D3DXVECTOR3 vNormal,
                                   float fTotalHeight, float fDoorHeight, float fTotalWidth, float fDoorWidth, float fDoorStart)
{
    HRESULT hr = S_OK;
    float fScale = 1.0f;
    float fYToeGuard = TOEGUARD_HEIGHT;

    CTexture * pToeTexture = m_pMain->GetGlobalTexture(ITEM_TOEGUARD, &fScale);
    float fTSToeGuardX = (TEXTURESCALE_TOEGUARD * fScale);     // How many repeats per 1 unit.
    float fTSToeGuardY = fTSToeGuardX * pToeTexture->GetSurfaceRatio();

    CTexture * pTexture = m_pMain->GetGlobalTexture(ITEM_WALLPAPER, &fScale);
    float fTSWallpaperX = (TEXTURESCALE_WALLPAPER * fScale);     // How many repeats per 1 unit.
    float fTSWallpaperY = fTSWallpaperX * pTexture->GetSurfaceRatio();

    CTexture * pFloorTexture = m_pMain->GetGlobalTexture(ITEM_FLOOR, &fScale);
    float fTSFloorX = (TEXTURESCALE_FLOOR * fScale);     // How many repeats per 1 unit.
    float fTSFloorY = fTSFloorX * pFloorTexture->GetSurfaceRatio();

    // Create Main Wall
    D3DXVECTOR3 vSize = ((fDoorStart * vWidth) + (fTotalHeight * vHeight));

    hr = pobjWall->InitPlane(pTexture, m_pMain->GetD3DDevice(), vLocation, vSize, vNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
    if (SUCCEEDED(hr))
    {
        D3DXVECTOR3 vToeLocation = (vLocation + (g_fFudge * vNormal));    // Offset the toeguard so it's above the wall.
        vSize = D3DXVECTOR3(D3DXVec3Multiply(vSize, vWidth) + (vHeight * fYToeGuard));            // Replace the height component with the ToeGuard height)

        hr = pobjToeGuard->InitPlane(pToeTexture, m_pMain->GetD3DDevice(), vToeLocation, vSize, vNormal, 2, 2, fTSToeGuardX, fTSToeGuardY, 0, 0);
        if (SUCCEEDED(hr))
        {
            int nParts = 9;
            D3DXVECTOR3 vNextLocation;
            D3DXVECTOR3 vTempNormal;

            while (nParts--)    // We have 2 more wall parts and 1 more toeguards to add.
            {
                C3DObject * pNewObject = new C3DObject(m_pMain);

                if (pNewObject)
                {
                    switch (nParts)
                    {
                    case 8:             // Floor at base of door way.
                        vNextLocation = (vLocation + (fDoorStart * vWidth));
                        vSize = (((-1.0f * DOORFRAME_DEPTH) * vNormal) + (fDoorWidth * vWidth));
                        vTempNormal = D3DXVECTOR3(0.0f, 1.0f, 0.0f);        // Normal points up
                        hr = pNewObject->InitPlane(pFloorTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSFloorX, fTSFloorY, 0, 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjFloor->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 7:             // Add the wallguard in the door way #2
                        vNextLocation = (vLocation + ((fDoorStart + g_fFudge) * vWidth) + (g_fFudge * vNormal));
                        vSize = (((-1.0f * (DOORFRAME_DEPTH + (2.0f * g_fFudge)) * vNormal)) + (fYToeGuard * vHeight));
                        vTempNormal = vWidth;
                        hr = pNewObject->InitPlane(pToeTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSToeGuardX, fTSToeGuardY, 0, 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjToeGuard->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 6:             // Add the wallguard in the door way #1
                        vNextLocation = (vLocation + ((fDoorStart + fDoorWidth - g_fFudge) * vWidth) + (g_fFudge * vNormal));
                        vSize = (((-1.0f * (DOORFRAME_DEPTH + (2.0f * g_fFudge))) * vNormal) + (fYToeGuard * vHeight));
                        vTempNormal = (-1.0f * vWidth);
                        hr = pNewObject->InitPlane(pToeTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSToeGuardX, fTSToeGuardY, 0, 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjToeGuard->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 5:             // Add door frame top
                        vNextLocation = (vLocation + (fDoorStart * vWidth) + (fDoorHeight * vHeight));
                        vSize = (((-1.0f * DOORFRAME_DEPTH) * vNormal) + (fDoorWidth * vWidth));
                        vTempNormal = D3DXVECTOR3(0.0f, -1.0f, 0.0f);
                        hr = pNewObject->InitPlane(pTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjWall->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 4:             // Add door frame #2
                        vNextLocation = (vLocation + (fDoorStart * vWidth));
                        vSize = (((-1.0f * DOORFRAME_DEPTH) * vNormal) + (fTotalHeight * vHeight));
                        vTempNormal = vWidth;
                        hr = pNewObject->InitPlane(pTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjWall->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 3:             // Add door frame #1
                        vNextLocation = (vLocation + ((fDoorStart + fDoorWidth) * vWidth));
                        vSize = (((-1.0f * DOORFRAME_DEPTH) * vNormal) + (fTotalHeight * vHeight));
                        vTempNormal = (-1.0f * vWidth);
                        hr = pNewObject->InitPlane(pToeTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjWall->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 2:             // Add the second wall part. (Wall over the door)
                        vNextLocation = (vLocation + (fDoorStart * vWidth) + (fDoorHeight * vHeight));
                        vSize = ((fDoorWidth * vWidth) + ((fTotalHeight - fDoorHeight) * vHeight));
                        hr = pNewObject->InitPlane(pTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjWall->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 1:             // Add the third wall part
                        vNextLocation = (vLocation + ((fDoorStart + fDoorWidth) * vWidth));
                        vSize = (((fTotalWidth - (fDoorStart + fDoorWidth)) * vWidth) + (fTotalHeight * vHeight));
                        hr = pNewObject->InitPlane(pTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjWall->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 0:             // Add the second Toe Guard   
                        vNextLocation = (vLocation + ((fDoorStart + fDoorWidth) * vWidth) + (g_fFudge * vNormal));
                        vSize = (((fTotalWidth - (fDoorStart + fDoorWidth)) * vWidth) + (fYToeGuard * vHeight));
                        hr = pNewObject->InitPlane(pToeTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vNormal, 2, 2, fTSToeGuardX, fTSToeGuardY, 0, 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjToeGuard->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    return hr;
}


HRESULT CTheRoom::_SetRotationMatrix(void)
{
    HRESULT hr = S_OK;
    D3DXMATRIX matRotate;
    D3DXMATRIX matTrans;

    // We want to set the matricies to get us to the next room.
    // Next Room
    if (m_pFirstRoom)
    {
        D3DXMatrixRotationY(&matRotate, D3DXToRadian(180));
        D3DXMatrixTranslation(&matTrans, ((g_fRoomWidthX / 2.0f) + (DOOR_WIDTH / 2.0f) + m_pFirstRoom->GetDoorOffset()), 0.0f, -1.0f);
        D3DXMatrixMultiply(&m_matFirstRoom, &matRotate, &matTrans);
    }

    if (m_pLeftRoom)
    {
        D3DXMatrixRotationY(&matRotate, D3DXToRadian(270));
        D3DXMatrixTranslation(&matTrans, -1.0f, 0.0f, WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f) - m_pLeftRoom->GetDoorOffset());
        D3DXMatrixMultiply(&m_matLeftRoom, &matRotate, &matTrans);
    }

    // Side Room
    if (m_pRightRoom)
    {
        D3DXMatrixRotationY(&matRotate, D3DXToRadian(90));
        D3DXMatrixTranslation(&matTrans, (g_fRoomWidthX + 1.0f), 0.0f, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f) + m_pRightRoom->GetDoorOffset()));
        D3DXMatrixMultiply(&m_matRightRoom, &matRotate, &matTrans);
    }

    return hr;
}


HRESULT CTheRoom::_CreateLobbySign(void)
{
    TCHAR szLine2[MAX_PATH];
    TCHAR szUsername[MAX_PATH];
    HRESULT hr = GetCurrentUserCustomName(szUsername, ARRAYSIZE(szUsername));

    LoadString(HINST_THISDLL, IDS_LOBBY_TITLE2, szLine2, ARRAYSIZE(szLine2));
    if (SUCCEEDED(hr))
    {
        // TODO:
        // 1. Create Sign backdrop. (Marble, wood?)
        // 2. Render Text. (D3DXCreateTextW, etc.)
    }

    return hr;
}


HRESULT CTheRoom::_CreateRoom(void)
{
    // TODO: For Square room, layout differently
    HRESULT hr = S_OK;

    D3DXVECTOR3 vNormalWall1(0, 0, -1);
    D3DXVECTOR3 vNormalWall2(-1, 0, 0);
    D3DXVECTOR3 vNormalWall3(0, 0, 1);
    D3DXVECTOR3 vNormalWall4(1, 0, 0);
    D3DXVECTOR3 vNormalFloor(0, 1, 0);
    D3DXVECTOR3 vNormalCeiling(0, -1, 0);
    DWORD dwRugMaxPixelSize = ((3 * g_dwHeight) / 4);

    m_fCeiling = m_fToeGuard = m_fPaintings = m_fRug = m_fPower = m_fWalls = m_fFloor = TRUE;
    m_fCeiling = !g_fOverheadViewTest;

    // Locations
    float fYToeGuard = TOEGUARD_HEIGHT;

    // Rug
    float fScale = 1.0f;
    float fRugWidth = 40.0f;
    float fRugDepth = (fRugWidth * (m_pMain->GetGlobalTexture(ITEM_RUG, &fScale))->GetSurfaceRatio());            // This will cause one object to be above another.
    D3DXVECTOR3 vRugLoc(((g_fRoomWidthX - fRugWidth) / 2.0f), g_fFudge, ((g_fRoomDepthZ - fRugDepth) / 2.0f));
    D3DXVECTOR3 vRugSize(fRugWidth, 0, fRugDepth);

    // PowerSocket
    float fPowerWidth = 2.5f;
    float fPowerHeight = (fPowerWidth * (m_pMain->GetGlobalTexture(ITEM_POWEROUTLET, &fScale))->GetSurfaceRatio());            // This will cause one object to be above another.
    D3DXVECTOR3 vPowerLoc(((g_fRoomWidthX - fPowerWidth) / 2.0f), 5.00f, (g_fRoomDepthZ - g_fFudge));
    D3DXVECTOR3 vPowerSize(fPowerWidth, fPowerHeight, 0.0f);

    // Texture Coords
    CTexture * pTexture = m_pMain->GetGlobalTexture(ITEM_WALLPAPER, &fScale);
    float fTSWallpaperX = (TEXTURESCALE_WALLPAPER * fScale);     // How many repeats per 1 unit.
    float fTSWallpaperY = fTSWallpaperX * pTexture->GetSurfaceRatio();

    CTexture * pFloorTexture = m_pMain->GetGlobalTexture(ITEM_FLOOR, &fScale);
    float fTSFloorX = (TEXTURESCALE_FLOOR * fScale);     // How many repeats per 1 unit.
    float fTSFloorY = fTSFloorX * pFloorTexture->GetSurfaceRatio();

    CTexture * pToeGuardTexture = m_pMain->GetGlobalTexture(ITEM_TOEGUARD, &fScale);
    float fTSToeGuardX = (TEXTURESCALE_TOEGUARD * fScale);     // How many repeats per 1 unit.
    float fTSToeGuardY = fTSToeGuardX * pToeGuardTexture->GetSurfaceRatio();

    CTexture * pCeilingTexture = m_pMain->GetGlobalTexture(ITEM_CEILING, &fScale);
    float fTSCeilingX = (TEXTURESCALE_CEILING * fScale);     // How many repeats per 1 unit.
    float fTSCeilingY = fTSCeilingX * pCeilingTexture->GetSurfaceRatio();

    // Draw Floor
    D3DXVECTOR3 vLocation(0.00f, 0.00f, 0.00f);
    D3DXVECTOR3 vSize(g_fRoomWidthX, 0.00f, g_fRoomDepthZ);
    hr = m_objFloor.InitPlane(pFloorTexture, m_pMain->GetD3DDevice(), vLocation, vSize, vNormalFloor, 2, 2, fTSFloorY, fTSFloorX, 0, 10);


    // Draw Wall 1 (Facing Wall)
    vLocation = D3DXVECTOR3(0.00f, 0.00f, g_fRoomDepthZ);
    vSize = D3DXVECTOR3(g_fRoomWidthX, g_fRoomHeightY, 0.00f);
    hr = m_objWall1.InitPlane(pTexture, m_pMain->GetD3DDevice(), vLocation, vSize, vNormalWall1, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);

    // Draw ToeGuard 1
    vLocation = D3DXVECTOR3(0.00f, 0.00f, g_fRoomDepthZ-g_fFudge);
    vSize = D3DXVECTOR3(g_fRoomWidthX, fYToeGuard, 0.00f);
    hr = m_objToeGuard1.InitPlane(pToeGuardTexture, m_pMain->GetD3DDevice(), vLocation, vSize, vNormalWall1, 2, 2, fTSToeGuardY, fTSToeGuardX, 0, 0);


    // Draw Wall 2 (Right wall)
    vLocation = D3DXVECTOR3(g_fRoomWidthX, 0.00f, 0.00f);
    hr = _AddWall((NULL != m_pRightRoom), vLocation, D3DXVECTOR3(0.0f, 0.0f, 1.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), vNormalWall2, g_fRoomHeightY,
                            DOOR_HEIGHT, g_fRoomDepthZ, DOOR_WIDTH, WALL_WIDTHBEFOREDOOR);


    // Draw Wall 3 (Back Wall)
    vLocation = D3DXVECTOR3(0.00f, 0.00f, 0.00f);
    hr = _AddWall(FALSE, vLocation, D3DXVECTOR3(1.0f, 0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), vNormalWall3, g_fRoomHeightY,
                            DOOR_HEIGHT, g_fRoomWidthX, DOOR_WIDTH, ((g_fRoomWidthX - DOOR_WIDTH) / 2.0f));


    // Draw Wall 4 (Left Wall)
    vLocation = D3DXVECTOR3(0.00f, 0.00f, 0.00f);
    hr = _AddWall((NULL != m_pLeftRoom), vLocation, D3DXVECTOR3(0.0f, 0.0f, 1.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), vNormalWall4, g_fRoomHeightY,
                        DOOR_HEIGHT, g_fRoomDepthZ, DOOR_WIDTH, WALL_WIDTHBEFOREDOOR);

    // Draw Ceiling
    vLocation = D3DXVECTOR3(0.00f, g_fRoomHeightY, 0.00f);
    vSize = D3DXVECTOR3(g_fRoomWidthX, 0.00f, g_fRoomDepthZ);
    hr = m_objCeiling.InitPlane(pCeilingTexture, m_pMain->GetD3DDevice(), vLocation, vSize, vNormalCeiling, 2, 2, fTSCeilingY, fTSCeilingX, 0, 10);
    

    // Room Items (Rug, Power Sockets, Benches)
    hr = m_theRug.InitPlaneStretch(m_pMain->GetGlobalTexture(ITEM_RUG, &fScale), m_pMain->GetD3DDevice(), vRugLoc, vRugSize, vNormalFloor, 2, 2, dwRugMaxPixelSize);

    if (m_fLobby)
    {
        hr = _CreateLobbySign();
    }
    else
    {
        // We don't want a powerplug in the lobby.
        hr = m_thePowerSocket.InitPlaneStretch(m_pMain->GetGlobalTexture(ITEM_POWEROUTLET, &fScale), m_pMain->GetD3DDevice(), vPowerLoc, vPowerSize, vNormalWall1, 2, 2, 0);
    }

    hr = _SetRotationMatrix();

    m_fWalls = TRUE;

    return hr;
}


//-----------------------------------------------------------------------------
// Name: OneTimeSceneInit()
// Desc: Called during initial app startup, this function performs all the
//       permanent initialization.
//-----------------------------------------------------------------------------
HRESULT CTheRoom::OneTimeSceneInit(int nFutureRooms, BOOL fLowPriority)
{
    HRESULT hr = S_OK;

    m_fLowPriority = fLowPriority;
    if (!m_fRoomCreated)
    {
//        assert(!m_pFirstRoom);      // This will cause a leak
//        ASSERT(!m_pLeftRoom);       //, TEXT("This will cause a leak"));
//        ASSERT(!m_pRightRoom);      // , TEXT("This will cause a leak"));

        if (m_pFloorPlan->nEnterDoor == 0)
        {
            IUnknown_Set((IUnknown **) &m_pFirstRoom, m_pEnterRoom);
        }
        else
        {
            if (m_pFloorPlan->fDoor0)
            {
                m_pFirstRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
                if (!m_pFirstRoom)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (m_pFloorPlan->nEnterDoor == 1)
        {
            IUnknown_Set((IUnknown **) &m_pLeftRoom, m_pEnterRoom);
        }
        else
        {
            if (m_pFloorPlan->fDoor1)
            {
                m_pLeftRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
                if (!m_pLeftRoom)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (m_pFloorPlan->nEnterDoor == 2)
        {
            IUnknown_Set((IUnknown **) &m_pRightRoom, m_pEnterRoom);
        }
        else
        {
            if (m_pFloorPlan->fDoor2)
            {
                m_pRightRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
                if (!m_pRightRoom)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (SUCCEEDED(hr) &&
            (m_pFirstRoom || m_pLeftRoom || m_pRightRoom))
        {
            hr = _CreateRoom();
            if (!m_fLobby && !g_fFirstFrame)
            {
                _InitPaintings();
            }

            if (SUCCEEDED(hr))
            {
                m_fVisible = TRUE;       // We have children to render.
                m_fRoomCreated = TRUE;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr) && (nFutureRooms > 0))
    {
        if (m_pLeftRoom)
        {
            hr = m_pLeftRoom->OneTimeSceneInit(nFutureRooms-1, FALSE);
        }
        if (SUCCEEDED(hr) && m_pRightRoom)
        {
            hr = m_pRightRoom->OneTimeSceneInit(nFutureRooms-1, FALSE);
        }  // TODO: Need first room?
    }

    return hr;
}


HRESULT CTheRoom::FreePictures(int nMaxBatch)
{
    HRESULT hr = S_OK;

    if (-1 == nMaxBatch)
    {
        nMaxBatch = m_nBatch;
    }

    if (nMaxBatch >= m_nBatch)
    {
        if (g_pPictureMgr)
        {
            g_pPictureMgr->ReleaseBatch(m_nBatch);
            m_nBatch = 0;
        }

        // Free our paintings
        for (int nIndex = 0; (nIndex < ARRAYSIZE(m_pPaintings)); nIndex++)
        {
            SAFE_DELETE(m_pPaintings[nIndex]);
        }

        if (m_pFloorPlan)
        {
            if (m_pFirstRoom && (m_pFirstRoom != m_pEnterRoom) &&
                (!m_fCurrentRoom || (0 != m_pFloorPlan->nExitDoor)))
            {
                hr = m_pFirstRoom->FreePictures(nMaxBatch);
            }

            if (m_pLeftRoom && (m_pLeftRoom != m_pEnterRoom) &&
                (!m_fCurrentRoom || (1 != m_pFloorPlan->nExitDoor)))
            {
                hr = m_pLeftRoom->FreePictures(nMaxBatch);
            }

            if (m_pRightRoom && (m_pRightRoom != m_pEnterRoom) &&
                (!m_fCurrentRoom || (2 != m_pFloorPlan->nExitDoor)))
            {
                hr = m_pRightRoom->FreePictures(nMaxBatch);
            }
        }
    }

    return hr;
}


HRESULT CTheRoom::SetCurrent(BOOL fCurrent)
{
    HRESULT hr = S_OK;

    m_fCurrentRoom = fCurrent;
    if (fCurrent)
    {
        if (m_pFirstRoom)
        {
            hr = m_pFirstRoom->OneTimeSceneInit(1, TRUE);
        }

        if (m_pLeftRoom)
        {
            hr = m_pLeftRoom->OneTimeSceneInit(1, TRUE);
        }

        if (m_pRightRoom)
        {
            hr = m_pRightRoom->OneTimeSceneInit(1, TRUE);
        }

        m_fVisible = TRUE;
    }
    else
    {
    }

    return hr;
}


HRESULT CTheRoom::GetNextRoom(CTheRoom ** ppNextRoom)
{
    // This function does two things:
    // 1. Gives the caller a pointer to our next room, and
    // 2. Changes the order so we free rooms we will no longer need.
    // We want to take this opportunity to free our other rooms in case we come back into this room.
    // TODO: Regen other rooms.  Use Ref-counting with SetSite(NULL) in order to track memory correctly.

    // We would need to re-generate m_pFloorPlan that has the same enter door as our exit door
    // with the same floor plan if we want to walk into previous rooms.
    switch (m_pFloorPlan->nExitDoor)
    {
    case 0: // Enter door
        IUnknown_Set((IUnknown **) ppNextRoom, m_pFirstRoom);
        IUnknown_Set((IUnknown **) &m_pEnterRoom, m_pFirstRoom);
        break;
    case 1: // Left door
        IUnknown_Set((IUnknown **) ppNextRoom, m_pLeftRoom);
        IUnknown_Set((IUnknown **) &m_pEnterRoom, m_pLeftRoom);
        break;
    case 2: // Right door
        IUnknown_Set((IUnknown **) ppNextRoom, m_pRightRoom);
        IUnknown_Set((IUnknown **) &m_pEnterRoom, m_pRightRoom);
        break;
    };

    BOOL fReEnter = ((ppNextRoom && *ppNextRoom) ? ((*ppNextRoom)->GetEnterDoor() == (*ppNextRoom)->GetExitDoor()) : FALSE);

    if (m_pFirstRoom != m_pEnterRoom)
    {
        if (m_pFirstRoom) m_pFirstRoom->FinalCleanup();
        SAFE_RELEASE(m_pFirstRoom);

        if (fReEnter)
        {
            m_pFirstRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
        }
    }

    if (m_pLeftRoom != m_pEnterRoom)
    {
        if (m_pLeftRoom) m_pLeftRoom->FinalCleanup();
        SAFE_RELEASE(m_pLeftRoom);

        if (fReEnter)
        {
            m_pLeftRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
        }
    }

    if (m_pRightRoom != m_pEnterRoom)
    {
        if (m_pRightRoom) m_pRightRoom->FinalCleanup();
        SAFE_RELEASE(m_pRightRoom);

        if (fReEnter)
        {
            m_pRightRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
        }
    }

    return (*ppNextRoom ? S_OK : E_FAIL);
}


//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
HRESULT CTheRoom::FinalCleanup(void)
{
    // This is where we break all the circular ref-counts
    if (m_pFirstRoom && (m_pEnterRoom != m_pFirstRoom))  m_pFirstRoom->FinalCleanup();
    if (m_pLeftRoom && (m_pEnterRoom != m_pLeftRoom))  m_pLeftRoom->FinalCleanup();
    if (m_pRightRoom && (m_pEnterRoom != m_pRightRoom))  m_pRightRoom->FinalCleanup();

    SAFE_RELEASE(m_pEnterRoom);
    SAFE_RELEASE(m_pFirstRoom);
    SAFE_RELEASE(m_pLeftRoom);
    SAFE_RELEASE(m_pRightRoom);

    m_theRug.FinalCleanup();
    m_thePowerSocket.FinalCleanup();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
HRESULT CTheRoom::DeleteDeviceObjects(void)
{
    m_theRug.DeleteDeviceObjects();
    m_thePowerSocket.DeleteDeviceObjects();

    return S_OK;
}


#define ABS(i)  (((i) < 0) ? -(i) : (i))


HRESULT CTheRoom::_RenderThisRoom(IDirect3DDevice8 * pD3DDevice, int nRenderPhase, BOOL fFrontToBack)
{
    HRESULT hr = S_OK;
    DWORD dwTesting = 0;

    switch (nRenderPhase)
    {
        case 0:         // Wallpaper
        if (m_fWalls)
        {
            hr = m_objWall1.Render(pD3DDevice);
        }
        break;

        case 1:
        if (m_fFloor)
        {
            hr = m_objFloor.Render(pD3DDevice);
        }
        break;


        case 2:
        if (m_fToeGuard)
        {
    //        pD3DDevice->SetRenderState(D3DRS_ZBIAS, 12);   // Force the ToeGuard to appear above the wallpaper.
            hr = m_objToeGuard1.Render(pD3DDevice);
        }
        break;

        case 3:         // Frames
        case 4:         // Pictures. (Here's where we blow the cache)
        if (m_fPaintings)
        {
            if (m_fLobby)
            {
                // TODO: Paint lobby sign. (user name)  Anything created in _CreateLobbySign().
            }
            else
            {
//        pD3DDevice->SetRenderState(D3DRS_ZBIAS, 13);
                if (!m_pPaintings[0] && m_fVisible && !g_fFirstFrame)      // Did the background thread not yet have any pictures for us?
                {
                    hr = _InitPaintings();      // If so, see if they have anything yet?
                }

                for (int nIndex = ARRAYSIZE(m_pPaintings)-1; m_fVisible && (nIndex >= 0); nIndex--)
                {
                    if (m_pPaintings[nIndex])       // May be NULL if out of memory or in lobby.
                    {
                        // We use fFrontToBack because we always want to render the frame first.  This way
                        // the painting is always painted on top.  We don't worry about blowing the texture
                        // cache on the video card because since we will render so many paintings and change
                        // the paintings we render so often, the cache will almost be certainly blown anyway.
                        // We always want 0 rendered first.
                        if (fFrontToBack)
                        {
                            m_pPaintings[nIndex]->Render(pD3DDevice, nRenderPhase-3);
                        }
                        else
                        {
                            m_pPaintings[nIndex]->Render(pD3DDevice, ((4 == nRenderPhase) ? 0 : 1));
                        }
                    }
                }
            }
        }
        break;

        case 5:
        if (m_fPower)
        {
//        pD3DDevice->SetRenderState(D3DRS_ZBIAS, 11);
            m_thePowerSocket.Render(pD3DDevice);
        }
        break;

        case 6:
        if (m_fRug)
        {
//        pD3DDevice->SetRenderState(D3DRS_ZBIAS, 10);
            m_theRug.Render(pD3DDevice);
        }
        break;

        case 7:
        if (m_fCeiling)
        {
            hr = m_objCeiling.Render(pD3DDevice);
        }
        break;
    }

    return hr;
}


//#define COLOR_DOORFRAME_GRAY        D3DXCOLOR(0.78f, 0.78f, 0.78f, 1.0f)
#define COLOR_DOORFRAME_GRAY        D3DXCOLOR(0.28f, 0.28f, 0.28f, 1.0f)

BOOL CTheRoom::_IsRoomVisible(IDirect3DDevice8 * pD3DDevice, int nRoomNumber)
{
    D3DXVECTOR3 vMin;
    D3DXVECTOR3 vMax;
    D3DXMATRIX matWorld;
    pD3DDevice->GetTransform(D3DTS_WORLD, &matWorld);

    switch (nRoomNumber)
    {
    case 0:             // First Door.
        return FALSE; // we never look back at the first door

    case 1:             // Left Door.
        vMin = D3DXVECTOR3( 0, 0, WALL_WIDTHBEFOREDOOR );
        vMax = D3DXVECTOR3( 0, DOOR_HEIGHT, WALL_WIDTHBEFOREDOOR + DOOR_WIDTH );
        return Is3DRectViewable( m_pMain->PCullInfo(), &matWorld, vMin, vMax );

    case 2:            // Right Door
        vMin = D3DXVECTOR3( g_fRoomWidthX, 0, WALL_WIDTHBEFOREDOOR );
        vMax = D3DXVECTOR3( g_fRoomWidthX, DOOR_HEIGHT, WALL_WIDTHBEFOREDOOR + DOOR_WIDTH );
        return Is3DRectViewable( m_pMain->PCullInfo(), &matWorld, vMin, vMax );

    default:
        return FALSE;
    }
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CTheRoom::Render(IDirect3DDevice8 * pD3DDevice, int nRenderPhase, BOOL fFrontToBack)
{
    HRESULT hr;
    DWORD dwTesting = 0;

    // Draw the obstacles
    D3DMATERIAL8 mtrl = {0};
    mtrl.Ambient.r = mtrl.Specular.r = mtrl.Diffuse.r = 1.0f;
    mtrl.Ambient.g = mtrl.Specular.g = mtrl.Diffuse.g = 1.0f;
    mtrl.Ambient.b = mtrl.Specular.b = mtrl.Diffuse.b = 1.0f;
    mtrl.Ambient.a = mtrl.Specular.a = mtrl.Diffuse.a = 1.0f;

    if (m_fCurrentRoom)
    {
//        DXUtil_Trace(TEXT("ROOM: m_nExitDoor=%d, m_pLeftRoom=%d, m_pRightRoom=%d\n"), m_pFloorPlan->nExitDoor, m_pLeftRoom, m_pRightRoom);
    }

    hr = pD3DDevice->SetMaterial(&mtrl);

    if (SUCCEEDED(hr) && m_fVisible && (m_pEnterRoom || m_pLeftRoom || m_pRightRoom))
    {
        // We really want to do hit testing here otherwise we are really wasting our time.
        D3DXMATRIX matPrevious;
        D3DXMATRIX matNext;

        hr = pD3DDevice->GetTransform(D3DTS_WORLD, &matPrevious);

        if (m_pEnterRoom && _IsRoomVisible(pD3DDevice, 0) &&
            (m_pEnterRoom != m_pFirstRoom))
        {
            D3DXMatrixMultiply(&matNext, &m_matFirstRoom, &matPrevious);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matNext);
            hr = m_pFirstRoom->Render(pD3DDevice, nRenderPhase, fFrontToBack);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matPrevious);
        }

        if (m_pLeftRoom && _IsRoomVisible(pD3DDevice, 1) &&
            (m_pEnterRoom != m_pLeftRoom))
        {
            D3DXMatrixMultiply(&matNext, &m_matLeftRoom, &matPrevious);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matNext);
            hr = m_pLeftRoom->Render(pD3DDevice, nRenderPhase, fFrontToBack);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matPrevious);
        }

        if (m_pRightRoom && _IsRoomVisible(pD3DDevice, 2) &&
            (m_pEnterRoom != m_pRightRoom))
        {
            D3DXMatrixMultiply(&matNext, &m_matRightRoom, &matPrevious);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matNext);
            hr = m_pRightRoom->Render(pD3DDevice, nRenderPhase, fFrontToBack);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matPrevious);
        }
    }

    hr = _RenderThisRoom(pD3DDevice, nRenderPhase, fFrontToBack);

    return hr;
}


#define DIST_TO_WALL_ON_ZOOM                10.0f

HRESULT CTheRoom::_AddPaintingToPaintingMovements(CCameraMove * ptheCamera, D3DXVECTOR3 vSourceLocIn, D3DXVECTOR3 vSourceTangentIn, 
                                                  D3DXVECTOR3 vPainting, D3DXVECTOR3 * pvDestDir, float fDest, D3DXVECTOR3 * pvDestTangent,
                                                  int nBatch)
{
    HRESULT hr = S_OK;
    float fDistToWall = 30.0f;
    float fZoomDistToWall = DIST_TO_WALL_ON_ZOOM;
    float fZoomDelta = (fDistToWall - fZoomDistToWall);
    BOOL fExitLeft = ((1 == m_pFloorPlan->nExitDoor) ? TRUE : FALSE);

    D3DXVECTOR3 vSourceLoc = vSourceLocIn;
    D3DXVECTOR3 vSourceTangent = vSourceTangentIn;
    D3DXVECTOR3 vDestLoc;
    D3DXVECTOR3 vDestTangent;

    // Move closer to the first painting so it's full screen
    vDestLoc = (vSourceLoc + (vPainting * fZoomDelta));
    vDestTangent = vSourceTangent;
    hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

    // Look at painting #1
    hr = ptheCamera->CreateNextWait(m_nBatch+3, nBatch);

    // Back up some and start moving to the next painting.
    vSourceLoc = vDestLoc;
    vSourceTangent = vDestTangent;
    vDestLoc = (vSourceLocIn + (*pvDestDir * (fDest * 0.5f)));
    vDestTangent = (*pvDestDir * fDest);
    hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

    // Now walk much closer to the next painting
    vSourceLoc = vDestLoc;
    vSourceTangent = vDestTangent;
    vDestLoc = (vSourceLocIn + (*pvDestDir * (fDest * 0.90f)));
    vDestTangent = vSourceTangent;
    hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

    // Now move close to the painting
    vSourceLoc = vDestLoc;
    vSourceTangent = vDestTangent;
    vDestLoc = (vSourceLocIn + (vPainting * fZoomDelta) + (*pvDestDir * fDest));
    vDestTangent = (vPainting * 5.0f) * 1000.0f;
    hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

    // Look at painting #2
    hr = ptheCamera->CreateNextWait(m_nBatch+3, nBatch);

    vSourceLoc = vDestLoc;
    vSourceTangent = vDestTangent = vPainting;
    vDestLoc = (vSourceLocIn + (*pvDestDir * fDest));
    hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

    *pvDestDir = vDestLoc;
    *pvDestTangent = vDestTangent;

    return hr;
}


HRESULT CTheRoom::_LongRoomEnterDoorMovements(CCameraMove * ptheCamera)
{
    HRESULT hr = S_OK;

    float fDistant = 5.0f;
    float fDistToWall = 30.0f;
    float fWalkHeight = 20.0f;

    D3DXVECTOR3 vSourceLoc((g_fRoomWidthX / 2.0f), fWalkHeight, 1.0f);
    D3DXVECTOR3 vSourceTangent(0.0f, 0.0f, fDistant);

    hr = ptheCamera->Init(vSourceLoc, vSourceTangent, D3DXVECTOR3(0.0f, 1.0f, 0.0f));
    if (SUCCEEDED(hr))
    {
        BOOL fExitLeft = ((1 == m_pFloorPlan->nExitDoor) ? TRUE : FALSE);

        // fExitLeft 1=Left
        D3DXVECTOR3 vDestLoc((fExitLeft ? fDistToWall : g_fRoomWidthX-fDistToWall), fWalkHeight, (g_fRoomDepthZ * (1.0f / 4.0f)));
        D3DXVECTOR3 vDestTangent((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
        hr = _AddPaintingToPaintingMovements(ptheCamera, vSourceLoc, vSourceTangent, D3DXVECTOR3((fExitLeft ? -1.0f : 1.0f), 0.0f, 0.0f),
                                &vDestLoc, (g_fRoomDepthZ * (1.0f / 4.0f)), &vDestTangent, 2);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? fDistant : -fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? g_fRoomWidthX-fDistToWall : fDistToWall), fWalkHeight, (g_fRoomDepthZ * (2.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        // If we removed this door, then let us look at the painting that took it's place.
        if (!m_pLeftRoom || !m_pRightRoom)
        {
            vSourceLoc = vDestLoc;
            vSourceTangent = vDestTangent;
            vDestLoc = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
            hr = _AddPaintingToPaintingMovements(ptheCamera, vSourceLoc, vSourceTangent, D3DXVECTOR3((fExitLeft ? 1.0f : -1.0f), 0.0f, 0.0f),
                                    &vDestLoc, (g_fRoomDepthZ * (1.0f / 4.0f)), &vDestTangent, 1);
        }
        else
        {
            vSourceLoc = vDestLoc;
            vSourceTangent = vDestTangent;
            vDestLoc = D3DXVECTOR3((fExitLeft ? g_fRoomWidthX-DIST_TO_WALL_ON_ZOOM : DIST_TO_WALL_ON_ZOOM), fWalkHeight, (g_fRoomDepthZ * (2.0f / 4.0f)));
            hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

            // Look at painting #3
            hr = ptheCamera->CreateNextWait(m_nBatch+3, 1);

            vSourceLoc = vDestLoc;
            vSourceTangent = vDestTangent;
            vDestTangent = D3DXVECTOR3((fExitLeft ? fDistant : -fDistant), 0.0f, fDistant);
            hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);
        }

        // Now, walk from this painting close up to the location of the next painting
        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? 2.0f : 1.0f) * (g_fRoomWidthX/3.0f), fWalkHeight, (g_fRoomDepthZ - fDistToWall));
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? -1.0f : 1.0f), 0.0f, 0.0f);
        hr = _AddPaintingToPaintingMovements(ptheCamera, vSourceLoc, vSourceTangent, D3DXVECTOR3(0.0f, 0.0f, 1.0f), 
                                &vDestLoc, (g_fRoomWidthX * (1.0f / 3.0f)), &vDestTangent, 1);

        // Turn toward the door while walking.
        vSourceLoc = vDestLoc;
        vSourceTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        vDestLoc = D3DXVECTOR3((fExitLeft ? 0.0f : g_fRoomWidthX), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        vDestTangent = D3DXVECTOR3((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
#define TURN_RATE           0.30f
        D3DXVECTOR3 vTemp;
        D3DXVec3Lerp(&vTemp, &vSourceLoc, &vDestLoc, TURN_RATE);        // We want to do our turn towards the door while walking.  We do it while walking 10% towards the door.
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vTemp, vDestTangent);
        vSourceLoc = vTemp;


        // Finish walking to and thru the exit door.
        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? 0.0f : g_fRoomWidthX), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);
    }

    return hr;
}


HRESULT CTheRoom::_LongRoomSideEnterLeaveMovements(CCameraMove * ptheCamera)
{
    HRESULT hr = S_OK;
    BOOL fExitLeft = ((1 == m_pFloorPlan->nExitDoor) ? TRUE : FALSE);

    float fDistant = 5.0f;
    float fDistToWall = 30.0f;
    float fWalkHeight = 20.0f;

    D3DXVECTOR3 vSourceLoc((fExitLeft ? g_fRoomWidthX : 0.0f), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
    D3DXVECTOR3 vSourceTangent((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);

    hr = ptheCamera->Init(vSourceLoc, vSourceTangent, D3DXVECTOR3(0.0f, 1.0f, 0.0f));
    if (SUCCEEDED(hr))
    {
        BOOL fExitLeft = ((1 == m_pFloorPlan->nExitDoor) ? TRUE : FALSE);

        // fExitLeft 1=Left
        D3DXVECTOR3 vDestLoc((fExitLeft ? g_fRoomWidthX-fDistToWall : fDistToWall), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        D3DXVECTOR3 vDestTangent((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, -fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? g_fRoomWidthX-fDistToWall : fDistToWall), fWalkHeight, (g_fRoomDepthZ * (3.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? fDistant : -fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        // Look at painting #1
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 2);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, -fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? g_fRoomWidthX-fDistToWall : fDistToWall), fWalkHeight, (g_fRoomDepthZ * (2.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? fDistant : -fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        // Look at painting #2
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 2);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, -fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? g_fRoomWidthX-fDistToWall : fDistToWall), fWalkHeight, (g_fRoomDepthZ * (1.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? fDistant : -fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        // Look at painting #3
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 1);

        // Now do the 180 degree turn around
        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, (GetRandomInt(0, 1) ? -fDistant : fDistant));
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? fDistToWall : g_fRoomWidthX-fDistToWall), fWalkHeight, (g_fRoomDepthZ * (1.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        // Look at painting #4 (Front Wall #1)
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 1);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? fDistToWall : g_fRoomWidthX-fDistToWall), fWalkHeight, (g_fRoomDepthZ * (2.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        // Look at painting #5 (Front Wall #2)
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 1);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? fDistToWall : g_fRoomWidthX-fDistToWall), fWalkHeight, (g_fRoomDepthZ * (3.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        // Look at painting #6 (Front Wall #2)
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 1);

        // Walk towards the door
        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? fDistToWall : g_fRoomWidthX-fDistToWall), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        // Now leave the room.
        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? 0.0f : g_fRoomWidthX), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);
    }

    return hr;
}


HRESULT CTheRoom::LoadCameraMoves(CCameraMove * ptheCamera)
{   // TODO: We need to change this based on the room shape and the door entered.
    HRESULT hr = S_OK;

    if (m_fLobby)
    {
        hr = _LoadLobbyPath(ptheCamera);
    }
    else
    {
        switch (m_pFloorPlan->nMovementPattern)
        {
        case 0:
            hr = _LongRoomEnterDoorMovements(ptheCamera);
            break;
        case 1:
            hr = _LongRoomSideEnterLeaveMovements(ptheCamera);
            break;
        }
    }

    return hr;
}


HRESULT CTheRoom::_LoadLobbyPath(CCameraMove * ptheCamera)
{
    HRESULT hr = S_OK;

    float fDistant = 5.0f;
    float fDistToWall = 30.0f;
    float fWalkHeight = 20.0f;

    D3DXVECTOR3 vSourceLoc((g_fRoomWidthX / 2.0f), fWalkHeight, 1.0f);
    D3DXVECTOR3 vSourceTangent(0.0f, 0.0f, fDistant);

    hr = ptheCamera->Init(vSourceLoc, vSourceTangent, D3DXVECTOR3(0.0f, 1.0f, 0.0f));
    if (SUCCEEDED(hr))
    {
        // Walk down the middle of the room.
        D3DXVECTOR3 vDestLoc((g_fRoomWidthX / 2.0f), fWalkHeight, (g_fRoomDepthZ * (2.0f / 4.0f)));
        D3DXVECTOR3 vDestTangent(0.0f, 0.0f, 1.0f);
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        // Now start walking toward the door.
        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;

        // 1=Left
        vDestTangent = D3DXVECTOR3(((1 == m_pFloorPlan->nExitDoor) ? -1.0f : 1.0f), 0.0f, 0.0f);
        vDestLoc = D3DXVECTOR3(((1 == m_pFloorPlan->nExitDoor) ? 0.0f : g_fRoomWidthX), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);
    }

    return hr;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CTheRoom::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CTheRoom::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CTheRoom::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTheRoom, IUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}



int CTheRoom::GetEnterDoor(void)
{
    int nDoor = 0;

    if (m_pFloorPlan)
    {
        nDoor = m_pFloorPlan->nEnterDoor;
    }

    return nDoor;
}


int CTheRoom::GetExitDoor(void)
{
    int nDoor = 0;

    if (m_pFloorPlan)
    {
        nDoor = m_pFloorPlan->nExitDoor;
    }

    return nDoor;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\pictures.cpp ===
/*****************************************************************************\
    FILE: pictures.cpp

    DESCRIPTION:
        Manage the pictures in the user's directories.  Convert them when needed.
    Handle caching and making sure we don't use too much diskspace.  Also add
    picture frame when needed.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include <shlobj.h>
#include "pictures.h"
#include "util.h"


#undef __IShellFolder2_FWD_DEFINED__

#include <ccstock.h>




CPictureManager * g_pPictureMgr = NULL;



int CALLBACK DSACallback_FreePainting(LPVOID p, LPVOID pData)
{
    SSPICTURE_INFO * pPInfo = (SSPICTURE_INFO *) p;

    if (pPInfo)
    {
        Str_SetPtr(&pPInfo->pszPath, NULL);
    }

    return 1;
}


CPictureManager::CPictureManager(CMSLogoDXScreenSaver * pMain)
{
    m_nCurrent = 0;
    m_hdsaPictures = NULL;

    m_pMain = pMain;

    m_hdsaBatches = 0;
    m_nCurrentBatch = 0;

    _EnumPaintings();
}


CPictureManager::~CPictureManager()
{
    if (m_hdsaBatches)
    {
        DSA_Destroy(m_hdsaBatches);
        m_hdsaBatches = NULL;
    }

    if (m_hdsaPictures)
    {
        DSA_DestroyCallback(m_hdsaPictures, DSACallback_FreePainting, NULL);
        m_hdsaPictures = NULL;
    }

    m_pMain = NULL;
}




HRESULT CPictureManager::_PInfoCreate(int nIndex, LPCTSTR pszPath)
{
    HRESULT hr = S_OK;
    SSPICTURE_INFO pInfo = {0};

    pInfo.fInABatch = FALSE;
    pInfo.pszPath = NULL;
    Str_SetPtr(&pInfo.pszPath, pszPath);

    // We add them in a random order so the pattern doesn't get boring.
    if (-1 == DSA_InsertItem(m_hdsaPictures, nIndex, &pInfo))
    {
        // We failed so free the memory
        Str_SetPtr(&pInfo.pszPath, NULL);
        hr = E_OUTOFMEMORY;
    }

    return S_OK;
}


HRESULT CPictureManager::_AddPaintingsFromDir(LPCTSTR pszPath)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (!m_hdsaPictures)
    {
        m_hdsaPictures = DSA_Create(sizeof(SSPICTURE_INFO), 20);
    }

    if (m_hdsaPictures)
    {
        TCHAR szSearch[MAX_PATH];
        WIN32_FIND_DATA findFileData;

        hr = S_OK;
        StrCpyN(szSearch, pszPath, ARRAYSIZE(szSearch));
        PathAppend(szSearch, TEXT("*.*"));
        HANDLE hFindFiles = FindFirstFile(szSearch, &findFileData);
        if (INVALID_HANDLE_VALUE != hFindFiles)
        {
            while ((INVALID_HANDLE_VALUE != hFindFiles))
            {
                if (!PathIsDotOrDotDot(findFileData.cFileName))
                {
                    if (!(FILE_ATTRIBUTE_DIRECTORY & findFileData.dwFileAttributes))
                    {
                        LPCTSTR pszExt = PathFindExtension(findFileData.cFileName);

                        if (pszExt && pszExt[0] &&
                            (!StrCmpI(pszExt, TEXT(".bmp"))
                              || !StrCmpI(pszExt, TEXT(".jpg"))
                              || !StrCmpI(pszExt, TEXT(".jpeg"))
                              || !StrCmpI(pszExt, TEXT(".png"))
//                              || !StrCmpI(pszExt, TEXT(".gif"))
                              || !StrCmpI(pszExt, TEXT(".tiff"))
                            ))
                        {
                            int nInsertLoc = GetRandomInt(0, max(0, DSA_GetItemCount(m_hdsaPictures) - 1));

                            StrCpyN(szSearch, pszPath, ARRAYSIZE(szSearch));
                            PathAppend(szSearch, findFileData.cFileName);

                            hr = _PInfoCreate(nInsertLoc, szSearch);
                        }
                    }
                    else
                    {
                        StrCpyN(szSearch, pszPath, ARRAYSIZE(szSearch));
                        PathAppend(szSearch, findFileData.cFileName);
                        hr = _AddPaintingsFromDir(szSearch);
                    }
                }

                if (!FindNextFile(hFindFiles, &findFileData))
                {
                    break;
                }
            }

            FindClose(hFindFiles);
        }
    }

    return hr;
}


HRESULT CPictureManager::_EnumPaintings(void)
{
    HRESULT hr = E_FAIL;
    TCHAR szDir[MAX_PATH];

    if (g_pConfig)
    {
        hr = S_OK;
        if (g_pConfig->GetFolderOn(CONFIG_FOLDER_MYPICTS) &&
            SHGetSpecialFolderPath(NULL, szDir, CSIDL_MYPICTURES, TRUE))
        {
            hr = _AddPaintingsFromDir(szDir);
        }

        if (g_pConfig->GetFolderOn(CONFIG_FOLDER_COMMONPICTS))
        {
            // TODO: When Common Pictures are added.
        }

        if (g_pConfig->GetFolderOn(CONFIG_FOLDER_OTHER) &&
            SUCCEEDED(g_pConfig->GetOtherDir(szDir, ARRAYSIZE(szDir))))
        {
            hr = _AddPaintingsFromDir(szDir);
        }

        // If we have less than 10 paintings, then we force add the
        // Windows wallpapers.
        if ((g_pConfig->GetFolderOn(CONFIG_FOLDER_WINPICTS) ||
            (10 > DSA_GetItemCount(m_hdsaPictures))) &&
            SHGetSpecialFolderPath(NULL, szDir, CSIDL_WINDOWS, TRUE))
        {
            PathAppend(szDir, TEXT("Web\\Wallpaper"));
            hr = _AddPaintingsFromDir(szDir);
        }

        if (m_hdsaPictures)
        {
            m_nCurrent = GetRandomInt(0, max(0, DSA_GetItemCount(m_hdsaPictures) - 1));
        }
    }

    return hr;
}


HRESULT CPictureManager::_LoadTexture(SSPICTURE_INFO * pInfo, BOOL fFaultInTexture)
{
    // We keep trying until we hit the end.  We give up after that.
    HRESULT hr = E_INVALIDARG;

    if (pInfo)
    {
        if (!pInfo->pTexture)
        {
            pInfo->pTexture = new CTexture(m_pMain, pInfo->pszPath, NULL, 1.0f);
        }

        hr = (pInfo->pTexture ? S_OK : E_OUTOFMEMORY);

        if (pInfo->pTexture && fFaultInTexture)
        {
            pInfo->pTexture->GetTexture(NULL);  // Force the image to be paged in.
        }
    }

    return hr;
}


#define GNPF_NONE           0x00000000
#define GNPF_ALREADYLOADED  0x00000001
#define GNPF_FAULTINTEXTURE 0x00000002
#define GNPF_ALLOWALREADYINBATCH 0x00000004

HRESULT CPictureManager::_TryGetNextPainting(SSPICTURE_INFO ** ppInfo, DWORD dwFlags)
{
    // We keep trying until we hit the end.  We give up after that.
    HRESULT hr = E_FAIL;

    while (m_hdsaPictures &&
            FAILED(hr) && (m_nCurrent < DSA_GetItemCount(m_hdsaPictures)))
    {
        SSPICTURE_INFO * pPInfo = (SSPICTURE_INFO *) DSA_GetItemPtr(m_hdsaPictures, m_nCurrent);

        if (pPInfo && pPInfo->pszPath)
        {
            if (!pPInfo->fInABatch || (dwFlags & GNPF_ALLOWALREADYINBATCH))
            {
                if (dwFlags & GNPF_ALREADYLOADED)
                {
                    if (pPInfo->pTexture && pPInfo->pTexture->IsLoadedInAnyDevice())
                    {
                        // The caller only wants an object that's already pre-fetched, and we just found one.
                        *ppInfo = pPInfo;
                        pPInfo->fInABatch = TRUE;
                        hr = S_OK;
                    }
                }
                else
                {
                    // The caller is happen to this now.  We only get this far if we failed to load it.
                    hr = _LoadTexture(pPInfo, (dwFlags & GNPF_FAULTINTEXTURE));
                    if (SUCCEEDED(hr))
                    {
                        *ppInfo = pPInfo;
                        pPInfo->fInABatch = TRUE;
                    }
                }
            }
        }

        m_nCurrent++;
    }

    return hr;
}


HRESULT CPictureManager::_GetNextWithWrap(SSPICTURE_INFO ** ppInfo, BOOL fAlreadyLoaded, BOOL fFaultInTexture)
{
    DWORD dwFlags = ((fAlreadyLoaded ? GNPF_ALREADYLOADED : GNPF_NONE) | (fFaultInTexture ? GNPF_FAULTINTEXTURE : GNPF_NONE));

    *ppInfo = NULL;
    HRESULT hr = _TryGetNextPainting(ppInfo, dwFlags);

    if (m_nCurrent >= DSA_GetItemCount(m_hdsaPictures))
    {
        m_nCurrent = 0;
        if (FAILED(hr))
        {
            // Maybe it was necessary to wrap.  We don't loop to prevent infinite recursion in corner cases.
            hr = _TryGetNextPainting(ppInfo, dwFlags);
            if (FAILED(hr))
            {
                // Maybe we have so few paintings available that we need to reuse.
                m_nCurrent = 0;
                hr = _TryGetNextPainting(ppInfo, (dwFlags | GNPF_ALLOWALREADYINBATCH));
            }
        }
    }

    if (SUCCEEDED(hr) && (10 < DSA_GetItemCount(m_hdsaPictures)) &&
            (1 == GetRandomInt(0, 4)))
    {
        // There is a one in for chance we want to skip pictures.  This will keep the order somewhat random
        // while still not always going in the same order.  We only do this if the user has more than 10
        // pictures or it may lap and the user will have the same picture twice in the same room.
        m_nCurrent += GetRandomInt(1, 5);
        if (m_nCurrent >= DSA_GetItemCount(m_hdsaPictures))
        {
            m_nCurrent = 0;
        }
    }

    return hr;
}


HRESULT CPictureManager::_CreateNewBatch(int nBatch, BOOL fFaultInTexture)
{
    HRESULT hr = S_OK;
    SSPICTURES_BATCH batch = {0};
    int nIndex;

    for (nIndex = 0; (nIndex < ARRAYSIZE(batch.pInfo)) && SUCCEEDED(hr); nIndex++)
    {
        // First try and not get any dups
        hr = _GetNextWithWrap(&(batch.pInfo[nIndex]), FALSE, fFaultInTexture);
    }

    if (SUCCEEDED(hr))
    {
        if (-1 == DSA_AppendItem(m_hdsaBatches, &batch))
        {
            // We failed so free the memory
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}




///////////////////////////////////////////////////////////////////////
// FUNCTION: GetPainting
///////////////////////////////////////////////////////////////////////
HRESULT CPictureManager::GetPainting(int nBatch, int nIndex, DWORD dwFlags, CTexture ** ppTexture)
{
    HRESULT hr = E_FAIL;

    if (!m_hdsaBatches)
    {
        m_hdsaBatches = DSA_Create(sizeof(SSPICTURES_BATCH), 20);
    }

    m_nCurrentBatch = max(m_nCurrentBatch, nBatch);

    *ppTexture = NULL;
    if (m_hdsaPictures && m_hdsaBatches)
    {
        hr = S_OK;

        while ((nBatch >= DSA_GetItemCount(m_hdsaBatches)) && SUCCEEDED(hr))
        {
            hr = _CreateNewBatch(nBatch, TRUE);
        }

        if (SUCCEEDED(hr))
        {
            SSPICTURES_BATCH * pBatch = (SSPICTURES_BATCH *) DSA_GetItemPtr(m_hdsaBatches, nBatch);

            if (pBatch && ((void *)-1 != pBatch) && pBatch->pInfo[nIndex] && pBatch->pInfo[nIndex]->pTexture)
            {
                IUnknown_Set((IUnknown **) ppTexture, (IUnknown *) pBatch->pInfo[nIndex]->pTexture);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////
// FUNCTION: PreFetch
///////////////////////////////////////////////////////////////////////
HRESULT CPictureManager::PreFetch(int nBatch, int nToFetch)
{
    HRESULT hr = S_OK;

    while ((nBatch >= DSA_GetItemCount(m_hdsaBatches)) && SUCCEEDED(hr))
    {
        hr = _CreateNewBatch(nBatch, FALSE);
        if (FAILED(hr))
        {
            DXUtil_Trace(TEXT("ERROR: PreFetch() _CreateNewBatch failed.  nBatch=%d\n"), nBatch);
        }
    }

    SSPICTURES_BATCH * pBatch = (SSPICTURES_BATCH *) DSA_GetItemPtr(m_hdsaBatches, nBatch);

    if (pBatch && (nToFetch < ARRAYSIZE(pBatch->pInfo)))
    {
        int nIndex;

        for (nIndex = 0; (nIndex < ARRAYSIZE(pBatch->pInfo)) && nToFetch; nIndex++)
        {
            if (pBatch->pInfo[nIndex] && 
                (!pBatch->pInfo[nIndex]->pTexture ||
                 !pBatch->pInfo[nIndex]->pTexture->IsLoadedForThisDevice()))
            {
                hr = _LoadTexture(pBatch->pInfo[nIndex], TRUE);

                nToFetch--;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////
// FUNCTION: ReleaseBatch
///////////////////////////////////////////////////////////////////////
HRESULT CPictureManager::ReleaseBatch(int nBatch)
{
    HRESULT hr = E_INVALIDARG;

    for (int nIndex = 0; nIndex < nBatch; nIndex++)
    {
        SSPICTURES_BATCH * pBatch = (SSPICTURES_BATCH *) DSA_GetItemPtr(m_hdsaBatches, nIndex);

        for (int nIndex2 = 0; nIndex2 < ARRAYSIZE(pBatch->pInfo); nIndex2++)
        {
            if (pBatch && pBatch->pInfo[nIndex2] && (pBatch->pInfo[nIndex2]->fInABatch || pBatch->pInfo[nIndex2]->pTexture))
            {
                ReleaseBatch(nIndex);
                DXUtil_Trace(TEXT("ERROR: ReleaseBatch() and previous batch aren't released.  nBatch=%d, nIndex=%d\n"), nBatch, nIndex);
                break;
            }
        }
    }

    if (nBatch < m_nCurrentBatch)
    {
        SSPICTURES_BATCH * pBatch = (SSPICTURES_BATCH *) DSA_GetItemPtr(m_hdsaBatches, nBatch);

        if (pBatch && ((void *)-1 != pBatch))
        {
            hr = S_OK;
            for (int nIndex = 0; (nIndex < ARRAYSIZE(pBatch->pInfo)); nIndex++)
            {
                if (pBatch->pInfo[nIndex])
                {
                    SAFE_RELEASE(pBatch->pInfo[nIndex]->pTexture);
                    pBatch->pInfo[nIndex]->fInABatch = FALSE;
                    pBatch->pInfo[nIndex] = NULL;
                }
            }
        }
    }
    else
    {
        DXUtil_Trace(TEXT("ERROR: ReleaseBatch() and batch is bad.  nBatch=%d, m_nCurrentBatch=%d\n"), nBatch, m_nCurrentBatch);
        hr = E_UNEXPECTED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__706F9FE5_FCA6_11D2_A4B0_005004208000__INCLUDED_)
#define AFX_STDAFX_H__706F9FE5_FCA6_11D2_A4B0_005004208000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN       // Exclude rarely-used stuff from Windows headers
//#define STRICT
#define D3D_OVERLOADS




#include <windows.h>
#include <windowsx.h>

#undef __IShellFolder2_FWD_DEFINED__
#include <shlobj.h>
#include <shlwapi.h>

#include <mmsystem.h>
#include <math.h>
#include <time.h>


#include <d3d8.h>
#include <d3dx8.h>

#include <d3dsaver.h>
#include <d3d8rgbrast.h>
#include <util.h>
#include <..\D3DSaver\dxutil.h>



// Only use this feature if it speeds us up.
//#define FEATUER_USEVISIBILITY_CHECKING

#include "texture.h"




#endif // !defined(AFX_STDAFX_H__706F9FE5_FCA6_11D2_A4B0_005004208000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\room.h ===
/*****************************************************************************\
    FILE: room.h

    DESCRIPTION:

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/


#ifndef ROOM_H
#define ROOM_H

#include "util.h"
#include "main.h"
#include "painting.h"
#include "pictures.h"


#define WATER_COLOR          0x00008899



//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------

#define WALL_VECTORS                6
#define CEILING_VECTORS             4
#define FLOOR_VECTORS               4


#define DOORFRAME_DEPTH             1.0f
#define DOOR_HEIGHT                 30.0f
#define DOOR_WIDTH                  30.0f
#define WALL_WIDTHBEFOREDOOR        145.0f

#define TOEGUARD_HEIGHT             1.25f

// Smaller numbers make them appear larger.
#define TEXTURESCALE_WALLPAPER      0.6f        // 0.6f for 25x36 Orig, 0.3f for CDWallpaper 256x256.
#define TEXTURESCALE_TOEGUARD       0.6f        // 0.6f for 32x32.
#define TEXTURESCALE_CEILING        0.09f
#define TEXTURESCALE_FLOOR          0.05f       // 0.03f or 0.05f for Hardwoods (476x214), 0.09f for Tile (256x256)

#define DOOR_DISTANCETOFIRSTDOOR    0.6f

#define NUM_PAINTINGS               8

extern float g_fRoomWidthX;
extern float g_fRoomDepthZ;
extern float g_fRoomHeightY;
extern float g_fFudge;            // This will cause one object to be above another.



typedef struct
{
    D3DXVECTOR3 vLocation;
    D3DXVECTOR3 vNormal;
} PAINTING_LAYOUT;


typedef struct
{
    int nEnterDoor;
    int nExitDoor;
    int nMovementPattern;   // What pattern should be used in the user's movements?
    BOOL fDoor0;            // Does this door exist?
    BOOL fDoor1;            // Does this door exist?
    BOOL fDoor2;            // Does this door exist?
    int nPaintings;         // Number of PAINTING_LAYOUT in pPaintingsLayout.
    PAINTING_LAYOUT * pPaintingsLayout;
} ROOM_FLOORPLANS;




class CTheRoom          : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

public:
    HRESULT OneTimeSceneInit(int nFutureRooms, BOOL fLowPriority);
    HRESULT Render(IDirect3DDevice8 * lpDev, int nRenderPhase, BOOL fFrontToBack);
    HRESULT FinalCleanup(void);
    HRESULT DeleteDeviceObjects(void);
    HRESULT SetCurrent(BOOL fCurrent);
    HRESULT GetNextRoom(CTheRoom ** ppNextRoom);
    HRESULT LoadCameraMoves(CCameraMove * ptheCamera);
    HRESULT FreePictures(int nMaxBatch = -1);

    float GetDoorOffset(void) {return (g_fRoomWidthX / 2.0f);}       // This will return the distance between the new room's 0 coord and the middle of it's the enter door.
    int GetMaxRenderPhases(void) {return 8;};
    int GetEnterDoor(void);
    int GetExitDoor(void);

    CTheRoom(BOOL fLobby, CMSLogoDXScreenSaver * pMain, CTheRoom * pEnterRoom, int nBatch);
    virtual ~CTheRoom();

protected:
    int m_nBatch;

private:
    long m_cRef;

    D3DXMATRIX m_matIdentity;

    C3DObject m_objWall1;
    C3DObject m_objCeiling;
    C3DObject m_objToeGuard1;
    C3DObject m_objFloor;

    C3DObject m_theRug;
    C3DObject m_thePowerSocket;
    CPainting * m_pPaintings[NUM_PAINTINGS];

    BOOL m_fWalls;
    BOOL m_fToeGuard;
    BOOL m_fRug;
    BOOL m_fPower;
    BOOL m_fCeiling;
    BOOL m_fFloor;
    BOOL m_fPaintings;
    BOOL m_fLobby;

    BOOL m_fCurrentRoom;          // Current Room
    BOOL m_fVisible;
    BOOL m_fLowPriority;

    CMSLogoDXScreenSaver * m_pMain;         // Weak reference
    ROOM_FLOORPLANS * m_pFloorPlan;

    CTheRoom * m_pEnterRoom;                // Equal to m_pFirstRoom or m_pLeftRoom or m_pRightRoom
    CTheRoom * m_pFirstRoom;                // Thru Door 0
    CTheRoom * m_pLeftRoom;                 // Thru Door 1
    CTheRoom * m_pRightRoom;                // Thru Door 2
    D3DXMATRIX m_matFirstRoom;
    D3DXMATRIX m_matLeftRoom;
    D3DXMATRIX m_matRightRoom;

    BOOL m_fRoomCreated;

    // Functions:
    LPCTSTR _GetItemTexturePath(DWORD dwItem);
    HRESULT _InitPaintings(void);
    HRESULT _CreateRoom(void);
    HRESULT _AddWallWithDoor(C3DObject * pobjWall, C3DObject * pobjToeGuard, C3DObject * pobjFloor, D3DXVECTOR3 vLocation, D3DXVECTOR3 vWidth, D3DXVECTOR3 vHeight, D3DXVECTOR3 vNormal,
                                   float fTotalHeight, float fDoorHeight, float fTotalWidth, float fDoorWidth, float fDoorStart);
    HRESULT _RenderThisRoom(IDirect3DDevice8 * pD3DDevice, int nRenderPhase, BOOL fFrontToBack);
    HRESULT _SetRotationMatrix(void);
    HRESULT _LoadLobbyPath(CCameraMove * ptheCamera);
    HRESULT _CreateLobbySign(void);

    HRESULT _LongRoomEnterDoorMovements(CCameraMove * ptheCamera);
    HRESULT _LongRoomSideEnterLeaveMovements(CCameraMove * ptheCamera);

    BOOL _IsRoomVisible(IDirect3DDevice8 * pD3DDevice, int nRoomNumber);
    HRESULT _AddWall(BOOL fWithDoor, D3DXVECTOR3 vLocation, D3DXVECTOR3 vWidth, D3DXVECTOR3 vHeight, D3DXVECTOR3 vNormal,
                       float fTotalHeight, float fDoorHeight, float fTotalWidth, float fDoorWidth, float fDoorStart);
    HRESULT _AddPaintingToPaintingMovements(CCameraMove * ptheCamera, D3DXVECTOR3 vSourceLocIn, D3DXVECTOR3 vSourceTangentIn, 
                                                  D3DXVECTOR3 vPainting, D3DXVECTOR3 * pvDestDir, float fDest, D3DXVECTOR3 * pvDestTangent, int nBatch);

    friend CMSLogoDXScreenSaver;
};


#endif // ROOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\texture.cpp ===
/*****************************************************************************\
    FILE: texture.cpp

    DESCRIPTION:
        Manage a texture for several instance for each monitor.  Also manage keeping the
    ratio correct when it's not square when loaded.

    BryanSt 2/9/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include "texture.h"
#include "util.h"


int g_nTotalTexturesLoaded = 0;
int g_nTexturesRenderedInThisFrame = 0;


CTexture::CTexture(CMSLogoDXScreenSaver * pMain, LPCTSTR pszPath, LPVOID pvBits, DWORD cbSize)
{
    _Init(pMain);

    Str_SetPtr(&m_pszPath, pszPath);
    m_pvBits = pvBits;
    m_cbSize = cbSize;
}


CTexture::CTexture(CMSLogoDXScreenSaver * pMain, LPCTSTR pszPath, LPCTSTR pszResource, float fScale)
{
    _Init(pMain);
    Str_SetPtr(&m_pszPath, pszPath);
    Str_SetPtr(&m_pszResource, pszResource);
    m_fScale = fScale;
}


CTexture::~CTexture()
{
    Str_SetPtr(&m_pszResource, NULL);
    Str_SetPtr(&m_pszPath, NULL);
    if (m_pvBits)
    {
        LocalFree(m_pvBits);
        m_pvBits = NULL;
        m_cbSize = 0;
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pTexture); nIndex++)
    {
        if (m_pTexture[nIndex])
        {
            SAFE_RELEASE(m_pTexture[nIndex]);
            g_nTotalTexturesLoaded--;
        }
    }

    m_pMain = NULL;
}


void CTexture::_Init(CMSLogoDXScreenSaver * pMain)
{
    m_pszResource = NULL;
    m_fScale = 1.0f;
    m_pszPath = NULL;
    m_pvBits = NULL;
    m_cbSize = 0;

    m_dxImageInfo.Width = 0;
    m_dxImageInfo.Height = 0;
    m_dxImageInfo.Depth = 0;
    m_dxImageInfo.MipLevels = 0;
    m_dxImageInfo.Format = D3DFMT_UNKNOWN;

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pTexture); nIndex++)
    {
        m_pTexture[nIndex] = NULL;
    }

    m_cRef = 1;
    m_pMain = pMain;
}


BOOL CTexture::IsLoadedInAnyDevice(void)
{
    BOOL fIsLoaded = FALSE;

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pTexture); nIndex++)
    {
        if (m_pTexture[nIndex])
        {
            fIsLoaded = TRUE;
            break;
        }
    }

    return fIsLoaded;
}


BOOL CTexture::IsLoadedForThisDevice(void)
{
    BOOL fIsLoaded = FALSE;

    if (m_pMain)
    {
        int nCurrMonitor = m_pMain->GetCurrMonitorIndex();

        if (m_pTexture[nCurrMonitor])
        {
            fIsLoaded = TRUE;
        }
    }

    return fIsLoaded;
}


HRESULT CTexture::_GetPictureInfo(HRESULT hr, LPTSTR pszString, DWORD cchSize)
{
    int nCurrMonitor = m_pMain->GetCurrMonitorIndex();

    StrCpyN(pszString, TEXT("<NoInfo>"), cchSize);
    if (SUCCEEDED(hr) && m_pTexture[nCurrMonitor] && m_pMain)
    {
        D3DSURFACE_DESC d3dSurfaceDesc;

        if (SUCCEEDED(m_pTexture[nCurrMonitor]->GetLevelDesc(0, &d3dSurfaceDesc)))
        {
            wnsprintf(pszString, cchSize, TEXT("Size Orig=<%d,%d> Now=<%d,%d>"), 
                    m_dxImageInfo.Width, m_dxImageInfo.Height, d3dSurfaceDesc.Width, d3dSurfaceDesc.Height);
        }
    }

    return S_OK;
}


BOOL CTexture::_DoesImageNeedClipping(int * pnNewWidth, int * pnNewHeight)
{
    BOOL fClip = FALSE;

    *pnNewWidth = 512;
    *pnNewHeight = 512;
    if (m_pMain)
    {
        int nScreenWidth;
        int nScreenHeight;
        int nCurrMonitor = m_pMain->GetCurrMonitorIndex();
        D3DSURFACE_DESC d3dSurfaceDesc;

        if (FAILED(m_pMain->GetCurrentScreenSize(&nScreenWidth, &nScreenHeight)))
        {
            nScreenWidth = 800; // Fall back values
            nScreenHeight = 600;
        }

        if (!m_pTexture[nCurrMonitor] ||
            FAILED(m_pTexture[nCurrMonitor]->GetLevelDesc(0, &d3dSurfaceDesc)))
        {
            d3dSurfaceDesc.Width = 800;  // default values
            d3dSurfaceDesc.Height = 800;  // default values
        }

        int nCapWidth = 256;
        int nCapHeight = 256;

        if (d3dSurfaceDesc.Width > 256)
        {
            if (d3dSurfaceDesc.Width > 300)
            {
                nCapWidth = 512;

                if (d3dSurfaceDesc.Width > 512)
                {
                    if (d3dSurfaceDesc.Width > 640)     // 615 is 20% larger than 512
                    {
                        nCapWidth = 1024;
                        if (d3dSurfaceDesc.Width > 1024)     // 615 is 20% larger than 512
                        {
                            fClip = TRUE;       // We don't want it any larger than this
                        }
                    }
                    else
                    {
                        fClip = TRUE;       // We are forcing it down to 512
                    }
                }
            }
            else
            {
                fClip = TRUE;       // We are forcing it down to 256
            }
        }

        if (d3dSurfaceDesc.Height > 256)
        {
            if (d3dSurfaceDesc.Height > 300)
            {
                nCapHeight = 512;

                if (d3dSurfaceDesc.Height > 512)
                {
                    if (d3dSurfaceDesc.Height > 640)     // 615 is 20% larger than 512
                    {
                        nCapHeight = 1024;
                        if (d3dSurfaceDesc.Height > 1024)     // 615 is 20% larger than 512
                        {
                            fClip = TRUE;       // We don't want it any larger than this
                        }
                    }
                    else
                    {
                        fClip = TRUE;       // We are forcing it down to 512
                    }
                }
            }
            else
            {
                fClip = TRUE;       // We are forcing it down to 256
            }
        }

        if ((FALSE == fClip) && m_pMain->UseSmallImages())
        {
            // The caller wants to make sure we don't use anything larger than 512.
            if (512 < nCapHeight)
            {
                nCapHeight = 512;
                fClip = TRUE;
            }

            if (512 < nCapWidth)
            {
                nCapWidth = 512;
                fClip = TRUE;
            }
        }

        *pnNewWidth = nCapWidth;
        *pnNewHeight = nCapHeight;
    }

    return fClip;
}

IDirect3DTexture8 * CTexture::GetTexture(float * pfScale)
{
    IDirect3DTexture8 * pTexture = NULL;
    HRESULT hr = E_FAIL;
    TCHAR szPictureInfo[MAX_PATH];

    if (pfScale)
    {
        *pfScale = m_fScale;
    }

    // PERF NOTES: Often the background thread will only spend 107ms to load the file (ReadFile)
    // but it will take the forground thread 694ms in D3DXCreateTextureFromFileInMemoryEx to
    // load and decode the file.  This is because more memory is needed after the file is finished
    // being compressed and it takes a while to decompress.  After this, if the image is too large,
    // it will need to call D3DXCreateTextureFromFileInMemoryEx in order to load it into a smaller
    // size, which will take 902ms.
    // TODO: How should we solve this?
    if (m_pMain)
    {
        int nCurrMonitor = m_pMain->GetCurrMonitorIndex();

        pTexture = m_pTexture[nCurrMonitor];
        if (!pTexture)          // Cache is empty, so populate it.
        {
            if (m_pvBits)
            {
                DebugStartWatch();
                hr = D3DXCreateTextureFromFileInMemoryEx(m_pMain->GetD3DDevice(), m_pvBits, m_cbSize, 
                    D3DX_DEFAULT /* Size X*/, D3DX_DEFAULT /* Size Y*/, 5/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                    D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                    &(m_pTexture[nCurrMonitor]));
                _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                DXUtil_Trace(TEXT("PICTURE: It took %d ms for D3DXCreateTextureFromFileInMemoryEx(\"%ls\").  %s  hr=%#08lx\n"), DebugStopWatch(), m_pszPath, szPictureInfo, hr);
                if (SUCCEEDED(hr))
                {
                    int nNewWidth;
                    int nNewHeight;

                    g_nTotalTexturesLoaded++;

                    // In order to save memory, we never want to load images over 800x600.  If the render surface is small, we want to use
                    // even smaller max sizes.
                    if (_DoesImageNeedClipping(&nNewWidth, &nNewHeight))
                    {
                        SAFE_RELEASE(m_pTexture[nCurrMonitor]);
                        g_nTotalTexturesLoaded--;

                        DebugStartWatch();
                        // Now we found that we want to re-render the image, but this time shrink it, then we do that now.
                        hr = D3DXCreateTextureFromFileInMemoryEx(m_pMain->GetD3DDevice(), m_pvBits, m_cbSize, 
                            nNewWidth /* Size X*/, nNewHeight /* Size Y*/, 5/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                            D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                            &(m_pTexture[nCurrMonitor]));
                        _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                        DXUtil_Trace(TEXT("PICTURE: It took %d ms for D3DXCreateTextureFromFileInMemoryEx(\"%ls\") 2nd time.  %s  hr=%#08lx\n"), DebugStopWatch(), m_pszPath, szPictureInfo, hr);

                        if (SUCCEEDED(hr))
                        {
                            g_nTotalTexturesLoaded++;
                        }
                    }
                }
            }
            else
            {
                // This will give people a chance to customize the images.
                if (m_pszPath && PathFileExists(m_pszPath))
                {
                    int nOrigX;
                    int nOrigY;

                    DebugStartWatch();
                    hr = D3DXCreateTextureFromFileEx(m_pMain->GetD3DDevice(), m_pszPath, 
                        D3DX_DEFAULT /* Size X*/, D3DX_DEFAULT /* Size Y*/, 5/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                        D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                        &(m_pTexture[nCurrMonitor]));
                    _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                    DXUtil_Trace(TEXT("PICTURE: It took %d ms for FromFileEx(\"%ls\").  %s hr=%#08lx\n"), 
                                DebugStopWatch(), (PathFindFileName(m_pszPath) ? PathFindFileName(m_pszPath) : m_pszPath), szPictureInfo, hr);
                    if (SUCCEEDED(hr))
                    {
                        int nNewWidth;
                        int nNewHeight;

                        g_nTotalTexturesLoaded++;

                        // In order to save memory, we never want to load images over 800x600.  If the render surface is small, we want to use
                        // even smaller max sizes.
                        if (_DoesImageNeedClipping(&nNewWidth, &nNewHeight))
                        {
                            SAFE_RELEASE(m_pTexture[nCurrMonitor]);
                            g_nTotalTexturesLoaded--;

                            DebugStartWatch();
                            // Now we found that we want to re-render the image, but this time shrink it, then we do that now.
                            hr = D3DXCreateTextureFromFileEx(m_pMain->GetD3DDevice(), m_pszPath, 
                                nNewWidth /* Size X*/, nNewHeight /* Size Y*/, 5/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                                D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                                &(m_pTexture[nCurrMonitor]));
                            _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                            DXUtil_Trace(TEXT("PICTURE: It took %d ms for FromFileEx(\"%ls\") 2nd time. %s  hr=%#08lx\n"), 
                                    DebugStopWatch(), (PathFindFileName(m_pszPath) ? PathFindFileName(m_pszPath) : m_pszPath), szPictureInfo, hr);

                            if (SUCCEEDED(hr))
                            {
                                g_nTotalTexturesLoaded++;
                            }
                        }
                    }
                    else
                    {
                        // We failed to load the picture, so it may be a type we don't support,
                        // like .gif.  So stop trying to load it.
                        Str_SetPtr(&m_pszPath, NULL);
                    }
                }

                if (FAILED(hr) && m_pszResource)
                {
                    // Now, let's grab our standard value.
                    int nMipLevels = 5;

                    DebugStartWatch();
                    hr = D3DXCreateTextureFromResourceEx(m_pMain->GetD3DDevice(), HINST_THISDLL, m_pszResource, 
                        D3DX_DEFAULT /* Size X*/, D3DX_DEFAULT /* Size Y*/, nMipLevels/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                        D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                        &(m_pTexture[nCurrMonitor]));
                    _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                    DXUtil_Trace(TEXT("PICTURE: It took %d ms for D3DXCreateTextureFromResourceEx(\"%ls\").  %s  hr=%#08lx\n"), DebugStopWatch(), m_pszResource, szPictureInfo, hr);
                    if (SUCCEEDED(hr))
                    {
                        int nNewWidth;
                        int nNewHeight;

                        g_nTotalTexturesLoaded++;

                        // In order to save memory, we never want to load images over 800x600.  If the render surface is small, we want to use
                        // even smaller max sizes.
                        if (_DoesImageNeedClipping(&nNewWidth, &nNewHeight))
                        {
                            SAFE_RELEASE(m_pTexture[nCurrMonitor]);
                            g_nTotalTexturesLoaded--;

                            DebugStartWatch();
                            // Now we found that we want to re-render the image, but this time shrink it, then we do that now.
                            hr = D3DXCreateTextureFromResourceEx(m_pMain->GetD3DDevice(), HINST_THISDLL, m_pszResource, 
                                nNewWidth /* Size X*/, nNewHeight /* Size Y*/, 5/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                                D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                                &(m_pTexture[nCurrMonitor]));
                            _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                            DXUtil_Trace(TEXT("PICTURE: It took %d ms for D3DXCreateTextureFromResourceEx(\"%ls\") 2nd time.  %s  hr=%#08lx\n"), DebugStopWatch(), m_pszResource, szPictureInfo, hr);

                            if (SUCCEEDED(hr))
                            {
                                g_nTotalTexturesLoaded++;
                            }
                        }
                    }
                    else
                    {
                        // We failed to load the picture, so it may be a type we don't support,
                        // like .gif.  So stop trying to load it.
                        Str_SetPtr(&m_pszPath, NULL);
                    }
                }
            }

            pTexture = m_pTexture[nCurrMonitor];
        }
    }

    return pTexture;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CTexture::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CTexture::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CTexture::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CTexture, IUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\util.h ===
/*****************************************************************************\
    FILE: util.h

    DESCRIPTION:

    BryanSt 12/22/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef UTIL_H
#define UTIL_H

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a)/sizeof(*a))
#endif

//-----------------------------------------------------------------------------
// Name: enum CULLSTATE
// Desc: Represents the result of the culling calculation on an object.
//-----------------------------------------------------------------------------
enum CULLSTATE
{
    CS_UNKNOWN,      // cull state not yet computed
    CS_INSIDE,       // object bounding box is at least partly inside the frustum
    CS_OUTSIDE,      // object bounding box is outside the frustum
    CS_INSIDE_SLOW,  // OBB is inside frustum, but it took extensive testing to determine this
    CS_OUTSIDE_SLOW, // OBB is outside frustum, but it took extensive testing to determine this
};


//-----------------------------------------------------------------------------
// Name: struct CULLINFO
// Desc: Stores information that will be used when culling objects.  It needs
//       to be recomputed whenever the view matrix or projection matrix changes.
//-----------------------------------------------------------------------------
struct CULLINFO
{
    D3DXVECTOR3 vecFrustum[8];    // corners of the view frustum
    D3DXPLANE planeFrustum[6];    // planes of the view frustum
    D3DXVECTOR3 vecFrustumCenter; // center of the view frustum
};

#include "main.h"


#define HINST_THISDLL       g_hMainInstance


extern BOOL g_fOverheadViewTest;
extern HINSTANCE g_hMainInstance;


void FloatToString(float fValue, int nDecimalDigits, LPTSTR pszString, DWORD cchSize);
void PrintLocation(LPTSTR pszTemplate, D3DXVECTOR3 vLoc, D3DXVECTOR3 vTangent);


HRESULT SetBoxStripVertexes(MYVERTEX * ppvVertexs, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal);
float GetSurfaceRatio(IDirect3DTexture8 * pTexture);
float AddVectorComponents(D3DXVECTOR3 vDir);

int CALLBACK DPALocalFree_Callback(LPVOID p, LPVOID pData);
int CALLBACK DPAStrCompare(void * pv1, void * pv2, LPARAM lParam);
BOOL Is3DRectViewable(CULLINFO* pCullInfo, D3DXMATRIX* pMatWorld, 
                      D3DXVECTOR3 vMin, D3DXVECTOR3 vMax);

int GetTextureHeight(IDirect3DTexture8 * pTexture);
int GetTextureWidth(IDirect3DTexture8 * pTexture);


BOOL PathDeleteDirectoryRecursively(LPCTSTR pszDir);
ULONGLONG PathGetFileSize(LPCTSTR pszPath);



int GetRandomInt(int nMin, int nMax);
HRESULT GetCurrentUserCustomName(LPWSTR pszDisplayName, DWORD cchSize);
HRESULT ShellFolderParsePath(LPCWSTR pszPath, LPITEMIDLIST * ppidl);
HRESULT ShellFolderGetPath(LPCITEMIDLIST pidl, LPWSTR pszPath, DWORD cchSize);


// Reg Wrappers
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
HRESULT HrRegGetDWORD(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, LPDWORD pdwValue, DWORD dwDefaultValue);
HRESULT HrRegSetDWORD(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwValue);
HRESULT HrRegGetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, IN LPWSTR pszString, IN DWORD cchSize);
HRESULT HrRegSetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, OUT LPCWSTR pszString);


// UI Wrappers
void SetCheckBox(HWND hwndDlg, UINT idControl, BOOL fChecked);
BOOL GetCheckBox(HWND hwndDlg, UINT idControl);


// Prototypes for the culling functions
VOID UpdateCullInfo( CULLINFO* pCullInfo, D3DXMATRIX* pMatView, D3DXMATRIX* pMatProj );
CULLSTATE CullObject( CULLINFO* pCullInfo, D3DXVECTOR3* pVecBounds, D3DXPLANE* pPlaneBounds );
BOOL EdgeIntersectsFace( D3DXVECTOR3* pEdges, D3DXVECTOR3* pFaces, D3DXPLANE* pPlane );

// Other
void DebugStartWatch(void);
DWORD DebugStopWatch(void);

D3DXVECTOR3 D3DXVec3Multiply(CONST D3DXVECTOR3 v1, CONST D3DXVECTOR3 v2);


typedef struct
{
    float fTimeToRotate;
    float fTimeToWalk;
    float fTimeToLookAtPaintings;
    int nMinTurnFrames;
    int nMinWalkFrames;
    int nMaxTurnFrames;
    int nMaxWalkFrames;
} SPEED_SETTING;

#define MAX_SPEED                   11

extern SPEED_SETTING s_SpeedSettings[MAX_SPEED];

#define TaskBar_SetRange(hwndControl, fRedraw, nMin, nMax)  SendMessage(hwndControl, TBM_SETRANGE, (WPARAM) (BOOL) fRedraw, (LPARAM) MAKELONG(nMin, nMax))
#define TaskBar_SetPos(hwndControl, fRedraw, nPosition)  SendMessage(hwndControl, TBM_SETPOS, (WPARAM) (BOOL) fRedraw, (LPARAM) (LONG) nPosition)
#define TaskBar_GetPos(hwndControl)  (int) SendMessage(hwndControl, TBM_GETPOS, 0, 0)



float rnd(void);

#define ABS(i)  (((i) < 0) ? -(i) : (i))



//------------------------------------------------------------------------

////////////////
//
//  Critical section stuff
//
//  Helper macros that give nice debug support
//
EXTERN_C CRITICAL_SECTION g_csDll;
#ifdef DEBUG
EXTERN_C UINT g_CriticalSectionCount;
EXTERN_C DWORD g_CriticalSectionOwner;
EXTERN_C void Dll_EnterCriticalSection(CRITICAL_SECTION*);
EXTERN_C void Dll_LeaveCriticalSection(CRITICAL_SECTION*);
#if defined(__cplusplus) && defined(AssertMsg)
class DEBUGCRITICAL {
protected:
    BOOL fClosed;
public:
    DEBUGCRITICAL() {fClosed = FALSE;};
    void Leave() {fClosed = TRUE;};
    ~DEBUGCRITICAL() 
    {
        AssertMsg(fClosed, TEXT("you left scope while holding the critical section"));
    }
};
#define ENTERCRITICAL DEBUGCRITICAL debug_crit; Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL debug_crit.Leave(); Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#else // __cplusplus
#define ENTERCRITICAL Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#endif // __cplusplus
#define ASSERTCRITICAL ASSERT(g_CriticalSectionCount > 0 && GetCurrentThreadId() == g_CriticalSectionOwner)
#define ASSERTNONCRITICAL ASSERT(GetCurrentThreadId() != g_CriticalSectionOwner)
#else // DEBUG
#define ENTERCRITICAL EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT LeaveCriticalSection(&g_csDll)
#define ASSERTCRITICAL 
#define ASSERTNONCRITICAL
#endif // DEBUG



#endif // UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:

    BryanSt 12/22/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"
#include "..\\d3dsaver\\dxutil.h"

#define SECURITY_WIN32
#include <sspi.h>
extern "C" {
    #include <Secext.h>     // for GetUserNameEx()
}


// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "MSMUSEUM"
#define SZ_MODULE           "MSMUSEUM"
#define DECLARE_DEBUG


#undef __IShellFolder2_FWD_DEFINED__
#include <ccstock.h>
#include <debug.h>

#include "util.h"


BOOL g_fOverheadViewTest = FALSE;


#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0xFFFFFFFF;
DWORD g_TLSliStopWatchStartLo = 0xFFFFFFFF;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG


/////////////////////////////////////////////////////////////////////
// Debug Timing Helpers
/////////////////////////////////////////////////////////////////////

#ifdef DEBUG
void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;

    if (-1 == g_TLSliStopWatchStartHi)
    {
        g_TLSliStopWatchStartHi = TlsAlloc();
        g_TLSliStopWatchStartLo = TlsAlloc();
        liStopWatchStart.QuadPart = 0;

        QueryPerformanceFrequency(&g_liStopWatchFreq);      // Only a one time call since it's value can't change while the system is running.
    }
    else
    {
        liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
        liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    }

    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, IntToPtr(liStopWatchStart.HighPart));
    TlsSetValue(g_TLSliStopWatchStartLo, IntToPtr(liStopWatchStart.LowPart));
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);

    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#else // DEBUG

void DebugStartWatch(void)
{
}

DWORD DebugStopWatch(void)
{
    return 0;
}
#endif // DEBUG






float rnd(void)
{
    return (((FLOAT)rand() ) / RAND_MAX);
}

int GetRandomInt(int nMin, int nMax)
{
    int nDelta = (nMax - nMin + 1);
    float fRandom = (((float) rand()) / ((float) RAND_MAX));
    float fDelta = (fRandom * nDelta);

    int nAmount = (int)(fDelta);
    nAmount = min(nAmount, nDelta - 1);

    return (nMin + nAmount);
}


HRESULT SetBoxStripVertexes(MYVERTEX * ppvVertexs, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal)
{
    HRESULT hr = S_OK;
    float fTextureScale = 1.0f;     // How many repeats per 1 unit.

    // Draw Object
    if (vNormal.x)        // The object is in the y-z plane
    {
        ppvVertexs[0] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y, vLocation.z), vNormal, 0, fTextureScale);
        ppvVertexs[1] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y + vSize.y, vLocation.z), vNormal, 0, 0);
        ppvVertexs[2] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y, vLocation.z + vSize.z), vNormal, fTextureScale, fTextureScale);
        ppvVertexs[3] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y + vSize.y, vLocation.z + vSize.z), vNormal, fTextureScale, 0);
    }
    else if (vNormal.y)        // The object is in the x-z plane
    {
        ppvVertexs[0] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y, vLocation.z), vNormal, 0, fTextureScale);
        ppvVertexs[1] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y, vLocation.z + vSize.z), vNormal, 0, 0);
        ppvVertexs[2] = MYVERTEX(D3DXVECTOR3(vLocation.x + vSize.x, vLocation.y, vLocation.z), vNormal, fTextureScale, fTextureScale);
        ppvVertexs[3] = MYVERTEX(D3DXVECTOR3(vLocation.x + vSize.x, vLocation.y, vLocation.z + vSize.z), vNormal, fTextureScale, 0);
    }
    else
    {           // The object is in the x-y plane
        ppvVertexs[0] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y, vLocation.z), vNormal, 0, fTextureScale);
        ppvVertexs[1] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y + vSize.y, vLocation.z), vNormal, 0, 0);
        ppvVertexs[2] = MYVERTEX(D3DXVECTOR3(vLocation.x + vSize.x, vLocation.y, vLocation.z), vNormal, fTextureScale, fTextureScale);
        ppvVertexs[3] = MYVERTEX(D3DXVECTOR3(vLocation.x + vSize.x, vLocation.y + vSize.y, vLocation.z), vNormal, fTextureScale, 0);
    }

    return hr;
}


float AddVectorComponents(D3DXVECTOR3 vDir)
{
    return (vDir.x + vDir.y + vDir.z);
}


int CALLBACK DPALocalFree_Callback(LPVOID p, LPVOID pData)
{
    LocalFree(p);       // NULLs will be ignored.
    return 1;
}


int CALLBACK DPAStrCompare(void * pv1, void * pv2, LPARAM lParam)
{
    LPCTSTR pszSearch = (LPCTSTR) pv1;
    LPCTSTR pszCurrent = (LPCTSTR) pv2;

    if (pszSearch && pszCurrent &&
        !StrCmpI(pszSearch, pszCurrent))
    {
        return 0;       // They match
    }

    return 1;
}


float GetSurfaceRatio(IDirect3DTexture8 * pTexture)
{
    float fX = 1.0f;
    float fY = 1.0f;

    if (pTexture)
    {
        D3DSURFACE_DESC desc;

        if (SUCCEEDED(pTexture->GetLevelDesc(0, &desc)))
        {
            fX = (float) desc.Width;
            fY = (float) desc.Height;
        }
    }

    if (0.0f == fX)
    {
        fX = 1.0f;      // Protect from zero divides
    }
    
    return (fY / fX);
}


int GetTextureHeight(IDirect3DTexture8 * pTexture)
{
    int nHeight = 0;

    if (pTexture)
    {
        D3DSURFACE_DESC desc;

        if (SUCCEEDED(pTexture->GetLevelDesc(0, &desc)))
        {
            nHeight = desc.Height;
        }
    }

    return nHeight;
}


int GetTextureWidth(IDirect3DTexture8 * pTexture)
{
    int nWidth = 0;

    if (pTexture)
    {
        D3DSURFACE_DESC desc;

        if (SUCCEEDED(pTexture->GetLevelDesc(0, &desc)))
        {
            nWidth = desc.Width;
        }
    }

    return nWidth;
}





/////////////////////////////////////////////////////////////////////
// Registry Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
    DWORD dwError = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    DWORD dwError = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType,
                    OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData)
{
    DWORD dwError = SHGetValue(hKey, pszSubKey, pszValue, pdwType, pvData, pcbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrSHSetValue(IN HKEY hkey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwType, OPTIONAL OUT LPVOID pvData, IN DWORD cbData)
{
    DWORD dwError = SHSetValue(hkey, pszSubKey, pszValue, dwType, pvData, cbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegSetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, OUT LPCWSTR pszString)
{
    DWORD cbSize = ((lstrlenW(pszString) + 1) * sizeof(pszString[0]));

    return  HrSHSetValue(hKey, pszSubKey, pszValueName, REG_SZ, (BYTE *)pszString, cbSize);
}


HRESULT HrRegGetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, IN LPWSTR pszString, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszString[0]));

    HRESULT hr = HrSHGetValue(hKey, pszSubKey, pszValueName, &dwType, (BYTE *)pszString, &cbSize);
    if (SUCCEEDED(hr) && (REG_SZ != dwType))
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT HrRegGetDWORD(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, LPDWORD pdwValue, DWORD dwDefaultValue)
{
    DWORD dwType;
    DWORD cbSize = sizeof(*pdwValue);

    HRESULT hr = HrSHGetValue(hKey, pszSubKey, pszValue, &dwType, (void *) pdwValue, &cbSize);
    if (FAILED(hr))
    {
        *pdwValue = dwDefaultValue;
        hr = S_OK;
    }

    return hr;
}


HRESULT HrRegSetDWORD(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwValue)
{
    return HrSHSetValue(hKey, pszSubKey, pszValue, REG_DWORD, (void *) &dwValue, sizeof(dwValue));
}




// UI Wrappers
void SetCheckBox(HWND hwndDlg, UINT idControl, BOOL fChecked)
{
    SendMessage((HWND)GetDlgItem(hwndDlg, idControl), BM_SETCHECK, (WPARAM)fChecked, 0);
}


BOOL GetCheckBox(HWND hwndDlg, UINT idControl)
{
    return (BST_CHECKED == SendMessage((HWND)GetDlgItem(hwndDlg, idControl), BM_GETCHECK, 0, 0));
}


HRESULT ShellFolderParsePath(LPCWSTR pszPath, LPITEMIDLIST * ppidl)
{
    IShellFolder * psf;
    HRESULT hr = SHGetDesktopFolder(&psf);

    if (SUCCEEDED(hr))
    {
        hr = psf->ParseDisplayName(NULL, NULL, (LPOLESTR) pszPath, NULL, ppidl, NULL);
        psf->Release();
    }

    return hr;
}


HRESULT ShellFolderGetPath(LPCITEMIDLIST pidl, LPWSTR pszPath, DWORD cchSize)
{
    IShellFolder * psf;
    HRESULT hr = SHGetDesktopFolder(&psf);

    if (SUCCEEDED(hr))
    {
        IShellFolder * psfFolder;
        LPITEMIDLIST pidlParent = ILCloneParent(pidl);

        if (pidlParent) 
        {
            hr = psf->BindToObject(pidlParent, NULL, IID_IShellFolder, (void **) &psfFolder);
            if (SUCCEEDED(hr))
            {
                STRRET strRet = {0};
                LPITEMIDLIST pidlLast = ILFindLastID(pidl);

                hr = psfFolder->GetDisplayNameOf(pidlLast, (SHGDN_NORMAL | SHGDN_FORPARSING), &strRet);
                if (SUCCEEDED(hr))
                {
                    hr = StrRetToBuf(&strRet, pidlLast, pszPath, cchSize);
                }
                psfFolder->Release();
            }

            ILFree(pidlParent);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        psf->Release();
    }

    return hr;
}


BOOL PathDeleteDirectoryRecursively(LPCTSTR pszDir)
{
    BOOL fReturn = FALSE;
    HANDLE hFind;
    WIN32_FIND_DATA wfd;
    TCHAR szTemp[MAX_PATH];

    StrCpyN(szTemp, pszDir, ARRAYSIZE(szTemp));
    PathAppend(szTemp, TEXT("*.*"));
    hFind = FindFirstFile(szTemp, &wfd);

    if (INVALID_HANDLE_VALUE != hFind)
    {
        do
        {
            if (!PathIsDotOrDotDot(wfd.cFileName))
            {
                // build the path of the directory or file found
                StrCpyN(szTemp, pszDir, ARRAYSIZE(szTemp));
                PathAppend(szTemp, wfd.cFileName);

                if (FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes)
                {
                    // We found a directory - call this function recursively
                    // Note that since we use recursion, this can only go so far
                    // before it blows the stack.  If you plan on going into deep
                    // directories, put szTemp above on the heap.
                    fReturn = PathDeleteDirectoryRecursively(szTemp);
                }
                else
                {
                    DeleteFile(szTemp);
                }
            }
        }
        while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }

    fReturn = RemoveDirectory(pszDir);

    return fReturn;
}


ULONGLONG PathGetFileSize(LPCTSTR pszPath)
{
    ULONGLONG ullResult = 0;
    HANDLE hFile = CreateFile(pszPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        LARGE_INTEGER liFileSize;

        if (GetFileSizeEx(hFile, &liFileSize))
        {
            ullResult = liFileSize.QuadPart;
        }

        CloseHandle(hFile);
    }

    return ullResult;
}


void PrintLocation(LPTSTR pszTemplate, D3DXVECTOR3 vLoc, D3DXVECTOR3 vTangent)
{
    TCHAR szOut[1024];
    TCHAR szVector1[90];
    TCHAR szVector2[90];
    TCHAR szFloat1[20];
    TCHAR szFloat2[20];
    TCHAR szFloat3[20];

    FloatToString(vLoc.x, 4, szFloat1, ARRAYSIZE(szFloat1));
    FloatToString(vLoc.y, 4, szFloat2, ARRAYSIZE(szFloat2));
    FloatToString(vLoc.z, 4, szFloat3, ARRAYSIZE(szFloat3));
    wnsprintf(szVector1, ARRAYSIZE(szVector1), TEXT("<%s, %s, %s>"), szFloat1, szFloat2, szFloat3);

    FloatToString(vTangent.x, 4, szFloat1, ARRAYSIZE(szFloat1));
    FloatToString(vTangent.y, 4, szFloat2, ARRAYSIZE(szFloat2));
    FloatToString(vTangent.z, 4, szFloat3, ARRAYSIZE(szFloat3));
    wnsprintf(szVector2, ARRAYSIZE(szVector2), TEXT("<%s, %s, %s>\n"), szFloat1, szFloat2, szFloat3);

    wnsprintf(szOut, ARRAYSIZE(szOut), pszTemplate, szVector1, szVector2);
    DXUtil_Trace(szOut);
}


//-----------------------------------------------------------------------------
// Name: UpdateCullInfo()
// Desc: Sets up the frustum planes, endpoints, and center for the frustum
//       defined by a given view matrix and projection matrix.  This info will 
//       be used when culling each object in CullObject().
//-----------------------------------------------------------------------------
VOID UpdateCullInfo( CULLINFO* pCullInfo, D3DXMATRIX* pMatView, D3DXMATRIX* pMatProj )
{
    D3DXMATRIX mat;

    D3DXMatrixMultiply( &mat, pMatView, pMatProj );
    D3DXMatrixInverse( &mat, NULL, &mat );

    pCullInfo->vecFrustum[0] = D3DXVECTOR3(-1.0f, -1.0f,  0.0f); // xyz
    pCullInfo->vecFrustum[1] = D3DXVECTOR3( 1.0f, -1.0f,  0.0f); // Xyz
    pCullInfo->vecFrustum[2] = D3DXVECTOR3(-1.0f,  1.0f,  0.0f); // xYz
    pCullInfo->vecFrustum[3] = D3DXVECTOR3( 1.0f,  1.0f,  0.0f); // XYz
    pCullInfo->vecFrustum[4] = D3DXVECTOR3(-1.0f, -1.0f,  1.0f); // xyZ
    pCullInfo->vecFrustum[5] = D3DXVECTOR3( 1.0f, -1.0f,  1.0f); // XyZ
    pCullInfo->vecFrustum[6] = D3DXVECTOR3(-1.0f,  1.0f,  1.0f); // xYZ
    pCullInfo->vecFrustum[7] = D3DXVECTOR3( 1.0f,  1.0f,  1.0f); // XYZ

    pCullInfo->vecFrustumCenter = D3DXVECTOR3(0, 0, 0);
    for( INT i = 0; i < 8; i++ )
    {
        D3DXVec3TransformCoord( &pCullInfo->vecFrustum[i], &pCullInfo->vecFrustum[i], &mat );
        pCullInfo->vecFrustumCenter += pCullInfo->vecFrustum[i];
    }
    pCullInfo->vecFrustumCenter /= 8;

    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[0], &pCullInfo->vecFrustum[0], 
        &pCullInfo->vecFrustum[1], &pCullInfo->vecFrustum[2] ); // Near
    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[1], &pCullInfo->vecFrustum[6], 
        &pCullInfo->vecFrustum[7], &pCullInfo->vecFrustum[5] ); // Far
    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[2], &pCullInfo->vecFrustum[2], 
        &pCullInfo->vecFrustum[6], &pCullInfo->vecFrustum[4] ); // Left
    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[3], &pCullInfo->vecFrustum[7], 
        &pCullInfo->vecFrustum[3], &pCullInfo->vecFrustum[5] ); // Right
    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[4], &pCullInfo->vecFrustum[2], 
        &pCullInfo->vecFrustum[3], &pCullInfo->vecFrustum[6] ); // Top
    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[5], &pCullInfo->vecFrustum[1], 
        &pCullInfo->vecFrustum[0], &pCullInfo->vecFrustum[4] ); // Bottom
}




//-----------------------------------------------------------------------------
// Name: CullObject()
// Desc: Determine the cullstate for an object.
//-----------------------------------------------------------------------------
CULLSTATE CullObject( CULLINFO* pCullInfo, D3DXVECTOR3* pVecBounds, 
                      D3DXPLANE* pPlaneBounds )
{
    BYTE bOutside[8];
    ZeroMemory( &bOutside, sizeof(bOutside) );

    // Check boundary vertices against all 6 frustum planes, 
    // and store result (1 if outside) in a bitfield
    for( int iPoint = 0; iPoint < 8; iPoint++ )
    {
        for( int iPlane = 0; iPlane < 6; iPlane++ )
        {
            if( pCullInfo->planeFrustum[iPlane].a * pVecBounds[iPoint].x +
                pCullInfo->planeFrustum[iPlane].b * pVecBounds[iPoint].y +
                pCullInfo->planeFrustum[iPlane].c * pVecBounds[iPoint].z +
                pCullInfo->planeFrustum[iPlane].d < 0)
            {
                bOutside[iPoint] |= (1 << iPlane);
            }
        }
        // If any point is inside all 6 frustum planes, it is inside
        // the frustum, so the object must be rendered.
        if( bOutside[iPoint] == 0 )
            return CS_INSIDE;
    }

    // If all points are outside any single frustum plane, the object is
    // outside the frustum
    if( (bOutside[0] & bOutside[1] & bOutside[2] & bOutside[3] & 
        bOutside[4] & bOutside[5] & bOutside[6] & bOutside[7]) != 0 )
    {
        return CS_OUTSIDE;
    }

    // Now see if any of the frustum edges penetrate any of the faces of
    // the bounding box
    D3DXVECTOR3 edge[12][2] = 
    {
        pCullInfo->vecFrustum[0], pCullInfo->vecFrustum[1], // front bottom
        pCullInfo->vecFrustum[2], pCullInfo->vecFrustum[3], // front top
        pCullInfo->vecFrustum[0], pCullInfo->vecFrustum[2], // front left
        pCullInfo->vecFrustum[1], pCullInfo->vecFrustum[3], // front right
        pCullInfo->vecFrustum[4], pCullInfo->vecFrustum[5], // back bottom
        pCullInfo->vecFrustum[6], pCullInfo->vecFrustum[7], // back top
        pCullInfo->vecFrustum[4], pCullInfo->vecFrustum[6], // back left
        pCullInfo->vecFrustum[5], pCullInfo->vecFrustum[7], // back right
        pCullInfo->vecFrustum[0], pCullInfo->vecFrustum[4], // left bottom
        pCullInfo->vecFrustum[2], pCullInfo->vecFrustum[6], // left top
        pCullInfo->vecFrustum[1], pCullInfo->vecFrustum[5], // right bottom
        pCullInfo->vecFrustum[3], pCullInfo->vecFrustum[7], // right top
    };
    D3DXVECTOR3 face[6][4] =
    {
        pVecBounds[0], pVecBounds[2], pVecBounds[3], pVecBounds[1], // front
        pVecBounds[4], pVecBounds[5], pVecBounds[7], pVecBounds[6], // back
        pVecBounds[0], pVecBounds[4], pVecBounds[6], pVecBounds[2], // left
        pVecBounds[1], pVecBounds[3], pVecBounds[7], pVecBounds[5], // right
        pVecBounds[2], pVecBounds[6], pVecBounds[7], pVecBounds[3], // top
        pVecBounds[0], pVecBounds[4], pVecBounds[5], pVecBounds[1], // bottom
    };
    D3DXVECTOR3* pEdge;
    D3DXVECTOR3* pFace;
    pEdge = &edge[0][0];
    for( INT iEdge = 0; iEdge < 12; iEdge++ )
    {
        pFace = &face[0][0];
        for( INT iFace = 0; iFace < 6; iFace++ )
        {
            if( EdgeIntersectsFace( pEdge, pFace, &pPlaneBounds[iFace] ) )
            {
                return CS_INSIDE_SLOW;
            }
            pFace += 4;
        }
        pEdge += 2;
    }

    // Now see if frustum is contained in bounding box
    // If the frustum center is outside any plane of the bounding box,
    // the frustum is not contained in the bounding box, so the object
    // is outside the frustum
    for( INT iPlane = 0; iPlane < 6; iPlane++ )
    {
        if( pPlaneBounds[iPlane].a * pCullInfo->vecFrustumCenter.x +
            pPlaneBounds[iPlane].b * pCullInfo->vecFrustumCenter.y +
            pPlaneBounds[iPlane].c * pCullInfo->vecFrustumCenter.z +
            pPlaneBounds[iPlane].d  < 0 )
        {
            return CS_OUTSIDE_SLOW;
        }
    }

    // Bounding box must contain the frustum, so render the object
    return CS_INSIDE_SLOW;
}




//-----------------------------------------------------------------------------
// Name: EdgeIntersectsFace()
// Desc: Determine if the edge bounded by the two vectors in pEdges intersects
//       the quadrilateral described by the four vectors in pFacePoints.  
//       Note: pPlanePoints could be derived from pFacePoints using 
//       D3DXPlaneFromPoints, but it is precomputed in advance for greater
//       speed.
//-----------------------------------------------------------------------------
BOOL EdgeIntersectsFace( D3DXVECTOR3* pEdges, D3DXVECTOR3* pFacePoints, 
                         D3DXPLANE* pPlane )
{
    // If both edge points are on the same side of the plane, the edge does
    // not intersect the face
    FLOAT fDist1;
    FLOAT fDist2;
    fDist1 = pPlane->a * pEdges[0].x + pPlane->b * pEdges[0].y +
             pPlane->c * pEdges[0].z + pPlane->d;
    fDist2 = pPlane->a * pEdges[1].x + pPlane->b * pEdges[1].y +
             pPlane->c * pEdges[1].z + pPlane->d;
    if( fDist1 > 0 && fDist2 > 0 ||
        fDist1 < 0 && fDist2 < 0 )
    {
        return FALSE;
    }

    // Find point of intersection between edge and face plane (if they're
    // parallel, edge does not intersect face and D3DXPlaneIntersectLine 
    // returns NULL)
    D3DXVECTOR3 ptIntersection;
    if( NULL == D3DXPlaneIntersectLine( &ptIntersection, pPlane, &pEdges[0], &pEdges[1] ) )
        return FALSE;

    // Project onto a 2D plane to make the pt-in-poly test easier
    FLOAT fAbsA = (pPlane->a > 0 ? pPlane->a : -pPlane->a);
    FLOAT fAbsB = (pPlane->b > 0 ? pPlane->b : -pPlane->b);
    FLOAT fAbsC = (pPlane->c > 0 ? pPlane->c : -pPlane->c);
    D3DXVECTOR2 facePoints[4];
    D3DXVECTOR2 point;
    if( fAbsA > fAbsB && fAbsA > fAbsC )
    {
        // Plane is mainly pointing along X axis, so use Y and Z
        for( INT i = 0; i < 4; i++)
        {
            facePoints[i].x = pFacePoints[i].y;
            facePoints[i].y = pFacePoints[i].z;
        }
        point.x = ptIntersection.y;
        point.y = ptIntersection.z;
    }
    else if( fAbsB > fAbsA && fAbsB > fAbsC )
    {
        // Plane is mainly pointing along Y axis, so use X and Z
        for( INT i = 0; i < 4; i++)
        {
            facePoints[i].x = pFacePoints[i].x;
            facePoints[i].y = pFacePoints[i].z;
        }
        point.x = ptIntersection.x;
        point.y = ptIntersection.z;
    }
    else
    {
        // Plane is mainly pointing along Z axis, so use X and Y
        for( INT i = 0; i < 4; i++)
        {
            facePoints[i].x = pFacePoints[i].x;
            facePoints[i].y = pFacePoints[i].y;
        }
        point.x = ptIntersection.x;
        point.y = ptIntersection.y;
    }

    // If point is on the outside of any of the face edges, it is
    // outside the face.  
    // We can do this by taking the determinant of the following matrix:
    // | x0 y0 1 |
    // | x1 y1 1 |
    // | x2 y2 1 |
    // where (x0,y0) and (x1,y1) are points on the face edge and (x2,y2) 
    // is our test point.  If this value is positive, the test point is
    // "to the left" of the line.  To determine whether a point needs to
    // be "to the right" or "to the left" of the four lines to qualify as
    // inside the face, we need to see if the faces are specified in 
    // clockwise or counter-clockwise order (it could be either, since the
    // edge could be penetrating from either side).  To determine this, we
    // do the same test to see if the third point is "to the right" or 
    // "to the left" of the line formed by the first two points.
    // See http://forum.swarthmore.edu/dr.math/problems/scott5.31.96.html
    FLOAT x0, x1, x2, y0, y1, y2;
    x0 = facePoints[0].x;
    y0 = facePoints[0].y;
    x1 = facePoints[1].x;
    y1 = facePoints[1].y;
    x2 = facePoints[2].x;
    y2 = facePoints[2].y;
    BOOL bClockwise = FALSE;
    if( x1*y2 - y1*x2 - x0*y2 + y0*x2 + x0*y1 - y0*x1 < 0 )
        bClockwise = TRUE;
    x2 = point.x;
    y2 = point.y;
    for( INT i = 0; i < 4; i++ )
    {
        x0 = facePoints[i].x;
        y0 = facePoints[i].y;
        if( i < 3 )
        {
            x1 = facePoints[i+1].x;
            y1 = facePoints[i+1].y;
        }
        else
        {
            x1 = facePoints[0].x;
            y1 = facePoints[0].y;
        }
        if( ( x1*y2 - y1*x2 - x0*y2 + y0*x2 + x0*y1 - y0*x1 > 0 ) == bClockwise )
            return FALSE;
    }

    // If we get here, the point is inside all four face edges, 
    // so it's inside the face.
    return TRUE;
}




BOOL Is3DRectViewable(CULLINFO* pCullInfo, D3DXMATRIX* pMatWorld, 
                      D3DXVECTOR3 vecMin, D3DXVECTOR3 vecMax)
{
    BOOL fViewable = TRUE;
    D3DXVECTOR3 vecBoundsLocal[8];
    D3DXVECTOR3 vecBoundsWorld[8];
    D3DXPLANE planeBoundsWorld[6];
    CULLSTATE cs;

    vecBoundsLocal[0] = D3DXVECTOR3( vecMin.x, vecMin.y, vecMin.z ); // xyz
    vecBoundsLocal[1] = D3DXVECTOR3( vecMax.x, vecMin.y, vecMin.z ); // Xyz
    vecBoundsLocal[2] = D3DXVECTOR3( vecMin.x, vecMax.y, vecMin.z ); // xYz
    vecBoundsLocal[3] = D3DXVECTOR3( vecMax.x, vecMax.y, vecMin.z ); // XYz
    vecBoundsLocal[4] = D3DXVECTOR3( vecMin.x, vecMin.y, vecMax.z ); // xyZ
    vecBoundsLocal[5] = D3DXVECTOR3( vecMax.x, vecMin.y, vecMax.z ); // XyZ
    vecBoundsLocal[6] = D3DXVECTOR3( vecMin.x, vecMax.y, vecMax.z ); // xYZ
    vecBoundsLocal[7] = D3DXVECTOR3( vecMax.x, vecMax.y, vecMax.z ); // XYZ

    for( int i = 0; i < 8; i++ )
    {
        D3DXVec3TransformCoord( &vecBoundsWorld[i], &vecBoundsLocal[i], pMatWorld );
    }

    // Determine planes of bounding box coords
    D3DXPlaneFromPoints( &planeBoundsWorld[0], &vecBoundsWorld[0], &vecBoundsWorld[1], &vecBoundsWorld[2] ); // Near
    D3DXPlaneFromPoints( &planeBoundsWorld[1], &vecBoundsWorld[6], &vecBoundsWorld[7], &vecBoundsWorld[5] ); // Far
    D3DXPlaneFromPoints( &planeBoundsWorld[2], &vecBoundsWorld[2], &vecBoundsWorld[6], &vecBoundsWorld[4] ); // Left
    D3DXPlaneFromPoints( &planeBoundsWorld[3], &vecBoundsWorld[7], &vecBoundsWorld[3], &vecBoundsWorld[5] ); // Right
    D3DXPlaneFromPoints( &planeBoundsWorld[4], &vecBoundsWorld[2], &vecBoundsWorld[3], &vecBoundsWorld[6] ); // Top
    D3DXPlaneFromPoints( &planeBoundsWorld[5], &vecBoundsWorld[1], &vecBoundsWorld[0], &vecBoundsWorld[4] ); // Bottom

    cs = CullObject( pCullInfo, vecBoundsWorld, planeBoundsWorld );

    fViewable = (cs != CS_OUTSIDE && cs != CS_OUTSIDE_SLOW);

    return fViewable;
}


HRESULT GetCurrentUserCustomName(LPWSTR pszDisplayName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    ULONG cchUserSize = cchSize;

    if (GetUserNameEx(NameDisplay, pszDisplayName, &cchUserSize))
    {
        // It succeeded, so use it.
    }
    else
    {
        // It failed, so load "My".  It's better than nothing.
        LoadString(HINST_THISDLL, IDS_LOBBY_TITLE, pszDisplayName, cchSize);
    }

    return hr;
}


D3DXVECTOR3 D3DXVec3Multiply(CONST D3DXVECTOR3 v1, CONST D3DXVECTOR3 v2)
{
    D3DXVECTOR3 vResults;

    vResults.x = (v1.x * v2.x);
    vResults.y = (v1.y * v2.y);
    vResults.z = (v1.z * v2.z);

    return vResults;
}


void FloatToString(float fValue, int nDecimalDigits, LPTSTR pszString, DWORD cchSize)
{
    int nIntValue = (int) fValue;
    float fDecimalValue = (float)((fValue - (float)nIntValue) * (pow(10, nDecimalDigits)));
    int nDecimalValue = (int) fDecimalValue;

    if (0 == nDecimalDigits)
    {
        wnsprintf(pszString, cchSize, TEXT("%d"), nIntValue);
    }
    else
    {
        wnsprintf(pszString, cchSize, TEXT("%d.%d"), nIntValue, nDecimalValue);
    }
}



///////
// Critical section helper stuff
//
#ifdef DEBUG
UINT g_CriticalSectionCount = 0;
DWORD g_CriticalSectionOwner = 0;
#ifdef STACKBACKTRACE
DBstkback g_CriticalSectionLastCall[4] = { 0 };
#endif


void Dll_EnterCriticalSection(CRITICAL_SECTION * pcsDll)
{
#ifdef STACKBACKTRACE
    int var0;       // *must* be 1st on frame
#endif

    EnterCriticalSection(pcsDll);
    if (g_CriticalSectionCount++ == 0)
    {
        g_CriticalSectionOwner = GetCurrentThreadId();
#ifdef STACKBACKTRACE
        int fp = (int) (1 + (int *)&var0);
        DBGetStackBack(&fp, g_CriticalSectionLastCall, ARRAYSIZE(g_CriticalSectionLastCall));
#endif
    }
}

void Dll_LeaveCriticalSection(CRITICAL_SECTION * pcsDll)
{
    if (--g_CriticalSectionCount == 0)
        g_CriticalSectionOwner = 0;
    LeaveCriticalSection(pcsDll);
}
#endif


#include <string.h>
#include <wchar.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\museum\texture.h ===
/*****************************************************************************\
    FILE: texture.h

    DESCRIPTION:
        Manage a texture for several instance for each monitor.  Also manage keeping the
    ratio correct when it's not square when loaded.

    BryanSt 2/9/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef TEXTURE_H
#define TEXTURE_H


#include "util.h"
#include "main.h"
#include "config.h"

extern int g_nTotalTexturesLoaded;
extern int g_nTexturesRenderedInThisFrame;

class CTexture                 : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);


    // Member Functions
    IDirect3DTexture8 * GetTexture(float * pfScale = NULL);
    DWORD GetTextureWidth(void) {GetTexture(); return m_dxImageInfo.Width;}
    DWORD GetTextureHeight(void) {GetTexture(); return m_dxImageInfo.Height;}
    float GetScale(void) {GetTexture(); return m_fScale;}
    float GetSurfaceRatio(void) {GetTexture(); return 1.0f; /*(((float) m_dxImageInfo.Height) / ((float) m_dxImageInfo.Width));*/}

    BOOL IsLoadedInAnyDevice(void);
    BOOL IsLoadedForThisDevice(void);

    CTexture(CMSLogoDXScreenSaver * pMain, LPCTSTR pszPath, LPVOID pvBits, DWORD cbSize);
    CTexture(CMSLogoDXScreenSaver * pMain, LPCTSTR pszPath, LPCTSTR pszResource, float fScale);

    LPTSTR m_pszPath;

private:
    // Helper Functions
    void _Init(CMSLogoDXScreenSaver * pMain);
    HRESULT _GetPictureInfo(HRESULT hr, LPTSTR pszString, DWORD cchSize);
    BOOL _DoesImageNeedClipping(int * pnNewWidth, int * pnNewHeight);

    virtual ~CTexture();


    // Private Member Variables
    long                    m_cRef;

    // Member Variables
    IDirect3DTexture8 * m_pTexture[10];
    LPTSTR m_pszResource;
    LPVOID m_pvBits;          // The background thread will load the image into these bits.  The forground thread needs to create the interface.
    DWORD m_cbSize;           // The number of bytes in pvBits
    float m_fScale;           // The scale value.
    D3DXIMAGE_INFO m_dxImageInfo;

    CMSLogoDXScreenSaver * m_pMain;         // Weak reference
};



#endif // TEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\mystify\strings.h ===
#define idsDescription    1
#define idsPolygon        2
#define idsName         100

#include "..\common\comstrin.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\mystify\ssmyst.c ===
/*  MYSTIFY.C
**
**  Copyright (C) Microsoft, 1991, All Rights Reserved.
**
**  Screensaver Control Panel Applet.  This type creates one or two polygons
**  which bounce around the screen.
**
**  History:
**       6/17/91        stevecat    ported to NT Windows
**       2/10/92        stevecat    snapped to latest ported to NT Windows
*/

#define  OEMRESOURCE
#include <windows.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "mystify.dlg"
#include "strings.h"
#include "uniconv.h"


// void  SetFields (HWND, WORD);

DWORD AdjustColor      (DWORD dwSrc, DWORD dwDest, int nInc, int nCnt);
LONG  AppOwnerDraw     (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
WORD  AtoI             (LPTSTR lpszConvert);
BOOL  DrawBitmap       (HDC hdc, int x, int y, HBITMAP hbm, DWORD rop);
VOID  DrawPolygon      (HDC hDC, HPEN hPen, WORD wPolygon, WORD wLine);
VOID  FillR            (HDC hdc, LPRECT prc, DWORD rgb);
VOID  FrameR           (HDC hdc, LPRECT prc, DWORD rgb, int iFrame);
DWORD GenerateColor    (VOID);
WORD  GenerateVelocity (VOID);
VOID  GetFields        (VOID);
DWORD GetProfileRgb    (LPTSTR szApp, LPTSTR szItem, DWORD rgb);
VOID  PatB             (HDC hdc, int x, int y, int dx, int dy, DWORD rgb);
WORD  rand             (VOID);
VOID  ShadeWindows     (HWND hDlg, WORD wPoly, WORD wPolygon);
VOID  srand            (DWORD dwSeed);

#define RAND(x)  ((rand () % (x))+1)
#define ZRAND(x) (rand () % (x))

#define rgbBlack        RGB (0,0,0)
#define rgbWhite        RGB (255,255,255)
#define rgbGrey         RGB (128,128,128)
#define rgbMenu         GetSysColor (COLOR_MENU)
#define rgbMenuText     GetSysColor (COLOR_MENUTEXT)

#define BUFFER_SIZE     20
#define BUFFER2_SIZE    20

#define NUMBER_POLYGONS  2
#define MAXXVEL         12
#define MAXYVEL         12
#define MAXLINES        15
#define NUMLINES         8

TCHAR  szClearName[] = TEXT("Clear Screen");   // ClearScreen .INI key

DWORD dwRand = 1L;                      // current Random seed

TCHAR  szBuffer[BUFFER_SIZE];            // temp buffer

TCHAR  szBuffer2[BUFFER2_SIZE];          // temp buffer

BOOL  fOn[NUMBER_POLYGONS];             // flag for Active status of polygon

BOOL  fWalk[NUMBER_POLYGONS];           // color usage for each polygon

WORD  wLines[NUMBER_POLYGONS];          // number of lines for each polygon

WORD  wNumDisplay[2];
WORD  wFreeEntry[NUMBER_POLYGONS];      // colors for each polygon

DWORD dwStartColor[NUMBER_POLYGONS];
DWORD dwEndColor[NUMBER_POLYGONS];
DWORD dwCurrentColor[NUMBER_POLYGONS];
DWORD dwDestColor[NUMBER_POLYGONS];
DWORD dwSrcColor[NUMBER_POLYGONS];
WORD  wIncColor[NUMBER_POLYGONS];
WORD  wCurInc[NUMBER_POLYGONS];
TCHAR cblogpalPal[(MAXLINES*NUMBER_POLYGONS+1)
                           *sizeof (PALETTEENTRY)+sizeof (LOGPALETTE)];
POINT ptBox[MAXLINES*NUMBER_POLYGONS][4]; // array for points used in polygons

LPLOGPALETTE   lplogpalPal;
LPPALETTEENTRY lppePal;
HPALETTE       hPalette;
BOOL fClearScreen;                      // Global flag for ClearScreen state

//
// Help IDs
//
DWORD aMystDlgHelpIds[] = {
    ((DWORD) -1),((DWORD) -1),
    ID_SHAPE_LABEL,             IDH_DISPLAY_SCREENSAVER_MYSTIFY_SHAPE,
    ID_SHAPE,                   IDH_DISPLAY_SCREENSAVER_MYSTIFY_SHAPE,
    ID_ACTIVE,                  IDH_DISPLAY_SCREENSAVER_MYSTIFY_ACTIVE,
    ID_LINES_LABEL,             IDH_DISPLAY_SCREENSAVER_MYSTIFY_LINES,
    ID_LINES,                   IDH_DISPLAY_SCREENSAVER_MYSTIFY_LINES,
    ID_LINESARROW,              IDH_DISPLAY_SCREENSAVER_MYSTIFY_LINES,
    ID_COLORGROUP,              ((DWORD) -1),
    ID_2COLORS,                 IDH_DISPLAY_SCREENSAVER_MYSTIFY_TWO_COLORS,
    ID_COLOR1,                  IDH_DISPLAY_SCREENSAVER_MYSTIFY_TWO_COLORS,
    ID_COLOR2,                  IDH_DISPLAY_SCREENSAVER_MYSTIFY_TWO_COLORS,
    ID_RANDOMCOLORS,            IDH_DISPLAY_SCREENSAVER_MYSTIFY_RANDOM_COLORS,
    ID_CLEARSCREEN,             IDH_DISPLAY_SCREENSAVER_MYSTIFY_CLEAR_SCREEN,
    0,0
};

LRESULT ScreenSaverProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static POINT ptChange[MAXLINES*NUMBER_POLYGONS][4];
    static UINT_PTR  wTimer;
    WORD         wLoop1;
    WORD         wLoop2;
    WORD         wMainLoop;
    static WORD  wScreenX;
    static WORD  wScreenY;
    HPEN         hPen;
    static HPEN  hErasePen;
    HDC          hDC;
    HPALETTE     hOldPal;

    switch (message)
    {
    // Things to do while setting up the window...
    case WM_CREATE:
        GetFields ();
        wTimer = SetTimer (hWnd, 1, 10, NULL);

        // Make sure we use the entire virtual desktop size for multiple
        // displays
        wScreenX = (WORD) ((LPCREATESTRUCT)lParam)->cx;
        wScreenY = (WORD) ((LPCREATESTRUCT)lParam)->cy;

        srand (GetCurrentTime ());
        for (wMainLoop = 0; wMainLoop < NUMBER_POLYGONS; wMainLoop++)
        {
            if (fOn[wMainLoop])
            {
                for (wLoop1 = 0; wLoop1 < 4; wLoop1++)
                {
                    ptBox[wMainLoop*MAXLINES][wLoop1].x = RAND (wScreenX) - 1;
                    ptBox[wMainLoop*MAXLINES][wLoop1].y = RAND (wScreenY) - 1;
                    if ((ptChange[wMainLoop*MAXLINES][wLoop1].x =
                        RAND (MAXXVEL * 2)) > MAXXVEL)
                        ptChange[wMainLoop*MAXLINES][wLoop1].x =
                            -(ptChange[wMainLoop*MAXLINES][wLoop1].x
                            -MAXXVEL);
                    if ((ptChange[wMainLoop*MAXLINES][wLoop1].y =
                        RAND (MAXYVEL * 2)) > MAXYVEL)
                        ptChange[wMainLoop*MAXLINES][wLoop1].y =
                            -(ptChange[wMainLoop*MAXLINES][wLoop1].y
                            -MAXYVEL);
                }
                wNumDisplay[wMainLoop] = 1;
                wFreeEntry[wMainLoop] = 0;
                wCurInc[wMainLoop] = 0;
                wIncColor[wMainLoop] = 0;
                if (fWalk[wMainLoop])
                    dwDestColor[wMainLoop] = GenerateColor ();
                else
                    dwDestColor[wMainLoop] = dwStartColor[wMainLoop];
            }
        }
        lppePal = (LPPALETTEENTRY)(cblogpalPal + 4);
        lplogpalPal = (LPLOGPALETTE)cblogpalPal;
        lplogpalPal->palVersion = 0x300;
        lplogpalPal->palNumEntries = MAXLINES * NUMBER_POLYGONS + 1;
        for (wLoop1 = 0; wLoop1 <= MAXLINES * NUMBER_POLYGONS; wLoop1++)
        {
            lplogpalPal->palPalEntry[wLoop1].peRed = 0;
            lplogpalPal->palPalEntry[wLoop1].peGreen = 0;
            lplogpalPal->palPalEntry[wLoop1].peBlue = 0;
            lplogpalPal->palPalEntry[wLoop1].peFlags = PC_RESERVED;
        }
        hErasePen = CreatePen (PS_SOLID, 1,
            PALETTEINDEX (MAXLINES * NUMBER_POLYGONS));
        hPalette = CreatePalette (lplogpalPal);
        break;

    case WM_SIZE:
        wScreenX = LOWORD(lParam);
        wScreenY = HIWORD(lParam);
        break;



    case WM_ERASEBKGND:
        if (fClearScreen)
            break;
        return 0l;

    case WM_TIMER:
        // Get the display context...
        hDC = GetDC (hWnd);
        if (hDC != NULL)
        {
            // Now that we have changed the palette, make sure that it
            // gets updated by first unrealizing, and then realizing...
            hOldPal = SelectPalette (hDC, hPalette, 0);
            RealizePalette (hDC);

            for (wMainLoop = 0; wMainLoop < NUMBER_POLYGONS; wMainLoop++)
            {
                // Check to see if the current loop is on...
                if (fOn[wMainLoop])
                {
                    // If our current count is the same as the final count,
                    // generate a new count...
                    if (wCurInc[wMainLoop] == wIncColor[wMainLoop])
                    {
                        // Set the count to zero...
                        wCurInc[wMainLoop] = 0;

                        // Set an new variant...
                        wIncColor[wMainLoop] = GenerateVelocity ();

                        // Set up the cycling colors...
                        dwSrcColor[wMainLoop] = dwDestColor[wMainLoop];

                        if (fWalk[wMainLoop])
                            dwDestColor[wMainLoop] = GenerateColor ();
                        else if (dwSrcColor[wMainLoop] == dwEndColor[wMainLoop])
                            dwDestColor[wMainLoop] = dwStartColor[wMainLoop];
                        else
                            dwDestColor[wMainLoop] = dwEndColor[wMainLoop];
                    }
                    else
                        wCurInc[wMainLoop]++;

                    // Now adjust the color between the starting and the
                    // ending values...
                    dwCurrentColor[wMainLoop] = AdjustColor (dwSrcColor
                        [wMainLoop], dwDestColor[wMainLoop], wIncColor
                        [wMainLoop], wCurInc[wMainLoop]);
                    wLoop2 = wFreeEntry[wMainLoop] + wMainLoop * MAXLINES;

                    lplogpalPal->palPalEntry[wLoop2].peRed =
                                        GetRValue (dwCurrentColor[wMainLoop]);
                    lplogpalPal->palPalEntry[wLoop2].peGreen =
                                        GetGValue (dwCurrentColor[wMainLoop]);
                    lplogpalPal->palPalEntry[wLoop2].peBlue =
                                        GetBValue (dwCurrentColor[wMainLoop]);
                    lplogpalPal->palPalEntry[wLoop2].peFlags = PC_RESERVED;

                    // Adjust the palette...
                    AnimatePalette (hPalette, wLoop2, 1,
                                        &lplogpalPal->palPalEntry[wLoop2]);
                }
            }

            // Now cycle through again...
            for (wMainLoop = 0; wMainLoop < NUMBER_POLYGONS; wMainLoop++)
            {
                if (fOn[wMainLoop])
                {
                    /* If we are currently displaying all of the lines, then
                       delete the last line... */
                    if (wNumDisplay[wMainLoop] == wLines[wMainLoop])
                        /* Erase the last line... */
                        DrawPolygon (hDC, hErasePen, wMainLoop,
                                     (WORD) (wNumDisplay[wMainLoop] - 1));

                    /* Starting with the last entry, make it equal to the
                       entry before it... until we reach the first
                       entry... */
                    for (wLoop1 = (wNumDisplay[wMainLoop] - 1); wLoop1; wLoop1--)
                    {
                        /* Copy the points in the polygon over... */
                        for (wLoop2 = 0; wLoop2 < 4; wLoop2++)
                        {
                            ptBox[wLoop1+wMainLoop*MAXLINES][wLoop2].x =
                                ptBox[wLoop1-1+wMainLoop*MAXLINES][wLoop2].x;
                            ptBox[wLoop1+wMainLoop*MAXLINES][wLoop2].y =
                                ptBox[wLoop1-1+wMainLoop*MAXLINES][wLoop2].y;
                            ptChange[wLoop1+wMainLoop*MAXLINES][wLoop2].x =
                                ptChange[wLoop1-1+wMainLoop*MAXLINES]
                                [wLoop2].x;
                            ptChange[wLoop1+wMainLoop*MAXLINES][wLoop2].y =
                                ptChange[wLoop1-1+wMainLoop*MAXLINES]
                                [wLoop2].y;
                        }
                    }

                    /* Seeing as we now have entry 0 the same as entry 1,
                       generate a new entry 0... */
                    for (wLoop1 = 0; wLoop1 < 4; wLoop1++)
                    {
                        ptBox[wMainLoop*MAXLINES][wLoop1].x +=
                            ptChange[wMainLoop*MAXLINES][wLoop1].x;
                        ptBox[wMainLoop*MAXLINES][wLoop1].y +=
                            ptChange[wMainLoop*MAXLINES][wLoop1].y;
                        if (ptBox[wMainLoop*MAXLINES][wLoop1].x >=
                            (int)wScreenX)
                        {
                            ptBox[wMainLoop*MAXLINES][wLoop1].x =
                                ptBox[wMainLoop*MAXLINES][wLoop1].x
                                -2 * (ptBox[wMainLoop*MAXLINES][wLoop1].x
                                -wScreenX + 1);
                            ptChange[wMainLoop*MAXLINES][wLoop1].x =
                                -RAND (MAXXVEL);
                        }
                        if ((int)ptBox[wMainLoop*MAXLINES][wLoop1].x < 0)
                        {
                            ptBox[wMainLoop*MAXLINES][wLoop1].x =
                                -ptBox[wMainLoop*MAXLINES][wLoop1].x;
                            ptChange[wMainLoop*MAXLINES][wLoop1].x =
                                RAND (MAXXVEL);
                        }
                        if (ptBox[wMainLoop*MAXLINES][wLoop1].y >=
                            (int)wScreenY)
                        {
                            ptBox[wMainLoop*MAXLINES][wLoop1].y =
                                ptBox[wMainLoop*MAXLINES][wLoop1].y - 2 *
                                (ptBox[wMainLoop*MAXLINES][wLoop1].y
                                -wScreenY + 1);
                            ptChange[wMainLoop*MAXLINES][wLoop1].y =
                                -RAND (MAXYVEL);
                        }
                        if ((int)ptBox[wMainLoop*MAXLINES][wLoop1].y < 0)
                        {
                            ptBox[wMainLoop*MAXLINES][wLoop1].y =
                                -ptBox[wMainLoop*MAXLINES][wLoop1].y;
                            ptChange[wMainLoop*MAXLINES][wLoop1].y =
                                RAND (MAXYVEL);
                        }
                    }

                    /* Now redraw the new line... */
                    wLoop2 = wFreeEntry[wMainLoop] + wMainLoop * MAXLINES;
                    hPen = CreatePen (PS_SOLID, 1, PALETTEINDEX (wLoop2));
                    DrawPolygon (hDC, hPen, wMainLoop, 0);
                    if (hPen)
                        DeleteObject (hPen);

                    /* Now, as we are finished with the entry in the
                       palette, increment it such that the next time
                       around, it points at the next position... */
                    if ((++wFreeEntry[wMainLoop]) == wLines[wMainLoop])
                        wFreeEntry[wMainLoop] = 0;

                    /* Now, if we are not at the maximum number of lines,
                       then increment towards there... */
                    if (wNumDisplay[wMainLoop] < wLines[wMainLoop])
                        wNumDisplay[wMainLoop]++;
                }
            }

            /* Reselect the old palette... */
            if (hOldPal)
                SelectPalette (hDC, hOldPal, FALSE);

            /* Release the display context... */
            ReleaseDC (hWnd, hDC);
        }
        break;

    case WM_DESTROY:
        if (wTimer)
            KillTimer (hWnd, 1);
        if (hPalette)
            DeleteObject (hPalette);
        if (hErasePen)
            DeleteObject (hErasePen);
        break;
    }
    return (DefScreenSaverProc (hWnd, message, wParam, lParam));
}


VOID srand (DWORD dwSeed)
{
    dwRand = dwSeed;
}

WORD rand (VOID)
{
    dwRand = dwRand * 214013L + 2531011L;
    return (WORD)((dwRand >> 16) & 0xffff);
}

BOOL RegisterDialogClasses (HANDLE hInst)
{
    /* Register the custom controls.. */
    InitCommonControls();
    return TRUE;
}


//***************************************************************************

BOOL ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    WORD         nPal;
    DWORD        dwTemp = 0;
    HPALETTE     hPal;
    WORD         wLoop, wTemp;
    BOOL         fError;
    BYTE         byR, byG, byB;
    RECT         rDlgBox;
    TCHAR        szTemp[80];
    static HWND  hIDOK;
    static WORD  wPolygon;

    switch (message)
    {
    case WM_INITDIALOG:
        GetFields ();                // Read fields from CONTROL.INI

        GetWindowRect (hDlg, (LPRECT) & rDlgBox);
        hIDOK = GetDlgItem (hDlg, IDOK);

        // Set the global clear state...
        CheckDlgButton (hDlg, ID_CLEARSCREEN, fClearScreen);

        // Fill the boxes...
        for (wLoop = 0; wLoop < NUMBER_POLYGONS; wLoop++)
        {
            TCHAR   szBuffer[20];
            WORD    wTemp;

            LoadString (hMainInstance, idsPolygon, szTemp, CharSizeOf(szTemp));
            wsprintf (szBuffer, szTemp, wLoop + 1);
            wTemp = (WORD)SendDlgItemMessage (hDlg, ID_SHAPE, CB_ADDSTRING, 0,
                                              (LPARAM)szBuffer);
            SendDlgItemMessage (hDlg, ID_SHAPE, CB_SETITEMDATA, wTemp, wLoop);
        }

        hPal = GetStockObject (DEFAULT_PALETTE);
        GetObject (hPal, sizeof (WORD), (LPTSTR) &nPal);
        for (wTemp = 0; wTemp < nPal; wTemp++)
        {
            SendDlgItemMessage (hDlg, ID_COLOR1, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"a");
            SendDlgItemMessage (hDlg, ID_COLOR2, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"a");
        }

        // Start at the first polygon and let'r rip...
        SendDlgItemMessage (hDlg, ID_LINES, EM_LIMITTEXT, 2, 0l);
        SendDlgItemMessage( hDlg, ID_LINESARROW, UDM_SETRANGE, 0, MAKELONG(MAXLINES, 1));
        SendDlgItemMessage (hDlg, ID_SHAPE, CB_SETCURSEL, (wPolygon = 0), 0l);
        SendMessage (hDlg, WM_COMMAND, MAKELONG (ID_SHAPE, CBN_SELCHANGE), 0);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        // If we switch polygons, then update all of the info...
        case ID_SHAPE:
            if (HIWORD (wParam) == CBN_SELCHANGE)
            {
                WORD    wTemp;

                wTemp = (WORD)SendDlgItemMessage (hDlg, ID_SHAPE,
                                                    CB_GETCURSEL, 0, 0l);
                wPolygon = (WORD)SendDlgItemMessage (hDlg, ID_SHAPE,
                                                    CB_GETITEMDATA, wTemp, 0l);
                CheckDlgButton (hDlg, ID_ACTIVE, fOn[wPolygon]);
                SetDlgItemInt (hDlg, ID_LINES, wLines[wPolygon], FALSE);
                hPal = GetStockObject (DEFAULT_PALETTE);
                GetObject (hPal, sizeof (WORD), (LPTSTR) &nPal);
                if (SendDlgItemMessage (hDlg, ID_COLOR1, CB_SETCURSEL,
                    GetNearestPaletteIndex (hPal, dwStartColor[wPolygon]),
                    0l) == CB_ERR)
                    SendDlgItemMessage (hDlg, ID_COLOR1, CB_SETCURSEL, 0, 0l);
                if (SendDlgItemMessage (hDlg, ID_COLOR2, CB_SETCURSEL,
                    GetNearestPaletteIndex (hPal, dwEndColor[wPolygon]),
                    0l) == CB_ERR)
                    SendDlgItemMessage (hDlg, ID_COLOR2, CB_SETCURSEL, 0, 0l);

                // Set the walk state...
                CheckRadioButton (hDlg, ID_2COLORS, ID_RANDOMCOLORS, ID_2COLORS +
                    fWalk[wPolygon]);

                // Enable/disbale windows...
                ShadeWindows (hDlg, wPolygon, wPolygon);
            }
            break;

        // Toggle the actiavtion state...
        case ID_ACTIVE:
            fOn[wPolygon] ^= 1;
            CheckDlgButton (hDlg, LOWORD(wParam), fOn[wPolygon]);
            ShadeWindows (hDlg, wPolygon, wPolygon);
            break;

        case ID_CLEARSCREEN:
            fClearScreen ^= 1;
            CheckDlgButton (hDlg, LOWORD(wParam), fClearScreen);
            break;

        case ID_COLOR1:
        case ID_COLOR2:
            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                wTemp = (WORD)SendDlgItemMessage (hDlg, LOWORD(wParam), CB_GETCURSEL, 0, 0l);
                hPal = GetStockObject (DEFAULT_PALETTE);
                GetPaletteEntries (hPal, wTemp, 1, (LPPALETTEENTRY)(LPDWORD) & dwTemp);
                if ( LOWORD(wParam) == ID_COLOR1 )
                    dwStartColor[wPolygon] = dwTemp & 0xffffffL;
                else
                    dwEndColor[wPolygon] = dwTemp & 0xffffffL;
            }
            break;

        // Toggle the walk state...
        case ID_2COLORS:
        case ID_RANDOMCOLORS:
            fWalk[wPolygon] = LOWORD(wParam) - ID_2COLORS;
            CheckRadioButton (hDlg, ID_2COLORS, ID_RANDOMCOLORS, LOWORD(wParam));
            EnableWindow (GetDlgItem (hDlg, ID_COLOR1), !fWalk[wPolygon]);
            InvalidateRect (GetDlgItem (hDlg, ID_COLOR1), NULL, TRUE);
            EnableWindow (GetDlgItem (hDlg, ID_COLOR2), !fWalk[wPolygon]);
            InvalidateRect (GetDlgItem (hDlg, ID_COLOR2), NULL, TRUE);
            break;

        // Check to see if the edit texts have lost their focus. If so
        // update...
        case ID_LINES:
            if (HIWORD(wParam) == EN_UPDATE)
            {
                wLoop = (WORD) GetDlgItemInt (hDlg, LOWORD(wParam), &fError, FALSE);
                fError = fError && (wLoop >= 1 && wLoop <= MAXLINES);
                EnableWindow (GetDlgItem (hDlg, ID_LINESARROW), fError);
                EnableWindow (GetDlgItem (hDlg, IDOK), fError);
                if (fError)
                    wLines[wPolygon] = wLoop;
            }
            break;

        // Save the current parameters...
        case IDOK:
            wLines[wPolygon] = (WORD) GetDlgItemInt (hDlg, ID_LINES, &fError, FALSE);

            // Write the activation state of clearing the screen...
            wsprintf (szBuffer, TEXT("%d"), fClearScreen);
            WritePrivateProfileString (szAppName, szClearName, szBuffer, szIniFile);

            /* Write the updated versions of everything here... */
            for (wLoop = 0; wLoop < NUMBER_POLYGONS; wLoop++)
            {
                /* Set the activation state... */
                wsprintf (szBuffer, TEXT("Active%d"), wLoop + 1);
                wsprintf (szBuffer2, TEXT("%d"), fOn[wLoop]);
                WritePrivateProfileString (szAppName, szBuffer, szBuffer2, szIniFile);

                /* Set the walk state... */
                wsprintf (szBuffer, TEXT("WalkRandom%d"), wLoop + 1);
                wsprintf (szBuffer2, TEXT("%d"), fWalk[wLoop]);
                WritePrivateProfileString (szAppName, szBuffer, szBuffer2, szIniFile);

                /* Get the number of lines for the current polygon... */
                wsprintf (szBuffer, TEXT("Lines%d"), wLoop + 1);
                wsprintf (szBuffer2, TEXT("%d"), wLines[wLoop]);
                WritePrivateProfileString (szAppName, szBuffer, szBuffer2, szIniFile);

                /* Set the start color... */
                wsprintf (szBuffer, TEXT("StartColor%d"), wLoop + 1);
                byR = GetRValue (dwStartColor[wLoop]);
                byG = GetGValue (dwStartColor[wLoop]);
                byB = GetBValue (dwStartColor[wLoop]);
                wsprintf (szBuffer2, TEXT("%d %d %d"), byR, byG, byB);
                WritePrivateProfileString (szAppName, szBuffer, szBuffer2, szIniFile);

                /* Set the end color... */
                wsprintf (szBuffer, TEXT("EndColor%d"), wLoop + 1);
                byR = GetRValue (dwEndColor[wLoop]);
                byG = GetGValue (dwEndColor[wLoop]);
                byB = GetBValue (dwEndColor[wLoop]);
                wsprintf (szBuffer2, TEXT("%d %d %d"), byR, byG, byB);
                WritePrivateProfileString (szAppName, szBuffer, szBuffer2, szIniFile);
            }

        /* Bail out... */

        case IDCANCEL:
            EndDialog (hDlg, LOWORD(wParam) == IDOK);
            return TRUE;

        }
        break;

    case WM_DRAWITEM:
        return (BOOL)AppOwnerDraw (hDlg, message, wParam, lParam);

    case WM_MEASUREITEM:
        return (BOOL)AppOwnerDraw (hDlg, message, wParam, lParam);

    case WM_DELETEITEM:
        return (BOOL)AppOwnerDraw (hDlg, message, wParam, lParam);

    case WM_HELP: // F1
        WinHelp(
            (HWND) ((LPHELPINFO) lParam)->hItemHandle,
            szHelpFile,
            HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aMystDlgHelpIds
        );
        break;

    case WM_CONTEXTMENU:  // right mouse click
        WinHelp(
            (HWND) wParam,
            szHelpFile,
            HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aMystDlgHelpIds
        );
        break;

    default:
        break;
    }
    return FALSE;
}


VOID GetFields (VOID)
{
    WORD wLoop;
    //Load Global Strings from stringtable
    LoadString (hMainInstance, idsName, szName, CharSizeOf(szName));
    LoadString (hMainInstance, idsAppName, szAppName, CharSizeOf(szAppName));

    //Load Common Strings from stringtable...
    LoadString (hMainInstance, idsIniFile, szIniFile, CharSizeOf(szIniFile));
    LoadString (hMainInstance, idsScreenSaver, szScreenSaver, CharSizeOf(szScreenSaver));
    LoadString (hMainInstance, idsHelpFile, szHelpFile, CharSizeOf(szHelpFile));
    LoadString (hMainInstance, idsNoHelpMemory, szNoHelpMemory, CharSizeOf(szNoHelpMemory));

    /* Do we clear the screen when we start... */
    if ((fClearScreen = GetPrivateProfileInt (szAppName, szClearName, 1, szIniFile)) != 0)
        fClearScreen = 1;

    /* Loop through and get all of the field information... */
    for (wLoop = 0; wLoop < NUMBER_POLYGONS; wLoop++)
    {
        /* Get the activation state... */
        wsprintf (szBuffer, TEXT("Active%d"), wLoop + 1);
        if ((fOn[wLoop] = GetPrivateProfileInt (szAppName, szBuffer, 1, szIniFile)) != 0)
            fOn[wLoop] = 1;

        /* Get the walk state... */
        wsprintf (szBuffer, TEXT("WalkRandom%d"), wLoop + 1);
        if ((fWalk[wLoop] = GetPrivateProfileInt (szAppName, szBuffer, 1, szIniFile)) != 0)
            fWalk[wLoop] = 1;

        /* Get the number of lines for the current polygon... */
        wsprintf (szBuffer, TEXT("Lines%d"), wLoop + 1);
        wLines[wLoop] = (WORD) GetPrivateProfileInt (szAppName, szBuffer, 5, szIniFile);
        if ((int)wLines[wLoop] < 1)
            wLines[wLoop] = 1;
        if (wLines[wLoop] > MAXLINES)
            wLines[wLoop] = MAXLINES;

        /* Get the starting and ending colors (stored in DWORD format)... */
        wsprintf (szBuffer, TEXT("StartColor%d"), wLoop + 1);
        dwStartColor[wLoop] = GetProfileRgb (szAppName, szBuffer, RGB (0, 0, 0));
        wsprintf (szBuffer, TEXT("EndColor%d"), wLoop + 1);
        dwEndColor[wLoop] = GetProfileRgb (szAppName, szBuffer, RGB (255, 255, 255));
    }

    return;
}


VOID DrawPolygon (HDC hDC, HPEN hPen, WORD wPolygon, WORD wLine)
{
    HANDLE          hOldPen;
    WORD            wLoop1;

    hOldPen = SelectObject (hDC, hPen);
    MoveToEx (hDC, ptBox[wPolygon*MAXLINES+wLine][0].x,
                                ptBox[wPolygon*MAXLINES+wLine][0].y, NULL);
    for (wLoop1 = 0; wLoop1 < 4; wLoop1++)
        LineTo (hDC, ptBox[wPolygon*MAXLINES+wLine][(wLoop1+1)%4].x,
            ptBox[wPolygon*MAXLINES+wLine][(wLoop1+1)%4].y);
    if (hOldPen)
        SelectObject (hDC, hOldPen);
    return;
}

/* Adjust each of the rgb components according to the four input variables...*/

DWORD AdjustColor (DWORD dwSrc, DWORD dwDest, int nInc, int nCnt)
{
    DWORD dwTemp;
    WORD  wLoop;
    int      nSrc, nDst, nTmp;
    int      n1, n2, n3, n4, n5;

    /* Nullify the end value... */
    dwTemp = 0;

    /* Cycle through and compute the difference on each byte... */
    for (wLoop = 0; wLoop < 3; wLoop++)
    {
        nSrc = (int)((dwSrc >> (wLoop * 8)) % 256);
        nDst = (int)((dwDest >> (wLoop * 8)) % 256);
        n1 = nDst - nSrc;
        n2 = n1 * 10;
        n3 = n2 / nInc;
        n4 = n3 * nCnt;
        n5 = n4 / 10;
        nTmp = nSrc + n5;
        dwTemp += ((DWORD)nTmp) << (wLoop * 8);
    }
    return dwTemp;
}


/* Compute a random color that is within the accepted norms... */

DWORD GenerateColor (VOID)
{
    return (((DWORD)ZRAND (256)) + (((DWORD)ZRAND (256)) << 8) +
                    (((DWORD)ZRAND (256)) << 16));
}


/* Compute a random velocity that is within the accepted norms... */

WORD GenerateVelocity (VOID)
{
    return 255;
    return (RAND (30) + 20);
}


LONG AppOwnerDraw (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    RECT        rc;
    DWORD       rgbBg;
    static HBITMAP hbmCheck = NULL;
    LPMEASUREITEMSTRUCT     lpMIS = ((LPMEASUREITEMSTRUCT)lParam);
    LPDRAWITEMSTRUCT        lpDIS = ((LPDRAWITEMSTRUCT)lParam);

    switch (msg)
    {
    case WM_MEASUREITEM:
        lpMIS->itemHeight = 15;
        return TRUE;

    case WM_DRAWITEM:
        rc    = lpDIS->rcItem;
        rgbBg = PALETTEINDEX (lpDIS->itemID);

        if (lpDIS->itemState & ODS_SELECTED)
        {
            FrameR (lpDIS->hDC, &rc, rgbBlack, 2);
            InflateRect (&rc, -1, -1);
            FrameR (lpDIS->hDC, &rc, rgbWhite, 2);
            InflateRect (&rc, -1, -1);
        }
        if (lpDIS->itemState & ODS_DISABLED)
            FillR (lpDIS->hDC, &rc, rgbGrey);
        else
            FillR (lpDIS->hDC, &rc, rgbBg);
        return TRUE;

    case WM_DELETEITEM:
        return TRUE;
    }
    return TRUE;
}


VOID PatB (HDC hdc, int x, int y, int dx, int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor (hdc, rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut (hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}


VOID FillR (HDC hdc, LPRECT prc, DWORD rgb)
{
    SetBkColor (hdc, rgb);
    ExtTextOut (hdc, 0, 0, ETO_OPAQUE, prc, NULL, 0, NULL);
}


VOID FrameR (HDC hdc, LPRECT prc, DWORD rgb, int iFrame)
{
//    RECT    rc;
    int    dx, dy;

    dx = prc->right  - prc->left;
    dy = prc->bottom - prc->top - 2 * iFrame;

    PatB (hdc, prc->left, prc->top,          dx, iFrame,   rgb);
    PatB (hdc, prc->left, prc->bottom - iFrame, dx, iFrame,   rgb);

    PatB (hdc, prc->left,          prc->top + iFrame, iFrame, dy, rgb);
    PatB (hdc, prc->right - iFrame,  prc->top + iFrame, iFrame, dy, rgb);
}


BOOL DrawBitmap (HDC hdc, int x, int y, HBITMAP hbm, DWORD rop)
{
    HDC hdcBits;
    BITMAP bm;
//    HPALETTE hpalT;
    HBITMAP oldbm;
    BOOL f;

    if (!hdc || !hbm)
        return FALSE;

    hdcBits = CreateCompatibleDC (hdc);
    GetObject (hbm, sizeof (BITMAP), (LPTSTR) & bm);
    oldbm = SelectObject (hdcBits, hbm);
    f = BitBlt (hdc, x, y, bm.bmWidth, bm.bmHeight, hdcBits, 0, 0, rop);
    if (oldbm)
        SelectObject (hdcBits, oldbm);
    DeleteDC (hdcBits);

    return f;
}


DWORD GetProfileRgb (LPTSTR szApp, LPTSTR szItem, DWORD rgb)
{
    TCHAR    buf[80];
    LPTSTR   pch;
    WORD     r, g, b;

    GetPrivateProfileString (szApp, szItem, TEXT(""), buf, CharSizeOf(buf), szIniFile);

    if (*buf)
    {
        pch = buf;
        r = AtoI (pch);
        while (*pch && *pch != TEXT(' '))
            pch++;
        while (*pch && *pch == TEXT(' '))
            pch++;
        g = AtoI (pch);
        while (*pch && *pch != TEXT(' '))
            pch++;
        while (*pch && *pch == TEXT(' '))
            pch++;
        b = AtoI (pch);

        return RGB (r, g, b);
    }
    else
        return rgb;
}


WORD AtoI (LPTSTR lpszConvert)
{
    WORD wReturn = 0;

    while (*lpszConvert >= TEXT('0') && *lpszConvert <= TEXT('9'))
    {
        wReturn = wReturn * 10 + (WORD)(*lpszConvert - TEXT('0'));
        lpszConvert++;
    }
    return wReturn;
}


VOID ShadeWindows (HWND hDlg, WORD wPoly, WORD wPolygon)
{
    EnableWindow (GetDlgItem (hDlg, ID_COLORGROUP), fOn[wPolygon]);
    EnableWindow (GetDlgItem (hDlg, ID_2COLORS), fOn[wPolygon]);
    EnableWindow (GetDlgItem (hDlg, ID_RANDOMCOLORS), fOn[wPolygon]);
    EnableWindow (GetDlgItem (hDlg, ID_LINES), fOn[wPolygon]);
    EnableWindow (GetDlgItem (hDlg, ID_LINESARROW), fOn[wPolygon]);
    EnableWindow (GetDlgItem (hDlg, ID_COLOR1), !fWalk[wPolygon] && fOn[wPolygon]);
    InvalidateRect (GetDlgItem (hDlg, ID_COLOR1), NULL, TRUE);
    EnableWindow (GetDlgItem (hDlg, ID_COLOR2), !fWalk[wPolygon] && fOn[wPolygon]);
    InvalidateRect (GetDlgItem (hDlg, ID_COLOR2), NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\eval.cpp ===
//-----------------------------------------------------------------------------
// File: eval.cpp
//
// Desc: EVAL class
//       Evaluator composed of one or more sections that are evaluated
//       separately with OpenGL evaluators
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"

typedef enum 
{
    X_PLANE = 0,
    Y_PLANE,
    Z_PLANE
};

#define EVAL_VSIZE 3  // vertex size in floats

#define TMAJOR_ORDER 2
#define TMINOR_ORDER 2

#define VDIM 3
#define TDIM 2

static void RotatePointSet( D3DXVECTOR3 *inPts, int numPts, float angle, int dir, 
                      float radius, D3DXVECTOR3 *outPts );
static void ExtrudePointSetDir( D3DXVECTOR3 *inPts, int numPts, float *acPts, 
                      int dir, D3DXVECTOR3 *outPts );




//-----------------------------------------------------------------------------
// Name: EVAL
// Desc: Evaluator constructor
//-----------------------------------------------------------------------------
EVAL::EVAL( BOOL bTex )
{
    m_bTexture = bTex; 

    // Allocate points buffer

    //mf: might want to use less than max in some cases
    int size = MAX_USECTIONS * MAX_UORDER * MAX_VORDER * sizeof(D3DXVECTOR3);
    m_pts = (D3DXVECTOR3 *) LocalAlloc( LMEM_FIXED, size );
    assert( m_pts != NULL && "EVAL constructor\n" );
    
    // Alloc texture points buffer
    if( m_bTexture ) 
    {
        size = MAX_USECTIONS * TEX_ORDER * TEX_ORDER * sizeof(TEX_POINT2D);
        m_texPts = (TEX_POINT2D *) LocalAlloc( LMEM_FIXED, size );
        assert( m_texPts != NULL && "EVAL constructor\n" );
    }
    
    ResetEvaluator( m_bTexture );
}




//-----------------------------------------------------------------------------
// Name: ~EVAL
// Desc: Evaluator destructor
//-----------------------------------------------------------------------------
EVAL::~EVAL( )
{
    LocalFree( m_pts );
    if( m_bTexture )
        LocalFree( m_texPts );
}




//-----------------------------------------------------------------------------
// Name: Reset
// Desc: Reset evaluator to generate 3d vertices and vertex normals
//-----------------------------------------------------------------------------
void ResetEvaluator( BOOL bTexture )
{
/*
    if( bTexture ) 
    {
        glEnable( GL_MAP2_TEXTURE_COORD_2 );
    }

    glEnable( GL_MAP2_VERTEX_3 );
    glEnable( GL_AUTO_NORMAL );
    glFrontFace( GL_CW ); // cuz
*/

    // mf: !!! if mixing Normal and Flex, have to watch out for this, cuz normal
    // needs CCW
}




//-----------------------------------------------------------------------------
// Name: SetTextureControlPoints
// Desc: Set texture control point net
//       
//       This sets up 'numSections' sets of texture coordinate control points, based
//       on starting and ending s and t values.
//       
//       s coords run along pipe direction, t coords run around circumference
//-----------------------------------------------------------------------------
void EVAL::SetTextureControlPoints( float s_start, float s_end, 
                                    float t_start, float t_end )
{
    int i;
    TEX_POINT2D *ptexPts = m_texPts;
    float t_delta = (t_end - t_start) / m_numSections;
    float t = t_start;

    // calc ctrl pts for each quadrant
    for( i = 0; i < m_numSections; i++, ptexPts += (TDIM*TDIM) ) 
    {
        // s, t coords
        ptexPts[0].t = ptexPts[2].t = t;
        t += t_delta;
        ptexPts[1].t = ptexPts[3].t = t;
        ptexPts[0].s = ptexPts[1].s = s_start;
        ptexPts[2].s = ptexPts[3].s = s_end;
    } 
}




//-----------------------------------------------------------------------------
// Name: SetVertexCtrlPtsXCTranslate
// Desc: Builds 3D control eval control net from 2 xcObjs displaced along the
//       z-axis by 'length'.
//       
//       First xc used to generate points in z=0 plane.
//       Second xc generates points in z=length plane.
//       ! Replicates the last point around each u.
//-----------------------------------------------------------------------------
void EVAL::SetVertexCtrlPtsXCTranslate( D3DXVECTOR3 *pts, float length, 
                                        XC *xcStart, XC *xcEnd )
{
    int i;
    D3DXVECTOR2 *ptsStart, *ptsEnd;
    D3DXVECTOR3 *pts1, *pts2;
    int     numPts = xcStart->m_numPts;

    numPts++;  // due to last point replication

    ptsStart = xcStart->m_pts;
    ptsEnd   = xcEnd->m_pts;
    pts1     = pts;
    pts2     = pts + numPts;

    for( i = 0; i < (numPts-1); i++, pts1++, pts2++ ) 
    {
        // copy over x,y from each xc
        *( (D3DXVECTOR2 *) pts1) = *ptsStart++;
        *( (D3DXVECTOR2 *) pts2) = *ptsEnd++;
        // set z for each
        pts1->z = 0.0f;
        pts2->z = length;
    }

    // Replicate last point in each u-band
    *pts1 = *pts;
    *pts2 = *(pts + numPts);
}




//-----------------------------------------------------------------------------
// Name: ProcessXCPrimLinear
// Desc: Processes a prim according to evaluator data
//       - Only valid for colinear xc's (along z)
//       - XC's may be identical (extrusion).  If not identical, may have
//         discontinuities at each end.
//       - Converts 2D XC pts to 3D pts
//-----------------------------------------------------------------------------
void EVAL::ProcessXCPrimLinear( XC *xcStart, XC *xcEnd, float length )
{
    if( length <= 0.0f )
        // nuttin' to do
        return;

    // Build a vertex control net from 2 xcObj's a distance 'length' apart
    // this will displace the end xcObj a distance 'length' down the z-axis
    SetVertexCtrlPtsXCTranslate( m_pts, length, xcStart, xcEnd );

    Evaluate( );
}




//-----------------------------------------------------------------------------
// Name: ProcessXCPrimBendSimple
// Desc: Processes a prim by bending along dir from xcCur
//       - dir is relative from xc in x-y plane
//       - adds C2 continuity at ends
//-----------------------------------------------------------------------------
void EVAL::ProcessXCPrimBendSimple( XC *xcCur, int dir, float radius )
{
    D3DXVECTOR3 *ptsSrc, *ptsDst;
    static float acPts[MAX_XC_PTS+1];
    int ptSetStride = xcCur->m_numPts + 1; // pt stride for output pts buffer

    // We will be creating 4 cross-sectional control point sets here.

    // Convert 2D pts in xcCur to 3D pts at z=0 for 1st point set
    xcCur->ConvertPtsZ( m_pts, 0.0f );

    // Calc 4th point set by rotating 1st set as per dir
    ptsDst = m_pts + 3*ptSetStride;
    RotatePointSet( m_pts, ptSetStride, 90.0f, dir, radius, ptsDst );

    // angles != 90, hard, cuz not easy to extrude 3rd set from 4th

    // Next, have to figure out ac values.  Need to extend each xc's points
    // into bend to generate ac net.  For circular bend (and later for general
    // case elliptical bend), need to know ac distance from xc for each point.
    // This is based on the point's turn radius - a function of its distance
    // from the 'hinge' of the turn.

    // Can take advantage of symmetry here.  Figure for one xc, good for 2nd.
    // This assumes 90 deg turn.  (also,last point replicated)
    xcCur->CalcArcACValues90( dir, radius, acPts );
    
    // 2) extrude each point's ac from xcCur (extrusion in +z)
    // apply values to 1st to get 2nd
    // MINUS_Z, cuz subtracts *back* from dir
    ExtrudePointSetDir( m_pts, ptSetStride, acPts, MINUS_Z, 
                                                    m_pts + ptSetStride );

    // 3) extrude each point's ac from xcEnd (extrusion in -dir)
    ptsSrc = m_pts + 3*ptSetStride;
    ptsDst = m_pts + 2*ptSetStride;
    ExtrudePointSetDir( ptsSrc, ptSetStride, acPts, dir, ptsDst );

    Evaluate();
}




//-----------------------------------------------------------------------------
// Name: EVAL::ProcessXCPrimSingularity
// Desc: Processes a prim by joining singularity to an xc
//       - Used for closing or opening the pipe
//       - If bOpening is true, starts with singularity, otherwise ends with one
//       - the xc side is always in z=0 plane
//       - singularity side is radius on either side of xc
//       - adds C2 continuity at ends (perpendicular to +z at singularity end)
//-----------------------------------------------------------------------------
void EVAL::ProcessXCPrimSingularity( XC *xcCur, float length, BOOL bOpening )
{
    D3DXVECTOR3 *ptsSing, *ptsXC;
    static float acPts[MAX_XC_PTS+1];
    float zSing; // z-value at singularity
    int ptSetStride = xcCur->m_numPts + 1; // pt stride for output pts buffer
    int i;
    XC xcSing(xcCur);

    // create singularity xc - which is an extremely scaled-down version
    //  of xcCur (this prevents any end-artifacts, unless of course we were
    //  to zoom it ultra-large).

    xcSing.Scale( .0005f );

    // We will be creating 4 cross-sectional control point sets here.
    // mf: 4 is like hard coded; what about for different xc component levels ?

    if( bOpening ) 
    {
        ptsSing = m_pts;
        ptsXC = m_pts + 3*ptSetStride;
    } 
    else 
    {
        ptsSing = m_pts + 3*ptSetStride;
        ptsXC = m_pts;
    }

    // Convert 2D pts in xcCur to 3D pts at 'xc' point set
    xcCur->ConvertPtsZ( ptsXC, 0.0f );

    // Set z-value for singularity point set
    zSing = bOpening ? -length : length;
    xcSing.ConvertPtsZ( ptsSing, zSing );

    // The arc control for each point is based on a radius value that is
    //  each xc point's distance from the xc center
    xcCur->CalcArcACValuesByDistance( acPts );

    // Calculate point set near xc
    if( bOpening )
        ExtrudePointSetDir( ptsXC, ptSetStride, acPts, PLUS_Z, 
                                                    ptsXC - ptSetStride );
    else
        ExtrudePointSetDir( ptsXC, ptSetStride, acPts, MINUS_Z, 
                                                    ptsXC + ptSetStride );

    // Point set near singularity is harder, as the points must generate
    // a curve between the singularity and each xc point
    // No, easier, just scale each point by universal arc controller !
    D3DXVECTOR3* ptsDst = m_pts;
    ptsDst = bOpening ? ptsSing + ptSetStride : ptsSing - ptSetStride;
    for( i = 0; i < ptSetStride; i ++, ptsDst++ ) 
    {
        ptsDst->x = EVAL_CIRC_ARC_CONTROL * ptsXC[i].x;
        ptsDst->y = EVAL_CIRC_ARC_CONTROL * ptsXC[i].y;
        ptsDst->z = zSing;
    }

    Evaluate();
}




//-----------------------------------------------------------------------------
// Name: Evaluate
// Desc: Evaluates the EVAL object
//       - There may be 1 or more lengthwise sections around an xc
//       - u is minor, v major
//       - u,t run around circumference, v,s lengthwise
//       - Texture maps are 2x2 for each section
//       - ! uDiv is per section !
//-----------------------------------------------------------------------------
void EVAL::Evaluate()
{
    int i;
    D3DXVECTOR3 *ppts = m_pts; 
    TEX_POINT2D *ptexPts = m_texPts;
    // total # pts in cross-section:
    int xcPointCount = (m_uOrder-1)*m_numSections + 1;

    for( i = 0; i < m_numSections; i ++, 
                                 ppts += (m_uOrder-1),
                                 ptexPts += (TEX_ORDER*TEX_ORDER) ) 
    {
/*
        // map texture coords
        if( bTexture ) 
        {
            glMap2f(GL_MAP2_TEXTURE_COORD_2, 
                    0.0f, 1.0f, TDIM, TEX_ORDER, 
                    0.0f, 1.0f, TEX_ORDER*TDIM, TEX_ORDER, 
                    (float *) ptexPts );
        }

        // map vertices
        glMa
        
          p2f(GL_MAP2_VERTEX_3, 
               0.0f, 1.0f, VDIM, uOrder, 
               0.0f, 1.0f, xcPointCount*VDIM, vOrder,
               (float *) ppts );

        // evaluate
        glMapGrid2f(uDiv, 0.0f, 1.0f, ``vDiv, 0.0f, 1.0f);
        glEvalMesh2( GL_FILL, 0, uDiv, 0, vDiv);
*/
    }
}




//-----------------------------------------------------------------------------
// Name: ExtrudePointSetDir
// Desc: Extrude a point set back from the current direction
//       Generates C2 continuity at the supplied point set xc, by generating another
//       point set back of the first, using supplied subtraction values.
//-----------------------------------------------------------------------------
static void ExtrudePointSetDir( D3DXVECTOR3 *inPts, int numPts, float *acPts, int dir, 
                                D3DXVECTOR3 *outPts )
{
    int i;
    float sign;
    int offset;

    switch( dir ) 
    {
        case PLUS_X:
            offset = 0;
            sign = -1.0f;
            break;
        case MINUS_X:
            offset = 0;
            sign =  1.0f;
            break;
        case PLUS_Y:
            offset = 1;
            sign = -1.0f;
            break;
        case MINUS_Y:
            offset = 1;
            sign =  1.0f;
            break;
        case PLUS_Z:
            offset = 2;
            sign = -1.0f;
            break;
        case MINUS_Z:
            offset = 2;
            sign =  1.0f;
            break;
    }

    for( i = 0; i < numPts; i++, inPts++, outPts++, acPts++ ) 
    {
        *outPts = *inPts;
        ((float *)outPts)[offset] = ((float *)inPts)[offset] + (sign * (*acPts));
    }
}




//-----------------------------------------------------------------------------
// Name: RotatePointSet
// Desc: Rotate point set by angle, according to dir and radius
//       - Put points in supplied outPts buffer
//-----------------------------------------------------------------------------
static void RotatePointSet( D3DXVECTOR3 *inPts, int numPts, float angle, int dir, 
                            float radius, D3DXVECTOR3 *outPts )
{
    D3DXMATRIX matrix1, matrix2, matrix3;
    int i;
    D3DXVECTOR3 rot = D3DXVECTOR3(0, 0, 0);
    D3DXVECTOR3 anchor = D3DXVECTOR3(0, 0, 0);

    //  dir      rot
    //  +x       90 y
    //  -x       -90 y
    //  +y       -90 x
    //  -y       90 x

    // convert angle to radians
    //mf: as noted in objects.c, we have to take negative angle to make
    // it work in familiar 'CCW rotation is positive' mode.  The ss_* rotate
    // routines must work in the 'CW is +'ve' mode, as axis pointing at you.
    angle = SS_DEG_TO_RAD(-angle);

    // set axis rotation and anchor point
    switch( dir ) 
    {
        case PLUS_X:
            rot.y = angle;
            anchor.x = radius;
            break;
        case MINUS_X:
            rot.y = -angle;
            anchor.x = -radius;
            break;
        case PLUS_Y:
            rot.x = -angle;
            anchor.y = radius;
            break;
        case MINUS_Y:
            rot.x = angle;
            anchor.y = -radius;
            break;
    }

    // translate anchor point to origin
    D3DXMatrixIdentity( &matrix1 );
    D3DXMatrixTranslation( &matrix1, -anchor.x, -anchor.y, -anchor.z );

    // rotate 
    D3DXMatrixIdentity( &matrix2 );
    D3DXMatrixRotationYawPitchRoll( &matrix2, rot.y, rot.x, rot.z ); // TODO: right?

    // concat these 2
    D3DXMatrixMultiply( &matrix3, &matrix2, &matrix1 );

    // translate back
    D3DXMatrixIdentity( &matrix2 );
    D3DXMatrixTranslation( &matrix2,  anchor.x,  anchor.y,  anchor.z );

    // concat these 2
    D3DXMatrixMultiply( &matrix1, &matrix2, &matrix3 );

    for( i = 0; i < numPts; i ++, outPts++, inPts++ ) 
    {
        // D3DXVec3TransformCoord( &tmp, inPts, &matrix1 ); // TODO: which?

        D3DXVECTOR4 tmp;
        D3DXVec3Transform( &tmp, inPts, &matrix1 );
        outPts->x = tmp.x;
        outPts->y = tmp.y;
        outPts->z = tmp.z;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\eval.h ===
//-----------------------------------------------------------------------------
// File: eval.h
//
// Desc: EVAL class
//       Evaluator composed of one or more sections that are evaluated
//       separately with OpenGL evaluators
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __EVAL_H__
#define __EVAL_H__

#define MAX_UORDER                      5 // this is per section
#define MAX_VORDER                      5
#define MAX_USECTIONS                   4
#define MAX_XC_PTS                      (MAX_UORDER * MAX_USECTIONS)

#define TEX_ORDER                       2
#define EVAL_ARC_ORDER                  4
#define EVAL_CYLINDER_ORDER             2
#define EVAL_ELBOW_ORDER                4

// # of components (eg. arcs) to form a complete cross-section
#define EVAL_XC_CIRC_SECTION_COUNT      4
#define EVAL_XC_POINT_COUNT             ( (EVAL_ARC_ORDER-1)*4 + 1 )
#define EVAL_CIRC_ARC_CONTROL           0.56f // for r=1




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class EVAL 
{
public:
    int             m_numSections;    // number of cross-sectional sections
    int             m_uOrder, m_vOrder;
    
    // assumed: all sections same order - uOrder is per
    // section; sections share vertex and texture control points
    int             m_uDiv, m_vDiv;    // figured out one level up ?
    D3DXVECTOR3*    m_pts;          // vertex control points

    // - texture always order 2 for s and t (linear mapping)
    BOOL            m_bTexture;
    TEX_POINT2D*    m_texPts;       // texture control points

    EVAL( BOOL bTexture );
    ~EVAL();

    void        Evaluate(); // evaluate/render the object
    void        SetVertexCtrlPtsXCTranslate( D3DXVECTOR3 *pts, float length, 
                                             XC *xcStart, XC *xcEnd );
    void        SetTextureControlPoints( float s_start, float s_end,
                                         float t_start, float t_end );
    void        ProcessXCPrimLinear( XC *xcStart, XC *xcEnd, float length );
    void        ProcessXCPrimBendSimple( XC *xcCur, int dir, float radius );
    void        ProcessXCPrimSingularity( XC *xcCur, float length, 
                                          BOOL bOpening );
};

extern void ResetEvaluator( BOOL bTexture );

#endif // __EVAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\fpipe.cpp ===
//-----------------------------------------------------------------------------
// File: fpipe.cpp
//
// Desc: Flex pipes
//
//       All Draw routines start with current xc at the beginning, and create
//       a new one at the end.  Since it is common to just have 2 xc's for
//       each prim, xcCur holds the current xc, and xcEnd is available
//       for the draw routine to use as the end xc.
//       They also reset xcCur when done
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"

// defCylNotch shows the absolute notch for the default cylinder,
// given a direction (notch is always along +x axis)
static int defCylNotch[NUM_DIRS] = 
        { MINUS_Z, PLUS_Z, PLUS_X, PLUS_X, PLUS_X, MINUS_X };

static int GetRelativeDir( int lastDir, int notchVec, int newDir );




//-----------------------------------------------------------------------------
// Name: FLEX_PIPE constructor
// Desc: 
//-----------------------------------------------------------------------------
FLEX_PIPE::FLEX_PIPE( STATE *pState ) : PIPE( pState )
{
    float circ;

    // Create an EVAL object
    m_nSlices = pState->m_nSlices;

    // No XC's yet, they will be allocated at pipe Start()
    m_xcCur = m_xcEnd = NULL;

    // The EVAL will be used for all pEvals in the pipe, so should be
    // set to hold max. possible # of pts for the pipe.
    m_pEval = new EVAL( m_pState->m_bUseTexture );

    // Determine pipe tesselation
    // For now, this is based on global tesselation factor

//mf: maybe clean up this scheme a bit
    // Calculate evalDivSize, a reference value for the size of a UxV division.
    // This is used later for calculating texture coords.
    circ = CIRCUMFERENCE( pState->m_radius );
    m_evalDivSize = circ / (float) m_nSlices;
}




//-----------------------------------------------------------------------------
// Name: ~FLEX_PIPE
// Desc: 
//-----------------------------------------------------------------------------
FLEX_PIPE::~FLEX_PIPE( )
{
    delete m_pEval;

    // delete any XC's
    if( m_xcCur != NULL ) 
    {
        if( m_xcEnd == m_xcCur )
//mf: so far this can't happen...
            m_xcEnd = NULL; // xcCur and xcEnd can point to same xc !
        delete m_xcCur;
        m_xcCur = NULL;
    }

    if( m_xcEnd != NULL ) 
    {
        delete m_xcEnd;
        m_xcEnd = NULL;
    }
}




//-----------------------------------------------------------------------------
// Name: REGULAR_FLEX_PIPE constructor
// Desc: 
//-----------------------------------------------------------------------------
REGULAR_FLEX_PIPE::REGULAR_FLEX_PIPE( STATE *state ) : FLEX_PIPE( state )
{
    static float turnFactorRange = 0.1f;
    m_type = TYPE_FLEX_REGULAR;

    // figure out turning factor range (0 for min bends, 1 for max bends)
#if 1
    float avgTurn = CPipesScreensaver::fRand( 0.11f, 0.81f );
    // set min and max turn factors, and clamp to 0..1
    m_turnFactorMin = 
                SS_CLAMP_TO_RANGE( avgTurn - turnFactorRange, 0.0f, 1.0f );
    m_turnFactorMax = 
                SS_CLAMP_TO_RANGE( avgTurn + turnFactorRange, 0.0f, 1.0f );
#else
// debug: test max bend
    turnFactorMin = turnFactorMax = 1.0f;
#endif

    // choose straight weighting
// mf:for now, same as npipe - if stays same, put in pipe
    if( !CPipesScreensaver::iRand( 20 ) )
        m_weightStraight = CPipesScreensaver::iRand2( MAX_WEIGHT_STRAIGHT/4, MAX_WEIGHT_STRAIGHT );
    else
        m_weightStraight = CPipesScreensaver::iRand( 4 );
}




//-----------------------------------------------------------------------------
// Name: TURNING_FLEX_PIPE constructor
// Desc: 
//-----------------------------------------------------------------------------
TURNING_FLEX_PIPE::TURNING_FLEX_PIPE( STATE *state ) : FLEX_PIPE( state )
{
    m_type = TYPE_FLEX_TURNING;
}




//-----------------------------------------------------------------------------
// Name: SetTexIndex
// Desc: Set the texture index for this pipe, and calculate texture state dependent
//       on texRep values
//-----------------------------------------------------------------------------
void FLEX_PIPE::SetTexParams( TEXTUREINFO *pTex, IPOINT2D *pTexRep )
{
    if( m_pState->m_bUseTexture ) 
    {
/*
        float m_tSize;
        float circ;

        m_tStart = (float) pTexRep->y * 1.0f;
        m_tEnd = 0.0f;

        // calc height (m_tSize) of one rep of texture around circumference
        circ = CIRCUMFERENCE( m_radius );
        m_tSize = circ / pTexRep->y;

        // now calc corresponding width of the texture using its x/y ratio
        m_sLength = m_tSize / pTex->origAspectRatio;
        m_sStart = m_sEnd = 0.0f;
*/
//mf: this means we are 'standardizing' the texture size and proportions
// on pipe of radius 1.0 for entire program.  Might want to recalc this on
// a per-pipe basis ?
    }
}




//-----------------------------------------------------------------------------
// Name: ChooseXCProfile
// Desc: Initialize extruded pipe scheme.  This uses a randomly constructed 
//       XC, but it remains constant throughout the pipe
//-----------------------------------------------------------------------------
void FLEX_PIPE::ChooseXCProfile()
{
    static float turnFactorRange = 0.1f;
    float baseRadius = m_pState->m_radius;

    // initialize evaluator elements:
    m_pEval->m_numSections = EVAL_XC_CIRC_SECTION_COUNT;
    m_pEval->m_uOrder = EVAL_ARC_ORDER;

//mf: watch this - maybe should ROUND_UP uDiv
    // set uDiv per section (assumed uDiv multiple of numSections)
    m_pEval->m_uDiv = m_nSlices / m_pEval->m_numSections;

    // Setup XC's

    // The xc profile remains constant throughout in this case,
    // so we only need one xc.

    // Choose between elliptical or random cross-sections.  Since elliptical
    //  looks a little better, make it more likely
    if( CPipesScreensaver::iRand(4) )  // 3/4 of the time
        m_xcCur = new ELLIPTICAL_XC( CPipesScreensaver::fRand(1.2f, 2.0f) * baseRadius, 
                                           baseRadius );
    else
        m_xcCur = new RANDOM4ARC_XC( CPipesScreensaver::fRand(1.5f, 2.0f) * baseRadius );
}




//-----------------------------------------------------------------------------
// Name: REGULAR_FLEX_PIPE::Start
// Desc: Does startup of extruded-XC pipe drawing scheme 
//-----------------------------------------------------------------------------
void REGULAR_FLEX_PIPE::Start()
{
    NODE_ARRAY* nodes = m_pState->m_nodes;
    int newDir;

    // Set start position
    if( !SetStartPos() ) 
    {
        m_status = PIPE_OUT_OF_NODES;
        return;
    }

    // set material
    ChooseMaterial();

    // set XC profile
    ChooseXCProfile();

    // push matrix with zTrans and scene rotation
//    glPushMatrix();

    // Translate to current position
    TranslateToCurrentPosition();

    // set random lastDir
    m_lastDir = CPipesScreensaver::iRand( NUM_DIRS );

    // get a new node to draw to
    newDir = ChooseNewDirection();

    if( newDir == DIR_NONE ) 
    {
        // draw like one of those tea-pouring thingies...
        m_status = PIPE_STUCK;
//        glPopMatrix();
        return;
    } 
    else
    {
        m_status = PIPE_ACTIVE;
    }

    align_plusz( newDir ); // get us pointed in right direction

    // draw start cap, which will end right at current node
    DrawCap( START_CAP );

    // set initial notch vector, which is just the default notch, since
    // we didn't have to spin the start cap around z
    m_notchVec = defCylNotch[newDir];

    m_zTrans = - m_pState->m_view.m_divSize;  // distance back from new node

    UpdateCurrentPosition( newDir );

    m_lastDir = newDir;
}




//-----------------------------------------------------------------------------
// Name: TURNING_FLEX_PIPE::Start
// Desc: Does startup of turning extruded-XC pipe drawing scheme 
//-----------------------------------------------------------------------------
void TURNING_FLEX_PIPE::Start( )
{
    NODE_ARRAY* nodes = m_pState->m_nodes;

    // Set start position

    if( !SetStartPos() ) 
    {
        m_status = PIPE_OUT_OF_NODES;
        return;
    }

    // Set material
    ChooseMaterial();

    // Set XC profile
    ChooseXCProfile();

    // Push matrix with zTrans and scene rotation
//    glPushMatrix();

    // Translate to current position
    TranslateToCurrentPosition();

    // lastDir has to be set to something valid, in case we get stuck right
    // away, cuz Draw() will be called anyways on next iteration, whereupon
    // it finds out it really is stuck, AFTER calling ChooseNewTurnDirection,
    // which requires valid lastDir. (mf: fix this)
    m_lastDir = CPipesScreensaver::iRand( NUM_DIRS );

    // Pick a starting direction by finding a neihgbouring empty node
    int newDir = nodes->FindClearestDirection( &m_curPos );
    // We don't 'choose' it, or mark it as taken, because ChooseNewDirection
    // will always check it anyways

    if( newDir == DIR_NONE ) 
    {
        // we can't go anywhere
        // draw like one of those tea-pouring thingies...
        m_status = PIPE_STUCK;
//        glPopMatrix();
        return;
    } 
    else
    {
        m_status = PIPE_ACTIVE;
    }

    align_plusz( newDir ); // get us pointed in right direction

    // Draw start cap, which will end right at current node
    DrawCap( START_CAP );

    // Set initial notch vector, which is just the default notch, since
    // we didn't have to spin the start cap around z
    m_notchVec = defCylNotch[newDir];

    m_zTrans = 0.0f;  // right at current node

    m_lastDir = newDir;
}




//-----------------------------------------------------------------------------
// Name: REGULAR_FLEX_PIPE::Draw
// Desc: Draws the pipe using a constant random xc that is extruded
// 
//       Minimum turn radius can vary, since xc is not symmetrical across any
//       of its axes.  Therefore here we draw using a pipe/elbow sequence, so we
//       know what direction we're going in before drawing the elbow.  The current
//       node is the one we will draw thru next time.  Typically, the actual end
//       of the pipe is way back of this node, almost at the previous node, due
//       to the variable turn radius
//-----------------------------------------------------------------------------
void REGULAR_FLEX_PIPE::Draw()
{
    float turnRadius, minTurnRadius;
    float pipeLen, maxPipeLen, minPipeLen;
    int newDir, relDir;
    float maxXCExtent;
    NODE_ARRAY* nodes = m_pState->m_nodes;
    float divSize = m_pState->m_view.m_divSize;

    // get new direction

    newDir = ChooseNewDirection();
    if( newDir == DIR_NONE ) 
    {
        m_status = PIPE_STUCK;
        DrawCap( END_CAP );
//        glPopMatrix();
        return;
    }

    // draw pipe, and if turning, joint
    if( newDir != m_lastDir ) 
    { 
        // turning! - we have to draw joint

        // get relative turn, to figure turn radius

        relDir = GetRelativeDir( m_lastDir, m_notchVec, newDir );
        minTurnRadius = m_xcCur->MinTurnRadius( relDir );

        // now calc maximum straight section we can draw before turning
        // zTrans is current pos'n of end of pipe, from current node ??
        // zTrans is current pos'n of end of pipe, from last node

        maxPipeLen = (-m_zTrans) - minTurnRadius;

        // there is also a minimum requirement for the length of the straight
        // section, cuz if we turn too soon with a large turn radius, we
        // will swing up too close to the next node, and won't be able to
        // make one or more of the 4 possible turns from that point

        maxXCExtent = m_xcCur->MaxExtent(); // in case need it again
        minPipeLen = maxXCExtent - (divSize + m_zTrans);
        if( minPipeLen < 0.0f )
            minPipeLen = 0.0f;

        // Choose length of straight section
        // (we are translating from turnFactor to 'straightFactor' here)
        pipeLen = minPipeLen +
            CPipesScreensaver::fRand( 1.0f - m_turnFactorMax, 1.0f - m_turnFactorMin ) * 
                        (maxPipeLen - minPipeLen);

        // turn radius is whatever's left over:
        turnRadius = maxPipeLen - pipeLen + minTurnRadius;

        // draw straight section
        DrawExtrudedXCObject( pipeLen );
        m_zTrans += pipeLen; // not necessary for now, since elbow no use

        // draw elbow
        // this updates axes, notchVec to position at end of elbow
        DrawXCElbow( newDir, turnRadius );

        m_zTrans = -(divSize - turnRadius);  // distance back from node
    }
    else 
    {  
        // no turn

        // draw a straight pipe through the current node
        // length can vary according to the turnFactors (e.g. for high turn
        // factors draw a short pipe, so next turn can be as big as possible)

        minPipeLen = -m_zTrans; // brings us just up to last node
        maxPipeLen = minPipeLen + divSize - m_xcCur->MaxExtent();
        // brings us as close as possible to new node

        pipeLen = minPipeLen +
            CPipesScreensaver::fRand( 1.0f - m_turnFactorMax, 1.0f - m_turnFactorMin ) * 
                                      (maxPipeLen - minPipeLen);

        // draw pipe
        DrawExtrudedXCObject( pipeLen );
        m_zTrans += (-divSize + pipeLen);
    }

    UpdateCurrentPosition( newDir );

    m_lastDir = newDir;
}




//-----------------------------------------------------------------------------
// Name: DrawTurningXCPipe
// Desc: Draws the pipe using only turns
//          - Go straight if no turns available
//-----------------------------------------------------------------------------
void TURNING_FLEX_PIPE::Draw()
{
    float turnRadius;
    int newDir;
    NODE_ARRAY *nodes = m_pState->m_nodes;
    float divSize = m_pState->m_view.m_divSize;

    // get new direction

//mf: pipe may have gotten stuck on Start...(we don't check for this)

    newDir = nodes->ChooseNewTurnDirection( &m_curPos, m_lastDir );
    if( newDir == DIR_NONE ) 
    {
        m_status = PIPE_STUCK;
        DrawCap( END_CAP );
//        glPopMatrix();
        return;
    }

    if( newDir == DIR_STRAIGHT ) 
    {
        // No turns available - draw straight section and hope for turns
        //  on next iteration
        DrawExtrudedXCObject( divSize );
        UpdateCurrentPosition( m_lastDir );
        // ! we have to mark node as taken for this case, since
        // ChooseNewTurnDirection doesn't know whether we're taking the
        // straight option or not
        nodes->NodeVisited( &m_curPos );
    } 
    else 
    {
        // draw turning pipe

        // since xc is always located right at current node, turn radius
        // stays constant at one node division

        turnRadius = divSize;

        DrawXCElbow( newDir, turnRadius );

        // (zTrans stays at 0)

        // need to update 2 nodes
        UpdateCurrentPosition( m_lastDir );
        UpdateCurrentPosition( newDir );

        m_lastDir = newDir;
    }
}




//-----------------------------------------------------------------------------
// Name: DrawXCElbow
// Desc: Draw elbow from current position through new direction
//          - Extends current xc around bend
//          - Radius of bend is provided - this is distance from xc center to hinge
//            point, along newDir.  e.g. for 'normal pipes', radius=vc->radius
//-----------------------------------------------------------------------------
void FLEX_PIPE::DrawXCElbow( int newDir, float radius )
{
    int relDir;  // 'relative' direction of turn
    float length;

    length = (2.0f * PI * radius) / 4.0f; // average length of elbow

    // calc vDiv, texture params based on length
//mf: I think we should improve resolution of elbows - more vDiv's
// could rewrite this fn to take a vDivSize
    CalcEvalLengthParams( length );

    m_pEval->m_vOrder = EVAL_ARC_ORDER;

    // convert absolute dir to relative dir
    relDir = GetRelativeDir( m_lastDir, m_notchVec, newDir );

    // draw it - call simple bend function

    m_pEval->ProcessXCPrimBendSimple( m_xcCur, relDir, radius );
/*
    // set transf. matrix to new position by translating/rotating/translating
    // ! Based on simple elbow
    glTranslatef( 0.0f, 0.0f, radius );
    switch( relDir ) 
    {
        case PLUS_X:
            glRotatef( 90.0f, 0.0f, 1.0f, 0.0f );
            break;
        case MINUS_X:
            glRotatef( -90.0f, 0.0f, 1.0f, 0.0f );
            break;
        case PLUS_Y:
            glRotatef( -90.0f, 1.0f, 0.0f, 0.0f );
            break;
        case MINUS_Y:
            glRotatef( 90.0f, 1.0f, 0.0f, 0.0f );
            break;
    }
    glTranslatef( 0.0f, 0.0f, radius );
*/  
    // update notch vector using old function
    m_notchVec = notchTurn[m_lastDir][newDir][m_notchVec];
}




//-----------------------------------------------------------------------------
// Name: DrawExtrudedXCObject
// Desc: Draws object generated by extruding the current xc
//          Object starts at xc at origin in z=0 plane, and grows along +z axis 
//-----------------------------------------------------------------------------
void FLEX_PIPE::DrawExtrudedXCObject( float length )
{
    // calc vDiv, and texture coord stuff based on length
    // this also calcs pEval texture ctrl pt arrray now
    CalcEvalLengthParams( length );

    // we can fill in some more stuff:
    m_pEval->m_vOrder = EVAL_CYLINDER_ORDER;

#if 0
    // continuity stuff
    prim.contStart = prim.contEnd = CONT_1; // geometric continuity
#endif

    // draw it

//mf: this fn doesn't really handle continutity for 2 different xc's, so
// may as well pass it one xc
    m_pEval->ProcessXCPrimLinear( m_xcCur, m_xcCur, length );

    // update state draw axes position
//    glTranslatef( 0.0f, 0.0f, length );
}




//-----------------------------------------------------------------------------
// Name: DrawXCCap
// Desc: Cap the start of the pipe
//          Needs newDir, so it can orient itself.
//          Cap ends at current position with approppriate profile, starts a distance
//          'z' back along newDir.
//          Profile is a singularity at start point.
//-----------------------------------------------------------------------------
void FLEX_PIPE::DrawCap( int type )
{
    float radius;
    XC *xc = m_xcCur;
    BOOL bOpening = (type == START_CAP) ? TRUE : FALSE;
    float length;

    // set radius as average of the bounding box min/max's
    radius = ((xc->m_xRight - xc->m_xLeft) + (xc->m_yTop - xc->m_yBottom)) / 4.0f;

    length = (2.0f * PI * radius) / 4.0f; // average length of arc

    // calc vDiv, and texture coord stuff based on length
    CalcEvalLengthParams( length );

    // we can fill in some more stuff:
    m_pEval->m_vOrder = EVAL_ARC_ORDER;

    // draw it
    m_pEval->ProcessXCPrimSingularity( xc, radius, bOpening );
}




//-----------------------------------------------------------------------------
// Name: CalcEvalLengthParams 
// Desc: Calculate pEval values that depend on the length of the extruded object
//          - calculate vDiv, m_sStart, m_sEnd, and the texture control net array
//-----------------------------------------------------------------------------
void FLEX_PIPE::CalcEvalLengthParams( float length )
{
    m_pEval->m_vDiv = (int ) SS_ROUND_UP( length / m_evalDivSize ); 

    // calc texture start and end coords

    if( m_pState->m_bUseTexture ) 
    {
        float s_delta;

        // Don't let m_sEnd overflow : it should stay in range (0..1.0)
        if( m_sEnd > 1.0f )
            m_sEnd -= (int) m_sEnd;

        m_sStart = m_sEnd;
        s_delta = (length / m_sLength );
        m_sEnd = m_sStart + s_delta;
        
        // the texture ctrl point array can be calc'd here - it is always
        // a simple 2x2 array for each section
        m_pEval->SetTextureControlPoints( m_sStart, m_sEnd, m_tStart, m_tEnd );
    }
}




//-----------------------------------------------------------------------------
// Name: relDir
// Desc: this array tells you relative turn
//       format: relDir[lastDir][notchVec][newDir]
//-----------------------------------------------------------------------------
static int relDir[NUM_DIRS][NUM_DIRS][NUM_DIRS] = 
{
//      +x      -x      +y      -y      +z      -z (newDir)

// lastDir = +x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Y, MINUS_Y,
        iXX,    iXX,    MINUS_X,PLUS_X, MINUS_Y,PLUS_Y,
        iXX,    iXX,    MINUS_Y,PLUS_Y, PLUS_X, MINUS_X,
        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X,
// lastDir = -x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    PLUS_X, MINUS_X,MINUS_Y,PLUS_Y,
        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Y, MINUS_Y,
        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,
        iXX,    iXX,    MINUS_Y,PLUS_Y, MINUS_X,PLUS_X,

// lastDir = +y
        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y,
        MINUS_X,PLUS_X, iXX,    iXX,    PLUS_Y, MINUS_Y,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_X, MINUS_X,
        MINUS_Y,PLUS_Y, iXX,    iXX,    MINUS_X,PLUS_X,
// lastDir = -y
        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y,
        MINUS_X,PLUS_X, iXX,    iXX,    MINUS_Y,PLUS_Y,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_X, MINUS_X,
        PLUS_Y, MINUS_Y,iXX,    iXX,    MINUS_X,PLUS_X,

// lastDir = +z
        PLUS_X, MINUS_X,PLUS_Y, MINUS_Y,iXX,    iXX,
        MINUS_X,PLUS_X, MINUS_Y,PLUS_Y, iXX,    iXX,
        MINUS_Y,PLUS_Y, PLUS_X, MINUS_X,iXX,    iXX,
        PLUS_Y, MINUS_Y,MINUS_X,PLUS_X, iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
// lastDir = -z
        PLUS_X, MINUS_X,MINUS_Y,PLUS_Y, iXX,    iXX,
        MINUS_X,PLUS_X, PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,iXX,    iXX,
        MINUS_Y,PLUS_Y, MINUS_X,PLUS_X, iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX
};




//-----------------------------------------------------------------------------
// Name: GetRelativeDir 
// Desc: Calculates relative direction of turn from lastDir, notchVec, newDir
//          - Use look up table for now.
//          - Relative direction is from xy-plane, and can be +x,-x,+y,-y   
//          - In current orientation, +z is along lastDir, +x along notchVec
//-----------------------------------------------------------------------------
static int GetRelativeDir( int lastDir, int notchVec, int newDir )
{
    return( relDir[lastDir][notchVec][newDir] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\fstate.h ===
//-----------------------------------------------------------------------------
// File: fstate.h
//
// Desc: FLEX_STATE
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __fstate_h__
#define __fstate_h__

class PIPE;
class STATE;


//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class FLEX_STATE 
{
public:
    int             m_scheme;         // current drawing scheme (right now this
                                    // is a per-frame thing)
    STATE*          m_pMainState;       

    FLEX_STATE( STATE *pState );
    PIPE*           NewPipe( STATE *pState );
    void            Reset();
    BOOL            OKToUseChase();
    int             GetMaxPipesPerFrame();
};

#endif // __fstate_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\fstate.cpp ===
//-----------------------------------------------------------------------------
// File: fstate.cpp
//
// Desc: FLEX_STATE
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: FLEX_STATE constructor
// Desc: 
//-----------------------------------------------------------------------------
FLEX_STATE::FLEX_STATE( STATE *pMainState )
{
    m_pMainState = pMainState;
    Reset();
}




//-----------------------------------------------------------------------------
// Name: Reset
// Desc: Reset a frame of normal pipes.
//-----------------------------------------------------------------------------
void FLEX_STATE::Reset( )
{
    // Choose a random scheme for each frame

    if( CPipesScreensaver::iRand(2) )  // 50/50
        m_scheme = SC_EXTRUDED_XC;
    else
        m_scheme = SC_TURNOMANIA;
}




//-----------------------------------------------------------------------------
// Name: OKToUseChase
// Desc: Determines if we can use chase mode for flex pipes
//-----------------------------------------------------------------------------
BOOL FLEX_STATE::OKToUseChase()
{
    return m_scheme != SC_TURNOMANIA;
}




//-----------------------------------------------------------------------------
// Name: NewPipe
// Desc: Create a new pipe, based on current drawing scheme
//-----------------------------------------------------------------------------
PIPE* FLEX_STATE::NewPipe( STATE *pState )
{
    if( m_scheme == SC_TURNOMANIA )
        return new TURNING_FLEX_PIPE( pState );
    else
        return new REGULAR_FLEX_PIPE( pState );
}




//-----------------------------------------------------------------------------
// Name: GetMaxPipesPerFrame
// Desc: 
//-----------------------------------------------------------------------------
int FLEX_STATE::GetMaxPipesPerFrame( )
{
    if( m_scheme == SC_TURNOMANIA ) 
    {
        return TURNOMANIA_PIPE_COUNT;
    } 
    else 
    {
        return m_pMainState->m_bUseTexture ? NORMAL_TEX_PIPE_COUNT : NORMAL_PIPE_COUNT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\fpipe.h ===
//-----------------------------------------------------------------------------
// File: fpipe.h
//
// Desc: Flexy pipe stuff
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __fpipe_h__
#define __fpipe_h__

// continuity types
enum 
{
    CONT_1 = 0,
    CONT_2
};

// cap types
enum 
{
    START_CAP = 0,
    END_CAP
};

#define CIRCUMFERENCE( r )         ( 2.0f * PI * ((float) r) )

// drawing schemes
enum 
{
    SC_EXTRUDED_XC,
    SC_TURNOMANIA,
    SC_VARIABLE_XC,
    SC_COUNT
};

#define TURNOMANIA_PIPE_COUNT 10




//-----------------------------------------------------------------------------
// Name: FLEX_PIPE class
// Desc: - Pipe has position and direction in node array
//-----------------------------------------------------------------------------
class FLEX_PIPE : public PIPE 
{
public:
    void        SetTexParams( TEXTUREINFO *pTex, IPOINT2D *pTexRep );

protected:
    XC*         m_xcCur;        // current xc, end xc
    XC*         m_xcEnd;  
    EVAL*       m_pEval;
    float       m_zTrans;       // pos'n of pipe back along current dir,
                                // from current node
    FLEX_PIPE( STATE *state );
    ~FLEX_PIPE();
    void        ChooseXCProfile();
    void        DrawExtrudedXCObject( float length );
    void        DrawXCElbow( int newDir, float radius );
    void        DrawCap( int type );

private:
    int         m_nSlices;        // intended # of slices around an xc (based on tessLevel)
    int         m_tangent;        // current tangent at curXC (usually PLUS_Z)
    float       m_sStart, m_sEnd;
    float       m_tStart, m_tEnd;
    float       m_sLength;        // length in WC's of texture width
    float       m_evalDivSize;    // ~size in WC's of an eval division

    void        CalcEvalLengthParams( float length );
};




//-----------------------------------------------------------------------------
// Name: REGULAR_FLEX_PIPE class
// Desc: 
//-----------------------------------------------------------------------------
class REGULAR_FLEX_PIPE : public FLEX_PIPE 
{
public:
    float       m_turnFactorMin;  // describes degree of bend in an elbow
    float       m_turnFactorMax;  //  [0-1]

    REGULAR_FLEX_PIPE( STATE *state );
    virtual void Start();
    virtual void Draw();
};




//-----------------------------------------------------------------------------
// Name: TURNING_FLEX_PIPE class
// Desc: 
//-----------------------------------------------------------------------------
class TURNING_FLEX_PIPE : public FLEX_PIPE 
{
public:
    TURNING_FLEX_PIPE( STATE *state );
    virtual void Start();
    virtual void Draw();
};

#endif // __fpipe_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\node.cpp ===
//-----------------------------------------------------------------------------
// File: node.cpp
//
// Desc: Pipes node array
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: NODE_ARRAY constructor
// Desc: 
//-----------------------------------------------------------------------------
NODE_ARRAY::NODE_ARRAY()
{
    m_nodes = NULL; // allocated on Resize

    m_numNodes.x = 0;
    m_numNodes.y = 0;
    m_numNodes.z = 0;
}




//-----------------------------------------------------------------------------
// Name: NODE_ARRAY destructor
// Desc: 
//-----------------------------------------------------------------------------
NODE_ARRAY::~NODE_ARRAY( )
{
    if( m_nodes )
        delete m_nodes;
}




//-----------------------------------------------------------------------------
// Name: Resize
// Desc: 
//-----------------------------------------------------------------------------
void NODE_ARRAY::Resize( IPOINT3D *pNewSize )
{
    if( (m_numNodes.x == pNewSize->x) &&
        (m_numNodes.y == pNewSize->y) &&
        (m_numNodes.z == pNewSize->z) )
        return;

    m_numNodes = *pNewSize;

    int elemCount = m_numNodes.x * m_numNodes.y * m_numNodes.z;

    if( m_nodes )
        delete m_nodes;

    m_nodes = new Node[elemCount];

    assert( m_nodes && "NODE_ARRAY::Resize : can't alloc nodes\n" );
    if( m_nodes == NULL )
        return;

    // Reset the node states to empty

    int i;
    Node *pNode = m_nodes;
    for( i = 0; i < elemCount; i++, pNode++ )
        pNode->MarkAsEmpty();

    // precalculate direction offsets between nodes for speed
    m_nodeDirInc[PLUS_X] = 1;
    m_nodeDirInc[MINUS_X] = -1;
    m_nodeDirInc[PLUS_Y] = m_numNodes.x;
    m_nodeDirInc[MINUS_Y] = - m_nodeDirInc[PLUS_Y];
    m_nodeDirInc[PLUS_Z] = m_numNodes.x * m_numNodes.y;
    m_nodeDirInc[MINUS_Z] = - m_nodeDirInc[PLUS_Z];
}




//-----------------------------------------------------------------------------
// Name: Reset
// Desc: 
//-----------------------------------------------------------------------------
void NODE_ARRAY::Reset( )
{
    int i;
    Node* pNode = m_nodes;

    // Reset the node states to empty
    for( i = 0; i < (m_numNodes.x)*(m_numNodes.y)*(m_numNodes.z); i++, pNode++ )
        pNode->MarkAsEmpty();
}




//-----------------------------------------------------------------------------
// Name: GetNodeCount
// Desc: 
//-----------------------------------------------------------------------------
void NODE_ARRAY::GetNodeCount( IPOINT3D *count )
{
    *count = m_numNodes;
}




//-----------------------------------------------------------------------------
// Name: ChooseRandomDirection
// Desc: Choose randomnly among the possible directions.  The likelyhood of going
//       straight is controlled by weighting it.
//-----------------------------------------------------------------------------
int NODE_ARRAY::ChooseRandomDirection( IPOINT3D *pos, int dir, int weightStraight )
{
    Node *nNode[NUM_DIRS];
    int numEmpty, newDir;
    int choice;
    Node *straightNode = NULL;
    int emptyDirs[NUM_DIRS];

    assert( (dir >= 0) && (dir < NUM_DIRS) && 
            "NODE_ARRAY::ChooseRandomDirection: invalid dir\n" );

    // Get the neigbouring nodes
    GetNeighbours( pos, nNode );

    // Get node in straight direction if necessary
    if( weightStraight && nNode[dir] && nNode[dir]->IsEmpty() ) 
    {
        straightNode = nNode[dir];
        // if maximum weight, choose and return
        if( weightStraight == MAX_WEIGHT_STRAIGHT ) 
        {
            straightNode->MarkAsTaken();
            return dir;
        }
    } 
    else
    {
        weightStraight = 0;
    }

    // Get directions of possible turns
    numEmpty = GetEmptyTurnNeighbours( nNode, emptyDirs, dir );

    // Make a random choice
    if( (choice = (weightStraight + numEmpty)) == 0 )
        return DIR_NONE;
    choice = CPipesScreensaver::iRand( choice );

    if( choice < weightStraight && straightNode != NULL ) 
    {
        straightNode->MarkAsTaken();
        return dir;
    } 
    else 
    {
        // choose one of the turns
        newDir = emptyDirs[choice - weightStraight];
        nNode[newDir]->MarkAsTaken();
        return newDir;
    }
}




//-----------------------------------------------------------------------------
// Name: ChoosePreferredDirection
// Desc: Choose randomnly from one of the supplied preferred directions.  If none
//       of these are available, then try and choose any empty direction
//-----------------------------------------------------------------------------
int NODE_ARRAY::ChoosePreferredDirection( IPOINT3D *pos, int dir, int *prefDirs,
                                          int nPrefDirs )
{
    Node *nNode[NUM_DIRS];
    int numEmpty, newDir;
    int emptyDirs[NUM_DIRS];
    int *pEmptyPrefDirs;
    int i, j;

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::ChoosePreferredDirection : invalid dir\n" );

    // Get the neigbouring nodes
    GetNeighbours( pos, nNode );

    // Create list of directions that are both preferred and empty

    pEmptyPrefDirs = emptyDirs;
    numEmpty = 0;

    for( i = 0, j = 0; (i < NUM_DIRS) && (j < nPrefDirs); i++ ) 
    {
        if( i == *prefDirs ) 
        {
            prefDirs++;
            j++;
            if( nNode[i] && nNode[i]->IsEmpty() ) 
            {
                // add it to list
                *pEmptyPrefDirs++ = i;
                numEmpty++;
            }
        }
    }

    // if no empty preferred dirs, then any empty dirs become preferred
    
    if( !numEmpty ) 
    {
        numEmpty = GetEmptyNeighbours( nNode, emptyDirs );
        if( numEmpty == 0 )
            return DIR_NONE;
    }
                
    // Pick a random dir from the empty set

    newDir = emptyDirs[CPipesScreensaver::iRand( numEmpty )];
    nNode[newDir]->MarkAsTaken();
    return newDir;
}




//-----------------------------------------------------------------------------
// Name: FindClearestDirection
// Desc: Finds the direction with the most empty nodes in a line 'searchRadius'
//       long.  Does not mark any nodes as taken.
//-----------------------------------------------------------------------------
int NODE_ARRAY::FindClearestDirection( IPOINT3D *pos )
{
    static Node *neighbNode[NUM_DIRS];
    static int emptyDirs[NUM_DIRS];
    int nEmpty, newDir;
    int maxEmpty = 0;
    int searchRadius = 3;
    int count = 0;
    int i;

    // Get ptrs to neighbour nodes
    GetNeighbours( pos, neighbNode );

    // find empty nodes in each direction
    for( i = 0; i < NUM_DIRS; i ++ ) 
    {
        if( neighbNode[i] && neighbNode[i]->IsEmpty() )
        {
            // find number of contiguous empty nodes along this direction
            nEmpty = GetEmptyNeighboursAlongDir( pos, i, searchRadius );
            if( nEmpty > maxEmpty ) 
            {
                // we have a new winner
                count = 0;
                maxEmpty = nEmpty;
                emptyDirs[count++] = i;
            }
            else if( nEmpty == maxEmpty ) 
            {
                // tied with current max
                emptyDirs[count++] = i;
            }
        }
    }

    if( count == 0 )
        return DIR_NONE;

    // randomnly choose a direction
    newDir = emptyDirs[CPipesScreensaver::iRand( count )];

    return newDir;
}




//-----------------------------------------------------------------------------
// Name: ChooseNewTurnDirection
// Desc: Choose a direction to turn
// 
//       This requires finding a pair of nodes to turn through.  The first node
//       is in the direction of the turn from the current node, and the second node
//       is at right angles to this at the end position.  The prim will not draw
//       through the first node, but may sweep close to it, so we have to mark it
//       as taken.
//       - if next node is free, but there are no turns available, return
//         DIR_STRAIGHT, so the caller can decide what to do in this case
//       - The turn possibilities are based on the orientation of the current xc, with
//         4 relative directions to seek turns in.
//-----------------------------------------------------------------------------
int NODE_ARRAY::ChooseNewTurnDirection( IPOINT3D *pos, int dir )
{
    int turns[NUM_DIRS], nTurns;
    IPOINT3D nextPos;
    int newDir;
    Node *nextNode;

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::ChooseNewTurnDirection : invalid dir\n" );

    // First, check if next node along current dir is empty

    if( !GetNextNodePos( pos, &nextPos, dir ) )
        return DIR_NONE; // node out of bounds or not empty

    // Ok, the next node is free - check the 4 possible turns from here

    nTurns = GetBestPossibleTurns( &nextPos, dir, turns );
    if( nTurns == 0 )
        return DIR_STRAIGHT; // nowhere to turn, but could go straight

    // randomnly choose one of the possible turns
    newDir = turns[ CPipesScreensaver::iRand( nTurns ) ];

    assert( (newDir >= 0) && (newDir < NUM_DIRS) &&
            "NODE_ARRAY::ChooseNewTurnDirection : invalid newDir\n" );


    // mark taken nodes

    nextNode = GetNode( &nextPos );
    nextNode->MarkAsTaken();

    nextNode = GetNextNode( &nextPos, newDir );

    if( nextNode != NULL )
        nextNode->MarkAsTaken();

    return newDir;
}




//-----------------------------------------------------------------------------
// Name: GetBestPossibleTurns
// Desc: From supplied direction and position, figure out which of 4 possible 
//       directions are best to turn in.
//       
//       Turns that have the greatest number of empty nodes after the turn are the
//       best, since a pipe is less likely to hit a dead end in this case.
//       - We only check as far as 'searchRadius' nodes along each dir.
//       - Return direction indices of best possible turns in turnDirs, and return 
//       count of these turns in fuction return value.
//-----------------------------------------------------------------------------
int NODE_ARRAY::GetBestPossibleTurns( IPOINT3D *pos, int dir, int *turnDirs )
{
    Node *neighbNode[NUM_DIRS]; // ptrs to 6 neighbour nodes
    int i, count = 0;
    BOOL check[NUM_DIRS] = {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE};
    int nEmpty, maxEmpty = 0;
    int searchRadius = 2;

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::GetBestPossibleTurns : invalid dir\n" );

    GetNeighbours( pos, neighbNode );

    switch( dir ) 
    {
        case PLUS_X:    
        case MINUS_X:
            check[PLUS_X] = FALSE;
            check[MINUS_X] = FALSE;
            break;
        case PLUS_Y:    
        case MINUS_Y:
            check[PLUS_Y] = FALSE;
            check[MINUS_Y] = FALSE;
            break;
        case PLUS_Z:    
        case MINUS_Z:
            check[PLUS_Z] = FALSE;
            check[MINUS_Z] = FALSE;
            break;
    }

    // check approppriate directions
    for( i = 0; i < NUM_DIRS; i ++ ) 
    {
        if( check[i] && neighbNode[i] && neighbNode[i]->IsEmpty() )
        {
            // find number of contiguous empty nodes along this direction
            nEmpty = GetEmptyNeighboursAlongDir( pos, i, searchRadius );
            if( nEmpty > maxEmpty ) 
            {
                // we have a new winner
                count = 0;
                maxEmpty = nEmpty;
                turnDirs[count++] = i;
            }
            else if( nEmpty == maxEmpty ) 
            {
                // tied with current max
                turnDirs[count++] = i;
            }
        }
    }

    return count;
}




//-----------------------------------------------------------------------------
// Name: GetNeighbours
// Desc: Get neigbour nodes relative to supplied position
//          - get addresses of the neigbour nodes,
//          and put them in supplied matrix
//          - boundary hits are returned as NULL
//-----------------------------------------------------------------------------
void NODE_ARRAY::GetNeighbours( IPOINT3D *pos, Node **nNode )
{
    Node *centerNode = GetNode( pos );

    nNode[PLUS_X]  = pos->x == (m_numNodes.x - 1) ? NULL : 
                                            centerNode + m_nodeDirInc[PLUS_X];
    nNode[PLUS_Y]  = pos->y == (m_numNodes.y - 1) ? NULL :
                                            centerNode + m_nodeDirInc[PLUS_Y];
    nNode[PLUS_Z]  = pos->z == (m_numNodes.z - 1) ? NULL : 
                                            centerNode + m_nodeDirInc[PLUS_Z];

    nNode[MINUS_X] = pos->x == 0 ? NULL : centerNode + m_nodeDirInc[MINUS_X];
    nNode[MINUS_Y] = pos->y == 0 ? NULL : centerNode + m_nodeDirInc[MINUS_Y];
    nNode[MINUS_Z] = pos->z == 0 ? NULL : centerNode + m_nodeDirInc[MINUS_Z];
}




//-----------------------------------------------------------------------------
// Name: NodeVisited
// Desc: Mark the node as non-empty
//-----------------------------------------------------------------------------
void NODE_ARRAY::NodeVisited( IPOINT3D *pos )
{
    (GetNode( pos ))->MarkAsTaken();
}




//-----------------------------------------------------------------------------
// Name: GetNode
// Desc: Get ptr to node from position
//-----------------------------------------------------------------------------
Node* NODE_ARRAY::GetNode( IPOINT3D *pos )
{
    return m_nodes +
           pos->x +
           pos->y * m_numNodes.x +
           pos->z * m_numNodes.x * m_numNodes.y;
}




//-----------------------------------------------------------------------------
// Name: GetNextNode
// Desc: Get ptr to next node from pos and dir
//-----------------------------------------------------------------------------
Node* NODE_ARRAY::GetNextNode( IPOINT3D *pos, int dir )
{
    Node *curNode = GetNode( pos );

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::GetNextNode : invalid dir\n" );

    switch( dir ) 
    {
        case PLUS_X:
            return( pos->x == (m_numNodes.x - 1) ? NULL : 
                              curNode + m_nodeDirInc[PLUS_X]);
            break;
        case MINUS_X:
            return( pos->x == 0 ? NULL : 
                              curNode + m_nodeDirInc[MINUS_X]);
            break;
        case PLUS_Y:
            return( pos->y == (m_numNodes.y - 1) ? NULL : 
                              curNode + m_nodeDirInc[PLUS_Y]);
            break;
        case MINUS_Y:
            return( pos->y == 0 ? NULL : 
                              curNode + m_nodeDirInc[MINUS_Y]);
            break;
        case PLUS_Z:
            return( pos->z == (m_numNodes.z - 1) ? NULL : 
                              curNode + m_nodeDirInc[PLUS_Z]);
            break;
        case MINUS_Z:
            return( pos->z == 0 ? NULL : 
                              curNode + m_nodeDirInc[MINUS_Z]);
            break;
        default:
            return NULL;
    }
}




//-----------------------------------------------------------------------------
// Name: GetNextNodePos
// Desc: Get position of next node from curPos and lastDir
//       Returns FALSE if boundary hit or node empty
//-----------------------------------------------------------------------------
BOOL NODE_ARRAY::GetNextNodePos( IPOINT3D *curPos, IPOINT3D *nextPos, int dir )
{
    static Node *neighbNode[NUM_DIRS]; // ptrs to 6 neighbour nodes

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::GetNextNodePos : invalid dir\n" );

    //mf: don't need to get all neighbours, just one in next direction
    GetNeighbours( curPos, neighbNode );

    *nextPos = *curPos;

    // bail if boundary hit or node not empty
    if( (neighbNode[dir] == NULL) || !neighbNode[dir]->IsEmpty() )
        return FALSE;

    switch( dir ) 
    {
        case PLUS_X:
            nextPos->x = curPos->x + 1;
            break;

        case MINUS_X:
            nextPos->x = curPos->x - 1;
            break;

        case PLUS_Y:
            nextPos->y = curPos->y + 1;
            break;

        case MINUS_Y:
            nextPos->y = curPos->y - 1;
            break;

        case PLUS_Z:
            nextPos->z = curPos->z + 1;
            break;

        case MINUS_Z:
            nextPos->z = curPos->z - 1;
            break;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: GetEmptyNeighbours()
// Desc: - get list of direction indices of empty node neighbours,
//         and put them in supplied matrix
//       - return number of empty node neighbours
//-----------------------------------------------------------------------------
int NODE_ARRAY::GetEmptyNeighbours( Node **nNode, int *nEmpty )
{
    int i, count = 0;

    for( i = 0; i < NUM_DIRS; i ++ ) 
    {
        if( nNode[i] && nNode[i]->IsEmpty() )
            nEmpty[count++] = i;
    }

    return count;
}




//-----------------------------------------------------------------------------
// Name: GetEmptyTurnNeighbours()
// Desc: - get list of direction indices of empty node neighbours,
//          and put them in supplied matrix
//       - don't include going straight
//       - return number of empty node neighbours
//-----------------------------------------------------------------------------
int NODE_ARRAY::GetEmptyTurnNeighbours( Node** nNode, int* nEmpty, int lastDir )
{
    int i, count = 0;

    for( i = 0; i < NUM_DIRS; i ++ ) 
    {
        if( nNode[i] && nNode[i]->IsEmpty() ) 
        {
            if( i == lastDir )
                continue;
            nEmpty[count++] = i;
        }
    }

    return count;
}




//-----------------------------------------------------------------------------
// Name: GetEmptyNeighboursAlongDir
// Desc: Sort of like above, but just gets one neigbour according to supplied dir
//          Given a position and direction, find out how many contiguous empty nodes 
//          there are in that direction.
//          - Can limit search with searchRadius parameter
//          - Return contiguous empty node count
//-----------------------------------------------------------------------------
int NODE_ARRAY::GetEmptyNeighboursAlongDir( IPOINT3D *pos, int dir,
                                            int searchRadius )
{
    Node *curNode = GetNode( pos );
    int nodeStride;
    int maxSearch;
    int count = 0;

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::GetEmptyNeighboursAlongDir : invalid dir\n" );

    nodeStride = m_nodeDirInc[dir];

    switch( dir ) 
    {
        case PLUS_X:    
            maxSearch = m_numNodes.x - pos->x - 1;
            break;
        case MINUS_X:
            maxSearch = pos->x;
            break;
        case PLUS_Y:    
            maxSearch = m_numNodes.y - pos->y - 1;
            break;
        case MINUS_Y:
            maxSearch = pos->y;
            break;
        case PLUS_Z:    
            maxSearch = m_numNodes.z - pos->z - 1;
            break;
        case MINUS_Z:
            maxSearch = pos->z;
            break;
    }
    
    if( searchRadius > maxSearch )
        searchRadius = maxSearch;

    if( !searchRadius )
        return 0;

    while( searchRadius-- ) 
    {
        curNode += nodeStride;
        if( ! curNode->IsEmpty() )
            return count;
        count++;
    }
    return count;
}




//-----------------------------------------------------------------------------
// Name: FindRandomEmptyNode
// Desc:    - Search for an empty node to start drawing
//          - Return position of empty node in supplied pos ptr
//          - Returns FALSE if couldn't find a node
//          - Marks node as taken (mf: renam fn to ChooseEmptyNode ?
//      If random search takes longer than twice the total number
//      of nodes, give up the random search.  There may not be any
//      empty nodes.
//-----------------------------------------------------------------------------
#define INFINITE_LOOP   (2 * NUM_NODE * NUM_NODE * NUM_NODE)

BOOL NODE_ARRAY::FindRandomEmptyNode( IPOINT3D *pos )
{
    int infLoopDetect = 0;

    while( TRUE ) 
    {
        // Pick a random node.
        pos->x = CPipesScreensaver::iRand( m_numNodes.x );
        pos->y = CPipesScreensaver::iRand( m_numNodes.y );
        pos->z = CPipesScreensaver::iRand( m_numNodes.z );

        // If its empty, we're done.
        if( GetNode(pos)->IsEmpty() ) 
        {
            NodeVisited( pos );
            return TRUE;
        } 
        else 
        {
            // Watch out for infinite loops!  After trying for
            // awhile, give up on the random search and look
            // for the first empty node.

            if ( infLoopDetect++ > INFINITE_LOOP ) 
            {
                // Search for first empty node.
                for ( pos->x = 0; pos->x < m_numNodes.x; pos->x++ )
                {
                    for ( pos->y = 0; pos->y < m_numNodes.y; pos->y++ )
                    {
                        for ( pos->z = 0; pos->z < m_numNodes.z; pos->z++ )
                        {
                            if( GetNode(pos)->IsEmpty() ) 
                            {
                                NodeVisited( pos );
                                return TRUE;
                            }
                        }
                    }
                }

                // There are no more empty nodes.
                // Reset the pipes and exit.

                return FALSE;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FindRandomEmptyNode2D
// Desc: - Like FindRandomEmptyNode, but limits search to a 2d plane of the supplied
//          box.
//-----------------------------------------------------------------------------
#define INFINITE_LOOP   (2 * NUM_NODE * NUM_NODE * NUM_NODE)
#define MIN_VAL 1
#define MAX_VAL 0

BOOL NODE_ARRAY::FindRandomEmptyNode2D( IPOINT3D *pos, int plane, int *box )
{
    int *newx, *newy;
    int *xDim, *yDim;

    switch( plane ) 
    {
        case PLUS_X:
        case MINUS_X:
            pos->x = box[plane];
            newx = &pos->z;
            newy = &pos->y;
            xDim = &box[PLUS_Z]; 
            yDim = &box[PLUS_Y]; 
            break;
        case PLUS_Y:
        case MINUS_Y:
            pos->y = box[plane];
            newx = &pos->x;
            newy = &pos->z;
            xDim = &box[PLUS_X]; 
            yDim = &box[PLUS_Z]; 
            break;
        case PLUS_Z:
        case MINUS_Z:
            newx = &pos->x;
            newy = &pos->y;
            pos->z = box[plane];
            xDim = &box[PLUS_X]; 
            yDim = &box[PLUS_Y]; 
            break;
    }

    int infLoop = 2 * (xDim[MAX_VAL] - xDim[MIN_VAL] + 1) *
                      (yDim[MAX_VAL] - yDim[MIN_VAL] + 1);
    int infLoopDetect = 0;

    while( TRUE ) 
    {
        // Pick a random node.
        *newx = CPipesScreensaver::iRand2( xDim[MIN_VAL], xDim[MAX_VAL] );
        *newy = CPipesScreensaver::iRand2( yDim[MIN_VAL], yDim[MAX_VAL] );

        // If its empty, we're done.
        if( GetNode(pos)->IsEmpty() ) 
        {
            NodeVisited( pos );
            return TRUE;
        } 
        else 
        {
            // Watch out for infinite loops!  After trying for
            // awhile, give up on the random search and look
            // for the first empty node.

            if ( ++infLoopDetect > infLoop ) 
            {

                // Do linear search for first empty node.

                for ( *newx = xDim[MIN_VAL]; *newx <= xDim[MAX_VAL]; (*newx)++ )
                {
                    for ( *newy = yDim[MIN_VAL]; *newy <= yDim[MAX_VAL]; (*newy)++ )
                    {
                        if( GetNode(pos)->IsEmpty() ) 
                        {
                            NodeVisited( pos );
                            return TRUE;
                        }
                    }
                }

                // There are no empty nodes in this plane.
                return FALSE;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: TakeClosestEmptyNode
// Desc: - Search for an empty node closest to supplied node position
//          - Returns FALSE if couldn't find a node
//          - Marks node as taken
//          - mf: not completely opimized - if when dilating the box, a side gets
//          clamped against the node array, this side will continue to be searched
//-----------------------------------------------------------------------------
static void DilateBox( int *box, IPOINT3D *bounds );

BOOL NODE_ARRAY::TakeClosestEmptyNode( IPOINT3D *newPos, IPOINT3D *pos )
{
    static int searchRadius = SS_MAX( m_numNodes.x, m_numNodes.y ) / 3;

    // easy out
    if( GetNode(pos)->IsEmpty() ) 
    {
        NodeVisited( pos );
        *newPos = *pos;
        return TRUE;
    }

    int box[NUM_DIRS] = {pos->x, pos->x, pos->y, pos->y, pos->z, pos->z};
    int clip[NUM_DIRS] = {0};

    // do a random search on successively larger search boxes
    for( int i = 0; i < searchRadius; i++ ) 
    {
        // Increase box size
        DilateBox( box, &m_numNodes );
        // start looking in random 2D face of the box
        int dir = CPipesScreensaver::iRand( NUM_DIRS );
        for( int j = 0; j < NUM_DIRS; j++, dir = (++dir == NUM_DIRS) ? 0 : dir ) 
        {
            if( FindRandomEmptyNode2D( newPos, dir, box ) )
                return TRUE;
        }
    }

    // nothing nearby - grab a random one
    return FindRandomEmptyNode( newPos );
}




//-----------------------------------------------------------------------------
// Name: DilateBox
// Desc: - Increase box radius without exceeding bounds
//-----------------------------------------------------------------------------
static void DilateBox( int *box, IPOINT3D *bounds )
{
    int *min = (int *) &box[MINUS_X];
    int *max = (int *) &box[PLUS_X];
    int *boundMax = (int *) bounds;
    
    // boundMin always 0
    for( int i = 0; i < 3; i ++, min+=2, max+=2, boundMax++ ) 
    {
        if( *min > 0 )
            (*min)--;
        if( *max < (*boundMax - 1) )
            (*max)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\npipe.h ===
//-----------------------------------------------------------------------------
// File: npipe.h
//
// Desc: Normal pipes code
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __npipe_h__
#define __npipe_h__

class NORMAL_STATE;


//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class NORMAL_PIPE : public PIPE 
{
public:
    NORMAL_STATE* m_pNState;

    NORMAL_PIPE( STATE *state );
    void        Start();
    int         ChooseElbow( int oldDir, int newDir);
    void        DrawJoint( int newDir );
    void        Draw( ); //mf: could take param to draw n sections
    void        DrawStartCap( int newDir );
    void        DrawEndCap();
    void        align_plusy( int oldDir, int newDir );
    void        align_notch( int newDir, int notch );
};


#endif // __npipe_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\nstate.cpp ===
//-----------------------------------------------------------------------------
// File: nstate.cpp
//
// Desc: NORMAL_STATE
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: NORMAL_STATE constructor
// Desc: 
//-----------------------------------------------------------------------------
NORMAL_STATE::NORMAL_STATE( STATE *pState )
{
    m_pd3dDevice = pState->m_pd3dDevice;

    // init joint types from dialog settings
    m_bCycleJointStyles = 0;

    switch( pState->m_pConfig->nJointType ) 
    {
        case JOINT_ELBOW:
            m_jointStyle = ELBOWS;
            break;

        case JOINT_BALL:
            m_jointStyle = BALLS;
            break;

        case JOINT_MIXED:
            m_jointStyle = EITHER;
            break;

        case JOINT_CYCLE:
            m_bCycleJointStyles = 1;
            m_jointStyle = EITHER;
            break;

        default:
            break;
    }

    // Build the objects
    BuildObjects( pState->m_radius, pState->m_view.m_divSize, pState->m_nSlices,
                  pState->m_bUseTexture, &pState->m_texRep[0] );
}




//-----------------------------------------------------------------------------
// Name: NORMAL_STATE destructor
// Desc: Some of the objects are always created, so don't have to check if they
//       exist. Others may be NULL.
//-----------------------------------------------------------------------------
NORMAL_STATE::~NORMAL_STATE()
{
    SAFE_DELETE( m_pShortPipe );
    SAFE_DELETE( m_pLongPipe );
    SAFE_DELETE( m_pBallCap );
    SAFE_DELETE( m_pBigBall );

    for( int i = 0; i < 4; i ++ ) 
    {
        SAFE_DELETE( m_pElbows[i] );
        SAFE_DELETE( m_pBallJoints[i] );
    }
}




//-----------------------------------------------------------------------------
// Name: BuildObjects
// Desc: - Build all the pipe primitives
//       - Different prims are built based on bTexture flag
//-----------------------------------------------------------------------------
void NORMAL_STATE::BuildObjects( float radius, float divSize, int nSlices, 
                                 BOOL bTexture, IPOINT2D *texRep )
{
    OBJECT_BUILD_INFO buildInfo;
    buildInfo.m_radius   = radius;
    buildInfo.m_divSize  = divSize;
    buildInfo.m_nSlices  = nSlices;
    buildInfo.m_bTexture = bTexture;
    buildInfo.m_texRep   = NULL;

    if( bTexture ) 
    {
        buildInfo.m_texRep = texRep;
        
        // Calc s texture intersection values
        float s_max = (float) texRep->y;
        float s_trans =  s_max * 2.0f * radius / divSize;

        // Build short and long pipes
        m_pShortPipe = new PIPE_OBJECT( m_pd3dDevice, &buildInfo, divSize - 2*radius,
                                       s_trans, s_max );
        m_pLongPipe = new PIPE_OBJECT( m_pd3dDevice, &buildInfo, divSize, 0.0f, s_max );

        // Build elbow and ball joints
        for( int i = 0; i < 4; i ++ ) 
        {
            m_pElbows[i] = new ELBOW_OBJECT( m_pd3dDevice, &buildInfo, i, 0.0f, s_trans );
            m_pBallJoints[i] = new BALLJOINT_OBJECT( m_pd3dDevice, &buildInfo, i, 0.0f, s_trans );
        }

        m_pBigBall = NULL;

        // Build end cap
        float s_start = - texRep->x * (ROOT_TWO - 1.0f) * radius / divSize;
        float s_end = texRep->x * (2.0f + (ROOT_TWO - 1.0f)) * radius / divSize;

        // calc compensation value, to prevent negative s coords
        float comp_s = (int) ( - s_start ) + 1.0f;
        s_start += comp_s;
        s_end += comp_s;
        m_pBallCap = new SPHERE_OBJECT( m_pd3dDevice, &buildInfo, ROOT_TWO*radius, s_start, s_end );
    } 
    else 
    {
        // Build pipes, elbows
        m_pShortPipe = new PIPE_OBJECT( m_pd3dDevice, &buildInfo, divSize - 2*radius );
        m_pLongPipe = new PIPE_OBJECT( m_pd3dDevice, &buildInfo, divSize );
        for( int i = 0; i < 4; i ++ ) 
        {
            m_pElbows[i] = new ELBOW_OBJECT( m_pd3dDevice, &buildInfo, i );
            m_pBallJoints[i] = NULL;
        }

        // Build just one ball joint when not texturing.  It is slightly
        // larger than standard ball joint, to prevent any pipe edges from
        // 'sticking' out of the ball.
        m_pBigBall = new SPHERE_OBJECT( m_pd3dDevice, &buildInfo,  
                                ROOT_TWO*radius / ((float) cos(PI/nSlices)) );

        // build end cap
        m_pBallCap = new SPHERE_OBJECT( m_pd3dDevice, &buildInfo, ROOT_TWO*radius );
    }
}




//-----------------------------------------------------------------------------
// Name: Reset
// Desc: Reset frame attributes for normal pipes.
//-----------------------------------------------------------------------------
void NORMAL_STATE::Reset()
{
    // Set the joint style
    if( m_bCycleJointStyles ) 
    {
        if( ++(m_jointStyle) >= NUM_JOINT_STYLES )
            m_jointStyle = 0;
    }
}




//-----------------------------------------------------------------------------
// Name: ChooseJointType
// Desc: - Decides which type of joint to draw 
//-----------------------------------------------------------------------------
int NORMAL_STATE::ChooseJointType()
{
    switch( m_jointStyle ) 
    {
        case ELBOWS:
            return ELBOW_JOINT;

        case BALLS:
            return BALL_JOINT;

        case EITHER:
        default:
            // otherwise an elbow or a ball (1/3 ball)
            if( !CPipesScreensaver::iRand(3) )
                return BALL_JOINT;
            else
                return ELBOW_JOINT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\node.h ===
//-----------------------------------------------------------------------------
// File: node.h
//
// Desc: Node stuff
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __node_h__
#define __node_h__

#define NUM_NODE (NUM_DIV - 1)  // num nodes in longest dimension

// maximum weighting of going straight for direction choosing functions
#define MAX_WEIGHT_STRAIGHT 100




//-----------------------------------------------------------------------------
// Name: Node class
// Desc: 
//-----------------------------------------------------------------------------
class Node 
{
public:
    void        MarkAsTaken() { m_empty = FALSE; }
    void        MarkAsEmpty() { m_empty = TRUE; }
    BOOL        IsEmpty() { return m_empty; }
private:
    BOOL        m_empty;
};




//-----------------------------------------------------------------------------
// Name: Node array class
// Desc: - 3d array of nodes
//       - Functions to access node neighbours, query if taken or not, etc. 
//       - Not only is this the node array, but a set of methods that operates on it
//-----------------------------------------------------------------------------
class NODE_ARRAY 
{
public:
    NODE_ARRAY();
    ~NODE_ARRAY();
    void        Resize( IPOINT3D *pNewSize ); // new array size
    void        Reset();       // set all nodes to empty
    int         ChooseRandomDirection( IPOINT3D *pos, int dir, int weight );
    int         ChoosePreferredDirection( IPOINT3D *pos, int dir, int *prefDirs,
                                          int nPrefDirs );
    int         ChooseNewTurnDirection( IPOINT3D *pos, int dir );
    int         FindClearestDirection( IPOINT3D *pos );
    int         GetBestPossibleTurns( IPOINT3D *pos, int dir, int *turnDirs );
    BOOL        FindRandomEmptyNode( IPOINT3D *ip3dEmpty );
    BOOL        FindRandomEmptyNode2D( IPOINT3D *pos, int plane, int *box );
    BOOL        TakeClosestEmptyNode( IPOINT3D *newPos, IPOINT3D *pos );
    void        NodeVisited( IPOINT3D *pos );
    void        GetNodeCount( IPOINT3D *pos );

private:
    Node*       m_nodes;         // ptr to node array
    int         m_lock;          // semaphore lock for >1 drawing pipes
    IPOINT3D    m_numNodes;      // x,y,z dimensions of node array
    int         m_nodeDirInc[NUM_DIRS]; // array offset between nodes for each dir

    void        GetNeighbours( IPOINT3D *pos, Node **nNode );
    Node*       GetNode( IPOINT3D *pos );
    Node*       GetNextNode( IPOINT3D *pos, int dir );
    BOOL        GetNextNodePos( IPOINT3D *curPos, IPOINT3D *nextPos, int dir );
    int         GetEmptyNeighbours( Node **nNode, int *nEmpty ); 
    int         GetEmptyTurnNeighbours( Node **nNode, int *nEmpty, int lastDir ); 
    int         GetEmptyNeighboursAlongDir( IPOINT3D *pos, int dir,
                                            int searchRadius );
};


#endif // __node_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\npipe.cpp ===
//-----------------------------------------------------------------------------
// File: npipe.cpp
//
// Desc: Normal pipes code
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"


static void align_notch( int newDir, int notch );
static void align_plusy( int oldDir, int newDir );

// defCylNotch shows where the notch for the default cylinder will be,
//  in absolute coords, once we do an align_plusz
static int defCylNotch[NUM_DIRS] = 
        { PLUS_Y, PLUS_Y, MINUS_Z, PLUS_Z, PLUS_Y, PLUS_Y };




//-----------------------------------------------------------------------------
// Name: NORMAL_PIPE constructor
// Desc: 
//-----------------------------------------------------------------------------
NORMAL_PIPE::NORMAL_PIPE( STATE *pState ) : PIPE( pState )
{
    m_type = TYPE_NORMAL;
    m_pNState = pState->m_pNState;

    // choose weighting of going straight
    if( ! CPipesScreensaver::iRand( 20 ) )
        m_weightStraight = CPipesScreensaver::iRand2( MAX_WEIGHT_STRAIGHT/4, MAX_WEIGHT_STRAIGHT );
    else
        m_weightStraight = 1 + CPipesScreensaver::iRand( 4 );
}




//-----------------------------------------------------------------------------
// Name: Start
// Desc: Start drawing a new normal pipe
//       - Draw a start cap and short pipe in new direction
//-----------------------------------------------------------------------------
void NORMAL_PIPE::Start()
{
    int newDir;

    // Set start position
    if( !SetStartPos() ) 
    {
        m_status = PIPE_OUT_OF_NODES;
        return;
    }

    // set a material
    ChooseMaterial();

    m_pState->m_pd3dDevice->SetTexture( 0, m_pState->m_textureInfo[0].pTexture );
    m_pState->m_pd3dDevice->SetMaterial( m_pMat );

    // push matrix that has initial zTrans and rotation
    m_pWorldMatrixStack->Push();

    // Translate to current position
    TranslateToCurrentPosition();

    // Pick a random lastDir
    m_lastDir = CPipesScreensaver::iRand( NUM_DIRS );

    newDir = ChooseNewDirection();

    if( newDir == DIR_NONE ) 
    {
        // pipe is stuck at the start node, draw nothing
        m_status = PIPE_STUCK;
        m_pWorldMatrixStack->Pop();
        return;
    } 
    else
    {
        m_status = PIPE_ACTIVE;
    }

    // set initial notch vector
    m_notchVec = defCylNotch[newDir];

    DrawStartCap( newDir );

    // move ahead 1.0*r to draw pipe
    m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, m_radius );
            
    // draw short pipe
    align_notch( newDir, m_notchVec );
    m_pNState->m_pShortPipe->Draw( m_pWorldMatrixStack->GetTop() );

    m_pWorldMatrixStack->Pop();

    UpdateCurrentPosition( newDir );

    m_lastDir = newDir;
}




//-----------------------------------------------------------------------------
// Name: Draw
// Desc: - if turning, draws a joint and a short cylinder, otherwise
//         draws a long cylinder.
//       - the 'current node' is set as the one we draw thru the NEXT
//         time around.
//-----------------------------------------------------------------------------
void NORMAL_PIPE::Draw()
{
    int newDir;

    m_pState->m_pd3dDevice->SetTexture( 0, m_pState->m_textureInfo[0].pTexture );
    m_pState->m_pd3dDevice->SetMaterial( m_pMat );

    newDir = ChooseNewDirection();

    if( newDir == DIR_NONE ) 
    {  
        // no empty nodes - nowhere to go
        DrawEndCap();
        m_status = PIPE_STUCK;
        return;
    }

    // push matrix that has initial zTrans and rotation
    m_pWorldMatrixStack->Push();

    // Translate to current position
    TranslateToCurrentPosition();

    // draw joint if necessary, and pipe
    if( newDir != m_lastDir ) 
    { 
        // turning! - we have to draw joint
        DrawJoint( newDir );

        // draw short pipe
        align_notch( newDir, m_notchVec );
        m_pNState->m_pShortPipe->Draw( m_pWorldMatrixStack->GetTop() );
    }
    else 
    {  
        // no turn -- draw long pipe, from point 1.0*r back
        align_plusz( newDir );
        align_notch( newDir, m_notchVec );
        m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, -m_radius );
        m_pNState->m_pLongPipe->Draw( m_pWorldMatrixStack->GetTop() );
    }

    m_pWorldMatrixStack->Pop();

    UpdateCurrentPosition( newDir );

    m_lastDir = newDir;
}




//-----------------------------------------------------------------------------
// Name: DrawStartCap
// Desc: Cap the start of the pipe with a ball
//-----------------------------------------------------------------------------
void NORMAL_PIPE::DrawStartCap( int newDir )
{
    if( m_pState->m_bUseTexture ) 
    {
        align_plusz( newDir );
        m_pNState->m_pBallCap->Draw( m_pWorldMatrixStack->GetTop() );
    }
    else 
    {
        // draw big ball in default orientation
        m_pNState->m_pBigBall->Draw( m_pWorldMatrixStack->GetTop() );
        align_plusz( newDir );
    }
}




//-----------------------------------------------------------------------------
// Name: DrawEndCap():
// Desc: - Draws a ball, used to cap end of a pipe
//-----------------------------------------------------------------------------
void NORMAL_PIPE::DrawEndCap()
{
    m_pWorldMatrixStack->Push();

    // Translate to current position
    TranslateToCurrentPosition();

    if( m_pState->m_bUseTexture ) 
    {
        align_plusz( m_lastDir );
        align_notch( m_lastDir, m_notchVec );
        m_pNState->m_pBallCap->Draw( m_pWorldMatrixStack->GetTop() );
    }
    else
    {
        m_pNState->m_pBigBall->Draw( m_pWorldMatrixStack->GetTop() );
    }

    m_pWorldMatrixStack->Pop();
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: this array supplies the sequence of elbow notch vectors, given
//       oldDir and newDir  (0's are don't cares)
//       it is also used to determine the ending notch of an elbow
//-----------------------------------------------------------------------------
static int notchElbDir[NUM_DIRS][NUM_DIRS][4] = 
{
// oldDir = +x
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Y,         MINUS_Z,        MINUS_Y,        PLUS_Z,
        MINUS_Y,        PLUS_Z,         PLUS_Y,         MINUS_Z,
        PLUS_Z,         PLUS_Y,         MINUS_Z,        MINUS_Y,
        MINUS_Z,        MINUS_Y,        PLUS_Z,         PLUS_Y,
// oldDir = -x
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Y,         PLUS_Z,         MINUS_Y,        MINUS_Z,
        MINUS_Y,        MINUS_Z,        PLUS_Y,         PLUS_Z,
        PLUS_Z,         MINUS_Y,        MINUS_Z,        PLUS_Y,
        MINUS_Z,        PLUS_Y,         PLUS_Z,         MINUS_Y,

// oldDir = +y
        PLUS_X,         PLUS_Z,         MINUS_X,        MINUS_Z,
        MINUS_X,        MINUS_Z,        PLUS_X,         PLUS_Z,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Z,         MINUS_X,        MINUS_Z,        PLUS_X,
        MINUS_Z,        PLUS_X,         PLUS_Z,         MINUS_X,
// oldDir = -y
        PLUS_X,         MINUS_Z,        MINUS_X,        PLUS_Z,
        MINUS_X,        PLUS_Z,         PLUS_X,         MINUS_Z,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Z,         PLUS_X,         MINUS_Z,        MINUS_X,
        MINUS_Z,        MINUS_X,        PLUS_Z,         PLUS_X,

// oldDir = +z
        PLUS_X,         MINUS_Y,        MINUS_X,        PLUS_Y,
        MINUS_X,        PLUS_Y,         PLUS_X,         MINUS_Y,
        PLUS_Y,         PLUS_X,         MINUS_Y,        MINUS_X,
        MINUS_Y,        MINUS_X,        PLUS_Y,         PLUS_X,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
// oldDir = -z
        PLUS_X,         PLUS_Y,         MINUS_X,        MINUS_Y,
        MINUS_X,        MINUS_Y,        PLUS_X,         PLUS_Y,
        PLUS_Y,         MINUS_X,        MINUS_Y,        PLUS_X,
        MINUS_Y,        PLUS_X,         PLUS_Y,         MINUS_X,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX
};




//-----------------------------------------------------------------------------
// Name: ChooseElbow
// Desc: - Decides which elbow to draw
//       - The beginning of each elbow is aligned along +y, and we have
//         to choose the one with the notch in correct position
//       - The 'primary' start notch (elbow[0]) is in same direction as
//         newDir, and successive elbows rotate this notch CCW around +y
//-----------------------------------------------------------------------------
int NORMAL_PIPE::ChooseElbow( int oldDir, int newDir )
{
    int i;

    // precomputed table supplies correct elbow orientation
    for( i=0; i<4; i++ ) 
    {
        if( notchElbDir[oldDir][newDir][i] == m_notchVec )
            return i;
    }

    // we shouldn't arrive here
    return -1;
}




//-----------------------------------------------------------------------------
// Name: DrawJoint
// Desc: Draw a joint between 2 pipes
//-----------------------------------------------------------------------------
void NORMAL_PIPE::DrawJoint( int newDir )
{
    int jointType;
    int iBend;
    
    jointType = m_pNState->ChooseJointType();
#if PIPES_DEBUG
    if( newDir == oppositeDir[lastDir] )
        OutputDebugString( "Warning: opposite dir chosen!\n" );
#endif
    
    switch( jointType ) 
    {
        case BALL_JOINT:
        {
            if( m_pState->m_bUseTexture ) 
            {
                // use special texture-friendly ballJoints           
                align_plusz( newDir );
                m_pWorldMatrixStack->Push();
            
                align_plusy( m_lastDir, newDir );
            
                // translate forward 1.0*r along +z to get set for drawing elbow
                m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, m_radius );

                // decide which elbow orientation to use
                iBend = ChooseElbow( m_lastDir, newDir );
                m_pNState->m_pBallJoints[iBend]->Draw( m_pWorldMatrixStack->GetTop() );
            
                m_pWorldMatrixStack->Pop();
            }
            else 
            {
                // draw big ball in default orientation
                m_pNState->m_pBigBall->Draw( m_pWorldMatrixStack->GetTop() );
                align_plusz( newDir );
            }

            // move ahead 1.0*r to draw pipe
            m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, m_radius );
            break;
        }
        
        case ELBOW_JOINT:
        default:
        {
            align_plusz( newDir );

            // the align_plusy() here will mess up 
            // our notch calcs, so we push-pop        
            m_pWorldMatrixStack->Push();
        
            align_plusy( m_lastDir, newDir );
        
            // translate forward 1.0*r along +z to get set for drawing elbow
            m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, m_radius );

            // decide which elbow orientation to use
            iBend = ChooseElbow( m_lastDir, newDir );
            if( iBend == -1 ) 
            {
#if PIPES_DEBUG
                OutputDebugString( "Bad result from ChooseElbow()\n" );
#endif
                iBend = 0; // recover
            }
            m_pNState->m_pElbows[iBend]->Draw( m_pWorldMatrixStack->GetTop() );
        
            m_pWorldMatrixStack->Pop();
       
            m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, m_radius );
            break;
        }
    }
    
    // update the current notch vector
    m_notchVec = notchTurn[m_lastDir][newDir][m_notchVec];
    
#if PIPES_DEBUG
    if( m_notchVec == iXX )
        OutputDebugString( "notchTurn gave bad value\n" );
#endif
}




//-----------------------------------------------------------------------------
// Name: align_plusy
// Desc: - Assuming +z axis is already aligned with newDir, align        
//         +y axis BACK along lastDir                                    
//-----------------------------------------------------------------------------
void NORMAL_PIPE::align_plusy( int oldDir, int newDir )
{
    static D3DXVECTOR3 zAxis = D3DXVECTOR3(0.0f,0.0f,1.0f);
    static float RotZ[NUM_DIRS][NUM_DIRS] = 
    {
              0.0f,   0.0f,  90.0f,  90.0f,  90.0f, -90.0f,
              0.0f,   0.0f, -90.0f, -90.0f, -90.0f,  90.0f,
            180.0f, 180.0f,   0.0f,   0.0f, 180.0f, 180.0f,
              0.0f,   0.0f,   0.0f,   0.0f,   0.0f,   0.0f,
            -90.0f,  90.0f,   0.0f, 180.0f,   0.0f,   0.0f,
             90.0f, -90.0f, 180.0f,   0.0f,   0.0f,   0.0f 
    };

    float rotz = RotZ[oldDir][newDir];
    if( rotz != 0.0f )
        m_pWorldMatrixStack->RotateAxisLocal( &zAxis, SS_DEG_TO_RAD(rotz) );
}




//-----------------------------------------------------------------------------
// Name: align_notch
// Desc: - a cylinder is notched, and we have to line this up            
//         with the previous primitive's notch which is maintained as    
//         notchVec.                                                     
//         - this adds a rotation around z to achieve this                
//-----------------------------------------------------------------------------
void NORMAL_PIPE::align_notch( int newDir, int notch )
{
    float rotz;
    int curNotch;

    // figure out where notch is presently after +z alignment
    curNotch = defCylNotch[newDir];
    // (don't need this now we have lut)

    // given a dir, determine how much to rotate cylinder around z to match notches
    // format is [newDir][notchVec]
    static float alignNotchRot[NUM_DIRS][NUM_DIRS] = 
    {
            fXX,    fXX,    0.0f,   180.0f,  90.0f, -90.0f,
            fXX,    fXX,    0.0f,   180.0f,  -90.0f, 90.0f,
            -90.0f, 90.0f,  fXX,    fXX,    180.0f, 0.0f,
            -90.0f, 90.0f,  fXX,    fXX,    0.0f,   180.0f,
            -90.0f, 90.0f,  0.0f,   180.0f, fXX,    fXX,
            90.0f,  -90.0f, 0.0f,   180.0f, fXX,    fXX
    };

    // look up rotation value in table
    rotz = alignNotchRot[newDir][notch];

#if PIPES_DEBUG
    if( rotz == fXX ) 
    {
        printf( "align_notch(): unexpected value\n" );
        return;
    }
#endif

    static D3DXVECTOR3 zAxis = D3DXVECTOR3(0.0f,0.0f,1.0f);
    if( rotz != 0.0f )
        m_pWorldMatrixStack->RotateAxisLocal( &zAxis, SS_DEG_TO_RAD(rotz) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\objects.cpp ===
//-----------------------------------------------------------------------------
// File: objects.cpp
//
// Desc: Creates command lists for pipe primitive objects
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: OBJECT constructor
// Desc: 
//-----------------------------------------------------------------------------
OBJECT::OBJECT( IDirect3DDevice8* pd3dDevice )
{
    m_pd3dDevice = pd3dDevice;
    m_pVB = NULL;
    m_dwNumTriangles = 0;
}




//-----------------------------------------------------------------------------
// Name: OBJECT destructor
// Desc: 
//-----------------------------------------------------------------------------
OBJECT::~OBJECT( )
{
    SAFE_RELEASE( m_pVB );
}




//-----------------------------------------------------------------------------
// Name: Draw
// Desc: - Draw the object by calling its display list
//-----------------------------------------------------------------------------
void OBJECT::Draw( D3DXMATRIX* pWorldMat )
{
    if( m_pVB )
    {
        m_pd3dDevice->SetTransform( D3DTS_WORLD, pWorldMat );

        m_pd3dDevice->SetVertexShader( D3DFVF_VERTEX );
        m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(D3DVERTEX) );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST,
                                     0, m_dwNumTriangles );
    }
}




//-----------------------------------------------------------------------------
// Name: PIPE_OBJECT constructors
// Desc: 
//-----------------------------------------------------------------------------
PIPE_OBJECT::PIPE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, float len ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, len, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
PIPE_OBJECT::PIPE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, float len, 
                          float s_start, float s_end ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, len, s_start, s_end );
}




//-----------------------------------------------------------------------------
// Name: ELBOW_OBJECT constructors
// Desc: 
//-----------------------------------------------------------------------------
ELBOW_OBJECT::ELBOW_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, 
                            int notch ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, notch, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
ELBOW_OBJECT::ELBOW_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, int notch, float s_start, float s_end ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, notch, s_start, s_end );
}




//-----------------------------------------------------------------------------
// Name: BALLJOINT_OBJECT constructor
// Desc: 
//-----------------------------------------------------------------------------
BALLJOINT_OBJECT::BALLJOINT_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, 
                                    int notch, float s_start, float s_end ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, notch, s_start, s_end );
}




//-----------------------------------------------------------------------------
// Name: SPHERE_OBJECT constructors
// Desc: 
//-----------------------------------------------------------------------------
SPHERE_OBJECT::SPHERE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, float radius ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, radius, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
SPHERE_OBJECT::SPHERE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, 
                              float radius, float s_start, float s_end ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, radius, s_start, s_end );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: rotate circle around x-axis, with edge attached to anchor
//-----------------------------------------------------------------------------
static void TransformCircle( float angle, D3DXVECTOR3 *inPoint, D3DXVECTOR3 *outPoint, 
                             int num, D3DXVECTOR3 *anchor )
{
    D3DXMATRIX matrix1, matrix2, matrix3;
    int i;

    // translate anchor point to origin
    D3DXMatrixIdentity( &matrix1 );
    D3DXMatrixTranslation( &matrix1, -anchor->x, -anchor->y, -anchor->z );

    // rotate by angle, cw around x-axis
    D3DXMatrixIdentity( &matrix2 );
    D3DXMatrixRotationYawPitchRoll( &matrix2, 0.0f, angle, 0.0f ); 

    // concat these 2
    D3DXMatrixMultiply( &matrix3, &matrix1, &matrix2  );

    // translate back
    D3DXMatrixIdentity( &matrix2 );
    D3DXMatrixTranslation( &matrix2,  anchor->x,  anchor->y,  anchor->z );

    // concat these 2
    D3DXMatrixMultiply( &matrix1, &matrix3, &matrix2  );

    // transform all the points, + center
    for( i = 0; i < num; i ++, outPoint++, inPoint++ ) 
    {
        D3DXVECTOR4 tmp;
        D3DXVec3Transform( &tmp, inPoint, &matrix1 );
        outPoint->x = tmp.x;
        outPoint->y = tmp.y;
        outPoint->z = tmp.z;
    }
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
static void CalcNormals( D3DXVECTOR3 *p, D3DXVECTOR3 *n, D3DXVECTOR3 *center,
                         int num )
{
    D3DXVECTOR3 vec;
    int i;

    for( i = 0; i < num; i ++, n++, p++ ) 
    {
        n->x = p->x - center->x;
        n->y = p->y - center->y;
        n->z = p->z - center->z;
        D3DXVec3Normalize( n, n );
    }
}




#define CACHE_SIZE      100     




//-----------------------------------------------------------------------------
// Name: BuildElbow
// Desc: - builds elbows, by rotating a circle in the y=r plane          
//         centered at (0,r,-r), CW around the x-axis at anchor pt.      
//         (r = radius of the circle)                                    
//         - rotation is 90.0 degrees, ending at circle in z=0 plane,     
//         centered at origin.                                           
//         - in order to 'mate' texture coords with the cylinders         
//         generated with glu, we generate 4 elbows, each corresponding  
//         to the 4 possible CW 90 degree orientations of the start point
//         for each circle.                                              
//         - We call this start point the 'notch'.  If we characterize    
//         each notch by the axis it points down in the starting and     
//         ending circles of the elbow, then we get the following axis   
//         pairs for our 4 notches:                                      
//              - +z,+y                                                 
//              - +x,+x                                                 
//              - -z,-y                                                 
//               - -x,-x                                                 
//         Since the start of the elbow always points down +y, the 4     
//         start notches give all possible 90.0 degree orientations      
//         around y-axis.                                                
//         - We can keep track of the current 'notch' vector to provide   
//         proper mating between primitives.                             
//         - Each circle of points is described CW from the start point,  
//         assuming looking down the +y axis(+y direction).              
//         - texture 's' starts at 0.0, and goes to 2.0*r/divSize at      
//         end of the elbow.  (Then a short pipe would start with this   
//         's', and run it to 1.0).                                      
//-----------------------------------------------------------------------------
void ELBOW_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, int notch, 
                          float s_start, float s_end )
{
    int   stacks, slices;
    float angle, startAng;
    int numPoints;
    float s_delta;
    D3DXVECTOR3 pi[CACHE_SIZE]; // initial row of points + center
    D3DXVECTOR3 p0[CACHE_SIZE]; // 2 rows of points
    D3DXVECTOR3 p1[CACHE_SIZE];
    D3DXVECTOR3 n0[CACHE_SIZE]; // 2 rows of normals
    D3DXVECTOR3 n1[CACHE_SIZE];
    float tex_t[CACHE_SIZE];// 't' texture coords
    float* curTex_t;
    float tex_s[2];  // 's' texture coords
    D3DXVECTOR3 center;  // center of circle
    D3DXVECTOR3 anchor;  // where circle is anchored
    D3DXVECTOR3* pA;
    D3DXVECTOR3* pB;
    D3DXVECTOR3* nA;
    D3DXVECTOR3* nB;

    D3DXVECTOR3* pTA;
    D3DXVECTOR3* pTB;
    D3DXVECTOR3* nTA;
    D3DXVECTOR3* nTB;

    int i,j;
    IPOINT2D* texRep = pBuildInfo->m_texRep;
    float radius = pBuildInfo->m_radius;

    slices = pBuildInfo->m_nSlices;
    stacks = slices / 2;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;

    s_delta = s_end - s_start;

    // calculate 't' texture coords
    if( texRep )
    {
        for( i = 0; i <= slices; i ++ ) 
        {
            tex_t[i] = (float) i * texRep->y / slices;
        }
    }

    numPoints = slices + 1;

    // starting angle increment 90.0 degrees each time
    startAng = notch * PI / 2;

    // calc initial circle of points for circle centered at 0,r,-r
    // points start at (0,r,0), and rotate circle CCW

    for( i = 0; i <= slices; i ++ ) 
    {
        angle = startAng + (2 * PI * i / slices);
        pi[i].x = radius * (float) sin(angle);
        pi[i].y = radius;
        // translate z by -r, cuz these cos calcs are for circle at origin
        pi[i].z = radius * (float) cos(angle) - radius;
    }

    // center point, tacked onto end of circle of points
    pi[i].x =  0.0f;
    pi[i].y =  radius;
    pi[i].z = -radius;
    center = pi[i];

    // anchor point
    anchor.x = anchor.z = 0.0f;
    anchor.y = radius;

    // calculate initial normals
    CalcNormals( pi, n0, &center, numPoints );

    // initial 's' texture coordinate
    tex_s[0] = s_start;

    // setup pointers
    pA = pi;
    pB = p0;
    nA = n0;
    nB = n1;

    DWORD dwNumQuadStripsPerStack = numPoints - 1;
    DWORD dwNumQuadStrips = dwNumQuadStripsPerStack * stacks;
    m_dwNumTriangles = dwNumQuadStrips * 2;
    DWORD dwNumVertices = m_dwNumTriangles * 3;
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(D3DVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_VERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
        return;

    D3DVERTEX* vQuad;
    D3DVERTEX* vCurQuad;
    vQuad = new D3DVERTEX[dwNumVertices];
    ZeroMemory( vQuad, sizeof(D3DVERTEX) * dwNumVertices );

    vCurQuad = vQuad;
    for( i = 1; i <= stacks; i ++ ) 
    {
        // ! this angle must be negative, for correct vertex orientation !
        angle = - 0.5f * PI * i / stacks;

        // transform to get next circle of points + center
        TransformCircle( angle, pi, pB, numPoints+1, &anchor );

        // calculate normals
        center = pB[numPoints];
        CalcNormals( pB, nB, &center, numPoints );

        // calculate next 's' texture coord
        tex_s[1] = (float) s_start + s_delta * i / stacks;

        curTex_t = tex_t;
        pTA = pA;
        pTB = pB;
        nTA = nA;
        nTB = nB;

        for (j = 0; j < numPoints; j++) 
        {
            vCurQuad->p = *pTA++;
            vCurQuad->n = *nTA++;
            if( texRep )
            {
                vCurQuad->tu = (float) tex_s[0];
                vCurQuad->tv = (float) *curTex_t;
            }
            vCurQuad++;

            vCurQuad->p = *pTB++;
            vCurQuad->n = *nTB++;
            if( texRep )
            {
                vCurQuad->tu = (float) tex_s[1];
                vCurQuad->tv = (float) *curTex_t++;
            }
            vCurQuad++;
        }

        // reset pointers
        pA = pB;
        nA = nB;
        pB = (pB == p0) ? p1 : p0;
        nB = (nB == n0) ? n1 : n0;
        tex_s[0] = tex_s[1];
    }

    D3DVERTEX* v;
    DWORD dwCurQuad = 0;
    DWORD dwVert = 0;

    m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );

    for (j = 0; j < stacks; j++) 
    {
        for (i = 0; i < numPoints; i++) 
        {
            if(  i==0 )
            {
                dwCurQuad++;
                continue;
            }

            // Vertices 2n-1, 2n, 2n+2, and 2n+1 define quadrilateral n
            DWORD dwTemp = dwCurQuad*2-1;

            v[dwVert++] = vQuad[dwTemp];
            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+2];

            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+1];
            v[dwVert++] = vQuad[dwTemp+2];

            dwCurQuad++;
        }
    }

    m_pVB->Unlock();

    SAFE_DELETE_ARRAY( vQuad );
}




//-----------------------------------------------------------------------------
// Name: BuildBallJoint
// Desc: - These are very similar to the elbows, in that the starting    
//         and ending positions are almost identical.   The difference   
//         here is that the circles in the sweep describe a sphere as    
//         they are rotated.                                            
//-----------------------------------------------------------------------------
void BALLJOINT_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, int notch, 
                              float s_start, float s_end )
{
    float ballRadius;
    float angle, delta_a, startAng, theta;
    int numPoints;
    float s_delta;
    D3DXVECTOR3 pi0[CACHE_SIZE]; // 2 circles of untransformed points
    D3DXVECTOR3 pi1[CACHE_SIZE];
    D3DXVECTOR3 p0[CACHE_SIZE]; // 2 rows of transformed points
    D3DXVECTOR3 p1[CACHE_SIZE];
    D3DXVECTOR3 n0[CACHE_SIZE]; // 2 rows of normals
    D3DXVECTOR3 n1[CACHE_SIZE];
    float   r[CACHE_SIZE];  // radii of the circles
    float tex_t[CACHE_SIZE];// 't' texture coords
    float tex_s[2];  // 's' texture coords
    D3DXVECTOR3 center;  // center of circle
    D3DXVECTOR3 anchor;  // where circle is anchored
    D3DXVECTOR3 *pA, *pB, *nA, *nB;
    float* curTex_t;
    D3DXVECTOR3* pTA;
    D3DXVECTOR3* pTB;
    D3DXVECTOR3* nTA;
    D3DXVECTOR3* nTB;
    int i, j, k;
    int   stacks, slices;
    IPOINT2D *texRep = pBuildInfo->m_texRep;
    float radius = pBuildInfo->m_radius;

    slices = pBuildInfo->m_nSlices;
    stacks = slices;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;

    // calculate the radii for each circle in the sweep, where
    // r[i] = y = sin(angle)/r

    angle = PI / 4;  // first radius always at 45.0 degrees
    delta_a = (PI / 2.0f) / stacks;

    ballRadius = ROOT_TWO * radius;
    for( i = 0; i <= stacks; i ++, angle += delta_a ) 
    {
        r[i] = (float) sin(angle) * ballRadius;
    }

    // calculate 't' texture coords
    for( i = 0; i <= slices; i ++ ) 
    {
        tex_t[i] = (float) i * texRep->y / slices;
    }

    s_delta = s_end - s_start;
 
    numPoints = slices + 1;

    // unlike the elbow, the center for the ball joint is constant
    center.x = center.y = 0.0f;
    center.z = -radius;

    // starting angle along circle, increment 90.0 degrees each time
    startAng = notch * PI / 2;

    // calc initial circle of points for circle centered at 0,r,-r
    // points start at (0,r,0), and rotate circle CCW

    delta_a = 2 * PI / slices;
    for( i = 0, theta = startAng; i <= slices; i ++, theta += delta_a ) 
    {
        pi0[i].x = r[0] * (float) sin(theta);
        pi0[i].y = radius;
        // translate z by -r, cuz these cos calcs are for circle at origin
        pi0[i].z = r[0] * (float) cos(theta) - r[0];
    }

    // anchor point
    anchor.x = anchor.z = 0.0f;
    anchor.y = radius;

    // calculate initial normals
    CalcNormals( pi0, n0, &center, numPoints );

    // initial 's' texture coordinate
    tex_s[0] = s_start;

    // setup pointers
    pA = pi0; // circles of transformed points
    pB = p0;
    nA = n0; // circles of transformed normals
    nB = n1;

    DWORD dwNumQuadStripsPerStack = numPoints - 1;
    DWORD dwNumQuadStrips = dwNumQuadStripsPerStack * stacks;
    m_dwNumTriangles = dwNumQuadStrips * 2;
    DWORD dwNumVertices = m_dwNumTriangles * 3;
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(D3DVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_VERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
        return;

    D3DVERTEX* vQuad;
    D3DVERTEX* vCurQuad;
    vQuad = new D3DVERTEX[dwNumVertices];
    ZeroMemory( vQuad, sizeof(D3DVERTEX) * dwNumVertices );

    vCurQuad = vQuad;
    for( i = 1; i <= stacks; i ++ ) 
    {
        // ! this angle must be negative, for correct vertex orientation !
        angle = - 0.5f * PI * i / stacks;

        for( k = 0, theta = startAng; k <= slices; k ++, theta+=delta_a ) 
        {
            pi1[k].x = r[i] * (float) sin(theta);
            pi1[k].y = radius;
            // translate z by -r, cuz calcs are for circle at origin
            pi1[k].z = r[i] * (float) cos(theta) - r[i];
        }

        // transform to get next circle of points + center
        TransformCircle( angle, pi1, pB, numPoints, &anchor );

        // calculate normals
        CalcNormals( pB, nB, &center, numPoints );

        // calculate next 's' texture coord
        tex_s[1] = (float) s_start + s_delta * i / stacks;

        curTex_t = tex_t;
        pTA = pA;
        pTB = pB;
        nTA = nA;
        nTB = nB;

        for (j = 0; j < numPoints; j++) 
        {
            vCurQuad->p = *pTA++;
            vCurQuad->n = *nTA++;
            if( texRep )
            {
                vCurQuad->tu = (float) tex_s[0];
                vCurQuad->tv = (float) *curTex_t;
            }
            vCurQuad++;

            vCurQuad->p = *pTB++;
            vCurQuad->n = *nTB++;
            if( texRep )
            {
                vCurQuad->tu = (float) tex_s[1];
                vCurQuad->tv = (float) *curTex_t++;
            }
            vCurQuad++;
        }

        // reset pointers
        pA = pB;
        nA = nB;
        pB = (pB == p0) ? p1 : p0;
        nB = (nB == n0) ? n1 : n0;
        tex_s[0] = tex_s[1];
    }

    D3DVERTEX* v;
    DWORD dwCurQuad = 0;
    DWORD dwVert = 0;

    m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );

    for (j = 0; j < stacks; j++) 
    {
        for (i = 0; i < numPoints; i++) 
        {
            if(  i==0 )
            {
                dwCurQuad++;
                continue;
            }

            // Vertices 2n-1, 2n, 2n+2, and 2n+1 define quadrilateral n
            DWORD dwTemp = dwCurQuad*2-1;

            v[dwVert++] = vQuad[dwTemp];
            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+2];

            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+1];
            v[dwVert++] = vQuad[dwTemp+2];

            dwCurQuad++;
        }
    }

    m_pVB->Unlock();
    
    SAFE_DELETE_ARRAY( vQuad );
}

// 'glu' routines
#ifdef _EXTENSIONS_
#define COS cosf
#define SIN sinf
#define SQRT sqrtf
#else
#define COS cos
#define SIN sin
#define SQRT sqrt
#endif




//-----------------------------------------------------------------------------
// Name: BuildCylinder
// Desc: 
//-----------------------------------------------------------------------------
void PIPE_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, float length, float s_start, 
                         float s_end )
{
    int   stacks, slices;
    int   i,j;
    float sinCache[CACHE_SIZE];
    float cosCache[CACHE_SIZE];
    float sinCache2[CACHE_SIZE];
    float cosCache2[CACHE_SIZE];
    float angle;
    float zNormal;
    float s_delta;
    float zHigh, zLow;
    IPOINT2D *texRep = pBuildInfo->m_texRep;
    float radius = pBuildInfo->m_radius;

    slices = pBuildInfo->m_nSlices;
    stacks = (int) SS_ROUND_UP( (length/pBuildInfo->m_divSize) * (float)slices) ;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;
    zNormal = 0.0f;

    s_delta = s_end - s_start;

    for (i = 0; i < slices; i++) 
    {
        angle = 2 * PI * i / slices;
        sinCache2[i] = (float) SIN(angle);
        cosCache2[i] = (float) COS(angle);
        sinCache[i] = (float) SIN(angle);
        cosCache[i] = (float) COS(angle);
    }

    sinCache[slices] = sinCache[0];
    cosCache[slices] = cosCache[0];
    sinCache2[slices] = sinCache2[0];
    cosCache2[slices] = cosCache2[0];

    DWORD dwNumQuadStripsPerStack = slices;
    DWORD dwNumQuadStrips = dwNumQuadStripsPerStack * stacks;
    m_dwNumTriangles = dwNumQuadStrips * 2;
    DWORD dwNumVertices = m_dwNumTriangles * 3;
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(D3DVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_VERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
        return;

    D3DVERTEX* vQuad;
    D3DVERTEX* vCurQuad;
    vQuad = new D3DVERTEX[dwNumVertices];
    ZeroMemory( vQuad, sizeof(D3DVERTEX) * dwNumVertices );

    vCurQuad = vQuad;
    for (j = 0; j < stacks; j++) 
    {
        zLow = j * length / stacks;
        zHigh = (j + 1) * length / stacks;

        for (i = 0; i <= slices; i++) 
        {
            vCurQuad->p = D3DXVECTOR3( radius * sinCache[i], radius * cosCache[i], zLow );
            vCurQuad->n = D3DXVECTOR3( sinCache2[i], cosCache2[i], zNormal );
            if( texRep )
            {
                vCurQuad->tu = (float) s_start + s_delta * j / stacks;
                vCurQuad->tv = (float) i * texRep->y / slices;
            }
            vCurQuad++;

            vCurQuad->p = D3DXVECTOR3( radius * sinCache[i], radius * cosCache[i], zHigh );
            vCurQuad->n = D3DXVECTOR3( sinCache2[i], cosCache2[i], zNormal );
            if( texRep )
            {
                vCurQuad->tu = (float) s_start + s_delta*(j+1) / stacks;
                vCurQuad->tv = (float) i * texRep->y / slices;
            }
            vCurQuad++;
        }
    }

    D3DVERTEX* v;
    DWORD dwCurQuad = 0;
    DWORD dwVert = 0;

    m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );

    for (j = 0; j < stacks; j++) 
    {
        for (i = 0; i <= slices; i++) 
        {
            if(  i==0 )
            {
                dwCurQuad++;
                continue;
            }
            // Vertices 2n-1, 2n, 2n+2, and 2n+1 define quadrilateral n
            DWORD dwTemp = dwCurQuad*2-1;

            v[dwVert++] = vQuad[dwTemp];
            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+2];

            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+1];
            v[dwVert++] = vQuad[dwTemp+2];

            dwCurQuad++;
        }
    }

    m_pVB->Unlock();

    SAFE_DELETE_ARRAY( vQuad );
}




//-----------------------------------------------------------------------------
// Name: pipeSphere
// Desc: 
//-----------------------------------------------------------------------------
void SPHERE_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, float radius, 
                           float s_start, float s_end)
{
    int i,j;
    float sinCache1a[CACHE_SIZE];
    float cosCache1a[CACHE_SIZE];
    float sinCache2a[CACHE_SIZE];
    float cosCache2a[CACHE_SIZE];
    float sinCache1b[CACHE_SIZE];
    float cosCache1b[CACHE_SIZE];
    float sinCache2b[CACHE_SIZE];
    float cosCache2b[CACHE_SIZE];
    float angle;
    float s_delta;
    int   stacks, slices;
    IPOINT2D *texRep = pBuildInfo->m_texRep;

    slices = pBuildInfo->m_nSlices;
    stacks = slices;
    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;

    // invert sense of s - it seems the glu sphere is not built similarly
    // to the glu cylinder
    // (this probably means stacks don't grow along +z - check it out)
    s_delta = s_start;
    s_start = s_end;
    s_end = s_delta; 

    s_delta = s_end - s_start;

    // Cache is the vertex locations cache
    //  Cache2 is the various normals at the vertices themselves
    for (i = 0; i < slices; i++) 
    {
        angle = 2 * PI * i / slices;
        sinCache1a[i] = (float) SIN(angle);
        cosCache1a[i] = (float) COS(angle);
        sinCache2a[i] = sinCache1a[i];
        cosCache2a[i] = cosCache1a[i];
    }

    for (j = 0; j <= stacks; j++) 
    {
        angle = PI * j / stacks;
        sinCache2b[j] = (float) SIN(angle);
        cosCache2b[j] = (float) COS(angle);
        sinCache1b[j] = radius * (float) SIN(angle);
        cosCache1b[j] = radius * (float) COS(angle);
    }

    // Make sure it comes to a point 
    sinCache1b[0] = 0.0f;
    sinCache1b[stacks] = 0.0f;

    sinCache1a[slices] = sinCache1a[0];
    cosCache1a[slices] = cosCache1a[0];
    sinCache2a[slices] = sinCache2a[0];
    cosCache2a[slices] = cosCache2a[0];

    int start, finish;
    float zLow, zHigh;
    float sintemp1, sintemp2, sintemp3, sintemp4;
    float costemp3, costemp4;

    start = 0;
    finish = stacks;

    DWORD dwNumQuadStripsPerStack = slices;
    DWORD dwNumQuadStrips = dwNumQuadStripsPerStack * (finish-start);
    m_dwNumTriangles = dwNumQuadStrips * 2;
    DWORD dwNumVertices = m_dwNumTriangles * 3;
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(D3DVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_VERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
        return;

    D3DVERTEX* vQuad;
    D3DVERTEX* vCurQuad;
    vQuad = new D3DVERTEX[dwNumVertices];
    ZeroMemory( vQuad, sizeof(D3DVERTEX) * dwNumVertices );

    vCurQuad = vQuad;
    for (j = 0; j < stacks; j++) 
    {
        zLow = cosCache1b[j];
        zHigh = cosCache1b[j+1];
        sintemp1 = sinCache1b[j];
        sintemp2 = sinCache1b[j+1];

        sintemp3 = sinCache2b[j+1];
        costemp3 = cosCache2b[j+1];
        sintemp4 = sinCache2b[j];
        costemp4 = cosCache2b[j];

        for (i = 0; i <= slices; i++) 
        {

            vCurQuad->p = D3DXVECTOR3( sintemp2 * sinCache1a[i], sintemp2 * cosCache1a[i], zHigh );
            vCurQuad->n = D3DXVECTOR3( sinCache2a[i] * sintemp3, cosCache2a[i] * sintemp3, costemp3 );
            if( texRep )
            {
                vCurQuad->tu = (float) s_start + s_delta*(j+1) / stacks;
                vCurQuad->tv = (float) i * texRep->y / slices;
            }
            vCurQuad++;

            vCurQuad->p = D3DXVECTOR3( sintemp1 * sinCache1a[i], sintemp1 * cosCache1a[i], zLow );
            vCurQuad->n = D3DXVECTOR3( sinCache2a[i] * sintemp4, cosCache2a[i] * sintemp4, costemp4 );
            if( texRep )
            {
                vCurQuad->tu = (float) s_start + s_delta * j / stacks;
                vCurQuad->tv = (float) i * texRep->y / slices;
            }
            vCurQuad++;

        }
    }

    D3DVERTEX* v;
    DWORD dwCurQuad = 0;
    DWORD dwVert = 0;

    m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );

    for (j = 0; j < stacks; j++) 
    {
        for (i = 0; i <= slices; i++) 
        {
            if(  i==0 )
            {
                dwCurQuad++;
                continue;
            }
            // Vertices 2n-1, 2n, 2n+2, and 2n+1 define quadrilateral n
            DWORD dwTemp = dwCurQuad*2-1;

            v[dwVert++] = vQuad[dwTemp];
            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+2];

            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+1];
            v[dwVert++] = vQuad[dwTemp+2];

            dwCurQuad++;
        }
    }

    m_pVB->Unlock();

    SAFE_DELETE_ARRAY( vQuad );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\nstate.h ===
//-----------------------------------------------------------------------------
// File: nstate.h
//
// Desc: NORMAL_STATE
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __nstate_h__
#define __nstate_h__

#define NORMAL_PIPE_COUNT       5
#define NORMAL_TEX_PIPE_COUNT   3
#define NUM_JOINT_STYLES        3


// styles for pipe joints
enum 
{
    ELBOWS = 0,
    BALLS,
    EITHER
};

// joint types
enum 
{
    ELBOW_JOINT = 0,
    BALL_JOINT
};

// shchemes for choosing directions
enum 
{
    NORMAL_SCHEME_CHOOSE_DIR_RANDOM,
    NORMAL_SCHEME_CHOOSE_DIR_TURN,
    NORMAL_SCHEME_CHOOSE_DIR_STRAIGHT
};

// this used for traditional pipe drawing
class PIPE_OBJECT;
class ELBOW_OBJECT;
class SPHERE_OBJECT;
class BALLJOINT_OBJECT;
class STATE;




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class NORMAL_STATE 
{
public:
    int                 m_jointStyle;
    int                 m_bCycleJointStyles;
    IDirect3DDevice8*   m_pd3dDevice;
    
    PIPE_OBJECT*        m_pShortPipe;
    PIPE_OBJECT*        m_pLongPipe;
    ELBOW_OBJECT*       m_pElbows[4];
    SPHERE_OBJECT*      m_pBallCap;
    SPHERE_OBJECT*      m_pBigBall;
    BALLJOINT_OBJECT*   m_pBallJoints[4];

    NORMAL_STATE( STATE *pState );
    ~NORMAL_STATE();

    void            Reset();
    void            BuildObjects( float radius, float divSize, int nSlices,
                                  BOOL bTexture, IPOINT2D *pTexRep );  
    int             ChooseJointType();
};

#endif // __nstate_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\pipe.cpp ===
//-----------------------------------------------------------------------------
// File: pipe.cpp
//
// Desc: Pipe base class stuff
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: PIPE constructor
// Desc: 
//-----------------------------------------------------------------------------
PIPE::PIPE( STATE *state )
{
    m_pState = state;
    m_pWorldMatrixStack = m_pState->m_pWorldMatrixStack;
    m_radius = m_pState->m_radius;

    // default direction choosing is random
    m_chooseDirMethod = CHOOSE_DIR_RANDOM_WEIGHTED;
    m_chooseStartPosMethod = CHOOSE_STARTPOS_RANDOM;
    m_weightStraight = 1;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
PIPE::~PIPE()
{
}




//-----------------------------------------------------------------------------
// Name: ChooseMaterial
// Desc: 
//-----------------------------------------------------------------------------
void PIPE::ChooseMaterial( )
{
    if( m_pState->m_bUseTexture )
        m_pMat = RandomTexMaterial();
    else
        m_pMat = RandomTeaMaterial();
}




//-----------------------------------------------------------------------------
// Name: SetChooseDirectionMethod
// Desc: 
//-----------------------------------------------------------------------------
void PIPE::SetChooseDirectionMethod( int method )
{
    m_chooseDirMethod = method;
}




//-----------------------------------------------------------------------------
// Name: ChooseNewDirection
// Desc: Call direction-finding function based on current method
//       This is a generic entry point that is used by some pipe types
//-----------------------------------------------------------------------------
int PIPE::ChooseNewDirection()
{
    NODE_ARRAY* nodes = m_pState->m_nodes;
    int bestDirs[NUM_DIRS], nBestDirs;

    // figger out which fn to call
    switch( m_chooseDirMethod ) 
    {
        case CHOOSE_DIR_CHASE:
            if( nBestDirs = GetBestDirsForChase( bestDirs ) )
                return nodes->ChoosePreferredDirection( &m_curPos, m_lastDir, 
                                                        bestDirs, nBestDirs );
            // else lead pipe must have died, so fall thru:

        case CHOOSE_DIR_RANDOM_WEIGHTED :
        default:
            return nodes->ChooseRandomDirection( &m_curPos, m_lastDir, m_weightStraight );
    }
}




//-----------------------------------------------------------------------------
// Name: GetBestDirsForChase
// Desc: Find the best directions to take to close in on the lead pipe in chase mode.
//
//       mf: ? but want to use similar scheme for turning flex pipes !! (later) 
//-----------------------------------------------------------------------------
int PIPE::GetBestDirsForChase( int *bestDirs )
{
    // Figure out best dirs to close in on leadPos

    //mf: will have to 'protect' leadPos with GetLeadPos() for multi-threading
    IPOINT3D* leadPos = &m_pState->m_pLeadPipe->m_curPos;
    IPOINT3D delta;
    int numDirs = 0;

    delta.x = leadPos->x - m_curPos.x;
    delta.y = leadPos->y - m_curPos.y;
    delta.z = leadPos->z - m_curPos.z;

    if( delta.x ) 
    {
        numDirs++;
        *bestDirs++ = delta.x > 0 ? PLUS_X : MINUS_X;
    }

    if( delta.y ) 
    {
        numDirs++;
        *bestDirs++ = delta.y > 0 ? PLUS_Y : MINUS_Y;
    }

    if( delta.z ) 
    {
        numDirs++;
        *bestDirs++ = delta.z > 0 ? PLUS_Z : MINUS_Z;
    }

    // It should be impossible for numDirs = 0 (all deltas = 0), as this
    // means curPos = leadPos
    return numDirs;
}




//-----------------------------------------------------------------------------
// Name: SetChooseStartPosMethod
// Desc: 
//-----------------------------------------------------------------------------
void PIPE::SetChooseStartPosMethod( int method )
{
    m_chooseStartPosMethod = method;
}




//-----------------------------------------------------------------------------
// Name: PIPE::SetStartPos
// Desc: - Find an empty node to start the pipe on
//-----------------------------------------------------------------------------
BOOL PIPE::SetStartPos()
{
    NODE_ARRAY* nodes = m_pState->m_nodes;

    switch( m_chooseStartPosMethod ) 
    {
        case CHOOSE_STARTPOS_RANDOM:
        default:
            if( !nodes->FindRandomEmptyNode( &m_curPos ) ) 
            {
                return FALSE;
            }
            return TRUE;
        
        case CHOOSE_STARTPOS_FURTHEST:
            // find node furthest away from curPos
            IPOINT3D refPos, numNodes;
            nodes->GetNodeCount( &numNodes );
            refPos.x = (m_curPos.x >= (numNodes.x / 2)) ? 0 : numNodes.x - 1;
            refPos.y = (m_curPos.y >= (numNodes.y / 2)) ? 0 : numNodes.y - 1;
            refPos.z = (m_curPos.z >= (numNodes.z / 2)) ? 0 : numNodes.z - 1;

            if( !nodes->TakeClosestEmptyNode( &m_curPos, &refPos ) ) 
            {
                return FALSE;
            }
            return TRUE;
    }
}




//-----------------------------------------------------------------------------
// Name: PIPE::IsStuck
// Desc: 
//-----------------------------------------------------------------------------
BOOL PIPE::IsStuck()
{
    return m_status == PIPE_STUCK;
}




//-----------------------------------------------------------------------------
// Name: PIPE::TranslateToCurrentPosition
// Desc: 
//-----------------------------------------------------------------------------
void PIPE::TranslateToCurrentPosition()
{
    IPOINT3D numNodes;

    float divSize = m_pState->m_view.m_divSize;

    // this requires knowing the size of the node array
    m_pState->m_nodes->GetNodeCount( &numNodes );

    m_pWorldMatrixStack->TranslateLocal( (m_curPos.x - (numNodes.x - 1)/2.0f )*divSize,
                                    (m_curPos.y - (numNodes.y - 1)/2.0f )*divSize,
                                    (m_curPos.z - (numNodes.z - 1)/2.0f )*divSize );

}




//-----------------------------------------------------------------------------
// Name: UpdateCurrentPosition
// Desc: Increment current position according to direction taken
//-----------------------------------------------------------------------------
void PIPE::UpdateCurrentPosition( int newDir )
{
    switch( newDir ) 
    {
        case PLUS_X:
            m_curPos.x += 1;
            break;
        case MINUS_X:
            m_curPos.x -= 1;
            break;
        case PLUS_Y:
            m_curPos.y += 1;
            break;
        case MINUS_Y:
            m_curPos.y -= 1;
            break;
        case PLUS_Z:
            m_curPos.z += 1;
            break;
        case MINUS_Z:
            m_curPos.z -= 1;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: align_plusz
// Desc: - Aligns the z axis along specified direction
//       - Used for all types of pipes
//-----------------------------------------------------------------------------
void PIPE::align_plusz( int newDir )
{
    static D3DXVECTOR3 xAxis = D3DXVECTOR3(1.0f,0.0f,0.0f);
    static D3DXVECTOR3 yAxis = D3DXVECTOR3(0.0f,1.0f,0.0f);

    // align +z along new direction
    switch( newDir ) 
    {
        case PLUS_X:
            m_pWorldMatrixStack->RotateAxisLocal( &yAxis, PI/2.0f );
            break;
        case MINUS_X:
            m_pWorldMatrixStack->RotateAxisLocal( &yAxis, -PI/2.0f );
            break;
        case PLUS_Y:
            m_pWorldMatrixStack->RotateAxisLocal( &xAxis, -PI/2.0f );
            break;
        case MINUS_Y:
            m_pWorldMatrixStack->RotateAxisLocal( &xAxis, PI/2.0f );
            break;
        case PLUS_Z:
            m_pWorldMatrixStack->RotateAxisLocal( &yAxis, 0.0f );
            break;
        case MINUS_Z:
            m_pWorldMatrixStack->RotateAxisLocal( &yAxis, PI );
            break;

    }
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: this array tells you which way the notch will be once you make
//       a turn
//       format: notchTurn[oldDir][newDir][notchVec] 
//-----------------------------------------------------------------------------
int notchTurn[NUM_DIRS][NUM_DIRS][NUM_DIRS] = 
{
// oldDir = +x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Z, MINUS_Z,
        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,
        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X,
        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,
// oldDir = -x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,
        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Z, MINUS_Z,
        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,
        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X,

// oldDir = +y
        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_Z, MINUS_Z,
        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_Z, MINUS_Z,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y,
        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y,
// oldDir = -y
        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_Z, MINUS_Z,
        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_Z, MINUS_Z,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y,
        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y,

// oldDir = +z
        MINUS_Z,PLUS_Z, PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_Z, MINUS_Z,PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_X, MINUS_X,MINUS_Z,PLUS_Z, iXX,    iXX,
        PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
// oldDir = -z
        PLUS_Z, MINUS_Z,PLUS_Y, MINUS_Y,iXX,    iXX,
        MINUS_Z,PLUS_Z, PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,iXX,    iXX,
        PLUS_X, MINUS_X,MINUS_Z,PLUS_Z, iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\objects.h ===
//-----------------------------------------------------------------------------
// File: objects.h
//
// Desc: 
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __objects_h__
#define __objects_h__



//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class OBJECT_BUILD_INFO 
{
public:
    float       m_radius;
    float       m_divSize;
    int         m_nSlices;
    BOOL        m_bTexture;
    IPOINT2D*   m_texRep;
};




//-----------------------------------------------------------------------------
// Name: OBJECT classes
// Desc: - Display list objects
//-----------------------------------------------------------------------------
class OBJECT 
{
protected:
    int         m_listNum;
    int         m_nSlices;

    IDirect3DDevice8*       m_pd3dDevice;
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwNumTriangles;

public:
    void        Draw( D3DXMATRIX* pWorldMat );

    OBJECT( IDirect3DDevice8* pd3dDevice );
    ~OBJECT();
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class PIPE_OBJECT : public OBJECT 
{
private:
    void Build( OBJECT_BUILD_INFO *state, float length, float start_s, float s_end );
public:
    PIPE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, float length );
    PIPE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, float length, float start_s, float end_s );
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class ELBOW_OBJECT : public OBJECT 
{
private:
    void Build( OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
public:
    ELBOW_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, int notch );
    ELBOW_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class BALLJOINT_OBJECT : public OBJECT 
{
private:
    void Build( OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
public:
    // texturing version only
    BALLJOINT_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class SPHERE_OBJECT : public OBJECT 
{
private:
    void Build( OBJECT_BUILD_INFO *state, float radius, float start_s, float end_s );
public:
    SPHERE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, float radius, float start_s, float end_s );
    SPHERE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, float radius );
};


#endif // __objects_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\pipe.h ===
//-----------------------------------------------------------------------------
// File: pipe.h
//
// Desc: PIPE base class
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __pipe_h__
#define __pipe_h__

// pipe drawing status
enum 
{
    PIPE_ACTIVE,
    PIPE_STUCK,
    PIPE_OUT_OF_NODES
};

// pipe types
enum 
{
    TYPE_NORMAL,
    TYPE_FLEX_REGULAR,
    TYPE_FLEX_TURNING
};

// ways pipe choose directions
enum 
{
    CHOOSE_DIR_RANDOM_WEIGHTED,
    CHOOSE_DIR_CHASE // when chasing a lead pipe
};

// ways pipe choose start positions
enum 
{
    CHOOSE_STARTPOS_RANDOM,
    CHOOSE_STARTPOS_FURTHEST // furthest from last position
};




//-----------------------------------------------------------------------------
// Name: PIPE class
// Desc: - Describes a pipe that draws thru the node array
//       - Could have more than one pipe drawing in each array at same time
//       - Pipe has position and direction in node array
//-----------------------------------------------------------------------------
class STATE;

class PIPE 
{
public:
    int         m_type;
    IPOINT3D    m_curPos;         // current node position of pipe
    D3DMATERIAL8* m_pMat;

    STATE*      m_pState;        // for state value access

    void        SetChooseDirectionMethod( int method );
    void        SetChooseStartPosMethod( int method );
    int         ChooseNewDirection();
    BOOL        IsStuck();      // if pipe is stuck or not
    BOOL        NowhereToRun()          { return m_status == PIPE_OUT_OF_NODES; }

    PIPE( STATE *state );
    virtual ~PIPE();
    virtual void Start() = 0;
    virtual void Draw() = 0;

protected:
    float       m_radius;         // ideal radius (fluctuates for FPIPE)
    int         m_status;         // ACTIVE/STUCK/STOPPED, etc.
    int         m_lastDir;        // last direction taken by pipe
    int         m_notchVec;       // current notch vector
    int         m_weightStraight; // current weighting of going straight
    ID3DXMatrixStack* m_pWorldMatrixStack;

    BOOL        SetStartPos();  // starting node position
    void        ChooseMaterial();
    void        UpdateCurrentPosition( int dir );
    void        TranslateToCurrentPosition();
    void        align_plusz( int newDir );

private:
    int         m_chooseDirMethod;
    int         m_chooseStartPosMethod;

    int         GetBestDirsForChase( int *bestDirs );
};

extern void align_plusz( int newDir );
extern int notchTurn[NUM_DIRS][NUM_DIRS][NUM_DIRS];

#endif // __pipe_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Pipes.rc
//

#define IDS_DESCRIPTION			1
#define IDD_CONFIGURE                   106
#define IDB_DEFTEX                      107

#define IDI_MAIN_ICON                   101
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201

#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016

#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112

#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212



#define IDC_RADIO_SINGLE_PIPE           3000
#define IDC_RADIO_MULTIPLE_PIPES        3001
#define IDC_RADIO_NORMAL                3002
#define IDC_RADIO_FLEX                  3003
#define IDC_STATIC_TESS_GRP             3004
#define IDC_STATIC_JOINTTYPE            3005
#define IDC_RADIO_SOLID                 3006
#define IDC_RADIO_TEX                   3007
#define DLG_COMBO_JOINTTYPE             3008
#define IDC_STATIC_TESS_MIN             3009
#define IDC_STATIC_TESS_MAX             3010
#define DLG_SETUP_TESSEL                3011
#define DLG_SETUP_TEXTURE               3012
#define IDC_SCREENSETTINGS	        3013
#define IDC_SPEED_SLIDER                3014
#define IDS_TEXTUREFILTER               3015
#define IDS_TEXTUREDIALOGTITLE          3016
#define IDS_TITLE			3017

#define IDS_JOINT_FIRST 		IDS_JOINT_ELBOW
#define IDS_JOINT_ELBOW                 4001
#define IDS_JOINT_BALL                  4002
#define IDS_JOINT_MIXED                 4003
#define IDS_JOINT_CYCLE                 4004
#define IDS_JOINT_LAST 			IDS_JOINT_CYCLE
#define IDS_JOINT_COUNT 		(IDS_JOINT_LAST-IDS_JOINT_FIRST+1)

#define IDS_JOINTTYPE                   9000
#define IDS_SURFSTYLE                   9001
#define IDS_TEXQUAL                     9002
#define IDS_MULTIPIPES                  9003
#define IDS_SAVERNAME                   9004
#define IDS_INIFILE                     9005
#define IDS_TEXTURE                     9006
    
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40000
#define _APS_NEXT_CONTROL_VALUE         3015
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\pipes.cpp ===
//-----------------------------------------------------------------------------
// File: Pipes.cpp
//
// Desc: Fun screen saver.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: struct MYVERTEX
// Desc: D3D vertex type for this app
//-----------------------------------------------------------------------------
struct MYVERTEX
{
    D3DXVECTOR3 p;     // Position
    FLOAT       tu;    // Vertex texture coordinates
    FLOAT       tv;
    
    MYVERTEX(D3DXVECTOR3 pInit, FLOAT tuInit, FLOAT tvInit)
        { p = pInit; tu = tuInit; tv = tvInit; }
};

#define D3DFVF_MYVERTEX (D3DFVF_XYZ | D3DFVF_TEX1)



#define BUF_SIZE 255
TCHAR g_szSectName[BUF_SIZE];
TCHAR g_szFname[BUF_SIZE];


CPipesScreensaver* g_pMyPipesScreensaver = NULL;



//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    HRESULT hr;
    CPipesScreensaver pipesScreensaverSS;

    if( FAILED( hr = pipesScreensaverSS.Create( hInst ) ) )
    {
        pipesScreensaverSS.DisplayErrorMsg( hr );
        return 0;
    }

    return pipesScreensaverSS.Run();
}




//-----------------------------------------------------------------------------
// Name: CPipesScreensaver()
// Desc: Constructor
//-----------------------------------------------------------------------------
CPipesScreensaver::CPipesScreensaver( )
{
    g_pMyPipesScreensaver = this;

    InitCommonControls();

    for( int i=0; i<MAX_DEVICE_OBJECTS; i++ )
    {
        m_DeviceObjects[i].m_pState = NULL;
    }

    LoadString( NULL, IDS_DESCRIPTION, m_strWindowTitle, 200 );
    m_bUseDepthBuffer = TRUE;
    m_SwapEffectFullscreen = D3DSWAPEFFECT_COPY;
    m_SwapEffectWindowed = D3DSWAPEFFECT_COPY_VSYNC;
    m_pDeviceObjects = NULL;
    lstrcpy( m_strRegPath, TEXT("Software\\Microsoft\\ScreenSavers\\Pipes") );

    m_Config.bMultiPipes     = FALSE;
    m_Config.nJointType      = JOINT_ELBOW;
    m_Config.bTextured       = FALSE;
    m_Config.bDefaultTexture = TRUE;
    lstrcpy( m_Config.strTextureName[0], TEXT("") );
    m_Config.bFlexMode       = FALSE;
    m_Config.dwTesselFact    = 0;
    m_Config.dwSpeed         = 16;
    
    m_iRenderUnit = 0;

    RandInit();
}



//-----------------------------------------------------------------------------
// Name: SetDevice()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::SetDevice( UINT iDevice )
{
    m_pDeviceObjects = &m_DeviceObjects[iDevice];
    m_iRenderUnit = iDevice;
}




//-----------------------------------------------------------------------------
// Name: RegisterSoftwareDevice()
// Desc: This can register the D3D8RGBRasterizer or any other
//       pluggable software rasterizer.
//-----------------------------------------------------------------------------
HRESULT CPipesScreensaver::RegisterSoftwareDevice()
{ 
    m_pD3D->RegisterSoftwareDevice( D3D8RGBRasterizer );

    return S_OK; 
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CPipesScreensaver::FrameMove()
{
    m_pDeviceObjects->m_pState->FrameMove( m_fElapsedTime );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DoPaint()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::DoPaint(HWND hwnd, HDC hdc)
{
    CD3DScreensaver::DoPaint( hwnd, hdc );

    for( int iDevice=0; iDevice<MAX_DEVICE_OBJECTS; iDevice++ )
    {
        if( m_DeviceObjects[iDevice].m_pState )
            m_DeviceObjects[iDevice].m_pState->Repaint();
    }
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CPipesScreensaver::Render()
{
    BOOL bRenderNewPiece = FALSE;

    if( m_Config.dwSpeed == 20 )
    {
        bRenderNewPiece = TRUE;
    }
    else
    {
        FLOAT fCurTime = DXUtil_Timer( TIMER_GETAPPTIME );
        if( fCurTime - m_pDeviceObjects->m_pState->m_fLastTime > 
                            (20-m_Config.dwSpeed) * 0.005 )
        {
            bRenderNewPiece = TRUE;
            m_pDeviceObjects->m_pState->m_fLastTime = fCurTime;
        }
    }

    if( bRenderNewPiece )
    {       
        // Begin the scene 
        if( SUCCEEDED( m_pd3dDevice->BeginScene() ) )
        {
            m_pDeviceObjects->m_pState->Render();

            // End the scene.
            m_pd3dDevice->EndScene();
        }
    }
    else
    {
        if( m_iRenderUnit == 0 )
        {
            // Wait for a little while so we don't draw the pipes too fast
            Sleep(10);
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CPipesScreensaver::RestoreDeviceObjects()
{
    if( m_pd3dDevice == NULL )
        return S_OK;
    
    m_pDeviceObjects->m_pState    = new STATE( &m_Config );
    m_pDeviceObjects->m_pState->InitDeviceObjects( m_pd3dDevice );
    m_pDeviceObjects->m_pState->RestoreDeviceObjects();

    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         0x00000000, 1.0f, 0L );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CPipesScreensaver::InvalidateDeviceObjects()
{
    m_pDeviceObjects->m_pState->InvalidateDeviceObjects();
    m_pDeviceObjects->m_pState->DeleteDeviceObjects();
    SAFE_DELETE( m_pDeviceObjects->m_pState );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ConfigureDialogProcHelper()
// Desc: 
//-----------------------------------------------------------------------------
INT_PTR CALLBACK ConfigureDialogProcHelper( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return g_pMyPipesScreensaver->ConfigureDialogProc( hwndDlg, uMsg, wParam, lParam );
}




//-----------------------------------------------------------------------------
// Name: DoConfig()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::DoConfig()
{
    DialogBox( NULL, MAKEINTRESOURCE(IDD_CONFIGURE), m_hWndParent, ConfigureDialogProcHelper );
}




//-----------------------------------------------------------------------------
// Name: ConfigureDialogProc()
// Desc: 
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CPipesScreensaver::ConfigureDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    static CONFIG s_TempConfig;

    switch (uMsg)
    {
        case WM_INITDIALOG:       
        {
            ReadSettings();
            s_TempConfig = m_Config;
            lstrcpy( s_TempConfig.strTextureName[0], m_Config.strTextureName[0] );

            if( s_TempConfig.bMultiPipes )       
                CheckRadioButton(hwndDlg, IDC_RADIO_SINGLE_PIPE, IDC_RADIO_MULTIPLE_PIPES,
                                 IDC_RADIO_MULTIPLE_PIPES);
            else
                CheckRadioButton(hwndDlg, IDC_RADIO_SINGLE_PIPE, IDC_RADIO_MULTIPLE_PIPES,
                                 IDC_RADIO_SINGLE_PIPE);

            HWND hCtrl = GetDlgItem(hwndDlg, DLG_COMBO_JOINTTYPE);
            SendMessage(hCtrl, CB_RESETCONTENT, 0, 0);

            TCHAR strJointNames[IDS_JOINT_COUNT][MAX_PATH];
            for (int i = 0; i < IDS_JOINT_COUNT; i++)
            {
                LoadString( NULL, i+IDS_JOINT_FIRST, strJointNames[i],
                            sizeof(strJointNames)/IDS_JOINT_COUNT );
                SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)strJointNames[i]);
            }
            SendMessage(hCtrl, CB_SETCURSEL, s_TempConfig.nJointType, 0);

            if( !s_TempConfig.bTextured )
            {
                CheckRadioButton(hwndDlg, IDC_RADIO_SOLID, IDC_RADIO_TEX,
                                 IDC_RADIO_SOLID);
                EnableWindow( GetDlgItem( hwndDlg, DLG_SETUP_TEXTURE ), FALSE );
            }
            else
            {
                CheckRadioButton(hwndDlg, IDC_RADIO_SOLID, IDC_RADIO_TEX,
                                 IDC_RADIO_TEX);
                EnableWindow( GetDlgItem( hwndDlg, DLG_SETUP_TEXTURE ), TRUE );
            }
        
            SendDlgItemMessage( hwndDlg, IDC_SPEED_SLIDER, TBM_SETRANGE, (WPARAM) TRUE, (LPARAM) MAKELONG( 0, 20 ) );
            SendDlgItemMessage( hwndDlg, IDC_SPEED_SLIDER, TBM_SETPOS,   (WPARAM) TRUE, (LPARAM) m_Config.dwSpeed );
            SendDlgItemMessage( hwndDlg, IDC_SPEED_SLIDER, TBM_SETPAGESIZE, (WPARAM) 0, (LPARAM) 5 );
            SendDlgItemMessage( hwndDlg, IDC_SPEED_SLIDER, TBM_SETLINESIZE, (WPARAM) 0, (LPARAM) 1 );
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch( LOWORD( wParam ) )
            {
                case IDC_RADIO_TEX:
                    EnableWindow( GetDlgItem( hwndDlg, DLG_SETUP_TEXTURE ), TRUE );
                    break;

                case IDC_RADIO_SOLID:
                    EnableWindow( GetDlgItem( hwndDlg, DLG_SETUP_TEXTURE ), FALSE );
                    break;

                case DLG_SETUP_TEXTURE:
                {
                    if( SelectTextureFile( hwndDlg, s_TempConfig.strTextureName[0] ) )
                    {
                        CheckRadioButton(hwndDlg, IDC_RADIO_SOLID, IDC_RADIO_TEX,
                                         IDC_RADIO_TEX);
                        s_TempConfig.bDefaultTexture = FALSE;
                    }
                    else
                    {
                        s_TempConfig.bDefaultTexture = TRUE;
                    }
                    break;
                }

                case IDC_SCREENSETTINGS:
                {
                    DoScreenSettingsDialog( hwndDlg ); 
                    break;
                }

                case IDOK:
                {
                    s_TempConfig.bMultiPipes = IsDlgButtonChecked(hwndDlg, IDC_RADIO_MULTIPLE_PIPES);
                    HWND hCtrl = GetDlgItem(hwndDlg, DLG_COMBO_JOINTTYPE);
                    s_TempConfig.nJointType = (DWORD) SendMessage(hCtrl, CB_GETCURSEL, 0, 0);
                    s_TempConfig.bTextured = IsDlgButtonChecked(hwndDlg, IDC_RADIO_TEX);
                    s_TempConfig.dwSpeed = (DWORD) SendDlgItemMessage( hwndDlg, IDC_SPEED_SLIDER, TBM_GETPOS, 0, 0 );

                    m_Config = s_TempConfig;
                    lstrcpy( m_Config.strTextureName[0], s_TempConfig.strTextureName[0] );

                    WriteSettings();
                    EndDialog(hwndDlg, IDOK);
                    break;
                }

                case IDCANCEL:
                {
                    EndDialog(hwndDlg, IDCANCEL);
                    break;
                }
            }
            return TRUE;
        }
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
// Name: SelectTextureFile()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CPipesScreensaver::SelectTextureFile( HWND hDlg, TCHAR* origPathName )
{
    TCHAR fn[MAX_PATH] = TEXT("\0");
    TCHAR szDialogTitle[MAX_PATH];
    TCHAR szTextureFilter[MAX_PATH];
    TCHAR szTitle[MAX_PATH];

    LoadString(NULL, IDS_TEXTUREFILTER, szTextureFilter, MAX_PATH);
    // Filter strings are weird because they contain nulls.
    // The string loaded from a resource has # where nulls
    // should be inserted.
    for( TCHAR* pch = szTextureFilter; *pch != TEXT('\0'); pch++ )
    {
        if (*pch == TEXT('#'))
            *pch = TEXT('\0');
    }
    LoadString(NULL, IDS_TEXTUREDIALOGTITLE, szDialogTitle, MAX_PATH);
    LoadString(NULL, IDS_TITLE, szTitle, MAX_PATH);

    TCHAR szWindowsDir[MAX_PATH];
    szWindowsDir[0] = TEXT('\0');
    GetWindowsDirectory( szWindowsDir, MAX_PATH );

    OPENFILENAME    ofn;
    memset( &ofn, 0, sizeof(ofn) );
    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hDlg;
    ofn.hInstance       = m_hInstance;
    ofn.lpstrFilter     = szTextureFilter;
    ofn.nFilterIndex    = 1;
    ofn.lpstrFile       = origPathName;
    ofn.nMaxFile        = sizeof(fn);
    ofn.lpstrTitle      = szDialogTitle;
    ofn.Flags           = OFN_ENABLESIZING|OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt     = TEXT("BMP");
    if( lstrlen( origPathName ) == 0 )
        ofn.lpstrInitialDir = szWindowsDir;

    if( GetOpenFileName( &ofn ) )
    {
        lstrcpy( origPathName, ofn.lpstrFile );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::ReadSettings()
{
    HKEY hkey;

    // Read OpenGL settings first, so OS upgrade cases work
    ss_ReadSettings();

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        ReadScreenSettings( hkey );

//        DXUtil_ReadBoolRegKey( hkey, TEXT("Flex Mode"), &m_Config.bFlexMode, m_Config.bFlexMode );
        DXUtil_ReadBoolRegKey( hkey, TEXT("MultiPipes"), &m_Config.bMultiPipes, m_Config.bMultiPipes );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Textured"), &m_Config.bTextured, m_Config.bTextured );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Default Texture"), &m_Config.bDefaultTexture, m_Config.bDefaultTexture );
        DXUtil_ReadIntRegKey( hkey, TEXT("Tessel Factor"), &m_Config.dwTesselFact, m_Config.dwTesselFact );
        if( m_Config.dwTesselFact >= 4 )
            m_Config.dwTesselFact = 4;
        DXUtil_ReadIntRegKey( hkey, TEXT("Joint Type"), &m_Config.nJointType, m_Config.nJointType );
        if( m_Config.nJointType >= NUM_JOINTTYPES )
            m_Config.nJointType = JOINT_ELBOW;
        DXUtil_ReadIntRegKey( hkey, TEXT("Speed"), &m_Config.dwSpeed, m_Config.dwSpeed );
        DXUtil_ReadStringRegKey( hkey, TEXT("Texture Name"), m_Config.strTextureName[0], MAX_PATH, m_Config.strTextureName[0] );

        RegCloseKey( hkey );
    }
}




//-----------------------------------------------------------------------------
// Name: ss_ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::ss_ReadSettings()
{
    // Get registry settings
    if( ss_RegistrySetup( IDS_SAVERNAME, IDS_INIFILE ) )
    {
        m_Config.nJointType = ss_GetRegistryInt( IDS_JOINTTYPE, 0 );
        m_Config.bTextured = (ss_GetRegistryInt( IDS_SURFSTYLE, 0 ) == 1);
        if( m_Config.bTextured )
            m_Config.bDefaultTexture = TRUE;

        m_Config.bMultiPipes = ss_GetRegistryInt( IDS_MULTIPIPES, 0 );
        ss_GetRegistryString( IDS_TEXTURE, 0, m_Config.strTextureName[0], MAX_PATH);
        if( lstrlen(m_Config.strTextureName[0]) > 0 )
            m_Config.bDefaultTexture = FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CPipesScreensaver::ss_RegistrySetup( int section, int file )
{
    if( LoadString(m_hInstance, section, g_szSectName, BUF_SIZE) &&
        LoadString(m_hInstance, file, g_szFname, BUF_SIZE) ) 
    {
        TCHAR pBuffer[100];
        DWORD dwRealSize = GetPrivateProfileSection( g_szSectName, pBuffer, 100, g_szFname );
        if( dwRealSize > 0 )
            return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
int CPipesScreensaver::ss_GetRegistryInt( int name, int iDefault )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        return GetPrivateProfileInt(g_szSectName, szItemName, iDefault, g_szFname);

    return 0;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::ss_GetRegistryString( int name, LPTSTR lpDefault, 
                                                         LPTSTR lpDest, int bufSize )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        GetPrivateProfileString(g_szSectName, szItemName, lpDefault, lpDest,
                                bufSize, g_szFname);

    return;
}




//-----------------------------------------------------------------------------
// Name: WriteSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::WriteSettings()
{
    HKEY hkey;
    DWORD dwType = REG_DWORD;
    DWORD dwLength = sizeof(DWORD);

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        WriteScreenSettings( hkey );

//        DXUtil_WriteBoolRegKey( hkey, TEXT("Flex Mode"), m_Config.bFlexMode );
        DXUtil_WriteBoolRegKey( hkey, TEXT("MultiPipes"), m_Config.bMultiPipes );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Textured"), m_Config.bTextured );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Default Texture"), m_Config.bDefaultTexture );
        DXUtil_WriteIntRegKey( hkey, TEXT("Tessel Factor"), m_Config.dwTesselFact );
        DXUtil_WriteIntRegKey( hkey, TEXT("Joint Type"), m_Config.nJointType );
        DXUtil_WriteStringRegKey( hkey, TEXT("Texture Name"), m_Config.strTextureName[0] );
        DXUtil_WriteIntRegKey( hkey, TEXT("Speed"), m_Config.dwSpeed );
        
        RegCloseKey( hkey );
    }
}




//-----------------------------------------------------------------------------
// Name: iRand()
// Desc: Generates integer random number 0..(max-1)
//-----------------------------------------------------------------------------
int CPipesScreensaver::iRand( int max )
{
    return (int) ( max * ( ((float)rand()) / ((float)(RAND_MAX+1)) ) );
}




//-----------------------------------------------------------------------------
// Name: iRand2()
// Desc: Generates integer random number min..max
//-----------------------------------------------------------------------------
int CPipesScreensaver::iRand2( int min, int max )
{
    if( min == max )
    {
        return min;
    }
    else if( max < min ) 
    {
        int temp = min;
        min = max;
        max = temp;
    }

    return min + (int) ( (max-min+1) * ( ((float)rand()) / ((float)(RAND_MAX+1)) ) );
}




//-----------------------------------------------------------------------------
// Name: fRand()
// Desc: Generates float random number min...max
//-----------------------------------------------------------------------------
FLOAT CPipesScreensaver::fRand( FLOAT min, FLOAT max )
{
    FLOAT diff;

    diff = max - min;
    return min + ( diff * ( ((float)rand()) / ((float)(RAND_MAX)) ) );
}




//-----------------------------------------------------------------------------
// Name: RandInit()
// Desc: Initializes the randomizer
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::RandInit()
{
    struct _timeb time;

    _ftime( &time );
    srand( time.millitm );

    for( int i = 0; i < 10; i ++ )
        rand();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\material.cpp ===
//-----------------------------------------------------------------------------
// File: material.cpp
//
// Desc: materials
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"




// 24 tea materials (from teapots app)
#define NUM_TEA_MATERIALS 24

enum 
{
    EMERALD = 0,
    JADE,
    OBSIDIAN,
    PEARL,
    RUBY,
    TURQUOISE,
    BRASS,
    BRONZE,
    CHROME,
    COPPER,
    GOLD,
    SILVER,
    BLACK_PLASTIC,
    CYAN_PLASTIC,
    GREEN_PLASTIC,
    RED_PLASTIC,
    WHITE_PLASTIC,
    YELLOW_PLASTIC,
    BLACK_RUBBER,
    CYAN_RUBBER,
    GREEN_RUBBER,
    RED_RUBBER,
    WHITE_RUBBER,
    YELLOW_RUBBER
};

// 'white' materials, for texturing
#define NUM_TEX_MATERIALS 4

enum 
{
    BRIGHT_WHITE = NUM_TEA_MATERIALS,
    WHITE,
    WARM_WHITE,
    COOL_WHITE
};

#define NUM_GOOD_MATERIALS 16  // 'good' ones among the 24 tea materials

int goodMaterials[NUM_GOOD_MATERIALS] = {
        EMERALD, JADE, PEARL, RUBY, TURQUOISE, BRASS, BRONZE,
        COPPER, GOLD, SILVER, CYAN_PLASTIC, WHITE_PLASTIC, YELLOW_PLASTIC,
        CYAN_RUBBER, GREEN_RUBBER, WHITE_RUBBER };

// materials:  emerald, jade, obsidian, pearl, ruby, turquoise
//              brass, bronze, chrome, copper, gold, silver
//              black, cyan, green, red, white, yellow plastic
//              black, cyan, green, red, white, yellow rubber
// 
// description: ambient(RGB), diffuse(RGB), specular(RGB), shininess
 
// 'tea' materials, from aux teapots program
static float teaMaterialData[NUM_TEA_MATERIALS*10] = 
{
    // EMERALD = 0,
    0.0215f, 0.1745f, 0.0215f, 0.07568f, 0.61424f, 0.07568f, 0.633f, 0.727811f, 0.633f, 0.6f,

    // JADE,
    0.135f, 0.2225f, 0.1575f, 0.54f, 0.89f, 0.63f, 0.316228f, 0.316228f, 0.316228f, 0.1f,

    // OBSIDIAN,
    0.05375f, 0.05f, 0.06625f, 0.18275f, 0.17f, 0.22525f, 0.332741f, 0.328634f, 0.346435f, 0.3f,

    // PEARL,
    0.25f, 0.20725f, 0.20725f, 1.0f, 0.829f, 0.829f, 0.296648f, 0.296648f, 0.296648f, 0.088f,

    // RUBY,
    0.1745f, 0.01175f, 0.01175f, 0.61424f, 0.04136f, 0.04136f, 0.727811f, 0.626959f, 0.626959f, 0.6f,

    // TURQUOISE,
    0.1f, 0.18725f, 0.1745f, 0.396f, 0.74151f, 0.69102f, 0.297254f, 0.30829f, 0.306678f, 0.1f,

    // BRASS,
    0.329412f, 0.223529f, 0.027451f, 0.780392f, 0.568627f, 0.113725f, 0.992157f, 0.941176f, 0.807843f, 0.21794872f,

    // BRONZE,
    0.2125f, 0.1275f, 0.054f, 0.714f, 0.4284f, 0.18144f, 0.393548f, 0.271906f, 0.166721f, 0.2f,

    // CHROME,
    0.25f, 0.25f, 0.25f,  0.4f, 0.4f, 0.4f, 0.774597f, 0.774597f, 0.774597f, 0.6f,

    // COPPER,
    0.19125f, 0.0735f, 0.0225f, 0.7038f, 0.27048f, 0.0828f, 0.256777f, 0.137622f, 0.086014f, 0.1f,

    // GOLD,
    0.24725f, 0.1995f, 0.0745f, 0.75164f, 0.60648f, 0.22648f, 0.628281f, 0.555802f, 0.366065f, 0.4f,

    // SILVER,
    0.19225f, 0.19225f, 0.19225f, 0.50754f, 0.50754f, 0.50754f, 0.508273f, 0.508273f, 0.508273f, 0.4f,

    // BLACK_PLASTIC,
    0.0f, 0.0f, 0.0f, 0.01f, 0.01f, 0.01f, 0.50f, 0.50f, 0.50f, .25f,

    // CYAN_PLASTIC,
    0.0f, 0.1f, 0.06f, 0.0f, 0.50980392f, 0.50980392f, 0.50196078f, 0.50196078f, 0.50196078f, .25f,

    // GREEN_PLASTIC,
    0.0f, 0.0f, 0.0f, 0.1f, 0.35f, 0.1f, 0.45f, 0.55f, 0.45f, .25f,

    // RED_PLASTIC,
    0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.7f, 0.6f, 0.6f, .25f,

    // WHITE_PLASTIC,
    0.0f, 0.0f, 0.0f, 0.55f, 0.55f, 0.55f, 0.70f, 0.70f, 0.70f, .25f,

    // YELLOW_PLASTIC,
    0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.0f, 0.60f, 0.60f, 0.50f, .25f,

    // BLACK_RUBBER,
    0.02f, 0.02f, 0.02f, 0.01f, 0.01f, 0.01f, 0.4f, 0.4f, 0.4f, .078125f,

    // CYAN_RUBBER,
    0.0f, 0.05f, 0.05f, 0.4f, 0.5f, 0.5f, 0.04f, 0.7f, 0.7f, .078125f,

    // GREEN_RUBBER,
    0.0f, 0.05f, 0.0f, 0.4f, 0.5f, 0.4f, 0.04f, 0.7f, 0.04f, .078125f,

    // RED_RUBBER,
    0.05f, 0.0f, 0.0f, 0.5f, 0.4f, 0.4f, 0.7f, 0.04f, 0.04f, .078125f,

    // WHITE_RUBBER,
    0.05f, 0.05f, 0.05f, 0.5f, 0.5f, 0.5f, 0.7f, 0.7f, 0.7f, .078125f,

    // YELLOW_RUBBER
    0.05f, 0.05f, 0.0f, 0.5f, 0.5f, 0.4f, 0.7f, 0.7f, 0.04f, .078125f 
};

// generally white materials for texturing

static float texMaterialData[NUM_TEX_MATERIALS*10] = 
{
// bright white
     0.2f, 0.2f, 0.2f,
        1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.5f,
// less bright white
     0.2f, 0.2f, 0.2f,
        0.9f, 0.9f, 0.9f, 0.9f, 0.9f, 0.9f, 0.5f,
// warmish white
     0.3f, 0.2f, 0.2f,
        1.0f, 0.9f, 0.8f, 1.0f, 0.9f, 0.8f, 0.5f,
// coolish white
     0.2f, 0.2f, 0.3f,
        0.8f, 0.9f, 1.0f, 0.8f, 0.9f, 1.0f, 0.5f
};

D3DMATERIAL8 g_Materials[NUM_TEA_MATERIALS + NUM_TEX_MATERIALS];

//-----------------------------------------------------------------------------
// Name: InitMaterials
// Desc: Initialize MATERIAL structures with data
//       - Set alpha to 0.5 for all materials
//-----------------------------------------------------------------------------
void InitMaterials()
{
    int i;
    float* pf;
    D3DMATERIAL8* pMat;

    pf = &teaMaterialData[0];
    for( i = 0; i < NUM_TEA_MATERIALS; i++ ) 
    {        
        pMat = &g_Materials[i];
        pMat->Ambient.r = *pf++;
        pMat->Ambient.g = *pf++;
        pMat->Ambient.b = *pf++;
        pMat->Ambient.a = 1.0f;

        pMat->Diffuse.r = *pf++;
        pMat->Diffuse.g = *pf++;
        pMat->Diffuse.b = *pf++;
        pMat->Diffuse.a = 1.0f;

        pMat->Specular.r = *pf++;
        pMat->Specular.g = *pf++;
        pMat->Specular.b = *pf++;
        pMat->Specular.a = 1.0f;

        pMat->Power = 128* (*pf++);
    }
   
    pf = &texMaterialData[0];
    for( i = 0; i < NUM_TEX_MATERIALS; i++ ) 
    {        
        pMat = &g_Materials[i+NUM_TEA_MATERIALS];
        pMat->Ambient.r = *pf++;
        pMat->Ambient.g = *pf++;
        pMat->Ambient.b = *pf++;
        pMat->Ambient.a = 1.0f;

        pMat->Diffuse.r = *pf++;
        pMat->Diffuse.g = *pf++;
        pMat->Diffuse.b = *pf++;
        pMat->Diffuse.a = 1.0f;

        pMat->Specular.r = *pf++;
        pMat->Specular.g = *pf++;
        pMat->Specular.b = *pf++;
        pMat->Specular.a = 1.0f;

        pMat->Power = *pf++;
    }
}




//-----------------------------------------------------------------------------
// Name: RandomTeaMaterial
// Desc: Select a random TeaMaterial
//-----------------------------------------------------------------------------
D3DMATERIAL8* RandomTeaMaterial()
{
    int index = goodMaterials[ CPipesScreensaver::iRand(NUM_GOOD_MATERIALS) ];   
    return &g_Materials[ index ];
}




//-----------------------------------------------------------------------------
// Name: RandomTexMaterial
// Desc: Select a random TexMaterial
//-----------------------------------------------------------------------------
D3DMATERIAL8* RandomTexMaterial()
{
    int index = NUM_TEA_MATERIALS + CPipesScreensaver::iRand(NUM_TEX_MATERIALS);   
    return &g_Materials[ index ];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\pipes.h ===
//-----------------------------------------------------------------------------
// File: Pipes.h
//
// Desc: 
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _PIPES_H
#define _PIPES_H


#define MAX_DEVICE_OBJECTS 10

struct DeviceObjects
{
    STATE*    m_pState;
};

struct CONFIG
{
    BOOL  bMultiPipes;
    DWORD nJointType;
    BOOL  bTextured;
    BOOL  bDefaultTexture;
    TCHAR strTextureName[MAX_PATH][MAX_TEXTURES];
    DWORD dwSpeed;
    BOOL  bFlexMode;
    DWORD dwTesselFact;
};



//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class CPipesScreensaver : public CD3DScreensaver
{
protected:
    DeviceObjects  m_DeviceObjects[MAX_DEVICE_OBJECTS];
    DeviceObjects* m_pDeviceObjects;
    int            m_iRenderUnit;

    D3DXCOLOR m_col3;

protected:
    virtual HRESULT RegisterSoftwareDevice();
    virtual VOID    DoConfig();
    virtual VOID    ReadSettings();
            VOID    WriteSettings();
    virtual VOID    DoPaint( HWND hwnd, HDC hdc );

    virtual VOID    SetDevice( UINT iDevice );
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();

    VOID    Randomize( INT* piNum, INT iMax );


public:
    CPipesScreensaver();

    CONFIG  m_Config;
    D3DSURFACE_DESC* GetSurfaceDesc() { return &m_d3dsdBackBuffer; };
    BOOL SelectTextureFile( HWND hDlg, TCHAR* origPathName );

    VOID ss_ReadSettings();
    BOOL ss_RegistrySetup( int section, int file );
    int  ss_GetRegistryInt( int name, int iDefault );
    VOID ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, int bufSize );
    
    // Override from CD3DScreensaver
    INT_PTR CALLBACK ConfigureDialogProc( HWND hwndDlg, UINT uMsg, 
                                          WPARAM wParam, LPARAM lParam );

    static int iRand( int max );
    static int iRand2( int min, int max );
    static FLOAT fRand( FLOAT min, FLOAT max );
    static VOID RandInit();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\state.cpp ===
//-----------------------------------------------------------------------------
// File: state.cpp
//
// Desc: STATE
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: STATE constructor
// Desc: global state init
//       translates variables set from the dialog boxes
//-----------------------------------------------------------------------------
STATE::STATE( CONFIG* pConfig )
{
    ZeroMemory( &m_textureInfo, sizeof(TEXTUREINFO)*MAX_TEXTURES );

    m_pConfig           = pConfig; 
    m_resetStatus       = 0;
    m_pClearVB          = NULL;
    m_pNState           = NULL;
    m_pd3dDevice        = NULL;
    m_pWorldMatrixStack = NULL;
    m_pLeadPipe         = NULL;
    m_nodes             = NULL;
    m_pFState           = NULL;
    m_maxDrawThreads    = 0;
    m_nTextures         = 0;
    m_bUseTexture       = FALSE;
    m_nSlices           = 0;
    m_radius            = 0;
    m_drawMode          = 0;
    m_maxPipesPerFrame  = 0;
    m_nPipesDrawn       = 0;
    m_nDrawThreads      = 0;
    m_fLastTime         = 0.0f;
    m_drawScheme        = FRAME_SCHEME_RANDOM;     // default draw scheme
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STATE::InitDeviceObjects( IDirect3DDevice8* pd3dDevice )
{
    m_pd3dDevice = pd3dDevice;

    if( m_view.SetWinSize( g_pMyPipesScreensaver->GetSurfaceDesc()->Width, 
                           g_pMyPipesScreensaver->GetSurfaceDesc()->Height ) )
        m_resetStatus |= RESET_RESIZE_BIT;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STATE::RestoreDeviceObjects()
{
    int anDefaultResource[1];
    anDefaultResource[0] = IDB_DEFTEX;

    m_bUseTexture = FALSE;
    if( m_pConfig->bTextured )
    {
        if( SUCCEEDED( LoadTextureFiles( 1, m_pConfig->strTextureName, anDefaultResource ) ) )
            m_bUseTexture = TRUE;
    }

    DRAW_THREAD* pThread = m_drawThreads;
    for( int i=0; i<m_maxDrawThreads; i++ ) 
    {
        pThread->InitDeviceObjects( m_pd3dDevice );
        pThread->RestoreDeviceObjects();
        pThread++;
    }

    D3DXCreateMatrixStack( 0, &m_pWorldMatrixStack );

    m_view.SetProjMatrix( m_pd3dDevice );

    D3DCAPS8 d3d8caps;
    ZeroMemory( &d3d8caps, sizeof(D3DCAPS8) );

    m_pd3dDevice->GetDeviceCaps( &d3d8caps );

    if( d3d8caps.TextureOpCaps & D3DTEXOPCAPS_MODULATE )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    } 
    else if( d3d8caps.TextureOpCaps & D3DTEXOPCAPS_SELECTARG1 )
    {
        if( m_bUseTexture )
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        else
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );

        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    }

    if( d3d8caps.TextureFilterCaps & D3DPTFILTERCAPS_MINFLINEAR )
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    else if( d3d8caps.TextureFilterCaps & D3DPTFILTERCAPS_MINFPOINT )
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );

    if( d3d8caps.TextureFilterCaps & D3DPTFILTERCAPS_MAGFLINEAR )
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    else if( d3d8caps.TextureFilterCaps & D3DPTFILTERCAPS_MAGFPOINT )
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );

    if( d3d8caps.TextureAddressCaps & D3DPTADDRESSCAPS_WRAP )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
        m_pd3dDevice->SetRenderState( D3DRS_WRAP0,             D3DWRAP_U | D3DWRAP_V );
    }
    else if( d3d8caps.TextureAddressCaps & D3DPTADDRESSCAPS_CLAMP ) 
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    }

    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,          D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,         D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,          0x00 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,         D3DCMP_GREATER );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,      TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,    TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,           TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_NORMALIZENORMALS,  TRUE );

    if( d3d8caps.PrimitiveMiscCaps & D3DPMISCCAPS_CULLCW ) 
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,          D3DCULL_CW );
    else
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,          D3DCULL_NONE );

    // Set up the lighting states
    ZeroMemory( &m_light, sizeof(D3DLIGHT8) );
    m_light.Type        = D3DLIGHT_DIRECTIONAL;
    m_light.Diffuse.r   = 1.0f;
    m_light.Diffuse.g   = 1.0f;
    m_light.Diffuse.b   = 1.0f;
    m_light.Diffuse.a   = 1.0f;
    if( m_bUseTexture )        
    {
        m_light.Specular.r   = 0.0f;
        m_light.Specular.g   = 0.0f;
        m_light.Specular.b   = 0.0f;
    }
    else
    {
        m_light.Specular.r   = 0.6f;
        m_light.Specular.g   = 0.6f;
        m_light.Specular.b   = 0.6f;
    }
    m_light.Specular.a   = 1.0f;
    m_light.Position.x   = 0.0f;
    m_light.Position.y   = -50.0f;
    m_light.Position.z   = -150.0f;
    m_light.Ambient.r = 0.1f;
    m_light.Ambient.g = 0.1f;
    m_light.Ambient.b = 0.1f;
    m_light.Ambient.a = 1.1f;
    D3DXVec3Normalize( (D3DXVECTOR3*)&m_light.Direction, &D3DXVECTOR3(m_light.Position.x, m_light.Position.y, m_light.Position.z) );
    m_light.Range        = 1000.0f;
    m_pd3dDevice->SetLight( 0, &m_light );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    if( m_bUseTexture )        
        m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0xFF2F2F2F );
    else
        m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0xFFFFFFFF );

    InitMaterials();

    // set 'reference' radius value
    m_radius = 1.0f;

    // convert tesselation from dwTesselFact(0.0-2.0) to tessLevel(0-MAX_TESS)
    int tessLevel = (int) (m_pConfig->dwTesselFact * (MAX_TESS+1) / 2.0001f);
    m_nSlices = (tessLevel+2) * 4;

    // Allocate basic NODE_ARRAY
    // NODE_ARRAY size is determined in Reshape (based on window size)
    m_nodes = new NODE_ARRAY;

    // Set drawing mode, and initialize accordingly.  For now, either all normal
    // or all flex pipes are drawn, but they could be combined later.
    // Can assume here that if there's any possibility that normal pipes
    // will be drawn, NORMAL_STATE will be initialized so that dlists are
    // built
    
    // Again, since have either NORMAL or FLEX, set maxPipesPerFrame,
    // maxDrawThreads
    if( m_pConfig->bMultiPipes )
        m_maxDrawThreads = MAX_DRAW_THREADS;
    else
        m_maxDrawThreads = 1;
    m_nDrawThreads = 0; // no active threads yet
    m_nPipesDrawn = 0;
    // maxPipesPerFrame is set in Reset()

    // Create a square for rendering the clear transition
    SAFE_RELEASE( m_pClearVB );
    m_pd3dDevice->CreateVertexBuffer( 4*sizeof(D3DTLVERTEX),
                                      D3DUSAGE_WRITEONLY, D3DFVF_TLVERTEX,
                                      D3DPOOL_MANAGED, &m_pClearVB );
    // Size the background image
    D3DTLVERTEX* vBackground;
    m_pClearVB->Lock( 0, 0, (BYTE**)&vBackground, 0 );
    for( i=0; i<4; i ++ )
    {
        vBackground[i].p = D3DXVECTOR4( 0.0f, 0.0f, 0.95f, 1.0f );
        vBackground[i].color = 0x20000000;
    }
    vBackground[0].p.y = (FLOAT)m_view.m_winSize.height;
    vBackground[1].p.y = (FLOAT)m_view.m_winSize.height;
    vBackground[1].p.x = (FLOAT)m_view.m_winSize.width;
    vBackground[3].p.x = (FLOAT)m_view.m_winSize.width;
    m_pClearVB->Unlock();

    if( m_pConfig->bFlexMode ) 
    {
        m_drawMode = DRAW_FLEX;
        m_pFState = new FLEX_STATE( this );
        m_pNState = NULL;
    } 
    else 
    {
        m_drawMode = DRAW_NORMAL;
        m_pNState = new NORMAL_STATE( this );
        m_pFState = NULL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STATE::FrameMove( FLOAT fElapsedTime )
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: - Top-level pipe drawing routine
//       - Each pipe thread keeps drawing new pipes until we reach maximum number
//       of pipes per frame - then each thread gets killed as soon as it gets
//       stuck.  Once number of drawing threads reaches 0, we start a new
//       frame
//-----------------------------------------------------------------------------
HRESULT STATE::Render()
{
    int i;
    int nKilledThreads = 0;
    BOOL bChooseNewLead = FALSE;
    DRAW_THREAD* pThread;

    // Reset the frame if its time
    if( m_resetStatus != 0 )
    {
        if( FALSE == FrameReset() )
            return S_OK;
    }

    // Check each pipe's status
    pThread = m_drawThreads;
    for( i=0; i<m_nDrawThreads; i++ ) 
    {
        if( pThread->m_pPipe->IsStuck() ) 
        {
            m_nPipesDrawn++;
            if( m_nPipesDrawn > m_maxPipesPerFrame ) 
            {
                // Reaching pipe saturation - kill this pipe thread
                if( (m_drawScheme == FRAME_SCHEME_CHASE) &&
                    (pThread->m_pPipe == m_pLeadPipe) ) 
                    bChooseNewLead = TRUE;

                pThread->KillPipe();
                nKilledThreads++;
            } 
            else 
            {
                // Start up another pipe
                if( ! pThread->StartPipe() )
                {
                    // we won't be able to draw any more pipes this frame
                    // (probably out of nodes)
                    m_maxPipesPerFrame = m_nPipesDrawn;
                }
            }
        }

        pThread++;
    }

    // Whenever one or more pipes are killed, compact the thread list
    if( nKilledThreads ) 
    {
        CompactThreadList();
        m_nDrawThreads -= nKilledThreads;
    }

    if( m_nDrawThreads == 0 ) 
    {
        // This frame is finished - mark for reset on next Draw
        m_resetStatus |= RESET_NORMAL_BIT;
        return S_OK;
    }

    if( bChooseNewLead ) 
    {
        // We're in 'chase mode' and need to pick a new lead pipe
        ChooseNewLeadPipe();
    }

    // Draw each pipe
    pThread = m_drawThreads;
    for( i=0; i<m_nDrawThreads; i++ ) 
    {
        pThread->Render();
        pThread++;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STATE::InvalidateDeviceObjects()
{
    int i;

    // Cleanup threads
    DRAW_THREAD* pThread = m_drawThreads;
    for( i=0; i<m_maxDrawThreads; i++ ) 
    {
        pThread->InvalidateDeviceObjects();
        pThread->DeleteDeviceObjects();
        pThread++;
    }

    SAFE_RELEASE( m_pClearVB );

    // Cleanup textures
    for( i=0; i<m_nTextures; i++ ) 
    {
        SAFE_RELEASE( m_textureInfo[i].pTexture );
    }

    SAFE_RELEASE( m_pWorldMatrixStack );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STATE::DeleteDeviceObjects()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: STATE destructor
// Desc: 
//-----------------------------------------------------------------------------
STATE::~STATE()
{
    SAFE_DELETE( m_pNState );
    SAFE_DELETE( m_pFState );
    SAFE_DELETE( m_nodes );

    // Delete any RC's - should be done by ~THREAD, but since common lib
    // deletes shareRC, have to do it here

    DRAW_THREAD* pThread = m_drawThreads;
    for( int i=0; i<m_maxDrawThreads; i++ ) 
    {
        pThread->KillPipe();
        pThread++;
    }
}




//-----------------------------------------------------------------------------
// Name: CalcTexRepFactors 
// Desc: 
//-----------------------------------------------------------------------------
void STATE::CalcTexRepFactors()
{
    ISIZE winSize;
    D3DXVECTOR2 texFact;

    winSize = m_view.m_winSize;

    // Figure out repetition factor of texture, based on bitmap size and
    // screen size.
    //
    // We arbitrarily decide to repeat textures that are smaller than
    // 1/8th of screen width or height.
    for( int i = 0; i < m_nTextures; i++ ) 
    {
        m_texRep[i].x = m_texRep[i].y = 1;

        if( (texFact.x = winSize.width / m_textureInfo[i].width / 8.0f) >= 1.0f)
            m_texRep[i].x = (int) (texFact.x+0.5f);

        if( (texFact.y = winSize.height / m_textureInfo[i].height / 8.0f) >= 1.0f)
            m_texRep[i].y = (int) (texFact.y+0.5f);
    }
    
    // ! If display list based normal pipes, texture repetition is embedded
    // in the dlists and can't be changed. So use the smallest rep factors.
    // mf: Should change this so smaller textures are replicated close to
    // the largest texture, then same rep factor will work well for all
    
    if( m_pNState ) 
    {
        //put smallest rep factors in texRep[0]; (mf:this is ok for now, as
        // flex pipes and normal pipes don't coexist)
    
        for( i = 1; i < m_nTextures; i++ ) 
        {
            if( m_texRep[i].x < m_texRep[0].x )
                m_texRep[0].x = m_texRep[i].x;
            if( m_texRep[i].y < m_texRep[0].y )
                m_texRep[0].y = m_texRep[i].y;
        }
    } 
}




//-----------------------------------------------------------------------------
// Name: LoadTextureFiles
// Desc: - Load user texture files.  If texturing on but no user textures, or
//       problems loading them, load default texture resource
//       mf: later, may want to have > 1 texture resource
//-----------------------------------------------------------------------------
HRESULT STATE::LoadTextureFiles( int nTextures, TCHAR strTextureFileNames[MAX_PATH][MAX_TEXTURES], int* anDefaultTextureResource )
{
    HRESULT hr;
    m_nTextures = 0;

    for( int i=0; i<nTextures; i++ )
    {
        SAFE_RELEASE( m_textureInfo[i].pTexture );

        if( !m_pConfig->bDefaultTexture )
        {
            WIN32_FIND_DATA findFileData;
            HANDLE hFind = FindFirstFile( strTextureFileNames[i], &findFileData);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                // Load texture in strTextureFileNames[i] using D3DX
                hr = D3DXCreateTextureFromFileEx( m_pd3dDevice, strTextureFileNames[i], 
                            D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, 
                            D3DPOOL_MANAGED, D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 
                            D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 0, NULL, NULL, &m_textureInfo[i].pTexture );
                if( FAILED( hr ) )
                {
                    SAFE_RELEASE( m_textureInfo[i].pTexture );
                }
            }
        }

        if( m_textureInfo[i].pTexture == NULL )
        {
            // Load default texture in resource anDefaultTextureResource[i]
            hr = D3DXCreateTextureFromResourceEx( m_pd3dDevice, NULL, MAKEINTRESOURCE( anDefaultTextureResource[i] ), 
                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, 
                        D3DPOOL_MANAGED, D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 
                        D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 0, NULL, NULL, &m_textureInfo[i].pTexture );
            if( FAILED( hr ) )
            {
                SAFE_RELEASE( m_textureInfo[i].pTexture );
            }
        }

        if( m_textureInfo[i].pTexture == NULL )
        {
            // Couldn't load texture
            return E_FAIL;
        }
        else
        {
            D3DSURFACE_DESC d3dDesc;
            ZeroMemory( &d3dDesc, sizeof(D3DSURFACE_DESC) );
            m_textureInfo[i].pTexture->GetLevelDesc( 0, &d3dDesc );
            m_textureInfo[i].width  = d3dDesc.Width;
            m_textureInfo[i].height = d3dDesc.Height;
        }
    }

    m_nTextures = nTextures;
    CalcTexRepFactors();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Repaint
// Desc: This is called when a WM_PAINT msg has been sent to the window.   The paint
//       will overwrite the frame buffer, screwing up the scene if pipes is in single
//       buffer mode.  We set resetStatus accordingly to clear things up on next
//       draw. 
//-----------------------------------------------------------------------------
void STATE::Repaint()
{
    m_resetStatus |= RESET_REPAINT_BIT;
}




//-----------------------------------------------------------------------------
// Name: Reshape
// Desc: - called on resize, expose
//       - always called on app startup
//       - set new window size for VIEW object, and set resetStatus for validation
//         at draw time
//-----------------------------------------------------------------------------
void STATE::Reshape( int width, int height )
{
}




//-----------------------------------------------------------------------------
// Name: ResetView
// Desc: Called on FrameReset resulting from change in viewing paramters (e.g. from
//       a Resize event).
//-----------------------------------------------------------------------------
void STATE::ResetView()
{
    IPOINT3D numNodes;

    // Have VIEW calculate the node array size based on view params
    m_view.CalcNodeArraySize( &numNodes );

    // Resize the node array
    m_nodes->Resize( &numNodes );
}




//-----------------------------------------------------------------------------
// Name: FrameReset
// Desc: Start a new frame of pipes
//       The resetStatus parameter indicates what triggered the Reset.
//-----------------------------------------------------------------------------
BOOL STATE::FrameReset()
{    
    int i;
    float xRot = 0.0f;
    float zRot = 0.0f;

    // Kill off any active pipes ! (so they can shut down ok)
    DRAW_THREAD* pThread = m_drawThreads;
    for( i=0; i<m_nDrawThreads; i++ ) 
    {
        pThread->KillPipe();
        pThread++;
    }
    m_nDrawThreads = 0;
    
    // Clear the screen
    if( FALSE == Clear() )
        return FALSE;

    // Check for window resize status
    if( m_resetStatus & RESET_RESIZE_BIT ) 
    {
        ResetView();
    }

    // Reset the node states to empty
    m_nodes->Reset();

    // Call any pipe-specific state resets, and get any recommended
    // pipesPerFrame counts
    if( m_pNState ) 
    {
        m_pNState->Reset();
    }

    if( m_pFState ) 
    {
        m_pFState->Reset();

        //mf: maybe should figure out min spherical view dist
        xRot = CPipesScreensaver::fRand(-5.0f, 5.0f);
        zRot = CPipesScreensaver::fRand(-5.0f, 5.0f);
    }
    m_maxPipesPerFrame = CalcMaxPipesPerFrame();

    // Set new number of drawing threads
    if( m_maxDrawThreads > 1 ) 
    {
        // Set maximum # of pipes per frame
        m_maxPipesPerFrame = (int) (m_maxPipesPerFrame * 1.5);

        // Set # of draw threads
        m_nDrawThreads = SS_MIN( m_maxPipesPerFrame, CPipesScreensaver::iRand2( 2, m_maxDrawThreads ) );
        // Set chase mode if applicable, every now and then
        BOOL bUseChase = m_pNState || (m_pFState && m_pFState->OKToUseChase());
        if( bUseChase && (!CPipesScreensaver::iRand(5)) ) 
        {
            m_drawScheme = FRAME_SCHEME_CHASE;
        }
    } 
    else 
    {
        m_nDrawThreads = 1;
    }
    m_nPipesDrawn = 0;

    // for now, either all NORMAL or all FLEX for each frame
    pThread = m_drawThreads;
    for( i=0; i<m_nDrawThreads; i++ ) 
    {
        PIPE* pNewPipe;
        
        // Rotate Scene
        D3DXVECTOR3 xAxis = D3DXVECTOR3(1.0f,0.0f,0.0f);
        D3DXVECTOR3 yAxis = D3DXVECTOR3(0.0f,1.0f,0.0f);
        D3DXVECTOR3 zAxis = D3DXVECTOR3(0.0f,0.0f,1.0f);

        // Set up the modeling view
        m_pWorldMatrixStack->LoadIdentity();
        m_pWorldMatrixStack->RotateAxis( &yAxis, m_view.m_yRot );

        // create approppriate pipe for this thread slot
        switch( m_drawMode ) 
        {
            case DRAW_NORMAL:
                pNewPipe = (PIPE*) new NORMAL_PIPE(this);
                break;

            case DRAW_FLEX:
                // There are several kinds of FLEX pipes 
                // so have FLEX_STATE decide which one to create
                pNewPipe = m_pFState->NewPipe( this );
                break;
        }

        pThread->SetPipe( pNewPipe );

        if( m_drawScheme == FRAME_SCHEME_CHASE ) 
        {
            if( i == 0 ) 
            {
                // this will be the lead pipe
                m_pLeadPipe = pNewPipe;
                pNewPipe->SetChooseDirectionMethod( CHOOSE_DIR_RANDOM_WEIGHTED );
            } 
            else 
            {
                pNewPipe->SetChooseDirectionMethod( CHOOSE_DIR_CHASE );
            }
        }

        // If texturing, pick a random texture for this thread
        if( m_bUseTexture ) 
        {
            int index = PickRandomTexture( i, m_nTextures );
            pThread->SetTexture( &m_textureInfo[index] );

            // Flex pipes need to be informed of the texture, so they 
            // can dynamically calculate various texture params
            if( m_pFState )
                ((FLEX_PIPE *) pNewPipe)->SetTexParams( &m_textureInfo[index], 
                                                        &m_texRep[index] );
        }

        // Launch the pipe (assumed: always more nodes than pipes starting, so
        // StartPipe cannot fail)

        // ! All pipe setup needs to be done before we call StartPipe, as this
        // is where the pipe starts drawing
        pThread->StartPipe();

        // Kind of klugey, but if in chase mode, I set chooseStartPos here,
        // since first startPos used in StartPipe() should be random
        if( (i == 0) && (m_drawScheme == FRAME_SCHEME_CHASE) )
            pNewPipe->SetChooseStartPosMethod( CHOOSE_STARTPOS_FURTHEST );

        pThread++;
        m_nPipesDrawn++;
    }

    // Increment scene rotation for normal reset case
    if( m_resetStatus & RESET_NORMAL_BIT )
        m_view.IncrementSceneRotation();

    // clear reset status
    m_resetStatus = 0;

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: CalcMaxPipesPerFrame
// Desc: 
//-----------------------------------------------------------------------------
int STATE::CalcMaxPipesPerFrame()
{
    int nCount=0, fCount=0;

    if( m_pFState )
        fCount = m_pFState->GetMaxPipesPerFrame();

    if( m_pNState )
        nCount = m_bUseTexture ? NORMAL_TEX_PIPE_COUNT : NORMAL_PIPE_COUNT;

    return SS_MAX( nCount, fCount );
}




//-----------------------------------------------------------------------------
// Name: PickRandomTexture
// Desc: Pick a random texture index from a list.  Remove entry from list as it
//       is picked.  Once all have been picked, or starting a new frame, reset.
//-----------------------------------------------------------------------------
int STATE::PickRandomTexture( int iThread, int nTextures )
{
    if( nTextures == 0 )
        return 0;

    static int pickSet[MAX_TEXTURES] = {0};
    static int nPicked = 0;
    int i, index;

    if( iThread == 0 )
    {
        // new frame - force reset
        nPicked = nTextures;
    }

    // reset condition
    if( ++nPicked > nTextures ) 
    {
        for( i = 0; i < nTextures; i ++ ) pickSet[i] = 0;
        nPicked = 1; // cuz
    }

    // Pick a random texture index
    index = CPipesScreensaver::iRand( nTextures );
    while( pickSet[index] ) 
    {
        // this index has alread been taken, try the next one
        if( ++index >= nTextures )
            index = 0;
    }

    // Hopefully, the above loop will exit :).  This means that we have
    // found a texIndex that is available
    pickSet[index] = 1; // mark as taken
    return index;
}




//-----------------------------------------------------------------------------
// Name: Clear
// Desc: Clear the screen.  Depending on resetStatus, use normal clear or
//       fancy transitional clear.
//-----------------------------------------------------------------------------
BOOL STATE::Clear()
{
    if( m_resetStatus & RESET_NORMAL_BIT )
    {
        // do the normal transitional clear
        static DWORD s_dwCount = 0;
        static FLOAT s_fLastStepTime = DXUtil_Timer( TIMER_GETAPPTIME );

        if( s_dwCount == 0 )
            s_dwCount = 30;

        float fCurTime = DXUtil_Timer( TIMER_GETAPPTIME );
        if( fCurTime - s_fLastStepTime > 0.016 )
        {
            s_fLastStepTime = fCurTime;

            s_dwCount--;
            if( s_dwCount == 0 )
            {
                m_pd3dDevice->SetTexture( 0, NULL );
                m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
                m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 
                                     0x00000000, 1.0f, 0L );

                return TRUE;
            }
            else
            {
                m_pd3dDevice->SetTexture( 0, NULL );
                m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
                m_pd3dDevice->SetVertexShader( D3DFVF_TLVERTEX );
                m_pd3dDevice->SetStreamSource( 0, m_pClearVB, sizeof(D3DTLVERTEX) );
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }
    else 
    {
        // do a fast one-shot clear
        m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 
                             0x00000000, 1.0f, 0L );
        return TRUE;
    }
}




//-----------------------------------------------------------------------------
// Name: DrawValidate
// Desc: Validation done before every Draw
//       For now, this just involves checking resetStatus
//-----------------------------------------------------------------------------
void STATE::DrawValidate()
{    
}




//-----------------------------------------------------------------------------
// Name: CompactThreadList
// Desc: - Compact the thread list according to number of pipe threads killed
//       - The pipes have been killed, but the RC's in each slot are still valid
//       and reusable.  So we swap up entries with valid pipes. This means that
//       the ordering of the RC's in the thread list will change during the life
//       of the program.  This should be OK.
//-----------------------------------------------------------------------------
#define SWAP_SLOT( a, b ) \
    DRAW_THREAD pTemp; \
    pTemp = *(a); \
    *(a) = *(b); \
    *(b) = pTemp;
    
void STATE::CompactThreadList()
{
    if( m_nDrawThreads <= 1 )
        // If only one active thread, it must be in slot 0 from previous
        // compactions - so nothing to do
        return;

    int iEmpty = 0;
    DRAW_THREAD* pThread = m_drawThreads;
    for( int i=0; i<m_nDrawThreads; i++ ) 
    {
        if( pThread->m_pPipe ) 
        {
            if( iEmpty < i ) 
            {
                // swap active pipe thread and empty slot
                SWAP_SLOT( &(m_drawThreads[iEmpty]), pThread );
            }

            iEmpty++;
        }
        pThread++;
    }
}




//-----------------------------------------------------------------------------
// Name: ChooseNewLeadPipe
// Desc: Choose a new lead pipe for chase mode.
//-----------------------------------------------------------------------------
void STATE::ChooseNewLeadPipe()
{
    // Pick one of the active pipes at random to become the new lead

    int iLead = CPipesScreensaver::iRand( m_nDrawThreads );
    m_pLeadPipe = m_drawThreads[iLead].m_pPipe;
    m_pLeadPipe->SetChooseStartPosMethod( CHOOSE_STARTPOS_FURTHEST );
    m_pLeadPipe->SetChooseDirectionMethod( CHOOSE_DIR_RANDOM_WEIGHTED );
}




//-----------------------------------------------------------------------------
// Name: DRAW_THREAD constructor
// Desc: 
//-----------------------------------------------------------------------------
DRAW_THREAD::DRAW_THREAD()
{
    m_pd3dDevice    = NULL;
    m_pPipe         = NULL;
    m_pTextureInfo  = NULL;
}




//-----------------------------------------------------------------------------
// Name: DRAW_THREAD destructor
// Desc: 
//-----------------------------------------------------------------------------
DRAW_THREAD::~DRAW_THREAD()
{
}




//-----------------------------------------------------------------------------
// Name: SetPipe
// Desc: 
//-----------------------------------------------------------------------------
void DRAW_THREAD::SetPipe( PIPE* pPipe )
{
    m_pPipe = pPipe;
}




//-----------------------------------------------------------------------------
// Name: SetTexture
// Desc: 
//-----------------------------------------------------------------------------
void DRAW_THREAD::SetTexture( TEXTUREINFO* pTextureInfo )
{
    m_pTextureInfo = pTextureInfo;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::InitDeviceObjects( IDirect3DDevice8* pd3dDevice )
{
    m_pd3dDevice = pd3dDevice;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::RestoreDeviceObjects()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::FrameMove( FLOAT fElapsedTime )
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: - Draw pipe in thread slot, according to its type
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::Render()
{
    m_pPipe->Draw();
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::InvalidateDeviceObjects()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::DeleteDeviceObjects()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: StartPipe
// Desc: Starts up pipe of the approppriate type.  If can't find an empty node
//       for the pipe to start on, returns FALSE;
//-----------------------------------------------------------------------------
BOOL DRAW_THREAD::StartPipe()
{
    // call pipe-type specific Start function
    m_pPipe->Start();

    // check status
    if( m_pPipe->NowhereToRun() )
        return FALSE;
    else
        return TRUE;
}




//-----------------------------------------------------------------------------
// Name: KillPipe
// Desc: 
//-----------------------------------------------------------------------------
void DRAW_THREAD::KillPipe()
{
    SAFE_DELETE( m_pPipe );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\stdafx.cpp ===
//-----------------------------------------------------------------------------
// File: stdafx.cpp
//
// Desc: 
//
// Copyright (c) 1995-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#define INITGUID
#include "stdafx.h"

DEFINE_GUID(IID_IUnknown, 
0x000000000, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\state.h ===
//-----------------------------------------------------------------------------
// File: state.h
//
// Desc: STATE
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __state_h__
#define __state_h__

#define MAX_DRAW_THREADS    4
#define MAX_TESS            3

// type(s) of pipes that are drawn
enum 
{
    DRAW_NORMAL,
    DRAW_FLEX,
    DRAW_BOTH  // not currently used
};

// Reset status
#define  RESET_STARTUP_BIT  (1L << 0)
#define  RESET_NORMAL_BIT   (1L << 1)
#define  RESET_RESIZE_BIT   (1L << 2)
#define  RESET_REPAINT_BIT  (1L << 3)

// Frame draw schemes
enum 
{
    FRAME_SCHEME_RANDOM,  // pipes draw randomly
    FRAME_SCHEME_CHASE,   // pipes chase a lead pipe
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class DRAW_THREAD 
{
private:

public:
    TEXTUREINFO*        m_pTextureInfo;
    IDirect3DDevice8*   m_pd3dDevice;
    PIPE*               m_pPipe;       // generic pipe ptr
    int                 m_priority;

    DRAW_THREAD();
    ~DRAW_THREAD();

    HRESULT InitDeviceObjects( IDirect3DDevice8* pd3dDevice );
    HRESULT RestoreDeviceObjects();
    HRESULT InvalidateDeviceObjects();
    HRESULT DeleteDeviceObjects();
    HRESULT Render();
    HRESULT FrameMove( FLOAT fElapsedTime );

    void        SetTexture( TEXTUREINFO* pTextureInfo );
    void        SetPipe( PIPE* pPipe );
    BOOL        StartPipe();
    void        KillPipe();
};


// Program existence instance
class NORMAL_STATE;
class FLEX_STATE;


struct CONFIG;

//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class STATE 
{
public:
    CONFIG*         m_pConfig;
    BOOL            m_bUseTexture;              // global texture enable
    TEXTUREINFO     m_textureInfo[MAX_TEXTURES];
    int             m_nTextures;
    IDirect3DDevice8* m_pd3dDevice;
    ID3DXMatrixStack* m_pWorldMatrixStack;
    D3DLIGHT8       m_light;
    FLOAT           m_fLastTime;

    PIPE*           m_pLeadPipe;     // lead pipe for chase scenarios
    int             m_nSlices;      // reference # of slices around a pipe
    IPOINT2D        m_texRep[MAX_TEXTURES];
    VIEW            m_view;           // viewing parameters
    float           m_radius;         // 'reference' pipe radius value
    NODE_ARRAY*     m_nodes;         // for keeping track of draw space
    NORMAL_STATE*   m_pNState;
    FLEX_STATE*     m_pFState;
    LPDIRECT3DVERTEXBUFFER8 m_pClearVB;

    STATE( CONFIG* pConfig );
    ~STATE();
    void        Reshape( int width, int height );
    void        Repaint();

    HRESULT InitDeviceObjects( IDirect3DDevice8* pd3dDevice );
    HRESULT RestoreDeviceObjects();
    HRESULT InvalidateDeviceObjects();
    HRESULT DeleteDeviceObjects();
    HRESULT Render();
    HRESULT FrameMove( FLOAT fElapsedTime );

private:
    int         m_drawMode;       // drawing mode (flex or normal for now)
    int         m_drawScheme;     // random or chase
    int         m_maxPipesPerFrame; // max number of separate pipes/frame
    int         m_nPipesDrawn;    // number of pipes drawn or drawing in frame
    int         m_maxDrawThreads; // max number of concurrently drawing pipes
    int         m_nDrawThreads;   // number of live threads
    DRAW_THREAD m_drawThreads[MAX_DRAW_THREADS];
    int         m_resetStatus;

    HRESULT     LoadTextureFiles( int nTextures, TCHAR strTextureFileNames[MAX_PATH][MAX_TEXTURES], int* anDefaultTextureResource );
    int         PickRandomTexture( int iThread, int nTextures );

    BOOL        Clear();
    void        ChooseNewLeadPipe();
    void        CompactThreadList();
    void        GLInit();
    void        DrawValidate();  // validation to do before each Draw
    void        ResetView();
    BOOL        FrameReset();
    void        CalcTexRepFactors();
    int         CalcMaxPipesPerFrame();
};

#endif // __state_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\stdafx.h ===
//-----------------------------------------------------------------------------
// File: stdafx.h
//
// Desc: Global header for 3D Pipes screen saver.
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <commdlg.h>
#include <sys/timeb.h>
#include <sys/types.h>
#include <assert.h>
#include <time.h>
#include <math.h>
#include <commctrl.h>
#include <d3dx8.h>
#include <d3d8rgbrast.h>
#include <tchar.h>

#define iXX -1
#define fXX -0.01f

// These are absolute directions, with origin in center of screen,
// looking down -z
enum 
{
    PLUS_X = 0,
    MINUS_X,
    PLUS_Y,
    MINUS_Y,
    PLUS_Z,
    MINUS_Z,
    NUM_DIRS,
    DIR_NONE,
    DIR_STRAIGHT
};

enum 
{
    JOINT_ELBOW=0,
    JOINT_BALL,
    JOINT_MIXED,
    JOINT_CYCLE,
    NUM_JOINTTYPES
};

// surface styles
enum 
{
    SURFSTYLE_SOLID = 0,
    SURFSTYLE_TEX,
    SURFSTYLE_WIREFRAME
};

#define NUM_DIV 16              // divisions in window in longest dimension
#define MAX_TEXTURES 8

// texture quality level
enum 
{
    TEXQUAL_DEFAULT = 0,
    TEXQUAL_HIGH
};

typedef struct _ipoint2d 
{
    int x;
    int y;
} IPOINT2D;

typedef struct _ipoint3d 
{
    int x;
    int y;
    int z;
} IPOINT3D;

typedef struct _texpoint2d 
{
    float s;
    float t;
} TEX_POINT2D;

typedef struct _isize 
{
    int width;
    int height;
} ISIZE;

typedef struct _fsize 
{
    float width;
    float height;
} FSIZE;

typedef struct _glrect 
{
    int x, y;
    int width, height;
} GLRECT;

typedef struct 
{
    int     type;
    int     name;
} TEX_RES;

typedef struct 
{
    int     nOffset;  // filename offset into pathname
    TCHAR   szPathName[MAX_PATH];  // texture pathname
} TEXFILE;

// texture data
typedef struct 
{
    LPDIRECT3DTEXTURE8 pTexture;
    int     width;
    int     height;
//    GLenum  format;
//    GLsizei components;
    float   origAspectRatio; // original width/height aspect ratio
//    unsigned char *data;
//    GLuint  texObj;          // texture object
//    RGBQUAD *pal;
} TEXTUREINFO;

struct D3DVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;
};

#define D3DFVF_VERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

struct D3DTLVERTEX  // Vertex type used for rendering background
{
    D3DXVECTOR4 p;
    DWORD       color;
};

#define D3DFVF_TLVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)



#define PI 3.14159265358979323846f
// double version of PI
#define PI_D 3.14159265358979323846264338327950288419716939937510
#define ONE_OVER_PI (1.0f / PI)
#define ROOT_TWO 1.414213562373f

// degree<->radian macros
#define ONE_OVER_180                (1.0f / 180.0f)
#define SS_DEG_TO_RAD( a )          ( (a*PI) * ONE_OVER_180 )
#define SS_RAD_TO_DEG( a )          ( (a*180.0f) * D3DX_1BYPI )

// Useful macros
#define SS_MAX( a, b )              ( a > b ? a : b )
#define SS_MIN( a, b )              ( a < b ? a : b )

// macro to round up floating values
#define SS_ROUND_UP( fval )         ( (((fval) - (FLOAT)(int)(fval)) > 0.0f) ? (int) ((fval)+1.0f) : (int) (fval) )

// macros to clamp a value within a range
#define SS_CLAMP_TO_RANGE( a, lo, hi )      ( (a < lo) ? lo : ((a > hi) ? hi : a) )
#define SS_CLAMP_TO_RANGE2( a, lo, hi )     ( a = (a < lo) ? lo : ((a > hi) ? hi : a) )

#include "d3dsaver.h"
#include "dxutil.h"
#include "resource.h"

#include "xc.h"
#include "eval.h"
#include "fstate.h"
#include "nstate.h"
#include "node.h"
#include "pipe.h"
#include "npipe.h"
#include "fpipe.h"
#include "objects.h"
#include "view.h"
#include "state.h"
#include "pipes.h"

extern void InitMaterials();
extern D3DMATERIAL8* RandomTexMaterial();
extern D3DMATERIAL8* RandomTeaMaterial();

extern CPipesScreensaver* g_pMyPipesScreensaver;

#endif // __STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\view.cpp ===
//-----------------------------------------------------------------------------
// File: view.cpp
//
// Desc: 
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: 
// Desc: VIEW constructor
//-----------------------------------------------------------------------------
VIEW::VIEW()
{
    m_bProjMode = TRUE;

    // set some initial viewing and size params
    m_zTrans = -75.0f;
    m_viewDist = -m_zTrans;

    m_numDiv = NUM_DIV;
    assert( m_numDiv >= 2 && "VIEW constructor: not enough divisions\n" );
    // Because number of nodes in a dimension is derived from (numDiv-1), and
    // can't be 0

    m_divSize = 7.0f;

    m_persp.viewAngle = D3DX_PI / 2.0f; //90.0f;
    m_persp.zNear = 1.0f;

    m_yRot = 0.0f;

    m_winSize.width = m_winSize.height = 0; 
}




//-----------------------------------------------------------------------------
// Name: SetProjMatrix
// Desc: Set Projection matrix
//-----------------------------------------------------------------------------
void VIEW::SetProjMatrix( IDirect3DDevice8* pd3dDevice )
{
    // Rotate the camera about the y-axis
    D3DXVECTOR3 vFromPt   = D3DXVECTOR3( 0.0f, 0.0f, -m_zTrans );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vFromPt, &vLookatPt, &vUpVec );
    pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set the projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, m_persp.viewAngle, m_aspectRatio, m_persp.zNear, m_persp.zFar );
    pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
}




//-----------------------------------------------------------------------------
// Name: CalcNodeArraySize
// Desc: Based on the viewing width and height, and numDiv, calculate the x,y,z array
//       node dimensions.
//-----------------------------------------------------------------------------
void VIEW::CalcNodeArraySize( IPOINT3D *pNodeDim )
{
    // mf: !!! if aspect ratio deviates too much from 1, then nodes will get
    // clipped as view rotates
    if( m_winSize.width >= m_winSize.height ) 
    {
        pNodeDim->x = m_numDiv - 1;
        pNodeDim->y = (int) (pNodeDim->x / m_aspectRatio) ;
        if( pNodeDim->y < 1 )
            pNodeDim->y = 1;
        pNodeDim->z = pNodeDim->x;
    }
    else 
    {
        pNodeDim->y = m_numDiv - 1;
        pNodeDim->x = (int) (m_aspectRatio * pNodeDim->y);
        if( pNodeDim->x < 1 )
            pNodeDim->x = 1;
        pNodeDim->z = pNodeDim->y;
    }
}




//-----------------------------------------------------------------------------
// Name: SetWinSize
// Desc: Set the window size for the view, derive other view params.
//       Return FALSE if new size same as old.
//-----------------------------------------------------------------------------
BOOL VIEW::SetWinSize( int width, int height )
{
    if( (width == m_winSize.width) &&
        (height == m_winSize.height) )
        return FALSE;

    m_winSize.width = width;
    m_winSize.height = height;

    m_aspectRatio = m_winSize.height == 0 ? 1.0f : (float)m_winSize.width/m_winSize.height;

    if( m_winSize.width >= m_winSize.height ) 
    {
        m_world.x = m_numDiv * m_divSize;
        m_world.y = m_world.x / m_aspectRatio;
        m_world.z = m_world.x;
    }
    else 
    {
        m_world.y = m_numDiv * m_divSize;
        m_world.x = m_world.y * m_aspectRatio;
        m_world.z = m_world.y;
    }

    m_persp.zFar = m_viewDist + m_world.z*2;

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: SetSceneRotation 
// Desc: 
//-----------------------------------------------------------------------------
void VIEW::IncrementSceneRotation()
{
    m_yRot += 9.73156f;
    if( m_yRot >= 360.0f )
        // prevent overflow
        m_yRot -= 360.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\stars\strings.h ===
#include "..\common\comstrin.h"

#define idsDescription    1
#define idsName         100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\view.h ===
//-----------------------------------------------------------------------------
// File: view.h
//
// Desc: 
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __view_h__
#define __view_h__


typedef struct 
{
    float viewAngle;            // field of view angle for height
    float zNear;                // near z clip value
    float zFar;                 // far z clip value
} Perspective;  // perspective view description




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class VIEW 
{
public:
    float       m_zTrans;         // z translation
    float       m_yRot;           // current yRotation
    float       m_viewDist;       // viewing distance, usually -zTrans
    int         m_numDiv;         // # grid divisions in x,y,z
    float       m_divSize;        // distance between divisions
    ISIZE       m_winSize;        // window size in pixels

    VIEW();
    BOOL        SetWinSize( int width, int height );
    void        CalcNodeArraySize( IPOINT3D *pNodeDim );
    void        SetProjMatrix( IDirect3DDevice8* pd3dDevice );
    void        IncrementSceneRotation();
private:
    BOOL        m_bProjMode;      // projection mode
    Perspective m_persp;          // perspective view description
    float       m_aspectRatio;    // x/y window aspect ratio
    D3DXVECTOR3 m_world;          // view area in world space
};

#endif // __view_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\xc.h ===
//-----------------------------------------------------------------------------
// File: xc.h
//
// Desc: Cross_section (xc) class
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __XC_H__
#define __XC_H__


// useful for xc-coords
enum 
{
    RIGHT = 0,
    TOP,
    LEFT,
    BOTTOM
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: Cross_section (xc) class
//-----------------------------------------------------------------------------
class XC 
{
public:
    float           m_xLeft, m_xRight;  // bounding box
    float           m_yTop, m_yBottom;
    int             m_numPts;
    D3DXVECTOR2*    m_pts;        // CW points around the xc, from +x

    XC( int numPts );
    XC( const XC& xc );
    XC( XC *xc );
    ~XC();

    void        Scale( float scale );
    float       MaxExtent();
    float       MinTurnRadius( int relDir );
    void        CalcArcACValues90( int dir, float r, float *acPts );
    void        CalcArcACValuesByDistance(  float *acPts );
    void        ConvertPtsZ( D3DXVECTOR3 *pts, float z );

protected:
    void        CalcBoundingBox();
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: Specific xc's derived from base xc class
//-----------------------------------------------------------------------------
class ELLIPTICAL_XC : public XC 
{
public:
    ELLIPTICAL_XC( float r1, float r2 );
    ~ELLIPTICAL_XC();

private:
    void SetControlPoints( float r1, float r2 );
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: Specific xc's derived from base xc class
//-----------------------------------------------------------------------------
class RANDOM4ARC_XC : public XC 
{
public:
    RANDOM4ARC_XC( float r );
    ~RANDOM4ARC_XC();

private:
    void SetControlPoints( float radius );
};


#endif __XC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\pipes\xc.cpp ===
//-----------------------------------------------------------------------------
// File: xc.cpp
//
// Desc: Cross-section (xc) object stuff
//
// Copyright (c) 1995-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"





//-----------------------------------------------------------------------------
// Name: XC::CalcArcACValues90
// Desc: Calculate arc control points for a 90 degree rotation of an xc
// 
//       Arc is a quarter-circle
//       - 90 degree is much easier, so we special case it
//       radius is distance from xc-origin to hinge of turn
//-----------------------------------------------------------------------------
void XC::CalcArcACValues90( int dir, float radius, float *acPts )
{
    int i;
    float sign;
    int offset;
    float* ppts = (float *) m_pts;

    // 1) calc 'r' values for each point (4 turn possibilities/point).  From
    //  this can determine ac, which is extrusion of point from xc face
    switch( dir ) 
    {
        case PLUS_X:
            offset = 0;
            sign = -1.0f;
            break;
        case MINUS_X:
            offset = 0;
            sign =  1.0f;
            break;
        case PLUS_Y:
            offset = 1;
            sign = -1.0f;
            break;
        case MINUS_Y:
            offset = 1;
            sign =  1.0f;
            break;
    }

    for( i = 0; i < m_numPts; i++, ppts+=2, acPts++ ) 
    {
        *acPts = EVAL_CIRC_ARC_CONTROL * (radius + (sign * ppts[offset]));
    }

    // replicate !
    *acPts = *(acPts - m_numPts);
}




//-----------------------------------------------------------------------------
// Name: XC::CalcArcACValuesByDistance
// Desc: Use the distance of each xc point from the xc origin, as the radius for
//       an arc control value.
//-----------------------------------------------------------------------------
void XC::CalcArcACValuesByDistance( float *acPts )
{
    int i;
    float r;
    D3DXVECTOR2* ppts = m_pts;

    for( i = 0; i < m_numPts; i++, ppts++ ) 
    {
        r = (float) sqrt( ppts->x*ppts->x + ppts->y*ppts->y );
        *acPts++ = EVAL_CIRC_ARC_CONTROL * r;
    }

    // replicate !
    *acPts = *(acPts - m_numPts);
}




//-----------------------------------------------------------------------------
// Name: ELLIPTICAL_XC::SetControlPoints
// Desc: Set the 12 control points for a circle at origin in z=0 plane
//-----------------------------------------------------------------------------
void ELLIPTICAL_XC::SetControlPoints( float r1, float r2 )
{
    float ac1, ac2; 

    ac1 = EVAL_CIRC_ARC_CONTROL * r2;
    ac2 = EVAL_CIRC_ARC_CONTROL * r1;

    // create 12-pt. set CCW from +x

    // last 2 points of right triplet
    m_pts[0].x = r1;
    m_pts[0].y = 0.0f;
    m_pts[1].x = r1;
    m_pts[1].y = ac1;

    // top triplet
    m_pts[2].x = ac2;
    m_pts[2].y = r2;
    m_pts[3].x = 0.0f;
    m_pts[3].y = r2;
    m_pts[4].x = -ac2;
    m_pts[4].y = r2;

    // left triplet
    m_pts[5].x = -r1;
    m_pts[5].y = ac1;
    m_pts[6].x = -r1;
    m_pts[6].y = 0.0f;
    m_pts[7].x = -r1;
    m_pts[7].y = -ac1;

    // bottom triplet
    m_pts[8].x = -ac2;
    m_pts[8].y = -r2;
    m_pts[9].x = 0.0f;
    m_pts[9].y = -r2;
    m_pts[10].x = ac2;
    m_pts[10].y = -r2;

    // first point of first triplet
    m_pts[11].x = r1;
    m_pts[11].y = -ac1;
}




//-----------------------------------------------------------------------------
// Name: RANDOM4ARC_XC::SetControlPoints
// Desc: Set random control points for xc
//       Points go CCW from +x
//-----------------------------------------------------------------------------
void RANDOM4ARC_XC::SetControlPoints( float radius )
{
    int i;
    float r[4];
    float rMin = 0.5f * radius;
    float distx, disty;

    // figure the radius of each side first

    for( i = 0; i < 4; i ++ )
        r[i] = CPipesScreensaver::fRand( rMin, radius );

    // The 4 r's now describe a box around the origin - this restricts stuff

    // Now need to select a point along each edge of the box as the joining
    // points for each arc (join points are at indices 0,3,6,9)

    m_pts[0].x = r[RIGHT];
    m_pts[3].y = r[TOP];
    m_pts[6].x = -r[LEFT];
    m_pts[9].y = -r[BOTTOM];

    // quarter of distance between edges
    disty = (r[TOP] - -r[BOTTOM]) / 4.0f;
    distx = (r[RIGHT] - -r[LEFT]) / 4.0f;
    
    // uh, put'em somwhere in the middle half of each side
    m_pts[0].y = CPipesScreensaver::fRand( -r[BOTTOM] + disty, r[TOP] - disty );
    m_pts[6].y = CPipesScreensaver::fRand( -r[BOTTOM] + disty, r[TOP] - disty );
    m_pts[3].x = CPipesScreensaver::fRand( -r[LEFT] + distx, r[RIGHT] - distx );
    m_pts[9].x = CPipesScreensaver::fRand( -r[LEFT] + distx, r[RIGHT] - distx );

    // now can calc ac's
    // easy part first:
    m_pts[1].x = m_pts[11].x = m_pts[0].x;
    m_pts[2].y = m_pts[4].y  = m_pts[3].y;
    m_pts[5].x = m_pts[7].x  = m_pts[6].x;
    m_pts[8].y = m_pts[10].y = m_pts[9].y;

    // right side ac's
    disty = (r[TOP] - m_pts[0].y) / 4.0f;
    m_pts[1].y = CPipesScreensaver::fRand( m_pts[0].y + disty, r[TOP] );
    disty = (m_pts[0].y - -r[BOTTOM]) / 4.0f;
    m_pts[11].y = CPipesScreensaver::fRand( -r[BOTTOM], m_pts[0].y - disty );

    // left side ac's
    disty = (r[TOP] - m_pts[6].y) / 4.0f;
    m_pts[5].y = CPipesScreensaver::fRand( m_pts[6].y + disty, r[TOP]);
    disty = (m_pts[6].y - -r[BOTTOM]) / 4.0f;
    m_pts[7].y = CPipesScreensaver::fRand( -r[BOTTOM], m_pts[6].y - disty );

    // top ac's
    distx = (r[RIGHT] - m_pts[3].x) / 4.0f;
    m_pts[2].x = CPipesScreensaver::fRand( m_pts[3].x + distx, r[RIGHT] );
    distx = (m_pts[3].x - -r[LEFT]) / 4.0f;
    m_pts[4].x = CPipesScreensaver::fRand( -r[LEFT],  m_pts[3].x - distx );

    // bottom ac's
    distx = (r[RIGHT] - m_pts[9].x) / 4.0f;
    m_pts[10].x = CPipesScreensaver::fRand( m_pts[9].x + distx, r[RIGHT] );
    distx = (m_pts[9].x - -r[LEFT]) / 4.0f;
    m_pts[8].x = CPipesScreensaver::fRand( -r[LEFT], m_pts[9].x - distx );
}




//-----------------------------------------------------------------------------
// Name: ConvertPtsZ
// Desc: Convert the 2D pts in an xc, to 3D pts in point buffer, with z.
// 
//       Also replicate the last point.
//-----------------------------------------------------------------------------
void XC::ConvertPtsZ( D3DXVECTOR3 *newpts, float z )
{
    int i;
    D3DXVECTOR2* xcPts = m_pts;

    for( i = 0; i < m_numPts; i++, newpts++ ) 
    {
        *( (D3DXVECTOR2 *) newpts ) = *xcPts++;
        newpts->z = z;
    }

    *newpts = *(newpts - m_numPts);
}




//-----------------------------------------------------------------------------
// Name: XC::CalcBoundingBox
// Desc: Calculate bounding box in x/y plane for xc
//-----------------------------------------------------------------------------
void XC::CalcBoundingBox( )
{
    D3DXVECTOR2* ppts = m_pts;
    int i;
    float xMin, xMax, yMax, yMin;

    // initialize to really insane numbers
    xMax = yMax = -FLT_MAX;
    xMin = yMin = FLT_MAX;

    // compare with rest of points
    for( i = 0; i < m_numPts; i ++, ppts++ ) 
    {
        if( ppts->x < xMin )
            xMin = ppts->x;
        else if( ppts->x > xMax )
            xMax = ppts->x;
        if( ppts->y < yMin )
            yMin = ppts->y;
        else if( ppts->y > yMax )
            yMax = ppts->y;
    }

    m_xLeft   = xMin;
    m_xRight  = xMax;
    m_yBottom = yMin;
    m_yTop    = yMax;
}




//-----------------------------------------------------------------------------
// Name: MinTurnRadius
// Desc: Get minimum radius for the xc to turn in given direction. 
//
//       If the turn radius is less than this minimum, then primitive will 'fold'
//       over itself at the inside of the turn, creating ugliness.
//-----------------------------------------------------------------------------
float XC::MinTurnRadius( int relDir )
{
    // For now, assume xRight, yTop positive, xLeft, yBottom negative
    // otherwise, might want to consider 'negative'radius
    switch( relDir ) 
    {
        case PLUS_X:
            return( m_xRight );
        case MINUS_X:
            return( - m_xLeft );
        case PLUS_Y:
            return( m_yTop );
        case MINUS_Y:
            return( - m_yBottom );
        default:
            return(0.0f);
    }
}




//-----------------------------------------------------------------------------
// Name: XC::MaxExtent
// Desc: Get maximum extent of the xc in x and y
//-----------------------------------------------------------------------------
float XC::MaxExtent( )
{
    float max;

    max = m_xRight;

    if( m_yTop > max )
        max = m_yTop;
    if( -m_xLeft > max )
        max = -m_xLeft;
    if( -m_yBottom > max )
        max = -m_yBottom;

    return max;
}




//-----------------------------------------------------------------------------
// Name: XC::Scale
// Desc: Scale an XC's points and extents by supplied scale value
//-----------------------------------------------------------------------------
void XC::Scale( float scale )
{
    int i;
    D3DXVECTOR2* ppts = m_pts;
    if( ppts == NULL )
        return;

    for( i = 0; i < m_numPts; i ++, ppts++ ) 
    {
        ppts->x *= scale;
        ppts->y *= scale;
    }

    m_xLeft   *= scale;
    m_xRight  *= scale;
    m_yBottom *= scale;
    m_yTop    *= scale;
}




//-----------------------------------------------------------------------------
// Name: ~XC::XC
// Desc: Destructor
//-----------------------------------------------------------------------------
XC::~XC()
{
    if( m_pts )
        LocalFree( m_pts );
}




//-----------------------------------------------------------------------------
// Name: XC::XC
// Desc: Constructor
//       Allocates point buffer for the xc
//-----------------------------------------------------------------------------
XC::XC( int nPts )
{
    m_numPts = nPts;
    m_pts = (D3DXVECTOR2 *)  LocalAlloc( LMEM_FIXED, m_numPts * sizeof(D3DXVECTOR2) );
    assert( m_pts != 0 && "XC constructor\n" );
}





//-----------------------------------------------------------------------------
// Name: XC::XC
// Desc: Constructor
//       Allocates point buffer for the xc from another XC
//-----------------------------------------------------------------------------
XC::XC( XC *xc )
{
    m_numPts = xc->m_numPts;
    m_pts = (D3DXVECTOR2 *)  LocalAlloc( LMEM_FIXED, m_numPts * sizeof(D3DXVECTOR2) );
    assert( m_pts != 0 && "XC constructor\n" );
    if( m_pts != NULL )
        RtlCopyMemory( m_pts, xc->m_pts, m_numPts * sizeof(D3DXVECTOR2) );

    m_xLeft   = xc->m_xLeft;
    m_xRight  = xc->m_xRight;
    m_yBottom = xc->m_yBottom;
    m_yTop    = xc->m_yTop;
}




//-----------------------------------------------------------------------------
// Name: ELLIPTICAL_XC::ELLIPTICALXC
// Desc: Elliptical XC constructor
//       These have 4 sections of 4 pts each, with pts shared between sections.
//-----------------------------------------------------------------------------
ELLIPTICAL_XC::ELLIPTICAL_XC( float r1, float r2 )
    // initialize base XC with numPts
    : XC( (int) EVAL_XC_CIRC_SECTION_COUNT * (EVAL_ARC_ORDER - 1))
{
    SetControlPoints( r1, r2 );
    CalcBoundingBox( );
}




//-----------------------------------------------------------------------------
// Name: RANDOM4ARC_XC::RANDOM4ARC_XC
// Desc: Random 4-arc XC constructor
//       The bounding box is 2*r each side
//       These have 4 sections of 4 pts each, with pts shared between sections.
//-----------------------------------------------------------------------------
RANDOM4ARC_XC::RANDOM4ARC_XC( float r )
    // initialize base XC with numPts
    : XC( (int) EVAL_XC_CIRC_SECTION_COUNT * (EVAL_ARC_ORDER - 1))
{
    SetControlPoints( r );
    CalcBoundingBox( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\swoosh\swoosh.h ===
#ifndef	_SWOOSH_H
#define	_SWOOSH_H

//**********************************************************************************

#include	<windows.h>
#include	<d3d8.h>
#include    <d3d8rgbrast.h>
#include	<d3dx8.h>
#include	<d3dsaver.h>

//**********************************************************************************
class	CSwoosh : public CD3DScreensaver
{
public:
	CSwoosh();

	virtual	HRESULT	Create( HINSTANCE hInstance );

protected:
	// Key stuff to override from CD3DScreensaver
    virtual HRESULT RegisterSoftwareDevice();
    virtual void    SetDevice( UINT iDevice );
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();
	virtual	void	ReadSettings();
	virtual	void	DoConfig();

	// All the settings for the screensaver
	DWORD	m_dwNumParticles;
	DWORD	m_dwColourMix;
	DWORD	m_dwColour1;
	DWORD	m_dwColour2;
	DWORD	m_dwFixedColour1;
	DWORD	m_dwFixedColour2;
	float	m_fFlowRate;
	float	m_fRollRate;
	float	m_fYawRate;
	float	m_fParticleSize;

	// Stuff we need to keep track of on a per-device basis (textures, whathaveyou)
	// We update the m_pDeviceObjects pointer in SetDevice to point to the current set
	struct DeviceObjects
	{
		DeviceObjects();

		IDirect3DTexture8*			pBlobTexture;
		IDirect3DVertexBuffer8*		pParticleVB;
		IDirect3DIndexBuffer8*		pParticleIB;
	};
	enum { MAX_DEVICE_OBJECTS = 10 };
    DeviceObjects	m_DeviceObjects[MAX_DEVICE_OBJECTS];
    DeviceObjects*	m_pDeviceObjects;
	DWORD			m_dwVertMemType;

	struct	Particle
	{
		D3DXVECTOR3	pos;
		D3DCOLOR	colour;
	};
	enum { MAX_PARTICLES = 8192 };
	Particle		m_Particles[MAX_PARTICLES];
	D3DXMATRIX		m_Camera;

	void	InitParticles();
	void	UpdateParticles();
	void	RenderParticles();
	void	UpdateCamera();
	void	WriteSettings();

	float	m_fCameraYaw,m_fCameraRoll;
	float	m_fYawDirection;
	float	m_fYawPause;

	static BOOL CALLBACK	ConfigDlgProcStub( HWND hDlg , UINT msg , WPARAM wParam , LPARAM lParam );
	BOOL					ConfigDlgProc( HWND hDlg , UINT msg , WPARAM wParam , LPARAM lParam );
	void					ExtractDialogSettings( HWND hDlg );
	DWORD					PickColour( HWND hParent , DWORD defcolour );
};

//**********************************************************************************
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\swoosh\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Swoosh.rc
//
#define IDB_BITMAP1                     101
#define IDB_BLOB                        101
#define IDI_ICON                        102
#define IDD_SETTINGS                    103
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201
#define IDC_COLOUR1_MULTI               1000
#define IDC_COLOUR1_FIXED               1001
#define IDC_COLOUR1_PICK                1002
#define IDC_COLOUR2_MULTI               1003
#define IDC_COLOUR2_FIXED               1004
#define IDC_COLOUR2_PICK                1005
#define IDC_COLOUR_MIX                  1006
#define IDC_ROLL_RATE                   1007
#define IDC_YAW_RATE                    1008
#define IDC_FLOW_RATE                   1009
#define IDC_PARTICLE_SIZE               1010
#define IDC_NUM_PARTICLES               1011
#define IDC_SCREEN_SETTINGS             1012
#define IDC_RESET                       1013
#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016
#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112
#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\swoosh\swoosh.cpp ===
#include	"Swoosh.h"
#include	"Resource.h"
#include	<commdlg.h>
#include	<commctrl.h>

#define	SAFE_RELEASE(p) if(p){(p)->Release();(p)=NULL;};

struct	SimpleVertex
{
	D3DXVECTOR3	pos;
	D3DCOLOR	colour;
	float		u,v;
};
#define	FVF_SimpleVertex	(D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)

#define	PARTICLES_PER_VB	256

typedef	unsigned char UBYTE;

CSwoosh	g_Swoosh;	

const float	pi = 3.1415926536f;
const float	pi2 = pi * 2.0f;

const float	TUBE_LENGTH = 20.0f;
const float	TUBE_RADIUS = 5.0f;
const float	FALLOFF_FACTOR = (255.0f/((TUBE_LENGTH*TUBE_LENGTH)+(TUBE_RADIUS*TUBE_RADIUS)))*0.98f;

const float	MAX_FLOW_RATE = 8.0f;
const float MAX_ROLL_RATE = 4.0f;
const float MAX_YAW_RATE = 5.0f;
const float MIN_PARTICLE_SIZE = 0.01f;
const float MAX_PARTICLE_SIZE = 0.5f;

//**********************************************************************************
int WINAPI	WinMain( HINSTANCE hInstance , HINSTANCE , LPSTR lpCmdLine , int )
{
	if ( FAILED(g_Swoosh.Create( hInstance )) )
		return -1;

	return	g_Swoosh.Run();
}

//**********************************************************************************
CSwoosh::CSwoosh()
{
	D3DXMatrixLookAtLH( &m_Camera , &D3DXVECTOR3(0,0,0) , &D3DXVECTOR3(0,0,1) ,
						&D3DXVECTOR3(0,1,0) );
	m_fCameraYaw = m_fCameraRoll = 0;
	m_fYawDirection = 0;
	m_fYawPause = 6.0f;

	m_fParticleSize = 0.15f;
	m_dwNumParticles = MAX_PARTICLES;
	m_dwColourMix = 0x2000;
	m_dwColour1 = 0xffffff;
	m_dwColour2 = 0x0000ff;
	m_fFlowRate = 4.0f;
	m_fRollRate = 1.0f;
	m_fYawRate = 1.0f;
	m_dwFixedColour1 = 0xffffff;
	m_dwFixedColour2 = 0x1111ff;
}

//**********************************************************************************
HRESULT	CSwoosh::Create( HINSTANCE hInstance )
{
	// Do base class Create
	HRESULT	rc = CD3DScreensaver::Create( hInstance );
	if ( FAILED(rc) )
		return rc;

	// Initialise particles
	InitParticles();

	return S_OK;
}

//**********************************************************************************
CSwoosh::DeviceObjects::DeviceObjects()
{
	pBlobTexture = NULL;
}

//**********************************************************************************
HRESULT CSwoosh::RegisterSoftwareDevice()
{ 
    m_pD3D->RegisterSoftwareDevice( D3D8RGBRasterizer );

    return S_OK; 
}


//**********************************************************************************
void	CSwoosh::InitParticles()
{
	// Initialise particles, by evenly distributing them in a cylinder along the
	// z-axis [-30,30] with radius 3.0. Choose colours based on colour settings

	Particle*	pparticle = m_Particles;
	for ( int i = 0 ; i < MAX_PARTICLES ; i++ )
	{
		// Pick z position for particle, evenly distribute in range [-TUBE_LENGTH,TUBE_LENGTH]
		pparticle->pos.z = (float(rand()&0x7fff) * (TUBE_LENGTH*2.0f/32767.0f)) - TUBE_LENGTH;

		// Pick (x,y) position for particle. We evenly distribute in a circle radius 3.0f
		float	rad = (float(rand()&0x7fff) * (1.0f/32767.0f));
		rad = sqrtf(rad);
		rad *= TUBE_RADIUS;
		float	angle = float(rand()&0x7fff) * (pi2/32767.0f);
		pparticle->pos.x = rad * sinf(angle);
		pparticle->pos.y = rad * cosf(angle);

		// Pick colour for particle. It's one of the two colour sets. Each colour set is
		// either one particular colour, or random (denoted by 0xffffffff)
		if ( DWORD(rand()&0x3fff) > m_dwColourMix )
		{
			if ( m_dwColour1 != 0xffffffff )
				pparticle->colour = m_dwColour1;
			else
				pparticle->colour = (rand()&0xff)|((rand()&0xff)<<8)|((rand()&0xff)<<16);
		}
		else
		{
			if ( m_dwColour2 != 0xffffffff )
				pparticle->colour = m_dwColour2;
			else
				pparticle->colour = (rand()&0xff)|((rand()&0xff)<<8)|((rand()&0xff)<<16);
		}

		pparticle++;
	}
}

//**********************************************************************************
void    CSwoosh::SetDevice( UINT iDevice )
{
	// Point at the correct set of device data
	m_pDeviceObjects = &m_DeviceObjects[iDevice];

	// Figure out if vertices for this device should be software VP or not
	if ( m_RenderUnits[iDevice].dwBehavior & D3DCREATE_HARDWARE_VERTEXPROCESSING )
		m_dwVertMemType = 0;
	else
		m_dwVertMemType = D3DUSAGE_SOFTWAREPROCESSING;
}

//**********************************************************************************
HRESULT CSwoosh::RestoreDeviceObjects()
{
	HRESULT	rc;

	// Create "blob" texture
	rc = D3DXCreateTextureFromResource( m_pd3dDevice , NULL , MAKEINTRESOURCE(IDB_BLOB) ,
										&m_pDeviceObjects->pBlobTexture );
	if ( FAILED(rc) )
		return rc;

	// Create vertex buffer to hold particles
	rc = m_pd3dDevice->CreateVertexBuffer( sizeof(SimpleVertex)*4*PARTICLES_PER_VB ,
										   D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY|m_dwVertMemType ,
										   FVF_SimpleVertex , D3DPOOL_DEFAULT ,
										   &m_pDeviceObjects->pParticleVB );
	if ( FAILED(rc) )
		return rc;

	// Create index buffer to hold particle indices
	rc = m_pd3dDevice->CreateIndexBuffer( sizeof(WORD)*6*PARTICLES_PER_VB ,
										  D3DUSAGE_WRITEONLY|m_dwVertMemType ,
										  D3DFMT_INDEX16 , D3DPOOL_DEFAULT ,
										  &m_pDeviceObjects->pParticleIB );
	if ( FAILED(rc) )
		return rc;

	// Populate index buffer with indices for a series of disjoint quads
	WORD*	pidx;
	m_pDeviceObjects->pParticleIB->Lock( 0 , sizeof(WORD)*6*PARTICLES_PER_VB , (BYTE**)&pidx ,
										 D3DLOCK_NOSYSLOCK );
	WORD	index = 0;
	for ( int i = 0 ; i < PARTICLES_PER_VB ; i++ )
	{
		*pidx++ = index; *pidx++ = index+1; *pidx++ = index+3;
		*pidx++ = index; *pidx++ = index+3; *pidx++ = index+2;
		index += 4;
	}
	m_pDeviceObjects->pParticleIB->Unlock();

	// Set up world and view matrices
	D3DXMATRIX	world;
	D3DXMatrixIdentity( &world );
	m_pd3dDevice->SetTransform( D3DTS_WORLDMATRIX(0) , &world );
	m_pd3dDevice->SetTransform( D3DTS_VIEW , &m_Camera );

	// Set alpha blending mode to SRCALPHA:ONE
	m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE , TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND , D3DBLEND_SRCALPHA );
	m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND , D3DBLEND_ONE );

	// Set pixel pipe to single texture modulated by diffuse colour
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLOROP , D3DTOP_MODULATE );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG1 , D3DTA_TEXTURE );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG2 , D3DTA_DIFFUSE );
	m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_COLOROP , D3DTOP_DISABLE );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ALPHAOP , D3DTOP_SELECTARG2 );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ALPHAARG1 , D3DTA_TEXTURE );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ALPHAARG2 , D3DTA_DIFFUSE );
	m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_ALPHAOP , D3DTOP_DISABLE );

	// Bind "blob" texture to stage 0, and set filter mode to bilinear
	m_pd3dDevice->SetTexture( 0 , m_pDeviceObjects->pBlobTexture );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MAGFILTER , D3DTEXF_LINEAR );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MINFILTER , D3DTEXF_LINEAR );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MIPFILTER , D3DTEXF_POINT );

	// Disable culling, lighting, and specular
	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE , D3DCULL_NONE );
	m_pd3dDevice->SetRenderState( D3DRS_LIGHTING , FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE , FALSE );

	// Set vertex shader to fixed-function pipeline for SimpleVertex
	m_pd3dDevice->SetVertexShader( FVF_SimpleVertex );

	// Bind vertex stream 0 and index source to the particle VB/IB
	m_pd3dDevice->SetStreamSource( 0 , m_pDeviceObjects->pParticleVB , sizeof(SimpleVertex) );
	m_pd3dDevice->SetIndices( m_pDeviceObjects->pParticleIB , 0 );

	return S_OK;
}

//**********************************************************************************
HRESULT CSwoosh::InvalidateDeviceObjects()
{
	SAFE_RELEASE(m_pDeviceObjects->pParticleVB);
	SAFE_RELEASE(m_pDeviceObjects->pParticleIB);
	SAFE_RELEASE(m_pDeviceObjects->pBlobTexture);

	return S_OK;
}

//**********************************************************************************
HRESULT CSwoosh::FrameMove()
{
	UpdateParticles();
	UpdateCamera();
	return S_OK;
}

//**********************************************************************************
void	CSwoosh::UpdateCamera()
{
	// Adjust camera roll
	m_fCameraRoll += m_fElapsedTime * m_fRollRate;

	// Adjust camera yaw. If we're not yawing, then countdown pause timer
	if ( m_fYawDirection == 0.0f )
	{
		m_fYawPause -= m_fElapsedTime;
		if ( m_fYawPause <= 0.0f )
		{
			// Done pausing, so reset timer and pick yaw direction
			m_fYawPause = 6.0f;

			if ( m_fCameraYaw == 0.0f )
				m_fYawDirection = m_fYawRate;
			else
				m_fYawDirection = -m_fYawRate;
		}
	}
	else
	{
		// Yawing, so adjust yaw parameter
		m_fCameraYaw += m_fElapsedTime * m_fYawDirection;

		// If we've hit the end, stop yawing
		if ( m_fYawDirection == m_fYawRate )
		{
			if ( m_fCameraYaw >= pi )
			{
				m_fCameraYaw = pi;
				m_fYawDirection = 0.0f;
			}
		}
		else
		{
			if ( m_fCameraYaw <= 0.0f )
			{
				m_fCameraYaw = 0.0f;
				m_fYawDirection = 0.0f;
			}
		}
	}

	// Compute matrices for roll and yaw components of orientation
	// We smooth out the yaw via a cos to give a nice slow rolloff at each end
	D3DXMATRIX	roll,yaw;
	D3DXMatrixRotationZ( &roll , m_fCameraRoll );
	D3DXMatrixRotationY( &yaw , pi * 0.5f * (1.0f - cosf(m_fCameraYaw)) );
	D3DXMatrixLookAtLH( &m_Camera , &D3DXVECTOR3(0,0,0) , &D3DXVECTOR3(0,0,1) ,
						&D3DXVECTOR3(0,1,0) );

	// Compute final camera matrix
	m_Camera = m_Camera * yaw * roll;
}

//**********************************************************************************
void	CSwoosh::UpdateParticles()
{
	Particle*	pparticle = m_Particles;
	for ( DWORD i = 0 ; i < m_dwNumParticles ; i++ )
	{
		// Flow particle along cylinder
		pparticle->pos.z -= m_fElapsedTime * m_fFlowRate;

		// If we reached the end, warp to other end of cylinder
		if ( pparticle->pos.z < -TUBE_LENGTH )
			pparticle->pos.z += TUBE_LENGTH*2.0f;			

		// Compute particle distance to camera and scale alpha
		// value by distance (to give slight fade out)
		float	dist = (pparticle->pos.x * pparticle->pos.x) +
					   (pparticle->pos.y * pparticle->pos.y) +
					   (pparticle->pos.z * pparticle->pos.z);
		UBYTE	alpha = UBYTE(255.0f - (dist * FALLOFF_FACTOR));
		pparticle->colour |= (alpha<<24);

		pparticle++;
	}
}

//**********************************************************************************
HRESULT CSwoosh::Render()
{
	// Clear the buffer, and set up projection matrix for this device
	m_pd3dDevice->Clear( 0 , NULL , D3DCLEAR_TARGET , 0 , 1.0f , 0 );
	SetProjectionMatrix( 0.1f , 200.0f );

	// Set camera
	m_pd3dDevice->SetTransform( D3DTS_VIEW , &m_Camera );

	m_pd3dDevice->BeginScene();

	RenderParticles();

	m_pd3dDevice->EndScene();

	return S_OK;
}

//**********************************************************************************
void	CSwoosh::RenderParticles()
{
	DWORD		particles_left = m_dwNumParticles;
	Particle*	pparticle = m_Particles;

	// Compute offsets from particle center to make camera facing billboard
	// We cheat a little and use the same offsets for all the particles, orienting
	// them to be perpendicular to the view direction rather than to the view vector
	// to the particle centre. It's faster and the effect is close enough.
	D3DXVECTOR3	offset[4];
	D3DXVECTOR3	dx,dy;
	dx.x = m_Camera._11; dx.y = m_Camera._21; dx.z = m_Camera._31;
	dy.x = m_Camera._12; dy.y = m_Camera._22; dy.z = m_Camera._32;
	dx *= m_fParticleSize;
	dy *= m_fParticleSize;
	offset[0] = -dx+dy;
	offset[1] =  dx+dy;
	offset[2] = -dx-dy;
	offset[3] =  dx-dy;

	D3DXVECTOR3	look;
	look.x = m_Camera._13; look.y = m_Camera._23; look.z = m_Camera._33;

	DWORD			batch_size = 0;
	SimpleVertex*	pverts;
	m_pDeviceObjects->pParticleVB->Lock( 0 , 0 , (BYTE**)&pverts ,
										 D3DLOCK_DISCARD|D3DLOCK_NOSYSLOCK );
	for ( DWORD i = 0 ; i < m_dwNumParticles ; i++ , pparticle++ )
	{
		// Don't render if it's behind us
		if ( ((pparticle->pos.x*look.x) + (pparticle->pos.y*look.y) +
			  (pparticle->pos.z*look.z)) <= 0 )
			  continue;

		// Tack particle onto buffer
		pverts->pos = pparticle->pos + offset[0];
		pverts->colour = pparticle->colour;
		pverts->u = 0; pverts->v = 0;
		pverts++;
		pverts->pos = pparticle->pos + offset[1];
		pverts->colour = pparticle->colour;
		pverts->u = 1; pverts->v = 0;
		pverts++;
		pverts->pos = pparticle->pos + offset[2];
		pverts->colour = pparticle->colour;
		pverts->u = 0; pverts->v = 1;
		pverts++;
		pverts->pos = pparticle->pos + offset[3];
		pverts->colour = pparticle->colour;
		pverts->u = 1; pverts->v = 1;
		pverts++;

		// If we've hit the buffer max, then flush it
		if ( ++batch_size == PARTICLES_PER_VB )
		{
			m_pDeviceObjects->pParticleVB->Unlock();
			m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST , 0 , 4*PARTICLES_PER_VB ,
											   0 , 2*PARTICLES_PER_VB );
			m_pDeviceObjects->pParticleVB->Lock( 0 , 0 , (BYTE**)&pverts ,
												 D3DLOCK_DISCARD|D3DLOCK_NOSYSLOCK );
			batch_size = 0;
		}
	}

	// Flush last batch
	m_pDeviceObjects->pParticleVB->Unlock();
	if ( batch_size > 0 )
	{
		m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST , 0 , 4*batch_size ,
											0 , 2*batch_size );
	}
}

//**********************************************************************************
void	CSwoosh::ReadSettings()
{
    HKEY hkey;
    DWORD dwType = REG_DWORD;
    DWORD dwLength = sizeof(DWORD);

// Couple of macros to reduce typing. We just want to check if the registry read was okay, if it wasn't
// then we set a default value, if it was then we check against valid boundaries. For floats we also make
// sure the float is finite (not NaN or +/-INF).
#define	DEFAULT_AND_BOUND(v,d,l,h) if (rc!=ERROR_SUCCESS){v=d;}else if(v<=l){v=l;}else if(v>h){v=h;};
#define	DEFAULT_AND_BOUND_FLOAT(v,d,l,h) if (rc!=ERROR_SUCCESS||!_finite(v)){v=d;}else if(v<l){v=l;}else if(v>h){v=h;};

	// Open our reg key
    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Swoosh"), 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
		LONG	rc;

		// Read NumParticles
        rc = RegQueryValueEx( hkey, TEXT("NumParticles"), NULL, &dwType, (BYTE*)&m_dwNumParticles, &dwLength);
		DEFAULT_AND_BOUND(m_dwNumParticles,MAX_PARTICLES/2,1,MAX_PARTICLES);

		// Read FlowRate (float, but we munge into DWORD datatype)
        rc = RegQueryValueEx( hkey, TEXT("fFlowRate"), NULL, &dwType, (BYTE*)&m_fFlowRate, &dwLength);
		DEFAULT_AND_BOUND_FLOAT(m_fFlowRate,4.0f,0,MAX_FLOW_RATE);

		// Read RollRate (float, but we munge into DWORD datatype)
        rc = RegQueryValueEx( hkey, TEXT("fRollRate"), NULL, &dwType, (BYTE*)&m_fRollRate, &dwLength);
		DEFAULT_AND_BOUND_FLOAT(m_fRollRate,1.0f,0,MAX_ROLL_RATE);

		// Read YawRate (float, but we munge into DWORD datatype)
        rc = RegQueryValueEx( hkey, TEXT("fYawRate"), NULL, &dwType, (BYTE*)&m_fYawRate, &dwLength);
		DEFAULT_AND_BOUND_FLOAT(m_fYawRate,1.0f,0,MAX_YAW_RATE);

		// Read ParticleSize (float, but we munge into DWORD datatype)
        rc = RegQueryValueEx( hkey, TEXT("fParticleSize"), NULL, &dwType, (BYTE*)&m_fParticleSize, &dwLength);
		DEFAULT_AND_BOUND_FLOAT(m_fParticleSize,0.15f,MIN_PARTICLE_SIZE,MAX_PARTICLE_SIZE);

		// Read ColourMix
        rc = RegQueryValueEx( hkey, TEXT("ColourMix"), NULL, &dwType, (BYTE*)&m_dwColourMix, &dwLength);
		DEFAULT_AND_BOUND(m_dwColourMix,0x2000,0,0x4000);

		// Read Colours
        rc = RegQueryValueEx( hkey, TEXT("Colour1"), NULL, &dwType, (BYTE*)&m_dwColour1, &dwLength);
		if ( rc != ERROR_SUCCESS )
			m_dwColour1 = 0xffffff;
		else if ( m_dwColour1 != 0xffffffff )
			m_dwColour1 &= 0x00ffffff;
        rc = RegQueryValueEx( hkey, TEXT("Colour2"), NULL, &dwType, (BYTE*)&m_dwColour2, &dwLength);
		if ( rc != ERROR_SUCCESS )
			m_dwColour2 = 0xffffffff;
		else if ( m_dwColour2 != 0xffffffff )
			m_dwColour2 &= 0x00ffffff;
        rc = RegQueryValueEx( hkey, TEXT("FixedColour1"), NULL, &dwType, (BYTE*)&m_dwFixedColour1, &dwLength);
		if ( rc != ERROR_SUCCESS )
			m_dwFixedColour1 = 0xffffff;
		else
			m_dwFixedColour1 &= 0x00ffffff;
        rc = RegQueryValueEx( hkey, TEXT("FixedColour2"), NULL, &dwType, (BYTE*)&m_dwFixedColour2, &dwLength);
		if ( rc != ERROR_SUCCESS )
			m_dwFixedColour2 = 0xffffff;
		else
			m_dwFixedColour2 &= 0x00ffffff;

		// Read settings for screen setup (multimon gubbins)
        ReadScreenSettings( hkey );

		// Done
        RegCloseKey( hkey );
    }
}

//**********************************************************************************
void	CSwoosh::WriteSettings()
{
    HKEY hkey;
    DWORD dwType = REG_DWORD;
    DWORD dwLength = sizeof(DWORD);

	// Open our reg key
    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Swoosh"), 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
		// Write out all the settings (we munge floats into DWORDs)
        RegSetValueEx( hkey, TEXT("NumParticles"), NULL, REG_DWORD, (BYTE*)&m_dwNumParticles, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("ColourMix"), NULL, REG_DWORD, (BYTE*)&m_dwColourMix, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("Colour1"), NULL, REG_DWORD, (BYTE*)&m_dwColour1, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("Colour2"), NULL, REG_DWORD, (BYTE*)&m_dwColour2, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("fFlowRate"), NULL, REG_DWORD, (BYTE*)&m_fFlowRate, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("fRollRate"), NULL, REG_DWORD, (BYTE*)&m_fRollRate, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("fYawRate"), NULL, REG_DWORD, (BYTE*)&m_fYawRate, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("fParticleSize"), NULL, REG_DWORD, (BYTE*)&m_fParticleSize, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FixedColour1"), NULL, REG_DWORD, (BYTE*)&m_dwFixedColour1, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FixedColour2"), NULL, REG_DWORD, (BYTE*)&m_dwFixedColour2, sizeof(DWORD) );

		// Write screen settings out (multimon gubbins)
        WriteScreenSettings( hkey );

		// Done
        RegCloseKey( hkey );
    }
}

//**********************************************************************************
void	CSwoosh::DoConfig()
{
	// Make sure we've got the common controls we need loaded
    InitCommonControls();

	// Do the dialog box
	DialogBox( m_hInstance , MAKEINTRESOURCE(IDD_SETTINGS) , NULL , ConfigDlgProcStub );
}

//**********************************************************************************
BOOL CALLBACK CSwoosh::ConfigDlgProcStub( HWND hDlg , UINT msg , WPARAM wParam , LPARAM lParam )
{
	return g_Swoosh.ConfigDlgProc( hDlg , msg , wParam , lParam );
}

//**********************************************************************************
BOOL	CSwoosh::ConfigDlgProc( HWND hDlg , UINT msg , WPARAM wParam , LPARAM lParam )
{
	HWND	hNumParticles = GetDlgItem( hDlg , IDC_NUM_PARTICLES );
	HWND	hColourMix = GetDlgItem( hDlg , IDC_COLOUR_MIX );
	HWND	hFlowRate = GetDlgItem( hDlg , IDC_FLOW_RATE );
	HWND	hRollRate = GetDlgItem( hDlg , IDC_ROLL_RATE );
	HWND	hYawRate = GetDlgItem( hDlg , IDC_YAW_RATE );
	HWND	hParticleSize = GetDlgItem( hDlg , IDC_PARTICLE_SIZE );

	switch ( msg )
	{
		case WM_INITDIALOG:
			// Set up ranges on the sliders. Map floats into integer range [0,10000]
			SendMessage( hNumParticles , TBM_SETRANGE , FALSE , MAKELONG(0,MAX_PARTICLES) );
			SendMessage( hColourMix , TBM_SETRANGE , FALSE , MAKELONG(0,0x4000) );
			SendMessage( hFlowRate , TBM_SETRANGE , FALSE , MAKELONG(0,10000) );
			SendMessage( hRollRate , TBM_SETRANGE , FALSE , MAKELONG(0,10000) );
			SendMessage( hYawRate , TBM_SETRANGE , FALSE , MAKELONG(0,10000) );
			SendMessage( hParticleSize , TBM_SETRANGE , FALSE , MAKELONG(0,10000) );

			// Set initial values on the sliders
			SendMessage( hNumParticles , TBM_SETPOS , TRUE , m_dwNumParticles );
			SendMessage( hColourMix , TBM_SETPOS , TRUE , m_dwColourMix );
			SendMessage( hFlowRate , TBM_SETPOS , TRUE , DWORD(m_fFlowRate * (10000.0f/MAX_FLOW_RATE)) );
			SendMessage( hRollRate , TBM_SETPOS , TRUE , DWORD(m_fRollRate * (10000.0f/MAX_ROLL_RATE)) );
			SendMessage( hYawRate , TBM_SETPOS , TRUE , DWORD(m_fYawRate * (10000.0f/MAX_YAW_RATE)) );
			SendMessage( hParticleSize , TBM_SETPOS , TRUE ,
						 DWORD((m_fParticleSize-MIN_PARTICLE_SIZE)*(10000.0f/(MAX_PARTICLE_SIZE-MIN_PARTICLE_SIZE))) );

			// Set up radio buttons for colour sets. Disable "pick.." button if multicoloured is selected
			if ( m_dwColour1 == 0xffffffff )
			{
				CheckRadioButton( hDlg , IDC_COLOUR1_MULTI , IDC_COLOUR1_FIXED , IDC_COLOUR1_MULTI );
				EnableWindow( GetDlgItem( hDlg , IDC_COLOUR1_PICK ) , FALSE );
			}
			else
				CheckRadioButton( hDlg , IDC_COLOUR1_MULTI , IDC_COLOUR1_FIXED , IDC_COLOUR1_FIXED );

			if ( m_dwColour2 == 0xffffffff )
			{
				CheckRadioButton( hDlg , IDC_COLOUR2_MULTI , IDC_COLOUR2_FIXED , IDC_COLOUR2_MULTI );
				EnableWindow( GetDlgItem( hDlg , IDC_COLOUR2_PICK ) , FALSE );
			}
			else
				CheckRadioButton( hDlg , IDC_COLOUR2_MULTI , IDC_COLOUR2_FIXED , IDC_COLOUR2_FIXED );

			return FALSE;

		case WM_COMMAND:
			switch ( LOWORD(wParam) )
			{
				case IDOK:
					ExtractDialogSettings( hDlg );
					WriteSettings();
					EndDialog( hDlg , IDOK );
					break;

				case IDCANCEL:
					EndDialog( hDlg , IDCANCEL );
					break;

				case IDC_SCREEN_SETTINGS:
					DoScreenSettingsDialog( hDlg );
					break;

				case IDC_COLOUR1_MULTI:
					EnableWindow( GetDlgItem( hDlg , IDC_COLOUR1_PICK ) , FALSE );
					break;

				case IDC_COLOUR2_MULTI:
					EnableWindow( GetDlgItem( hDlg , IDC_COLOUR2_PICK ) , FALSE );
					break;

				case IDC_COLOUR1_FIXED:
					EnableWindow( GetDlgItem( hDlg , IDC_COLOUR1_PICK ) , TRUE );
					break;

				case IDC_COLOUR2_FIXED:
					EnableWindow( GetDlgItem( hDlg , IDC_COLOUR2_PICK ) , TRUE );
					break;

				case IDC_COLOUR1_PICK:
					m_dwFixedColour1 = PickColour( hDlg , m_dwFixedColour1 );
					break;

				case IDC_COLOUR2_PICK:
					m_dwFixedColour2 = PickColour( hDlg , m_dwFixedColour2 );
					break;
			}
			return TRUE;

		default:
			return FALSE;
	}
}

//**********************************************************************************
DWORD	CSwoosh::PickColour( HWND hParent , DWORD defcolour )
{
	CHOOSECOLOR		choose;
	static COLORREF	custom[16];

	choose.lStructSize = sizeof(choose);
	choose.hwndOwner = hParent;
	choose.rgbResult = ((defcolour&0xff)<<16)|((defcolour&0xff00))|((defcolour&0xff0000)>>16);
	choose.lpCustColors = custom;
	choose.Flags = CC_ANYCOLOR|CC_FULLOPEN|CC_RGBINIT;

	if ( ChooseColor( &choose ) )
		return ((choose.rgbResult&0xff)<<16)|((choose.rgbResult&0xff00)|(choose.rgbResult&0xff0000)>>16);
	else
		return defcolour;
}

//**********************************************************************************
void	CSwoosh::ExtractDialogSettings( HWND hDlg )
{
	HWND	hNumParticles = GetDlgItem( hDlg , IDC_NUM_PARTICLES );
	HWND	hColourMix = GetDlgItem( hDlg , IDC_COLOUR_MIX );
	HWND	hFlowRate = GetDlgItem( hDlg , IDC_FLOW_RATE );
	HWND	hRollRate = GetDlgItem( hDlg , IDC_ROLL_RATE );
	HWND	hYawRate = GetDlgItem( hDlg , IDC_YAW_RATE );
	HWND	hParticleSize = GetDlgItem( hDlg , IDC_PARTICLE_SIZE );

	float	f;

	m_dwNumParticles = SendMessage( hNumParticles , TBM_GETPOS , 0 , 0 );
	m_dwColourMix = SendMessage( hColourMix , TBM_GETPOS , 0 , 0 );

	f = (float)SendMessage( hFlowRate , TBM_GETPOS , 0 , 0 );
	m_fFlowRate = f * (MAX_FLOW_RATE/10000.0f);

	f = (float)SendMessage( hRollRate , TBM_GETPOS , 0 , 0 );
	m_fRollRate = f * (MAX_ROLL_RATE/10000.0f);

	f = (float)SendMessage( hYawRate , TBM_GETPOS , 0 , 0 );
	m_fYawRate = f * (MAX_YAW_RATE/10000.0f);

	f = (float)SendMessage( hParticleSize , TBM_GETPOS , 0 , 0 );
	m_fParticleSize = (f * ((MAX_PARTICLE_SIZE-MIN_PARTICLE_SIZE)/10000.0f)) + MIN_PARTICLE_SIZE;

	if ( IsDlgButtonChecked( hDlg , IDC_COLOUR1_MULTI ) )
		m_dwColour1 = 0xffffffff;
	else
		m_dwColour1 = m_dwFixedColour1;

	if ( IsDlgButtonChecked( hDlg , IDC_COLOUR2_MULTI ) )
		m_dwColour2 = 0xffffffff;
	else
		m_dwColour2 = m_dwFixedColour2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\stars\ssstars.c ===
/*

STARS.C

Starfield simulator screensaver.

  History:
       6/17/91        stevecat    ported to NT Windows
       2/10/92        stevecat    snapped to latest ported to NT Windows
*/

#include <windows.h>
#include <scrnsave.h>
#include <commctrl.h>
#include "stars.dlg"
#include "strings.h"
#include "uniconv.h"


#define SCOPE       256
#define MAXWARP     10              // Maximum warp speed
#define MINWARP     0               // Minimum warp speed
#define CLICKRANGE (MAXWARP-MINWARP)// Range for WarpSpeed scroll bar
#define MINSTARS    10              // Minimum number of stars in field
#define MAXSTARS    200             // Maximum number of stars in field
#define WARPFACTOR  10              // Warp Factor 10 Mr. Sulu!
#define SIZE        64
#define DEF_DENSITY 25              // Default number of stars in field
#define RAND(x)     ((rand() % (x))+1)
#define ZRAND(x)    (rand() % (x))
#define MINTIMERSPEED 50

VOID CreateStar            (WORD wIndex);
LONG GetDlgItemLong        (HWND hDlg, WORD wID, BOOL *pfTranslated, BOOL fSigned);
VOID GetIniEntries         (VOID);
LONG GetPrivateProfileLong (LPTSTR pszApp, LPTSTR pszKey, LONG lDefault);
WORD rand                  (VOID);
VOID srand                 (DWORD dwSeed);

DWORD dwRand;                           // Current random seed

TCHAR  szWarpSpeed [] = TEXT("WarpSpeed");     // .INI WarpSpeed key

TCHAR  szDensity [] = TEXT("Density");         // .INI Density key

LONG  nX[MAXSTARS],
      nY[MAXSTARS],
      nZ[MAXSTARS];
WORD  wXScreen,
      wYScreen,
      wX2Screen,
      wY2Screen;
WORD  wWarpSpeed,                       // Global WarpSpeed value
      wDensity;                         // Global starfield density value

//
// Help IDs
//
DWORD aStarsDlgHelpIds[] = {
    ((DWORD) -1), ((DWORD) -1),
    ID_SPEED_SLOW,              IDH_DISPLAY_SCREENSAVER_STARFIELD_WARP,
    ID_SPEED_FAST,              IDH_DISPLAY_SCREENSAVER_STARFIELD_WARP,
    ID_SPEED,                   IDH_DISPLAY_SCREENSAVER_STARFIELD_WARP,
    ID_DENSITY_LABEL,           IDH_DISPLAY_SCREENSAVER_STARFIELD_DENSITY,
    ID_DENSITY,                 IDH_DISPLAY_SCREENSAVER_STARFIELD_DENSITY,
    ID_DENSITYARROW,            IDH_DISPLAY_SCREENSAVER_STARFIELD_DENSITY,
    0,0
};

#define DIVIDE_SAFE(nNumber)            ((0 == (nNumber)) ? 1 : (nNumber))

/* This is the main window procedure to be used when the screen saver is
    activated in a screen saver mode ( as opposed to configure mode ).  This
    function must be declared as an EXPORT in the EXPORTS section of the
    DEFinition file... */

LRESULT ScreenSaverProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT         rRect;
    WORD         wLoop;
    static UINT_PTR wTimer;
    static WORD  wWarp;
    static WORD  wTimerSet=MINTIMERSPEED;
    static WORD  wCurrentWarp;
    static int   nPassCount=0;
    int          nXTemp, nYTemp, nTemp;
    BOOL         fHyperSpace = TRUE;
    HDC          hDC;

    switch (message)
    {
    case WM_CREATE:
        /* Do anything that you need to do when you initialize the window
           here... */
        GetIniEntries ();
        srand (GetCurrentTime ());

        /* Make sure we use the entire virtual desktop size for multiple
           displays... */

        wXScreen = (WORD) ((LPCREATESTRUCT)lParam)->cx;
        wYScreen = (WORD) ((LPCREATESTRUCT)lParam)->cy;


        wX2Screen = wXScreen / 2;
        wY2Screen = wYScreen / 2;
        for (wLoop = 0; wLoop < wDensity; wLoop++)
            CreateStar (wLoop);
        wWarp = wWarpSpeed * WARPFACTOR + WARPFACTOR; // ZRAND (((wWarpSpeed)*WARPFACTOR)+1)+1;

        wTimer = SetTimer (hWnd, 1, wTimerSet, NULL);
        break;

    case WM_SIZE:
        wXScreen = LOWORD(lParam);
        wYScreen = HIWORD(lParam);
        break;


    case WM_TIMER:
    {
        MSG msg;

        hDC = GetDC (hWnd);
        /* Begin to loop through each star, accelerating so it seems that
           we are traversing the starfield... */
        for (wLoop = 0; wLoop < wDensity; wLoop++)
        {
            nXTemp = (int)((nX[wLoop] * (LONG)(SCOPE * WARPFACTOR))
                                                / DIVIDE_SAFE(nZ[wLoop])) + wX2Screen;
            nYTemp = (int)((nY[wLoop] * SCOPE * WARPFACTOR) / DIVIDE_SAFE(nZ[wLoop]))
                                                     + wY2Screen;
            nTemp = (int)((SCOPE * WARPFACTOR - nZ[wLoop]) /
                                                    (SIZE * WARPFACTOR)) + 1;
            PatBlt (hDC, nXTemp, nYTemp, nTemp, nTemp, BLACKNESS);

            if (wCurrentWarp < wWarp)
                wCurrentWarp++;
            else if (wCurrentWarp > wWarp)
                wCurrentWarp--;

            nZ[wLoop] = max (0, (int)(nZ[wLoop] - wCurrentWarp));
            if (!nZ[wLoop])
                CreateStar (wLoop);

            nXTemp = (int)((nX[wLoop] * (LONG)(SCOPE * WARPFACTOR))
                                                    / DIVIDE_SAFE(nZ[wLoop])) + wX2Screen;
            nYTemp = (int)((nY[wLoop] * SCOPE * WARPFACTOR)
                                                    / DIVIDE_SAFE(nZ[wLoop])) + wY2Screen;
            if ((nXTemp < 0 || nYTemp < 0) ||
                (nXTemp > (int) wXScreen || nYTemp > (int) wYScreen))
            {
                CreateStar (wLoop);
                nXTemp = (int)((nX[wLoop] * (LONG)(SCOPE * WARPFACTOR))
                                                 / DIVIDE_SAFE(nZ[wLoop])) + wX2Screen;
                nYTemp = (int)((nY[wLoop] * SCOPE * WARPFACTOR)
                                                 / DIVIDE_SAFE(nZ[wLoop])) + wY2Screen;
            }
            nTemp = (int)((SCOPE * WARPFACTOR - nZ[wLoop]) /
                                                (SIZE * WARPFACTOR)) + 1;
            PatBlt (hDC, nXTemp, nYTemp, nTemp, nTemp, WHITENESS);
        }
        ReleaseDC (hWnd, hDC);

        if (PeekMessage(&msg, hWnd, WM_TIMER, WM_TIMER, PM_REMOVE))
        {
            // There is another WM_TIMER message in the queue.  We have
            // removed it, but now we want to adjust the timer a bit so
            // hopefully we won't get another WM_TIMER message before we
            // finish the screen update. (bug #8423)  TG:11/25/91

            wTimerSet += 10;
            SetTimer(hWnd, 1, wTimerSet, NULL);
            nPassCount = 0;
        }
        else
            ++nPassCount;

        if (nPassCount >= 100)
        {
            nPassCount = 0;
            wTimerSet -= 100;
            if ((short)wTimerSet < MINTIMERSPEED)
                wTimerSet = MINTIMERSPEED;
            SetTimer(hWnd, 1, wTimerSet, NULL);
        }
        break;
    }

    case WM_ERASEBKGND:
            /* If you want something put on the background, do it right here
                using wParam as a handle to a device context.  Remember to
                unrealize a brush if it is not a solid color.  If you do
                something here, you want to use the line:
                    return 0l;
                So the program knows not to take the default action. Otherwise
                just use:
                    break;
                */
        break;
        GetClientRect (hWnd, &rRect);
        FillRect ((HDC) wParam, &rRect, GetStockObject (GRAY_BRUSH));
        return 0l;

    case WM_DESTROY:
        /* Anything that needs to be deleted when the window is closed
                goes here... */
        if (wTimer)
            KillTimer (hWnd, wTimer);
        break;
    }
    /* Unless it is told otherwise, the program will take default actions... */
    return (DefScreenSaverProc (hWnd, message, wParam, lParam));
}


//***************************************************************************

BOOL ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL    fError;                         // Error flag

    UINT    wTemp;
    TCHAR   szTemp[20];                     // Temporary string buffer

    static WORD wPause, wScroll;
    static HWND hWarpSpeed,                 // window handle of Speed scrollbar
                hIDOK,                      // window handle of OK button
                hSetPassword,               // window handle of SetPassword button
                hDensity;                   // window handle of Density EditControl

    static WORD wIncScroll = 1;             // density spin button parameters

    static WORD wStartScroll = 1;
    static WORD wStartPause = 1;
    static WORD wMaxScroll = 10;
    static WORD wPauseScroll = 20;
    static LONG lMinScroll = MINSTARS;
    static LONG lMaxScroll = MAXSTARS;


    switch (message)
    {
    case WM_INITDIALOG:
        GetIniEntries ();
        hWarpSpeed = GetDlgItem (hDlg, ID_SPEED);
        hIDOK = GetDlgItem (hDlg, IDOK);
        hDensity = GetDlgItem (hDlg, ID_DENSITY);
        SendMessage (hDensity, EM_LIMITTEXT, 3, 0);

        SendDlgItemMessage( hDlg, ID_DENSITYARROW, UDM_SETBUDDY, (WPARAM)hDensity, 0);
        SendDlgItemMessage( hDlg, ID_DENSITYARROW, UDM_SETRANGE, 0, MAKELONG(lMaxScroll, lMinScroll));

        SetScrollRange (hWarpSpeed, SB_CTL, MINWARP, MAXWARP, FALSE);
        SetScrollPos (hWarpSpeed, SB_CTL, wWarpSpeed, TRUE);

        SetDlgItemInt (hDlg, ID_DENSITY, wDensity, FALSE);
        return TRUE;

    case WM_HSCROLL:
        switch (LOWORD(wParam))
        {
        case SB_LINEUP:
        case SB_PAGEUP:
            --wWarpSpeed;
            break;

        case SB_LINEDOWN:
        case SB_PAGEDOWN:
            ++wWarpSpeed;
            break;

        case SB_THUMBPOSITION:
            wWarpSpeed = HIWORD (wParam);
            break;

        case SB_TOP:
            wWarpSpeed = MINWARP;
            break;

        case SB_BOTTOM:
            wWarpSpeed = MAXWARP;
            break;

        case SB_THUMBTRACK:
        case SB_ENDSCROLL:
            return TRUE;
            break;
        }
        if ((int)((short)wWarpSpeed) <= MINWARP)
            wWarpSpeed = MINWARP;
        if ((int)wWarpSpeed >= MAXWARP)
            wWarpSpeed = MAXWARP;

        SetScrollPos ((HWND) lParam, SB_CTL, wWarpSpeed, TRUE);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_DENSITY:
            if (HIWORD(wParam) == EN_UPDATE)
            {
                wTemp = GetDlgItemInt (hDlg, ID_DENSITY, &fError, FALSE);
                fError = ((wTemp <= MAXSTARS) && (wTemp >= MINSTARS));
                EnableWindow (GetDlgItem (hDlg, ID_DENSITYARROW), fError);
                EnableWindow (GetDlgItem (hDlg, IDOK), fError);
            }
            break;

        case IDOK:
            wTemp = GetDlgItemInt (hDlg, ID_DENSITY, &fError, FALSE);
            wsprintf (szTemp, TEXT("%d"), wTemp);
            WritePrivateProfileString (szAppName, szDensity, szTemp, szIniFile);
            wsprintf (szTemp, TEXT("%d"), wWarpSpeed);
            WritePrivateProfileString (szAppName, szWarpSpeed, szTemp, szIniFile);

        case IDCANCEL:
            EndDialog (hDlg, LOWORD(wParam) == IDOK);
            return TRUE;

        }
        break;

    case WM_HELP: // F1
        WinHelp(
            (HWND) ((LPHELPINFO) lParam)->hItemHandle,
            szHelpFile,
            HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aStarsDlgHelpIds
        );
        break;

    case WM_CONTEXTMENU:  // right mouse click
        WinHelp(
            (HWND) wParam,
            szHelpFile,
            HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aStarsDlgHelpIds
        );
        break;

    default:
        break;
    }
    return FALSE;
}


/* This procedure is called right before the dialog box above is created in
   order to register any child windows that are custom controls.  If no
   custom controls need to be registered, then simply return TRUE.
   Otherwise, register the child controls however is convenient... */

BOOL RegisterDialogClasses (HANDLE hInst)
{
    InitCommonControls();

    return TRUE;
}

VOID srand (DWORD dwSeed)
{
    dwRand = dwSeed;
}

WORD rand (VOID)
{
    dwRand = dwRand * 214013L + 2531011L;
    return (WORD)((dwRand >> 16) & 0xffff);
}

VOID CreateStar (WORD wIndex)
{
    nX[wIndex] = wXScreen ? (LONG)((int)(ZRAND (wXScreen)) - (int)wX2Screen) : 0;
    nY[wIndex] = wXScreen ? (LONG)((int)(ZRAND (wYScreen)) - (int)wY2Screen) : 0;
    nZ[wIndex] = SCOPE * WARPFACTOR;
}

LONG GetDlgItemLong (HWND hDlg, WORD wID, BOOL *pfTranslated, BOOL fSigned)
{
    TCHAR szTemp[20];
    LPTSTR pszTemp;
    LONG lTemp = 0l;
    BOOL fNegative;

    if (!GetDlgItemText (hDlg, wID, szTemp, CharSizeOf(szTemp)))
        goto GetDlgItemLongError;

    szTemp[19] = TEXT('\0');
    pszTemp = szTemp;
    while (*pszTemp == TEXT(' ') || *pszTemp == TEXT('\t'))
        pszTemp++;
    if ((!fSigned && *pszTemp == TEXT('-')) || !*pszTemp)
        goto GetDlgItemLongError;
    fNegative = (*pszTemp == TEXT('-')) ? TRUE : FALSE;
    while (*pszTemp >= TEXT('0') && *pszTemp <= TEXT('9'))
        lTemp = lTemp * 10l + (LONG)(*(pszTemp++) - TEXT('0'));
    if (*pszTemp)
        goto GetDlgItemLongError;
    if (fNegative)
        lTemp *= -1;
    *pfTranslated = TRUE;
    return lTemp;

GetDlgItemLongError:
    *pfTranslated = FALSE;
    return 0l;
}


LONG GetPrivateProfileLong (LPTSTR pszApp, LPTSTR pszKey, LONG lDefault)
{
    LONG    lTemp = 0l;
    TCHAR    szTemp[20];
    LPTSTR pszTemp;

    if (!GetPrivateProfileString (pszApp, pszKey, TEXT(""), szTemp, CharSizeOf(szTemp), szIniFile))
        goto GetProfileLongError;

    szTemp[19] = TEXT('\0');
    pszTemp = szTemp;
    while (*pszTemp >= TEXT('0') && *pszTemp <= TEXT('9'))
        lTemp = lTemp * 10l + (LONG)(*(pszTemp++) - TEXT('0'));
    if (*pszTemp)
        goto GetProfileLongError;
    return lTemp;

GetProfileLongError:
    return lDefault;
}


VOID GetIniEntries (VOID)
{
    LoadString (hMainInstance, idsName, szName, CharSizeOf(szName));
    LoadString (hMainInstance, idsAppName, szAppName, CharSizeOf(szAppName));

    //Load Common Strings from stringtable...
    LoadString (hMainInstance, idsIniFile, szIniFile, CharSizeOf(szIniFile));
    LoadString (hMainInstance, idsScreenSaver, szScreenSaver, CharSizeOf(szScreenSaver));
    LoadString (hMainInstance, idsHelpFile, szHelpFile, CharSizeOf(szHelpFile));
    LoadString (hMainInstance, idsNoHelpMemory, szNoHelpMemory, CharSizeOf(szNoHelpMemory));

    wWarpSpeed = (WORD) GetPrivateProfileInt (szAppName, szWarpSpeed, MINWARP + ((MAXWARP - MINWARP) / 2), szIniFile);
    if (wWarpSpeed > MAXWARP)
        wWarpSpeed = MINWARP + ((MAXWARP - MINWARP) / 2);

    wDensity = (WORD) GetPrivateProfileInt (szAppName, szDensity, DEF_DENSITY, szIniFile);
    if (wDensity > MAXSTARS)
        wDensity = MAXSTARS;
    if (wDensity < MINSTARS)
        wDensity = MINSTARS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\text3d\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Text3D.rc
//
#define IDS_DESCRIPTION                 1
#define IDI_ICON1                       101
#define IDB_TEXTURE                     102
#define IDB_SPHEREMAP                   103
#define IDD_SETTINGS                    105
#define IDD_ABOUT                       116
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201
#define IDC_DEVICE_SELECT               1000
#define IDS_DEFAULTTEXT                 1000
#define IDC_MODE_SELECT                 1001
#define IDC_SCREENSETTINGS              1002
#define IDC_RADIO_TIME                  1004
#define IDC_RADIO_TEXT                  1005
#define IDC_RADIO_COLOR                 1007
#define IDS_NONE                        1008
#define IDC_RADIO_TEXTURE               1008
#define IDS_SPIN                        1009
#define IDC_RADIO_REFLECTION            1009
#define IDS_SEESAW                      1010
#define IDS_WOBBLE                      1011
#define IDC_SPECULAR                    1012
#define IDS_TUMBLE                      1012
#define IDC_ROTATION_SPEED              1013
#define IDS_FILEFILTER                  1013
#define IDC_ROTATION_STYLE              1014
#define IDS_OPENTEXTURETITLE            1014
#define IDC_ABOUT                       1015
#define IDS_OPENENVIRONMENTMAPTITLE     1015
#define IDS_FONT                        1016
#define IDC_RESOLUTION                  1016
#define IDC_SURFACE_COLOR               1017
#define IDC_VIEWPORTSIZE                1020
#define IDC_BROWSE_TEXTURE              1022
#define IDC_BROWSE_ENVIRONMENT          1024
#define IDC_USE_CUSTOM_TEXTURE          1025
#define IDC_USE_CUSTOM_ENVIRONMENT      1026
#define IDC_USE_CUSTOM_COLOR            1027
#define IDC_SELECT_FONT                 1028
#define IDC_DISPLAY_STRING              1029
#define DLG_SELECT_FONT                 1543
#define IDS_INIFILE                     9105
#define IDS_INI_SECTION                 9106
#define IDS_SAVERNAME                   9107
#define IDS_OPTIONS                     9108
#define IDS_OBJTYPE                     9109
#define IDS_TEXTURE                     9110
#define IDS_TEXTURE_FILE_OFFSET         9111
#define IDS_SIZE                        9112
#define IDS_TESSELATION                 9113
#define IDS_GENNAME                     9114
#define IDS_DEFFONT                     9115
#define IDS_DEFCHARSET	                9116
#define IDS_DEMOTYPE                    9117
#define IDS_SURFSTYLE                   9118
#define IDS_FONT_REG                    9119
#define IDS_FONT_ATTRIBUTES             9120
#define IDS_CHARSET                     9121
#define IDS_TEXT                        9122
#define IDS_SPEED                       9123
#define IDS_ROTSTYLE                    9124
#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016
#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112
#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\sound\init.c ===
#include <windows.h>
#include <port1632.h>
#include <cpl.h>
#include <cphelp.h>
#include "snd.h"

/*---------------------------------------------------------------------------*/

#define NUM_APPLETS 1

/*---------------------------------------------------------------------------*/

typedef struct tagAppletInfo {
   int   idIcon;
    int idName;
    int idInfo;
    BOOL    bEnabled;
    DWORD   dwContext;
    PSTR    szHelp;
}   APPLET_INFO;

/*---------------------------------------------------------------------------*/

char    aszSoundHlp[24];
char    aszErrorPlayTitle[32];
char    aszErrorPlayMessage[64];
char    aszWarningTitle[64];
char    aszWarningMessage[128];
char    aszNoSound[16];
char    aszNoDevice[128];
char    aszAppName[30];
char    aszWriteErr[100];
DWORD   dwContext;
HINSTANCE   hInstance;
UINT    uHelpMessage;

/*---------------------------------------------------------------------------*/

static  SZCODE aszHelpMessage[] = "ShellHelp";
static  APPLET_INFO applets[NUM_APPLETS];

/*---------------------------------------------------------------------------*/

BOOL DllInitialize( IN PVOID hmod
                  , IN DWORD ulReason
                  , IN PCONTEXT pctx OPTIONAL
                  )
{
    if (ulReason != DLL_PROCESS_ATTACH)
        return TRUE;

    hInstance = hmod;
    applets[0].idIcon = ID_ICON;
    applets[0].idName = IDS_NAME;
    applets[0].idInfo = IDS_INFO;
    applets[0].bEnabled = TRUE;
    applets[0].dwContext = IDH_CHILD_SND;
    applets[0].szHelp = aszSoundHlp;

    LoadString(hInstance, IDS_UNABLETITLE, aszErrorPlayTitle, sizeof(aszErrorPlayTitle));
    LoadString(hInstance, IDS_UNABLEMESSAGE, aszErrorPlayMessage, sizeof(aszErrorPlayMessage));
    LoadString(hInstance, IDS_WARNINGTITLE, aszWarningTitle, sizeof(aszWarningTitle));
    LoadString(hInstance, IDS_WARNINGMESSAGE, aszWarningMessage, sizeof(aszWarningMessage));
    LoadString(hInstance, IDS_NONE, aszNoSound, sizeof(aszNoSound));
    LoadString(hInstance, IDS_APPNAME, aszAppName, sizeof(aszAppName));
    LoadString(hInstance, IDS_HELPFILE, aszSoundHlp, sizeof(aszSoundHlp));
    LoadString(hInstance, IDS_NODEVICE, aszNoDevice, sizeof(aszNoDevice));
    LoadString(hInstance, IDS_WRITEERR, aszWriteErr, sizeof(aszWriteErr));
    return TRUE;
}/* DllInitialize */

/*---------------------------------------------------------------------------*/

static void RunApplet( HWND hwnd, int cmd)
{
    dwContext = applets[cmd].dwContext;
    DialogBox(hInstance, MAKEINTRESOURCE(DLG_SOUND), hwnd, SoundDlg);
}/* RunApplet */

/*---------------------------------------------------------------------------*/

LRESULT CPlApplet( HWND hwnd
              , UINT wMsg
              , LPARAM lParam1
              , LPARAM lParam2
              )
{
    LPCPLINFO lpCPlInfo;         // was LPNEWCLPINFO in 3.1  -- LKG ???
    int iApplet;

    switch (wMsg) {
    case CPL_INIT:
        uHelpMessage = RegisterWindowMessage(aszHelpMessage);
        return TRUE;

    case CPL_GETCOUNT:
        // second message to CPlApplet(), sent once only
        return NUM_APPLETS;

    case CPL_INQUIRE:            // was NEWINQUIRE in 3.1 -- LKG ???
        /* third message to CPlApplet().  It is sent as many times
           as the number of applets returned by CPL_GETCOUNT message
        */
        /* Your DLL must contain an icon and two string resources.
           idIcon is the icon resource ID, idName and idInfo are
           string resource ID's for a short name, and description.
        */
        lpCPlInfo = (LPCPLINFO)lParam2;       // was LPNEWCPLINFO in 3.1 ???
        iApplet = (int)(LONG)lParam1;
      /***************3.1*******************
         lpCPlInfo->hIcon = LoadIcon( hInstance
                                    , MAKEINTRESOURCE(applets[iApplet].idIcon)
                                    );
         if ( !LoadString( hInstance
                         , applets[iApplet].idName
                         , lpCPlInfo->szName
                         , sizeof(lpCPlInfo->szName)
                         )
            )
            lpCPlInfo->szName[0] = 0;
         if( !LoadString( hInstance
                        , applets[iApplet].idInfo
                        , lpCPlInfo->szInfo
                        , sizeof(lpCPlInfo->szInfo)
                        )
           )
            lpCPlInfo->szInfo[0] = 0;
         lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
         lpCPlInfo->dwHelpContext = applets[iApplet].dwContext;
         lstrcpy(lpCPlInfo->szHelpFile, applets[iApplet].szHelp);
      ************************************/
      lpCPlInfo->idIcon = ID_ICON;
      lpCPlInfo->idName = IDS_NAME;
        lpCPlInfo->lData = (LONG)iApplet;
        lpCPlInfo->idInfo = IDS_INFO;
        return TRUE;
    case CPL_DBLCLK:
        RunApplet(hwnd, (int)(LONG)lParam2);
        break;
    case CPL_SELECT:
        /* One of your applets has been selected.
           lParam1 is an index from 0 to (NUM_APPLETS-1)
           lParam2 is the lData value associated with the applet
        */
        break;
    case CPL_STOP:
        /* Sent once for each applet prior to the CPL_EXIT msg.
           lParam1 is an index from 0 to (NUM_APPLETS-1)
           lParam2 is the lData value associated with the applet
        */
        break;
    case CPL_EXIT:
        /* Last message, sent once only, before CONTROL.EXE calls
           FreeLibrary() on your DLL.
        */
        break;
    }
    return 0;

}/* CPlApplet */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\text3d\text3d.cpp ===
//-----------------------------------------------------------------------------
// File: Text3D.cpp
//
// Desc: Fun screen saver.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <Windows.h>
#include <d3d8.h>
#include <d3dx8.h>
#include <d3dsaver.h>
#include <d3d8rgbrast.h>
#include <time.h>
#include <commdlg.h>
#include <commctrl.h>
#include "Text3D.h"
#include "Resource.h"
#include "dxutil.h"


CTextScreensaver* g_pMyTextScreensaver = NULL;



#define BUF_SIZE 255
TCHAR g_szSectName[BUF_SIZE];
TCHAR g_szFname[BUF_SIZE];


//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    HRESULT hr;
    CTextScreensaver textSS;

    if( FAILED( hr = textSS.Create( hInst ) ) )
    {
        textSS.DisplayErrorMsg( hr );
        return 0;
    }

    return textSS.Run();
}




//-----------------------------------------------------------------------------
// Name: LoadTextureFromResource()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT LoadTextureFromResource( LPDIRECT3DDEVICE8 pd3dDevice, 
    TCHAR* strRes, TCHAR* strResType, LPDIRECT3DTEXTURE8* ppTex )
{
    HRESULT hr;
    HMODULE hModule = NULL;
    HRSRC rsrc;
    HGLOBAL hgData;
    LPVOID pvData;
    DWORD cbData;

    rsrc = FindResource( hModule, strRes, strResType );
    if( rsrc != NULL )
    {
        cbData = SizeofResource( hModule, rsrc );
        if( cbData > 0 )
        {
            hgData = LoadResource( hModule, rsrc );
            if( hgData != NULL )
            {
                pvData = LockResource( hgData );
                if( pvData != NULL )
                {
                    if( FAILED( hr = D3DXCreateTextureFromFileInMemory( pd3dDevice, 
                        pvData, cbData, ppTex ) ) )
                    {
                        return hr;
                    }
                }
            }
        }
    }
    
    if( *ppTex == NULL)
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CTextScreensaver()
// Desc: Constructor
//-----------------------------------------------------------------------------
CTextScreensaver::CTextScreensaver()
{
    g_pMyTextScreensaver = this;

    LoadString( NULL, IDS_DESCRIPTION, m_strWindowTitle, 200 );
    InitCommonControls();
    
    ZeroMemory( m_DeviceObjects, sizeof(m_DeviceObjects) );
    m_hFont = NULL; 
    m_bUseDepthBuffer = TRUE;
    m_dwMinDepthBits = 16;
    m_floatrect.xSize = 0.0f;
    lstrcpy( m_strRegPath, TEXT("Software\\Microsoft\\Screensavers\\Text3D") );

    m_fAngleX = 0.0f;
    m_fAngleY = 0.0f;
    m_fAngleZ = 0.0f;

    m_dwMeshUpdateCounter = 0;

    srand((UINT)time(NULL)); // seed random number generator
}




//-----------------------------------------------------------------------------
// Name: RegisterSoftwareDevice()
// Desc: This can register the D3D8RGBRasterizer or any other
//       pluggable software rasterizer.
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::RegisterSoftwareDevice()
{ 
    m_pD3D->RegisterSoftwareDevice( D3D8RGBRasterizer );

    return S_OK; 
}


//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::FrameMove()
{
    DWORD   tick = GetTickCount();
    DWORD   elapsed = tick - m_dwLastTick;
    m_dwLastTick = tick;

    // update floatrect
    RECT rcBounceBounds;

    if( m_floatrect.xSize == 0.0f )
    {
        // Initialize floatrect
        RECT rcBounds;
        DWORD dwParentWidth;
        DWORD dwParentHeight;

        rcBounds = m_rcRenderTotal;

        dwParentWidth = rcBounds.right - rcBounds.left;
        dwParentHeight = rcBounds.bottom - rcBounds.top;

        FLOAT sizeFact;
        FLOAT sizeScale;
        DWORD size;

        sizeScale = m_dwSize / 10.0f;
        sizeFact = 0.25f + (0.75f * sizeScale);     // range 25-100%
        size = (DWORD) (sizeFact * ( dwParentWidth > dwParentHeight ? dwParentHeight : dwParentWidth ) );

        if( size > dwParentWidth )
            size = dwParentWidth;
        if( size > dwParentHeight )
            size = dwParentHeight;

        // Start floatrect centered on first RenderUnit's screen
        if( !m_bWindowed )
        {
            INT iMonitor = m_RenderUnits[0].iMonitor;
            rcBounds = m_Monitors[iMonitor].rcScreen;
        }
        m_floatrect.xMin = rcBounds.left + ((rcBounds.right - rcBounds.left) - size) / 2.0f;
        m_floatrect.yMin = rcBounds.top + ((rcBounds.bottom - rcBounds.top) - size) / 2.0f;
        m_floatrect.xSize = (FLOAT)size;
        m_floatrect.ySize = (FLOAT)size;

        m_floatrect.xVel = 0.01f * (FLOAT) size;
        if( rand() % 2 == 0 )
            m_floatrect.xVel = -m_floatrect.xVel;

        m_floatrect.yVel = 0.01f * (FLOAT) size;
        if( rand() % 2 == 0 )
            m_floatrect.yVel = -m_floatrect.yVel;
    }

    rcBounceBounds = m_rcRenderTotal;

    FLOAT xMinOld = m_floatrect.xMin;
    FLOAT yMinOld = m_floatrect.yMin;

    m_floatrect.xMin += m_floatrect.xVel * 20.0f * m_fElapsedTime;
    m_floatrect.yMin += m_floatrect.yVel * 20.0f * m_fElapsedTime;
    if( m_floatrect.xVel < 0 && m_floatrect.xMin < rcBounceBounds.left || 
        m_floatrect.xVel > 0 && (m_floatrect.xMin + m_floatrect.xSize) > rcBounceBounds.right )
    {
        m_floatrect.xMin = xMinOld; // undo last move
        m_floatrect.xVel = -m_floatrect.xVel; // change direction
    }
    if( m_floatrect.yVel < 0 && m_floatrect.yMin < rcBounceBounds.top || 
        m_floatrect.yVel > 0 && (m_floatrect.yMin + m_floatrect.ySize) > rcBounceBounds.bottom )
    {
        m_floatrect.yMin = yMinOld; // undo last move
        m_floatrect.yVel = -m_floatrect.yVel; // change direction
    }

    UpdateAngles( elapsed );

    if ( m_bDisplayTime )
    {
        if ( UpdateTimeString( m_szDisplayString ) )
        {
            m_dwMeshUpdateCounter++; // provoke a mesh update at render tiem
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::Render()
{
    D3DVIEWPORT8 vp;

    // First, clear the entire back buffer to the background color
    vp.X = 0;
    vp.Y = 0;
    vp.Width = m_rcRenderCurDevice.right - m_rcRenderCurDevice.left;
    vp.Height = m_rcRenderCurDevice.bottom - m_rcRenderCurDevice.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff000000, 1.0f, 0L );

    // Now determine what part of the floatrect, if any, intersects the current screen
    RECT rcFloatThisScreen;
    RECT rcFloatThisScreenClipped;

    rcFloatThisScreen.left = (INT)m_floatrect.xMin;
    rcFloatThisScreen.top = (INT)m_floatrect.yMin;
    rcFloatThisScreen.right = rcFloatThisScreen.left + (INT)m_floatrect.xSize;
    rcFloatThisScreen.bottom = rcFloatThisScreen.top + (INT)m_floatrect.ySize;

    if( !IntersectRect(&rcFloatThisScreenClipped, &rcFloatThisScreen, &m_rcRenderCurDevice) )
    {
        return S_OK; // no intersection, so nothing further to render on this screen
    }

    // Convert rcFloatThisScreen from screen to window coordinates
    OffsetRect(&rcFloatThisScreen, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);
    OffsetRect(&rcFloatThisScreenClipped, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);

    // Now set up the viewport to render to the clipped rect
    vp.X = rcFloatThisScreenClipped.left;
    vp.Y = rcFloatThisScreenClipped.top;
    vp.Width = rcFloatThisScreenClipped.right - rcFloatThisScreenClipped.left;
    vp.Height = rcFloatThisScreenClipped.bottom - rcFloatThisScreenClipped.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );
//    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff0000ff, 1.0f, 0L );

    // Now set up the projection matrix to only render the onscreen part of the
    // rect to the viewport
    D3DXMATRIX matProj;
    FLOAT l,r,b,t;
    l = -0.8f;
    r =  0.8f;
    b =  0.8f;
    t = -0.8f;
    FLOAT cxUnclipped = (rcFloatThisScreen.right + rcFloatThisScreen.left) / 2.0f;
    FLOAT cyUnclipped = (rcFloatThisScreen.bottom + rcFloatThisScreen.top) / 2.0f;
    l *= (rcFloatThisScreenClipped.left - cxUnclipped) / (rcFloatThisScreen.left - cxUnclipped);
    r *= (rcFloatThisScreenClipped.right - cxUnclipped) / (rcFloatThisScreen.right - cxUnclipped);
    t *= (rcFloatThisScreenClipped.top - cyUnclipped) / (rcFloatThisScreen.top - cyUnclipped);
    b *= (rcFloatThisScreenClipped.bottom - cyUnclipped) / (rcFloatThisScreen.bottom - cyUnclipped);
    D3DXMatrixPerspectiveOffCenterLH( &matProj, l, r, t, b, 1.0f, 50.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION , &matProj );

    // Mesh updates happen in Render() instead of FrameMove() since they
    // are per-device
    if( m_pDeviceObjects->m_dwMeshUpdateCounter != m_dwMeshUpdateCounter )
    {
        BuildTextMesh( m_szDisplayString );
        m_pDeviceObjects->m_dwMeshUpdateCounter = m_dwMeshUpdateCounter;
    }

    m_pd3dDevice->BeginScene();

    // Set world matrix
    D3DXMATRIX  rotx,roty,rotz,trans,trans2;
    D3DXMatrixTranslation( &trans , m_fTextOffsetX , m_fTextOffsetY , 0.25f );
    D3DXMatrixRotationX( &rotx , m_fAngleX );
    D3DXMatrixRotationY( &roty , m_fAngleY );
    D3DXMatrixRotationZ( &rotz , m_fAngleZ );
    D3DXMatrixTranslation( &trans2, 0, 0, 1.5f + (m_fTextMaxX - m_fTextMinX) );
    m_matWorld = trans * rotx * roty * rotz * trans2;
    m_pd3dDevice->SetTransform( D3DTS_WORLDMATRIX(0) , &m_matWorld );

    // Set other per-frame states
    SetPerFrameStates();

    // Draw mesh
    m_pDeviceObjects->m_pObject->DrawSubset( 0 );

    m_pd3dDevice->EndScene();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::RestoreDeviceObjects()
{
    HRESULT rc;

    // Set up sensible view matrix
    D3DXMatrixLookAtLH( &m_matView , &D3DXVECTOR3(0,0,0) , &D3DXVECTOR3(0,0,1) , &D3DXVECTOR3(0,1,0) );
    m_pd3dDevice->SetTransform( D3DTS_VIEW , &m_matView );

    // Set some basic renderstates
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE , D3DZB_TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZFUNC , D3DCMP_LESSEQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE , m_bSpecular );

    // Create the GDI font object
    LONG    h = m_Font.lfHeight;
    m_Font.lfHeight = 100;
    m_hFont = CreateFontIndirect( &m_Font );
    m_Font.lfHeight = h;
    if ( m_hFont == NULL )
        return E_FAIL;

    // Initialise time string
    if ( m_bDisplayTime )
        UpdateTimeString( m_szDisplayString );

    // Make mesh for text string
    if ( FAILED(rc = BuildTextMesh( m_szDisplayString )) )
        return rc;

    // Update offsets for mesh
    m_fTextOffsetX = (m_fTextMinX + m_fTextMaxX) * -0.5f;
    m_fTextOffsetY = (m_fTextMinY + m_fTextMaxY) * -0.5f;

    // Load appropriate texture (if any)
    switch ( m_SurfType )
    {
        case color:
            m_pDeviceObjects->m_pTexture = NULL;
            break;

        case environment:
            if ( m_bUseCustomEnvironment )
            {
                m_pDeviceObjects->m_pTexture = CreateTextureFromFile( m_szCustomEnvironment );
            }
            if ( m_pDeviceObjects->m_pTexture == NULL )
            {
                LoadTextureFromResource( m_pd3dDevice, MAKEINTRESOURCE(IDB_SPHEREMAP), 
                    TEXT("JPG"), &m_pDeviceObjects->m_pTexture );
            }
            break;

        case texture:
            if ( m_bUseCustomTexture )
            {
                m_pDeviceObjects->m_pTexture = CreateTextureFromFile( m_szCustomTexture );
            }
            if ( m_pDeviceObjects->m_pTexture == NULL )
            {
                LoadTextureFromResource( m_pd3dDevice, MAKEINTRESOURCE(IDB_TEXTURE), 
                    TEXT("JPG"), &m_pDeviceObjects->m_pTexture );
            }
            break;

        default:
            return E_FAIL;
    }

    // Set per-frame states
    SetPerFrameStates();

    m_dwLastTick = GetTickCount();

    return S_OK;
}




//**********************************************************************************
VOID CTextScreensaver::SetPerFrameStates()
{
    m_pd3dDevice->SetTexture( 0 , m_pDeviceObjects->m_pTexture );

    // Set up texture pipeline
    if ( m_SurfType == color )
    {
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLOROP , D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG1 , D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG2 , D3DTA_DIFFUSE );
    }
    else
    {
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLOROP , D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG1 , D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG2 , D3DTA_DIFFUSE );
    }
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ALPHAOP , D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MAGFILTER , D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MINFILTER , D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MIPFILTER , D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ADDRESSU , D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ADDRESSV , D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_COLOROP , D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_ALPHAOP , D3DTOP_DISABLE );

    // Set up lighting
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING , TRUE );
    if ( !m_bSpecular )
        m_pd3dDevice->SetRenderState( D3DRS_AMBIENT , 0x646464 );
    else
        m_pd3dDevice->SetRenderState( D3DRS_AMBIENT , 0x464646 );
    D3DLIGHT8   light;
    light.Type = D3DLIGHT_DIRECTIONAL;
    light.Diffuse = D3DXCOLOR(1,1,1,0);
    light.Specular = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
    light.Ambient = D3DXCOLOR(0,0,0,0);
    light.Direction = D3DXVECTOR3(0.5,-0.5,1);
    light.Position = D3DXVECTOR3(0,0,0);
    light.Range = 10000;
    light.Falloff = light.Attenuation0 = light.Attenuation1 = light.Attenuation2 = 0;
    light.Phi = light.Theta = 0;
    m_pd3dDevice->SetLight( 0 , &light );
    m_pd3dDevice->LightEnable( 0 , TRUE );

    // Set up material
    D3DMATERIAL8    mat;
    if ( m_SurfType == color )
    {
        DWORD dwColor;
        if( m_bUseCustomColor )
            dwColor = m_SurfaceColor;
        else
            dwColor = 0x00777777;

        mat.Diffuse.r = FLOAT(dwColor&0xff)/255.0f;
        mat.Diffuse.g = FLOAT((dwColor>>8)&0xff)/255.0f;
        mat.Diffuse.b = FLOAT((dwColor>>16)&0xff)/255.0f;
    }
    else
    {
        mat.Diffuse = D3DXCOLOR(1,1,1,0);
    }
    mat.Ambient = mat.Diffuse;
    mat.Specular = D3DXCOLOR(1.0f,1.0f,1.0f,0);
    mat.Emissive = D3DXCOLOR(0,0,0,0);
    mat.Power = 5;
    m_pd3dDevice->SetMaterial( &mat );

    // Set up texture coordinate generation if we're environment mapping or just force to passthrough
    if ( m_SurfType == environment )
    {
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_TEXCOORDINDEX , D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_TEXTURETRANSFORMFLAGS , D3DTTFF_COUNT2 );

        D3DXMATRIX  envmat;
        D3DXMatrixIdentity( &envmat );

        envmat._11 = envmat._22 = 0.5f;
        envmat._31 = envmat._32 = 0.5f;
        m_pd3dDevice->SetTransform( D3DTS_TEXTURE0 , &envmat );
    }
    else
    {
        D3DXMATRIX matWorldView;
        D3DXMATRIX matWorldViewInv;

        matWorldView = m_matWorld * m_matView;
        D3DXMatrixInverse( &matWorldViewInv, NULL, &matWorldView );
        m_pd3dDevice->SetTransform( D3DTS_TEXTURE0, &matWorldViewInv );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_TEXCOORDINDEX , D3DTSS_TCI_CAMERASPACEPOSITION );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_TEXTURETRANSFORMFLAGS , D3DTTFF_COUNT2 );
    }

    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE , FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE , FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE , m_bSpecular );
    m_pd3dDevice->SetRenderState( D3DRS_WRAP0 , D3DWRAP_U|D3DWRAP_V );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE , FALSE );

    m_pd3dDevice->SetTexture( 0, m_pDeviceObjects->m_pTexture );
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::InvalidateDeviceObjects()
{
    SAFE_RELEASE(m_pDeviceObjects->m_pTexture);
    SAFE_RELEASE(m_pDeviceObjects->m_pObject);
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ConfirmDevice()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, 
                                        D3DFORMAT fmtBackBuffer)
{
    // Need D3DVTXPCAPS_TEXGEN for D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR
    if( ( ( dwBehavior & D3DCREATE_HARDWARE_VERTEXPROCESSING ) ||
          ( dwBehavior & D3DCREATE_MIXED_VERTEXPROCESSING ) ) &&
        ( pCaps->VertexProcessingCaps & D3DVTXPCAPS_TEXGEN ) == 0 )
    {
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetDevice()
// Desc: 
//-----------------------------------------------------------------------------
VOID CTextScreensaver::SetDevice( UINT iDevice )
{
    m_pDeviceObjects = &m_DeviceObjects[iDevice];
}




//***************************************************************************************
IDirect3DTexture8*  CTextScreensaver::CreateTextureFromFile( const TCHAR* filename )
{
    IDirect3DTexture8*  texture;
    if ( FAILED(D3DXCreateTextureFromFile( m_pd3dDevice , filename , &texture )) )
        return NULL;
    else
        return texture;
}




//***************************************************************************************
HRESULT CTextScreensaver::BuildTextMesh( const TCHAR* text )
{
    // Release any old text mesh we built
    SAFE_RELEASE(m_pDeviceObjects->m_pObject);

    // Create temporary DC and select the correct font into it
    HDC hdc = CreateDC( TEXT("DISPLAY") , NULL , NULL , NULL );
    SelectObject( hdc , m_hFont );

    TCHAR szText[MAX_DISPLAY_STRING+1];
    lstrcpy( szText, text );

    // Build new mesh
    FLOAT               max_deviation = 5.0f / FLOAT(m_dwMeshQuality+10);
    GLYPHMETRICSFLOAT   metrics[MAX_DISPLAY_STRING+1];
    HRESULT             rc;
    rc = D3DXCreateText( m_pd3dDevice , hdc , szText , max_deviation, 0.5f , &m_pDeviceObjects->m_pObject , NULL, metrics );
    if( FAILED( rc ) )
    {
        // We might have failed because the string had no glyphs, so try 
        // the default text instead
        LoadString( NULL, IDS_DEFAULTTEXT, szText, MAX_DISPLAY_STRING );
        rc = D3DXCreateText( m_pd3dDevice , hdc , szText , max_deviation, 0.5f , &m_pDeviceObjects->m_pObject , NULL, metrics );
    }

    // Delete temporary DC
    DeleteDC( hdc );
    if ( FAILED(rc) )
        return rc;

    // Compute the bounding box for the mesh by stepping through the glyph metrics structures
    int len = lstrlen( szText );
    m_fTextMinX = 1000000;
    m_fTextMaxX = -1000000;
    m_fTextMinY = 1000000;
    m_fTextMaxY = -1000000;
    FLOAT   originx = 0;
    FLOAT   originy = 0;
    GLYPHMETRICSFLOAT*  pglyph = metrics;
    for ( int i = 0 ; i < len ; i++ , pglyph++ )
    {
        if ( (pglyph->gmfptGlyphOrigin.x + originx) < m_fTextMinX )
            m_fTextMinX = (pglyph->gmfptGlyphOrigin.x + originx);
        if ( (pglyph->gmfptGlyphOrigin.x + originx + pglyph->gmfBlackBoxX) > m_fTextMaxX )
            m_fTextMaxX = (pglyph->gmfptGlyphOrigin.x + originx + pglyph->gmfBlackBoxX);

        if ( (pglyph->gmfptGlyphOrigin.y + originy) > m_fTextMaxY )
            m_fTextMaxY = (pglyph->gmfptGlyphOrigin.y + originy);
        if ( (pglyph->gmfptGlyphOrigin.y + originy - pglyph->gmfBlackBoxY) < m_fTextMinY )
            m_fTextMinY = (pglyph->gmfptGlyphOrigin.y + originy - pglyph->gmfBlackBoxY);

        originx += pglyph->gmfCellIncX;
        originy += pglyph->gmfCellIncY;
    }

    return S_OK;
}




//*********************************************************************************
VOID CTextScreensaver::UpdateAngles( DWORD elapsed )
{
    static FLOAT    x,y,z,t;
    const FLOAT     pi2 = 3.1415926536f * 2.0f;

    FLOAT inc = FLOAT(elapsed * m_dwRotationSpeed);

    switch ( m_RotType )
    {
        case spin:
            y += inc * 0.00002f;
            break;

        case seesaw:
            t += inc * 0.000025f;
            y = (FLOAT(sin((t * pi2))) * 0.17f) + 1.0f;
            break;

        case wobble:
            t += inc * 0.000025f;
            y = (FLOAT(sin((t * pi2))) * 0.17f) + 1.0f;
            z = (FLOAT(cos((t * pi2))) * 0.09f) + 1.0f;
            break;

        case tumble:
            x += inc * 0.000004f;
            y += inc * 0.000018f;
            z += inc * 0.000007f;
            break;
    }

    x = x - int(x);
    y = y - int(y);
    z = z - int(z);

    m_fAngleX = x * pi2;
    m_fAngleY = y * pi2;
    m_fAngleZ = z * pi2;
}




//***************************************************************************************
BOOL CTextScreensaver::UpdateTimeString( TCHAR* string )
{
    TCHAR    str[30];

    GetTimeFormat( LOCALE_USER_DEFAULT, 0, NULL, NULL, str, 30 );

    if ( lstrcmp( string , str ) )
    {
        lstrcpy( string , str );
        return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CTextScreensaver::ReadSettings()
{
    HKEY hkey;
    DWORD dwType = REG_DWORD;
    DWORD dwLength = sizeof(DWORD);

    // Defaults
    LoadString( NULL, IDS_DEFAULTTEXT, m_szDisplayString, MAX_DISPLAY_STRING );
    m_Font.lfHeight = 96;
    m_Font.lfWidth = 0;
    m_Font.lfEscapement = 0;
    m_Font.lfOrientation = 0;
    m_Font.lfWeight = 0;
    m_Font.lfItalic = 0;
    m_Font.lfUnderline = 0;
    m_Font.lfStrikeOut = 0;
    m_Font.lfCharSet = DEFAULT_CHARSET;
    m_Font.lfOutPrecision = OUT_DEFAULT_PRECIS;
    m_Font.lfClipPrecision = OUT_DEFAULT_PRECIS;
    m_Font.lfQuality = DEFAULT_QUALITY;
    m_Font.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
    LoadString( NULL, IDS_FONT, m_Font.lfFaceName, LF_FACESIZE ); 
    m_bDisplayTime = FALSE;
    m_dwMeshQuality = 500;
    m_SurfType = SurfType(environment);
    m_bSpecular = TRUE;
    m_dwRotationSpeed = 10;
    m_dwSize = 10;
    m_RotType = RotType(spin);
    m_SurfaceColor = 0x00777777;
    m_bUseCustomColor = FALSE;
    m_bUseCustomTexture = FALSE;
    m_bUseCustomEnvironment = FALSE;
    lstrcpy( m_szCustomTexture, TEXT("") );
    lstrcpy( m_szCustomEnvironment, TEXT("") );

    // Read OpenGL settings first, so OS upgrade cases work
    ss_ReadSettings();

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        dwLength = (MAX_DISPLAY_STRING + 1) * sizeof(TCHAR);
        RegQueryValueEx( hkey, TEXT("DisplayString"), NULL, &dwType, (BYTE*)m_szDisplayString, &dwLength );

        dwLength = sizeof(DWORD);
        RegQueryValueEx( hkey, TEXT("FontHeight"), NULL, &dwType, (BYTE*)&m_Font.lfHeight, &dwLength );

        RegQueryValueEx( hkey, TEXT("FontWeight"), NULL, &dwType, (BYTE*)&m_Font.lfWeight, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("FontItalic"), NULL, &dwType, (BYTE*)&m_Font.lfItalic, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("FontCharSet"), NULL, &dwType, (BYTE*)&m_Font.lfCharSet, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("FontPitchFamily"), NULL, &dwType, (BYTE*)&m_Font.lfPitchAndFamily, &dwLength );

        dwLength = sizeof(m_Font.lfFaceName);
        RegQueryValueEx( hkey, TEXT("FontFace"), NULL, &dwType, (BYTE*)m_Font.lfFaceName, &dwLength );

        dwLength = sizeof(DWORD);
        RegQueryValueEx( hkey, TEXT("DisplayTime"), NULL, &dwType, (BYTE*)&m_bDisplayTime, &dwLength );

        RegQueryValueEx( hkey, TEXT("MeshQuality"), NULL, &dwType, (BYTE*)&m_dwMeshQuality, &dwLength );
        if ( m_dwMeshQuality > 1000 )
            m_dwMeshQuality = 1000;

        RegQueryValueEx( hkey, TEXT("SurfaceType"), NULL, &dwType, (BYTE*)&m_SurfType, &dwLength );

        RegQueryValueEx( hkey, TEXT("Specular"), NULL, &dwType, (BYTE*)&m_bSpecular, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("RotationSpeed"), NULL, &dwType, (BYTE*)&m_dwRotationSpeed, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("Size"), NULL, &dwType, (BYTE*)&m_dwSize, &dwLength );
        if( m_dwSize < 1 )
            m_dwSize = 1;
        if( m_dwSize > 10 )
            m_dwSize = 10;
        
        RegQueryValueEx( hkey, TEXT("RotationStyle"), NULL, &dwType, (BYTE*)&m_RotType, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("SurfaceColor"), NULL, &dwType, (BYTE*)&m_SurfaceColor, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("UseCustomColor"), NULL, &dwType, (BYTE*)&m_bUseCustomColor, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("UseCustomTexture"), NULL, &dwType, (BYTE*)&m_bUseCustomTexture, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("UseCustomEnvironment"), NULL, &dwType, (BYTE*)&m_bUseCustomEnvironment, &dwLength );
        
        dwLength = sizeof(m_szCustomTexture);
        RegQueryValueEx( hkey, TEXT("CustomTexture"), NULL, &dwType, (BYTE*)m_szCustomTexture, &dwLength );
        
        dwLength = sizeof(m_szCustomEnvironment);
        RegQueryValueEx( hkey, TEXT("CustomEnvironment"), NULL, &dwType, (BYTE*)m_szCustomEnvironment, &dwLength );

        ReadScreenSettings( hkey );

        RegCloseKey( hkey );
    }
}




//-----------------------------------------------------------------------------
// Name: ss_ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CTextScreensaver::ss_ReadSettings()
{
    int    options;
    int    optMask = 1;

    // Get registry settings
    if( ss_RegistrySetup( IDS_SAVERNAME, IDS_INIFILE ) )
    {
        // get demo type
        int demoType = ss_GetRegistryInt( IDS_DEMOTYPE, 0 );
        if( demoType == 1 )
        {
            m_bDisplayTime = TRUE;
        }

        // get rotation style
        m_RotType = (RotType) (ss_GetRegistryInt( IDS_ROTSTYLE, 0 ) + 1); // add 1
        if( m_RotType == 1 ) // 1==none,2=right,3=right,4=random->spin
            m_RotType = none;
        if( m_RotType > 3 )  
            m_RotType = spin;

        // get tesselation
        m_dwMeshQuality = ss_GetRegistryInt( IDS_TESSELATION, 0 ); // 0-100
        m_dwMeshQuality = m_dwMeshQuality*10 + 1; // 1-1000
        if ( m_dwMeshQuality > 1000 )
            m_dwMeshQuality = 1000;

        // get size 
        m_dwSize = ss_GetRegistryInt( IDS_SIZE, 0 ); // 0-100
        m_dwSize = (unsigned) ( ((m_dwSize / 100.0f) * 90.0f + 10.0f) / 10.0f ); // 1-10

        // get speed
        m_dwRotationSpeed = ss_GetRegistryInt( IDS_SPEED, 0 ); // 0-100
        m_dwRotationSpeed = (unsigned) ( ((m_dwRotationSpeed / 100.0f) * 190.0f + 10.0f) / 10.0f ); // 1-20

        // get font, attributes, and charset
        ss_GetRegistryString( IDS_FONT_REG, TEXT(""),
                              m_Font.lfFaceName, LF_FACESIZE );

        options = ss_GetRegistryInt( IDS_FONT_ATTRIBUTES, 0 );
        if( options >= 0 ) 
        {
            optMask = 1;
            m_Font.lfWeight = ((options & optMask) != 0) ? FW_BOLD : FW_NORMAL;
            optMask <<=1;
            m_Font.lfItalic = ((options & optMask) != 0) ? (BYTE) 1 : 0;
        }

        m_Font.lfCharSet = (BYTE)ss_GetRegistryInt( IDS_CHARSET, 0 );

        // get display string
        ss_GetRegistryString( IDS_TEXT, TEXT(""), m_szDisplayString, MAX_DISPLAY_STRING );

        m_SurfType = (SurfType) ss_GetRegistryInt( IDS_SURFSTYLE, color );
        if( m_SurfType >= 1 )
            m_SurfType = texture;

        // Is there a texture specified in the registry that overrides the default?
        ss_GetRegistryString( IDS_TEXTURE, NULL, m_szCustomTexture, MAX_PATH );
        if( lstrlen( m_szCustomTexture ) > 0 )
        {
            m_bUseCustomTexture = TRUE;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CTextScreensaver::ss_RegistrySetup( int section, int file )
{
    if( LoadString(m_hInstance, section, g_szSectName, BUF_SIZE) &&
        LoadString(m_hInstance, file, g_szFname, BUF_SIZE) ) 
    {
        TCHAR pBuffer[100];
        DWORD dwRealSize = GetPrivateProfileSection( g_szSectName, pBuffer, 100, g_szFname );
        if( dwRealSize > 0 )
            return TRUE;
    }
    
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryInt()
// Desc: 
//-----------------------------------------------------------------------------
int CTextScreensaver::ss_GetRegistryInt( int name, int iDefault )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        return GetPrivateProfileInt(g_szSectName, szItemName, iDefault, g_szFname);

    return 0;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
VOID CTextScreensaver::ss_GetRegistryString( int name, LPTSTR lpDefault, 
                                                         LPTSTR lpDest, int bufSize )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        GetPrivateProfileString(g_szSectName, szItemName, lpDefault, lpDest,
                                bufSize, g_szFname);

    return;
}




//-----------------------------------------------------------------------------
// Name: DoConfig()
// Desc: 
//-----------------------------------------------------------------------------
VOID CTextScreensaver::DoConfig()
{
    ReadSettings();
    DialogBox( NULL, MAKEINTRESOURCE( IDD_SETTINGS ),
               m_hWndParent, (DLGPROC)SettingsDialogProcStub );
}




BOOL WINAPI CTextScreensaver::SettingsDialogProcStub( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{ 
    return g_pMyTextScreensaver->SettingsDialogProc( hDlg, message, wParam, lParam ); 
};




BOOL CTextScreensaver::SettingsDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch ( message )
    {
        case WM_INITDIALOG:
            InitItems( hDlg );
            return FALSE;

        case WM_COMMAND:
            switch ( HIWORD(wParam) )
            {
                case BN_CLICKED:
                {
                    switch( LOWORD(wParam) )
                    {
                        case IDOK:
                            ExtractAndWriteSettings( hDlg );
                            EndDialog( hDlg, TRUE );
                            break;

                        case IDCANCEL:
                            ReadSettings();
                            EndDialog( hDlg, FALSE );
                            break;

                        case IDC_SELECT_FONT:
                            SelectFont( hDlg );
                            break;

                        case IDC_RADIO_TIME:
                            EnableWindow( GetDlgItem( hDlg , IDC_DISPLAY_STRING ) , FALSE );
                            break;

                        case IDC_RADIO_TEXT:
                            EnableWindow( GetDlgItem( hDlg , IDC_DISPLAY_STRING ) , TRUE );
                            break;

                        case IDC_RADIO_COLOR:
                        case IDC_RADIO_TEXTURE:
                        case IDC_RADIO_REFLECTION:
                        case IDC_USE_CUSTOM_COLOR:
                        case IDC_USE_CUSTOM_TEXTURE:
                        case IDC_USE_CUSTOM_ENVIRONMENT:
                        {
                            if( IsDlgButtonChecked( hDlg, IDC_RADIO_COLOR ) )
                                m_SurfType = color;
                            else if( IsDlgButtonChecked( hDlg, IDC_RADIO_TEXTURE ) )
                                m_SurfType = texture;
                            else if( IsDlgButtonChecked( hDlg, IDC_RADIO_REFLECTION ) )
                                m_SurfType = environment;
                            EnableTextureWindows( hDlg , SurfType(m_SurfType) );
                        }
                        break;

                        case IDC_SURFACE_COLOR:
                            SelectSurfaceColor( hDlg );
                            break;

                        case IDC_BROWSE_TEXTURE:
                            SelectCustomTexture( hDlg );
                            break;

                        case IDC_BROWSE_ENVIRONMENT:
                            SelectCustomEnvironment( hDlg );
                            break;

                        case IDC_SCREENSETTINGS:
                            DoScreenSettingsDialog( hDlg );
                            break;
                    }
                }
                break;

                case EN_CHANGE:
                    if ( LOWORD(wParam) == IDC_DISPLAY_STRING )
                    {
                        GetDlgItemText( hDlg , IDC_DISPLAY_STRING , m_szDisplayString , MAX_DISPLAY_STRING );
                    }
                    break;
            }
            return FALSE;
    }

    return FALSE;
}




VOID CTextScreensaver::InitItems( HWND hDlg )
{
    TCHAR sz[100];

    // Set the limit of the text box
    SendDlgItemMessage( hDlg, IDC_DISPLAY_STRING, EM_SETLIMITTEXT, MAX_DISPLAY_STRING, 0 );

    // Set the text string
    SetDlgItemText( hDlg, IDC_DISPLAY_STRING, m_szDisplayString );

    // Set the radio button for time/text display
    if ( m_bDisplayTime )
    {
        EnableWindow( GetDlgItem( hDlg, IDC_DISPLAY_STRING ), FALSE );
        CheckRadioButton( hDlg, IDC_RADIO_TIME, IDC_RADIO_TEXT, IDC_RADIO_TIME );
    }
    else
    {
        EnableWindow( GetDlgItem( hDlg, IDC_DISPLAY_STRING ), TRUE );
        CheckRadioButton( hDlg, IDC_RADIO_TIME, IDC_RADIO_TEXT, IDC_RADIO_TEXT );
    }

    switch( m_SurfType )
    {
    case color:
        CheckRadioButton( hDlg, IDC_RADIO_COLOR, IDC_RADIO_REFLECTION, IDC_RADIO_COLOR );
        break;
    case texture:
        CheckRadioButton( hDlg, IDC_RADIO_COLOR, IDC_RADIO_REFLECTION, IDC_RADIO_TEXTURE );
        break;
    case environment:
        CheckRadioButton( hDlg, IDC_RADIO_COLOR, IDC_RADIO_REFLECTION, IDC_RADIO_REFLECTION );
        break;
    }

    // Check/uncheck the specular box
    SendDlgItemMessage( hDlg, IDC_SPECULAR, BM_SETCHECK,
                        m_bSpecular ? BST_CHECKED : BST_UNCHECKED, 0 );

    // Enable/disable surface color button
    EnableWindow( GetDlgItem( hDlg, IDC_SURFACE_COLOR ), m_SurfType == color );

    // Check/uncheck the custom texture boxes
    SendDlgItemMessage( hDlg, IDC_USE_CUSTOM_COLOR, BM_SETCHECK,
                        m_bUseCustomColor ? BST_CHECKED : BST_UNCHECKED, 0 );
    SendDlgItemMessage( hDlg, IDC_USE_CUSTOM_TEXTURE, BM_SETCHECK,
                        m_bUseCustomTexture ? BST_CHECKED : BST_UNCHECKED, 0 );
    SendDlgItemMessage( hDlg, IDC_USE_CUSTOM_ENVIRONMENT, BM_SETCHECK,
                        m_bUseCustomEnvironment ? BST_CHECKED : BST_UNCHECKED, 0 );

    // Enable all the texture windows as appropriate
    EnableTextureWindows( hDlg, m_SurfType );

    // Fill the rotation style combo box
    LoadString( NULL, IDS_NONE, sz, 100 );
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_ADDSTRING, 0, (LPARAM) sz );
    LoadString( NULL, IDS_SPIN, sz, 100 );
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_ADDSTRING, 0, (LPARAM) sz );
    LoadString( NULL, IDS_SEESAW, sz, 100 );
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_ADDSTRING, 0, (LPARAM) sz );
    LoadString( NULL, IDS_WOBBLE, sz, 100 );
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_ADDSTRING, 0, (LPARAM) sz );
    LoadString( NULL, IDS_TUMBLE, sz, 100 );
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_ADDSTRING, 0, (LPARAM) sz );

    // Set the current rotation style selection
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_SETCURSEL, m_RotType, 0 );

    // Set up the rotation speed slider
    SendDlgItemMessage( hDlg, IDC_ROTATION_SPEED, TBM_SETRANGE, TRUE, MAKELONG(1,20) );
    SendDlgItemMessage( hDlg, IDC_ROTATION_SPEED, TBM_SETPOS, TRUE, m_dwRotationSpeed );

    // Set up the resolution slider
    SendDlgItemMessage( hDlg, IDC_RESOLUTION, TBM_SETRANGE, TRUE, MAKELONG(1,10) );
    SendDlgItemMessage( hDlg, IDC_RESOLUTION, TBM_SETPOS, TRUE, m_dwMeshQuality / 100 );

    // Set up the size slider
    SendDlgItemMessage( hDlg, IDC_VIEWPORTSIZE, TBM_SETRANGE, TRUE, MAKELONG(1,10) );
    SendDlgItemMessage( hDlg, IDC_VIEWPORTSIZE, TBM_SETPOS, TRUE, m_dwSize );
}



  
VOID CTextScreensaver::ExtractAndWriteSettings( HWND hDlg )
{
    LRESULT ret;
    HKEY hkey = NULL;

    m_bSpecular = IsDlgButtonChecked( hDlg, IDC_SPECULAR );

    m_bUseCustomColor = IsDlgButtonChecked( hDlg, IDC_USE_CUSTOM_COLOR );
    m_bUseCustomTexture = IsDlgButtonChecked( hDlg, IDC_USE_CUSTOM_TEXTURE );
    m_bUseCustomEnvironment = IsDlgButtonChecked( hDlg, IDC_USE_CUSTOM_ENVIRONMENT );

    if ( (ret = SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_GETCURSEL, 0, 0 )) != CB_ERR )
        m_RotType = RotType(ret);

    m_dwSize = (DWORD)SendDlgItemMessage( hDlg, IDC_VIEWPORTSIZE, TBM_GETPOS, 0, 0 );
    m_dwRotationSpeed = (DWORD)SendDlgItemMessage( hDlg, IDC_ROTATION_SPEED, TBM_GETPOS, 0, 0 );
    m_dwMeshQuality = 100 * (DWORD)SendDlgItemMessage( hDlg, IDC_RESOLUTION, TBM_GETPOS, 0, 0 );

    GetDlgItemText( hDlg, IDC_DISPLAY_STRING, m_szDisplayString, MAX_DISPLAY_STRING + 1 );

    if ( IsDlgButtonChecked( hDlg, IDC_RADIO_TIME ) )
        m_bDisplayTime = TRUE;
    else
        m_bDisplayTime = FALSE;

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        WriteScreenSettings( hkey );
        RegSetValueEx( hkey, TEXT("SurfaceType"), NULL, REG_DWORD, (BYTE*)&m_SurfType, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("Specular"), NULL, REG_DWORD, (BYTE*)&m_bSpecular, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("SurfaceColor"), NULL, REG_DWORD, (BYTE*)&m_SurfaceColor, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("CustomTexture"), NULL, REG_SZ, (BYTE*)&m_szCustomTexture, (lstrlen(m_szCustomTexture) + 1) * sizeof(TCHAR) );
        RegSetValueEx( hkey, TEXT("CustomEnvironment"), NULL, REG_SZ, (BYTE*)&m_szCustomEnvironment, (lstrlen(m_szCustomEnvironment) + 1) * sizeof(TCHAR) );
        RegSetValueEx( hkey, TEXT("UseCustomColor"), NULL, REG_DWORD, (BYTE*)&m_bUseCustomColor, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("UseCustomTexture"), NULL, REG_DWORD, (BYTE*)&m_bUseCustomTexture, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("UseCustomEnvironment"), NULL, REG_DWORD, (BYTE*)&m_bUseCustomEnvironment, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("MeshQuality"), NULL, REG_DWORD, (BYTE*)&m_dwMeshQuality, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("Size"), NULL, REG_DWORD, (BYTE*)&m_dwSize, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("RotationSpeed"), NULL, REG_DWORD, (BYTE*)&m_dwRotationSpeed, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("RotationStyle"), NULL, REG_DWORD, (BYTE*)&m_RotType, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("DisplayString"), NULL, REG_SZ, (BYTE*)&m_szDisplayString, (lstrlen(m_szDisplayString) + 1) * sizeof(TCHAR) );
        RegSetValueEx( hkey, TEXT("DisplayTime"), NULL, REG_DWORD, (BYTE*)&m_bDisplayTime, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontWeight"), NULL, REG_DWORD, (BYTE*)&m_Font.lfWeight, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontHeight"), NULL, REG_DWORD, (BYTE*)&m_Font.lfHeight, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontItalic"), NULL, REG_DWORD, (BYTE*)&m_Font.lfItalic, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontCharSet"), NULL, REG_DWORD, (BYTE*)&m_Font.lfCharSet, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontPitchFamily"), NULL, REG_DWORD, (BYTE*)&m_Font.lfPitchAndFamily, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontFace"), NULL, REG_SZ, (BYTE*)&m_Font.lfFaceName, (lstrlen(m_Font.lfFaceName) + 1) * sizeof(TCHAR) );
        RegCloseKey( hkey );
    }
}




//***************************************************************************************
VOID CTextScreensaver::SelectSurfaceColor( HWND hDlg )
{
    static COLORREF cust_colors[16];

    CHOOSECOLOR choose;
    choose.lStructSize = sizeof(choose);
    choose.hwndOwner = hDlg;
    choose.hInstance = HWND(m_hInstance);
    choose.rgbResult = m_SurfaceColor;
    choose.lpCustColors = cust_colors;
    choose.Flags = CC_ANYCOLOR|CC_FULLOPEN|CC_RGBINIT;
    choose.lCustData = 0;
    choose.lpfnHook = NULL;
    choose.lpTemplateName = NULL;

    if ( ChooseColor( &choose ) )
        m_SurfaceColor = choose.rgbResult;
}




//***************************************************************************************
VOID CTextScreensaver::SelectFont( HWND hDlg )
{
    CHOOSEFONT  choose;

    choose.lStructSize = sizeof(choose);
    choose.hwndOwner = hDlg;
    choose.hDC;
    choose.iPointSize = 720;
    choose.lpLogFont = &m_Font;
    choose.Flags = CF_TTONLY|CF_FORCEFONTEXIST|CF_NOVERTFONTS|CF_SCREENFONTS|CF_INITTOLOGFONTSTRUCT|CF_ENABLETEMPLATE;
    choose.lpTemplateName = MAKEINTRESOURCE(DLG_SELECT_FONT);
    choose.hInstance = m_hInstance;

    if ( ChooseFont( &choose ) )
        m_Font = *choose.lpLogFont;
}




//***************************************************************************************
VOID CTextScreensaver::SelectCustomTexture( HWND hDlg )
{
    TCHAR    fn[MAX_PATH] = TEXT("\0");
    TCHAR    strTitle[100];
    LoadString( NULL, IDS_OPENTEXTURETITLE, strTitle, 100 );

    lstrcpy( fn, m_szCustomTexture );

    TCHAR    filter[200];
    LoadString( NULL, IDS_FILEFILTER, filter, 200); 
    for( TCHAR* pch = filter; *pch != TEXT('\0'); pch++ )
    {
        if( *pch == TEXT('#') )
            *pch = TEXT('\0');
    }

    TCHAR szWindowsDir[MAX_PATH];
    szWindowsDir[0] = TEXT('\0');
    GetWindowsDirectory( szWindowsDir, MAX_PATH );

    OPENFILENAME    ofn;
    memset( &ofn , 0 , sizeof(ofn) );
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = m_hInstance;
    ofn.lpstrFilter = filter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = fn;
    ofn.nMaxFile = sizeof(fn);
    ofn.lpstrTitle = strTitle;
    ofn.Flags = OFN_ENABLESIZING|OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = TEXT("mid");
    if( lstrlen( fn ) == 0 )
        ofn.lpstrInitialDir = szWindowsDir;

    if ( GetOpenFileName( &ofn ) )
        lstrcpy( m_szCustomTexture , ofn.lpstrFile );
}




//***************************************************************************************
VOID CTextScreensaver::SelectCustomEnvironment( HWND hDlg )
{
    TCHAR    fn[MAX_PATH] = TEXT("\0");
    TCHAR    strTitle[100];
    LoadString( NULL, IDS_OPENENVIRONMENTMAPTITLE, strTitle, 100 );

    TCHAR    filter[200];
    LoadString( NULL, IDS_FILEFILTER, filter, 200); 
    for( TCHAR* pch = filter; *pch != TEXT('\0'); pch++ )
    {
        if( *pch == TEXT('#') )
            *pch = TEXT('\0');
    }

    TCHAR szWindowsDir[MAX_PATH];
    szWindowsDir[0] = TEXT('\0');
    GetWindowsDirectory( szWindowsDir, MAX_PATH );

    OPENFILENAME    ofn;
    memset( &ofn , 0 , sizeof(ofn) );
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = m_hInstance;
    ofn.lpstrFilter = filter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = fn;
    ofn.nMaxFile = sizeof(fn);
    ofn.lpstrTitle = strTitle;
    ofn.Flags = OFN_ENABLESIZING|OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = TEXT("mid");
    if( lstrlen( fn ) == 0 )
        ofn.lpstrInitialDir = szWindowsDir;

    if ( GetOpenFileName( &ofn ) )
        lstrcpy( m_szCustomEnvironment , ofn.lpstrFile );
}




//***************************************************************************************
VOID CTextScreensaver::EnableTextureWindows( HWND hDlg , SurfType sel )
{
    HWND    use_color = GetDlgItem( hDlg , IDC_USE_CUSTOM_COLOR );
    HWND    use_texture = GetDlgItem( hDlg , IDC_USE_CUSTOM_TEXTURE );
    HWND    use_environ = GetDlgItem( hDlg , IDC_USE_CUSTOM_ENVIRONMENT );
    HWND    browse_color = GetDlgItem( hDlg , IDC_SURFACE_COLOR );
    HWND    browse_texture = GetDlgItem( hDlg , IDC_BROWSE_TEXTURE );
    HWND    browse_environ = GetDlgItem( hDlg , IDC_BROWSE_ENVIRONMENT );

    BOOL    color_checked = IsDlgButtonChecked( hDlg , IDC_USE_CUSTOM_COLOR );
    BOOL    texture_checked = IsDlgButtonChecked( hDlg , IDC_USE_CUSTOM_TEXTURE );
    BOOL    environment_checked = IsDlgButtonChecked( hDlg , IDC_USE_CUSTOM_ENVIRONMENT );

    switch ( sel )
    {
        case environment:
            EnableWindow( use_color , FALSE );
            EnableWindow( use_texture , FALSE );
            EnableWindow( use_environ , TRUE );
            EnableWindow( browse_color , FALSE );
            EnableWindow( browse_texture , FALSE );
            EnableWindow( browse_environ , environment_checked );
            break;

        case texture:
            EnableWindow( use_color , FALSE );
            EnableWindow( use_texture , TRUE );
            EnableWindow( use_environ , FALSE );
            EnableWindow( browse_color , FALSE );
            EnableWindow( browse_texture , texture_checked );
            EnableWindow( browse_environ , FALSE );
            break;

        case color:
        default:
            EnableWindow( use_color , TRUE );
            EnableWindow( use_texture , FALSE );
            EnableWindow( use_environ , FALSE );
            EnableWindow( browse_color , color_checked );
            EnableWindow( browse_texture , FALSE );
            EnableWindow( browse_environ , FALSE );
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\sound\snd.h ===
/*
**  SND.H
**
**  Example header to create a DLL to control applet(s) to be
**  displayed by the Multimedia Control Panel.
**
**  History:
**
**      Fri Apr 27 1990 -by- ToddLa
**          Created.
*/

/*---------------------------------------------------------------------------*/

#include <multimed.h>

#define DLG_SOUND       42
#define DLG_CHANGED     45

#define ID_DIR          100
#define LB_NAMES        101
#define LB_FILES        102
#define ID_VOLUME       103
#define ID_PLAY         104
#define ID_EDIT         105
#define ID_BEEP         106
#define ID_CHANGED      108

#define ICON_EXCLAIM        32515

#define IDS_UNABLETITLE     3
#define IDS_UNABLEMESSAGE   4
#define IDS_WARNINGTITLE    5
#define IDS_WARNINGMESSAGE  6
#define IDS_NONE            7
#define IDS_APPNAME         8
#define IDS_NODEVICE        9
#define IDS_HELPFILE    IDS_CONTROL_HLP
#define IDS_WRITEERR        11

/*---------------------------------------------------------------------------*/

#define CODE                                     //_based(_segname("_CODE"))
typedef char    CODE SZCODE;

/*---------------------------------------------------------------------------*/

extern  char aszSoundHlp[];
extern  char aszErrorPlayTitle[];
extern  char aszErrorPlayMessage[];
extern  char aszWarningTitle[];
extern  char aszWarningMessage[];
extern  char aszNoSound[];
extern  char aszNoDevice[];
extern  char aszWriteErr[];
extern  char aszAppName[];
extern  HINSTANCE hInstance;
extern  DWORD dwContext;
extern  UINT uHelpMessage;

/*---------------------------------------------------------------------------*/

INT_PTR SoundDlg( HWND   hwnd
             , UINT   wMsg
             , WPARAM wParam
             , LPARAM lParam
             );
/*---------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\sound\snd.c ===
/*
** SND.C
**
** Sound applet for the NT Control Panel.
**
*/
/* Revision history:
 * Laurie Griffiths 19/12/91  Ported the windows 3.1 code to NT
 */

/*=============================================================================
| The whole thing is kicked off by Init.c
| When the DLL is loaded DllInitialize in init.c is called (as a result of
| the DLLENTRY line in SOURCES).  This just loads some static strings
| with values dug out of resources.
|
| The control panel then calls CPlApplet in init.c with a series of
| messages which are explained in control\h\cpl.h
|
| The CPL_INQUIRE message is different in 3.1 (CPL_NEWINQUIRE).
|
| The big one is CPL_DBLCLK which is the go signal.
| A dialog box is created in RunApplet in init.c with window procedure
| SoundDlg (end of this file).
|
| WM_INITDIALOG is the trigger to fill the list boxes with text which is
| taken from the INI file (InitDialog).  If there is no wave device present
| then it just allows the user to set the message beep flag (displays
| original state and allows alteration).  If there is a wave device then
| the Test button is enabled.  Whether or not there is a device to play the
| files, you can still assign them to events.  This could be useful
| to someone installing the system.  There's no real reason why they should
| be forced to configure the sound board first.
|
| Currently it does a message box to say that there's no sound board.
| Is this too intrusive?
|
| The calling tree looks like:
|
| DllInitialize  loads resources
|
| CPlApplet             main entry point from control panel (in init.c)
|     RunApplet             brings up dialog box (in init.c)
|         DialogBox
|             SoundDlg              dialog procedure
|                 InitDialog
|                     FindDescription        find description in <name=file,descr> string
|                     ShowSound              show filename associated with a sound
|                     NewSound               update list box with new <name,file,descr>
|                     catPath                concatenate path onto file
|                 DrawItem               draw item in list box
|                     DrawItemText           draw text of item
|                         GetSoundEntry          interrogate list box
|                 ControlMessage         process messages from controls in dialogs
|                     EnablePlay             enable/disable the TEST button
|                     FillDirBox             fill list box from files in current dir
|                     ShowSound              show filename associated with a sound
|                     PlayTheSound           play the i-th sound entry
|                         GetSoundEntry          interrogate list box
|                     WriteSounds            write out a new [sounds] section
|                    ChangeSound            change the filename associated with a sound
|                         QualifyFileName        get full path name of file
|                         NewSound               update list box with new <name,file,descr>
|                         GetSoundEntry          interrogate list box
|
| The following are called from several places in the above
|
| GetSoundEntry
|     FindDescription        find description in <name=file,descr> string
|
| EnablePlay            enable/disable the TEST button
|     GetSoundEntry         interrogate list box
|
| ShowSound             show filename associated with a sound
|     GetSoundEntry         interrogate list box
|     QualifyFileName       get full path name of file
|     FileName              extract file name from full path name
|     StripPathName         split path into path and file by inserting null
|         FileName              extract file name from full path name
|     FillDirBox            fill list box from files in current dir
|     EnablePlay            enable/disable the TEST button
 ============================================================================*/

#include <windows.h>
#include <mmsystem.h>
#include <port1632.h>
#include <cphelp.h>

#include <cpl.h>
#include <shellapi.h>
#include "snd.h"

#define     SetWindowRedraw(hwnd, fRedraw)  \
            ((VOID)SendMessage(hwnd, WM_SETREDRAW, (UINT)(BOOL)(fRedraw), 0L))


/*---------------------------------------------------------------------------*/

#define STRSIZ  MAX_PATH    // maximum size of a string or filename
#define MAXINI  4096       // max size of all ini keys in [sounds] section
#define SLASH(c)        ((c) == '/' || (c) == '\\')

/*
**  DLGOPEN private definitions
**/

#define ATTRFILELIST    0x0000  // include files only
#define ATTRDIRLIST     0xC010  // directories and drives ONLY

/*---------------------------------------------------------------------------*/

static SZCODE aszNull[] = "";
static SZCODE aszDirSeparator[] = "\\";
static SZCODE aszResourceDir[]= "resource";
static SZCODE aszSounds[] = "sounds";
static SZCODE aszNewSoundFindFormat[] = "%s=";
static SZCODE aszNewSoundFormat[] = "%s=%s,%s";
static SZCODE aszCurrentDir[] = ".";
static SZCODE aszFileFilter[] = "*.wav";
static char   aszAllFiles[] = "*.*";    // this is written on by DlgDirList()
static BOOL   fSndPlaySound;            // sound board working
static BOOL   fIniChanged;
static BOOL   fEnabled= FALSE;          // True iff [Sounds] Enabled=1 in Win.ini

#if PARANOIA
/*---------------------------------------------------------------------------
| put <title><str>"\n" out onto debug screen
 ----------------------------------------------------------------------------*/
void Trace(LPSTR lpstr, LPSTR lpstrTitle)
{  char msg[255];
   if (!lpstr) lpstr = "";
   if (!lpstrTitle) lpstrTitle = "SOUND: SND.C";
   wsprintf(msg, "%s %s\n", lpstrTitle, lpstr);
   OutputDebugString(msg);
} /* Trace */
#endif

/*---------------------------------------------------------------------------
| ?
 ----------------------------------------------------------------------------*/
static VOID PASCAL NEAR CPHelp( HWND hwnd, DWORD dContext)
{  WinHelp(hwnd, aszSoundHlp, HELP_CONTEXT, dContext);
} /* CPHelp */

/*---------------------------------------------------------------------------
| lszEntry points to a string from WIN.INI
| split it at the start of the description by inserting 0 and return
| pointer to the description
|
| CASE1 (nice -- delimiter present )
|       input string :  text<delim>text
|       return ptr   :             ^
|       output string:  text0      text
|    where <delim> ::= ","[{<tab>|<space>|","}...]
|           0 represents the end-of-string delimiter
|
| CASE2 (nasty -- no delimiter present )
|       input string :  text0
|       return ptr   :      ^
|       output string:  text0
| (Since Fangled And Tangled file systems allow spaces in names, the delimiter
| rules were changed from DOS require the delimiter to start with comma).
 ----------------------------------------------------------------------------*/
static LPSTR FindDescription( LPSTR lszEntry)
{
   /* skip to next end-of-string or comma (space or tab no longer count) */
   for (
       ; *lszEntry && *lszEntry!=','
       ; lszEntry++
       )
   ;

   if (*lszEntry)
   {  BOOL fComma;

      fComma = (*lszEntry == ',');
      *lszEntry = (char)0;
      /* skip the inserted null and any following blanks and tabs */
      for (lszEntry++; *lszEntry == ' ' || *lszEntry == '\t'; lszEntry++)
      ;
      /* if now found a comma and hadn't before, skip tabs and spaces again */
      if (!fComma && (*lszEntry == ','))
      {  for (lszEntry++; *lszEntry == ' ' || *lszEntry == '\t'; lszEntry++)
         ;
      }
   }
   return lszEntry;
} /* FindDescription */

/*---------------------------------------------------------------------------
| Get (Event, File, Description) from the iListEntry-th entry in the NAMES list box
| iListEntry==-1 means use the current selection
| Supplying NULL for any of these PLPSTRs is safe and means don't bother
| to return this item.
 ----------------------------------------------------------------------------*/
static VOID NEAR GetSoundEntry( HWND    hwnd           /* dialog box */
                              , int iListEntry         /* number of event */
                              , LPSTR lszEvent         /* event name returned */
                              , LPSTR lszFile          /* file name returned */
                              , LPSTR lszDescription   /* description returned */
                              )
{  char aszBuffer[STRSIZ];
   LPSTR lszCur;
   LPSTR lszStart;

   /* aszBuffer = text of iListEntry-th entry in list box, -1 => use current */
   hwnd = GetDlgItem(hwnd, LB_NAMES);
   if (iListEntry == -1)
      iListEntry = (int)(LONG)
                      SendMessage(hwnd, LB_GETCURSEL, (WPARAM)0, (LPARAM)0);
   lstrcpy(aszBuffer, (PSTR)SendMessage(hwnd, LB_GETITEMDATA, (WPARAM)iListEntry, (LPARAM)0));

   /* replace "=" in aszBuffer with NULL (there'd better be one there!) */
   for (lszCur = aszBuffer; *lszCur != '='; lszCur++)
   ;
   *lszCur = (char)0;

   /* lszEvent = <Event> from list entry */
   if (lszEvent)
   {  lstrcpy(lszEvent, aszBuffer);
   }

   lszStart = ++lszCur;
   lszCur = FindDescription(lszCur);
   if (lszFile)
   {  if (!lstrcmpi(lszStart, aszNoSound))
          *lszFile = (char)0;
      else
         lstrcpy(lszFile, lszStart);
   }
   if (lszDescription)
   {  if (!*lszCur)
         lszCur = aszBuffer;
      lstrcpy(lszDescription, lszCur);
   }
}/* GetSoundEntry */


/*---------------------------------------------------------------------------
| get full path name of file.  Return TRUE iff it worked.
| updates lszFile, assumes there is enough room.
 ----------------------------------------------------------------------------*/
static BOOL NEAR PASCAL QualifyFileName( LPSTR  lszFile )
{  OFSTRUCT of;
   UINT     fErrMode;
   BOOL     fReturn;

   fErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);  /* return errors to us */
   if ( OpenFile( lszFile
                , &of
                , OF_EXIST | OF_SHARE_DENY_NONE | OF_READ
                )
      != HFILE_ERROR
      )
   {  OemToAnsi(of.szPathName, lszFile);
      fReturn = TRUE;
   } else
      fReturn = FALSE;
   SetErrorMode(fErrMode);
   return fReturn;
}/* QualifyFileName */

/*---------------------------------------------------------------------------
| update lszPath to point to file-name at end of path-and-file-name
 ----------------------------------------------------------------------------*/
static LPSTR NEAR PASCAL FileName( LPCSTR lszPath)
{  LPCSTR lszCur;
   /* move forward to first null */
   for (lszCur = lszPath; *lszCur; lszCur++)
   ;
   /* move backwards until find SLASH or colon */
   for (; lszCur >= lszPath && !SLASH(*lszCur) && *lszCur != ':'; lszCur--)
   ;
   /* move forwards one char */
   return (LPSTR)++lszCur;
}/* FileName */

/*---------------------------------------------------------------------------
| update lszPath to insert a null at end of path (possibly hitting the "\"
| possibly hitting the start of the file name)
 ----------------------------------------------------------------------------*/
static VOID NEAR PASCAL StripPathName( LPSTR lszPath)
{  LPSTR lszCur;
   /* move on to first char of filename at end of path */
   lszCur = FileName(lszPath);
   /* if path at least two chars long and ends in \ and not in :\
   |  then move back one char
   */
   if (lszCur > lszPath+1 && SLASH(lszCur[-1]) && lszCur[-2] != ':')
      lszCur--;
   /* insert null */
   *lszCur = (char)0;
}/* StripPathName */

/*---------------------------------------------------------------------------
| show the filenames that can be associated with sounds
 ----------------------------------------------------------------------------*/
static VOID NEAR FillDirBox( HWND hwnd
                           , LPSTR lszDir  // the path
                           )
{  char aszCWD[STRSIZ];
   char aszNewCWD[STRSIZ];
   int iDirLen;
   UINT fErrMode;

   // remove any trailing '/'
   iDirLen = lstrlen(lszDir) - 1;
   if (SLASH(lszDir[iDirLen]) && lszDir[iDirLen - 1] != ':')
      lszDir[iDirLen] = (char)0;

   GetCurrentDirectory(STRSIZ, aszCWD);
   fErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);  /* return errors to us */
   if (  !SetCurrentDirectory(lszDir)              // set from string
      || !GetCurrentDirectory(STRSIZ, aszNewCWD)   // get canonical form?
      )
   {  /* failed!  back out and beep */
      SetCurrentDirectory(aszCWD);
      SetErrorMode(fErrMode);
      MessageBeep(0);
   } else
   {  HWND hwndFiles;

      SetErrorMode(fErrMode);
      hwndFiles = GetDlgItem(hwnd, LB_FILES);
      if ( !(int)(LONG)
                   SendMessage( hwndFiles, LB_GETCOUNT, (WPARAM)0, (LPARAM)0)
         || lstrcmpi(aszNewCWD, aszCWD)
         )
      {  /* Fill directory listbox from current directory */
         SetWindowRedraw(hwndFiles, FALSE);
         DlgDirList(hwnd, aszAllFiles, LB_FILES, ID_DIR, ATTRDIRLIST);
         SendMessage( hwndFiles
                    , LB_DIR
                    , (WPARAM)ATTRFILELIST
                    , (LPARAM)(LPCSTR)aszFileFilter
                    );
         SetWindowRedraw(hwndFiles, TRUE);
         SendMessage( hwndFiles
                    , LB_ADDSTRING
                    , (WPARAM)0
                    , (LPARAM)(LPCSTR)aszNoSound
                    );
      }
   }
}/* FillDirBox */

/*---------------------------------------------------------------------------
| Enable or Disable the test button, file and sound displays
 ----------------------------------------------------------------------------*/
static VOID NEAR EnablePlay( HWND hwnd)
{ char    aszFile[STRSIZ];
  int     iSelection;
  BOOL    fSelection;
  HWND    hwndFiles;

  hwndFiles = GetDlgItem(hwnd, LB_FILES);
  iSelection = (int)(LONG)
                    SendMessage(hwndFiles, LB_GETCURSEL, (WPARAM)0, (LPARAM)0);
  fSelection = DlgDirSelectEx(hwnd, aszFile, STRSIZ, LB_FILES);
  GetSoundEntry(hwnd, -1, NULL, aszFile, NULL);
  EnableWindow( GetDlgItem(hwnd, ID_PLAY)               // the TEST button
              , fSndPlaySound
                && !fSelection
                && *aszFile
                && (iSelection != LB_ERR)
              );
  // enable disable the listboxes -- actually always enable (LKG)
  EnableWindow(GetDlgItem(hwnd, LB_NAMES), TRUE || fSndPlaySound);
  EnableWindow(hwndFiles, TRUE || fSndPlaySound);
}/* EnablePlay */


/*---------------------------------------------------------------------------
| Select the i-th element in the event NAMES list box
| Look up the file from the registry.
| Refill the FILES list box based on the dir containing the file
| Highlight (select) the file associated with it in the FILES list box
| if possible - the filename from the registry might be crap
| If there is no file, set the selection to no sound
 ----------------------------------------------------------------------------*/
static VOID NEAR ShowSound( HWND hwnd, int i)
{  char aszFile[STRSIZ];
   char aszPath[STRSIZ];


   if (i != -1)
      SendDlgItemMessage(hwnd, LB_NAMES, LB_SETCURSEL, (WPARAM)i, (LPARAM)0);
   GetSoundEntry(hwnd, i, NULL, aszFile, NULL);
   lstrcpy(aszPath, aszFile);
   if (QualifyFileName(aszPath))
   {
      LRESULT lRc;
      StripPathName(aszPath);                /* aszPath is now just the path */
      FillDirBox(hwnd, aszPath);
      lRc = SendDlgItemMessage( hwnd
                              , LB_FILES
                              , LB_SELECTSTRING
                              , (WPARAM)-1
                              , (LPARAM)FileName(aszFile)
                              );
      if (lRc==-1) {
          /* We couldn't find the file name in the list box.
          ** The most likely reason is that the file name contains a comma
          ** and we have stored the short file name in the registry.
          ** (storing file names with commas in the registry breaks the
          ** parsing scheme which is inherited from DOS.  Some apps go
          ** looking there so we need to keep compatibility.
          ** FindFirstFile is how you get the long name back
          */

          WIN32_FIND_DATA fd;
          FindFirstFile(aszFile, &fd);

          lRc = SendDlgItemMessage( hwnd
                                  , LB_FILES
                                  , LB_SELECTSTRING
                                  , (WPARAM)-1
                                  , (LPARAM)FileName(fd.cFileName)
                                  );
          if (lRc==-1) {
             /* Can't even find the long name - maybe there' stuff in the registry
             ** or the file has been deleted.
             */

             SendDlgItemMessage(hwnd, LB_FILES, LB_SETCURSEL, (WPARAM)(-1), (LPARAM)0);
          }
      }
   } else
   {

      FillDirBox(hwnd, aszCurrentDir);
      SendDlgItemMessage( hwnd
                        , LB_FILES
                        , LB_SELECTSTRING
                        , (WPARAM)-1
                        , (LPARAM)(LPCSTR)aszNoSound
                        );
   }
   EnablePlay(hwnd);
}/* ShowSound */

/*---------------------------------------------------------------------------
| play the filename associated with a sound
 ----------------------------------------------------------------------------*/
static VOID NEAR PlayTheSound( HWND hwnd, int i)
{  char aszFile[STRSIZ];

   GetSoundEntry(hwnd, i, NULL, aszFile, NULL);
   // play the sound if it is not associated with <none>
   if (fSndPlaySound && *aszFile)
   {  BOOL fPlayed;
      HCURSOR hcur;

      hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
      fPlayed = sndPlaySound(aszFile, SND_ASYNC | SND_FILENAME);
#if PARANOIA
                                       Trace("Sound should have played", NULL);
#endif //DBG
      SetCursor(hcur);
      // The sound did not play, tell the user.
      if (!fPlayed)
         MessageBox(hwnd, aszErrorPlayMessage, aszErrorPlayTitle, MB_OK);
   }
}/* PlayTheSound */

/*---------------------------------------------------------------------------
| update list box.
| add/repl any <lszEvent>=... entry with <lszEvent>=<lszFile>,<lszDescription>
 ----------------------------------------------------------------------------*/
static VOID NEAR NewSound( HWND hwnd         /* dialog box window handle */
                         , LPCSTR lszEvent
                         , LPCSTR lszFile
                         , LPCSTR lszDescription
                         )
{
   PSTR szEntry;
   int  iSound;
   int  iNewSound;

   hwnd = GetDlgItem(hwnd, LB_NAMES);

   /*
   ** The original Win 31 did not check the return value from LocalAlloc
   ** i'll just return if we could not allocate the storage.
   */
   szEntry = (PSTR)LocalAlloc(LMEM_FIXED, lstrlen(lszEvent)
                                + lstrlen(lszFile)
                                + lstrlen(lszDescription) + 3);
   if ( szEntry == NULL ) {
       return;
   }

   iSound = (int)(LONG)SendMessage(hwnd, LB_FINDSTRING, (WPARAM)-1, (LPARAM)lszDescription);
   if (iSound == LB_ERR)
        iNewSound = (int)(DWORD)SendMessage(hwnd, LB_ADDSTRING,
                                            (WPARAM)0, (LPARAM)lszDescription);
   else {
        LocalFree((HLOCAL)SendMessage(hwnd, LB_GETITEMDATA,
                                                   (WPARAM)iSound, (LPARAM)0));
        iNewSound = iSound;
   }


   wsprintf(szEntry, aszNewSoundFormat, lszEvent, lszFile, lszDescription);
   SendMessage(hwnd, LB_SETITEMDATA, (WPARAM)iNewSound, (LPARAM)szEntry );
   if (iSound == LB_ERR)
   	SendMessage(hwnd, LB_SETCURSEL, (WPARAM)iNewSound, (LPARAM)0);

   if (iSound != LB_ERR)
      SetWindowRedraw(hwnd, TRUE);

}/* NewSound */

/*---------------------------------------------------------------------------
| change the file associated with a sound
 ----------------------------------------------------------------------------*/
static VOID NEAR ChangeSound(HWND hwnd,int iSound, LPSTR lszFile)
{  char aszName[STRSIZ];
   char aszDescription[STRSIZ];
   char aszShortName[STRSIZ];

   if (!QualifyFileName(lszFile))
      lszFile = aszNull;
   GetSoundEntry(hwnd, iSound, aszName, NULL, aszDescription);
   /* because long file names can contain commas which totally mess with the parsing
      of the directory entries (basically <event>=<file>,<descr>), if there is
      a comma in the long file name, we put the short one in instead.
      If the short name also has a comma, then we're in trouble.  Such file
      names are not allowed!  In this case we set the sound to <none>
   */
   if (0 != strchr(lszFile,',')) {
       GetShortPathName(lszFile, aszShortName, STRSIZ);
       lszFile = aszShortName;
       if (0 != strchr(lszFile,','))
          strcpy(lszFile, "<none>");
   }
   NewSound(hwnd, aszName, lszFile, aszDescription);
}/* ChangeSound */

/*---------------------------------------------------------------------------
| write out a new [sounds] section
 ----------------------------------------------------------------------------*/
static VOID NEAR WriteSounds(HWND hwnd)
{  int iSound;
   int iTotalSounds;
   BOOL bAllOK = TRUE; /* all sounds written OK */
   DWORD dwLastError = 0;

   /* The idea is to capture the error code of the first error that we see,
      to put up an error box in the event of any error (so that the user has
      some idea of what has happened), but to continue to the end anyway
      as it may be that it's still going to write all the data anyway
   */

   hwnd = GetDlgItem(hwnd, LB_NAMES);
   iTotalSounds = (int)(LONG)SendMessage( hwnd
                                        , LB_GETCOUNT
                                        , (WPARAM)0
                                        , (LPARAM)0
                                        );
   // delete the whole section;
   bAllOK = WriteProfileString(aszSounds, NULL, NULL);
   if (!bAllOK)
   {  dwLastError = GetLastError();
      if (dwLastError==259)   /* "No more items".  This is normal */
      {  bAllOK = TRUE;
         dwLastError = 0;
      }
   }

   //Write Enabled flag
   if(fEnabled)
   {  BOOL bOK = WriteProfileString(aszSounds, "Enable", "1");
      if (bAllOK && !bOK)
      {  dwLastError = GetLastError();
      }
      bAllOK =  bAllOK && bOK;

   }
   else
   {  BOOL bOK = WriteProfileString(aszSounds, "Enable", "0");
      if (bAllOK && !bOK)
      {  dwLastError = GetLastError();
      }
      bAllOK =  bAllOK && bOK;
   }

   for (iSound = 0; iSound < iTotalSounds; iSound++)
   {  char aszBuffer[STRSIZ];
      LPSTR   lszCur;
      BOOL    bOK;

      lstrcpy(aszBuffer, (PSTR)SendMessage(hwnd, LB_GETITEMDATA, (WPARAM)iSound, (LPARAM)0));
      for (lszCur = aszBuffer; *lszCur != '='; lszCur++)
      ;
      *lszCur = (char)0;
      bOK = WriteProfileString(aszSounds, aszBuffer, lszCur + 1);
      if (bAllOK && !bOK)
      {  dwLastError = GetLastError();
      }
      bAllOK =  bAllOK && bOK;
   }
   if (!bAllOK)
   {   char szErr[STRSIZ];
       wsprintf(szErr, aszWriteErr, GetLastError());
       MessageBox(hwnd, szErr, aszAppName, MB_OK);
   }

   SendMessage( (HWND)-1
              , WM_WININICHANGE
              , (WPARAM)0
              , (LPARAM)(LPCSTR)aszSounds
              );
} /* WriteSounds */

/*---------------------------------------------------------------------------
|  Process control message from dialog box
 ----------------------------------------------------------------------------*/
static VOID PASCAL NEAR ControlMessage(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
   switch ((WORD)wParam)
   {  HWND hwndFocus;

      case IDH_CHILD_SND:
         CPHelp(hwnd, dwContext);
         break;
      case IDOK:
         hwndFocus = GetFocus();
         if (hwndFocus && (GetDlgCtrlID(hwndFocus) == LB_FILES))
#if defined(WIN16)
            PostMessage( hwnd
                       , WM_COMMAND
                       , (WPARAM)LB_FILES
                       , MAKELPARAM(hwndFocus, LBN_DBLCLK)
                       );
#else
            PostMessage( hwnd
                       , WM_COMMAND
                       , (WPARAM)MAKELONG(LB_FILES,LBN_DBLCLK)
                       , (LPARAM)hwndFocus
                       );
#endif //WIN16
         else
            {  HCURSOR hcur;
               BOOL    fBeep;

               if (fIniChanged)
               {  if ( MessageBox( hwnd
                                 , aszWarningMessage
                                 , aszWarningTitle
                                 , MB_ICONEXCLAMATION | MB_OKCANCEL
                                 )
                     == IDCANCEL
                     )
                     {  //  PostMessage(hwnd, WM_INITDIALOG, 0, 0L);
                        //Bug #3298 -jyg-
                        break;
                     }
               }
               /* hourglass while we do things */
               hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

               /* write any sounds away. */
               if (fSndPlaySound)
                  sndPlaySound(NULL, 0);            // flush any cached sounds
#if PARANOIA
                                 Trace("Sound should have been flushed", NULL);
#endif //DBG
               WriteSounds(hwnd);

               /* Write the new beep setting */
               SystemParametersInfo(SPI_GETBEEP, 0, &fBeep, 0);
               if (fBeep != (BOOL)IsDlgButtonChecked(hwnd, ID_BEEP))
                  SystemParametersInfo( SPI_SETBEEP
                                      , !fBeep
                                      , NULL
                                      , SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE
                                      );
               /* restore pointer */
               SetCursor(hcur);
               EndDialog(hwnd, TRUE);
            }
            break;
      case IDCANCEL:
         if (fSndPlaySound)
            sndPlaySound(NULL, 0); // Shut up when the dialog exits
                                   // meaningful when we go async
#if PARANOIA
                                  Trace("Sound should have been killed", NULL);
#endif // DBG
         EndDialog(hwnd, FALSE);
         break;
      case ID_PLAY:
         PlayTheSound(hwnd, -1);
         break;
      case ID_BEEP:
         break;
      case LB_NAMES:
         switch(HIWORD(wParam))            /* NT change, was HIWORD(lParam) */
         {  case LBN_SELCHANGE:
               ShowSound(hwnd, -1);
               break;
            case LBN_DBLCLK:
               PostMessage(hwnd, WM_COMMAND, (WPARAM)ID_PLAY, (LPARAM)0);
               break;
         }
         break;
      case LB_FILES:
         switch(HIWORD(wParam))
         {  char aszSelection[STRSIZ];

            case LBN_SELCHANGE:
               if (!DlgDirSelectEx(hwnd, aszSelection, STRSIZ, LB_FILES))
                  ChangeSound(hwnd, -1, aszSelection);
               EnablePlay(hwnd);
               break;
            case LBN_DBLCLK:
               if (DlgDirSelectEx(hwnd, aszSelection, STRSIZ, LB_FILES))
                  FillDirBox(hwnd, aszSelection);
               else
                  PostMessage(hwnd, WM_COMMAND, (WPARAM)ID_PLAY, (LPARAM)0);
               break;
         }
         break;
   }
}/* ControlMessage */

/*---------------------------------------------------------------------------
| lszpath = lszpath [\] xlsz
| where xlsz is lsz with any leading drive: and .\ removed
 ----------------------------------------------------------------------------*/
static VOID NEAR PASCAL catpath( LPSTR  lszpath, LPCSTR lsz)
{
   // Remove any drive letters from the directory to append
   if (lsz[1] == ':')
      lsz += 2;
   // Remove any current directories ".\" from directory to append
   while (*lsz == '.' && SLASH(lsz[1]))
      lsz += 2;
   // Dont append a NULL string or a single "."
   if (*lsz && !(*lsz == '.' && !lsz[1]))
   {  /* add a "\" unless it already ends in "\" or ":" */
      if (  (!SLASH(lszpath[lstrlen(lszpath)-1]))
         && ((lszpath[lstrlen(lszpath)-1]) != ':')
         )
      lstrcat(lszpath, aszDirSeparator);
      lstrcat(lszpath, lsz);
   }
}/* catpath */

/*---------------------------------------------------------------------------
| Initialse the dialog
| fIniChanged = FALSE
 ----------------------------------------------------------------------------*/
static BOOL PASCAL NEAR InitDialog( HWND hwnd          /* dlg box window */
                                  )
{  char        aszBuffer[STRSIZ];
   WAVEOUTCAPS woCaps;
   LPSTR       lszSection;
   HANDLE      hgSection;
   BOOL        fBeep;
   BOOL        fSoundsExist = TRUE;


   fIniChanged = FALSE;

   // Determine if there is a wave device;
   fSndPlaySound = waveOutGetNumDevs()
                   && !waveOutGetDevCaps(0, &woCaps, sizeof(woCaps))
                   && woCaps.dwFormats != 0L;
   /*********************************************
   * fSndPlaySound
   * = (IDYES==MessageBox(NULL,"Pretend sound device available?","???",MB_YESNO));
   **********************************************/

   if (!fSndPlaySound)
      MessageBox(hwnd, aszNoDevice, aszErrorPlayTitle, MB_OK);

   // Set the Windows Enabled flag
   fEnabled = (1==GetProfileInt(aszSounds, "Enable", 0));

   /* fill the list box with the [sounds] section of WIN.INI; */
   if ((hgSection = GlobalAlloc(GMEM_MOVEABLE, (DWORD)MAXINI)) == NULL)
      return FALSE;
   lszSection = (LPVOID)GlobalLock(hgSection);
   if (0<(int)GetProfileString(aszSounds, NULL, aszNull, lszSection, MAXINI))
   {
       for (; *lszSection; lszSection += lstrlen(lszSection) + 1)
       {
          LPSTR  lszDescription;

          if (0>=(int)GetProfileString( aszSounds
                                      , lszSection
                                      , aszNull
                                      , aszBuffer
                                      , sizeof(aszBuffer)
                                      )
             ) break;
          /* split string by inserting null and get pointer to second part */
          lszDescription = FindDescription(aszBuffer);
          if (!*lszDescription)
             lszDescription = lszSection;
          if (0!=lstrcmpi(lszSection,"Enable"))
          {
              NewSound(hwnd, lszSection, aszBuffer, lszDescription);
          }
       }
   }
   else fSoundsExist = FALSE;
   GlobalUnlock(hgSection);
   GlobalFree(hgSection);

   //  Try to change to the windows "resource" directory;
   //  if that fails hit up the windows "system" directory;
   GetWindowsDirectory(aszBuffer, sizeof(aszBuffer));
   catpath(aszBuffer, aszResourceDir);
   if (!SetCurrentDirectory(aszBuffer))
   {  GetSystemDirectory(aszBuffer, sizeof(aszBuffer));
      SetCurrentDirectory(aszBuffer);
   }

   // select the first sound;  There might not be any courtesy SteveWo.
   if (fSoundsExist) ShowSound(hwnd, 0);

   //  Get the beep enabled flag from USER;
   SystemParametersInfo(SPI_GETBEEP, 0, (&fBeep), 0);
   CheckDlgButton(hwnd, ID_BEEP, fBeep);

}/* InitDialog */

/*---------------------------------------------------------------------------*/
static	VOID PASCAL NEAR Destroy(
	HWND	hwnd)
{
	int	iEvents;

	hwnd = GetDlgItem(hwnd, LB_NAMES);
	iEvents = (int)(DWORD)SendMessage(hwnd, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);
	for (; iEvents--;)
		LocalFree((HLOCAL)SendMessage(hwnd, LB_GETITEMDATA, (WPARAM)iEvents, (LPARAM)0));
}

/*---------------------------------------------------------------------------
| Dialog procedure for the dialog box
 ----------------------------------------------------------------------------*/
INT_PTR SoundDlg( HWND     hwnd
             , UINT     uMsg
             , WPARAM   wParam
             , LPARAM   lParam
             )
{
   switch (uMsg)
   {
      case WM_WININICHANGE:
         // See if someone has modified the sounds section or can't tell;
         if (  !lstrcmpi((LPCSTR)lParam, aszSounds)
            || !*((LPCSTR)lParam)
            )
            fIniChanged = TRUE;
         break;

      case WM_COMMAND:
         ControlMessage(hwnd, wParam, lParam);
         return TRUE;

      case WM_INITDIALOG:
         return InitDialog(hwnd);

      case WM_DESTROY:
         Destroy(hwnd);
         break;

      default:
         if (uMsg == uHelpMessage)
         {  CPHelp(hwnd, dwContext);
            return TRUE;
         }
         break;
   }
   return FALSE;
}/* SoundDlg */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\scrnsave\text3d\text3d.h ===
//-----------------------------------------------------------------------------
// File: TextSaver.h
//
// Desc: Fun screen saver
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _TEXTSAVER_H
#define _TEXTSAVER_H

//***************************************************************************************
#define MAX_DISPLAY_STRING  20

enum SurfType
{
    color = 0,
    environment = 1,
    texture = 2
};

enum RotType
{
    none = 0,
    spin = 1,
    seesaw = 2,
    wobble = 3,
    tumble = 4
};

//***************************************************************************************
#define MAX_DEVICE_OBJECTS 10

struct DeviceObjects
{
    ID3DXMesh*          m_pObject;
    IDirect3DTexture8*  m_pTexture;
    DWORD               m_dwMeshUpdateCounter;
};


//-----------------------------------------------------------------------------
// Name: struct FLOATRECT
// Desc: Floating viewport rect
//-----------------------------------------------------------------------------
struct FLOATRECT
{
    FLOAT xMin;           
    FLOAT yMin;
    FLOAT xSize;
    FLOAT ySize;
    FLOAT xVel;
    FLOAT yVel;
};



class CTextScreensaver : public CD3DScreensaver
{
public:
    CTextScreensaver();

    virtual VOID        DoConfig();

protected:
    // Overrides from CD3DScreensaver
    virtual HRESULT RegisterSoftwareDevice();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();
    virtual HRESULT ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, 
                                  D3DFORMAT fmtBackBuffer);
    virtual VOID    SetDevice( UINT iDevice );

    DeviceObjects  m_DeviceObjects[MAX_DEVICE_OBJECTS];
    DeviceObjects* m_pDeviceObjects;

    FLOATRECT      m_floatrect;
    HFONT          m_hFont;
    FLOAT          m_fTextMinX,m_fTextMaxX;
    FLOAT          m_fTextMinY,m_fTextMaxY;
    FLOAT          m_fTextOffsetX,m_fTextOffsetY;

    FLOAT          m_fAngleX,m_fAngleY,m_fAngleZ;

    DWORD          m_dwLastTick;
    DWORD          m_dwMeshUpdateCounter;

    IDirect3DTexture8*  CreateTextureFromFile( const TCHAR* filename );
    HRESULT        BuildTextMesh( const TCHAR* text );
    VOID           UpdateAngles( DWORD elapsed );
    BOOL           UpdateTimeString( TCHAR* string );
    VOID           SetPerFrameStates();

    // Configuration stuff
    TCHAR          m_szDisplayString[MAX_DISPLAY_STRING+1];
    LOGFONT        m_Font;
    BOOL           m_bDisplayTime;
    SurfType       m_SurfType;
    BOOL           m_bSpecular;
    DWORD          m_dwRotationSpeed;
    DWORD          m_dwSize;
    RotType        m_RotType;
    COLORREF       m_SurfaceColor;
    BOOL           m_bUseCustomColor;
    BOOL           m_bUseCustomTexture;
    BOOL           m_bUseCustomEnvironment;
    TCHAR          m_szCustomTexture[_MAX_PATH];
    TCHAR          m_szCustomEnvironment[_MAX_PATH];
    DWORD          m_dwMeshQuality;
    D3DXMATRIX     m_matWorld;
    D3DXMATRIX     m_matView;

    virtual VOID   ReadSettings();

    VOID ss_ReadSettings();
    BOOL ss_RegistrySetup( int section, int file );
    int  ss_GetRegistryInt( int name, int iDefault );
    VOID ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, int bufSize );
    
    static BOOL WINAPI SettingsDialogProcStub( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
    BOOL           SettingsDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
    VOID           InitItems( HWND hDlg );
    VOID           ExtractAndWriteSettings( HWND hDlg );
    VOID           SelectSurfaceColor( HWND hDlg );
    VOID           SelectFont( HWND hDlg );
    VOID           SelectCustomTexture( HWND hDlg );
    VOID           SelectCustomEnvironment( HWND hDlg );
    VOID           EnableTextureWindows( HWND hDlg , SurfType sel );
};

//***************************************************************************************
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\atmpfm.c ===
/*--------------------------------------------------------------------------*/
/* WINATM version only                                                      */
/*--------------------------------------------------------------------------*/
//
//      Copyright 1990, 1991 -- Adobe Systems, Inc.
//      PostScript is a trademark of Adobe Systems, Inc.
//
// NOTICE:  All information contained herein or attendant hereto is, and
// remains, the property of Adobe Systems, Inc.  Many of the intellectual
// and technical concepts contained herein are proprietary to Adobe Systems,
// Inc. and may be covered by U.S. and Foreign Patents or Patents Pending or
// are protected as trade secrets.  Any dissemination of this information or
// reproduction of this material are strictly forbidden unless prior written
// permission is obtained from Adobe Systems, Inc.
//
/*--------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <fcntl.h>
#include <ctype.h>
#include <io.h>

#include "windows.h"
#pragma pack(1)
#include "makepfm.h"
#pragma pack(4)

#include "fvscodes.h"  // FVS_xxxxxx (font validation status) codes and macros.

#ifdef WIN30
  #define LPCSTR LPSTR
#endif

typedef LPSZ GlyphName;
extern  AFM  afm;

// bodind added these

#define str_DotINF ".INF"
#define str_DotPFM ".PFM"

/*--------------------------------------------------------------------------*/
static CHAR msgbuff[128];
static HANDLE hMemArray[258];  // #_of_glyphnames + 1_glypharray + 1_kernpairs
static INT indexMemArray = 0;
static GlyphName winEnc[] =
/*  8-27-91 yh  Added some characters for Windows 3.1 */
{   /*   0 */    "",
    /*   1 */    "",
    /*   2 */    "",
    /*   3 */    "",
    /*   4 */    "",
    /*   5 */    "",
    /*   6 */    "",
    /*   7 */    "",
    /*   8 */    "",
    /*   9 */    "",
    /*  10 */    "",
    /*  11 */    "",
    /*  12 */    "",
    /*  13 */    "",
    /*  14 */    "",
    /*  15 */    "",
    /*  16 */    "",
    /*  17 */    "",
    /*  18 */    "",
    /*  19 */    "",
    /*  20 */    "",
    /*  21 */    "",
    /*  22 */    "",
    /*  23 */    "",
    /*  24 */    "",
    /*  25 */    "",
    /*  26 */    "",
    /*  27 */    "",
    /*  28 */    "",
    /*  29 */    "",
    /*  30 */    "",
    /*  31 */    "",
    /*  32 */    "space",
    /*  33 */    "exclam",
    /*  34 */    "quotedbl",
    /*  35 */    "numbersign",
    /*  36 */    "dollar",
    /*  37 */    "percent",
    /*  38 */    "ampersand",
    /*  39 */    "quotesingle",
    /*  40 */    "parenleft",
    /*  41 */    "parenright",
    /*  42 */    "asterisk",
    /*  43 */    "plus",
    /*  44 */    "comma",
    /*  45 */    "hyphen",
    /*  46 */    "period",
    /*  47 */    "slash",
    /*  48 */    "zero",
    /*  49 */    "one",
    /*  50 */    "two",
    /*  51 */    "three",
    /*  52 */    "four",
    /*  53 */    "five",
    /*  54 */    "six",
    /*  55 */    "seven",
    /*  56 */    "eight",
    /*  57 */    "nine",
    /*  58 */    "colon",
    /*  59 */    "semicolon",
    /*  60 */    "less",
    /*  61 */    "equal",
    /*  62 */    "greater",
    /*  63 */    "question",
    /*  64 */    "at",
    /*  65 */    "A",
    /*  66 */    "B",
    /*  67 */    "C",
    /*  68 */    "D",
    /*  69 */    "E",
    /*  70 */    "F",
    /*  71 */    "G",
    /*  72 */    "H",
    /*  73 */    "I",
    /*  74 */    "J",
    /*  75 */    "K",
    /*  76 */    "L",
    /*  77 */    "M",
    /*  78 */    "N",
    /*  79 */    "O",
    /*  80 */    "P",
    /*  81 */    "Q",
    /*  82 */    "R",
    /*  83 */    "S",
    /*  84 */    "T",
    /*  85 */    "U",
    /*  86 */    "V",
    /*  87 */    "W",
    /*  88 */    "X",
    /*  89 */    "Y",
    /*  90 */    "Z",
    /*  91 */    "bracketleft",
    /*  92 */    "backslash",
    /*  93 */    "bracketright",
    /*  94 */    "asciicircum",
    /*  95 */    "underscore",
    /*  96 */    "grave",
    /*  97 */    "a",
    /*  98 */    "b",
    /*  99 */    "c",
    /* 100 */    "d",
    /* 101 */    "e",
    /* 102 */    "f",
    /* 103 */    "g",
    /* 104 */    "h",
    /* 105 */    "i",
    /* 106 */    "j",
    /* 107 */    "k",
    /* 108 */    "l",
    /* 109 */    "m",
    /* 110 */    "n",
    /* 111 */    "o",
    /* 112 */    "p",
    /* 113 */    "q",
    /* 114 */    "r",
    /* 115 */    "s",
    /* 116 */    "t",
    /* 117 */    "u",
    /* 118 */    "v",
    /* 119 */    "w",
    /* 120 */    "x",
    /* 121 */    "y",
    /* 122 */    "z",
    /* 123 */    "braceleft",
    /* 124 */    "bar",
    /* 125 */    "braceright",
    /* 126 */    "asciitilde",
    /* 127 */    "",
    /* 128 */    "",
    /* 129 */    "",
    /* 130 */    "quotesinglbase",
    /* 131 */    "florin",
    /* 132 */    "quotedblbase",
    /* 133 */    "ellipsis",
    /* 134 */    "dagger",
    /* 135 */    "daggerdbl",
    /* 136 */    "circumflex",
    /* 137 */    "perthousand",
    /* 138 */    "Scaron",
    /* 139 */    "guilsinglleft",
    /* 140 */    "OE",
    /* 141 */    "",
    /* 142 */    "",
    /* 143 */    "",
    /* 144 */    "",
    /* 145 */    "quoteleft",
    /* 146 */    "quoteright",
    /* 147 */    "quotedblleft",
    /* 148 */    "quotedblright",
    /* 149 */    "bullet",
    /* 150 */    "endash",
    /* 151 */    "emdash",
    /* 152 */    "tilde",
    /* 153 */    "trademark",
    /* 154 */    "scaron",
    /* 155 */    "guilsinglright",
    /* 156 */    "oe",
    /* 157 */    "",
    /* 158 */    "",
    /* 159 */    "Ydieresis",
    /* 160 */    "space",
    /* 161 */    "exclamdown",
    /* 162 */    "cent",
    /* 163 */    "sterling",
    /* 164 */    "currency",
    /* 165 */    "yen",
    /* 166 */    "brokenbar",
    /* 167 */    "section",
    /* 168 */    "dieresis",
    /* 169 */    "copyright",
    /* 170 */    "ordfeminine",
    /* 171 */    "guillemotleft",
    /* 172 */    "logicalnot",
    /* 173 */    "minus",
    /* 174 */    "registered",
    /* 175 */    "macron",
    /* 176 */    "degree",
    /* 177 */    "plusminus",
    /* 178 */    "twosuperior",
    /* 179 */    "threesuperior",
    /* 180 */    "acute",
    /* 181 */    "mu",
    /* 182 */    "paragraph",
    /* 183 */    "periodcentered",
    /* 184 */    "cedilla",
    /* 185 */    "onesuperior",
    /* 186 */    "ordmasculine",
    /* 187 */    "guillemotright",
    /* 188 */    "onequarter",
    /* 189 */    "onehalf",
    /* 190 */    "threequarters",
    /* 191 */    "questiondown",
    /* 192 */    "Agrave",
    /* 193 */    "Aacute",
    /* 194 */    "Acircumflex",
    /* 195 */    "Atilde",
    /* 196 */    "Adieresis",
    /* 197 */    "Aring",
    /* 198 */    "AE",
    /* 199 */    "Ccedilla",
    /* 200 */    "Egrave",
    /* 201 */    "Eacute",
    /* 202 */    "Ecircumflex",
    /* 203 */    "Edieresis",
    /* 204 */    "Igrave",
    /* 205 */    "Iacute",
    /* 206 */    "Icircumflex",
    /* 207 */    "Idieresis",
    /* 208 */    "Eth",
    /* 209 */    "Ntilde",
    /* 210 */    "Ograve",
    /* 211 */    "Oacute",
    /* 212 */    "Ocircumflex",
    /* 213 */    "Otilde",
    /* 214 */    "Odieresis",
    /* 215 */    "multiply",
    /* 216 */    "Oslash",
    /* 217 */    "Ugrave",
    /* 218 */    "Uacute",
    /* 219 */    "Ucircumflex",
    /* 220 */    "Udieresis",
    /* 221 */    "Yacute",
    /* 222 */    "Thorn",
    /* 223 */    "germandbls",
    /* 224 */    "agrave",
    /* 225 */    "aacute",
    /* 226 */    "acircumflex",
    /* 227 */    "atilde",
    /* 228 */    "adieresis",
    /* 229 */    "aring",
    /* 230 */    "ae",
    /* 231 */    "ccedilla",
    /* 232 */    "egrave",
    /* 233 */    "eacute",
    /* 234 */    "ecircumflex",
    /* 235 */    "edieresis",
    /* 236 */    "igrave",
    /* 237 */    "iacute",
    /* 238 */    "icircumflex",
    /* 239 */    "idieresis",
    /* 240 */    "eth",
    /* 241 */    "ntilde",
    /* 242 */    "ograve",
    /* 243 */    "oacute",
    /* 244 */    "ocircumflex",
    /* 245 */    "otilde",
    /* 246 */    "odieresis",
    /* 247 */    "divide",
    /* 248 */    "oslash",
    /* 249 */    "ugrave",
    /* 250 */    "uacute",
    /* 251 */    "ucircumflex",
    /* 252 */    "udieresis",
    /* 253 */    "yacute",
    /* 254 */    "thorn",
    /* 255 */    "ydieresis",
                 NULL,
};

extern CHAR encfile[MAX_PATH];
extern CHAR outfile[MAX_PATH];
extern CHAR infofile[MAX_PATH];
extern INT charset;
extern INT devType;
extern BOOL forceVariablePitch;

/*--------------------------------------------------------------------------*/
BOOL GetINFFontDescription(LPSZ, LPSZ, LPSZ);
BOOL MakePfm(LPSZ, LPSZ, LPSZ);

VOID GetFilename(LPSZ, LPSZ);
INT OpenParseFile(LPSZ);
INT OpenTargetFile(LPSZ);
VOID WriteDots(VOID);
LPVOID AllocateMem(UINT);
VOID FreeAllMem(VOID);
GlyphName *SetupGlyphArray(LPSZ);

extern short _MakePfm(VOID);          /* afm.c */
extern VOID StartParse(VOID);         /* token.c */
extern BOOL GetLine(INT);
extern VOID GetWord(CHAR *, INT);
extern BOOL GetString(CHAR *, INT);
extern INT  GetToken(INT, KEY *);

/*--------------------------------------------------------------------------*/

#ifdef ADOBE_CODE_WE_DO_NOT_USE


BOOL GetINFFontDescription(
  LPSZ    lpszInf,
  LPSZ    lpszDescription,
  LPSZ    lpszPSFontName
)
{
  INT         hfile, iToken;
  CHAR        szName[128];
  CHAR        szAngle[10];
  CHAR        szStyle[2];
  CHAR        szMods[30];
  BOOL        bAddItalic = FALSE;
  CHAR        szBold[20];
  CHAR        szItalic[20];

  static KEY infKeys[] = {
      "FontName",   TK_PSNAME,
      "MSMenuName", TK_MSMENUNAME,
      "VPStyle",    TK_VPSTYLE,
      "ItalicAngle",TK_ANGLE,
      NULL, 0
      };

  hfile = OpenParseFile( lpszInf );
  if( hfile == -1 ) return(FALSE);

  szName[0] = szStyle[0] = szMods[0] = lpszPSFontName[0] = 0;

  // bodind replaced AtmGetString by strcpy

  strcpy(szBold, "Bold");
  strcpy(szItalic, "Italic");
  //AtmGetString( RCN(STR_BOLD), szBold, sizeof(szBold) );
  //AtmGetString( RCN(STR_ITALIC), szItalic, sizeof(szItalic) );

  while( GetLine(hfile) ) {
      iToken = GetToken(hfile,infKeys);
      switch(iToken) {
          case TK_MSMENUNAME:
              GetString(szName, sizeof(szName));
              break;
          case TK_PSNAME:
              GetString(lpszPSFontName, MAX_PATH);
              break;
          case TK_ANGLE:
              GetWord(szAngle, sizeof(szAngle));
              if ( strcmp (szAngle, "0") )
                 bAddItalic = TRUE;
              break;
          case TK_VPSTYLE:
              GetString(szStyle, sizeof(szStyle));
              switch( toupper(szStyle[0]) ) {
                  case 'N': break;
                  case 'B': strcpy(szMods, szBold);    break;
                  case 'T': strcpy(szMods, szBold);
                  case 'I':
                     strcat(szMods, szItalic);
                     bAddItalic = FALSE;
                     break;
                  /* default:  break; */
                  }
              break;
          }
      }
  _lclose(hfile);

  if( !szName[0] ) return(FALSE);

  strcpy( lpszDescription, szName );
  if( szMods[0] ) {
      strcat( lpszDescription, "," );
      strcat( lpszDescription, szMods );
      if (bAddItalic)
         strcat(lpszDescription, szItalic);
      }         
  else
     {
      if (bAddItalic)
        {
        strcat (lpszDescription, "," );
        strcat (lpszDescription, szItalic);
        }
     }
  return(TRUE);
} // end of GetINFFontDescription


/*--------------------------------------------------------------------------*/
INT MakePfm(afmpath, infdir, pfmdir) /* MEF */
LPSZ afmpath, infdir, pfmdir;
{
  #define FATALERROR  2
  #define NOERROR     0

  CHAR bname[9];

  indexMemArray = 0;              /* init global */

  strcpy(afm.szFile, afmpath);
  GetFilename(afmpath, bname);
  if( infdir[strlen(infdir)-1] == '\\' )
      sprintf(infofile, "%s%s%s", infdir, bname, str_DotINF);
  else
      sprintf(infofile, "%s\\%s%s", infdir, bname, str_DotINF);
  if( pfmdir[strlen(pfmdir)-1] == '\\' )
      sprintf(outfile,  "%s%s%s", pfmdir, bname, str_DotPFM);
  else
      sprintf(outfile,  "%s\\%s%s", pfmdir, bname, str_DotPFM);

  afm.iPtSize = 12;
  encfile[0] = EOS;
  devType = POSTSCRIPT;
  if( !strcmp(_strupr(bname), "SY______") ) charset = SYMBOL_CHARSET;
  else charset = -1;
/*
 * yh 8/16/91 -- Keep forceVariablePitch to TRUE for now to be compatible
 * with bitmaps generated by Font Foundry.  ATM and device driver will
 * report different value for PitchAndFamily for monospaced fonts.
 *
 * forceVariablePitch = FALSE;
 */

  if( !_MakePfm() ) {
      return FATALERROR;
      }
  return(NOERROR);
}

#endif // ADOBE_CODE_WE_DO_NOT_USE

/*--------------------------------------------------------------------------*/
VOID GetFilename(path, name)
LPSZ path, name;
{
  LPSZ p;
  INT i;

  if( (p = strrchr(path,'\\')) == NULL )
      if( (p = strrchr(path,':') ) == NULL ) p = path;
  if( p != NULL ) p++;
  for(i=0; i<8; i++) {
      if( p[i]=='.' || p[i]==EOS ) break;
      name[i] = p[i];
      }
  name[i] = EOS;
}

/*----------------------------------------------------------------------------*/
INT OpenParseFile(lpszPath)
LPSZ lpszPath;
{
  OFSTRUCT    of;

  StartParse();
  return( OpenFile(lpszPath, &of, OF_READ) );
}

/*----------------------------------------------------------------------------*/
INT OpenTargetFile(lpszPath)
LPSZ lpszPath;
{
  OFSTRUCT    of;

  return( OpenFile(lpszPath, &of, OF_CREATE | OF_WRITE) );
}

LPVOID AllocateMem(size)
UINT size;
{
  HANDLE hmem;

  if( !(hmem=GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, size)) ) return(NULL);
  hMemArray[indexMemArray++] = hmem;
  return( GlobalLock(hmem) );
}

/*--------------------------------------------------------------------------*/
VOID FreeAllMem()
{
  INT i;

  for(i=0; i<indexMemArray; i++) {
      GlobalUnlock( hMemArray[i] );
      GlobalFree( hMemArray[i] );
      }
}

/*--------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
GlyphName *SetupGlyphArray(encFilePath)

LPSZ encFilePath;
{
  return(winEnc);
}

/*----------------------------------------------------------------------------*/



/******************************Public*Routine******************************\
*
* BOOL bGetDescFromInf(char * pszINF, DWORD cjDesc, char *pszDesc)
*
* Not same as adobe's routine, we use font name from which we weed out
* hyphes '-'
*
* History:
*  28-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bGetDescFromInf(char * pszINF, DWORD cjDesc, char *pszDesc)
{
  INT         hfile;

  static KEY akeyInf[] = {
      "FontName",   TK_PSNAME,
      NULL, 0
      };

  hfile = OpenParseFile( pszINF );
  if( hfile == -1 ) return(FALSE);

  pszDesc[0] = 0;

  while( GetLine(hfile) )
  {
    if (GetToken(hfile,akeyInf) == TK_PSNAME)
    {
       GetString(pszDesc, cjDesc);
       break;
    }
  }
  _lclose(hfile);

  if( !pszDesc[0] ) return(FALSE);

// weed out hyphens

  for ( ; *pszDesc; pszDesc++)
  {
    if (*pszDesc == '-')
        *pszDesc = ' ';
  }

  return(TRUE);

}

/******************************Public*Routine******************************\
*
* short CreatePFM(char *pszINF, char *pszAFM, char *pszPFM);
*
* slightly modified adobe's routine
*
* History:
*  28-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR  
*
\**************************************************************************/
short CreatePFM(char *pszINF, char *pszAFM, char *pszPFM)
{
  CHAR bname[9];

  indexMemArray = 0;              /* init global */

  strcpy(afm.szFile, pszAFM);
  GetFilename(pszAFM, bname);

  strcpy (infofile, pszINF);
  strcpy (outfile, pszPFM);

  afm.iPtSize = 12;
  encfile[0] = EOS;
  devType = POSTSCRIPT;

// this is something that would have never come to my mind [bodind]

  if( !strcmp(_strupr(bname), "SY______") )
    charset = SYMBOL_CHARSET;
  else
    charset = -1;

/*
 * yh 8/16/91 -- Keep forceVariablePitch to TRUE for now to be compatible
 * with bitmaps generated by Font Foundry.  ATM and device driver will
 * report different value for PitchAndFamily for monospaced fonts.
 *
 * forceVariablePitch = FALSE;
 */

  return _MakePfm();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\builder.c ===
/***
 **
 **   Module: Builder
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains functions that will write the tables found in a
 **    TrueType font file.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/



/**** INCLUDES */
/* General types and definitions. */
#include <string.h>     /* Prototype for memset */
#include <limits.h>

/* Special types and definitions. */
#include "types.h"
#include "metrics.h"
#include "safemem.h"
#include "encoding.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "titott.h"
#include "builder.h"
#include "fwriter.h"

#if DBG
#define STATIC
#else
#define STATIC static
#endif


/***** LOCAL TYPES */
struct GlyphKerning {
	USHORT left;
	USHORT right;
	funit delta;
};

struct GlyphList {
   long offset;            /* File offset of the sub-table for this glyph. */
   const struct encoding *code;  /* Encoding key (see the "Encoding" module. */
   funit aw;               /* Advance width. */
   funit lsb;              /* Left side bearing. */
   USHORT pts;             /* Total number of points in the glyph. */
   Point bbox[2];          /* Bounding box of the glyph. */
   USHORT conts;           /* Number of contours. */
};


/* MS cmap encoding sub-table. */
struct MSEncoding {
   USHORT segCount;
   USHORT *startCount;
   USHORT *endCount;
   USHORT *idOffsets;
   USHORT *gi;
   USHORT giCount;
   USHORT giMax;
};


struct TTHandle {
   OutputFile *file;
   Point bbox[2];
   struct GlyphList *pool;

   /* Accumulative 'maxp' entries. */
   USHORT count;
   USHORT maxcnt;
   USHORT maxpts;
   USHORT maxcontours;
   USHORT maxcomppts;
   USHORT maxcompcont;
   USHORT maxcompelements;
   USHORT maxstack;
   USHORT maxinstructions;
   USHORT maxtwilight;
};



/***** CONSTANTS */
#define SHORT_LOCA_MAX  65535
#define KERN_HORIZONTAL 0x0001
#define KERN_PAIR   0x0000
#define KERN_FORMAT0   0x0000

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002

#define PLT_MAC         (USHORT)1
#define PLT_MS          (USHORT)3

#define ENC_ROMAN       (USHORT)0

// for platform id = 3 cmap table, symbol font or ugl

#define ENC_SYMBOL      (USHORT)0
#define ENC_UGL         (USHORT)1

#define LAN_MS_US       (USHORT)0x0409
#define LAN_MAC_US      (USHORT)0

#define COPYRIGHT       (USHORT)0
#define FAMILY          (USHORT)1
#define SUBFAMILY       (USHORT)2
#define ID              (USHORT)3
#define FULLNAME        (USHORT)4
#define VERSION         (USHORT)5
#define PSNAME          (USHORT)6
#define NOTICE          (USHORT)7


/* Glyph constants. */
#define FLG_ONCURVE     0x01
#define FLG_SHORTX      0x02
#define FLG_SHORTY      0x04
#define FLG_REPEAT      0x08
#define FLG_SAMEX       0x10
#define FLG_SAMEY       0x20

#define ARGS_1_2_ARE_WORDS  0x0001
#define ARGS_ARE_XY_VALUES  0x0002
#define ROUND_XY_TO_GRID    0x0004
#define MORE_COMPONENTS     0x0020

#define GLYPHBUF     64          /* GlyphList's that are allocated each time */
#define MACSIZE      (USHORT)256 /* Length of the Mac encoding vector. */

/* Table constants. */
#define FIRSTCHAR    (USHORT)0x0020 /* First defined char. */
#define LASTCHAR     (USHORT)0xf002 /* Last defined char. */
#define MAXZONES     (USHORT)2      /* Number of zones in the font. */
#define MAXIDEFS     (USHORT)0      /* Number of idefs in the fpgm. */
#define MAXDEPTH     (USHORT)1      /* Number of recursions in composits. */
#define FM_READONLY  (USHORT)2      /* fsType Read Only. */
#define NO_CLASS     (USHORT)0      /* 0 = No class id for the font. */
#define OS2VERSION   (USHORT)0      /* Version of the OS/2 table. */
#define CARET_RISE   (USHORT)1      /* Vertical caret slope rise. */
#define CARET_RUN    (USHORT)0      /* Vertical caret slope run. */
#define RESERVED0    (USHORT)0
#define MAGICCOOKIE  0x5F0F3CF5L    /* Magic cookie. */
#define BASELINEY    (USHORT)0x0001 /* Baseline at y==0 */
#define LOWPPEM      (USHORT)8      /* Lowest PPEM size. */
#define ROMAN        (USHORT)2      /* Direction = left,right&neutrals.*/
#define GLYPH_FORMAT (USHORT)0      /* Current glyphs format. */
#define VERSION0     (USHORT)0      /* Version zero of a table. */
#define NUM_CMAPS    (USHORT)2      /* Number of cmap sub-tables. */
#define SEGMENT_MAP  (USHORT)4      /* MS segment mapping of cmap table. */
#define PAD0         (USHORT)0      /* Padding byte. */
#define MAX_PPEM_SIZE     (USHORT)65535  /* Maximum PPEM size in GASP table. */

/* LOCA constants */
#define SHORTOFFSETS 0
#define LONGOFFSETS  1


/* Weighted average character width. */
STATIC const long Weights[] = {
   64,
   14,
   27,
   35,
   100,
   20,
   14,
   42,
   63,
   3,
   6,
   35,
   20,
   56,
   56,
   17,
   4,
   49,
   56,
   71,
   31,
   10,
   18,
   3,
   18,
   2
};

/***** MACROS */
#define LONGVERSION(v,r)      ((((long)v)<<16L) | (long)r)


/***** STATIC FUNCTIONS */

/***
** Function: SearchRange
**
** Description:
**   Compute the search range key for the CMAP subtable
**   for Windows.
***/
STATIC USHORT SearchRange(const USHORT cnt)
{
   USHORT i;

   i = 0;
   while ((1u<<i) <= cnt) {
      i++;
   }

   return (USHORT)(1<<i);
}



/***
** Function: EntrySelector
**
** Description:
**   Compute the entry selector key for the CMAP subtable
**   for Windows.
***/
STATIC USHORT EntrySelector(const USHORT cnt)
{
   USHORT i;

   i = 0;
   while ((1u<<(i+1)) <= cnt) {
      i++;
   }

   return i;
}



/***
** Function: RangeShift
**
** Description:
**   Compute the range shift key for the CMAP subtable
**   for Windows.
***/
STATIC USHORT RangeShift(const USHORT cnt)
{
   return (USHORT)(2*cnt - SearchRange(cnt));
}



/***
 ** Function: PutGASP
 **
 ** Description:
 **   This function writes the optional 'GASP' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutGASP(OutputFile *file,
		      const USHORT treshold)
{
   long offset;

   offset = FileTell(file);

   WriteShort(VERSION0, file);
   WriteShort(3, file);

   /* First range 0 - 8 : GRIDFIT */
   WriteShort(8, file);
   WriteShort(GASP_DOGRAY, file);

   /* Second range 8 - onpix : GRIDFIT */
   WriteShort(treshold, file);
   WriteShort(GASP_GRIDFIT, file);

   /* Third range onpix - inf. : GRIDFIT | GRAYSCALE */
   WriteShort(MAX_PPEM_SIZE, file);
   WriteShort(GASP_GRIDFIT | GASP_DOGRAY, file);

   return CompleteTable(offset, TBL_GASP, file);
}


/***
** Function: cmpKern
**
** Description:
**
***/
STATIC int CDECL cmpKern(const void *a1, const void *a2)
{
   const struct GlyphKerning *k1 = a1;
   const struct GlyphKerning *k2 = a2;
   ULONG first;
   ULONG second;

   first = ((k1->left)<<16L) + k1->right;
   second = ((k2->left)<<16L) + k2->right;

   return (int)(first - second);
}


/***
 ** Function: StdEncToGlyphIndex
 **
 ** Description:
 **   This function maps an StdEncoding character code to a
 **   glyph index.
 **
 ***/
USHORT StdEncToGlyphIndex(const struct GlyphList *pool,
						  const USHORT count,
						  const USHORT code)
{
	USHORT i;

	for (i=0; i<count; i++) {
            if (LookupCharCode(pool[i].code, ENC_MSWINDOWS) == code)
                 return i;
	}

	return 0;
}


/***
 ** Function: PutKERN
 **
 ** Description:
 **   This function writes the optional 'KERN' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutKERN(OutputFile *file,
					   struct kerning *charkerns,
					   const USHORT kernsize,
					   const struct GlyphList *pool,
					   const USHORT count)
{
   struct GlyphKerning *kerns;
   long offset;
   unsigned i;
   USHORT cnt;

   if ((kerns = malloc(sizeof(struct GlyphKerning)*kernsize))==NULL)
	   return FAILURE;

   /* Translate the kerning from char codes to glyph index. */
   for (i=0, cnt=0; i<kernsize; i++) {
           if ((kerns[cnt].left  = StdEncToGlyphIndex(pool, count, charkerns[i].left))!=0 &&
               (kerns[cnt].right = StdEncToGlyphIndex(pool, count, charkerns[i].right))!=0)
           {
		   kerns[cnt].delta = charkerns[i].delta;
		   cnt++;
	   }
   }
   /* Sort the kerning pairs. */
   qsort((void *)kerns, cnt, sizeof(struct GlyphKerning), cmpKern);


   offset = FileTell(file);

   WriteShort(VERSION0, file);
   WriteShort(1, file);

   /* First sub-table header. */
   WriteShort(VERSION0, file);
   WriteShort((USHORT)(2+2+2+ 2+2+2+2+ cnt*(2+2+2)), file);
   WriteShort(KERN_HORIZONTAL | KERN_PAIR | KERN_FORMAT0, file);

   /* First sub-table, format 0 */
   WriteShort(cnt, file);
   WriteShort(SearchRange(cnt), file);
   WriteShort(EntrySelector(cnt), file);
   WriteShort(RangeShift(cnt), file);
   for (i=0; i<cnt; i++) {
      WriteShort((USHORT)kerns[i].left, file);
      WriteShort((USHORT)kerns[i].right, file);
      WriteShort((USHORT)kerns[i].delta, file);
   }

   free(kerns);

   return CompleteTable(offset, TBL_KERN, file);
}


/***
 ** Function: PutCVT
 **
 ** Description:
 **   This function writes the optional 'cvt' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutCVT(OutputFile *file,
		      const short *ppgm,
		      const USHORT num)
{
   USHORT i;
   long offset;

   offset = FileTell(file);

   for (i=0; i<num; i++)
      WriteShort((USHORT)ppgm[i], file);

   return CompleteTable(offset, TBL_CVT, file);
}



/***
 ** Function: PutPREP
 **
 ** Description:
 **   This function writes the optional 'prep' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutPREP(OutputFile *file,
		       const UBYTE *prep,
		       const USHORT num)
{
   long offset;

   offset = FileTell(file);

   (void)WriteBytes(prep, num, file);

   return CompleteTable(offset, TBL_PREP, file);
}



/***
 ** Function: PutFPGM
 **
 ** Description:
 **   This function writes the optional 'fpgm' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutFPGM(OutputFile *file,
		       const UBYTE *fpgm,
		       const USHORT num)
{
   long offset;

   offset = FileTell(file);

   (void)WriteBytes(fpgm, num, file);

   return CompleteTable(offset, TBL_FPGM, file);
}



/***
 ** Function: PutPOST
 **
 ** Description:
 **   This function writes the required 'post' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutPOST(OutputFile *file,
		       struct GlyphList *pool,
		       USHORT count,
		       struct TTMetrics *ttm)
{
   const char *str;
   long offset;
   USHORT i;

   offset = FileTell(file);
   WriteLong(LONGVERSION(2, 0), file);
   WriteLong((ULONG)ttm->angle, file);
   WriteShort((USHORT)ttm->underline, file);
   WriteShort((USHORT)ttm->uthick, file);
   WriteLong((ULONG)ttm->isFixPitched, file);
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);

   /* Write the character codes. */
   WriteShort(count, file);
   for (i=0; i<count; i++) {
      if (pool[i].code)
	 WriteShort(LookupCharCode(pool[i].code, ENC_MACCODES), file);
      else
	 WriteShort((USHORT)0, file);
   }

   /* Write the character names. */
   for (i=0; i<count; i++) {
      if (pool[i].code) {
	 str = LookupCharName(pool[i].code);
	 WriteByte((UBYTE)strlen(str), file);
	 (void)WriteBytes((UBYTE*)str, (USHORT)strlen(str), file);
      }
   }

   return CompleteTable(offset, TBL_POST, file);
}



/***
 ** Function: PutMAXP
 **
 ** Description:
 **   This function writes the required 'maxp' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutMAXP(struct TTHandle *tt,
		       const USHORT maxstorage,
		       const USHORT maxprepstack,
		       const USHORT maxfuns)
{
   long offset;

   offset = FileTell(tt->file);
   WriteLong(LONGVERSION(1, 0), tt->file);
   WriteShort(tt->count, tt->file);
   WriteShort(tt->maxpts, tt->file);
   WriteShort(tt->maxcontours, tt->file);
   WriteShort(tt->maxcomppts, tt->file);
   WriteShort(tt->maxcompcont, tt->file);
   WriteShort(MAXZONES, tt->file);
   WriteShort(tt->maxtwilight, tt->file);
   WriteShort(maxstorage, tt->file);
   WriteShort(maxfuns, tt->file);
   WriteShort(MAXIDEFS, tt->file);
   WriteShort((USHORT)MAX(tt->maxstack, maxprepstack), tt->file);
   WriteShort(tt->maxinstructions, tt->file);
   WriteShort(tt->maxcompelements, tt->file);
   WriteShort(MAXDEPTH, tt->file);
   return CompleteTable(offset, TBL_MAXP, tt->file);
}



/***
 ** Function: PutOS2
 **
 ** Description:
 **   This function writes the required 'OS/2' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutOS2(OutputFile *file,
		      const struct GlyphList *pool,
		      const USHORT count,
		      const struct TTMetrics *ttm)
{
   long offset;
   long aw;
   USHORT i;

   offset = FileTell(file);

   /* Compute some font metrics. */
   aw = 0;

   /* Do a weighted average? */
   if (ttm->Encoding==NULL) {
      for (i=0; i<count; i++) {
	 short letter = (short)LookupCharCode(pool[i].code, ENC_MACCODES);
	 if (letter==' ') {
	    aw = aw + 166L * pool[i].aw;
	 } else if ((letter>='a' && letter <= 'z')) {
	    aw = aw + pool[i].aw * Weights[letter - 'a'];
	 }
      }
      aw /= 1000;
   } else {
      for (i=0; i<count; i++) {
	 aw += pool[i].aw;
      }
      aw = aw / count;
   }

   WriteShort(OS2VERSION, file);
   WriteShort((USHORT)aw, file);
   WriteShort(ttm->usWeightClass, file);
   WriteShort(ttm->usWidthClass, file);
   WriteShort(FM_READONLY, file);
   WriteShort((USHORT)ttm->subsize.x, file);
   WriteShort((USHORT)ttm->subsize.y, file);
   WriteShort((USHORT)ttm->suboff.x, file);
   WriteShort((USHORT)ttm->suboff.y, file);
   WriteShort((USHORT)ttm->supersize.x, file);
   WriteShort((USHORT)ttm->supersize.y, file);
   WriteShort((USHORT)ttm->superoff.x, file);
   WriteShort((USHORT)ttm->superoff.y, file);
   WriteShort((USHORT)ttm->strikesize, file);
   WriteShort((USHORT)ttm->strikeoff, file);
   WriteShort(NO_CLASS, file);

   /* Panose */
   WriteBytes(ttm->panose, (USHORT)10, file);

   /* Char range. */
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);

   /* Vend ID. */
   WriteLong(0L, file);

   WriteShort(ttm->fsSelection, file);
   WriteShort(FIRSTCHAR, file);
   WriteShort(LASTCHAR, file);
   WriteShort((USHORT)ttm->typAscender, file);
   WriteShort((USHORT)ttm->typDescender, file);
   WriteShort((USHORT)ttm->typLinegap, file);
   WriteShort((USHORT)ttm->winAscender, file);
   WriteShort((USHORT)ttm->winDescender, file);

   return CompleteTable(offset, TBL_OS2, file);
}



/***
 ** Function: PutLOCA
 **
 ** Description:
 **   This function writes the required 'loca' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutLOCA(OutputFile *file,
		       const struct GlyphList *pool,
		       const USHORT count,
		       short *format)
{
   long offset;
   USHORT i;

   offset = FileTell(file);

   /* Check for offset size format. */
   for (i=0, (*format) = SHORTOFFSETS; i<=count &&
			 (*format)==SHORTOFFSETS; i++) {
      if (pool[i].offset/2>SHORT_LOCA_MAX)
	 (*format) = LONGOFFSETS;
   }

   if ((*format)==LONGOFFSETS)
      for (i=0; i<=count; i++)
	 WriteLong((ULONG)pool[i].offset, file);
   else
      for (i=0; i<=count; i++)
	 WriteShort((USHORT)(pool[i].offset/2), file);

   return CompleteTable(offset, TBL_LOCA, file);
}



/***
 ** Function: PutHMTX
 **
 ** Description:
 **   This function writes the required 'hmtx' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutHMTX(OutputFile *file,
		       const struct GlyphList *pool,
		       const USHORT count,
		       const funit *widths,
		       const USHORT first,
                       const USHORT last,
                       const  struct encoding *enc)

{
   long offset;
   USHORT std;
   USHORT i;
   USHORT usEnc = (USHORT) (enc? ENC_MACCODES : ENC_UNICODE);

   offset = FileTell(file);

   if (widths) {
      for (i=0; i<count; i++) {
	 if (pool[i].code) {
            std = LookupCharCode(pool[i].code, usEnc);
	 } else {
	    std = NOTDEFGLYPH;
	 }
	 if (std>=first && std<=last)
	    WriteShort((USHORT)widths[std-first], file);
	 else
	    WriteShort((USHORT)pool[i].aw, file);
	 WriteShort((USHORT)pool[i].lsb, file);
      }
   } else {
      for (i=0; i<count; i++) {
	 WriteShort((USHORT)pool[i].aw, file);
	 WriteShort((USHORT)pool[i].lsb, file);
      }
   }
   return CompleteTable(offset, TBL_HMTX, file);
}



/***
 ** Function: PutHHEA
 **
 ** Description:
 **   This function writes the required 'HHEA' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutHHEA(OutputFile *file,
		       const struct GlyphList *pool,
		       const USHORT count,
		       const Point bbox[2],
                       const funit linegap,
                       const struct TTMetrics *ttm
)
{
   funit awmin, awmax, xmax, lsb;
   long offset;
   USHORT i;

   offset = FileTell(file);

   /* Compute some font metrics. */
   awmax = SHRT_MIN;
   awmin = SHRT_MAX;
   xmax = SHRT_MIN;
   lsb = SHRT_MAX;
   for (i=0; i<count; i++) {
      funit rsb = pool[i].aw - pool[i].lsb -
		  (pool[i].bbox[1].x - pool[i].bbox[0].x);
      funit ext = pool[i].lsb +
		  (pool[i].bbox[1].x - pool[i].bbox[0].x);
      if (ext>xmax)
	 xmax = ext;
      if (rsb<awmin)
	 awmin = rsb;
      if (pool[i].aw>awmax)
	 awmax = pool[i].aw;
      if (pool[i].lsb<lsb)
	 lsb = pool[i].lsb;
   }


   WriteLong(LONGVERSION(1, 0), file);
   WriteShort((USHORT)bbox[1].y, file);
   WriteShort((USHORT)bbox[0].y, file);
   WriteShort((USHORT)linegap, file);
   WriteShort((USHORT)awmax, file);
   WriteShort((USHORT)lsb, file);
   WriteShort((USHORT)awmin, file);
   WriteShort((USHORT)xmax, file);
   WriteShort(CARET_RISE, file);
   WriteShort(CARET_RUN, file);
   WriteShort((USHORT)(ttm->FirstChar   << 8), file);
   WriteShort((USHORT)(ttm->LastChar    << 8), file);
   WriteShort((USHORT)(ttm->DefaultChar << 8), file);
   WriteShort((USHORT)(ttm->BreakChar   << 8), file);
   WriteShort((USHORT)(ttm->CharSet     << 8), file);
   WriteShort(RESERVED0, file);
   WriteShort(count, file);
   return CompleteTable(offset, TBL_HHEA, file);
}



/***
** Function: PutHEAD
**
** Description:
**   This function writes the required 'head' table to the
**   TT font file.
**
***/
STATIC errcode PutHEAD(OutputFile *file,
		       const Point bbox[2],
		       const struct TTMetrics *ttm,
		       const short loca,
		       long *csum)
{
   long offset;

   offset = FileTell(file);

   WriteLong(LONGVERSION(1, 0), file);
   WriteShort(ttm->version.ver, file);
   WriteShort(ttm->version.rev, file);
   (*csum) = (long)FileTell(file);
   WriteLong(0L, file);
   WriteLong(MAGICCOOKIE, file);
   WriteShort(BASELINEY, file);
   WriteShort((USHORT)ttm->emheight, file);
   WriteLong(ttm->created.a, file);WriteLong(ttm->created.b, file);
   WriteLong(ttm->created.a, file);WriteLong(ttm->created.b, file);
   WriteShort((USHORT)bbox[0].x, file);
   WriteShort((USHORT)bbox[0].y, file);
   WriteShort((USHORT)bbox[1].x, file);
   WriteShort((USHORT)bbox[1].y, file);
   WriteShort((USHORT)ttm->macStyle, file);
   WriteShort(LOWPPEM, file);
   WriteShort(ROMAN, file);
   WriteShort((USHORT)loca, file);
   WriteShort(GLYPH_FORMAT, file);

   return CompleteTable(offset, TBL_HEAD, file);
}



/***
** Function: WriteNameEntry
**
** Description:
**   This function writes an entry in the NAME table
**   header for one string.
**
***/
STATIC USHORT WriteNameEntry(OutputFile *file,
			     const USHORT platform,
			     const USHORT encoding,
			     const USHORT language,
			     const USHORT nameid,
			     const char *str,
			     const USHORT off)
{
   USHORT len;

   if (str) {
      len = (USHORT)strlen(str);
      switch (platform) {
	 case PLT_MS:
	    len *= 2;
	    break;
	 case PLT_MAC:
	    len *= 1;
	    break;
	 default:
	    LogError(MSG_WARNING, MSG_PLATFORM, NULL);
	    len *= 1;
	    break;
      }
      WriteShort(platform, file);
      WriteShort(encoding, file);
      WriteShort(language, file);
      WriteShort(nameid, file);
      WriteShort(len, file);
      WriteShort(off, file);
   } else {
      len = 0;
   }

   return len;
}



/***
** Function: WriteNameString
**
** Description:
**   This function write the textual data of a string
**   to the NAME table, according to the platform and
**   encoding schema.
**
***/
STATIC void WriteNameString(OutputFile *file,
			    const USHORT platform,
			    const char *str)
{
   USHORT i;

   if (str) {
      switch (platform) {
	 default:
	 case PLT_MAC:
	    (void)WriteBytes((UBYTE *)str, (USHORT)strlen(str), file);
	    break;
	 case PLT_MS:
	    for (i=0; i<strlen(str); i++)
	       WriteShort(LookupCharCode(DecodeChar(NULL,
						    (short)0,
						    ENC_STANDARD,
						    (USHORT)(UBYTE)str[i]),
					 ENC_UNICODE),
			  file);
	    break;
      }
   }
}



/***
** Function: PutNAME
**
** Description:
**   This function writes the required 'name' table to the
**   TT font file.
**
***/



STATIC errcode PutNAME(OutputFile *file, const struct TTMetrics *ttm)
{
   USHORT stroff = 0;
   USHORT count = 0;
   USHORT encId = ttm->Encoding ? ENC_SYMBOL : ENC_UGL;
   ULONG offset;
   char *id;
   char *pszStyle = NULL;

   if (ttm->usWeightClass < 500)
   {
      if (ttm->angle == 0)
      {
         pszStyle = "Regular";
      }
      else
      {
         pszStyle = "Italic";
      }
   }
   else
   {
      if (ttm->angle == 0)
      {
         pszStyle = "Bold";
      }
      else
      {
         pszStyle = "Bold Italic";
      }
   }

   /* Count the number of names. */
   if (ttm->copyright)
      count++;
   if (ttm->family)
      count++;
   if (pszStyle)
      count++;
   if (ttm->id) {
      count++;
      id = ttm->id;
   } else {
      id = ttm->name;
      count++;
   }
   if (ttm->fullname)
      count++;
   if (ttm->verstr)
      count++;
   if (ttm->name)
      count++;
   if (ttm->notice)
      count++;
   count *= 2;


   /* Write the name table. */
   offset = (ULONG)FileTell(file);
   WriteShort(VERSION0, file);
   WriteShort(count, file);
   WriteShort((USHORT)(6+count*12), file);

   /* Mac names */
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, COPYRIGHT,
		    ttm->copyright, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, FAMILY,
		    ttm->family, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, SUBFAMILY,
                    pszStyle, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, ID,
		    id, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, FULLNAME,
		    ttm->fullname, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, VERSION,
		    ttm->verstr, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, PSNAME,
		    ttm->name, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, NOTICE,
		    ttm->notice, stroff));

   /* MS names */
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, COPYRIGHT,
		    ttm->copyright, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, FAMILY,
		    ttm->family, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, SUBFAMILY,
                    pszStyle, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, ID,
		    id, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, FULLNAME,
		    ttm->fullname, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, VERSION,
		    ttm->verstr, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, PSNAME,
		    ttm->name, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, NOTICE,
		    ttm->notice, stroff));

   WriteNameString(file, PLT_MAC, ttm->copyright);
   WriteNameString(file, PLT_MAC, ttm->family);
   WriteNameString(file, PLT_MAC, pszStyle);
   WriteNameString(file, PLT_MAC, id);
   WriteNameString(file, PLT_MAC, ttm->fullname);
   WriteNameString(file, PLT_MAC, ttm->verstr);
   WriteNameString(file, PLT_MAC, ttm->name);
   WriteNameString(file, PLT_MAC, ttm->notice);

   WriteNameString(file, PLT_MS, ttm->copyright);
   WriteNameString(file, PLT_MS, ttm->family);
   WriteNameString(file, PLT_MS, pszStyle);
   WriteNameString(file, PLT_MS, id);
   WriteNameString(file, PLT_MS, ttm->fullname);
   WriteNameString(file, PLT_MS, ttm->verstr);
   WriteNameString(file, PLT_MS, ttm->name);
   WriteNameString(file, PLT_MS, ttm->notice);

   return CompleteTable((long)offset, TBL_NAME, file);
}



/***
** Function: BoundingBox
**
** Description:
**   Extend an already initialized rectangle (two points)
**   so that it encolses a number of coordinates.
***/
STATIC void BoundingBox(Point bbox[2],
			const Point *pts,
			const USHORT cnt)
{
   USHORT i;

   for (i=0; i<cnt; i++) {
      if (bbox[0].x > pts[i].x)
	 bbox[0].x = pts[i].x;
      if (bbox[1].x < pts[i].x)
	 bbox[1].x = pts[i].x;
      if (bbox[0].y > pts[i].y)
	 bbox[0].y = pts[i].y;
      if (bbox[1].y < pts[i].y)
	 bbox[1].y = pts[i].y;
   }
}



/***
** Function: RecordGlyph
**
** Description:
**   Record information about glyph record of the glyf table.
***/
STATIC errcode RecordGlyph(struct TTHandle *tt,
			   const struct encoding *code,
			   const Point *bbox,
			   const funit aw,
			   const USHORT pts,
			   const USHORT conts)
{
   errcode status;
   USHORT i;

   i = tt->count;

   /* Make sure that there is enough memory in the pool. */
   if (tt->count+1>=tt->maxcnt) {
      struct GlyphList *gl;

      if ((gl = Realloc(tt->pool,
			(size_t)(tt->maxcnt+GLYPHBUF)*
			sizeof(struct GlyphList)))==NULL) {
	 SetError(status=NOMEM);
	 return status;
      } else {
	 tt->maxcnt += GLYPHBUF;
	 tt->pool = gl;
      }
   }

   /* Record metrics. */
   tt->count++;
   tt->pool[i].pts = pts;
   tt->pool[i].conts = conts;
   tt->pool[i].lsb = bbox[0].x;
   tt->pool[i].aw = aw;
   tt->pool[i].bbox[0] = bbox[0];
   tt->pool[i].bbox[1] = bbox[1];
   tt->pool[i].code = code;
   tt->pool[i].offset = FileTell(tt->file) - 12L - (long)TBLDIRSIZE*NUMTBL;

   /* Update the global bounding box. */
   BoundingBox(tt->bbox, bbox, (short)2);

   /* Update maxp. */
   if (conts>tt->maxcontours)
      tt->maxcontours = conts;
   if (pts>tt->maxpts)
      tt->maxpts = pts;

   return SUCCESS;
}



/***
** Function: BuildMacCMAP
**
** Description:
**   Compute the CMAP subtable for the Mac.
***/
STATIC void BuildMacCMAP(const struct GlyphList *pool,
                         const USHORT count,
                         UBYTE *ascii2gi,
                         const struct encoding *encRoot,
                         const int encSize)
{
   const struct encoding *notdef = LookupNotDef();
   USHORT code;
   UBYTE i;

   /* Initiate the ascii to glyph-index array. Glyph 0 is the "notdef"
		character, so any unassigned character will be mapped to "notdef". */
   memset(ascii2gi, NOTDEFGLYPH, (unsigned int)MACSIZE);

   /* Build the ascii to glyph-index array. */
   if (encRoot==NULL)
   {
      for (i=2; i<MIN(255,count); i++)
      {
         if (pool[i].code!=NULL)
         {
            /* i = glyph index, Lookup..() = character code.
            Map glyph i only if it is a valid Mac character. */
            if (pool[i].code!=NULL &&
                (code = LookupCharCode(pool[i].code,ENC_MACCODES))!=NOTDEFCODE)
               ascii2gi[code] = i;
         }
      }
   }
   else
   {
      for (i=2; i<MIN(255,count); i++)
      {
         if (pool[i].code!=NULL && pool[i].code!=notdef)
         {
            const struct encoding *encGlyph;
            encGlyph = LookupFirstEnc(encRoot, encSize, pool[i].code);
            do
            {
               if ((code = LookupCharCode(encGlyph, ENC_MACCODES))!=NOTDEFCODE)
                  ascii2gi[code] = i;
            } while (encGlyph = LookupNextEnc(encRoot, encSize, encGlyph));
         }
      }
   }

   /* Constant Mac glyph/encoding mapping for standard encoded fonts */

   if (encRoot==NULL)
   {
      /* Missing glyphs. */
      for (i=1; i<=31; i++)
              ascii2gi[i] = NOTDEFGLYPH;
      ascii2gi[127] = NOTDEFGLYPH;

      /* Null glyphs. */
      ascii2gi[0] = 1;
      ascii2gi[8] = 1;
      ascii2gi[13] = 1;
      ascii2gi[29] = 1;

      /* No countours + positive advance width. */
      ascii2gi[9] = ascii2gi[32];
      ascii2gi[13] = ascii2gi[32];
      ascii2gi[202] = ascii2gi[32];
   }
}



/***
** Function: FreeMSEncoding
**
** Description:
**   Free resourses used while computing the CMAP subtable
**   for Windows.
***/
STATIC void FreeMSEncoding(struct MSEncoding *ms)
{
   if (ms->startCount)
      Free(ms->startCount);

   if (ms->gi)
      Free(ms->gi);
}



/***
** Function: BuildMSCMAP
**
** Description:
**   Compute the CMAP subtable for Windows.
***/
STATIC errcode BuildMSCMAP(const struct GlyphList *pool,
const  USHORT           count,
struct MSEncoding      *ms,
const  struct encoding *encRoot,
const  int              encSize
)
{
   USHORT *twobyte = NULL;
   USHORT idOffset;
   USHORT code, max;
   USHORT i, j, k, big, n;

   /* Get the range of the UGL characters. */
   max = 0;
   big = 0;

   if (encRoot==NULL)
   {
      for (i=2; i<count; i++)
      {
         if (pool[i].code!=NULL)
         {
            if ((code = LookupCharCode(pool[i].code, ENC_UNICODE))!=NOTDEFCODE)
            {
               if (code<=0xff)
               {
                  if (code>max)
                     max = code;
               }
               else
               {
                  big++;
               }
            }
         }
      }
   }
   else
   /* A non-standard encoded font, i.e. a fonts with an explicit
      encoding array may reference the same glyph more than once,
           though each glyph only refers to one encoding item. We have to
           enumerate through all code point for each glyph in this case.
   */
   {
      for (i=2; i<count; i++)
      {
         if (pool[i].code!=NULL)
         {
            const struct encoding *encGlyph = LookupFirstEnc(encRoot,
                                                             encSize,pool[i].code);
            do
            {
               if ((code = LookupCharCode(encGlyph, ENC_MACCODES))!=NOTDEFCODE)
               {
                  if (code>max)
                     max = code;
               }

            } while (encGlyph = LookupNextEnc(encRoot, encSize, encGlyph));
         }
      }
   }

   max++;
   max = (USHORT)(max + big);
   if ((ms->gi = Malloc(sizeof(USHORT)*max))==NULL) {
      return NOMEM;
   }
   memset(ms->gi, NOTDEFGLYPH, max*sizeof(USHORT));

   if (big && (twobyte = Malloc(sizeof(USHORT)*big))==NULL) {
      Free(ms->gi);
      ms->gi = NULL;
      return NOMEM;
   }
	
   j = 0;
   if (encRoot==NULL)
   {
      /* Glyph zero and Glyp one are the "notdef" and the "null" glyph,
              and are not encoded here, so skip the first two glyph.
      */
      for (i=2; i<count; i++)
      {
         code = LookupCharCode(pool[i].code, ENC_UNICODE);
         if (pool[i].code && code!=NOTDEFCODE)
         {
            if (code<=0xff)
            {
               ms->gi[code] = i;
            }
            else
            {
               for (k=0; k<j; k++)
                  if (twobyte[k]>code)
                     break;
               for (n=j; n>k; n--)
               {
                  twobyte[n] = twobyte[n-1];
                  ms->gi[max-big+n] = ms->gi[max-big+n-1];
               }
               twobyte[k] = code;
               ms->gi[max-big+k] = i;
               j++;
            }
         }
      }
   }
   else
   {
      for (i=2; i<count; i++)
      {
         const struct encoding *encGlyph;

         if (pool[i].code)
         {
            encGlyph = LookupFirstEnc(encRoot, encSize, pool[i].code);
            do
            {
               if ((code = LookupCharCode(encGlyph, ENC_MACCODES))!=NOTDEFCODE)
               {
                  ms->gi[code] = i;
               }
            } while (encGlyph = LookupNextEnc(encRoot, encSize, encGlyph));
         }
      }
   }

   /* Count the segments. */
   ms->segCount=(USHORT)(2+big);
   for (i=0; i<max-big-1; i++) {
      if (ms->gi[i]!=NOTDEFGLYPH && ms->gi[i+1]==NOTDEFGLYPH) {
	 ms->segCount++;
      }
   }

   ms->startCount = Malloc(3 * (sizeof(USHORT)*ms->segCount));

   if (ms->startCount==NULL) {
      if (twobyte)
	 Free(twobyte);
      FreeMSEncoding(ms);
      return NOMEM;
   }

   ms->endCount =  (USHORT *)((char *)ms->startCount + sizeof(USHORT)*ms->segCount);
   ms->idOffsets = (USHORT *)((char *)ms->endCount +  sizeof(USHORT)*ms->segCount);

   /* i=UGL index, j=segment index, k=glyph index. */
   for (i=0, j=0, k=0; i<max-big; i++) {
      if (ms->gi[i]!=NOTDEFGLYPH) {
	 if (i==0 || (ms->gi[i-1]==NOTDEFGLYPH)) {
	    ms->startCount[j] = i;
	    ms->idOffsets[j] = (USHORT)((ms->segCount-j+k)*2);
	 }
	 if ((i==max-1-big) || (ms->gi[i+1]==NOTDEFGLYPH)) {
	    ms->endCount[j] = i;
	    j++;
	 }
	 k++;
      }
   }

   /* Segment for the double byte characters. */
   idOffset = (USHORT)((ms->segCount-j+k)*2);
   for (i=0; i<big; i++) {
      ms->startCount[j] = twobyte[i];
      ms->idOffsets[j] = idOffset;
      ms->endCount[j] = twobyte[i];
      k++;
      j++;
   }

   ms->giCount = k;
   ms->giMax = max;

   /* Sentinel segments. */
   ms->startCount[ms->segCount-1] = 0xffff;
   ms->endCount[ms->segCount-1] = 0xffff;
   ms->idOffsets[ms->segCount-1] = 0;

   if (twobyte)
      Free(twobyte);

   return SUCCESS;
}



/***
** Function: PutCMAP
**
** Description:
**   This function writes the required 'cmap' table to the
**   TT font file.
***/
STATIC errcode PutCMAP(
struct TTHandle *tt,
UBYTE *ascii2gi,
const struct encoding *enc,
const int encSize)
{
   struct MSEncoding ms;
   long end, offset;
   errcode status = SUCCESS;
   USHORT i;
   USHORT usBias = (USHORT)(enc ? 0xf000 : 0); // bias for the first glyph

   /* Build Mac encoding table. */
   BuildMacCMAP(tt->pool, tt->count, ascii2gi, enc, encSize);


   /* Build MS encoding table. */
   if ((status = BuildMSCMAP(tt->pool, tt->count, &ms, enc, encSize))!=SUCCESS)
      return status;

   offset = FileTell(tt->file);

   /* Write cmap table. */
   WriteShort(VERSION0, tt->file);
   WriteShort(NUM_CMAPS, tt->file);

   /*== CMAP table directory ==*/
   WriteShort(PLT_MAC, tt->file);
   WriteShort(ENC_ROMAN, tt->file);
   WriteLong(0L, tt->file);
   WriteShort(PLT_MS, tt->file);
   WriteShort((USHORT)(enc ? ENC_SYMBOL : ENC_UGL), tt->file);
   WriteLong(0L, tt->file);

   /* Standard apple encoding. */
   end = FileTell(tt->file);
   (void)FileSeek(tt->file, offset+8);
   WriteLong((ULONG)(end-offset), tt->file);
   (void)FileSeek(tt->file, end);
   WriteShort((USHORT)0, tt->file);
   WriteShort((USHORT)(2+2+2+MACSIZE), tt->file);
   WriteShort((USHORT)0, tt->file);
   (void)WriteBytes(ascii2gi, MACSIZE, tt->file);

   /* Long word align the subtable. */
   end = FileTell(tt->file);
   if ((end-offset)%4)
      for (i=0; (short)i<(4-((end-offset)%4)); i++)
	 WriteByte(0, tt->file);


   /* MS delta encoding. */
   end = FileTell(tt->file);
   (void)FileSeek(tt->file, offset+16);
   WriteLong((ULONG)(end-offset), tt->file);
   (void)FileSeek(tt->file, end);

   /* format */
   WriteShort(SEGMENT_MAP, tt->file);
   /* length */
   WriteShort((USHORT)(16+ms.segCount*(2+2+2+2)+ms.giCount*2), tt->file);
   /* version */
   WriteShort(VERSION0, tt->file);
   /* 2*segCount */
   WriteShort((USHORT)(ms.segCount*2), tt->file);
   /* searchRange */
   WriteShort(SearchRange(ms.segCount), tt->file);
   /* entrySelector */
   WriteShort(EntrySelector(ms.segCount), tt->file);
   /* rangeShift */
   WriteShort(RangeShift(ms.segCount), tt->file);

   /* endCount */

   for (i=0; i<ms.segCount; i++)
      WriteShort((USHORT)(ms.endCount[i] | usBias), tt->file);

   WriteShort(PAD0, tt->file);

   /* startCount */
   for (i=0; i<ms.segCount; i++)
      WriteShort((USHORT)(ms.startCount[i] | usBias), tt->file);

   /* idDelta */
   for (i=0; i<ms.segCount; i++)
      WriteShort(PAD0, tt->file);

   /* rangeOffsets */
   for (i=0; i<ms.segCount; i++)
      WriteShort(ms.idOffsets[i], tt->file);

   for (i=0; i<ms.giMax; i++)
      if (ms.gi[i]!=NOTDEFGLYPH)
	 WriteShort(ms.gi[i], tt->file);


   /* Free resources. */
   FreeMSEncoding(&ms);

   return CompleteTable(offset, TBL_CMAP, tt->file);
}




/***** FUNCTIONS */


/***
** Function: TypographicalAscender
**
** Description:
**   Compute the typographical ascender height, as ymax of
**   the letter 'b'.
***/
funit TypographicalAscender(const struct TTHandle *tt)
{
   USHORT i;
   funit height = 0;

   for (i=0; (i<tt->count) && height==0; i++) {
      if (tt->pool[i].code &&
	  !strcmp(LookupCharName(tt->pool[i].code), "b"))
	 height = tt->pool[i].bbox[1].y;
   }

   return height;
}



/***
** Function: TypographicalDescender
**
** Description:
**   Compute the typographical descender height, as ymin of
**   the letter 'g'.
***/
funit TypographicalDescender(const struct TTHandle *tt)
{
   USHORT i;
   funit height = 0;

   for (i=0; i<tt->count && height==0; i++) {
      if (tt->pool[i].code &&
	  !strcmp(LookupCharName(tt->pool[i].code), "g"))
	 height = tt->pool[i].bbox[0].y;
   }

   return height;
}



/***
** Function: WindowsBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Windows character set.
***/


#ifdef NOT_NEEDED_ON_NT


void WindowsBBox(const struct TTHandle *tt, Point *bbox)
{
   USHORT i;
   funit height = 0;

   bbox[0].x = bbox[0].y = SHRT_MAX;
   bbox[1].x = bbox[1].y = SHRT_MIN;
   for (i=0; i<tt->count && height==0; i++) {
      if (tt->pool[i].code && LookupCharCode(tt->pool[i].code,
					     ENC_MSWINDOWS)) {
	 BoundingBox(bbox, tt->pool[i].bbox, (USHORT)2);
      }
   }
}

#endif

/***
** Function: MacBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Mac character set.
**
**   This is currently set to the global bounding box
**   (tt->bbox) of all characters in the font. This will
**   ensure that accents are not sqeezed on Mac platforms.
***/
void MacBBox(const struct TTHandle *tt, Point *bbox)
{
   bbox[0] = tt->bbox[0];
   bbox[1] = tt->bbox[1];
}


void GlobalBBox(const struct TTHandle *tt, Point *bbox)
{
   bbox[0] = tt->bbox[0];
   bbox[1] = tt->bbox[1];
}







/***
** Function: InitTTOutput
**
** Description:
**   This function allocates the resources needed to
**   write a TT font file.
***/
errcode InitTTOutput(const struct TTArg *arg, struct TTHandle **tt)
{
   errcode status = SUCCESS;

   /* Allocate resources. */
   if (((*tt)=Malloc(sizeof(struct TTHandle)))==NULL) {
      SetError(status = NOMEM);
   } else {

      /* Initiate. */
      memset((*tt), '\0', sizeof(**tt));

      /* Open the file. */
      if (((*tt)->file=OpenOutputFile(arg->name))==NULL) {
	 SetError(status = BADOUTPUTFILE);
      } else {

	 /* Allocate space for glyph records. */
	 if (((*tt)->pool
	      = Malloc(sizeof(struct GlyphList)*GLYPHBUF))==NULL) {
	    SetError(status = NOMEM);
	 } else {

	    /* Initiate. */
	    (*tt)->bbox[0].x = (*tt)->bbox[0].y = SHRT_MAX;
	    (*tt)->bbox[1].x = (*tt)->bbox[1].y = SHRT_MIN;
	    (*tt)->count = 0;
	    (*tt)->maxcnt = GLYPHBUF;
	    (*tt)->maxcontours = 0;
	    (*tt)->maxpts = 0;
	    (*tt)->maxcompelements = 0;
	    (*tt)->maxtwilight = 0;

	    /* Write header. */
	    WriteTableHeader((*tt)->file);

	    /* Check error condition. */
	    if (FileError((*tt)->file))
	       status = BADOUTPUTFILE;
	 }
      }
   }

   return status;
}



/***
** Function: FreeTTMetrics
**
** Description:
**   This function free's the resources used to represent
**   TT specific metrics and auxiliary font information.
***/
void FreeTTMetrics(struct TTMetrics *ttm)
{
   if (ttm->verstr)
      Free(ttm->verstr);
   if (ttm->cvt)
      Free(ttm->cvt);
   if (ttm->widths)
      Free(ttm->widths);
   if (ttm->prep)
      Free((UBYTE *)ttm->prep);
}



/***
** Function: CleanUpTT
**
** Description:
**   This function free's the resources used while
**   writing a TT font file.
***/
errcode CleanUpTT(struct TTHandle *tt,
		  const struct TTArg *ttarg,
		  const errcode status)
{
   errcode rc = SUCCESS;

   if (tt) {
      if (tt->file)
	 rc = CloseOutputFile(tt->file);

      /* Nuke the output file? */
      if (status!=SUCCESS || rc!=SUCCESS)
	 RemoveFile(ttarg->name);

      if (tt->pool)
	 Free(tt->pool);
      Free(tt);
   }

   return rc;
}



/***
** Function: FreeTTGlyph
**
** Description:
**   This function will free the memory used to represent a
**   a TrueType glyph.
**
***/
void FreeTTGlyph(struct TTGlyph *glyph)
{
   Outline *path = NULL;

   /* Free the memory. */
   if (glyph) {
      while (glyph->paths) {
	 path = glyph->paths->next;
	 Free(glyph->paths->pts);
	 Free(glyph->paths->onoff);
	 Free(glyph->paths);
	 glyph->paths = path;
      }
      if (glyph->hints)
	 Free(glyph->hints);
      Free(glyph);
   }
}



/***
** Function: PutTTNotDefGlyph
**
** Description:
**   This function adds a record for a the ".notdef" glyph to the
**   'glyf' table of the TT font file.
**
***/
errcode PutTTNotDefGlyph(struct TTHandle *tt, const struct TTGlyph *glyph)
{
   struct TTGlyph ttg;
   long end = FileTell(tt->file);
   errcode status = SUCCESS;
   USHORT oldcount = tt->count;
   Outline *path;
   int conts = 0;
   int size = 0;
   int cnt = 0;


   /* Determine if there is enough room. */
   for (path=glyph->paths; path; path=path->next) {
      cnt += path->count;
      conts += 1;
   }
   size = cnt * sizeof(Point) +     /* coordinates */
	  conts * sizeof(short) +   /* end points */
	  glyph->num +              /* instructions */
	  cnt * sizeof(char) * 2;   /* flag bytes */

   ttg = *glyph;
   if (size > MAXNOTDEFSIZE) {
      ttg.num = 0;
      ttg.stack = 0;
      ttg.twilights = 0;
      ttg.hints = NULL;
      if (size - glyph->num > MAXNOTDEFSIZE) {
	 ttg.paths = NULL;
      }
   }


   /* Move back to glyph #0, i.e. the missing glyph. */
   tt->count = 0;
   (void)FileSeek(tt->file,
						tt->pool[NOTDEFGLYPH].offset+12L+(long)TBLDIRSIZE*NUMTBL);
   status = PutTTGlyph(tt, &ttg, FALSE);
   tt->count = oldcount;
   (void)FileSeek(tt->file, end);

   /* Missing outline? */
   if (ttg.paths==NULL)
      tt->pool[NOTDEFGLYPH].offset = tt->pool[NULLGLYPH].offset;

   return status;
}


/***
** Function: PutTTGlyph
**
** Description:
**   This function adds a record for a simple glyph to the
**   'glyf' table of the TT font file.
**
***/
errcode PutTTGlyph(struct TTHandle *tt, const struct TTGlyph *glyph,
						 const boolean fStdEncoding)
{
   errcode status = SUCCESS;
   UBYTE flag, prev, cnt;
   USHORT i, c, n = 0;
   Outline *path;
   Point bbox[2];
   funit x, y;


   if (glyph!=NULL) {

#ifdef DOT
      /* Replace the '.' character. */
      if (LookupCharCode(glyph->code, ENC_STANDARD)==0x2e) {
         STATIC struct TTGlyph marker;
         STATIC Outline box;
         STATIC ULONG onoff[1];
         STATIC Point pts[4];
         STATIC UBYTE xleading[] = {
	    0x00,
	    0xb9, 0, 3, 0, 0,
	    0x38,    /* SHPIX[], 4, 640 */
	 };


	 marker = *glyph;
	 glyph = &marker;
	 marker.paths = &box;
	 marker.num = sizeof(xleading);
	 marker.hints = xleading;
	 box.next = NULL;
	 box.count = 4;
	 box.onoff = &onoff[0];
	 onoff[0] = 0;
	 box.pts = pts;
	 pts[0].x = 200; pts[0].y = 1400;
	 pts[1].x = 600; pts[1].y = 1400;
	 pts[2].x = 600; pts[2].y = 1800;
	 pts[3].x = 200; pts[3].y = 1800;
      }
#endif

      /* Update maxp */
      if (glyph->num>tt->maxinstructions)
	 tt->maxinstructions = glyph->num;
      if (glyph->stack>tt->maxstack)
	 tt->maxstack = glyph->stack;
      if (glyph->twilights>tt->maxtwilight)
	 tt->maxtwilight = glyph->twilights;

      if (glyph->paths==NULL) {
	 bbox[0].x = bbox[1].x = glyph->lsb;
	 bbox[0].y = bbox[1].y = 0;

	 status=RecordGlyph(tt, glyph->code, bbox,
			    glyph->aw, (USHORT)0, (USHORT)0);
      } else {

	 /* Compute header information. */
	 bbox[0].x = bbox[0].y = SHRT_MAX;
	 bbox[1].x = bbox[1].y = SHRT_MIN;
	 for (c=0, path=glyph->paths; path; path=path->next, c++) {
	    BoundingBox(bbox, path->pts, path->count);
	    n = (USHORT)(n + path->count);
	 }

	 /* Record loca and cmap info. */
	 if ((status=RecordGlyph(tt, glyph->code, bbox,
				 glyph->aw, n, c))==SUCCESS) {

	    /* Write number of contours. */
	    WriteShort(c, tt->file);

	    /* Write bounding box. */
	    if (c) {
	       WriteShort((USHORT)bbox[0].x, tt->file);
	       WriteShort((USHORT)bbox[0].y, tt->file);
	       WriteShort((USHORT)bbox[1].x, tt->file);
	       WriteShort((USHORT)bbox[1].y, tt->file);
	    } else {
	       WriteShort(PAD0, tt->file);
	       WriteShort(PAD0, tt->file);
	       WriteShort(PAD0, tt->file);
	       WriteShort(PAD0, tt->file);
	    }

	    /* Write endPts */
	    for (c=0, path=glyph->paths; path; path=path->next) {
	       c = (USHORT)(c + path->count);
	       WriteShort((short)(c-1), tt->file);
	    }

	    /* Write instruction length. */
	    WriteShort(glyph->num, tt->file);

	    /* Write instruction. */
	    (void)WriteBytes(glyph->hints, glyph->num, tt->file);


	    /* Write the flags. */
	    x=0; y=0;
	    prev = 255;
	    cnt = 0;
	    for (path=glyph->paths; path; path=path->next) {
	       for (i=0; i<path->count; i++) {
		  flag = 0;
		  if (OnCurve(path->onoff, i))
		     flag |= FLG_ONCURVE;

		  if (path->pts[i].x==x) {
		     flag |= FLG_SAMEX;
		  } else if (ABS(path->pts[i].x - x) <= 255) {
		     flag |= FLG_SHORTX;
		     if (path->pts[i].x > x)
			flag |= FLG_SAMEX;
		  }

		  if (path->pts[i].y==y) {
		     flag |= FLG_SAMEY;
		  } else if (ABS(path->pts[i].y - y) <= 255) {
		     flag |= FLG_SHORTY;
		     if (path->pts[i].y > y)
			flag |= FLG_SAMEY;
		  }

		  x = path->pts[i].x;
		  y = path->pts[i].y;
		  if (prev!=255) {
		     if (prev!=flag) {
			if (cnt) {
			   prev |= FLG_REPEAT;
			   WriteByte(prev, tt->file);
			   WriteByte(cnt, tt->file);
			} else {
			   WriteByte(prev, tt->file);
			}
			cnt = 0;
		     } else {
			cnt ++;
		     }
		  }
		  prev = flag;
	       }
	    }
	    if (cnt) {
	       prev |= FLG_REPEAT;
	       WriteByte(prev, tt->file);
	       WriteByte(cnt, tt->file);
	    } else {
	       WriteByte(prev, tt->file);
	    }


	    /* Write the x's */
	    x = 0;
	    for (path=glyph->paths; path; path=path->next) {
	       for (i=0; i<path->count; i++) {
		  if (path->pts[i].x != x) {
		     funit dx = path->pts[i].x - x;
		     if (ABS(dx)<=255) {
			WriteByte((UBYTE)ABS(dx), tt->file);
		     } else {
			WriteShort((USHORT)dx, tt->file);
		     }
		  }
		  x = path->pts[i].x;
	       }
	    }

	    /* Write the y's */
	    y = 0;
	    for (path=glyph->paths; path; path=path->next) {
	       for (i=0; i<path->count; i++) {
		  if (path->pts[i].y != y) {
		     funit dy = path->pts[i].y - y;
		     if (ABS(dy)<=255) {
			WriteByte((UBYTE)ABS(dy), tt->file);
		     } else {
			WriteShort((USHORT)dy, tt->file);
		     }
		  }
		  y = path->pts[i].y;
	       }
	    }


	    /* Word align the glyph entry. */
	    if (FileTell(tt->file) & 1)
	       WriteByte(0, tt->file);

	    /* Poll the file status. */
	    if (FileError(tt->file))
	       status = FAILURE;
	 }
      }


      /* Check for aliases. */
		if (fStdEncoding)
		{
			if (LookupCharCode(glyph->code, ENC_UNICODE)==0x20) {
				struct TTGlyph nobreak;

				nobreak = *glyph;
				nobreak.code = LookupPSName(NULL, 0, "nbspace");
				PutTTGlyph(tt, &nobreak, FALSE);
			}
			if (LookupCharCode(glyph->code, ENC_UNICODE)==0x2d) {
				struct TTGlyph sfthyphen;

				sfthyphen = *glyph;
				sfthyphen.code = LookupPSName(NULL, 0, "sfthyphen");
				PutTTGlyph(tt, &sfthyphen, FALSE);
			}
		}
   }

   return status;
}




/***
** Function: PutTTOther
**
** Description:
**   This function writes the required TT tables to the
**   TT font file, except for the 'glyf' table which is
**   only completed (check sum is computed, etc.).
**
***/
errcode PutTTOther(struct TTHandle *tt, struct TTMetrics *ttm)
{
   long offset = TBLDIRSIZE*NUMTBL+12;
   errcode status = SUCCESS;
   UBYTE ascii2gi[MACSIZE];
   errcode err = SUCCESS;
   short locafmt = 0;
   long csum = 0;


   /*==GLYF===*/
   tt->pool[tt->count].offset = FileTell(tt->file) - offset;
   err = CompleteTable(offset, TBL_GLYF, tt->file);


   /*==CMAP===*/
   if (err==SUCCESS)
      err = PutCMAP(tt, ascii2gi, ttm->Encoding, ttm->encSize);


   /*==LOCA===*/
   if (err==SUCCESS)
      err = PutLOCA(tt->file, tt->pool, tt->count, &locafmt);


   /*==HEAD===*/
   if (err==SUCCESS)
      err = PutHEAD(tt->file, tt->bbox, ttm, locafmt, &csum);


   /*==HHEA===*/
   if (err==SUCCESS)
      err = PutHHEA(tt->file, tt->pool, tt->count,
                    tt->bbox, ttm->macLinegap, ttm);


   /*==HMTX===*/
   if (err==SUCCESS)
      err = PutHMTX(tt->file, tt->pool, tt->count,
                    ttm->widths, ttm->FirstChar, ttm->LastChar,ttm->Encoding);


   /*==OS/2===*/
   if (err==SUCCESS)
      err = PutOS2(tt->file, tt->pool, tt->count, ttm);


   /*==MAXP===*/
   if (err==SUCCESS)
      err = PutMAXP(tt, ttm->maxstorage, ttm->maxprepstack, ttm->maxfpgm);


   /*==Name===*/
   if (err==SUCCESS)
      err = PutNAME(tt->file, ttm);


   /*==POST===*/
   if (err==SUCCESS)
      err = PutPOST(tt->file, tt->pool, tt->count, ttm);

   /*==PREP===*/
   if (err==SUCCESS)
      err = PutPREP(tt->file,
		    ttm->prep, ttm->prep_size);

   /*==FPGM===*/
   if (err==SUCCESS)
      err = PutFPGM(tt->file,
		    ttm->fpgm, ttm->fpgm_size);

   /*==CVT===*/
   if (err==SUCCESS)
      err = PutCVT(tt->file, ttm->cvt, ttm->cvt_cnt);


   /*==GASP==*/
   if (err==SUCCESS)
      err = PutGASP(tt->file, ttm->onepix);


   if (ttm->kerns && (err==SUCCESS))
      err = PutKERN(tt->file, ttm->kerns, ttm->kernsize, tt->pool, tt->count);


   /*=====*/
   /* Compute check sum. */
   if (err==SUCCESS) {
      WriteChecksum(csum, tt->file);
      if (FileError(tt->file))
	 err = BADOUTPUTFILE;
   }


   if (err != SUCCESS)
      SetError(status = err);

   return status;
}




/***
** Function: PutTTComposite
**
** Description:
**
***/
errcode PutTTComposite(struct TTHandle *tt, struct TTComposite *comp)
{
   errcode status;
   Point bbox[2], pts[2];
   USHORT ai=0, bi=0, oi=0;
   USHORT n,c;

   /* Convert the encoding handles to glyph indices. */
   while (ai<tt->count && comp->aenc!=tt->pool[ai].code)
      ai++;
   while (bi<tt->count && comp->benc!=tt->pool[bi].code)
      bi++;
   if (comp->oenc) {
      while (oi<tt->count && comp->oenc!=tt->pool[oi].code)
	 oi++;
   }

   /* Update the bounding box. */
   comp->dx += tt->pool[bi].bbox[0].x - tt->pool[ai].bbox[0].x;
   bbox[0] = tt->pool[bi].bbox[0]; bbox[1] = tt->pool[bi].bbox[1];
   pts[0] = tt->pool[ai].bbox[0]; pts[1] = tt->pool[ai].bbox[1];
   pts[0].x += comp->dx; pts[1].x += comp->dx;
   pts[0].y += comp->dy; pts[1].y += comp->dy;
   BoundingBox(bbox, pts, (USHORT)2);
   bbox[0].x = tt->pool[bi].bbox[0].x; bbox[1].x = tt->pool[bi].bbox[1].x;
   if (comp->oenc)
      BoundingBox(bbox, tt->pool[oi].bbox, (USHORT)2);

   if ((status=RecordGlyph(tt, comp->cenc, bbox,
			   comp->aw, (USHORT)0, (USHORT)0))==FAILURE)
      return status;

   /* Update max composite points/contours/elements. */
   n = (USHORT)(tt->pool[bi].pts + tt->pool[ai].pts);
   c = (USHORT)(tt->pool[bi].conts + tt->pool[ai].conts);
   if (n>tt->maxcomppts)
      tt->maxcomppts = n;
   if (c>tt->maxcompcont)
      tt->maxcompcont = c;
   if (comp->oenc)
      tt->maxcompelements = 3;
   else if (tt->maxcompelements<2)
      tt->maxcompelements = 2;


   /* Write number of contours. */
   WriteShort((USHORT)-1, tt->file);

   /* Write bounding box. */
   WriteShort((USHORT)bbox[0].x, tt->file);
   WriteShort((USHORT)bbox[0].y, tt->file);
   WriteShort((USHORT)bbox[1].x, tt->file);
   WriteShort((USHORT)bbox[1].y, tt->file);

   /* Write flags. */
   WriteShort((USHORT)(MORE_COMPONENTS |
		       ARGS_ARE_XY_VALUES |
		       ROUND_XY_TO_GRID),
	      tt->file);

   /* Write base glyph index. */
   WriteShort(bi, tt->file);
   WriteByte(0, tt->file);
   WriteByte(0, tt->file);

   if (comp->oenc) {
      WriteShort((USHORT)(MORE_COMPONENTS |
			  ARGS_ARE_XY_VALUES |
			  ROUND_XY_TO_GRID),
		 tt->file);
      WriteShort(oi, tt->file);
      WriteByte(0, tt->file);
      WriteByte(0, tt->file);
   }

   WriteShort((USHORT)(ARGS_1_2_ARE_WORDS |
		       ARGS_ARE_XY_VALUES |
		       ROUND_XY_TO_GRID),
	      tt->file);
   WriteShort(ai, tt->file);
   WriteShort((USHORT)comp->dx, tt->file);
   WriteShort((USHORT)comp->dy, tt->file);

   /* Word align the glyph entry. */
   if (FileTell(tt->file) & 1)
      WriteByte(0, tt->file);

   if (FileError(tt->file))
      return FAILURE;
   return SUCCESS;
}




/***
** Function: GetPrep
**
** Description:
**   This function allocates needed space for the
**   pre-program.
**
***/
UBYTE *GetPrep(const int size)
{
   return Malloc((size_t)size);
}


/***
** Function: UsePrep
**
** Description:
**   This function records the pre-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**
***/
void UsePrep(struct TTMetrics *ttm,
	     const UBYTE *prep,
	     const USHORT prep_size)
{
   ttm->prep = (UBYTE *)prep;
   ttm->prep_size = prep_size;
}

/***
** Function: SetFPGM
**
** Description:
**   This function records the font-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**
***/
void SetFPGM(struct TTMetrics *ttm,
	     const UBYTE *fpgm,
	     const USHORT fpgm_size,
	     const USHORT num)
{
   ttm->fpgm = fpgm;
   ttm->fpgm_size = fpgm_size;
   ttm->maxfpgm = num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\charstr.c ===
/***
 **
 **   Module: CharStr
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contain one function that interprets the commands in a T1
 **    CharString and builds a representation of the glyph for the
 **    it.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/
    

/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "metrics.h"
#include "encoding.h"
#include "safemem.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "charstr.h"



/***** CONSTANTS */
#define MAXSTACK  24

#define BUFMARGIN    256

/* Known OtherSubr entries. */
#define HINT_END_FLEX      0
#define HINT_START_FLEX    1
#define HINT_MID_FLEX      2
#define HINT_REPLACEMENT   3


#define PSOP_HSTEM         1
#define PSOP_VSTEM         3
#define PSOP_VMOVETO       4
#define PSOP_RLINETO       5
#define PSOP_HLINETO       6
#define PSOP_VLINETO       7
#define PSOP_RRCURVETO     8
#define PSOP_CLOSEPATH     9
#define PSOP_CALLSUBR      10
#define PSOP_RETURN        11
#define PSOP_ESCAPE        12
#  define PSOP_DOTSECTION        0
#  define PSOP_VSTEM3            1
#  define PSOP_HSTEM3            2
#  define PSOP_SEAC              6
#  define PSOP_SBW               7
#  define PSOP_DIV               12
#  define PSOP_CALLOTHERSUBR     16
#  define PSOP_POP               17
#  define PSOP_SETCURRENTPOINT   33
#define PSOP_HSBW          13
#define PSOP_ENDCHAR       14
#define PSOP_RMOVETO       21
#define PSOP_HMOVETO       22
#define PSOP_VHCURVETO     30
#define PSOP_HVCURVETO     31




/***** LOCAL TYPES */
/* Referenced types. */
typedef struct PSState {
   long stack[MAXSTACK+2];
   Point *pts;
   ULONG *onoff;
   USHORT totpts;
   USHORT numpts;
   USHORT ptr;
   short hr;
   USHORT maxpts;
   USHORT flex;
   Point flexref;
	int calls;
	long otherargs[16];
	USHORT otherptr;
} PSState;



/***** MACROS */
#define AddPoint(ps, px, py) {ps->pts[ps->numpts].x = px;\
                              ps->pts[ps->numpts].y = py;\
                              ps->numpts++;}
#define CurrXPoint(ps)        ps->pts[ps->numpts-1].x
#define CurrYPoint(ps)        ps->pts[ps->numpts-1].y
#define PrevPoint(ps, index)  ps->pts[ps->numpts-1-index]

#define PushStack(v)    ps->stack[(ps->ptr)++] = (v)
#define PopStack()      ps->stack[--(ps->ptr)]




/***** STATIC FUNCTIONS */

/***
 ** Function: AddCSpline
 **
 ** Description:
 **   Record a cubic spline.
 **
 ***/
static void AddCSpline(PSState *ps,
                       const funit x1, const funit y1,
                       const funit x2, const funit y2,
                       const funit x3, const funit y3)
{
   SetOffPoint(ps->onoff, ps->numpts);
   AddPoint(ps, x1, y1);
   SetOffPoint(ps->onoff, ps->numpts);
   AddPoint(ps, x2, y2);
   SetOnPoint(ps->onoff, ps->numpts);
   AddPoint(ps, x3, y3);
}


/***
** Function: HintReplacement
**
** Description:
**   This function limits the range of points which are
**   affected by stem hints. It may be invoked by the 
**   "dotsection" and the more general hint replacement
**   mechanism found in T1 fonts.
***/
static void HintReplacement(T1Glyph *glyph, const short hr)
{
   Stem *stem;
   Stem3 *stem3;

   /* Dead stem hints?, e.g. replaced before ever used? */
   if (hr==ENDOFPATH) {
      for (stem=glyph->hints.hstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = NORANGE;
      for (stem=glyph->hints.vstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = NORANGE;
      for (stem3=glyph->hints.hstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = NORANGE;
            stem3->stem2.i2 = NORANGE;
            stem3->stem3.i2 = NORANGE;
         }
      }
      for (stem3=glyph->hints.vstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = NORANGE;
            stem3->stem2.i2 = NORANGE;
            stem3->stem3.i2 = NORANGE;
         }
      }

   /* Set the end-point for the stem hints that are replaced. */
   } else {

      for (stem=glyph->hints.hstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = hr;
      for (stem=glyph->hints.vstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = hr;
      for (stem3=glyph->hints.hstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = hr;
            stem3->stem2.i2 = hr;
            stem3->stem3.i2 = hr;
         }
      }
      for (stem3=glyph->hints.vstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = hr;
            stem3->stem2.i2 = hr;
            stem3->stem3.i2 = hr;
         }
      }
   }
}   


/***
** Function: NewFlex
**
** Description:
**   This function records a new flex hint for
**   the current glyph.
***/
static Flex *NewFlex(const Point ref,
                     const Point midpos,
                     const Point startpos,
                     const USHORT start,
                     const USHORT mid,
                     const USHORT end,
                     const funit civ)

{
   Flex *flex = NULL;

   if ((flex = Malloc(sizeof(Flex)))!=NULL) {
      flex->civ = civ;
      flex->pos = ref;
      flex->midpos = midpos;
      flex->startpos = startpos;
      flex->start = start;
      flex->mid = mid;
      flex->end = end;
   }

   return flex;
}



/***
** Function: NewStem
**
** Description:
**   This function records a new stem hint for
**   the current glyph.
***/
static Stem *NewStem(const funit offset,
                     const funit width,
                     const short hr)
{
   Stem *stem = NULL;

   if ((stem = Malloc(sizeof(Stem)))!=NULL) {
      if (width>0) {
         stem->offset = offset;
         stem->width = width;
      } else {
         stem->offset = offset+width;
         stem->width = -width;
      }
      stem->i1 = hr;
      stem->i2 = ENDOFPATH;
   }

   return stem;
}



/***
** Function: NewStem3
**
** Description:
**   This function records a new stem3 hint for the current glyph.
***/
static Stem3 *NewStem3(const funit o1, const funit w1,
                       const funit o2, const funit w2,
                       const funit o3, const funit w3,
                       const short hr)
{
   Stem3 *stem3 = NULL;

   if ((stem3 = Malloc(sizeof(Stem3)))!=NULL) {

      stem3->stem1.offset = o1;
      stem3->stem1.width = w1;
      stem3->stem1.i1 = hr;
      stem3->stem1.i2 = ENDOFPATH;

      stem3->stem2.offset = o2;
      stem3->stem2.width = w2;
      stem3->stem2.i1 = hr;
      stem3->stem2.i2 = ENDOFPATH;

      stem3->stem3.offset = o3;
      stem3->stem3.width = w3;
      stem3->stem3.i1 = hr;
      stem3->stem3.i2 = ENDOFPATH;
   }

   return stem3;
}



/***
** Function: NewPath
**
** Description:
**   This function adds a new contour to the current glyph.
***/
static errcode NewPath(T1Glyph *glyph,
                       const Point *pts,
                       ULONG *onoff,
                       const USHORT numpts)
{
   errcode status = SUCCESS;
   Outline *path;
   Outline *prev;

   /* Skip 1,2 point paths. */
   if (numpts>2) {
      if ((path=Malloc(sizeof(Outline)))==NULL) {
         SetError(status = NOMEM);
      } else {

         path->pts=Malloc(sizeof(Point)*numpts);
         path->onoff=Malloc(ONOFFSIZE(numpts));
         if (path->pts==NULL || path->onoff==NULL) {
            if (path->pts)
               Free(path->pts);
            if (path->onoff)
               Free(path->onoff);
            Free(path);
            return NOMEM;
         }

         /* Initiate the new sub-path. */
         memcpy(path->pts, pts, sizeof(Point)*numpts);
         memcpy(path->onoff, onoff, ONOFFSIZE(numpts));
         path->count = numpts;

         /* Link it in. */
         path->next = NULL;
         if (glyph->paths==NULL) {
            glyph->paths = path;
         } else {
            for (prev = glyph->paths; prev->next; prev=prev->next);
            prev->next = path;
         }
      }
   }

   return status;
}



/***** FUNCTIONS */

/***
** Function: AllocPSState
**
** Description:
**   This function allocates the workspace
**   used by the t1 parser.
***/
struct PSState *AllocPSState(void)
{
   struct PSState *ps;

   if ((ps = Malloc(sizeof(struct PSState)))!=NULL) {
      memset(ps, '\0', sizeof(struct PSState));
   }

   return ps;      
}


/***
** Function: FreePSState
**
** Description:
**   This function frees the workspace
**   used by the t1 parser.
***/
void FreePSState(struct PSState *ps)
{
   if (ps) {
      if (ps->onoff)
         Free(ps->onoff);
      if (ps->pts)
         Free(ps->pts);
   }

   Free(ps);
}


/***
** Function: InitPS
**
** Description:
**   This function initiate the workspace
**   used by the t1 parser.
***/
void InitPS(struct PSState *ps)
{
   ps->hr = 0;
   ps->totpts = 0;
   ps->ptr = 0;
	ps->calls = 0;
}


/***
** Function: ParseCharString
**
** Description:
**   This function parses a CharString and builds a
**   of the charstring glyph.
***/
errcode ParseCharString(T1Glyph *glyph,
                        struct Composite **comp,
                        PSState *ps,
                        const struct Subrs *subrs,
                        UBYTE *code,
                        USHORT len)
{
   Composite *c;
   Stem3 *stem3;
   Stem *stem;
   Flex *flex;
   long v, w;
   funit dx1, dy1, dx2, dy2, dx3, dy3;
   funit x0, y0, x1, y1, x2, y2, x3, y3;
   funit width, offset;
   funit o1, o2, o3, w1, w2, w3;
   long v1, v2, v3, v4;
   errcode status = SUCCESS;
   long subr, args;
   funit flexciv;
   char *glyph_name = NULL;
   USHORT zero[ENC_MAXCODES];
   char msg[64];
   int i;

   /* Keep track on the number of recursive calls. */
   ps->calls++;
   if (ps->calls>100) {
      LogError(MSG_ERROR, MSG_RECURSION, NULL);
      SetError(status = BADCHARSTRING);
      return status;
   }


   while (len) {
      v = *code++; len--;

      /* Check for space for the paths. */
      if (ps->numpts+4>=ps->maxpts) {
         Point *newpts;
         ULONG *newonoff;

         if ((newpts=Realloc(ps->pts,
                             sizeof(Point)*(ps->maxpts+BUFMARGIN)))==NULL)
            return NOMEM;
         else
            ps->pts = newpts;

         if ((newonoff=Realloc(ps->onoff,
                               ONOFFSIZE(ps->maxpts+BUFMARGIN)))==NULL)
            return NOMEM;
         else
            ps->onoff = newonoff;

         ps->maxpts += BUFMARGIN;
      }



      /* Decode integer. */
      if (v>=32) {
         if (v<=246)
            PushStack(v-139);
         else if (v<=250) {
            w = *code++; len--;
            PushStack((v-247)*256+w+108);
         } else if (v<=254) {
            w = *code++; len--;
            PushStack(-(v-251)*256-w-108);
         } else {
            v1 = *code++; len--;
            v2 = *code++; len--;
            v3 = *code++; len--;
            v4 = *code++; len--;
            PushStack(((v1*256+v2)*256+v3)*256+v4);
         }

         /* Decode command. */
      } else {
         switch (v) {
            case PSOP_HSTEM:
               width  = (funit)PopStack();
               offset = (funit)PopStack();
               if ((stem = NewStem(offset, width, ps->hr))==NULL)
                  return NOMEM;
               stem->next = glyph->hints.hstems;
               glyph->hints.hstems = stem;
               break;
            case PSOP_VSTEM:
               width  = (funit)PopStack();
               offset = (funit)PopStack()+glyph->lsb.x;
               if ((stem = NewStem(offset, width, (ps->hr)))==NULL)
                  return NOMEM;
               stem->next = glyph->hints.vstems;
               glyph->hints.vstems = stem;
               break;
            case PSOP_VMOVETO:
               CurrYPoint(ps) += (funit)PopStack();
               break;
            case PSOP_RLINETO:
               y1 = CurrYPoint(ps) + (funit)PopStack();
               x1 = CurrXPoint(ps) + (funit)PopStack();
               SetOnPoint(ps->onoff, ps->numpts);
               AddPoint(ps, x1, y1);
               break;
            case PSOP_HLINETO:
               x1 = CurrXPoint(ps) + (funit)PopStack();
               y1 = CurrYPoint(ps);
               SetOnPoint(ps->onoff, ps->numpts);
               AddPoint(ps, x1, y1);
               break;
            case PSOP_VLINETO:
               x1 = CurrXPoint(ps);
               y1 = CurrYPoint(ps) + (funit)PopStack();
               SetOnPoint(ps->onoff, ps->numpts);
               AddPoint(ps, x1, y1);
               break;
            case PSOP_RRCURVETO:
               dy3 = (funit)PopStack();
               dx3 = (funit)PopStack();
               dy2 = (funit)PopStack();
               dx2 = (funit)PopStack();
               dy1 = (funit)PopStack();
               dx1 = (funit)PopStack();

               x0 = CurrXPoint(ps);
               y0 = CurrYPoint(ps);
               x1 = x0 + dx1;
               y1 = y0 + dy1;
               x2 = x1 + dx2;
               y2 = y1 + dy2;
               x3 = x2 + dx3;
               y3 = y2 + dy3;

               AddCSpline(ps, x1, y1, x2, y2, x3, y3);
               break;
            case PSOP_CLOSEPATH:
               /* Add the path to the glyph. */
               if ((status = NewPath(glyph, ps->pts,
                                     ps->onoff, ps->numpts))!=SUCCESS)
                  return status;

               /* Current point = last point. */
               SetOnPoint(ps->onoff, 0);
               ps->pts[0] = ps->pts[ps->numpts-1];
               ps->totpts = (USHORT)(ps->totpts + ps->numpts);
               ps->numpts = 1;
               break;
            case PSOP_CALLSUBR:
               v = PopStack();
               if ((status = ParseCharString(glyph, comp, ps,
                                             subrs, subrs[v].code,
                                             subrs[v].len))!=SUCCESS)
                  return status;
               break;
            case PSOP_RETURN:
					ps->calls--;
               return SUCCESS;
            case PSOP_ESCAPE:
               v = *code++; len--;
               switch (v) {
                  case PSOP_DOTSECTION:
                     /* End of dot section? */
                     if (ps->numpts>1) {
                        ps->hr = (short)(ps->totpts+ps->numpts-1);
                        HintReplacement(glyph, (short)(ps->hr-1));
                     }
                     break;
                  case PSOP_VSTEM3:
                     w1 = (funit)PopStack();
                     o1 = (funit)PopStack()+glyph->lsb.x;
                     w2 = (funit)PopStack();
                     o2 = (funit)PopStack()+glyph->lsb.x;
                     w3 = (funit)PopStack();
                     o3 = (funit)PopStack()+glyph->lsb.x; 
                     if (o1>o2) {
                        SWAPINT(o1, o2);
                        SWAPINT(w1, w2);
                     }
                     if (o1>o3) {
                        SWAPINT(o1, o3);
                        SWAPINT(w1, w3);
                     }
                     if (o3<o2) {
                        SWAPINT(o2, o3);
                        SWAPINT(w2, w3);
                     }
                     if ((stem3 = NewStem3(o1, w1,
                                           o2, w2,
                                           o3, w3,
                                           ps->hr))==NULL)
                        return NOMEM;
                     stem3->next = glyph->hints.vstems3;
                     glyph->hints.vstems3 = stem3;
                     break;
                  case PSOP_HSTEM3:
                     w1 = (funit)PopStack(); o1 = (funit)PopStack();
                     w2 = (funit)PopStack(); o2 = (funit)PopStack();
                     w3 = (funit)PopStack(); o3 = (funit)PopStack(); 
                     if ((stem3 = NewStem3(o1, w1,
                                           o2, w2,
                                           o3, w3,
                                           ps->hr))==NULL)
                        return NOMEM;
                     stem3->next = glyph->hints.hstems3;
                     glyph->hints.hstems3 = stem3;
                     break;
                  case PSOP_SEAC:
                     if ((c=Malloc(sizeof(Composite)))==NULL) {
                        return NOMEM;
                     }
                     c->aw = glyph->width.x;
                     c->achar = LookupCharName(DecodeChar(NULL, (USHORT)0,
                                                          ENC_STANDARD,
                                                          (USHORT)PopStack()));
                     c->bchar = LookupCharName(DecodeChar(NULL, (USHORT)0,
                                                          ENC_STANDARD,
                                                          (USHORT)PopStack()));
                     if ((c->cchar = Strdup(glyph->name))==NULL)
                        return NOMEM;
                     c->oenc = NULL;
                     c->ady = (funit)PopStack();
                     c->adx = (funit)PopStack();
                     c->asbx = (funit)PopStack();
                     c->next = *comp;
                     *comp = c;
                     if (glyph->paths==NULL)
                        return SKIP;
                     if ((glyph->name = Malloc(strlen(c->achar)+
                                               strlen(c->bchar)+2))==NULL ||
                         (c->oenc = AllocEncodingTable((USHORT)1))==NULL) {
                        if (glyph->name)
                           Free(glyph->name);
                        if (c->oenc) 
                           Free(c->oenc);
                        return NOMEM;
                     }
                     strcpy(glyph->name, c->bchar);
                     strcat(glyph->name, c->achar);
                     memset(zero, '\0', sizeof(zero[0])*ENC_MAXCODES);
                     if ((glyph_name = Strdup(glyph->name))!=NULL)
                        SetEncodingEntry(c->oenc, (USHORT)0, glyph_name,
                                         ENC_MAXCODES, zero);
                     else
                        return NOMEM;
                     break;
                  case PSOP_SBW:
                     glyph->width.y = (funit)PopStack();
                     glyph->width.x = (funit)PopStack();
                     glyph->lsb.y = (funit)PopStack();
                     glyph->lsb.x = (funit)PopStack();
                     ps->pts[0].x = glyph->lsb.x;
                     ps->pts[0].y = glyph->lsb.y;
                     ps->numpts = 1;
                     SetOnPoint(ps->onoff, 0);
                     break;
                  case PSOP_DIV:
                     /* LogError("Floating point precision lost.\n"); */       
                     y1 = (funit)PopStack();
                     x1 = (funit)PopStack();
                     PushStack(((long)x1+(long)(y1>>1))/(long)y1);
                     break;
                  case PSOP_CALLOTHERSUBR:
                     subr = PopStack();
                     args = PopStack();

							/* Remember the arguments for future pop's. */
							for (i=0; i<args; i++) {
								ps->otherargs[i] = ps->stack[args-i-1];
							}
							ps->otherptr = 0;

                     switch (subr) {
                        case HINT_END_FLEX:
                           y0 = (funit)PopStack();
                           x0 = (funit)PopStack();
                           flexciv = (funit)PopStack();
                           ps->numpts--;
                           SetOffPoint(ps->onoff, ps->numpts-2);
                           SetOffPoint(ps->onoff, ps->numpts-3);
                           SetOffPoint(ps->onoff, ps->numpts-5);
                           SetOffPoint(ps->onoff, ps->numpts-6);
                           if ((flex = NewFlex(ps->flexref,
                                               PrevPoint(ps, 3),
                                               PrevPoint(ps, 6),
                                               (USHORT)(ps->totpts+
                                                        ps->numpts-7),
                                               (USHORT)(ps->totpts+
                                                        ps->numpts-4),
                                               (USHORT)(ps->totpts+
                                                        ps->numpts-1),
                                               flexciv))==NULL)
                              return NOMEM;
                           flex->next = glyph->hints.flex;
                           glyph->hints.flex = flex;
                           break;
                        case HINT_START_FLEX:
                           ps->flex = 1;
                           x0 = CurrXPoint(ps);
                           y0 = CurrYPoint(ps);
						   SetOnPoint(ps->onoff, ps->numpts);
                           AddPoint(ps, x0, y0);
                           break;
                        case HINT_MID_FLEX:
                           y0 = CurrYPoint(ps);
                           x0 = CurrXPoint(ps);
                           if (ps->flex==1) {
                              ps->flexref.x = x0;
                              ps->flexref.y = y0;
                              ps->flex=0;
                           } else {
							  SetOnPoint(ps->onoff, ps->numpts);
                              AddPoint(ps, x0, y0);
                           }
                           break;
                        case HINT_REPLACEMENT:
                           ps->hr = (short)(ps->totpts+ps->numpts-1);
                           HintReplacement(glyph, (short)(ps->hr-1));
                           (void)PopStack();
                           break;
                        default:
                           ps->ptr = (USHORT)(ps->ptr - args);
                           break;
                     }
                     break;
                        case PSOP_POP:
									PushStack(ps->otherargs[ps->otherptr++]);
                           break;
                        case PSOP_SETCURRENTPOINT:
                           (ps->ptr) -= 2;
                           break;
                        case 15:
                           ps->ptr-=2;
                           break;
                        default:
                           LogError(MSG_ERROR, MSG_BADESC, NULL);
                           SetError(status = BADCHARSTRING);
                           return status;
               }
               break;
            case PSOP_HSBW:
               glyph->width.x = (funit)PopStack();
               glyph->width.y = 0;
               glyph->lsb.x = (funit)PopStack();
               glyph->lsb.y = 0;
               ps->pts[0].x = glyph->lsb.x;
               ps->pts[0].y = 0;
               ps->numpts = 1;
               SetOnPoint(ps->onoff, 0);
               break;
            case PSOP_ENDCHAR:
               if (ps->numpts>1) {
                  if ((status = NewPath(glyph, ps->pts,
                                        ps->onoff, ps->numpts))!=SUCCESS)
                     return status;
               }
               return SUCCESS;
            case PSOP_RMOVETO:
               CurrYPoint(ps) += (funit)PopStack();
               CurrXPoint(ps) += (funit)PopStack();
               break;
            case PSOP_HMOVETO:
               CurrXPoint(ps) += (funit)PopStack();
               break;
            case PSOP_VHCURVETO:
               dy3 = 0;
               dx3 = (funit)PopStack();
               dy2 = (funit)PopStack();
               dx2 = (funit)PopStack();
               dy1 = (funit)PopStack();
               dx1 = 0;

               x0 = CurrXPoint(ps);
               y0 = CurrYPoint(ps);
               x1 = x0 + dx1;
               y1 = y0 + dy1;
               x2 = x1 + dx2;
               y2 = y1 + dy2;
               x3 = x2 + dx3;
               y3 = y2 + dy3;

               AddCSpline(ps, x1, y1, x2, y2, x3, y3);
               break;
            case PSOP_HVCURVETO:
               dy3 = (funit)PopStack();
               dx3 = 0;
               dy2 = (funit)PopStack();
               dx2 = (funit)PopStack();
               dy1 = 0;
               dx1 = (funit)PopStack();

               x0 = CurrXPoint(ps);
               y0 = CurrYPoint(ps);
               x1 = x0 + dx1;
               y1 = y0 + dy1;
               x2 = x1 + dx2;
               y2 = y1 + dy2;
               x3 = x2 + dx3;
               y3 = y2 + dy3;

               AddCSpline(ps, x1, y1, x2, y2, x3, y3);
               break;
            case 15:
               ps->ptr -=2;
               break;

            default:
               strcpy(msg,  "'00' (00)");
               msg[1] = (char)('0' + (v/10));
               msg[2] = (char)('0' + (v%10));
               msg[6] = (char)('0' + (ps->ptr/10));
               msg[7] = (char)('0' + (ps->ptr%10));
               LogError(MSG_ERROR, MSG_BADOP, msg);
               SetError(status = BADCHARSTRING);
               return status;
         }
      }

      /* Check number of elements on the stack. */
      if (ps->ptr>MAXSTACK)
         return BADCHARSTRING;
   }

   return SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\encoding.c ===
/***
 **
 **   Module: Encoding
 **
 **   Description:
 **      This is a module of the T1 to TT font converter. The module
 **      contains interface functions for the global encoding table,
 **      i.e. this is an abstract data type.
 **
 **   Author: Michael Jansson
 **
 **   Created: 6/13/93
 **
 ***/


/**** INCLUDES */
#include <string.h>
#include "types.h"
#include "encoding.h"
#include "safemem.h"



/***** LOCAL TYPES */
struct encoding {
   const char *name;            /* Postscript name of a glyph. */
   USHORT codes[ENC_MAXCODES];  /* Character codes for each encoding scheme. */
};


/***** CONSTANTS */
static const struct encoding StdEncoding[] = {
   {".notdef",       {0xffff, 0xffff, 0xffff, 0xffff}},
   {"A",             {0x0041, 0x0041, 0x0041, 0x0041}},
   {"AE",            {0x00c6, 0x00c6, 0x00e1, 174   }},
   {"Aacute",        {0x00c1, 0x00c1, 0xffff, 231   }},
   {"Abreve",        {0x0102, 0xffff, 0xffff, 0xffff}},
   {"Acircumflex",   {0x00c2, 0x00c2, 0xffff, 229   }},
   {"Adieresis",     {0x00c4, 0x00c4, 0xffff, 128   }},
   {"Agrave",        {0x00c0, 0x00c0, 0xffff, 203   }},
   {"Aogonek",       {0x0104, 0xffff, 0xffff, 0xffff}},
   {"Aring",         {0x00c5, 0x00c5, 0xffff, 129   }},
   {"Atilde",        {0x00c3, 0x00c3, 0xffff, 204   }},
   {"B",             {0x0042, 0x0042, 0x0042, 0x0042}},
   {"C",             {0x0043, 0x0043, 0x0043, 0x0043}},
   {"Cacute",        {0x0106, 0xffff, 0xffff, 0xffff}},
   {"Ccaron",        {0x010c, 0xffff, 0xffff, 0xffff}},
   {"Ccedilla",      {0x00c7, 0x00c7, 0xffff, 130   }},
   {"D",             {0x0044, 0x0044, 0x0044, 0x0044}},
   {"Dcaron",        {0x010e, 0xffff, 0xffff, 0xffff}},
   {"Delta",         {0x2206, 0xffff, 0xffff, 198   }},
   {"Dslash",        {0x0110, 0xffff, 0xffff, 0xffff}},
   {"E",             {0x0045, 0x0045, 0x0045, 0x0045}},
   {"Eacute",        {0x00c9, 0x00c9, 0xffff, 131   }},
   {"Ecaron",        {0x011a, 0xffff, 0xffff, 0xffff}},
   {"Ecircumflex",   {0x00ca, 0x00ca, 0xffff, 230   }},
   {"Edieresis",     {0x00cb, 0x00cb, 0xffff, 232   }},
   {"Egrave",        {0x00c8, 0x00c8, 0xffff, 233   }},
   {"Eogonek",       {0x0118, 0xffff, 0xffff, 0xffff}},
   {"Eth",           {0x00d0, 0x00d0, 0xffff, 0xffff}},
   {"F",             {0x0046, 0x0046, 0x0046, 0x0046}},
   {"G",             {0x0047, 0x0047, 0x0047, 0x0047}},
   {"Gamma",         {0x0393, 0xffff, 0xffff, 0xffff}},
   {"Gbreve",        {0x011e, 0xffff, 0xffff, 0xffff}},
   {"H",             {0x0048, 0x0048, 0x0048, 0x0048}},
   {"I",             {0x0049, 0x0049, 0x0049, 0x0049}},
   {"Iacute",        {0x00cd, 0x00cd, 0xffff, 234   }},
   {"Icircumflex",   {0x00ce, 0x00ce, 0xffff, 235   }},
   {"Idieresis",     {0x00cf, 0x00cf, 0xffff, 236   }},
   {"Idot",          {0x0130, 0xffff, 0xffff, 0xffff}},
   {"Igrave",        {0x00cc, 0x00cc, 0xffff, 237   }},
   {"J",             {0x004a, 0x004a, 0x004a, 0x004a}},
   {"K",             {0x004b, 0x004b, 0x004b, 0x004b}},
   {"L",             {0x004c, 0x004c, 0x004c, 0x004c}},
   {"Lacute",        {0x0139, 0xffff, 0xffff, 0xffff}},
   {"Lcaron",        {0x013d, 0xffff, 0xffff, 0xffff}},
   {"Ldot",          {0x013f, 0xffff, 0xffff, 0xffff}},
   {"Lslash",        {0x0141, 0xffff, 0x00e8, 0xffff}},
   {"M",             {0x004d, 0x004d, 0x004d, 0x004d}},
   {"N",             {0x004e, 0x004e, 0x004e, 0x004e}},
   {"Nacute",        {0x0143, 0xffff, 0xffff, 0xffff}},
   {"Ncaron",        {0x0147, 0xffff, 0xffff, 0xffff}},
   {"Ntilde",        {0x00d1, 0x00d1, 0xffff, 132   }},
   {"O",             {0x004f, 0x004f, 0x004f, 0x004f}},
   {"OE",            {0x0152, 0x008c, 0x00ea, 206   }},
   {"Oacute",        {0x00d3, 0x00d3, 0xffff, 238   }},
   {"Ocircumflex",   {0x00d4, 0x00d4, 0xffff, 239   }},
   {"Odblacute",     {0x0150, 0xffff, 0xffff, 0xffff}},
   {"Odieresis",     {0x00d6, 0x00d6, 0xffff, 133   }},
   {"Ograve",        {0x00d2, 0x00d2, 0xffff, 241   }},
   {"Oslash",        {0x00d8, 0x00d8, 0x00e9, 175   }},
   {"Otilde",        {0x00d5, 0x00d5, 0xffff, 205   }},
   {"P",             {0x0050, 0x0050, 0x0050, 0x0050}},
   {"Phi",           {0x03a6, 0xffff, 0xffff, 0xffff}},
   {"Q",             {0x0051, 0x0051, 0x0051, 0x0051}},
   {"R",             {0x0052, 0x0052, 0x0052, 0x0052}},
   {"Racute",        {0x0154, 0xffff, 0xffff, 0xffff}},
   {"Rcaron",        {0x0158, 0xffff, 0xffff, 0xffff}},
   {"S",             {0x0053, 0x0053, 0x0053, 0x0053}},
   {"Sacute",        {0x015a, 0xffff, 0xffff, 0xffff}},
   {"Scaron",        {0x0160, 0x008A, 0xffff, 0xffff}},
   {"Scedilla",      {0x015e, 0xffff, 0xffff, 0xffff}},
   {"T",             {0x0054, 0x0054, 0x0054, 0x0054}},
   {"Tcaron",        {0x0164, 0xffff, 0xffff, 0xffff}},
   {"Tcedilla",      {0x0162, 0xffff, 0xffff, 0xffff}},
   {"Theta",         {0x0398, 0xffff, 0xffff, 0xffff}},
   {"Thorn",         {0x00de, 0x00de, 0xffff, 0xffff}},
   {"U",             {0x0055, 0x0055, 0x0055, 0x0055}},
   {"Uacute",        {0x00da, 0x00da, 0xffff, 242   }},
   {"Ucircumflex",   {0x00db, 0x00db, 0xffff, 243   }},
   {"Udblacute",     {0x0170, 0xffff, 0xffff, 0xffff}},
   {"Udieresis",     {0x00dc, 0x00dc, 0xffff, 134   }},
   {"Ugrave",        {0x00d9, 0x00d9, 0xffff, 244   }},
   {"Uring",         {0x016e, 0xffff, 0xffff, 0xffff}},
   {"V",             {0x0056, 0x0056, 0x0056, 0x0056}},
   {"W",             {0x0057, 0x0057, 0x0057, 0x0057}},
   {"X",             {0x0058, 0x0058, 0x0058, 0x0058}},
   {"Y",             {0x0059, 0x0059, 0x0059, 0x0059}},
   {"Yacute",        {0x00dd, 0x00dd, 0xffff, 0xffff}},
   {"Ydieresis",     {0x0178, 0x009f, 0xffff, 217   }},
   {"Z",             {0x005a, 0x005a, 0x005a, 0x005a}},
   {"Zacute",        {0x0179, 0xffff, 0xffff, 0xffff}},
   {"Zcaron",        {0x017d, 0xffff, 0xffff, 0xffff}},
   {"Zdot",          {0x017b, 0xffff, 0xffff, 0xffff}},
   {"a",             {0x0061, 0x0061, 0x0061, 0x0061}},
   {"aacute",        {0x00e1, 0x00e1, 0xffff, 135   }},
   {"abreve",        {0x0103, 0xffff, 0xffff, 0xffff}},
   {"acircumflex",   {0x00e2, 0x00e2, 0xffff, 137   }},
   {"acute",         {0x00b4, 0x00b4, 0x00c2, 171   }},
   {"adieresis",     {0x00e4, 0x00e4, 0xffff, 138   }},
   {"ae",            {0x00e6, 0x00e6, 0x00f1, 190   }},
   {"agrave",        {0x00e0, 0x00e0, 0xffff, 136   }},
   {"alpha",         {0x03b1, 0xffff, 0xffff, 0xffff}},
   {"ampersand",     {0x0026, 0x0026, 0x0026, 0x0026}},
   {"aogonek",       {0x0105, 0xffff, 0xffff, 0xffff}},
   {"apple",         {0xf000, 0x000, 0xffff, 240   }},
   {"approxequal",   {0x2248, 0xffff, 0xffff, 197   }},
   {"aring",         {0x00e5, 0x00e5, 0xffff, 140   }},
   {"arrowboth",     {0x2194, 0xffff, 0xffff, 0xffff}},
   {"arrowdown",     {0x2193, 0xffff, 0xffff, 0xffff}},
   {"aroowleft",     {0x2190, 0xffff, 0xffff, 0xffff}},
   {"arrowright",    {0x2192, 0xffff, 0xffff, 0xffff}},
   {"arrowup",       {0x2191, 0xffff, 0xffff, 0xffff}},
   {"arrowupdn",     {0x2195, 0xffff, 0xffff, 0xffff}},
   {"arrowupdnbse",  {0x21a8, 0xffff, 0xffff, 0xffff}},
   {"asciicircum",   {0x005e, 0x005e, 0x005e, 0x005e}},
   {"asciitilde",    {0x007e, 0x007e, 0x007e, 0x007e}},
   {"asterisk",      {0x002a, 0x002a, 0x002a, 0x002a}},
   {"at",            {0x0040, 0x0040, 0x0040, 0x0040}},
   {"atilde",        {0x00e3, 0x00e3, 0xffff, 139   }},
   {"b",             {0x0062, 0x0062, 0x0062, 0x0062}},
   {"backslash",     {0x005c, 0x005c, 0x005c, 0x005c}},
   {"bar",           {0x007c, 0x007c, 0x007c, 0x007c}},
   {"block",         {0x2588, 0xffff, 0xffff, 0xffff}},
   {"braceleft",     {0x007b, 0x007b, 0x007b, 0x007b}},
   {"braceright",    {0x007d, 0x007d, 0x007d, 0x007d}},
   {"bracketleft",   {0x005b, 0x005b, 0x005b, 0x005b}},
   {"bracketright",  {0x005d, 0x005d, 0x005d, 0x005d}},
   {"breve",         {0x02d8, 0xffff, 0x00c6, 249   }},
   {"brokenbar",     {0x00a6, 0x00a6, 0xffff, 0xffff}},
   {"bullet",        {0x2022, 0x0095, 0x00b7, 165   }},
   {"c",             {0x0063, 0x0063, 0x0063, 0x0063}},
   {"cacute",        {0x0107, 0xffff, 0xffff, 0xffff}},
   {"caron",         {0x02c7, 0xffff, 0x00cf, 255   }},
   {"ccaron",        {0x010d, 0xffff, 0xffff, 0xffff}},
   {"ccedilla",      {0x00e7, 0x00e7, 0xffff, 141   }},
   {"cedilla",       {0x00b8, 0x00b8, 0x00cb, 252   }},
   {"cent",          {0x00a2, 0x00a2, 0x00a2, 162   }},
   {"circle",        {0x25cb, 0xffff, 0xffff, 0xffff}},
   {"circumflex",    {0x02c6, 0x0088, 0x00c3, 246   }},
   {"club",          {0x2663, 0xffff, 0xffff, 0xffff}},
   {"colon",         {0x003a, 0x003a, 0x003a, 0x003a}},
   {"comma",         {0x002c, 0x002c, 0x002c, 0x002c}},
   {"copyright",     {0x00a9, 0x00a9, 0xffff, 169   }},
   {"currency",      {0x00a4, 0x00a4, 0x00a8, 219   }},
   {"d",             {0x0064, 0x0064, 0x0064, 0x0064}},
   {"dagger",        {0x2020, 0x0086, 0x00b2, 160   }},
   {"daggerdbl",     {0x2021, 0x0087, 0x00b3, 224   }},
   {"dcaron",        {0x010f, 0xffff, 0xffff, 0xffff}},
   {"degree",        {0x00b0, 0x00b0, 0xffff, 161   }},
   {"delta",         {0x03b4, 0xffff, 0xffff, 0xffff}},
   {"diamond",       {0x2666, 0xffff, 0xffff, 0xffff}},
   {"dieresis",      {0x00a8, 0x00a8, 0x00c8, 172   }},
   {"divide",        {0x00f7, 0x00f7, 0xffff, 214   }},
   {"dkshade",       {0x2593, 0xffff, 0xffff, 0xffff}},
   {"dmacron",       {0x0111, 0xffff, 0xffff, 0xffff}},
   {"dnblock",       {0x2584, 0xffff, 0xffff, 0xffff}},
   {"dollar",        {0x0024, 0x0024, 0x0024, 0x0024}},
   {"dotaccent",     {0x02d9, 0xffff, 0x00c7, 250   }},
   {"dotlessi",      {0x0131, 0xffff, 0x00f5, 245   }},
   {"e",             {0x0065, 0x0065, 0x0065, 0x0065}},
   {"eacute",        {0x00e9, 0x00e9, 0xffff, 142   }},
   {"ecaron",        {0x011b, 0xffff, 0xffff, 0xffff}},
   {"ecircumflex",   {0x00ea, 0x00ea, 0xffff, 144   }},
   {"edieresis",     {0x00eb, 0x00eb, 0xffff, 145   }},
   {"egrave",        {0x00e8, 0x00e8, 0xffff, 143   }},
   {"eight",         {0x0038, 0x0038, 0x0038, 0x0038}},
   {"ellipsis",      {0x2026, 0x0085, 0x00bc, 201   }},
   {"emdash",        {0x2014, 0x0097, 0x00d0, 209   }},
   {"endash",        {0x2013, 0x0096, 0x00b1, 208   }},
   {"eogonek",       {0x0119, 0xffff, 0xffff, 0xffff}},
   {"epsilon",       {0x03b4, 0xffff, 0xffff, 0xffff}},
   {"equal",         {0x003d, 0x003d, 0x003d, 0x003d}},
   {"equivalence",   {0x2261, 0xffff, 0xffff, 0xffff}},
   {"eth",           {0x00f0, 0x00f0, 0xffff, 0xffff}},
   {"exclam",        {0x0021, 0x0021, 0x0021, 0x0021}},
   {"exclamdbl",     {0x203c, 0xffff, 0xffff, 0xffff}},
   {"exclamdown",    {0x00a1, 0x00a1, 0x00a1, 193   }},
   {"f",             {0x0066, 0x0066, 0x0066, 0x0066}},
   {"female",        {0x2640, 0xffff, 0xffff, 0xffff}},
   {"fi",            {0xf001, 0xffff, 0x00ae, 222   }},
   {"filledbox",     {0x25a0, 0xffff, 0xffff, 0xffff}},
   {"filledrect",    {0x25ac, 0xffff, 0xffff, 0xffff}},
   {"five",          {0x0035, 0x0035, 0x0035, 0x0035}},
   {"fl",            {0xf002, 0xffff, 0x00af, 223   }},
   {"florin",        {0x0192, 0x0083, 0x00a6, 196   }},
   {"four",          {0x0034, 0x0034, 0x0034, 0x0034}},
   {"fraction",      {0x2215, 0xffff, 0x00a4, 218   }},
   {"franc",         {0x20a3, 0xffff, 0xffff, 0xffff}},
   {"g",             {0x0067, 0x0067, 0x0067, 0x0067}},
   {"gbreve",        {0x011f, 0xffff, 0xffff, 0xffff}},
   {"germandbls",    {0x00df, 0x00df, 0x00fb, 167   }},
   {"grave",         {0x0060, 0x0060, 0x00c1, 0x0060}},
   {"greater",       {0x003e, 0x003e, 0x003e, 0x003e}},
   {"greaterequal",  {0x2265, 0xffff, 0xffff, 179   }},
   {"guillemotleft", {0x00ab, 0x00ab, 0x00ab, 199   }},
   {"guillemotright",{0x00bb, 0x00bb, 0x00bb, 200   }},
   {"guilsinglleft", {0x2039, 0x008b, 0x00ac, 220   }},
   {"guilsinglright",{0x203a, 0x009b, 0x00ad, 221   }},
   {"h",             {0x0068, 0x0068, 0x0068, 0x0068}},
   {"heart",         {0x2665, 0xffff, 0xffff, 0xffff}},
   {"house",         {0x2302, 0xffff, 0xffff, 0xffff}},
   {"hungarumlaut",  {0x02dd, 0xffff, 0x00cd, 0xffff}},
   {"hyphen",        {0x002d, 0x002d, 0x002d, 0x002d}},
   {"i",             {0x0069, 0x0069, 0x0069, 0x0069}},
   {"iacute",        {0x00ed, 0x00ed, 0xffff, 146   }},
   {"icircumflex",   {0x00ee, 0x00ee, 0xffff, 148   }},
   {"idieresis",     {0x00ef, 0x00ef, 0xffff, 149   }},
   {"igrave",        {0x00ec, 0x00ec, 0xffff, 147   }},
   {"infinity",      {0x221e, 0xffff, 0xffff, 176   }},
   {"integral",      {0x222b, 0xffff, 0xffff, 186   }},
   {"integralbt",    {0x2321, 0xffff, 0xffff, 0xffff}},
   {"integraltp",    {0x2320, 0xffff, 0xffff, 0xffff}},
   {"intersection",  {0x2229, 0xffff, 0xffff, 0xffff}},
   {"invbullet",     {0x25d8, 0xffff, 0xffff, 0xffff}},
   {"invcircle",     {0x25d9, 0xffff, 0xffff, 0xffff}},
   {"invsmileface",  {0x263b, 0xffff, 0xffff, 0xffff}},
   {"j",             {0x006a, 0x006a, 0x006a, 0x006a}},
   {"k",             {0x006b, 0x006b, 0x006b, 0x006b}},
   {"l",             {0x006c, 0x006c, 0x006c, 0x006c}},
   {"lacute",        {0x013a, 0xffff, 0xffff, 0xffff}},
   {"lcaron",        {0x013e, 0xffff, 0xffff, 0xffff}},
   {"ldot",          {0x0140, 0xffff, 0xffff, 0xffff}},
   {"less",          {0x003c, 0x003c, 0x003c, 0x003c}},
   {"lessequal",     {0x2264, 0xffff, 0xffff, 178   }},
   {"lfblock",       {0x258c, 0xffff, 0xffff, 0xffff}},
   {"logicalnot",    {0x00ac, 0x00ac, 0xffff, 194   }},
   {"lozenge",       {0x25ca, 0xffff, 0xffff, 215   }},
   {"lslash",        {0x0142, 0xffff, 0x00f8, 0xffff}},
   {"ltshade",       {0x2591, 0xffff, 0xffff, 0xffff}},
   {"m",             {0x006d, 0x006d, 0x006d, 0x006d}},
   {"macron",        {0x00af, 0xffff, 0x00c5, 248   }},
   {"male",          {0x2642, 0xffff, 0xffff, 0xffff}},
   {"middot",        {0x00b7, 0x00b7, 0xffff, 0xffff}},
   {"minus",         {0x2212, 0xffff, 0xffff, 0xffff}},
   {"mu",            {0x00b5, 0x00b5, 0xffff, 181   }},
   {"multiply",      {0x00d7, 0x00d7, 0xffff, 0xffff}},
   {"musicalnote",   {0x266a, 0xffff, 0xffff, 0xffff}},
   {"musicalnotedbl",{0x266b, 0xffff, 0xffff, 0xffff}},
   {"n",             {0x006e, 0x006e, 0x006e, 0x006e}},
   {"nacute",        {0x0144, 0xffff, 0xffff, 0xffff}},
   {"nbspace",       {0x00a0, 0x00a0, 0xffff, 0xffff}},
   {"ncaron",        {0x0148, 0xffff, 0xffff, 0xffff}},
   {"nine",          {0x0039, 0x0039, 0x0039, 0x0039}},
   {"notequal",      {0x2260, 0xffff, 0xffff, 173   }},
   {"nsuperior",     {0x207f, 0xffff, 0xffff, 0xffff}},
   {"ntilde",        {0x00f1, 0x00f1, 0xffff, 150   }},
   {"numbersign",    {0x0023, 0x0023, 0x0023, 0x0023}},
   {"o",             {0x006f, 0x006f, 0x006f, 0x006f}},
   {"oacute",        {0x00f3, 0x00f3, 0xffff, 151   }},
   {"ocircumflex",   {0x00f4, 0x00f4, 0xffff, 153   }},
   {"odblacute",     {0x0151, 0xffff, 0xffff, 0xffff}},
   {"odieresis",     {0x00f6, 0x00f6, 0xffff, 154   }},
   {"oe",            {0x0153, 0x009c, 0x00fa, 207   }},
   {"ogonek",        {0x02db, 0xffff, 0x00ce, 254   }},
   {"ograve",        {0x00f2, 0x00f2, 0xffff, 152   }},
   {"ohm",           {0x2126, 0xffff, 0xffff, 189   }},
   {"one",           {0x0031, 0x0031, 0x0031, 0x0031}},
   {"onehalf",       {0x00bd, 0x00bd, 0xffff, 0xffff}},
   {"onequarter",    {0x00bc, 0x00bc, 0xffff, 0xffff}},
   {"onesuperior",   {0x00b9, 0x00b9, 0xffff, 0xffff}},
   {"ordfeminine",   {0x00aa, 0x00aa, 0x00e3, 187   }},
   {"ordmasculine",  {0x00ba, 0x00ba, 0x00eb, 188   }},
   {"orthogonal",    {0x221f, 0xffff, 0xffff, 0xffff}},
   {"oslash",        {0x00f8, 0x00f8, 0x00f9, 191   }},
   {"otilde",        {0x00f5, 0x00f5, 0xffff, 155   }},
   {"overscore",     {0x00af, 0x00af, 0xffff, 0xffff}},
   {"p",             {0x0070, 0x0070, 0x0070, 0x0070}},
   {"paragraph",     {0x00b6, 0x00b6, 0x00b6, 166   }},
   {"parenleft",     {0x0028, 0x0028, 0x0028, 0x0028}},
   {"parenright",    {0x0029, 0x0029, 0x0029, 0x0029}},
   {"partialdiff",   {0x2202, 0xffff, 0xffff, 182   }},
   {"percent",       {0x0025, 0x0025, 0x0025, 0x0025}},
   {"period",        {0x002e, 0x002e, 0x002e, 0x002e}},
   {"periodcentered",{0x2219, 0xffff, 0x00b4, 225   }},
   {"perthousand",   {0x2030, 0x0089, 0x00bd, 228   }},
   {"peseta",        {0x20a7, 0xffff, 0xffff, 0xffff}},
   {"phi",           {0x03c6, 0xffff, 0xffff, 0xffff}},
   {"pi",            {0x03c0, 0xffff, 0xffff, 185   }},
   {"plus",          {0x002b, 0x002b, 0x002b, 0x002b}},
   {"plusminus",     {0x00b1, 0x00b1, 0xffff, 177   }},
   {"product",       {0x220f, 0xffff, 0xffff, 184   }},
   {"q",             {0x0071, 0x0071, 0x0071, 0x0071}},
   {"question",      {0x003f, 0x003f, 0x003f, 0x003f}},
   {"questiondown",  {0x00bf, 0x00bf, 0x00bf, 192   }},
   {"quotedbl",      {0x0022, 0x0022, 0x0022, 0x0022}},
   {"quotedblbase",  {0x201e, 0x0084, 0x00b9, 227   }},
   {"quotedblleft",  {0x201c, 0x0093, 0x00aa, 210   }},
   {"quotedblright", {0x201d, 0x0094, 0x00ba, 211   }},
   {"quoteleft",     {0x2018, 0x0091, 0x0060, 212   }},
   {"quoteright",    {0x2019, 0x0092, 0x0027, 213   }},
   {"quotesinglbase",{0x201a, 0x0082, 0x00b8, 226   }},
   {"quotesingle",   {0x0027, 0x0027, 0x00a9, 0x0027}},
   {"r",             {0x0072, 0x0072, 0x0072, 0x0072}},
   {"racute",        {0x0155, 0xffff, 0xffff, 0xffff}},
   {"radical",       {0x221a, 0xffff, 0xffff, 195   }},
   {"rcaron",        {0x0159, 0xffff, 0xffff, 0xffff}},
   {"registered",    {0x00ae, 0x00ae, 0xffff, 168   }},
   {"revlogicalnot", {0x2310, 0xffff, 0xffff, 0xffff}},
   {"ring",          {0x02da, 0xffff, 0x00ca, 251   }},
   {"rtblock",       {0x2590, 0xffff, 0xffff, 0xffff}},
   {"s",             {0x0073, 0x0073, 0x0073, 0x0073}},
   {"sacute",        {0x015b, 0xffff, 0xffff, 0xffff}},
   {"scaron",        {0x0161, 0x009a, 0xffff, 0xffff}},
   {"scedilla",      {0x015f, 0xffff, 0xffff, 0xffff}},
   {"section",       {0x00a7, 0x00a7, 0x00a7, 164   }},
   {"semicolon",     {0x003b, 0x003b, 0x003b, 0x003b}},
   {"seven",         {0x0037, 0x0037, 0x0037, 0x0037}},
   {"sfthyphen",     {0x00ad, 0x00ad, 0xffff, 0xffff}},
   {"shade",         {0x2592, 0xffff, 0xffff, 0xffff}},
   {"sigma",         {0x03c3, 0xffff, 0xffff, 0xffff}},
   {"six",           {0x0036, 0x0036, 0x0036, 0x0036}},
   {"slash",         {0x002f, 0x002f, 0x002f, 0x002f}},
   {"smileface",     {0x263a, 0xffff, 0xffff, 0xffff}},
   {"space",         {0x0020, 0x0020, 0x0020, 0x0020}},
   {"spade",         {0x2660, 0xffff, 0xffff, 0xffff}},
   {"sterling",      {0x00a3, 0x00a3, 0x00a3, 163   }},
   {"summation",     {0x2211, 0xffff, 0xffff, 183   }},
   {"sun",           {0x263c, 0xffff, 0xffff, 0xffff}},
   {"t",             {0x0074, 0x0074, 0x0074, 0x0074}},
   {"tau",           {0x03c4, 0xffff, 0xffff, 0xffff}},
   {"tcaron",        {0x0165, 0xffff, 0xffff, 0xffff}},
   {"tcedilla",      {0x0163, 0xffff, 0xffff, 0xffff}},
   {"thorn",         {0x00fe, 0x00fe, 0xffff, 0xffff}},
   {"three",         {0x0033, 0x0033, 0x0033, 0x0033}},
   {"threequarters", {0x00be, 0x00be, 0xffff, 0xffff}},
   {"threesuperior", {0x00b3, 0x00b3, 0xffff, 0xffff}},
   {"tilde",         {0x02dc, 0x0098, 0x00c4, 245   }},
   {"trademark",     {0x2122, 0x0099, 0xffff, 170   }},
   {"triagdn",       {0x25bc, 0xffff, 0xffff, 0xffff}},
   {"triagrt",       {0x25ba, 0xffff, 0xffff, 0xffff}},
   {"triagup",       {0x25b2, 0xffff, 0xffff, 0xffff}},
   {"traglf",        {0x25c4, 0xffff, 0xffff, 0xffff}},
   {"two",           {0x0032, 0x0032, 0x0032, 0x0032}},
   {"twosuperior",   {0x00b2, 0x00b2, 0xffff, 0xffff}},
   {"u",             {0x0075, 0x0075, 0x0075, 0x0075}},
   {"uacute",        {0x00fa, 0x00fa, 0xffff, 156   }},
   {"ucircumflex",   {0x00fb, 0x00fb, 0xffff, 158   }},
   {"udblacute",     {0x0171, 0xffff, 0xffff, 0xffff}},
   {"udieresis",     {0x00fc, 0x00fc, 0xffff, 159   }},
   {"ugrave",        {0x00f9, 0x00f9, 0xffff, 157   }},
   {"underscore",    {0x005f, 0x005f, 0x005f, 0x005f}},
   {"underscoredbl", {0x2017, 0xffff, 0xffff, 0xffff}},
   {"upblock",       {0x2580, 0xffff, 0xffff, 0xffff}},
   {"uring",         {0x016f, 0xffff, 0xffff, 0xffff}},
   {"v",             {0x0076, 0x0076, 0x0076, 0x0076}},
   {"w",             {0x0077, 0x0077, 0x0077, 0x0077}},
   {"x",             {0x0078, 0x0078, 0x0078, 0x0078}},
   {"y",             {0x0079, 0x0079, 0x0079, 0x0079}},
   {"yacute",        {0x00fd, 0x00fd, 0xffff, 0xffff}},
   {"ydieresis",     {0x00ff, 0x00ff, 0xffff, 216   }},
   {"yen",           {0x00a5, 0x00a5, 0x00a5, 180   }},
   {"z",             {0x007a, 0x007a, 0x007a, 0x007a}},
   {"zacute",        {0x017a, 0xffff, 0xffff, 0xffff}},
   {"zcaron",        {0x017e, 0xffff, 0xffff, 0xffff}},
   {"zdot",          {0x017c, 0xffff, 0xffff, 0xffff}},
   {"zero",          {0x0030, 0x0030, 0x0030, 0x0030}},
};


static const struct encoding SeacEncoding[] = {
   {"A",             {0xf041, 0x0041, 0x0041, 0x0041}},
   {"AE",            {0xf0c6, 0x00c6, 0x00e1, 174   }},
   {"B",             {0xf042, 0x0042, 0x0042, 0x0042}},
   {"C",             {0xf043, 0x0043, 0x0043, 0x0043}},
   {"D",             {0xf044, 0x0044, 0x0044, 0x0044}},
   {"E",             {0xf045, 0x0045, 0x0045, 0x0045}},
   {"F",             {0xf046, 0x0046, 0x0046, 0x0046}},
   {"G",             {0xf047, 0x0047, 0x0047, 0x0047}},
   {"H",             {0xf048, 0x0048, 0x0048, 0x0048}},
   {"I",             {0xf049, 0x0049, 0x0049, 0x0049}},
   {"J",             {0xf04a, 0x004a, 0x004a, 0x004a}},
   {"K",             {0xf04b, 0x004b, 0x004b, 0x004b}},
   {"L",             {0xf04c, 0x004c, 0x004c, 0x004c}},
   {"Lslash",        {0xf141, 0xffff, 0x00e8, 0xffff}},
   {"M",             {0xf04d, 0x004d, 0x004d, 0x004d}},
   {"N",             {0xf04e, 0x004e, 0x004e, 0x004e}},
   {"O",             {0xf04f, 0x004f, 0x004f, 0x004f}},
   {"OE",            {0xf152, 0x008c, 0x00ea, 206   }},
   {"Oslash",        {0xf0d8, 0x00d8, 0x00e9, 175   }},
   {"P",             {0xf050, 0x0050, 0x0050, 0x0050}},
   {"Q",             {0xf051, 0x0051, 0x0051, 0x0051}},
   {"R",             {0xf052, 0x0052, 0x0052, 0x0052}},
   {"S",             {0xf053, 0x0053, 0x0053, 0x0053}},
   {"T",             {0xf054, 0x0054, 0x0054, 0x0054}},
   {"U",             {0xf055, 0x0055, 0x0055, 0x0055}},
   {"V",             {0xf056, 0x0056, 0x0056, 0x0056}},
   {"W",             {0xf057, 0x0057, 0x0057, 0x0057}},
   {"X",             {0xf058, 0x0058, 0x0058, 0x0058}},
   {"Y",             {0xf059, 0x0059, 0x0059, 0x0059}},
   {"Z",             {0xf05a, 0x005a, 0x005a, 0x005a}},
   {"a",             {0xf061, 0x0061, 0x0061, 0x0061}},
   {"acute",         {0xf0b4, 0x00b4, 0x00c2, 171   }},
   {"ae",            {0xf0e6, 0x00e6, 0x00f1, 190   }},
   {"ampersand",     {0xf026, 0x0026, 0x0026, 0x0026}},
   {"asciicircum",   {0xf05e, 0x005e, 0x005e, 0x005e}},
   {"asciitilde",    {0xf07e, 0x007e, 0x007e, 0x007e}},
   {"asterisk",      {0xf02a, 0x002a, 0x002a, 0x002a}},
   {"at",            {0xf040, 0x0040, 0x0040, 0x0040}},
   {"b",             {0xf062, 0x0062, 0x0062, 0x0062}},
   {"backslash",     {0xf05c, 0x005c, 0x005c, 0x005c}},
   {"bar",           {0xf07c, 0x007c, 0x007c, 0x007c}},
   {"braceleft",     {0xf07b, 0x007b, 0x007b, 0x007b}},
   {"braceright",    {0xf07d, 0x007d, 0x007d, 0x007d}},
   {"bracketleft",   {0xf05b, 0x005b, 0x005b, 0x005b}},
   {"bracketright",  {0xf05d, 0x005d, 0x005d, 0x005d}},
   {"breve",         {0xf2d8, 0xffff, 0x00c6, 249   }},
   {"bullet",        {0x2022, 0x0095, 0x00b7, 165   }},
   {"c",             {0xf063, 0x0063, 0x0063, 0x0063}},
   {"caron",         {0xf2c7, 0xffff, 0x00cf, 255   }},
   {"cedilla",       {0xf0b8, 0x00b8, 0x00cb, 252   }},
   {"cent",          {0xf0a2, 0x00a2, 0x00a2, 162   }},
   {"circumflex",    {0xf2c6, 0x0088, 0x00c3, 246   }},
   {"colon",         {0xf03a, 0x003a, 0x003a, 0x003a}},
   {"comma",         {0xf02c, 0x002c, 0x002c, 0x002c}},
   {"currency",      {0xf0a4, 0x00a4, 0x00a8, 219   }},
   {"d",             {0xf064, 0x0064, 0x0064, 0x0064}},
   {"dagger",        {0x2020, 0x0086, 0x00b2, 160   }},
   {"daggerdbl",     {0x2021, 0x0087, 0x00b3, 224   }},
   {"dieresis",      {0xf0a8, 0x00a8, 0x00c8, 172   }},
   {"dollar",        {0xf024, 0x0024, 0x0024, 0x0024}},
   {"dotaccent",     {0xf2d9, 0xffff, 0x00c7, 250   }},
   {"dotlessi",      {0xf131, 0xffff, 0x00f5, 245   }},
   {"e",             {0xf065, 0x0065, 0x0065, 0x0065}},
   {"eight",         {0xf038, 0x0038, 0x0038, 0x0038}},
   {"ellipsis",      {0x2026, 0x0085, 0x00bc, 201   }},
   {"emdash",        {0x2014, 0x0097, 0x00d0, 209   }},
   {"endash",        {0x2013, 0x0096, 0x00b1, 208   }},
   {"equal",         {0xf03d, 0x003d, 0x003d, 0x003d}},
   {"exclam",        {0xf021, 0x0021, 0x0021, 0x0021}},
   {"exclamdown",    {0xf0a1, 0x00a1, 0x00a1, 193   }},
   {"f",             {0xf066, 0x0066, 0x0066, 0x0066}},
   {"fi",            {0xf001, 0xffff, 0x00ae, 222   }},
   {"five",          {0xf035, 0x0035, 0x0035, 0x0035}},
   {"fl",            {0xf002, 0xffff, 0x00af, 223   }},
   {"florin",        {0xf192, 0x0083, 0x00a6, 196   }},
   {"four",          {0xf034, 0x0034, 0x0034, 0x0034}},
   {"fraction",      {0x2215, 0xffff, 0x00a4, 218   }},
   {"g",             {0xf067, 0x0067, 0x0067, 0x0067}},
   {"germandbls",    {0xf0df, 0x00df, 0x00fb, 167   }},
   {"grave",         {0xf060, 0x0060, 0x00c1, 0x0060}},
   {"greater",       {0xf03e, 0x003e, 0x003e, 0x003e}},
   {"guillemotleft", {0xf0ab, 0x00ab, 0x00ab, 199   }},
   {"guillemotright",{0xf0bb, 0x00bb, 0x00bb, 200   }},
   {"guilsinglleft", {0x2039, 0x008b, 0x00ac, 220   }},
   {"guilsinglright",{0x203a, 0x009b, 0x00ad, 221   }},
   {"h",             {0xf068, 0x0068, 0x0068, 0x0068}},
   {"hungarumlaut",  {0xf2dd, 0xffff, 0x00cd, 0xffff}},
   {"hyphen",        {0xf02d, 0x002d, 0x002d, 0x002d}},
   {"i",             {0xf069, 0x0069, 0x0069, 0x0069}},
   {"j",             {0xf06a, 0x006a, 0x006a, 0x006a}},
   {"k",             {0xf06b, 0x006b, 0x006b, 0x006b}},
   {"l",             {0xf06c, 0x006c, 0x006c, 0x006c}},
   {"less",          {0xf03c, 0x003c, 0x003c, 0x003c}},
   {"lslash",        {0xf142, 0xffff, 0x00f8, 0xffff}},
   {"m",             {0xf06d, 0x006d, 0x006d, 0x006d}},
   {"macron",        {0xf0af, 0xffff, 0x00c5, 248   }},
   {"n",             {0xf06e, 0x006e, 0x006e, 0x006e}},
   {"nine",          {0xf039, 0x0039, 0x0039, 0x0039}},
   {"numbersign",    {0xf023, 0x0023, 0x0023, 0x0023}},
   {"o",             {0xf06f, 0x006f, 0x006f, 0x006f}},
   {"oe",            {0xf153, 0x009c, 0x00fa, 207   }},
   {"ogonek",        {0xf2db, 0xffff, 0x00ce, 254   }},
   {"one",           {0xf031, 0x0031, 0x0031, 0x0031}},
   {"ordfeminine",   {0xf0aa, 0x00aa, 0x00e3, 187   }},
   {"ordmasculine",  {0xf0ba, 0x00ba, 0x00eb, 188   }},
   {"oslash",        {0xf0f8, 0x00f8, 0x00f9, 191   }},
   {"p",             {0xf070, 0x0070, 0x0070, 0x0070}},
   {"paragraph",     {0xf0b6, 0x00b6, 0x00b6, 166   }},
   {"parenleft",     {0xf028, 0x0028, 0x0028, 0x0028}},
   {"parenright",    {0xf029, 0x0029, 0x0029, 0x0029}},
   {"percent",       {0xf025, 0x0025, 0x0025, 0x0025}},
   {"period",        {0xf02e, 0x002e, 0x002e, 0x002e}},
   {"periodcentered",{0x2219, 0xffff, 0x00b4, 225   }},
   {"perthousand",   {0x2030, 0x0089, 0x00bd, 228   }},
   {"plus",          {0xf02b, 0x002b, 0x002b, 0x002b}},
   {"q",             {0xf071, 0x0071, 0x0071, 0x0071}},
   {"question",      {0xf03f, 0x003f, 0x003f, 0x003f}},
   {"questiondown",  {0xf0bf, 0x00bf, 0x00bf, 192   }},
   {"quotedbl",      {0xf022, 0x0022, 0x0022, 0x0022}},
   {"quotedblbase",  {0x201e, 0x0084, 0x00b9, 227   }},
   {"quotedblleft",  {0x201c, 0x0093, 0x00aa, 210   }},
   {"quotedblright", {0x201d, 0x0094, 0x00ba, 211   }},
   {"quoteleft",     {0x2018, 0x0091, 0x0060, 212   }},
   {"quoteright",    {0x2019, 0x0092, 0x0027, 213   }},
   {"quotesinglbase",{0x201a, 0x0082, 0x00b8, 226   }},
   {"quotesingle",   {0xf027, 0x0027, 0x00a9, 0x0027}},
   {"r",             {0xf072, 0x0072, 0x0072, 0x0072}},
   {"ring",          {0xf2da, 0xffff, 0x00ca, 251   }},
   {"s",             {0xf073, 0x0073, 0x0073, 0x0073}},
   {"section",       {0xf0a7, 0x00a7, 0x00a7, 164   }},
   {"semicolon",     {0xf03b, 0x003b, 0x003b, 0x003b}},
   {"seven",         {0xf037, 0x0037, 0x0037, 0x0037}},
   {"six",           {0xf036, 0x0036, 0x0036, 0x0036}},
   {"slash",         {0xf02f, 0x002f, 0x002f, 0x002f}},
   {"space",         {0xf020, 0x0020, 0x0020, 0x0020}},
   {"sterling",      {0xf0a3, 0x00a3, 0x00a3, 163   }},
   {"t",             {0xf074, 0x0074, 0x0074, 0x0074}},
   {"three",         {0xf033, 0x0033, 0x0033, 0x0033}},
   {"tilde",         {0xf2dc, 0x0098, 0x00c4, 245   }},
   {"two",           {0xf032, 0x0032, 0x0032, 0x0032}},
   {"u",             {0xf075, 0x0075, 0x0075, 0x0075}},
   {"underscore",    {0xf05f, 0x005f, 0x005f, 0x005f}},
   {"v",             {0xf076, 0x0076, 0x0076, 0x0076}},
   {"w",             {0xf077, 0x0077, 0x0077, 0x0077}},
   {"x",             {0xf078, 0x0078, 0x0078, 0x0078}},
   {"y",             {0xf079, 0x0079, 0x0079, 0x0079}},
   {"yen",           {0xf0a5, 0x00a5, 0x00a5, 180   }},
   {"z",             {0xf07a, 0x007a, 0x007a, 0x007a}},
   {"zero",          {0xf030, 0x0030, 0x0030, 0x0030}},
};


/***** MACROS */
/*-none-*/


/***** STATIC FUNCTIONS */
/*-none-*/


/***** FUNCTIONS */

/***
** Function: AllocEncodingTable
**
** Description:
**   Create a new encoding ADT.
***/
struct encoding *AllocEncodingTable(const USHORT num)
{
   struct encoding *enc;
   if ((enc = Malloc(sizeof(struct encoding)*num))!=NULL)
      memset(enc, NOTDEFINIT, sizeof(struct encoding)*num);
   return enc;
}


/***
** Function: RehashEncodingTable
**
** Description:
**   Prepare an encoding ADT so that entries can be
**   located in it.
***/
void RehashEncodingTable(struct encoding *Encoding, const USHORT num)
{
   USHORT i;
   short j;
   struct encoding entry;

   for (i=1; i<num; i++) {
      j=(short)(i-1);
      entry = Encoding[i];
      while(j>=0 && strcmp(Encoding[j].name, entry.name)>0) {
         memcpy(&Encoding[j+1], &Encoding[j], sizeof(struct encoding));
         j--;
      }
      Encoding[j+1] = entry;
   }
}


/***
** Function: SetEncodingEntry
**
** Description:
**   Set the mapping from a glyph name to character
**   codes for various platforms.
***/
void SetEncodingEntry(struct encoding *Encoding,
                      const USHORT entry,
                      const char *name,
                      const USHORT num,
                      const USHORT *codes)
{
   USHORT i;

   Encoding[entry].name = name;
   for (i=0; i<num; i++) {
      Encoding[entry].codes[i] = codes[i];
   }
}


static int CDECL compare(const void *arg1, const void *arg2)
{
   return strcmp( *((const char **)arg1),
                  ((const struct encoding *)arg2)->name );
}


/***
** Function: LookupPSName
**
** Description:
**   Do a binary search for a postscript name, and return
**   a handle that can be used to look up a the character
**   code for a specific encoding schema.
**
**   If a custom encoding array is used and a glyph is not
**	 encoded by that array, though it is recognized by the
**   StandardEncoding array, then use the SeacEncoding.
**   This is needed in order to support bogus "seac" calls.
***/
struct encoding *LookupPSName(const struct encoding *Encoding,
                              USHORT size,
                              const char *name)
{
#ifndef BSEARCH
   struct encoding *result;
#else
   USHORT low, mid, high;
   short diff;

   /* Initiate. */
   low = 0;
   high = size;
#endif

   /* Use default encoding? */
   if (Encoding==NULL) {
      Encoding = StdEncoding;
      size = sizeof(StdEncoding)/sizeof(StdEncoding[0]);
   }

#ifndef BSEARCH
   result = (struct encoding *)bsearch((char *)&name,
                                       (char *)Encoding, size,
                                       sizeof(struct encoding),
                                       compare);
#else
   do {

	   mid = (low+high)>>1;
	   diff = (short)strcmp(Encoding[mid].name, name);

	   if (diff>0) {
		   high = (low+high)>>1;
	   } else if (diff<0) {
		   low = (short)((low+high+1)>>1);
	   } else if (diff==0) {
		   result =  &Encoding[mid];
	   }

   } while (low<high && result==NULL);
#endif


   if ((result==NULL) &&
	   (Encoding!=SeacEncoding) &&
	   (Encoding!=StdEncoding))
	   result = LookupPSName(SeacEncoding,
							 sizeof(SeacEncoding)/sizeof(SeacEncoding[0]),
							 name);

   return result;
}


/***
** Function: LookupCharCode
**
** Description:
**   look up a the character code for a
**   specific encoding scheme.
***/
USHORT LookupCharCode(const struct encoding *enc, const USHORT type)
{
   USHORT code = 0;

   if (enc)
      code = enc->codes[type];
   return code;
}


/***
** Function: LookupCharName
**
** Description:
**   look up a the character name for a
**   specific encoding scheme.
***/
const char *LookupCharName(const struct encoding *enc)
{
   return enc->name;
}


/***
** Function: LookupNotDef
**
** Description:
**   look up a the .notdef character
***/
const struct encoding *LookupNotDef(void)
{
   return &StdEncoding[0];
}



/***
** Function: DecodeChar
**
** Description:
**   look up an encoding record for a character code in some
**   known encoding.
***/
const struct encoding *DecodeChar(const struct encoding *Encoding,
                                  const USHORT max,
                                  const USHORT type,
                                  const USHORT code)
{
   const struct encoding *enc = &StdEncoding[0];
   USHORT i, high;

   /* Use default encoding? */
   if (Encoding==NULL) {
      Encoding = StdEncoding;
      high = sizeof(StdEncoding)/sizeof(StdEncoding[0]);
   } else {
      high = max;
   }

   for (i=0; i<high; i++) {
      if (Encoding[i].codes[type]==code) {
         enc = &Encoding[i];
         break;
      }
   }

   return enc;
}


/***
** Function: FreeEncoding
**
** Description:
**   Deallocate memory associated to the encoding array.
***/
void FreeEncoding(struct encoding *enc, const USHORT size)
{
   USHORT i;

   if (enc) {
      for (i=0; i<size; i++) {
         if (enc[i].name)
            Free((char *)enc[i].name);
      }
      Free(enc);
   }
}

/***
** Function: LookupFirstEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupFirstEnc(
    const struct encoding *encRoot,
    const int              encSize,
    const struct encoding *encItem
)
{
	/* Back up to the first item with the same glyph name. */
	while (encItem>encRoot && !strcmp(encItem[-1].name, encItem[0].name))
		encItem--;

	return encItem;
}

/***
** Function: LookupNextEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupNextEnc(
    const struct encoding *encRoot,
    const int              encSize,
    const struct encoding *encItem
)
{
	/* Back up to the first item with the same glyph name. */
	if (encItem<(&encRoot[encSize-1]) &&
		 !strcmp(encItem[0].name, encItem[1].name))
		return ++encItem;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\errors.c ===
/***
 **
 **   Module: T1Instal
 **
 **   Description:
 **      This is a Win32 DLL specific module, that implements
 **      the error logging mechanism under Win32.
 **
 **   Author: Michael Jansson
 **   Created: 12/18/93
 **
 ***/


/***** INCLUDES */
#include <windows.h>
#include "types.h"
#include "t1local.h"
#ifdef NOMSGBOX
#include <stdio.h>
#endif



/***** CONSTANTS */
/*-none-*/



/***** GLOBALS */
extern HANDLE hInst;       /* Cached in the T1Instal module. */



/***** PROTOTYPES */
extern int __cdecl sprintf(char *, const char *, ...);


/***
 ** Function: LogError
 **
 ** Description:
 **   Add another message to the error log.
 ***/
void LogError(const long type, const long id, const char *arg)
{
   char caption[256];
   char msg[256];
   WORD etype;
   HANDLE h;
   DWORD logit;
   DWORD size;
   HKEY key;

   /* Map the internal envent type to EventLog type. */
   if (type==MSG_INFO)
      etype = EVENTLOG_INFORMATION_TYPE;
   else if (type==MSG_WARNING)
      etype = EVENTLOG_WARNING_TYPE;
   else
      etype = EVENTLOG_ERROR_TYPE;

   /* Access the REG data base. */
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SUBKEY_TYPE1INSTAL, 0,
                    KEY_QUERY_VALUE, &key)==ERROR_SUCCESS) { 

      size = sizeof(logit);
      if (RegQueryValueEx(key, (LPTSTR)SUBKEY_LOGFILE, NULL, 
                          NULL, (LPVOID)&logit, &size)==ERROR_SUCCESS &&
          logit!=0) {

         h = RegisterEventSource(NULL, STR_APPNAME);
         if (h!=NULL) {
            ReportEvent(h, etype, 0, id, NULL, 1, 0, (LPSTR *)&arg, NULL);
            DeregisterEventSource(h);
         }

         if (etype==EVENTLOG_WARNING_TYPE) {
            LoadString(hInst, (UINT)id, caption, sizeof(caption));
            sprintf(msg, caption, arg);
            LoadString(hInst, IDS_CAPTION, caption, sizeof(caption));
#if NOMSGBOX
            fputs("WARNING- ", stderr);
            fputs(msg, stderr);
            fputs("\n", stderr);
#else         
            MessageBox(NULL, msg, caption, INFO);
#endif
            SetLastError(0);  /* MessageBox(NULL,...) is broken */
         }
      }

      if (etype==EVENTLOG_ERROR_TYPE) {
         LoadString(hInst, (UINT)id, caption, sizeof(caption));
         sprintf(msg, caption, arg);
         LoadString(hInst, IDS_CAPTION, caption, sizeof(caption));
#if NOMSGBOX
         fputs("ERROR  - ", stderr);
         fputs(msg, stderr);
         fputs("\n", stderr);
#else         
         MessageBox(NULL, msg, caption, INFO);
#endif
         SetLastError(0); /* MessageBox(NULL,...) is broken */
      }
      RegCloseKey(key);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\charstr.h ===
/***
 **
 **   Module: CharStr
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contain one function that interprets the commands in a T1
 **    CharString and builds a representation of the glyph for the
 **    it.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

struct Subrs {
   USHORT len;
   UBYTE *code;
};


struct T1Glyph;
struct Composite;
struct PSState;

/***
** Function: AllocPSState
**
** Description:
**   This function allocates the workspace
**   used by the t1 parser.
***/
struct PSState *AllocPSState     _ARGS((void));


/***
** Function: InitPS
**
** Description:
**   This function initiate the workspace
**   used by the t1 parser.
***/
void           InitPS            _ARGS((INOUT   struct PSState *ps));


/***
** Function: FreePSState
**
** Description:
**   This function frees the workspace
**   used by the t1 parser.
***/
void           FreePSState       _ARGS((INOUT   struct PSState *ps));


/***
** Function: ParseCharString
**
** Description:
**   This function parses a CharString and builds a
**   of the charstring glyph.
***/
errcode        ParseCharString   _ARGS((INOUT   struct T1Glyph *glyph,
                                        INOUT   struct Composite **comp,
                                        INOUT   struct PSState *ps,
                                        IN      struct Subrs *subrs,
                                        INOUT   UBYTE *code,
                                        INOUT   USHORT len));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\builder.h ===
/***
 **
 **   Module: Builder
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains functions that will write the tables found in a
 **    TrueType font file.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#define PREPSIZE        1000
#define MAXNOTDEFSIZE   1024


/* Referenced types. */
struct TTArg;
struct TTHandle;


/* Argument types. */
struct TTGlyph {
   struct encoding *code;

   USHORT num;
   USHORT stack;
   USHORT twilights;
   UBYTE *hints;

   Outline *paths;

   funit aw;
   funit lsb;
};

struct TTComposite {
   struct encoding *aenc;
   struct encoding *benc;
   struct encoding *cenc;
   struct encoding *oenc;
   funit dx;
   funit dy;
   funit aw;
   funit lsb;
};

typedef struct {
   ULONG a;
   ULONG b;
} longdate;

struct TTMetrics {
   struct {
      USHORT ver;
      USHORT rev;
   } version;
   longdate created;
   char *family;
   char *copyright;
   char *name;
   char *id;
   char *notice;
   char *fullname;
   char *weight;
   char *verstr;
   f16d16 angle;
   funit underline;
   funit uthick;
   USHORT macStyle;
   USHORT usWeightClass;
   USHORT usWidthClass;
   USHORT fsSelection;

   /* True Typographical metrics. */
   funit typAscender;
   funit typDescender;
   funit typLinegap;
   Point superoff;
   Point supersize;
   Point suboff;
   Point subsize;
   funit strikeoff;
   funit strikesize;
   short isFixPitched; 

   /* Windows based metrics. */
   funit winAscender;
   funit winDescender;
   UBYTE panose[10];

   /* Mac based metrics. */
   funit macLinegap;

   funit emheight;
   USHORT FirstChar;
   USHORT LastChar;
   USHORT DefaultChar;
   USHORT BreakChar;
   USHORT CharSet;
   funit *widths;
   short *cvt;
   USHORT cvt_cnt;
   struct kerning *kerns;
   USHORT kernsize;

   /* Copy of the encoding table. */
   struct encoding *Encoding;
   USHORT encSize;

   /* Hint specific information. */
   const UBYTE *prep;      /* PreProgram. */
   USHORT prep_size;
   const UBYTE *fpgm;      /* FontProgram. */
   USHORT fpgm_size;
   USHORT maxstorage;
   USHORT maxprepstack;    /* Max stack depth in pre-program. */
   USHORT maxfpgm;         /* Max number of function in the font program. */
   USHORT onepix;          /* Treshold where stems become >= 1.0 pixles. */
};


/***
** Function: InitTTOutput
**
** Description:
**   This function allocates the resources needed to
**   write a TT font file.
***/
errcode  InitTTOutput      _ARGS((IN      struct TTArg *,
                                  OUT     struct TTHandle **));

/***
** Function: CleanUpTT
**
** Description:
**   This function free's the resources used while
**   writing a TT font file.
***/
errcode  CleanUpTT         _ARGS((INOUT   struct TTHandle *,
                                  IN      struct TTArg *,
                                  IN      errcode status));

/***
** Function: PutTTNotDefGlyph
**
** Description:
**   This function adds a record for a the ".notdef" glyph to the
**   'glyf' table of the TT font file.
**   
***/
errcode  PutTTNotDefGlyph        _ARGS((INOUT   struct TTHandle *,
                                        IN      struct TTGlyph*));


/** Function: PutTTGlyph
**
** Description:
**   This function adds a record for a simple glyph to the
**   'glyf' table of the TT font file.
**   
***/
errcode  PutTTGlyph        _ARGS((INOUT   struct TTHandle *,
                                  IN      struct TTGlyph*,
											 IN		boolean fStdEncoding));


/***
** Function: PutTTOther
**
** Description:
**   This function writes the required TT tables to the
**   TT font file, except for the 'glyf' table which is
**   only completed (check sum is computed, etc.).
**   
***/
errcode  PutTTOther        _ARGS((INOUT   struct TTHandle *,
                                  INOUT   struct TTMetrics *));

/***
** Function: FreeTTGlyph
**
** Description:
**   This function will free the memory used to represent a 
**   a TrueType glyph.
**   
***/
void     FreeTTGlyph       _ARGS((INOUT   struct TTGlyph *));


/***
** Function: PutTTComposite
**
** Description:
**   
***/
errcode  PutTTComposite    _ARGS((INOUT   struct TTHandle *,
                                  OUT     struct TTComposite *));

/***
** Function: WindowsBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Windows character set.
***/
void     WindowsBBox       _ARGS((IN      struct TTHandle *tt,
                                  OUT     Point *bbox));

/***
** Function: MacBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Mac character set.
**
**   This is currently set to the global bounding box
**   (tt->bbox) of all characters in the font. This will
**   ensure that accents are not sqeezed on Mac platforms.
***/
void     MacBBox           _ARGS((IN      struct TTHandle *tt,
                                  OUT     Point *bbox));


// the name says it

void     GlobalBBox         _ARGS((IN      struct TTHandle *tt,
                                  OUT     Point *bbox));




/***
** Function: TypographicalAscender
**
** Description:
**   Compute the typographical ascender height, as ymax of
**   the letter 'b'.
***/
funit    TypographicalDescender _ARGS((IN struct TTHandle *tt));


/***
** Function: TypographicalDescender
**
** Description:
**   Compute the typographical descender height, as ymin of
**   the letter 'g'.
***/
funit    TypographicalAscender   _ARGS((IN struct TTHandle *tt));


/***
** Function: FreeTTMetrics
**
** Description:
**   This function free's the resources used to represent
**   TT specific metrics and auxiliary font information.
***/
void     FreeTTMetrics     _ARGS((INOUT struct TTMetrics *));


/***
** Function: UsePrep
**
** Description:
**   This function records the pre-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**   
***/
void     UsePrep           _ARGS((INOUT struct TTMetrics *,
                                  IN    UBYTE *prep,
                                  IN    USHORT size));


/***
** Function: SetFPGM
**
** Description:
**   This function records the font-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**   
***/
void     SetFPGM           _ARGS((INOUT struct TTMetrics *,
                                  IN    UBYTE *fpgm,
                                  IN    USHORT size,
                                  IN    USHORT num));

/***
** Function: GetPrep
**
** Description:
**   This function allocates needed space for the
**   pre-program.
**   
***/
UBYTE    *GetPrep          _ARGS((IN   int size));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\fileio.h ===
/***
**
**   Module: FileIO
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      is the interface towards all low level I/O functions that are
**      are available on the current platform.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif

#define READONLY  0
#define READWRITE 1

struct ioFile;



/***
** Function: io_Close
**
** Description:
**   This function closes an open file.
***/
errcode           io_CloseFile   _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_ReadOneByte
**
** Description:
**   This function reads one byte from the current position in 
**   the given file. 
***/
USHORT FASTCALL   io_ReadOneByte _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_FileError
**
** Description:
**   This function returns the current error status of the file.
***/
boolean           io_FileError   _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_FileTell
**
** Description:
**   This function returns the current position in the file.
***/
long FASTCALL     io_FileTell    _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_RemoveFile
**
** Description:
**   This function removes an already closed file.
***/
void FASTCALL     io_RemoveFile  _ARGS((IN      char *name));


/***
** Function: io_OpenFile
**
** Description:
**   This function opens a file.
***/
struct ioFile     *io_OpenFile   _ARGS((IN      char *name,
                                        IN      int mode));


/***
** Function: io_FileSeek
**
** Description:
**   This function moves the current position in the file,
**   relative the beginning of the file.
***/
long FASTCALL     io_FileSeek    _ARGS((INOUT   struct ioFile *fp,
                                        INOUT   long where));


/***
** Function: io_WriteBytes
**
** Description:
**   This function writes a number of bytes, starting at the 
**   current position in the file.
***/
USHORT FASTCALL   io_WriteBytes  _ARGS((IN      UBYTE *,
                                        INOUT   USHORT, struct ioFile *));


/***
** Function: io_ReadBytes
**
** Description:
**   This function reades a number of bytes, starting at the 
**   current position in the file.
***/
USHORT FASTCALL   io_ReadBytes   _ARGS((INOUT   UBYTE *buf,
                                        INOUT   USHORT len,
                                        INOUT   struct ioFile *fp));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\freader.c ===
/***
**
**   Module: FReader
**
**   Description:
**    This is a module of the T1 to TT font converter. The module
**    contains functions that decodes and decrypts the data of a
**    T1 font file.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <ctype.h>
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "freader.h"
#include "pfb.h"


/***** LOCAL TYPES */
struct FontFile {

   /* Low-level I/O functions. */
   errcode (FASTCALL *fclose)(struct t1file *);
   short (FASTCALL *fgetc)(struct t1file *);
   struct t1file *(*fopen)(const char *);
   boolean (FASTCALL *fstatus)(const struct t1file *);
   struct t1file *io;

   /* Font file state. */
   enum {prolog, eexec} state;
   short nextbyte;
   USHORT r;
};


/***** CONSTANTS */
static const USHORT c1 = 52845;
static const USHORT c2 = 22719;


/***** MACROS */
#define IOGetByte(f)       ((*f->fgetc)(f->io))
#define IOError(f)         ((*f->fstatus)(f->io))
#define IOOpen(f,n)        ((*f->fopen)(n))
#define IOClose(f)         ((*f->fclose)(f->io))
#define SetNextByte(ff, b) ff->nextbyte = (b)
#define NextByte(ff)       (ff->nextbyte)
#define Eexec(ff)          (boolean)(ff->state == eexec)
#define StartEexec(ff)     ff->state = eexec



/***** STATIC FUNCTIONS */
/*-none-*/



/***** FUNCTIONS */

/***
** Function: GetByte
**
** Description:
**   Pull one byte out of the T1 font file.
***/
short FASTCALL GetByte(struct FontFile *ff)
{
   short b, nb;

   b = IOGetByte(ff);

   /* Decrypt it? */
   if (Eexec(ff))
      b = (short)Decrypt(&ff->r, (UBYTE)b);

   /* Record look-a-head */
   nb = NextByte(ff);
   SetNextByte(ff, b);

   return nb;
}



/***
** Function: GetNewLine
**
** Description:
**   Pull one whole line from the T1 font file, starting at
**   the current position.
***/
char *GetNewLine(struct FontFile *ff, char *buf, const USHORT len)
{
   short i = 0;

   /* Get string. */
   while ((buf[i] = (char)GetByte(ff))!='\n' &&
          buf[i]!='\r' && ++i<((short)len-1));

   /* Skip extra characters. */
   if (buf[i]!='\n' && buf[i]!='\r')
      while (!IOError(ff) && NextByte(ff)!='\n' && NextByte(ff)!='\r')
         (void)GetByte(ff);

   /* Terminate string. */
   buf[i] = '\0';

   /* Check for the start of the eexec section. */
   if (!strcmp(buf, "eexec"))
      StartEexec(ff);

   /* Check error condition. */
   if (IOError(ff))
      return NULL;

   return buf;
}



/***
** Function: Get_Token
**
** Description:
**   Pull one token from the T1 font file. A token 
**   is delimited by white space and various brackets.
***/
char *Get_Token(struct FontFile *ff, char *buf, const USHORT len)
{
   short i = 0;
   short nb;

   /* Skip leading blanks. */
   while (isspace(NextByte(ff)))
      (void)GetByte(ff);

   /* Get string. */
   do {
      buf[i] = (char)GetByte(ff);
      nb = NextByte(ff);
   } while (++i<((short)len-1) && !isspace(nb) && nb!='{' &&
            nb!='(' && nb!='[' && nb!='/');

   /* Skip extra characters. */
   while (!IOError(ff) && !isspace(nb) && nb!='{' &&
          nb!='(' && nb!='[' && nb!='/') {
      (void)GetByte(ff);
      nb = NextByte(ff);
   }

   /* Terminate string. */
   buf[i] = '\0';

   /* Check for the start of the eexec section. */
   if (!strcmp(buf, "eexec"))
      StartEexec(ff);

   /* Check error condition. */
   if (IOError(ff))
      return NULL;

   return buf;
}



/***
** Function: GetSeq
**
** Description:
**   Pull one sequence of bytes that are delimited by 
**   a given pair of characters, e.g. '[' and ']'.
***/
char *GetSeq(struct FontFile *ff,
             char *buf,
             const USHORT len)
{
   char d1, d2;
   short i = 0;
   short inside = 0;

   /* Skip leading blanks. */
   while (NextByte(ff)!='[' &&
          NextByte(ff)!='{' &&
          NextByte(ff)!='(' &&
          !IOError(ff))
      (void)GetByte(ff);

   /* match the bracket. */
   d1 = (char)NextByte(ff);
   if (d1=='[') 
      d2 = ']';
   else if (d1=='{')
      d2 = '}';
   else if (d1=='(')
      d2 = ')';
   else
      return NULL;


   /* Get string. */ 
   (void)GetByte(ff);
   inside=1;
   do {
      buf[i] = (char)GetByte(ff);
      if (buf[i]==d1)
         inside++;
      if (buf[i]==d2)
         inside--;
   } while (inside && ++i<((short)len-1));

   /* Terminate string. */
   buf[i] = '\0';

   /* Check error condition. */
   if (IOError(ff))
      return NULL;

   return buf;
}



/***
** Function: FRInit
**
** Description:
**   Initite the resources needed to read/decode data from
**   a T1 font file.
***/
errcode FRInit(const char *name, const enum ftype type, struct FontFile **ff)
{
   errcode status = SUCCESS;
   short b;

   if (((*ff)=(struct FontFile *)Malloc(sizeof(struct FontFile)))==NULL) {
      SetError(status = NOMEM);
   } else {

      /* Initiat the handle. */
      memset((*ff), '\0', sizeof(**ff));

      /* Initiate low-level I/O. */
      switch (type) {
         case pfb_file:
            (*ff)->fgetc = PFBGetByte;
            (*ff)->fclose = PFBFreeIOBlock;
            (*ff)->fstatus = PFBFileError;
            (*ff)->fopen = PFBAllocIOBlock;
            break;
         case mac_file:
#if MACFILEFORMAT
            (*ff)->fgetc = MACGetByte;
            (*ff)->fclose = MACFreeIOBlock;
            (*ff)->fstatus = MACFileError;
            (*ff)->fopen = MACAllocIOBlock;
            break;
#endif
         case ascii_file:
#if ASCIIFILEFORMAT
            (*ff)->fgetc = ASCIIGetByte;
            (*ff)->fclose = ASCIIFreeIOBlock;
            (*ff)->fstatus = ASCIFileError;
            (*ff)->fopen = ASCIIAllocIOBlock;
            break;
#endif
         default:
            LogError(MSG_ERROR, MSG_BADFMT, NULL);
            SetError(status = BADINPUTFILE);
            break;
      }

      (*ff)->io = NULL;
      if (((*ff)->io = IOOpen((*ff),name))==NULL) {
         SetError(status = BADINPUTFILE);
      } else {
         (*ff)->state = prolog;
         (*ff)->r = 55665;

         b=GetByte(*ff);
         SetNextByte((*ff), b);
      }
   }

   return status;
}



/***
** Function: FRCleanUp
**
** Description:
**   Free the resources used when reading/decoding data from
**   a T1 font file.
***/
errcode FRCleanUp(struct FontFile *ff)
{
   errcode status = SUCCESS;

   if (ff) {
      if (ff->io)
         status = IOClose(ff);
      Free(ff);
   }

   return status;
}



/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
UBYTE FASTCALL Decrypt(USHORT *r, const UBYTE cipher)
{
   UBYTE plain;

   plain = (UBYTE)(cipher ^ (*r>>8));
   *r = (USHORT)((cipher+*r) * c1 + c2);

   return plain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\encoding.h ===
/***
 **
 **   Module: Encoding
 **
 **   Description:
 **      This is a module of the T1 to TT font converter. The module
 **      contains interface functions for the global encoding table,
 **      i.e. this is an abstract data type.
 **
 **   Author: Michael Jansson
 **
 **   Created: 6/13/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif


#define ENC_UNICODE   (USHORT)0   /* Unicode */
#define ENC_MSWINDOWS (USHORT)1   /* Microsoft Windows UGL sub-set encoding. */
#define ENC_STANDARD  (USHORT)2   /* Postscript Standard Encoding */
#define ENC_MACCODES  (USHORT)3   /* Mac encoding. */
#define ENC_MAXCODES  (USHORT)4

#define NOTDEFCODE (USHORT)0xffff /* 0xfffff is not a vaild code point so use
												 it for the .notdef character. */
#define NOTDEFINIT	0xffffffffL	 /* Used to init encoding arrays. */
#define NOTDEFGLYPH	(USHORT)0	 /* Glyph zero must be the notdef glyph. */
#define NULLGLYPH		(USHORT)1	 /* Glyph one must be the null glyph. */

/***
** Function: LookupNotDef
**
** Description:
**   look up a the .notdef character
***/
const struct encoding   *LookupNotDef        _ARGS((void));


/***
** Function: LookupPSName
**
** Description:
**   Do a binary search for a postscript name, and return
**   a handle that can be used to look up a the character
**   code for a specific encoding schema.
***/
struct encoding   *LookupPSName        _ARGS((IN      struct encoding *table,
                                              INOUT   USHORT size,
                                              IN      char *name));


/***
** Function: LookupCharName
**
** Description:
**   look up a the character name for a
**   specific encoding scheme.
***/
const char        *LookupCharName      _ARGS((IN      struct encoding *enc));


/***
** Function: LookupCharCode
**
** Description:
**   look up a the character code for a
**   specific encoding scheme.
***/
USHORT            LookupCharCode       _ARGS((IN      struct encoding *enc,
                                              IN      USHORT type));

/***
** Function: DecodeChar
**
** Description:
**   look up an encoding record for a character code in some
**   known encoding.
***/
const struct encoding   *DecodeChar    _ARGS((IN   struct encoding *table,
                                              IN      USHORT size,
                                              IN      USHORT type,
                                              IN      USHORT code));
/***
** Function: AllocEncodingTable
**
** Description:
**   Create a new encoding ADT.
***/
struct encoding   *AllocEncodingTable  _ARGS((IN      USHORT num));


/***
** Function: SetEncodingEntry
**
** Description:
**   Set the mapping from a glyph name to character
**   codes for various platforms.
***/
void              SetEncodingEntry     _ARGS((INOUT   struct encoding *, 
                                              IN      USHORT entry,
                                              IN      char *name,
                                              IN      USHORT max,
                                              IN      USHORT *codes));
/***
** Function: RehashEncodingTable
**
** Description:
**   Prepare an encoding ADT so that entries can be
**   located in it.
***/
void              RehashEncodingTable  _ARGS((INOUT   struct encoding *, 
                                              IN      USHORT num));


/***
** Function: FreeEncoding
**
** Description:
**   Deallocate memory associated to the encoding array.
***/
void              FreeEncoding         _ARGS((INOUT   struct encoding *,
                                              IN      USHORT num));

/***
** Function: LookupFirstEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupFirstEnc(const struct encoding *encRoot,
												  const int encSize,
												  const struct encoding *encItem);


/***
** Function: LookupNextEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupNextEnc(const struct encoding *encRoot,
												 const int encSize,
												 const struct encoding *encItem);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\freader.h ===
/***
**
**   Module: FReader
**
**   Description:
**    This is a module of the T1 to TT font converter. The module
**    contains functions that decodes and decrypts the data of a
**    T1 font file.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif

enum ftype {pfb_file, mac_file, ascii_file};

struct FRHandle;
struct FontFile;



/***
** Function: GetByte
**
** Description:
**   Pull one byte out of the T1 font file.
***/
short FASTCALL  GetByte     _ARGS((INOUT   struct FontFile *ff));


/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
UBYTE FASTCALL  Decrypt     _ARGS((INOUT   USHORT *r, IN UBYTE b));


/***
** Function: FRCleanUp
**
** Description:
**   Free the resources used when reading/decoding data from
**   a T1 font file.
***/
errcode         FRCleanUp   _ARGS((INOUT   struct FontFile *ff));


/***
** Function: FRInit
**
** Description:
**   Initite the resources needed to read/decode data from
**   a T1 font file.
***/
errcode         FRInit      _ARGS((IN      char *name,
				   IN      enum ftype,
				   OUT     struct  FontFile **));
/***
** Function: GetSeq
**
** Description:
**   Pull one sequence of bytes that are delimited by 
**   a given pair of characters, e.g. '[' and ']'.
***/
char            *GetSeq     _ARGS((INOUT   struct FontFile *ff,
				   OUT     char *buf,
				   IN      USHORT len));
/***
** Function: Get_Token
**
** Description:
**   Pull one token from the T1 font file. A token 
**   is delimited by white space and various brackets.
***/
char            *Get_Token   _ARGS((INOUT   struct FontFile *ff,
				   OUT     char *buf,
				   IN      USHORT len));
/***
** Function: GetNewLine
**
** Description:
**   Pull one whole line from the T1 font file, starting at
**   the current position.
***/
char            *GetNewLine    _ARGS((INOUT   struct FontFile *ff,
				   OUT     char *buf,
				   IN      USHORT len));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\fvscodes.h ===
#ifndef __FONT_VALIDATION_STATUS_CODES_H
#define __FONT_VALIDATION_STATUS_CODES_H

//
// Detailed status codes for function CheckInfWithStatusA().
// These codes were added after the initial creation of the T1 installer library.
// CheckInfA() returns TRUE/FALSE.  However, a FALSE return value was
// not sufficiently descriptive for a user interface to respond appropriately.
// The function CheckInfWithStatusA() was added to provide detailed status info.
// No new return points were added to T1 installer functions.  These codes merely
// replace the original TRUE/FALSE return values.
//
// These codes are also used in the font folder font validation functions.
//
// The code is designed to return information that identifies:
//    a) What happened.
//    b) What file the status applies to (if applicable).
//
//
// bit->  15                 7               0
//       +-+----------------+-----------------+
//       |S| Status Code    | File Type Code  |
//       +-+----------------+-----------------+
//        |
//        +--- Severity bit.
//
//             1 = Error.  A true error like file i/o, mem alloc etc.
//             0 = No error. But status may indicate invalid font file.
// 
//                 >>>>>>> NOTE <<<<<<<<
//
//   This file contains codes that are generated by the
//   T1 installer function CheckType1A and by related font folder functions.
//   Since both the T1 installer and the font folder must understand
//   these codes, the font folder must include this file.  I apologize for
//   this added coupling between the T1 installer and the font folder but
//   it is necessary for detailed status reporting [brianau].
//
#define FVS_FILE_UNK    0x00  // File unknown or "doesn't matter".
#define FVS_FILE_PFM    0x01  // PFM file
#define FVS_FILE_PFB    0x02  // PFB file
#define FVS_FILE_AFM    0x03  // AFM file
#define FVS_FILE_INF    0x04  // INF file
#define FVS_FILE_TTF    0x05  // TTF file
#define FVS_FILE_FOT    0x06  // FOT file

//
// Status codes.
//
#define FVS_SUCCESS                 0x00   // No problem!
#define FVS_INVALID_FONTFILE        0x01   // Invalid font file or file name.
#define FVS_BAD_VERSION             0x02   // File version not supported.
#define FVS_FILE_BUILD_ERR          0x03   // Error building a font file.
#define FVS_FILE_EXISTS             0x04   // File already exists.
#define FVS_FILE_OPEN_ERR           0x05   // Couldn't find/open existing file.

//
// These codes indicate true system errors.  Note use of high bit
// to indicate severity.
//
#define FVS_FILE_CREATE_ERR         0x80   // Couldn't create new file.
#define FVS_FILE_IO_ERR             0x81   // General file I/O error.
#define FVS_INVALID_ARG             0x82   // Invalid arg passed to function.
#define FVS_EXCEPTION               0x83   // Exception caught.
#define FVS_INSUFFICIENT_BUF        0x84   // Destination buf too small.
#define FVS_MEM_ALLOC_ERR           0x85   // Error allocating memory.
#define FVS_INVALID_STATUS          0x86   // For ensuring status was set.

//
// Macros for creating and parsing status codes.
//
#define FVS_MAKE_CODE(c,f)   ((WORD)(((BYTE)(c) << 8) | (BYTE)(f)))  // Build code
#define FVS_STATUS(c)        (((c) >> 8) & 0x00FF) // Get status part
#define FVS_FILE(c)          ((c) & 0x00FF)        // Get file part
#define FVS_ISERROR(c)       (((c) & 0x8000) != 0) // Severity bit == 1 ?

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\hints.c ===
/***
**
**   Module: Hints
**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of the T1 to TT data translator module. It deals
**      with hints. Any part pf the T1 font that gets translated into
** TrueType instructions is done within this module.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <limits.h>
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "trig.h"
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "trans.h"
#include "hints.h"
#include "ttprog.h"



/***** CONSTANTS */
#define VERSION_SELECTOR 1    /* GetInfo[] selector for version number. */
#define VERSION_1_5     33    /* Version 1.5 of Windows TrueType rasterizer. */
#define STEMSNAPARGS    6     /* Number of args of the CreateStem TTFUN. */

#ifdef SYMETRICAL_REDUCTION
#define MIN_REDUCTION   4     /* Min reduction of the diag. cntrl. */
#endif
#define REDUCTION_C1    10    /* Min reduction, second method. */

#define STACKINC        500   /* Stack increment for arg-stack + prep. */

#define TARGSIZE        100   /* Size of temporary argument stack. */
#define TTFLEXSIZE      9     /* Largest size of a flex, w/o the points. */

#define TMP_TWILIGHTS         2
#define TWILIGHTS_PER_STEM    4

#define LEFTSTEM        1
#define RIGHTSTEM       2

#define SECONDPAIR      2

#define MAXRANGE        15

#define MAXEXTR         60       /* Max num of IP buckets. */

#define UNDEF           -1

#define STDV_CVT  1
#define STDH_CVT  2
#define SNAPV_CVT(v)       (v+3)
#define SNAPH_CVT(t1m, v)  (t1m->snapv_cnt+3+v)


/* External leading hint programs. */
static const UBYTE roman_hints[] = {
   /* Magic cookie. */
   op_pushb1 + 4, 66, 3, 8, 2, 16,
   op_clear,

   op_svcta | SUBOP_Y,
   op_pushb1, 3,

   /* Push 2pnt, in sub-pels. */
   op_mppem,
   op_mps,
   op_div,
   op_pushb1, 128,
   op_mul,

   /* Push InternalLeading, in sub-pels. */
   op_pushb1+1, 2, 1,
   op_md,
   op_sub,

   /* Push MAX(2pnt - i-leading, 0) */
   op_pushb1, 0,
   op_max,

   /* Add the external leading to the Ascent height. */
   op_shpix,
};
static const UBYTE swiss_hints[] = {
   /* Magic cookie. */
   op_pushb1 + 4, 66, 3, 8, 2, 16,
   op_clear,

   op_svcta | SUBOP_Y,
   op_pushb1, 3,

   /* 0<=height<=12.5 */
   op_mps,
   op_pushw1, HIBYTE(800), LOBYTE(800),   /* 12.5 pnt */
   op_gt,
   op_if,

   /* Push 2pnt, in sub-pels. */
   op_mppem,
   op_mps,
   op_div,
   op_pushb1, 128,
   op_mul,

   op_else,

   /* 12.5 < height <= 13.5 */
   op_mps,
   op_pushw1, HIBYTE(864), LOBYTE(864),   /* 13.5 pnt */
   op_gt,
   op_if,

   /* Push 3pnt, in sub-pels. */
   op_mppem, op_pushb1, 1, op_div,
   op_mps,
   op_div,
   op_pushb1, 192,
   op_mul,

   op_else,

   /* Push 4pnt, in sub-pels. */
   op_mppem, op_pushb1, 1, op_div,
   op_mps,
   op_div,
   op_pushw1, HIBYTE(256), /* LOBYTE(256) */ 0,
   op_mul,

   op_eif,

   op_eif,

   /* Push InternalLeading, in sub-pels. */
   op_pushb1+1, 2, 1,
   op_md,
   op_sub,
   op_dup,

   /* Push MAX(?pnt - i-leading, 0) */
   op_pushb1, 0,
   op_max,

   /* Add the external leading to the Ascent height. */
   op_shpix,

};


/* Pre-program. */
static const UBYTE PrepProg[] = {
   op_pushw1, 0x01, 0xff, op_scanctrl,

   op_pushb1, 1, op_rcvt,
   op_pushb1, 128,
   op_lt,
   op_if,

   op_pushb1 + 1, 4, 0, op_scantype, op_scantype,

   op_else,

   op_pushb1 + 1, 5, 1, op_scantype, op_scantype,

   op_eif,
};


/***** LOCAL TYPES */
/* Used for associating points to stems. */
typedef struct {
   short from;
   short to; 
} Range;


/* Zone bucket - Used for grid fitting a stem that may have
been divided into several stem instructions due to hint replacement. */
typedef struct TTStem { 
   funit side1;
   funit side2;
   short rp1;
   short rp2;
   short ref;
   enum aligntype align;
   Range range[MAXRANGE];
   short cnt;
} TTStem;




/***** MACROS */

/* General macros. */
#define Trans3X     TransX
#define TransRX     TransY

#define CLOSETO(v1, v2, eps)   (ABS((v1)-(v2))<=eps)

#define CHECK_ARGSIZE(args, ta, num, asize)   /* Check argument stack. */ \
/*lint -e571 -e644 */if (((ta)+(int)(num))>(asize)) { \
   short *newarg = NULL;\
   if ((newarg = Realloc(args, sizeof(short)*(USHORT)(ta+num+STACKINC)))==NULL) { \
      Free(args); \
      LogError(MSG_ERROR, MSG_NOMEM, NULL);\
      return 0;\
   } else {\
      args = newarg;\
      asize = (short)(ta+num+STACKINC);\
/*line +e571 +e644 */   }\
}
#define CHECK_PREPSIZE(prep, tp, num, psize)   /* Check prep size. */ \
if (((tp)+(num))>(psize)) { \
   UBYTE *newprep = NULL;\
   if ((newprep = Realloc(prep, tp+num+STACKINC))==NULL) { \
      Free(prep); \
      LogError(MSG_ERROR, MSG_NOMEM, NULL);\
      return 0;\
   } else {\
      prep = newprep;\
      psize = (short)(tp+num+STACKINC);\
   }\
}



/***** STATIC FUNCTIONS */



/***
** Function: ConvertFlex
**
** Description:
**   Convert a T1 flex hint into a TrueType IP[] 
**   intruction sequence that will reduce a flex
**   that is flatter than a given height.
***/
static errcode ConvertFlex(const struct T1Metrics *t1m,
                           const Flex *flexRoot,
                           const short *ttpnts,
                           UBYTE *pgm,
                           short *pc,
                           short *args,
                           short *pcd,
                           short *marg)
{
   errcode status = SUCCESS;
   int cis, last_cis = UNDEF;
   char dir, last_dir = 0;
   short targ[TARGSIZE];
   funit height, diff;
   const Flex *flex;
   short ta = 0;
   int num = 0;


   /* Return to the glyph zone. */
   if (flexRoot) {
      pgm[(*pc)++] = op_szps;
      args[(*pcd)++] = 1;
   }

   for (flex=flexRoot; flex; flex=flex->next) {

      /* Points lost in ConvertOutline? */
      if (ttpnts[flex->start]==UNDEF ||
          ttpnts[flex->mid]==UNDEF ||
          ttpnts[flex->end]==UNDEF) {
         LogError(MSG_WARNING, MSG_FLEX, NULL);
         continue;
      }

      /* Vertical or horizontal flex? */
      if (ABS(flex->midpos.x-flex->pos.x) <
          ABS(flex->midpos.y-flex->pos.y)) {
         dir = SUBOP_Y;
         height = TransY(t1m, (funit)(flex->startpos.y - flex->pos.y));
         diff = TransY(t1m, (funit)(flex->midpos.y - flex->startpos.y));
      } else {
         dir = SUBOP_X;
         height = TransX(t1m, (funit)(flex->startpos.x - flex->pos.x));
         diff = TransX(t1m, (funit)(flex->midpos.x - flex->startpos.x));
      }

      /* Skip flex without depth. */
      if (diff==0)
         continue;

      cis = (int)((long)flex->civ * (long)GetUPEM(t1m) / 100 / ABS(diff));

      if (cis!=last_cis || dir!=last_dir ||
          (ta+TTFLEXSIZE+(ttpnts[flex->end]-ttpnts[flex->start]))>=TARGSIZE) {
         if (last_cis!=UNDEF) {
            AssembleArgs(targ, ta, pgm, pc);
            while(num--)
               pgm[(*pc)++] = op_call;
            pgm[(*pc)++] = op_eif;
            ta = 0;
         }
         pgm[(*pc)++] = (UBYTE)(op_svcta | dir);
         pgm[(*pc)++] = op_mppem;
         pgm[(*pc)++] = op_gt;
         pgm[(*pc)++] = op_if;
         args[(*pcd)++] = (short)(cis+1);
         num = 0;
      }

      status = EmitFlex(targ, &ta, height,
                        ttpnts[flex->start],
                        ttpnts[flex->mid],
                        ttpnts[flex->end]);

      last_dir = dir;
      last_cis = cis;
      num++;

      if (status!=SUCCESS) {
         SetError(status = TTSTACK);
         break;
      }
   }
   if (num) {
      AssembleArgs(targ, ta, pgm, pc);
      while(num--)
         pgm[(*pc)++] = op_call;
      pgm[(*pc)++] = op_eif;
   }

   if ((*marg)<2)
      (*marg) = 2;

   return status;
}



/***
** Function: GetSnapV
**
** Description:
**   Return the closest snap width entry.
***/
static short GetSnapV(const struct T1Metrics *t1m, const funit width)
{
   USHORT dist = SHRT_MAX;
   USHORT j = 0;
   USHORT i;

   for (i=0; i<t1m->snapv_cnt; i++) {
      if (ABS(width-t1m->stemsnapv[i])<(short)dist) {
         dist = (USHORT)ABS(width-t1m->stemsnapv[i]);
         j = i;
      }
   }

   if (dist==SHRT_MAX)
      return UNDEF;

   return (short)j;
}





/***
** Function: GetSnapH
**
** Description:
**   Return the closest snap width entry.
***/
static short GetSnapH(const struct T1Metrics *t1m, const funit width)
{
   USHORT dist = SHRT_MAX;
   USHORT j = 0;
   USHORT i;

   for (i=0; i<t1m->snaph_cnt; i++) {
      if (ABS(width-t1m->stemsnaph[i])<(short)dist) {
         dist = (USHORT)ABS(width-t1m->stemsnaph[i]);
         j = i;
      }
   }

   if (dist==SHRT_MAX)
      return UNDEF;

   return (short)j;
}




/***
** Function: PosX
**
** Description:
**   This is a call-back function used by
**   Interpolate.
***/
static funit PosX(const Point pnt)
{
   return pnt.x;
}



/***
** Function: PosY
**
** Description:
**   This is a call-back function used by
**   Interpolate.
***/
static funit PosY(const Point pnt)
{
   return pnt.y;
}



/***
** Function: InRange
**
** Description:
**   This is function determines if a point is
**   within range of a hint zone.
***/
static boolean InRange(const short pnt, const Range *range, const short cnt)
{
   short k;

   for (k=0; k<cnt; k++) {
      if ((range[k].from<=pnt) &&
          (range[k].to>=pnt || range[k].to==ENDOFPATH))
         break;
   }

   return (boolean)(k != cnt);
}


/***
** Function: BoundingStems
**
** Description:
**   Determines what stems are located to the
**   left and to the right of a point on the
**   outline, given its position.
**   
***/
static short BoundingStems(short pnt, const short max_pnt,
                           const funit pos, const TTStem *stems,
                           const short cnt,
                           short *left, short *right)
{
   funit min, max;
   short i;

   max = SHRT_MAX;
   min = 1-SHRT_MAX;
   (*right) = UNDEF;
   (*left) = UNDEF;
   do {
      for (i=0; i<cnt; i++) {
         /* Is stem to the left and defined for the point? */
         if ((stems[i].side1<=pos) &&
             (stems[i].side1>min) &&
             InRange(pnt, stems[i].range, stems[i].cnt)) {
            min = stems[i].side1;
            (*left) = (short)i;
         }

         /* Is stem to the right and defined for the point. */
         if ((stems[i].side2>=pos) &&
             (stems[i].side2<max) &&
             InRange(pnt, stems[i].range, stems[i].cnt)) {
            max = stems[i].side2;
            (*right) = (short)i;
         }
      }

   /* Advance to the next point on the outline if we did not find stems. */
   } while (((*left)==UNDEF) && ((*right)==UNDEF) && (++pnt<(short)max_pnt));

   return pnt;
}




/***
** Function: EndOfRegion
**
** Description:
**   Determine what is the closest point, after the
**   given point, for a new hint replacement.
**   
***/
static short EndOfRegion(const short pnt, const TTStem *stem)
{
   short k;

   for (k=0; k<stem->cnt; k++) {
      if ((stem->range[k].from<=pnt) &&
          (stem->range[k].to>=pnt || stem->range[k].to==ENDOFPATH))
         break;
   }

   return (short)((k==stem->cnt || stem->range[k].to==ENDOFPATH)
                  ? SHRT_MAX : stem->range[k].to);
}




/***
** Function: AddToBucket
**
** Description:
**   This function will add a point, that
**   is located between two stems, into a
**   bucket that represents an interpolation
**   zone.
***/
static short AddToBucket(Extremas *extr,
                         short xcnt,
                         const short pnt,
                         const funit left,
                         const funit right,
                         const TTStem *stems)
{
   short rp1, rp2;
   short tmp, j;

   /* Pick the reference points (which are located in the twilight zone). */
   if (left!=UNDEF)
      rp1 = stems[left].rp2;
   else
      rp1 = UNDEF;
   if (right!=UNDEF)
      rp2 = stems[right].rp1;
   else
      rp2 = UNDEF;

   /* Normalize the reference points. */
   tmp = rp1;
   rp1 = (short)MIN(rp1, rp2);
   rp2 = (short)MAX(tmp, rp2);

   /* Create/Fill IP bucket. */
   for (j=0; j<xcnt; j++) 
      if (extr[j].rp1==rp1 && extr[j].rp2==rp2 && extr[j].n<MAXPTS)
         break;
   if (j==xcnt) {
      if (xcnt<MAXEXTR) {
         extr[xcnt].rp1 = rp1;
         extr[xcnt].rp2 = rp2;
         extr[xcnt].n = 0;
         xcnt++;
      } else {
         LogError(MSG_WARNING, MSG_EXTREME1, NULL);
      }
   }

   /* Add the point to the bucket. */
   if (j<MAXEXTR && extr[j].n<MAXPTS &&
       (extr[j].pts[extr[j].n] = pnt)!=UNDEF)
      extr[j].n++;

   return xcnt;
}


/***
** Function: AddSidePntToBucket
**
** Description:
**   Same as AddToBucket, but the points are
**   known to reside exactly on the side of
**   a stem, and should be controled by one
**   reference point alone. This is only needed
**   for sheared fonts, where controling side
**   point w.r.t. two reference poins leads
**   to problems.
***/
static short AddSidePntToBucket(Extremas *extr,
                                short xcnt,
                                const short pnt,
                                const short rp)
{
   short j;

   /* Create/Fill IP bucket. */
   for (j=0; j<xcnt; j++) 
      if (extr[j].rp1==rp && extr[j].rp2==UNDEF && extr[j].n<MAXPTS)
         break;
   if (j==xcnt) {
      if (xcnt<MAXEXTR) {
         extr[xcnt].rp1 = rp;
         extr[xcnt].rp2 = UNDEF;
         extr[xcnt].n = 0;
         xcnt++;
      } else {
         LogError(MSG_WARNING, MSG_EXTREME1, NULL);
      }
   }

   /* Add the point to the bucket. */
   if (j<MAXEXTR && extr[j].n<MAXPTS &&
       (extr[j].pts[extr[j].n] = pnt)!=UNDEF)
      extr[j].n++;

   return xcnt;
}





/***
** Function: PickSides
**
** Description:
**   Select the position of the left and
**   right side boundry of a point, given
**   the stem to the left and right of the
**   current point on the outline.
***/
static void PickSides(short left, short right,
                      funit *left_side,
                      funit *right_side,
                      TTStem *stems)
{
   if (left!=right) {
      if (left!=UNDEF)
         (*left_side) = stems[left].side2;
      else
         (*left_side) = 1-SHRT_MAX/2;
      if (right!=UNDEF)
         (*right_side) = stems[right].side1;
      else
         (*right_side) = SHRT_MAX/2;
   } else {
      (*left_side) = stems[left].side1;
      (*right_side) = stems[right].side2;
   }
}   





/***
** Function: PickSequence
**
** Description:
**   Determine at what point the current
**   hint sequence is ending.
***/
static short PickSequence(short left, short right, short pnt, TTStem *stems)
{
   short left_end;
   short right_end; 
   short new_seq;

   if (left!=UNDEF && right!=UNDEF) {
      left_end = EndOfRegion(pnt, &stems[left]);
      right_end = EndOfRegion(pnt, &stems[right]);
      new_seq = (short)MIN(left_end, right_end);
   } else if (left!=UNDEF) {
      left_end = EndOfRegion(pnt, &stems[left]);
      new_seq = left_end;
   } else {
      right_end = EndOfRegion(pnt, &stems[right]);
      new_seq = right_end;
   }

   return new_seq;
}



/***
** Function: CollectPoints
**
** Description:
**   This function will go through the points
**   that are local extremas and interpolate
**   them w.r.t. the enclosing stem sides.
**   The non-extreme points are handled with
**   an IUP[] instruction when this is done.
***/
static short CollectPoints(const Outline *orgpaths,
                           const short *ttpnts,
                           TTStem *stems,
                           short cnt,
                           Extremas *extr,
                           funit (*Position)(const Point))
{
   const Outline *path;
   short xcnt = 0;
   short i,tot;
   short prev_stem;
   funit pos;
   short left, right;
   funit left_side, right_side;
   funit max, min;
   short max_pnt, min_pnt;
   short new_seq, n;
   short prev_pnt;
   funit prev_pos;
   short first;
   short pnt = UNDEF;


   tot = 0;
   for (path=orgpaths; path; path=path->next) {
      first = BoundingStems(tot,
                            (short)(tot+(short)path->count),
                            Position(path->pts[0]),
                            stems, cnt, &left, &right);
      if (first==tot+(short)path->count) {
         tot = (short)(tot + path->count);
         continue;
      }

      new_seq = PickSequence(left, right, tot, stems);
      PickSides(left, right, &left_side, &right_side, stems);
      max = 1-SHRT_MAX/2;
      min_pnt = UNDEF;
      max_pnt = UNDEF;
      min = SHRT_MAX/2;
      prev_pnt = FALSE;
      prev_pos = UNDEF;
      prev_stem = UNDEF;
      for (i = (short)(first-tot); i<(short)path->count; i++) {
         if (OnCurve(path->onoff, i)) {
            pos = Position(path->pts[i]);
            n = (short)(i+tot);

            /* Have we crossed over a stem side. */
            if ((prev_stem!=RIGHTSTEM && pos<=left_side && max_pnt!=UNDEF) ||
                (prev_stem!=LEFTSTEM && pos>=right_side && min_pnt!=UNDEF)) {

               if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                  pnt = max_pnt;
                  prev_pos = max;

               } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                  pnt = min_pnt;
                  prev_pos = min;
               }

               xcnt = AddToBucket(extr, xcnt, ttpnts[pnt], left, right, stems);

               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
               prev_pnt = TRUE;
            }

            /* Crossing the side of a stem. */
            if ((pos>=right_side) || (pos<=left_side)) {
               if (pos<left_side)
                  prev_stem = RIGHTSTEM;
               else
                  prev_stem = LEFTSTEM;
            }

            /* Change left/right stem sides? */
            if ((n>new_seq) || (pos>=right_side) || (pos<=left_side)) {
               first = BoundingStems(n,
                                     (short)(path->count+tot),
                                     pos, stems, cnt,
                                     &left, &right);
               if (left==UNDEF && right==UNDEF)
                  break;

               i = (short)(i + first - n);
               new_seq = PickSequence(left, right, n, stems);
               PickSides(left, right, &left_side, &right_side, stems);
               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
            }

            /* Is the point on the side of the stem? */
            if (CLOSETO(pos,left_side,2) || CLOSETO(pos,right_side,2)) {
               if (!prev_pnt || !CLOSETO(prev_pos, pos, 2)) {
                  if (CLOSETO(pos, right_side, 2) ||
                      CLOSETO(pos, left_side, 2)) {
                     pnt = (short)n;
                     prev_pos = pos;

                  } else if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                     pnt = max_pnt;
                     prev_pos = max;
                     max_pnt = UNDEF;

                  } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                     pnt = min_pnt;
                     prev_pos = min;
                     min_pnt = UNDEF;
                  }

                  xcnt = AddToBucket(extr, xcnt, ttpnts[pnt],
                                     left, right, stems);
               }

               prev_pnt = TRUE;
               prev_pos = pos;
            } else {
               prev_pnt = FALSE;

               /* New extremum candidate? */
               if (pos>max) {
                  max = pos;
                  max_pnt = (short)n;
               }
               if (pos<min) {
                  min = pos;
                  min_pnt = (short)n;
               }
            }
         }
      }


      if (left!=UNDEF || right!=UNDEF) {
         if (max_pnt!=UNDEF) {
            xcnt = AddToBucket(extr, xcnt, ttpnts[max_pnt],
                               left, right, stems);
         }
         if (min_pnt!=UNDEF && min!=max) {
            xcnt = AddToBucket(extr, xcnt, ttpnts[min_pnt],
                               left, right, stems);
         }
      }

      tot = (short)(tot + path->count);
   }


   return xcnt;
}



/***
** Function: CollectObliquePoints
**
** Description:
**   This function performs the same task as
**   the "CollectPoint" function, with the
**   exception that the outline is known to
**   be sheared. Some of the logics 
**   is changed, bacause the IUP[] instruction
**   and some IP instruction will not behave
**   the same as in a non-sheared font.
**   This differance applies only to vertical
**   stems (hints resulting in horizontal motion of
**   of points).
***/
static short CollectObliquePoints(const Outline *orgpaths,
                                  const short *ttpnts,
                                  TTStem *stems,
                                  short cnt,
                                  Extremas *extr,
                                  funit (*Position)(const Point))
{
   const Outline *path;
   short xcnt = 0;
   short i,tot;
   short prev_stem;
   funit pos;
   short left, right;
   funit left_side, right_side;
   funit max, min;
   short max_pnt, min_pnt;
   short new_seq, n;
   short first;
   short pnt = UNDEF;


   tot = 0;
   for (path=orgpaths; path; path=path->next) {
      first = BoundingStems(tot,
                            (short)(tot+path->count),
                            Position(path->pts[0]),
                            stems, cnt, &left, &right);
      if (first==tot+(short)path->count) {
         tot = (short)(tot + path->count);
         continue;
      }

      new_seq = PickSequence(left, right, tot, stems);
      PickSides(left, right, &left_side, &right_side, stems);
      max = 1-SHRT_MAX/2;
      min_pnt = UNDEF;
      max_pnt = UNDEF;
      min = SHRT_MAX/2;
      prev_stem = UNDEF;
      for (i = (short)(first-tot); i<(short)path->count; i++) {
         if (OnCurve(path->onoff, i)) {
            pos = Position(path->pts[i]);
            n = (short)(i+tot);

            /* Have we crossed over a stem side. */
            if ((prev_stem!=RIGHTSTEM && pos<=left_side && max_pnt!=UNDEF) ||
                (prev_stem!=LEFTSTEM && pos>=right_side && min_pnt!=UNDEF)) {

               if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                  pnt = max_pnt;

               } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                  pnt = min_pnt;
               }

               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
            }

            /* Crossing the side of a stem. */
            if ((pos>=right_side) || (pos<=left_side)) {
               if (pos<left_side)
                  prev_stem = RIGHTSTEM;
               else
                  prev_stem = LEFTSTEM;
            }

            /* Change left/right stem sides? */
            if ((n>new_seq) || (pos>=right_side) || (pos<=left_side)) {
               first = BoundingStems(n,
                                     (short)(path->count+tot),
                                     pos, stems, cnt,
                                     &left, &right);
               if (left==UNDEF && right==UNDEF)
                  break;

               i = (short)(i + first - n);
               new_seq = PickSequence(left, right, n, stems);
               PickSides(left, right, &left_side, &right_side, stems);
               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
            }

            /* Is the point on the side of the stem? */
            if (CLOSETO(pos,left_side,2) || CLOSETO(pos,right_side,2)) {
               if (CLOSETO(pos, right_side, 2)) {
                  pnt = (short)n;
                  if (stems[right].side1==right_side)
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[right].rp1);
                  else
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[right].rp2);

               } else if (CLOSETO(pos, left_side, 2)) {
                  pnt = (short)n;
                  if (stems[left].side1==left_side)
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[left].rp1);
                  else
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[left].rp2);

               } else if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                  pnt = max_pnt;
                  max_pnt = UNDEF;

               } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                  pnt = min_pnt;
                  min_pnt = UNDEF;

               }

            } else {

               /* New extremum candidate? */
               if (pos>max) {
                  max = pos;
                  max_pnt = (short)n;
               }
               if (pos<min) {
                  min = pos;
                  min_pnt = (short)n;
               }
            }
         }
      }


      if (left!=UNDEF || right!=UNDEF) {
         if (max_pnt!=UNDEF) {
         }
         if (min_pnt!=UNDEF && min!=max) {
         }
      }

      tot = (short)(tot + path->count);
   }


   return xcnt;
}



/***
** Function: AddRange
**
** Description:
**   This function adds a point range to
**   a stem bucket.
***/
static void AddRange(TTStem *stem, const short i1, const short i2)
{
   short i;

   /* Check if a prior range can be extended. */
   if (i2!=ENDOFPATH) {
      for (i=0; i<stem->cnt; i++) {
         if (stem->range[i].from == i2+1)
            break;
      }
   } else {
      i = stem->cnt;
   }

   if (i==stem->cnt) {
      if (stem->cnt<MAXRANGE) {
         stem->range[stem->cnt].from = i1;
         stem->range[stem->cnt].to = i2;
         stem->cnt++;
      } else {
         LogError(MSG_WARNING, MSG_REPLC, NULL); 
      }
   } else {
      stem->range[i].from = i1;
   }

}


/***
** Function: CreateStemBuckets
**
** Description:
**   This function will create stem buckets.
**   Several duplicated T1 stem instructions
**   may be mapped to the same bucket.
***/
static short CreateStemBuckets(Stem *stemRoot,
                               Stem3 *stem3Root,
                               TTStem **result)
{
   Stem3 *stem3, *stm3;
   Stem *stem, *stm;
   TTStem *stems = NULL;
   short i, j;
   short cnt;
   short tzpnt = TMPPNT1+1;


   /* Count the stems. */
   cnt = 0;
   (*result) = NULL;
   for (stem3=stem3Root; stem3; stem3=stem3->next) {

      /* Skip obsolete stems. */
      if (stem3->stem1.i2 == NORANGE)
         continue;

      /* Look for a duplicate. */
      for (stm3=stem3Root; stm3!=stem3; stm3=stm3->next) {
         if (stm3->stem1.offset==stem3->stem1.offset &&
             stm3->stem2.offset==stem3->stem2.offset &&
             stm3->stem3.offset==stem3->stem3.offset)
            break;
      }

      /* Count this stem if it is not a duplicate. */
      if (stm3==stem3)
         cnt = (short)(cnt + 3);
   }
   for (stem=stemRoot; stem; stem=stem->next) {

      /* Skip obsolete stems. */
      if (stem->i2 == NORANGE)
         continue;

      /* Look for a duplicate. */
      for (stm=stemRoot; stm!=stem; stm=stm->next) {
         if (stm->offset==stem->offset && stm->width==stem->width)
            break;
      }

      /* Don't count this stem if it is a duplicate. */
      if (stm==stem)
         cnt++;
   }



   /* Initiate them. */
   if (cnt) {
      if ((stems = Malloc(sizeof(TTStem)*(USHORT)cnt))==NULL) {
         errcode status;
         SetError(status=NOMEM);
         return status;
      }

      i = (short)(cnt-1);

      /* Initiate the buckets for the stem3s */
      for (stem3=stem3Root; stem3; stem3=stem3->next) {

         /* Skip obsolete stems. */
         if (stem3->stem1.i2 == NORANGE)
            continue;

         /* Skip if bucket exist for this stem already. */
         for (j=(short)(i+1); j<cnt; j++) {
            if (stems[j].side1==stem3->stem1.offset &&
                stems[j].side2==(stem3->stem1.offset+stem3->stem1.width))
               break;
         }

         if (j==cnt) { 

            /* The rightmost stem is positioned w.r.t. to the middle. */
            stems[i].side1 = stem3->stem1.offset;
            stems[i].side2 = stem3->stem1.width + stem3->stem1.offset;
            stems[i].align = at_relative2;
            stems[i].ref = (short)(i-2);
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem3->stem1.i1;
            stems[i].range[0].to = stem3->stem1.i2;
            tzpnt+=2;
            i--;

            /* The leftmost stem is positioned w.r.t. to the middle. */
            stems[i].side1 = stem3->stem3.offset;
            stems[i].side2 = stem3->stem3.width + stem3->stem3.offset;
            stems[i].align = at_relative1;
            stems[i].ref = (short)(i-1);
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem3->stem1.i1;
            stems[i].range[0].to = stem3->stem1.i2;
            tzpnt+=2;
            i--;

            /* The middle stem is centered. */
            stems[i].side1 = stem3->stem2.offset;
            stems[i].side2 = stem3->stem2.width + stem3->stem2.offset;
            stems[i].align = at_centered;
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem3->stem1.i1;
            stems[i].range[0].to = stem3->stem1.i2;
            tzpnt+=2;
            i--;
         } else {
            AddRange(&stems[j-0], stem3->stem1.i1, stem3->stem1.i2);
            AddRange(&stems[j-1], stem3->stem3.i1, stem3->stem3.i2);
            AddRange(&stems[j-2], stem3->stem2.i1, stem3->stem2.i2);
         }
      }      

      /* Initiate the buckets for the stems. */
      for (stem=stemRoot; stem; stem=stem->next) {

         /* Skip obsolete stems. */
         if (stem->i2 == NORANGE)
            continue;

         /* Skip if bucket exist for this stem already. */
         for (j=(short)(i+1); j<(short)cnt; j++) {
            if (stems[j].side1==stem->offset &&
                stems[j].side2==(stem->offset+stem->width))
               break;
         }

         /* Initiate new bucket:
         Plain vstems and hstems are centered by default. Some
         hstems may be top- or bottom-aligen at a latter point.
         Some stems may be positioned w.r.t. another vstem if
         they overlapp and the RELATIVESTEMS compiler flag is
         turned on. */
         if (j==cnt) {
            stems[i].side1 = stem->offset;
            stems[i].side2 = stem->width + stem->offset;
            stems[i].align = at_centered;
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem->i1;
            stems[i].range[0].to = stem->i2;
            tzpnt+=2;
            i--;
         } else {
            AddRange(&stems[j], stem->i1, stem->i2);
         }
      }

      /* This happens if two stems are defined for the same
      hint replacement region and the same position, which
      is an Adobe Type 1 font error (broken font). The
      converter will recover by ignoring redundant stems. */
      if (i!=-1) {
         /* LogError(MSG_STEM3); */
         for (j=0; j<=i; j++) {
            stems[j].cnt = 0;
         }
      }
   }

   (*result) = stems;

   return (short)cnt;
}


/***
** Function: ResolveRelativeStem
**
** Description:
**   This function decides if two stems should
**   be aligned side1->side1, side2->side2, 
**   side1->side2 or side2->side1.
**   Stem are positition in relation to each
**   other for two reasons: They overlapp, they
**   are aligned side by side or they are
**   members of a stem3 hint.
***/
static void ResolveRelativeStem(TTStem *ref, TTStem *cur)
{
   /* SIDE1->SIDE2 */
   if (cur->side1==ref->side2) {
      cur->ref = ref->rp2;
      cur->align = at_relative1;


      /* SIDE1->SIDE2 */
   } else if (cur->side2==ref->side1) {
      cur->ref = ref->rp1;
      cur->align = at_relative2;


      /* SIDE1->SIDE1 */
   } else if ((cur->side1>ref->side1) &&
              ((cur->side1-ref->side1+10)>=
               (cur->side2-ref->side2))) {
      cur->ref = ref->rp1;
      cur->align = at_relative1;


      /* SIDE2->SIDE2 */
   } else {
      cur->ref = ref->rp2;
      cur->align = at_relative2;
   }
}



/***
** Function: ConvertVStems
**
** Description:
**   This function translate vstem and vstem3 to TT instructions.
***/
static errcode ConvertVStems(struct T1Metrics *t1m,
                             const Hints *hints,
                             const Outline *orgpaths,
                             const short *ttpnts,
                             UBYTE *pgm,
                             short *pc_ptr,
                             short *args,
                             short *pcd_ptr,
                             USHORT *twilight_ptr)
{
   Extremas extr[MAXEXTR];
   short xcnt = 0;
   errcode status = SUCCESS;
   short pc = *pc_ptr;
   short pcd = *pcd_ptr;
   TTStem *stems = NULL;
   short i;
   short cnt;


   /* Create the buckets. */
   if ((cnt = CreateStemBuckets(hints->vstems,
                                hints->vstems3,
                                &(stems)))==NOMEM) {
      status = NOMEM;
   } else {

      /* Update Max num of twilight points. */
      if ((cnt*TWILIGHTS_PER_STEM+TMP_TWILIGHTS) > (long)(*twilight_ptr))
         (*twilight_ptr) = (USHORT)(cnt * TWILIGHTS_PER_STEM + TMP_TWILIGHTS);

      if (cnt && stems) {

#if RELATIVESTEMS
         /* Do counter- and overlappning stem control? */
         for (i=0; i<cnt; i++) {
            short j;

            if (stems[i].align==at_centered) {
               funit prox = (funit)(ABS(MAX(100,
                                            stems[i].side2 -
                                            stems[i].side1)));
               funit prox2;
               prox2 = (funit)(prox/2);
               for (j=0; j<i; j++) {
                  if (stems[j].cnt &&
                      !((stems[i].side1 - (funit)prox > stems[j].side2) ||
                        (stems[i].side2 + (funit)prox < stems[j].side1)) &&
                      (ABS(stems[i].side2-stems[i].side1-
                           (stems[j].side2-stems[j].side1)) < prox2 ||
                       (short)(stems[i].side1 > stems[j].side2) !=
                       (short)(stems[i].side2 < stems[j].side1)))
                     break;
               }
               if (i!=j) {
                  if (stems[j].side1 < stems[i].side1)
                     stems[i].align = at_relative1;
                  else
                     stems[i].align = at_relative2;
                  stems[i].ref = j;
               }
            }
         }
#endif

         /** Vertical stem hints */
         EmitVerticalStems(pgm, &pc, args, &pcd);

         /* Handle sheared fonts by settin the projection
         vector to the italic angle. The TT instructions for
         the T1 hints can handle any projection vector. */
         if (t1m->fmatrix!=DEFAULTMATRIX && GetFontMatrix(t1m)[2]!=0) {
            Point pt;

            pt.x = 0; pt.y = 1000;
            TransAllPoints(t1m, &pt, (short)1, GetFontMatrix(t1m));
            SetProjection(pgm, &pc, args, &pcd, pt.x, pt.y);
         }

         /* Convert the buckets into instructions. */
         for (i=0; i<cnt; i++) {
            if (stems[i].cnt==0)
               continue;

            /* Resolve relative stems */
            if ((stems[i].align == at_relative1 ||
                 stems[i].align == at_relative2) &&
                stems[i].ref != UNDEF)
               ResolveRelativeStem(&stems[stems[i].ref], &stems[i]);

            /* Emit the instructions. */
            status = EmitVStem(pgm, &pc, args, &pcd, t1m,
                               ABS(stems[i].side2 - stems[i].side1),
                               TransRX(t1m, stems[i].side1),
                               TransRX(t1m, stems[i].side2),
                               Trans3X(t1m, stems[i].side1),
                               Trans3X(t1m, stems[i].side2),
                               (short)MIN(stems[i].rp1, stems[i].rp2),
                               stems[i].align,
                               stems[i].ref);

            if (status!=SUCCESS)
               break;
         }

         /* Collect extremas residing within and between stem sides. */
         if (SyntheticOblique(t1m)) {
            xcnt = CollectObliquePoints(orgpaths, ttpnts,
                                        stems, cnt, extr, PosX);
         } else {
            xcnt = CollectPoints(orgpaths, ttpnts,  stems, cnt,
                                 extr, PosX);
         }

         /* Do the 3% scaling */
         ScaleDown3(extr, xcnt, pgm, &pc, args, &pcd);

         /* Switch over to GLYPHZONE */
         pgm[pc++] = op_szp2;
         args[pcd++] = 1;

         /* Interpolate the local extremas. */
         EmitIP(extr, xcnt, pgm, &pc, args, &pcd, (short)SECONDPAIR);

         /* Interpolate/Shift the rest. */
         pgm[pc++] = op_iup | SUBOP_X;


         /* Free used resources */
         if (stems)
            Free(stems);
      }
   }

   *pc_ptr = pc;
   *pcd_ptr = pcd;

   return status;
}



/***
** Function: ResolveBlueHStem3
**
** Description:
**   This function attemts to resolves a conflict between
**   a hstem3 that has one of its stems in an alignment zone,
**   if there is such a conflict.
***/
static short ResolveBlueHStem3(TTStem *stems,
                               const short cnt,
                               const short k)
{
   short ref = stems[k].ref;
   TTStem tmp;
   short i;

   /* The parent stem of a hstem3 must be first in the 'stems' array,
   i.e. the order of the stems is important.  The children stems may
   therefore have to be swaped with the parten to enforce this condition. */

   if ((stems[k].align==at_relative1 ||
        stems[k].align==at_relative2) &&
       (stems[ref].align!=at_relative1 &&
        stems[ref].align!=at_relative2 &&
        stems[ref].align!=at_side1 &&
        stems[ref].align!=at_side2)) {
      tmp = stems[k];
      stems[k] = stems[ref];
      stems[k].align = at_relative1;
      stems[k].ref = ref;
      stems[ref] = tmp;
      for (i=0; i<cnt; i++) {
         if (i!=k && i!=ref &&
             (stems[i].align==at_relative1 ||
              stems[i].align==at_relative2) &&
             stems[i].ref == ref) {
            stems[i].ref = (short)k;
            if (i<k) {
               tmp = stems[k];
               stems[k] = stems[i];
               stems[i] = tmp;
            }
            break;
         }
      }

   } else {
      ref = k;
   }

   return ref;
}



/***
** Function: ConvertHStems
**
** Description:
**   This function converts hstem and hstem3 T1 instructions.
***/
static errcode ConvertHStems(struct T1Metrics *t1m,
                             const Hints *hints,
                             const Outline *orgpaths,
                             const short *ttpnts,
                             UBYTE *pgm,
                             short *pc_ptr,
                             short *args,
                             short *pcd_ptr,
                             USHORT *twilight_ptr)
{
   Extremas extr[MAXEXTR];
   short xcnt = 0;
   errcode status = SUCCESS;
   short pc = *pc_ptr;
   short pcd = *pcd_ptr;
   TTStem *stems = NULL;
   short i, k;
   short cnt;
   short cvt;

   /* Create the stem buckets. */
   cnt = CreateStemBuckets(hints->hstems, hints->hstems3, &(stems));
   if (cnt==NOMEM)
      return NOMEM;

   /* Update Max num of twilight points. */
   if ((USHORT)(cnt*TWILIGHTS_PER_STEM+TMP_TWILIGHTS) > (*twilight_ptr))
      (*twilight_ptr) = (USHORT)(cnt * TWILIGHTS_PER_STEM + TMP_TWILIGHTS);

#if RELATIVESTEMS
   /* Do counter- and overlappning stem control? */
   for (i=0; i<cnt; i++) {
      short j;

      if (stems[i].align==at_centered) {
         funit prox = (funit)(ABS(MAX(100, stems[i].side2 - stems[i].side1)));
         funit prox2;
         prox2 = (funit)(prox/2);
         for (j=0; j<i; j++) {
            if (stems[j].cnt &&
                !((stems[i].side1 - (funit)prox > stems[j].side2) ||
                  (stems[i].side2 + (funit)prox < stems[j].side1)) &&
                (ABS(stems[i].side2-stems[i].side1-
                     (stems[j].side2-stems[j].side1)) < prox2 ||
                 (short)(stems[i].side1 > stems[j].side2) !=
                 (short)(stems[i].side2 < stems[j].side1)))
               break;
         }
         if (i!=j) {
            if (stems[j].side1 < stems[i].side1)
               stems[i].align = at_relative1;
            else
               stems[i].align = at_relative2;
            stems[i].ref = j;
         }
      }
   }
#endif

   /* Do alignment control. */
   for (i=0; i<cnt; i++) {
      if ((cvt=GetBottomPos(GetBlues(t1m),
                            GetAlignment(t1m),
                            stems[i].side1))!=UNDEF) {
         k = ResolveBlueHStem3(stems, cnt, i);
         stems[k].ref = cvt;
         stems[k].align = at_side1;
      } else if ((cvt=GetTopPos(GetBlues(t1m),
                                GetAlignment(t1m),
                                stems[i].side2))!=UNDEF) {
         k = ResolveBlueHStem3(stems, cnt, i);
         stems[k].ref = cvt;
         stems[k].align = at_side2;
      } 
   }


   if (cnt && stems) {

      /** Horizontal stem hints */
      EmitHorizontalStems(pgm, &pc, args, &pcd);

      /* Convert the buckets into instructions. */
      for (i=0; i<cnt; i++) {

         if (stems[i].cnt==0)
            continue;

         /* Resolve relative stems */
         if ((stems[i].align == at_relative1 ||
              stems[i].align == at_relative2) &&
             stems[i].ref != UNDEF)
            ResolveRelativeStem(&stems[stems[i].ref], &stems[i]);

         /* Emit the instructions. */
         status = EmitHStem(pgm, &pc, args, &pcd, t1m,
                            stems[i].side2 - stems[i].side1,
                            TransY(t1m, stems[i].side1),
                            TransY(t1m, stems[i].side2),
                            (short)MIN(stems[i].rp1, stems[i].rp2),
                            stems[i].align,
                            stems[i].ref);

         if (status!=SUCCESS)
            break;
      }


      /* Interpolate extremas residing within and between stem sides. */
      xcnt = CollectPoints(orgpaths, ttpnts, stems, cnt, extr, PosY);

      /* Switch over to GLYPHZONE */
      pgm[pc++] = op_szp2;
      args[pcd++] = 1;

      /* Interpolate the local extremas. */
      EmitIP(extr, xcnt, pgm, &pc, args, &pcd, (short)0);

      /* Interpoalte/Shift the rest. */
      pgm[pc++] = op_iup | SUBOP_Y;

      /* Free used resources */
      if (stems)
         Free(stems);
   }

   *pcd_ptr = pcd;
   *pc_ptr = pc;

   return status;
}


/***** FUNCTIONS */

/***
** Function: GetRomanHints
**
** Description:
***/
const UBYTE *GetRomanHints(int *size)
{
   (*size) = sizeof(roman_hints);

   return roman_hints;
}


/***
** Function: GetSwissHints
**
** Description:
***/
const UBYTE *GetSwissHints(int *size)
{
   (*size) = sizeof(swiss_hints);

   return swiss_hints;
}


/***
** Function: MatchingFamily
**
** Description:
**   Locate the family alignment zone that is closest to
**   a given alignment zone.
***/
short MatchingFamily(const funit pos,
                     const funit *family,
                     const USHORT fcnt)
{
   funit min_dist = SHRT_MAX;
   short k = UNDEF;
   USHORT j;

   /* Look for the closest family blue. */
   for (j=0; j<fcnt; j+=2) {
      if (ABS(family[j] - pos) < min_dist) {
         k = (short)j;
         min_dist = ABS(family[j] - pos);
      }
   }

   return k;
}




/***
** Function: ConvertHints
**
** Description:
**   This functions converts hstem, hstem3, vstem, vstem3 and flex
**   hints, as well as doing diagonal control.
***/
errcode ConvertHints(struct T1Metrics *t1m,
                     const Hints *hints,
                     const Outline *orgpaths,
                     const Outline *paths,
                     const short *ttpnts,
                     UBYTE **gpgm,
                     USHORT *num,
                     USHORT *stack,
                     USHORT *twilight)
{
   errcode status = SUCCESS;
   UBYTE *pgm = NULL;
   short *args = NULL;
   short pc = 0;
   short pcd = 0;
   short cnt = 0;
   short narg = 0;
   short marg = 0;

   /* Access resources. */
   pgm=GetCodeStack(t1m);
   args=GetArgStack(t1m);


   /* Convert the vertical stem hints. */
   if (status==SUCCESS)
      status = ConvertVStems(t1m, hints, orgpaths, ttpnts,
                             pgm, &pc, args, &pcd, twilight);
   /* Convert the horizontal stem hints. */
   if (status==SUCCESS)
      status = ConvertHStems(t1m, hints, orgpaths, ttpnts,
                             pgm, &pc, args, &pcd, twilight);

   /* Convert flex hints. */
   if (status==SUCCESS)
      status = ConvertFlex(t1m, hints->flex, ttpnts,
                           pgm, &pc, args, &pcd, &marg);

   /********************
   * Adjust diagonals 
   * Do not reduce if dominant vertical stem width is more than 
   * 2.0 pels at 11PPEm and above. This occurs when:
   * 1) StdVW > 187 
   * 2) StdVW < 100 and ForceBold = TRUE
   **/
   if ((ForceBold(t1m)==1 && GetStdVW(t1m)>100 && GetStdVW(t1m)<187) ||
       (ForceBold(t1m)==0 && GetStdVW(t1m)<187))
      narg = ReduceDiagonals(paths, pgm, &pc, args, &pcd);
   if (narg>marg)
      marg = narg;

   if (pc>PGMSIZE) {
      SetError(status = TTSTACK);
   }
   if (pcd>ARGSIZE) {
      SetError(status = ARGSTACK);
   }

   /* Allocate the gpgm */
   (*gpgm) = NULL;
   (*num) = 0;
   (*stack) = 0;
   if (status==SUCCESS) {
      if (pc) {
         if (((*gpgm) = Malloc((USHORT)(pc+pcd*3)))==NULL) {
            SetError(status = NOMEM);
         } else {
            /* Assemble the arguments for the instructions */
            cnt = 0;
            AssembleArgs(args, pcd, (*gpgm), &cnt);
            memcpy(&(*gpgm)[cnt], pgm, (USHORT)pc);
            (*num) = (USHORT)(cnt + pc);
            (*stack) = (USHORT)(pcd + marg);
         }
      }
   }


   return status;
}



/***
** Function: BuildPreProgram
**
** Description:
**   This function builds the pre-program that will compute
**   the CVT and storage entries for the TT stem hint
**   instructions to work. 
***/
USHORT BuildPreProgram(const struct T1Metrics *t1m,
                       const WeightControl *weight,
                       Blues *blues,
                       AlignmentControl *align,
                       UBYTE **glob_prep,
                       const int prepsize,
                       USHORT *maxstack)
{
   UBYTE *prep = (*glob_prep);
   short *args = NULL;
   short ta, tp = 0;
   USHORT i, j;
   long shift;
   funit stdvw, stdhw;
   short cis;
   funit std_width;
   USHORT std_tres;
   funit min_dist;
   short k;
   short argsize = ARGSIZE;
   short psize = (short)prepsize;

   /* Allocate work space. */
   if ((args=Malloc(sizeof(args[0])*(USHORT)argsize))==NULL) {
      LogError(MSG_ERROR, MSG_NOMEM, NULL);
   } else {

      /* Copy the standard pre-program. */
      memcpy(prep, PrepProg, sizeof(PrepProg));
      tp = sizeof(PrepProg);
      (*maxstack) = 0;

      /**********
      * Compute Blue values.
      */

      prep[tp++] = op_pushb1; prep[tp++] = blues->blueScale;
      prep[tp++] = op_mppem;
      prep[tp++] = op_lt;
      prep[tp++] = op_if;
      prep[tp++] = op_pushb1;
      prep[tp++] = ONEPIXEL;
      prep[tp++] = op_smd;
      prep[tp++] = op_pushb1;
      prep[tp++] = TWILIGHT;
      prep[tp++] = op_szps;
      prep[tp++] = op_svcta | SUBOP_Y;
      prep[tp++] = op_rtg;


      /***********************/
      /*** ABOVE BlueScale ***/
      /***********************/

      /* Align the top zones. */
      for (i=0; i<blues->blue_cnt/2; i++) { 
         min_dist = SHRT_MAX;
         k = UNDEF;

         /*** Copy the FamilyBlue entries to the BlueValues if */
         /*** below the Family cut in size.         */
         if (blues->fblue_cnt>0) {

            /* Do the cut in on FamilyBlue/BlueValue. */
            k = MatchingFamily(blues->bluevalues[i*2],
                               blues->familyblues,
                               blues->fblue_cnt);
            min_dist = ABS(blues->bluevalues[i*2] - blues->familyblues[k]);

            /* Always FamilyBlue? */
            if (min_dist) { 
               cis = (short)(GetUPEM(t1m) / TransY(t1m, min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
            }

            /* Allocate a cvt if this family has not been used before. */
            if (blues->family_cvt[k/2]==UNDEF_CVT) {
               blues->family_cvt[k/2] = align->cvt;
               align->cvt += 2;
            }

            ta = 2;
            CHECK_ARGSIZE(args, ta, align->top[i].cnt, argsize);
            for (j=0; j<align->top[i].cnt; j++) {
               args[ta++] = (short)align->top[i].pos[j].cvt;
            }
            CHECK_PREPSIZE(prep, tp, 2*ta+10, psize);
            tp = (short)CopyFamilyBlue(prep, tp, args, ta);
            if ((ta+2)>(int)(*maxstack))
               (*maxstack) = (USHORT)(ta+2);

            /* Set up the zone. */
            tp = (short)SetZone(prep, (USHORT)tp,
            (short)(blues->family_cvt[k/2]));

            if (min_dist>0)
               prep[tp++] = op_else;
         }


         /*** Set up the zone. */
         CHECK_PREPSIZE(prep, tp, STACKINC, psize);
         tp = (short)SetZone(prep, (USHORT)tp,
              (short)(align->top[i].blue_cvt));
         if (k!=UNDEF && min_dist) {
            prep[tp++] = op_eif;
         }


         /*** Round and enforce overshoot. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->top[i].cnt, argsize);
         for (j=0; j<align->top[i].cnt; j++) {
            if ((align->top[i].pos[j].y -
                 blues->bluevalues[i*2])*F8D8 > blues->blueShift) {
               args[ta++] = (short)align->top[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignOvershoot(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)ta;
         }

         ta = 2;
         CHECK_ARGSIZE(args, ta, align->top[i].cnt, argsize);
         for (j=0; j<align->top[i].cnt; j++) {
            if ((align->top[i].pos[j].y -
                 blues->bluevalues[i*2])*F8D8 <= blues->blueShift) {
               args[ta++] = (short)align->top[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignFlat(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)(ta+2);
         }
      }



      /* Align the bottom zones. */
      for (i=0; i<blues->oblue_cnt/2; i++) { 
         min_dist = SHRT_MAX;
         k = UNDEF;

         /*** Copy the FamilyBlue entries to the BlueValues if */
         /*** below the Family cut in size.         */
         if (blues->foblue_cnt>0) {

            /* Do the cut in on FamilyBlue/BlueValue. */
            k = MatchingFamily(blues->otherblues[i*2],
                               blues->familyotherblues,
                               blues->foblue_cnt);
            min_dist = ABS(blues->otherblues[i*2] -
                           blues->familyotherblues[k]);

            /* Always FamilyBlue? */
            if (min_dist) { 
               cis = (short)(GetUPEM(t1m) / TransY(t1m, min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
            }

            /* Allocate a cvt if this family has not been used before. */
            if (blues->familyother_cvt[k/2]==UNDEF_CVT) {
               blues->familyother_cvt[k/2] = align->cvt++;
            }

            ta = 2;
            CHECK_ARGSIZE(args, ta, align->bottom[i].cnt, argsize);
            for (j=0; j<align->bottom[i].cnt; j++) {
               args[ta++] = (short)align->bottom[i].pos[j].cvt;
            }
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)CopyFamilyBlue(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)ta;


            /* Set up the zone. */
            tp = (short)SetZone(prep, (USHORT)tp,
            (short)blues->familyother_cvt[k/2]);

            if (min_dist>0)
               prep[tp++] = op_else;
         }


         /*** Set up the zone. */
         tp = (short)SetZone(prep, (USHORT)tp,
              (short)align->bottom[i].blue_cvt);
         if (k!=UNDEF && min_dist) {
            prep[tp++] = op_eif;
         }


         /*** Round and enforce overshoot. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->bottom[i].cnt, argsize);
         for (j=0; j<align->bottom[i].cnt; j++) {
            if ((align->bottom[i].pos[j].y -
                 blues->otherblues[i*2+1])*F8D8 > blues->blueShift) {
               args[ta++] = (short)align->bottom[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignOvershoot(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)ta;
         }

         ta = 2;
         CHECK_ARGSIZE(args, ta, align->bottom[i].cnt, argsize);
         for (j=0; j<align->bottom[i].cnt; j++) {
            if ((align->bottom[i].pos[j].y -
                 blues->otherblues[i*2+1])*F8D8 <= blues->blueShift) {
               args[ta++] = (short)align->bottom[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignFlat(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)(ta+2);
         }
      }




      /***********************/
      /*** BELOW BlueScale ***/
      /***********************/
      prep[tp++] = op_else;

      /*** Align the top zones. */

      for (i=0; i<blues->blue_cnt/2; i++) { 

         /* Initiate */
         min_dist = SHRT_MAX;
         k = UNDEF;

         /* switch between blues and family blues. */
         if (blues->fblue_cnt) {

            /* Look for the closest family blue. */
            k = MatchingFamily(blues->bluevalues[i*2],
                               blues->familyblues,
                               blues->fblue_cnt);
            min_dist = ABS(blues->bluevalues[i*2] - blues->familyblues[k]);

            /* Copy/Round the family overshoot position to the zone. */
            if (min_dist) {
               cis = (short)(GetUPEM(t1m) / TransY(t1m, (funit)min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
               ta = 2;
               CHECK_ARGSIZE(args, ta, align->top[i].cnt*2, argsize);
               for (j=0; j<align->top[i].cnt; j++) {
                  args[ta++] = (short)(blues->family_cvt[k/2] + 1);
                  args[ta++] = (short)(align->top[i].pos[j].cvt);
               }
               CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
               tp = (short)CopyZone(prep, tp, args, ta);
               if (ta>(short)(*maxstack))
                  (*maxstack) = (USHORT)(ta+2);


               prep[tp++] = op_else;
            }
         }

         /* Copy/Round the blue overshoot position to the zone position. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->top[i].cnt*2, argsize);
         for (j=0; j<align->top[i].cnt; j++) {
            args[ta++] = (short)(align->top[i].blue_cvt + 1);
            args[ta++] = (short)(align->top[i].pos[j].cvt);
         }
         CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
         tp = (short)CopyZone(prep, tp, args, ta);
         if (ta>(short)(*maxstack))
            (*maxstack) = (USHORT)ta;

         if (k!=UNDEF && min_dist>0)
            prep[tp++] = op_eif;
      }


      /*** Align the bottom zones. */
      for (i=0; i<blues->oblue_cnt/2; i++) { 

         /* Initiate. */
         min_dist = SHRT_MAX;
         k = UNDEF;

         /* switch between blues and family blues. */
         if (blues->foblue_cnt) {

            /* Look for the closest family blue. */
            k = MatchingFamily(blues->otherblues[i*2],
                               blues->familyotherblues,
                               blues->foblue_cnt);
            min_dist = ABS(blues->otherblues[i*2] -
                           blues->familyotherblues[k]);

            /* Copy/Round the family overshoot position to the zone. */
            if (min_dist) {
               cis = (short)(GetUPEM(t1m) / TransY(t1m, (funit)min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
               ta = 2;
               CHECK_ARGSIZE(args, ta, align->bottom[i].cnt*2, argsize);
               for (j=0; j<align->bottom[i].cnt; j++) {
                  args[ta++] = (short)(blues->familyother_cvt[k/2]);
                  args[ta++] = (short)(align->bottom[i].pos[j].cvt);
               }
               CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
               tp = (short)CopyZone(prep, tp, args, ta);
               if (ta>(short)(*maxstack))
                  (*maxstack) = (USHORT)ta;

               prep[tp++] = op_else;
            }
         }

         /* Copy/Round the blue overshoot position to the zone position. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->bottom[i].cnt*2, argsize);
         for (j=0; j<align->bottom[i].cnt; j++) {
            args[ta++] = (short)(align->bottom[i].blue_cvt);
            args[ta++] = (short)(align->bottom[i].pos[j].cvt);
         }
         CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
         tp = (short)CopyZone(prep, tp, args, ta);
         if (ta>(short)(*maxstack))
            (*maxstack) = (USHORT)ta;

         if (k!=UNDEF && min_dist>0)
            prep[tp++] = op_eif;
      }


      /* EIF[] MMPEM<BlueScale */
      prep[tp++] = op_eif;


      prep[tp++] = op_pushb1;
      prep[tp++] = 64;
      prep[tp++] = op_smd;


      /**************************************/
      /***      STEM WEIGHT CONTROL       ***/
      /**************************************/

      /****** ForceBold ***/
      if (ForceBold(t1m)) {
         prep[tp++] = op_pushb1+2;
         prep[tp++] = STDV_CVT;
         prep[tp++] = ONEPIXEL*3/4;
         prep[tp++] = STDV_CVT;
         prep[tp++] = op_rcvt;
         prep[tp++] = op_max;
         prep[tp++] = op_wcvtp;
      }


      /******
      * Compute width of horizontal stems. 
      */
      prep[tp++] = op_rtdg;
      prep[tp++] = op_svcta | SUBOP_Y;
      if ((std_width = GetStdHW(t1m))==0)
         std_width = GetDefStdHW(t1m);
      std_width = TransY(t1m, std_width);
      std_tres = (USHORT)(GetUPEM(t1m) * 2 / std_width);
      ta = 0;
      CHECK_ARGSIZE(args, ta, STEMSNAPARGS*weight->cnt_hw, argsize);
      for (i=0; i<weight->cnt_hw; i++) { 
         funit width = TransY(t1m, weight->hwidths[i].width);
         short snap = GetSnapH(t1m, weight->hwidths[i].width);
         USHORT storage = weight->hwidths[i].storage;
         USHORT snap_ci, std_ci;
         short snap_cvt;

         std_ci = CutInSize(width, std_width, std_tres, GetUPEM(t1m));
         if (snap!=UNDEF) {
            snap_ci = CutInSize(width, TransY(t1m, t1m->stemsnaph[snap]),
                                std_tres, GetUPEM(t1m));
            snap_cvt = (short)SNAPH_CVT(t1m, snap);
            ta = (short)SnapStemArgs(args, (USHORT)ta,
                 width, STDH_CVT, (USHORT)snap_cvt,
                 std_ci, snap_ci, storage);
         } else {
            ta = (short)StdStemArgs(args, (USHORT)ta, width, STDH_CVT,
                std_ci, storage);
         }
      } 
      if (ta+2>(short)(*maxstack))   /* Args + loopcnt + fun_num */
         (*maxstack) = (USHORT)(ta+2);
      CHECK_PREPSIZE(prep, tp, ta*2+2, psize);
      AssembleArgs(args, ta, prep, &tp);
      if (t1m->snaph_cnt)
         tp = (short)CreateSnapStems(prep, (USHORT)tp, (short)weight->cnt_hw);
      else
         tp = (short)CreateStdStems(prep, (USHORT)tp,  (short)weight->cnt_hw);


      /******
      * Compute width of vertical stems. 
      */
      prep[tp++] = op_svcta | SUBOP_X;
      if ((std_width = GetStdVW(t1m))==0)
         std_width = GetDefStdVW(t1m);
      std_width = TransX(t1m, std_width);
      std_tres = (USHORT)(GetUPEM(t1m) * 2 / std_width);
      ta = 0;
      CHECK_ARGSIZE(args, ta, STEMSNAPARGS*weight->cnt_vw, argsize);
      for (i=0; i<weight->cnt_vw; i++) { 
         funit width = TransX(t1m, weight->vwidths[i].width);
         short storage = (short)weight->vwidths[i].storage;
         short snap = GetSnapV(t1m, weight->vwidths[i].width);
         USHORT snap_ci, std_ci;
         short snap_cvt;

         std_ci = CutInSize(width, std_width, std_tres, GetUPEM(t1m));
         if (snap!=UNDEF) {
            snap_ci = CutInSize(width, TransX(t1m, t1m->stemsnapv[snap]),
                                std_tres, GetUPEM(t1m));
            snap_cvt = (short)SNAPV_CVT(snap);
            ta = (short)SnapStemArgs(args, (USHORT)ta,
                              width, STDV_CVT, (USHORT)snap_cvt,
                              std_ci, snap_ci, (USHORT)storage);
         } else {
            ta = (short)StdStemArgs(args, (USHORT)ta, width,
                STDV_CVT, std_ci, (USHORT)storage);
         }
      } 
      if (ta+2>(short)(*maxstack))
         (*maxstack) = (USHORT)(ta+2);
      CHECK_PREPSIZE(prep, tp, ta*2+2, psize);
      AssembleArgs(args, ta, prep, &tp);
      if (t1m->snapv_cnt)
         tp = (short)CreateSnapStems(prep, (USHORT)tp, (short)weight->cnt_vw);
      else
         tp = (short)CreateStdStems(prep, (USHORT)tp, (short)weight->cnt_vw);



      prep[tp++] = op_rtg;


      /******
      * Compute diagonal control parameters.
      */
      CHECK_PREPSIZE(prep, tp, STACKINC, psize);
      if ((stdvw = GetStdVW(t1m))==0)
         stdvw = GetDefStdVW(t1m);
      if ((stdhw = GetStdHW(t1m))==0)
         stdhw = GetDefStdHW(t1m);
      if (stdvw && stdhw) {
         cis = (short)(MAX((GetUPEM(t1m) + GetUPEM(t1m)/2) / std_width, 1));
#ifdef SYMETRICAL_REDUCTION
         shift = (long)GetUPEM(t1m);
#else
         shift = (long)GetUPEM(t1m)*(long)MIN(stdvw,stdhw)/
                 (long)MAX(stdvw, stdhw)/2L+(long)GetUPEM(t1m)/2L;
#endif
      } else if (stdvw || stdhw) {
         cis = (short)(1548 / MAX(stdvw, stdhw) + 1);
         shift = (long)GetUPEM(t1m)/2;
      } else {
         cis = 41;
         shift = GetUPEM(t1m)/4;
      }

      prep[tp++] = op_pushb1; prep[tp++] = STORAGE_DIAG;
      prep[tp++] = op_pushb1; prep[tp++] = STDV_CVT;
      prep[tp++] = op_rcvt;
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)48;
      prep[tp++] = op_lt;
      prep[tp++] = op_if;

#ifdef SYMETRICAL_REDUCTION
      /* Compute the reduction. */
      shift = (short)(shift/(long)cis/4);
      prep[tp++] = op_npushw;
      prep[tp++] = 2;
      prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = 0;
      prep[tp++] = HIBYTE(shift);
      prep[tp++] = LOBYTE(shift);
      prep[tp++] = op_wcvtf;
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = op_rcvt;
      prep[tp++] = op_pushb1; prep[tp++] = MIN_REDUCTION;
      prep[tp++] = op_add;
#else
      /* Compute the reduction. */
      shift = (short)(shift/(long)cis/2);
      prep[tp++] = op_npushw;
      prep[tp++] = 2;
      prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = 0;
      prep[tp++] = HIBYTE(shift);
      prep[tp++] = LOBYTE(shift);
      prep[tp++] = op_wcvtf;
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = op_rcvt;
      prep[tp++] = op_pushb1; prep[tp++] = REDUCTION_C1;
      prep[tp++] = op_max;
#endif

      prep[tp++] = op_else;
      prep[tp++] = op_pushb1; prep[tp++] = 0;
      prep[tp++] = op_eif;

      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = VERSION_1_5;
      prep[tp++] = VERSION_SELECTOR;
      prep[tp++] = op_getinfo;
      prep[tp++] = op_gt;
      prep[tp++] = op_if;
      prep[tp++] = op_pushb1;
      prep[tp++] = 8;
      prep[tp++] = op_mul;
      prep[tp++] = op_eif;

      prep[tp++] = op_ws;

      Free(args);
   } 

   (*glob_prep) = prep;                             
   return (USHORT)tp;
}




/***
** Function: GetFontProg
**
** Description:
**   Return the font program.
***/
const UBYTE *GetFontProg(void)
{
   return tt_GetFontProg();
}


/***
** Function: GetFontProgSize
**
** Description:
**   Return the size of the font program.
***/
const USHORT GetFontProgSize(void)
{
   return tt_GetFontProgSize();
}


/***
** Function: GetNumFuns
**
** Description:
**   Return the number of functions defined in
**   the font program.
***/
const USHORT GetNumFuns(void)
{
   return tt_GetNumFuns();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\fwriter.h ===
/***
**
**   Module: T1Parser
**
**   Description:
**  This is a module of the T1 to TT font converter. The module
**  contains functions that is used by the Builder moduler, to
**  manage the lowlevel writing to the TT font file, as well as
**  generic check sum, table length and table offset computations.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef FWRITER_H
#define FWRITER_H

#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif


#define TBL_OS2   (USHORT)0
#define TBL_CMAP  (USHORT)1 
#define TBL_CVT   (USHORT)2 
#define TBL_FPGM  (USHORT)3 
#define TBL_GASP  (USHORT)4 
#define TBL_GLYF  (USHORT)5
#define TBL_HEAD  (USHORT)6 	      
#define TBL_HHEA  (USHORT)7 	      
#define TBL_HMTX  (USHORT)8 	      
#define TBL_KERN	(USHORT)9 
#define TBL_LOCA  (USHORT)10			 	      
#define TBL_MAXP  (USHORT)11			 	      
#define TBL_NAME  (USHORT)12			 	      
#define TBL_POST  (USHORT)13			 	      
#define TBL_PREP  (USHORT)14			 
#define NUMTBL    15L
#define TBLDIRSIZE (4L+4L+4L+4L)

/* Referenced types. */
typedef struct ioFile OutputFile;




/***
** Function: WriteTableHeader
**
** Description:
**   This function initiates a TT font file, by initiating 
**   a handle used when writing the tables and by writing
**   the leading table dictionary of the file.
***/
void        WriteTableHeader  _ARGS((INOUT   OutputFile *file));


/***
** Function: OpenOutputFile
**
** Description:
***/
OutputFile  *OpenOutputFile   _ARGS((IN      char *name));


/***
** Function: CloseOutputFile
**
** Description:
***/
errcode     CloseOutputFile   _ARGS((INOUT   OutputFile *fp));


/***
** Function: FileError
**
** Description:
***/
boolean     FileError         _ARGS((INOUT   OutputFile *fp));


/***
** Function: FileTell
**
** Description:
***/
long        FileTell          _ARGS((INOUT   OutputFile *fp));


/***
** Function: WriteLong
**
** Description:
**   This function writes a 32-bit integer in the
**   Big Endian byte order, regardless of the
**   used byte order.
***/
void        WriteLong         _ARGS((IN      ULONG val,
                                     INOUT   OutputFile *file));

/***
** Function: WriteShort
**
** Description:
**   This function writes a 16-bit integer in the
**   Big Endian byte order, regardless of the used
**   byte order.
***/
void        WriteShort        _ARGS((IN      USHORT val,

                                     INOUT   OutputFile *file));
/***
** Function: WriteByte
**
** Description:
**   This function writes an 8-bit integer in the
**   Big Endian byte order, regardless of used
**   byte order.
***/
void        WriteByte         _ARGS((IN      UBYTE val,
                                     INOUT   OutputFile *file));

/***
** Function: WriteChecksum
**
** Description:
**   This function completes the whole TT font file,
**   by computing the check sum of the whole file and writing
**   it at the designated place.
***/
void        WriteChecksum     _ARGS((IN      long offset,
                                     INOUT   OutputFile *file));

/***
** Function: FileSeek
**
** Description:
***/
long        FileSeek          _ARGS((INOUT   OutputFile *fp,

                                     IN      long where));
/***
** Function: WriteBytes
**
** Description:
***/
USHORT      WriteBytes        _ARGS((IN      UBYTE *buf,
                                     IN      USHORT len,
                                     INOUT   OutputFile *fp));
/***
** Function: CompleteTable
**
** Description:
**   This function completes a TT font file table,
**   by computing the check sum and writing it, the
**   table length and table offset to the table directory
**   of the TT font file.
**
**   Please note the dependency that this function must
**   be called right after the last byte of the contents
**   of the table have been written.
***/
errcode     CompleteTable     _ARGS((IN      long offset,
                                     IN      USHORT num,
                                     INOUT   OutputFile *file));
/***
** Function: RemoveFile
**
** Description:
**  Removes an already closed output file.
***/
void        RemoveFile        _ARGS((IN      char *name));
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\hints.h ===
/***
**
**   Module: Hints
**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of the T1 to TT data translator module. It deals
**      with hints. Any part pf the T1 font that gets translated into
** TrueType instructions is done within this module.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



/***
** Function: ConvertHints
**
** Description:
**   This functions converts hstem, hstem3, vstem, vstem3 and flex
**   hints, as well as doing diagonal control.
***/
errcode        ConvertHints      _ARGS((INOUT   struct T1Metrics *t1m,
                                        IN      Hints *hints,
                                        IN      Outline *orgpaths,
                                        IN      Outline *paths,
                                        IN      short *sideboard,
                                        OUT     UBYTE **gpgm,
                                        OUT     USHORT *num,
                                        OUT     USHORT *stack,
                                        OUT     USHORT *twilight));

/***
** Function: BuildPreProgram
**
** Description:
**   This function builds the pre-program that will compute
**   the CVT and storage entries for the TT stem hint
**   instructions to work. 
***/
USHORT         BuildPreProgram   _ARGS((IN      struct T1Metrics *t1m,
                                        IN      WeightControl *weight,
                                        INOUT   Blues *blues,
                                        INOUT   AlignmentControl *align,
                                        INOUT   UBYTE **prep,
                                        IN      int prepsize,
                                        OUT     USHORT *maxprepstack));
/***
** Function: MatchingFamily
**
** Description:
**   Locate the family alignment zone that is closest to
**   a given alignment zone.
***/
short          MatchingFamily    _ARGS((IN      funit pos,
                                        IN      funit *family,
                                        IN      USHORT fcnt));
/***
** Function: GetRomanHints
**
** Description:
***/
const UBYTE    *GetRomanHints    _ARGS((OUT     int *size));


/***
** Function: GetSwissHints
**
** Description:
***/
const UBYTE    *GetSwissHints    _ARGS((OUT     int *size));


/***
** Function: GetFontProg
**
** Description:
**   Return the font program.
***/
const UBYTE    *GetFontProg      _ARGS((void));


/***
** Function: GetFontProgSize
**
** Description:
**   Return the size of the font program.
***/
const USHORT   GetFontProgSize   _ARGS((void));


/***
** Function: GetNumFuns
**
** Description:
**   Return the number of functions defined in
**   the font program.
***/
const USHORT   GetNumFuns        _ARGS((void));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#

!IFNDEF BUILDMSG
BUILDMSG=
!ENDIF

!IFNDEF NO_STRICT
STRICT=1
!ENDIF

SDKINC = $(_NTROOT)\public\sdk\inc
OAKINC = $(_NTROOT)\public\oak\inc

TARGETSRCS=     msg00001.bin \
                t1msg.h      \
                t1msg.rc

all: $(TARGETSRCS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: cleansrc all

cleansrc:
    -erase $(TARGETSRCS)

msg00001.bin t1msg.rc t1msg.h: t1msg.mc
    mc -v t1msg.mc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\makepfm.c ===
//---------------------------------------------------------------------------
// makepfm.c
//---------------------------------------------------------------------------
// Create PFM file for Rev-3 fonts
//---------------------------------------------------------------------------
//
//      Copyright 1990, 1991 -- Adobe Systems, Inc.
//      PostScript is a trademark of Adobe Systems, Inc.
//
// NOTICE:  All information contained herein or attendant hereto is, and
// remains, the property of Adobe Systems, Inc.  Many of the intellectual
// and technical concepts contained herein are proprietary to Adobe Systems,
// Inc. and may be covered by U.S. and Foreign Patents or Patents Pending or
// are protected as trade secrets.  Any dissemination of this information or
// reproduction of this material are strictly forbidden unless prior written
// permission is obtained from Adobe Systems, Inc.
//
//---------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <ctype.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "windows.h"
#pragma pack(1)
#include "makepfm.h"
#pragma pack(4)

#include "fvscodes.h"  // FVS_xxxxxx (font validation status) codes and macros.

#ifdef WIN30
  #define LPCSTR LPSTR
#endif


#define WINATM 1
#if !WINATM
LPSZ stringtable[] = {
"MAKEPFM utility version %s released on %s.\n",
"Copyright (C) 1989-91, Adobe Systems Inc. All Rights Reserved.\n\n",
"Usage: makepfm [options] AFMfile\n",
"  -h n   - set device to PCL (n=1 for 1 byte typeface, 2 for 2 byte).\n",
"  -p n   - integral point size - only for PCL.\n",
"  -c str - PCL symbol set (9U for WinAnsi for example) - only for PCL.\n",
"  -d     - set orientation to landscape - only for PCL.\n",
"  -e str - encoding file.\n",
"  -o str - output file.\n",
"  -i str - fontinfo file.\n",
"  -l str - optional log file - defaults to \"user.log\".\n",
"  -f str - take input parameters from file instead of command line.\n",
"  -w     - display warning messages.\n",
"  -s n   - force dfCharSet to n.\n",
"Unrecognized command-line option: '%s'\n",
"Unable to open: %s\n",
"Too many track kerning data. Ignoring after %d.\n",
"Unexpected end of file - expected: %s\n",
"Expected: %s - current line: %s\n",
"Parsing character metrics - current line: %s\n",
"Parsing %s.\n",
"Missing \"MSFamily\" value\n",
"Can't create: %s\n",
"Disk is full...\n",
"Memory allocation\n",
"encoding file",
"Creating font metrics ( %s )",
"Finished.\n",
NULL
};
#endif

AFM afm = { 0 };
static ETM etm;
static PFM pfm;
static PFMEXT pfmext;
static DRIVERINFO d;

typedef LPSZ GlyphName;

/* CHAR rgbBuffer[2048]; The file buffer */
CHAR rgbBuffer[8704] = "";   /* increased to handle an additional 512 bytes of width info */
static INT cbBuffer;         /* The number of bytes in the buffer */
static LPSZ pbBuffer;        /* Ptr to current location in buffer */
static CHAR rgbLine[160];    /* The current line of text being processed */
static LPSZ szLine;          /* Ptr to the current location in the line */
static BOOL fEOF = FALSE;
static BOOL fUnGetLine = FALSE;

/*----------------------------------------------------------------------------*/
static LPSZ notdef = "";

#define IBULLET     0x095   /* 87-1-15 sec (was 1) */
#define ISPACE      0x20
#define IWINSPACE   0xA0

static BOOL parseError;
static float sf;             /* scale factor for converting to display widths */

/* flags type of PFM to build POSTSCRIPT vs PCL */
INT devType = POSTSCRIPT;

PCLINFO pclinfo = { PORTRAIT, WINANSI_SET, epsymGENERIC8, 0, 0, 2, 0, NULL };
static SHORT fiCapHeight;
static GlyphName *glyphArray;
extern GlyphName *SetupGlyphArray(LPSZ) ;
INT charset = -1;
static BOOL forceVariablePitch = TRUE;

/* names, pointers, and handles for output, log and data files */
CHAR encfile[FNAMEMAX] = "";
CHAR outfile[FNAMEMAX] = "";
CHAR infofile[FNAMEMAX] = "";

static INT fhIn;

#define TK_STARTKERNDATA      2
#define TK_STARTKERNPAIRS     3
#define TK_KPX                4
#define TK_ENDKERNPAIRS       5
#define TK_ENDKERNDATA        6
#define TK_FONTNAME           7
#define TK_WEIGHT             8
#define TK_ITALICANGLE        9
#define TK_ISFIXEDPITCH       10
#define TK_UNDERLINEPOSITION  11
#define TK_UNDERLINETHICKNESS 12
#define TK_FONTBBOX           13
#define TK_CAPHEIGHT          14
#define TK_XHEIGHT            15
#define TK_DESCENDER          16
#define TK_ASCENDER           17
#define TK_STARTCHARMETRICS   18
#define TK_ENDCHARMETRICS     19
#define TK_ENDFONTMETRICS     20
#define TK_STARTFONTMETRICS   21
#define TK_STARTTRACKKERN     22
#define TK_TRACKKERN          23
#define TK_ENDTRACKKERN       24

static KEY afmKeys[] = {
    "FontBBox",           TK_FONTBBOX,
    "StartFontMetrics",   TK_STARTFONTMETRICS,
    "FontName",           TK_FONTNAME,
    "Weight",             TK_WEIGHT,
    "ItalicAngle",        TK_ITALICANGLE,
    "IsFixedPitch",       TK_ISFIXEDPITCH,
    "UnderlinePosition",  TK_UNDERLINEPOSITION,
    "UnderlineThickness", TK_UNDERLINETHICKNESS,
    "CapHeight",          TK_CAPHEIGHT,
    "XHeight",            TK_XHEIGHT,
    "Descender",          TK_DESCENDER,
    "Ascender",           TK_ASCENDER,
    "StartCharMetrics",   TK_STARTCHARMETRICS,
    "EndCharMetrics",     TK_ENDCHARMETRICS,
    "StartKernData",      TK_STARTKERNDATA,
    "StartKernPairs",     TK_STARTKERNPAIRS,
    "KPX",                TK_KPX,
    "EndKernPairs",       TK_ENDKERNPAIRS,
    "EndKernData",        TK_ENDKERNDATA,
    "EndFontMetrics",     TK_ENDFONTMETRICS,
    "StartTrackKern",     TK_STARTTRACKKERN,
    "TrackKern",          TK_TRACKKERN,
    "EndTrackKern",       TK_ENDTRACKKERN,
    NULL,                 0
    };

#define CVTTOSCR(i)  (INT)(((float)(i) * sf) + 0.5)
#define DRIVERINFO_VERSION      (1)

/*----------------------------------------------------------------------------*/
VOID KxSort(KX *, KX *);
INT GetCharCode(LPSZ,  GlyphName *);
VOID ParseKernPairs(INT);
VOID ParseTrackKern(INT);
VOID ParseKernData(INT);
VOID ParseFontName(VOID);
VOID ParseMSFields(VOID);
VOID ParseCharMetrics(BOOL);
VOID ParseCharBox(BBOX *);
LPSZ ParseCharName(VOID);
INT ParseCharWidth(VOID);
INT ParseCharCode(VOID);
VOID ParseBoundingBox(BOOL);
VOID ParsePitchType(VOID);
VOID InitAfm(VOID);
short _MakePfm(VOID);
BOOL ReadFontInfo(INT);
VOID GetCharMetrics(INT, CM *);
VOID SetCharMetrics(INT, CM *);
VOID GetSmallCM(INT, CM *);
VOID SetFractionMetrics(INT, INT, INT, INT);
VOID FixCharWidths(VOID);
VOID SetAfm(VOID);
VOID SetAvgWidth(VOID);
VOID SetMaxWidth(VOID);

/*----------------------------------------------------------------------------*/
VOID ResetBuffer(VOID);
VOID PutByte(SHORT);
VOID PutRgb(LPSZ, INT);
VOID PutWord(SHORT);
VOID PutLong(long);
VOID SetDf(INT);
VOID PutString(LPSZ);
VOID PutDeviceName(LPSZ);
VOID PutFaceName(VOID);
BOOL MakeDf(BOOL, SHORT, LPSZ);
VOID PutPairKernTable(SHORT);
VOID PutTrackKernTable(SHORT);
VOID PutExtentOrWidthTable(INT);
BOOL WritePfm(LPSZ);

/*----------------------------------------------------------------------------*/
VOID SetDriverInfo(VOID);
VOID PutDriverInfo(INT);
LPSZ GetEscapeSequence(VOID);

/*----------------------------------------------------------------------------*/
VOID AfmToEtm(BOOL);
VOID PutEtm(BOOL);

/*----------------------------------------------------------------------------*/
VOID StartParse(VOID);
BOOL szIsEqual(LPSZ, LPSZ);
VOID szMove(LPSZ, LPSZ, INT);
BOOL GetBuffer(INT);
VOID UnGetLine(VOID);
BOOL GetLine(INT);
BOOL _GetLine(INT);
VOID EatWhite(VOID);
VOID GetWord(LPSZ, INT);
BOOL GetString(LPSZ, INT);
BOOL GetNumber(SHORT *);
BOOL GetFloat(float *, SHORT *);
INT MapToken(LPSZ, KEY *);
INT GetToken(INT, KEY *);

/*----------------------------------------------------------------------------*/
GlyphName *AllocateGlyphArray(INT);
VOID PutGlyphName(GlyphName *, INT, LPSZ);

/*----------------------------------------------------------------------------*/
#if DEBUG_MODE
VOID DumpAfm(VOID);
VOID DumpKernPairs(VOID);
VOID DumpKernTracks(VOID);
VOID DumpCharMetrics(VOID);
VOID DumpPfmHeader(VOID);
VOID DumpCharWidths(VOID);
VOID DumpPfmExtension(VOID);
VOID DumpDriverInfo(VOID);
VOID DumpEtm(VOID);
#endif

/*----------------------------------------------------------------------------*/
extern INT  OpenParseFile(LPSZ);                 /* main.c */
extern INT  OpenTargetFile(LPSZ);
// extern VOID cdecl PostWarning(LPCSTR,  ...);
// extern VOID cdecl PostError(LPCSTR, ...);
extern LPVOID AllocateMem(UINT);
extern VOID FreeAllMem(VOID);
extern VOID WriteDots(VOID);
extern GlyphName *SetupGlyphArray(LPSZ);
#if !WINATM
extern GlyphName *NewGlyphArray(INT);
extern LPSZ ReadLine(FILE *, LPSZ, INT);
extern LPSZ FirstTokenOnLine(FILE *, LPSZ, INT);
extern LPSZ Token(INT);
extern VOID ParseError(VOID);
#endif

/*----------------------------------------------------------------------------*/
/***************************************************************
* Name: KxSort()
* Action: Sort the pair kerning data using the quicksort algorithm.
******************************************************************/
VOID KxSort(pkx1, pkx2)
KX *pkx1;
KX *pkx2;
{
  static WORD iPivot;
  INT iKernAmount;
  KX *pkx1T;
  KX *pkx2T;

  if (pkx1>=pkx2) return;

  iPivot = pkx1->iKey;;
  iKernAmount = pkx1->iKernAmount;
  pkx1T = pkx1;
  pkx2T = pkx2;

  while (pkx1T < pkx2T)
    {
    while (pkx1T < pkx2T)
      {
      if (pkx2T->iKey < iPivot)
        {
        pkx1T->iKey = pkx2T->iKey;
        pkx1T->iKernAmount = pkx2T->iKernAmount;
        ++pkx1T;
        break;
        }
      else
        --pkx2T;
      }
    while (pkx1T < pkx2T)
      {
      if (pkx1T->iKey > iPivot)
        {
        pkx2T->iKey = pkx1T->iKey;
        pkx2T->iKernAmount = pkx1T->iKernAmount;
        --pkx2T;
        break;
        }
      else
        ++pkx1T;
      }
    }
  pkx2T->iKey = iPivot;
  pkx2T->iKernAmount = (SHORT)iKernAmount;
  ++pkx2T;
  if ((pkx1T - pkx1) < (pkx2 - pkx2T))
    {
    KxSort(pkx1, pkx1T);
    KxSort(pkx2T, pkx2);
    }
  else
    {
    KxSort(pkx2T, pkx2);
    KxSort(pkx1, pkx1T);
    }
}

/******************************************************************
* Name: GetCharCode(glyphname, glypharray)
* Action: Lookup glyphname in glypharray & return index.
********************************************************************/
INT GetCharCode(glyphname, glypharray)

LPSZ glyphname;
GlyphName *glypharray;
{
  register INT i;

  if ( STRCMP(glyphname, "") != 0 )
      for(i=0; glypharray[i]!=NULL; i++)
          if ( STRCMP(glypharray[i], glyphname) == 0 ) return(i);
  /* printf("GetCharCode: Undefined character = %s\n", glyphname); */
  return(-1);
}

/******************************************************************
* Name: ParseKernPairs()
* Action: Parse the pairwise kerning data.
********************************************************************/
VOID ParseKernPairs(pcl)
INT pcl;
{
  UINT iCh1, iCh2;
  KP *pkp;
  INT iToken;
  WORD cPairs, i;
  SHORT iKernAmount;
  CHAR szWord[80];

  GetNumber(&cPairs);
  if( cPairs == 0 )
      return;

  pkp = &afm.kp;
  pkp->cPairs = 0;
  pkp->rgPairs = (PKX) AllocateMem( (UINT) (sizeof(KX) * cPairs) );
  if( pkp->rgPairs == NULL ) {
      ; // PostError(str(MSG_PFM_BAD_MALLOC));
      parseError = TRUE;
      return;
      }

  for (i = 0; i < cPairs; ++i) {
      if( !GetLine(fhIn) ) break;
      if( GetToken(fhIn, afmKeys) != TK_KPX ) {
          UnGetLine();
          break;
          }
      GetWord(szWord, sizeof(szWord));
      iCh1 = (UINT)GetCharCode(szWord, glyphArray);
      GetWord(szWord, sizeof(szWord));
      iCh2 = (UINT)GetCharCode(szWord, glyphArray);
      GetNumber(&iKernAmount);

      /* no kern pairs for unencoded characters or miniscule kern amounts */
      if( (iCh1 == -1 || iCh2 == -1) || (pcl && CVTTOSCR(iKernAmount) == 0) )
          continue;

      pkp->rgPairs[pkp->cPairs].iKey = iCh2 << 8 | iCh1;
      pkp->rgPairs[pkp->cPairs++].iKernAmount =
                                       (pcl) ? CVTTOSCR(iKernAmount) : iKernAmount;
      }

  GetLine(fhIn);
  iToken = GetToken(fhIn, afmKeys);
  if( iToken == TK_EOF )
      ; // PostWarning(str(MSG_PFM_BAD_EOF), "EndKernPairs");
  else if( iToken != TK_ENDKERNPAIRS ) {
      ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndKernPairs", rgbLine);
      parseError = TRUE;
      }
  KxSort(&afm.kp.rgPairs[0], &afm.kp.rgPairs[afm.kp.cPairs - 1]);
}

/******************************************************************
* Name: ParseTrackKern()
* Action: Parse the track kerning data.
********************************************************************/
VOID ParseTrackKern(pcl)
INT pcl;
{
  float one;
  INT i;
  KT *pkt;
  INT iToken;

  one = (float) 1;
  pkt = &afm.kt;
  GetNumber(&pkt->cTracks);
  if( pkt->cTracks > MAXTRACKS) ; // PostWarning(str(MSG_PFM_BAD_TRACK), MAXTRACKS);

  for (i = 0; i < pkt->cTracks; ++i) {
    if( !GetLine(fhIn) ) {
        ; // PostError(str(MSG_PFM_BAD_EOF), "EndTrackKern");
        parseError = TRUE;
        return;
        }
    if( GetToken(fhIn, afmKeys) != TK_TRACKKERN ) {
        ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndTrackKern", rgbLine);
        parseError = TRUE;
        return;
        }
    if( i < MAXTRACKS) {
        GetNumber(&pkt->rgTracks[i].iDegree);
        GetFloat(&one, &pkt->rgTracks[i].iPtMin);
        (pcl) ? GetFloat(&sf, &pkt->rgTracks[i].iKernMin) :
                GetFloat(&one, &pkt->rgTracks[i].iKernMin);
        GetFloat(&one, &pkt->rgTracks[i].iPtMax);
        (pcl) ? GetFloat(&sf, &pkt->rgTracks[i].iKernMax) :
                GetFloat(&one, &pkt->rgTracks[i].iKernMax);
        }
    }

  GetLine(fhIn);
  iToken = GetToken(fhIn, afmKeys);
  if( iToken == TK_EOF ) {
    ; // PostError(str(MSG_PFM_BAD_EOF), "EndTrackKern");
    parseError = TRUE;
    }
  else if( iToken != TK_ENDTRACKKERN ) {
    ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndTrackKern", rgbLine);
    parseError = TRUE;
    }
}

/********************************************************
* Name: ParseKernData()
* Action: Start processing the kerning data.
*************************************************************/
VOID ParseKernData(pcl)
INT pcl;
{
  INT iToken;
  do {
    if ( !GetLine(fhIn) ) {
        ; // PostError(str(MSG_PFM_BAD_EOF), "EndKernData");
        parseError = TRUE;
        }
    iToken = GetToken(fhIn, afmKeys);
    if( iToken == TK_STARTKERNPAIRS ) ParseKernPairs(pcl);
    else if( iToken == TK_STARTTRACKKERN ) ParseTrackKern(pcl);
    } while( iToken != TK_ENDKERNDATA);
}

/***********************************************************
* Name: ParseFontName()
* Action: Move the font name from the input buffer into the afm
*    structure.
**************************************************************/
VOID ParseFontName()
{
  EatWhite();
  szMove(afm.szFont, szLine, sizeof(afm.szFont));
}

/**************************************************************
* Name: ParseCharMetrics()
* Action: Parse the character metrics entry in the input file
*   and set the width and bounding box in the afm structure.
*****************************************************************/
VOID ParseCharMetrics(pcl)
BOOL pcl;
{
  SHORT cChars;
  INT i, iChar, iWidth;
  BBOX rcChar;

  if (afm.iFamily == FF_DECORATIVE)
      glyphArray = AllocateGlyphArray(255);
  else
      glyphArray = SetupGlyphArray(encfile);
  if( glyphArray == NULL ) {
      parseError = TRUE;
      return;
      }
  GetNumber(&cChars);
  for (i = 0; i < cChars; ++i) {
      if( !GetLine(fhIn) ) {
          ; // PostError(str(MSG_PFM_BAD_EOF), "EndCharMetrics");
          parseError = TRUE;
          return;
          }
      iChar = ParseCharCode();
      iWidth = ParseCharWidth();
      if( afm.iFamily == FF_DECORATIVE ) {
          if( iChar < 0 || iChar > 255 ) continue;
          PutGlyphName(glyphArray, iChar, ParseCharName());
      } else {
          iChar = GetCharCode(ParseCharName(), glyphArray);
          if( iChar == -1 ) continue;
          }
      ParseCharBox(&rcChar);
      if( parseError == TRUE ) return;

      afm.rgcm[iChar].iWidth = (pcl) ? CVTTOSCR(iWidth) : iWidth;
      afm.rgcm[iChar].rc.top = (pcl) ? CVTTOSCR(rcChar.top) : rcChar.top;
      afm.rgcm[iChar].rc.left = (pcl) ? CVTTOSCR(rcChar.left) : rcChar.left;
      afm.rgcm[iChar].rc.right = (pcl) ? CVTTOSCR(rcChar.right) : rcChar.right;
      afm.rgcm[iChar].rc.bottom = (pcl) ? CVTTOSCR(rcChar.bottom) : rcChar.bottom;
      }
  GetLine(fhIn);
  if (GetToken(fhIn, afmKeys)!=TK_ENDCHARMETRICS) {
      ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndCharMetrics", rgbLine);
      parseError = TRUE;
      }
}

/***************************************************************
* Name: ParseCharBox()
* Action: Parse the character's bounding box and return its
*   dimensions in the destination rectangle.
*****************************************************************/
VOID ParseCharBox(prc)
BBOX *prc;   /* Pointer to the destination rectangle */
{
  CHAR szWord[16];

  GetWord(szWord, sizeof(szWord));
  if( szIsEqual("B", szWord) ) {
      GetNumber(&prc->left);
      GetNumber(&prc->bottom);
      GetNumber(&prc->right);
      GetNumber(&prc->top);
      }
  else {
      ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
      parseError = TRUE;
      return;
      }
  EatWhite();
  if (*szLine++ != ';') {
      ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
      parseError = TRUE;
      }
}

/*********************************************************
* Name: ParseCharName()
* Action: Parse a character's name
************************************************************/
LPSZ ParseCharName()
{
  static CHAR szWord[40];

  EatWhite();
  GetWord(szWord, sizeof(szWord));
  if (szIsEqual("N", szWord))
    GetWord(szWord, sizeof(szWord));
  else {
    ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    parseError = TRUE;
    return(szWord);
    }
  EatWhite();
  if (*szLine++ != ';') {
    ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    parseError = TRUE;
    }
  return(szWord);
}

/***********************************************************
* Name: ParseCharWidth()
* Action: Parse a character's width and return its numeric
*   value.
*************************************************************/
INT ParseCharWidth()
{
  SHORT iWidth;
  CHAR szWord[16];


  GetWord(szWord, sizeof(szWord));
  if (szIsEqual("WX", szWord)) {
    GetNumber(&iWidth);
    if (iWidth==0) ; // PostWarning(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    EatWhite();
    if (*szLine++ != ';') {
        ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
        parseError = TRUE;
        }
    }
  else {
    ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    parseError = TRUE;
    }
  return(iWidth);
}

/*****************************************************************
* Name: ParseCharCode()
* Action: Parse the ascii form of a character's code point and
*   return its numeric value.
******************************************************************/
INT ParseCharCode()
{
  SHORT iChar;
  CHAR szWord[16];

  iChar = 0;
  GetWord(szWord, sizeof(szWord));
  if (szIsEqual("C", szWord)) {
    GetNumber(&iChar);
    if (iChar==0) {
        ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
        parseError = TRUE;
        return(0);
        }
    EatWhite();
    if (*szLine++ != ';') {
        ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
        parseError = TRUE;
        }
    }
  return(iChar);
}

/****************************************************************
* Name: ParseBounding Box()
* Action: Parse a character's bounding box and return its size in
*   the afm structure.
*******************************************************************/
VOID ParseBoundingBox(pcl)
BOOL pcl;
{
  SHORT i;

  /*  8-26-91 yh  Note that values in rcBBox are not scaled for PCL either */
  GetNumber(&i);
//  afm.rcBBox.left = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.left = i;
  GetNumber(&i);
//  afm.rcBBox.bottom = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.bottom = i;
  GetNumber(&i);
//  afm.rcBBox.right = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.right = i;
  GetNumber(&i);
//  afm.rcBBox.top = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.top = i;
}

/************************************************************
* Name: ParsePitchType()
*
* Action: Parse the pitch type and set the variable pitch
*      flag in the afm structure.
*         Always set the pitch to be variable pitch for
*         our fonts in Windows
*
**********************************************************/
VOID ParsePitchType()
{
  CHAR szWord[16];

  EatWhite();
  GetWord(szWord, sizeof(szWord));
  if( !STRCMP(_strlwr(szWord), "true" ) ) {
      afm.fWasVariablePitch = FALSE;
      afm.fVariablePitch = forceVariablePitch;
      }
//  afm.fVariablePitch = TRUE;
}

/***********************************************************
* Name: InitAfm()
* Action: Initialize the afm structure.
************************************************************/
VOID InitAfm()
{
  register int i;

  afm.iFirstChar = 0x20;
  afm.iLastChar = 0x0ff;
  afm.iAvgWidth = 0;
  afm.iMaxWidth = 0;
  afm.iItalicAngle = 0;
  afm.iFamily = 0;
  afm.ulOffset = 0;
  afm.ulThick = 0;
  afm.iAscent = 0;
  afm.iDescent = 0;
  afm.fVariablePitch = TRUE;
  afm.fWasVariablePitch = TRUE;
  afm.szFont[0] = 0;
  afm.szFace[0] = 0;
  afm.iWeight = 400;
  afm.kp.cPairs = 0;
  afm.kt.cTracks = 0;
  afm.rcBBox.left = 0;
  afm.rcBBox.bottom = 0;
  afm.rcBBox.right = 0;
  afm.rcBBox.top = 0;

  for(i=0; i<256; i++ ) {
      afm.rgcm[i].rc.left = 0;
      afm.rgcm[i].rc.bottom = 0;
      afm.rgcm[i].rc.right = 0;
      afm.rgcm[i].rc.top = 0;
      afm.rgcm[i].iWidth = 0;
      }
}

/*----------------------------------------------------------------------------
** Returns: 16-bit encoded value indicating error and type of file where
**          error occurred.  (see fvscodes.h) for definitions.
**          The following table lists the "status" portion of the codes
**          returned.
**
**           FVS_SUCCESS
**           FVS_INVALID_FONTFILE
**           FVS_FILE_OPEN_ERR
**           FVS_FILE_BUILD_ERR
*/
short _MakePfm()
{
  INT hfile;
  SHORT i;
  float ten = (float) 10;
  BOOL fPrint = FALSE, fEndOfInput = FALSE, fStartInput = FALSE;
  BOOL bRes;

  // if ( devType == PCL ) sf = ((float)afm.iPtSize / 1000.0) * (300.0 / 72.0);
  InitAfm();

  if( (hfile = OpenParseFile(infofile)) == -1 ) {
      ; // PostError(str(MSG_PFM_BAD_FOPEN), infofile);
      return(FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_INF));
      }
  if( !ReadFontInfo(hfile) ) {
      CLOSE(hfile);
      ; // PostError(str(MSG_PFM_BAD_PARSE), infofile);
      return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_INF));
      }
  CLOSE(hfile);

  if( (fhIn = OpenParseFile(afm.szFile)) == -1 ) {
      ; // PostError(str(MSG_PFM_BAD_FOPEN), afm.szFile);
      return(FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_AFM));
      }
  parseError = FALSE;
  while (!fEndOfInput) {
      if( !GetLine(fhIn) ) break;
      switch( GetToken(fhIn, afmKeys) ) {
          case TK_STARTFONTMETRICS:
              fStartInput = TRUE;
              break;
          case TK_STARTKERNDATA:
              ParseKernData(devType == PCL);
              break;
          case TK_FONTNAME:
              ParseFontName();
              break;
          case TK_WEIGHT:
              break;
          case TK_ITALICANGLE:
              GetFloat(&ten, &afm.iItalicAngle);
              break;
          case TK_ISFIXEDPITCH:
              ParsePitchType();
              break;
          case TK_UNDERLINEPOSITION:
              GetNumber(&i);
              afm.ulOffset = (devType==POSTSCRIPT) ? abs(i) : CVTTOSCR(abs(i));
              break;
          case TK_UNDERLINETHICKNESS:
              GetNumber(&i);
              afm.ulThick = (devType == POSTSCRIPT) ? i : CVTTOSCR(i);
              break;
          case TK_FONTBBOX:
              ParseBoundingBox(devType == PCL);
              break;
          case TK_CAPHEIGHT:
              GetNumber(&i);
              if( fiCapHeight == 0 ) fiCapHeight = i;
              break;
          case TK_XHEIGHT:
              break;
          case TK_DESCENDER:
              GetNumber(&i);
              afm.iDescent = (devType == POSTSCRIPT) ? i : CVTTOSCR(i);
              break;
          case TK_ASCENDER:
              GetNumber(&i);
              if (i < 667) i = 667;
              afm.iAscent = (devType == POSTSCRIPT) ? i : CVTTOSCR(i);
              break;
          case TK_STARTCHARMETRICS:
              if (afm.iFamily == 0) {
                  ; // PostError(str(MSG_PFM_MISSING_MSFAMILY));
                  CLOSE(fhIn);
                  return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_AFM));
                  }
              ParseCharMetrics(devType == PCL);
              break;
          case TK_ENDFONTMETRICS:
              fEndOfInput = TRUE;
              break;
          }
      if( parseError ) {
          CLOSE(fhIn);
          return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_AFM));
          }
      }
  CLOSE(fhIn);
  if( !fStartInput ) {
      ; // PostError(str(MSG_PFM_BAD_EOF), "StartFontMetrics");
      return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_AFM));
      }
  FixCharWidths();
  SetAfm();

#if DEBUG_MODE
  DumpAfm();
  DumpKernPairs();
  DumpKernTracks();
  DumpCharMetrics();
#endif
  bRes = MakeDf(FALSE, (SHORT)devType, outfile);
  FreeAllMem();
  return(bRes ? FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK) :
                FVS_MAKE_CODE(FVS_FILE_BUILD_ERR, FVS_FILE_PFM));
}

/*----------------------------------------------------------------------------*/
BOOL ReadFontInfo(hfile)
INT hfile;
{
  INT iToken;
  CHAR szTemp[6];
  BOOL found[LAST_FI_TOKEN+1];
  static KEY infKeys[] = {
      "MSMenuName",      TK_MSMENUNAME,
      "VPStyle",         TK_VPSTYLE,
      "Pi",              TK_PI,
      "Serif",           TK_SERIF,
      "PCLStyle",        TK_PCLSTYLE,
      "PCLStrokeWeight", TK_PCLSTROKEWEIGHT,
      "PCLTypefaceID",   TK_PCLTYPEFACEID,
      "CapHeight",       TK_INF_CAPHEIGHT,
      NULL, 0
      };

  fiCapHeight = 0;
  for(iToken=0; iToken<=LAST_FI_TOKEN; iToken++) found[iToken] = FALSE;
  while( GetLine(hfile) ) {
      iToken = GetToken(hfile,infKeys);
      found[iToken] = TRUE;
      switch(iToken) {
          case TK_MSMENUNAME:
              if( !GetString(afm.szFace, sizeof(afm.szFace)) ) return(FALSE);
              break;
          case TK_VPSTYLE:
              if( !GetString(szTemp, sizeof(szTemp)) ) return(FALSE);
              switch( toupper(szTemp[0]) ) {
                  case 'N':
                  case 'I': afm.iWeight = FW_NORMAL; break;
                  case 'B':
                  case 'T': afm.iWeight = FW_BOLD; break;
                  default:  return(FALSE); break;
                  }
              break;
          case TK_PI:
              GetWord(szTemp, sizeof(szTemp));
              if( !STRCMP(_strupr(szTemp), "TRUE") )
                  afm.iFamily = FF_DECORATIVE;
              else if( STRCMP(szTemp, "FALSE") ) return(FALSE);
              break;
          case TK_SERIF:
              GetWord(szTemp, sizeof(szTemp));
              if( !STRCMP(_strupr(szTemp), "TRUE") ) {
                  if( afm.iFamily != FF_DECORATIVE ) afm.iFamily = FF_ROMAN;
                  }
              else if( !STRCMP(szTemp, "FALSE") )  {
                  if( afm.iFamily != FF_DECORATIVE ) afm.iFamily = FF_SWISS;
                  }
              else return(FALSE);
              break;
          case TK_INF_CAPHEIGHT:
              GetNumber(&fiCapHeight);
              break;
          case TK_PCLSTYLE:
              GetNumber(&pclinfo.style);
              break;
          case TK_PCLSTROKEWEIGHT:
              GetNumber(&pclinfo.strokeWeight);
              break;
          case TK_PCLTYPEFACEID:
              GetNumber((SHORT *)&pclinfo.typeface);
              if( pclinfo.typefaceLen == 1 ) pclinfo.typeface &= 0xFF;
              break;
          }
      }
  if( found[TK_MSMENUNAME] == FALSE ||
      found[TK_VPSTYLE] == FALSE ||
      found[TK_PI] == FALSE ||
      found[TK_SERIF] == FALSE ||
      found[TK_INF_CAPHEIGHT] == FALSE ) return(FALSE);
  if ( devType == PCL )
      if( found[TK_PCLSTYLE] == FALSE ||
          found[TK_PCLSTROKEWEIGHT] == FALSE ||
          found[TK_PCLTYPEFACEID] == FALSE ) return(FALSE);
  return(TRUE);
}

#if DEBUG_MODE
/*----------------------------------------------------------------------------*/
VOID DumpAfm()
{
  printf("\nAFM HEADER\n");
  printf("afm.iFirstChar: %d\n", afm.iFirstChar);
  printf("afm.iLastChar: %d\n", afm.iLastChar);
  printf("afm.iPtSize: %d\n", afm.iPtSize);
  printf("afm.iAvgWidth: %d\n", afm.iAvgWidth);
  printf("afm.iMaxWidth: %d\n", afm.iMaxWidth);
  printf("afm.iItalicAngle: %d\n", afm.iItalicAngle);
  printf("afm.iFamily: %d\n", afm.iFamily);
  printf("afm.ulOffset: %d\n", afm.ulOffset);
  printf("afm.ulThick: %d\n", afm.ulThick);
  printf("afm.iAscent: %d\n", afm.iAscent);
  printf("afm.iDescent: %d\n", afm.iDescent);
  printf("afm.fVariablePitch: %d\n", afm.fVariablePitch);
  printf("afm.szFile: %s\n", afm.szFile);
  printf("afm.szFont: %s\n", afm.szFont);
  printf("afm.szFace: %s\n", afm.szFace);
  printf("afm.iWeight: %d\n", afm.iWeight);
  printf("afm.rcBBox - top: %d left: %d right: %d bottom: %d\n",
    afm.rcBBox.top, afm.rcBBox.left, afm.rcBBox.right, afm.rcBBox.bottom);
}
/*----------------------------------------------------------------------------*/
VOID DumpKernPairs()
{
  INT indx;

  printf("\nKERN PAIRS\n");
  printf("afm.kp.cPairs: %d\n", afm.kp.cPairs);
  for (indx = 0; indx < afm.kp.cPairs; indx++)
        printf("afm.kp.rgPairs[%d] - iKey: %u iKernAmount: %d\n", indx,
          afm.kp.rgPairs[indx].iKey, afm.kp.rgPairs[indx].iKernAmount);
}
/*----------------------------------------------------------------------------*/
VOID DumpKernTracks()
{
  INT indx;

  printf("\nKERN TRACKS\n");
  printf("afm.kt.cTracks: %d\n", afm.kt.cTracks);
  for (indx = 0; indx < afm.kt.cTracks; indx++) {
        printf("track: %d iDegree: %d iPtMin: %d iKernMin: %d iPtMax: %d iKernMax: %d\n",
          indx,
          afm.kt.rgTracks[indx].iDegree,
          afm.kt.rgTracks[indx].iPtMin,
          afm.kt.rgTracks[indx].iKernMin,
          afm.kt.rgTracks[indx].iPtMax,
          afm.kt.rgTracks[indx].iKernMax);
        }

}
/*----------------------------------------------------------------------------*/
VOID DumpCharMetrics()
{
  INT indx;

  printf("\nCHARACTER METRICS\n");
  for (indx = afm.iFirstChar; indx <= afm.iLastChar; ++indx) {
    printf("indx: %d width: %d top: %d left: %d right: %d bottom: %d\n",
          indx,
          afm.rgcm[indx].iWidth,
          afm.rgcm[indx].rc.top,
          afm.rgcm[indx].rc.left,
    afm.rgcm[indx].rc.right,
          afm.rgcm[indx].rc.bottom);
        }
}
/*----------------------------------------------------------------------------*/
#endif

/******************************************************
* Name: GetCharMetrics()
* Action: Get the character metrics for a specified character.
**********************************************************/
VOID GetCharMetrics(iChar, pcm)
INT iChar;
CM *pcm;
{
  CM *pcmSrc;

  pcmSrc = &afm.rgcm[iChar];
  pcm->iWidth = pcmSrc->iWidth;
  pcm->rc.top = pcmSrc->rc.top;
  pcm->rc.left = pcmSrc->rc.left;
  pcm->rc.bottom = pcmSrc->rc.bottom;
  pcm->rc.right = pcmSrc->rc.right;
}

/*************************************************************
* Name: SetCharMetrics()
* Action: Set the character metrics for a specified character.
***************************************************************/
VOID SetCharMetrics(iChar, pcm)
INT iChar;
CM *pcm;
{
  CM *pcmDst;

  pcmDst = &afm.rgcm[iChar];
  pcmDst->iWidth = pcm->iWidth;
  pcmDst->rc.top = pcm->rc.top;
  pcmDst->rc.left = pcm->rc.left;
  pcmDst->rc.bottom = pcm->rc.bottom;
  pcmDst->rc.right = pcm->rc.right;
}

/************************************************************
* Name: GetSmallCM()
* Action: Compute the character metrics for small sized characters
*   such as superscripts.
**************************************************************/
VOID GetSmallCM(iCh, pcm)
INT iCh;
CM *pcm;
{
  GetCharMetrics(iCh, pcm);
  pcm->iWidth = pcm->iWidth / 2;
  pcm->rc.bottom = pcm->rc.top + (pcm->rc.top - pcm->rc.bottom)/2;
  pcm->rc.right = pcm->rc.left + (pcm->rc.right - pcm->rc.left)/2;
}

/*************************************************************
* Name: SetFractionMetrics()
* Action: Set the character metrics for a fractional character
*   which must be simulated.
***************************************************************/
VOID SetFractionMetrics(iChar, iTop, iBottom, pcl)
INT iChar;        /* The character code point */
INT iTop;         /* The ascii numerator character */
INT iBottom;      /* The denominator character */
INT pcl;          /* device type */
{
  INT cxBottom;   /* The width of the denominator */
  CM cm;

#define IFRACTIONBAR  167

  /* Set denominator width to 60 percent of bottom character */
  GetCharMetrics(iBottom, &cm);
  cxBottom = (INT)((long)cm.iWidth * (long)((pcl) ? CVTTOSCR(60) : 60)
        / (long)((pcl) ? CVTTOSCR(100) : 100));

  /* Set numerator width to 40 percent of top character */
  GetCharMetrics(iTop, &cm);
  cxBottom = (INT)((long)cm.iWidth * (long)((pcl) ? CVTTOSCR(40) : 40)
        / (long)((pcl) ? CVTTOSCR(100) : 100));

  cm.iWidth = iTop + iBottom + (pcl) ? CVTTOSCR(IFRACTIONBAR) : IFRACTIONBAR;
  cm.rc.right = cm.rc.left + cm.iWidth;
  SetCharMetrics(iChar, &cm);
}

/***********************************************************************
* Name: FixCharWidths()
* Action: Fix up the character widths for those characters which
*   must be simulated in the driver.
*************************************************************************/
VOID FixCharWidths()
{
  CM cm;
  CM cmSubstitute;
  INT i;

#if 0
  if (afm.iFamily == FF_DECORATIVE) {
        GetCharMetrics(ISPACE, &cmSubstitute);
    for (i = afm.iFirstChar; i <= afm.iLastChar; ++i) {
          GetCharMetrics(i, &cm);
          if (cm.iWidth == 0) {
            SetCharMetrics(i, &cmSubstitute);
                }
          }
        return;
        }

  /* this is a text font */
  GetCharMetrics(IBULLET, &cmSubstitute);
  for (i=0x07f; i<0x091; ++i) SetCharMetrics(i, &cmSubstitute);
  for (i=0x098; i<0x0a1; ++i) SetCharMetrics(i, &cmSubstitute);
#else
  /* yh 8-27-91  Added some characters for Windows 3.1. */
  if (afm.iFamily == FF_DECORATIVE)
        GetCharMetrics(ISPACE, &cmSubstitute);
  else {                                  /* WINANSI encoding */
        GetCharMetrics(ISPACE, &cm);      /* 'space' is encoded twice */
        SetCharMetrics(IWINSPACE, &cm);
        GetCharMetrics(IBULLET, &cmSubstitute);
        }
  for (i = afm.iFirstChar; i <= afm.iLastChar; ++i) {
        GetCharMetrics(i, &cm);
        if (cm.iWidth == 0)
            SetCharMetrics(i, &cmSubstitute);
        }
#endif
}

/***************************************************************
* Name: SetAfm()
* Action: Set the character metrics in the afm to their default values.
********************************************************************/
VOID SetAfm()
{
  INT i, cx;

  afm.iFirstChar = 0x0020;
  afm.iLastChar = 0x00ff;

  if( !afm.fVariablePitch ) {
    cx = afm.rgcm[afm.iFirstChar].iWidth;
    for (i=afm.iFirstChar; i<=afm.iLastChar; ++i)
        afm.rgcm[i].iWidth = (SHORT)cx;
    }
  SetAvgWidth();
  SetMaxWidth();
}

/******************************************************************
* Name: SetAvgWidth()
* Action: This routine computes the average character width
*   from the character metrics in the afm structure.
********************************************************************/
VOID SetAvgWidth()
{
  CM *rgcm;
  INT i;
  long cx;    /* The average character width */
  long cb;    /* The number of characters */

  rgcm = afm.rgcm;

  cx = 0L;
  cb = (long) (afm.iLastChar - afm.iFirstChar + 1);
  for (i=afm.iFirstChar; i<=afm.iLastChar; ++i)
    cx += (long) rgcm[i].iWidth;
  afm.iAvgWidth = (INT) (cx / cb);
}

/*****************************************************************
* Name: SetMaxWidth()
* Action: This routine computes the maximum character width from
*   the character metrics in the afm structure.
*******************************************************************/
VOID SetMaxWidth()
{
  CM *rgcm;
  INT cx;
  INT i;

  rgcm = afm.rgcm;

  cx = 0;
  for (i=afm.iFirstChar; i<=afm.iLastChar; ++i)
    if (rgcm[i].iWidth > cx) cx = rgcm[i].iWidth;
  afm.iMaxWidth = (SHORT)cx;
}
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/******************************************************************
* Name: ResetBuffer()
* Action: This function resets the output buffer.
********************************************************************/
VOID ResetBuffer()
{
  pbBuffer = rgbBuffer;
  cbBuffer = 0;
}

/****************************************************************
* Name: PutByte()
* Action: This function writes a byte to the output buffer.
******************************************************************/
VOID PutByte(iByte)
SHORT iByte;
{
  *pbBuffer++ = (BYTE) (iByte & 0x0ff);
  ++cbBuffer;
}

/****************************************************************
* Name: PutRgb()
* Action: This function writes an array of bytes to the output buffer.
******************************************************************/
VOID PutRgb(pb, cb)
LPSZ pb;
INT cb;
{
  while (--cb>=0)
  PutByte(*pb++);
}

/****************************************************************
* Name: PutWord()
* Action: This function writes a word to the output buffer.
******************************************************************/
VOID PutWord(iWord)
SHORT iWord;
{
  *pbBuffer++ = (CHAR) (iWord & 0x0ff);
  *pbBuffer++ = (CHAR) ( (iWord >> 8) & 0x0ff );
  cbBuffer += 2;
}

/****************************************************************
* Name: PutLong()
* Action: This function writes a long word to the output buffer.
******************************************************************/
VOID PutLong(lWord)
long lWord;
{
  PutWord((WORD) (lWord & 0x0ffffL));
  lWord >>= 16;
  PutWord((WORD) (lWord & 0x0ffffL));
}

/**************************************************************
* Name: SetDf()
* Action: This function sets the values in the device font structure
*         from the values in the afm structure.
*****************************************************************/
static CHAR szCopyright[] = "Copyright 1988-1991 Adobe Systems Inc.";
VOID SetDf(pcl)
INT pcl;
{
//WORD minAscent;
  WORD pixHeight;
  WORD internalLeading;
  SHORT leading;
  #ifndef FF_MASKFAMILY
    #define FF_MASKFAMILY ((BYTE) 0xF0)
  #endif
  #define MAX(a,b) ((a)>(b)?(a):(b))

  pfm.iVersion = 0x0100;        /* Version 1.00 */
  szMove(pfm.szCopyright, szCopyright, sizeof(pfm.szCopyright));
  pfm.iType = (pcl) ? PCL_FONTTYPE : PS_FONTTYPE;
  pfm.iCharSet = (charset == -1) ? (BYTE) ANSI_CHARSET : (BYTE) charset;
   /* (pcl && (afm.iFamily==FF_DECORATIVE)) ? PCL_PI_CHARSET : ANSI_CHARSET );
      Windows WRITE only displays fonts with CharSet=0 in the menu */
  pfm.iDefaultChar = (BYTE) (
       ( (afm.iFamily==FF_DECORATIVE) ? ISPACE : IBULLET ) - afm.iFirstChar );
  pfm.iBreakChar = (BYTE) (ISPACE - afm.iFirstChar);

  /* for a scalable font (i.e. PostScript) default to 80 column text */
  pfm.iPoints = (pcl) ? afm.iPtSize : 10;

  /* if we ever support other bitmapped printers we will no longer be able
  to assume that the default x and y res are 300. */
  pfm.iVertRes = 300;
  pfm.iHorizRes = 300;
  pfm.iItalic = (BYTE) ((afm.iItalicAngle != 0) ? 1 : 0);
  pfm.iWeight = afm.iWeight;
  pfm.iPitchAndFamily = (BYTE) afm.iFamily;
  pfm.iFirstChar = (BYTE) afm.iFirstChar;
  pfm.iLastChar = (BYTE) afm.iLastChar;
  pfm.iAvgWidth = afm.iAvgWidth;
  pfm.iMaxWidth = afm.iMaxWidth;
  pfm.iPixWidth = (afm.fVariablePitch) ? 0 : afm.iAvgWidth;
/* pfm.iPixHeight = afm.rcBBox.top - afm.rcBBox.bottom;
 * Changed to reduce round off error.  8-26-91 yh
 */
  pixHeight = afm.rcBBox.top - afm.rcBBox.bottom;
  pfm.iPixHeight = (pcl) ? CVTTOSCR(pixHeight) : pixHeight;
/*  pfm.iInternalLeading =
 *    (pcl) ? pfm.iPixHeight - ((afm.iPtSize * 300) / 72) : 0;
 *  Changed to match ATM.  7-31-91 yh
 *  Changed to reduce round off error.  8-26-91 yh
 */
  internalLeading = max(0, pixHeight - EM);
  pfm.iInternalLeading = (pcl) ? CVTTOSCR(internalLeading) : internalLeading;

/*  pfm.iAscent = afm.rcBBox.top;
 *  Changed to fix text alignment problem.  10-08-90 yh
 */
/*  pfm.iAscent = afm.iAscent;
 *  Changed to match ATM.  7-31-91 yh
 *  Changed to reduce round off error.  8-26-91 yh
 */
  pfm.iAscent = (pcl) ?
                CVTTOSCR(EM + afm.rcBBox.bottom) + CVTTOSCR(internalLeading) :
                EM + afm.rcBBox.bottom + internalLeading;
/* Deleted to match ATM.  yh 9-13-91
 * minAscent = (pcl) ? CVTTOSCR(667) : 667;          2/3 of EM
 * if( pfm.iAscent < minAscent ) pfm.iAscent = minAscent;
 */

/*  pfm.iExternalLeading = 196; */
/*  Changed to 0 to fix a bug in PCL landscape.  Was getting huge leading. */
  /*
   * yh 8-26-91  Changed ExternalLeading for pcl to match ATM .
   */
  if (!pcl)
      /* PostScript driver ignores this field and comes up with own
       * ExternalLeading value.
       *
       * !!! HACK ALERT !!!
       *
       * ATM needs to have ExternalLeading=0.  PFMs generated with Rev. 2
       * MAKEPFM have a bug in default & break character fields.  We had
       * encoding number instead of offsets.  ATM uses following algorithm
       * to recognize the Rev. 2 PFMs:
       *     rev2pfm = pfmRec->fmExternalLeading != 0 &&
       *               etmRec->etmStrikeOutOffset == 500 &&
       *               pfmRec->fmDefaultChar >= pfmRec->fmFirstChar;
       * So, we need to make sure that either ExternalLeading stays zero or
       * StrikeOutOffset is not 500.  With current algorithm, StrikeOutOffset
       * is very likely to be less than 500.
       *     etm.iStrikeOutOffset = fiCapHeight / 2 - (afm.ulThick / 2);
       */
      pfm.iExternalLeading = 0;
  else if (!afm.fWasVariablePitch)
      pfm.iExternalLeading = 0;
  else                               /* pcl & Variable pitch */
      {
      /* Adjust external leading such that we are compatible */
      /* with the values returned by the PostScript driver.  */
      /* Who did this code??  Microsoft?  Has to be! */
      switch (pfm.iPitchAndFamily & FF_MASKFAMILY)
        {
        case FF_ROMAN:  leading = (pfm.iVertRes + 18) / 36; //2-pnt leading
                        break;
        case FF_SWISS:  if (pfm.iPoints <= 12)
                          leading = (pfm.iVertRes + 18) / 36; //2-pnt leading
                        else if (pfm.iPoints < 14)
                          leading = (pfm.iVertRes + 12) / 24; //3-pnt leading
                        else
                          leading = (pfm.iVertRes + 9) / 18; //4-pnt leading
                        break;
        default:                /* Give 19.6% of the height for leading. */
                        leading = (short) (
                                  (long) (pfm.iPixHeight-pfm.iInternalLeading)
                                  * 196L / 1000L );
                        break;
        }

      pfm.iExternalLeading = MAX(0, (SHORT)(leading - pfm.iInternalLeading));
      }

  pfm.iWidthBytes = 0;
  if (afm.fVariablePitch) pfm.iPitchAndFamily |= 1;

  pfm.iUnderline = 0;
  pfm.iStrikeOut = 0;
  pfm.oBitsPointer = 0L;
  pfm.oBitsOffset = 0L;
}

/**********************************************************
* Name: PutString()
* Action: This function writes a null terminated string
*       to the output file.
***********************************************************/
VOID PutString(sz)
LPSZ sz;
{
  INT bCh;

  do    {
      bCh = *pbBuffer++ = *sz++;
      ++cbBuffer;
      } while( bCh );
}

/***************************************************************
* Name: PutdeviceName()
* Action: This function writes the device name to the output file.
**************************************************************/
VOID PutDeviceName(szDevice)
LPSZ szDevice;
{
  pfm.oDevice = cbBuffer;
  PutString(szDevice);
}

/***************************************************************
* Name: PutFaceName()
* Action: This function writes the font's face name to the output file.
**************************************************************/
VOID PutFaceName()
{
  pfm.oFace = cbBuffer;
  PutString(afm.szFace);
}

/**************************************************************
* Name: MakeDf()
* Action: This function writes the device font info structure
*       to the output file.
* Method: This function makes two passes over the data. On the first pass
* it collects offset data as it places data in the output buffer. On the
* second pass, it first resets the output buffer and then writes the data
* to the output buffer again with the offsets computed from pass 1.
***************************************************************/
BOOL MakeDf(fPass2, devType, outfile)
BOOL fPass2;            /* TRUE if this is the second pass */
SHORT devType;  /* 1=POSTSCRIPT 2=PCL */
LPSZ outfile;
{
  BOOL result = TRUE;
  INT iMarker;

  ResetBuffer();
  SetDf(devType == PCL);

  /* put out the PFM header structure */
  PutWord(pfm.iVersion);
  PutLong(pfm.iSize);
  PutRgb(pfm.szCopyright, 60);
  PutWord(pfm.iType);
  PutWord(pfm.iPoints);
  PutWord(pfm.iVertRes);
  PutWord(pfm.iHorizRes);
  PutWord(pfm.iAscent);
  PutWord(pfm.iInternalLeading);
  PutWord(pfm.iExternalLeading);
  PutByte(pfm.iItalic);
  PutByte(pfm.iUnderline);
  PutByte(pfm.iStrikeOut);
  PutWord(pfm.iWeight);
  PutByte(pfm.iCharSet);
  PutWord(pfm.iPixWidth);
  PutWord(pfm.iPixHeight);
  PutByte(pfm.iPitchAndFamily);
  PutWord(pfm.iAvgWidth);
  PutWord(pfm.iMaxWidth);
  PutByte(pfm.iFirstChar);
  PutByte(pfm.iLastChar);
  PutByte(pfm.iDefaultChar);
  PutByte(pfm.iBreakChar);
  PutWord(pfm.iWidthBytes);
  PutLong(pfm.oDevice);
  PutLong(pfm.oFace);
  PutLong(pfm.oBitsPointer);
  PutLong(pfm.oBitsOffset);

  /* need to determine if proportional etc. */
  if (devType == PCL) PutExtentOrWidthTable(1);

  /* put out the PFM extension structure */
  iMarker = cbBuffer;
  PutWord(pfmext.oSizeFields);
  PutLong(pfmext.oExtMetricsOffset);
  PutLong(pfmext.oExtentTable);
  PutLong(pfmext.oOriginTable);
  PutLong(pfmext.oPairKernTable);
  PutLong(pfmext.oTrackKernTable);
  PutLong(pfmext.oDriverInfo);
  PutLong(pfmext.iReserved);
  pfmext.oSizeFields = cbBuffer - iMarker;
  if (devType == POSTSCRIPT) {
    /* Put the extended text metrics table */
    pfmext.oExtMetricsOffset = cbBuffer;
    PutEtm(FALSE);

    PutDeviceName("PostScript");
    PutFaceName();
    PutDriverInfo(FALSE);

    /* Put the extent table */
    PutExtentOrWidthTable(0);

    pfmext.oOriginTable = 0;
    pfmext.iReserved = 0;
    PutPairKernTable(POSTSCRIPT);
    PutTrackKernTable(POSTSCRIPT);
    }

  if (devType == PCL) {
    PutFaceName();
    PutDeviceName("PCL/HP LaserJet");

    /* Put the extended text metrics table */
    pfmext.oExtMetricsOffset = cbBuffer;
    PutEtm(TRUE);

    PutPairKernTable(PCL);
    PutTrackKernTable(PCL);

    PutDriverInfo(TRUE);
    pfmext.oOriginTable = 0;
    pfmext.iReserved = 0;
    }

  if( !fPass2 ) {
    pfm.iSize = (long)cbBuffer;
    if( !MakeDf(TRUE, devType, outfile) ) result = FALSE;
    }
  else {
    if( !WritePfm(outfile) ) result = FALSE;
#if DEBUG_MODE
    DumpPfmHeader();
    DumpCharWidths();
    DumpPfmExtension();
#endif
    }
  return(result);
}

/*******************************************************************
* Name: PutPairKernTable(devType)
* Action: Send the pairwise kerning table to the output file.
*********************************************************************/
VOID PutPairKernTable(devType)
SHORT devType;  /* 1=POSTSCRIPT 2=PCL */
{
  WORD i;

  if( afm.kp.cPairs > 0 ) {
      pfmext.oPairKernTable = cbBuffer;
#if DEBUG_MODE
      printf("Pair Kern Table - pairs: %d\n", afm.kp.cPairs);
#endif
      if( devType == POSTSCRIPT ) PutWord(afm.kp.cPairs);
      for (i = 0; i < afm.kp.cPairs; ++i) {
          PutWord(afm.kp.rgPairs[i].iKey);
          PutWord(afm.kp.rgPairs[i].iKernAmount);
#if DEBUG_MODE
          printf("key: %x kern amount: %d\n",
          afm.kp.rgPairs[i].iKey, afm.kp.rgPairs[i].iKernAmount);
#endif
          }
      }
  else
      pfmext.oPairKernTable = 0;
}

/******************************************************************
* Name: PutTrackKernTable(devType)
* Action: Send the track kerning table to the output file.
********************************************************************/
VOID PutTrackKernTable(devType)
SHORT devType;  /* 1=POSTSCRIPT 2=PCL */
{
  INT i;

  if (afm.kt.cTracks == 0)
    {
    pfmext.oTrackKernTable = 0;
    return;
    }

  pfmext.oTrackKernTable = cbBuffer;
  if (devType == POSTSCRIPT) PutWord(afm.kt.cTracks);
  for (i=0; i<afm.kt.cTracks; ++i)
    {
    PutWord(afm.kt.rgTracks[i].iDegree);
    PutWord(afm.kt.rgTracks[i].iPtMin);
    PutWord(afm.kt.rgTracks[i].iKernMin);
    PutWord(afm.kt.rgTracks[i].iPtMax);
    PutWord(afm.kt.rgTracks[i].iKernMax);
    }
}

/***************************************************************
* Name: PutExtentTable()
* Action: Send the character extent information to the output file.
*****************************************************************/
VOID PutExtentOrWidthTable(width)
INT width; /* 0=extent 1=width */
{
  INT i;

  /* is the typeface proportional ?? */
  if (pfm.iPitchAndFamily & 1)
    {
    pfmext.oExtentTable = (width) ? 0 : cbBuffer;
    for (i = afm.iFirstChar; i <= afm.iLastChar; i++)
      PutWord(afm.rgcm[i].iWidth);
    if (width) PutWord(0);
    }
  else
    pfmext.oExtentTable = 0;
}

/***********************************************************
* Name: WritePfm()
* Action: Flush the ouput buffer to the file.  Note that this
*         function is only called after the entire pfm structure
*         has been built in the output buffer.
*************************************************************/
BOOL WritePfm(outfile)
LPSZ outfile;
{
  INT fh;

  if( (fh = OpenTargetFile(outfile) ) == -1 ) {
      ; // PostError(str(MSG_PFM_BAD_CREATE), outfile);
      return(FALSE);
      }

  if( cbBuffer > 0  )
    if( (WORD)WRITE_BLOCK(fh, rgbBuffer, cbBuffer) != (WORD)cbBuffer ) {
        CLOSE(fh);
        ; // PostError(str(MSG_PFM_DISK_FULL));
        return(FALSE);
        }
  CLOSE(fh);
  return(TRUE);
}

#if DEBUG_MODE
/*----------------------------------------------------------------------------*/
VOID DumpPfmHeader()
{
  printf("\nDUMP PFM HEADER\n");
  printf("pfm.iVersion=%d\n",pfm.iVersion);
  printf("pfm.iSize=%ld\n",pfm.iSize);
  printf("pfm.szCopyright=%s\n",pfm.szCopyright);
  printf("pfm.iType=%d\n",pfm.iType);
  printf("pfm.iPoints=%d\n",pfm.iPoints);
  printf("pfm.iVertRes=%d\n",pfm.iVertRes);
  printf("pfm.iHorizRes=%d\n",pfm.iHorizRes);
  printf("pfm.iAscent=%d\n",pfm.iAscent);
  printf("pfm.iInternalLeading=%d\n",pfm.iInternalLeading);
  printf("pfm.iExternalLeading=%d\n",pfm.iExternalLeading);
  printf("pfm.iItalic=%d\n",pfm.iItalic);
  printf("pfm.iUnderline=%d\n",pfm.iUnderline);
  printf("pfm.iStrikeOut=%d\n",pfm.iStrikeOut);
  printf("pfm.iWeight=%d\n",pfm.iWeight);
  printf("pfm.iCharSet=%d\n",pfm.iCharSet);
  printf("pfm.iPixWidth=%d\n",pfm.iPixWidth);
  printf("pfm.iPixHeight=%d\n",pfm.iPixHeight);
  printf("pfm.iPitchAndFamily=%d\n",pfm.iPitchAndFamily);
  printf("pfm.iAvgWidth=%d\n",pfm.iAvgWidth);
  printf("pfm.iMaxWidth=%d\n",pfm.iMaxWidth);
  printf("pfm.iFirstChar=%c\n",pfm.iFirstChar);
  printf("pfm.iLastChar=%c\n",pfm.iLastChar);
  printf("pfm.iDefaultChar=%d\n",pfm.iDefaultChar);
  printf("pfm.iBreakChar=%d\n",pfm.iBreakChar);
  printf("pfm.iWidthBytes=%d\n",pfm.iWidthBytes);
  printf("pfm.oDevice=%x\n",pfm.oDevice);
  printf("pfm.oFace=%x\n",pfm.oFace);
  printf("pfm.oBitsPointer=%ld\n",pfm.oBitsPointer);
  printf("pfm.oBitsOffset=%ld\n",pfm.oBitsOffset);
}
/*----------------------------------------------------------------------------*/
VOID DumpCharWidths()
{
  INT indx;

  printf("\nCHARACTER WIDTHS\n");
  for (indx = afm.iFirstChar; indx <= afm.iLastChar; indx++)
    printf("indx: %d width: %d\n", indx, afm.rgcm[indx].iWidth);
}
/*----------------------------------------------------------------------------*/
VOID DumpPfmExtension()
{
  printf("\nDUMP PFM EXTENSION\n");
  printf("pfmext.oSizeFields=%d\n",pfmext.oSizeFields);
  printf("pfmext.oExtMetricsOffset=%x\n",pfmext.oExtMetricsOffset);
  printf("pfmext.oExtentTable=%x\n",pfmext.oExtentTable);
  printf("pfmext.oOriginTable=%x\n",pfmext.oOriginTable);
  printf("pfmext.oPairKernTable=%x\n",pfmext.oPairKernTable);
  printf("pfmext.oTrackKernTable=%x\n",pfmext.oTrackKernTable);
  printf("pfmext.oDriverInfo=%x\n",pfmext.oDriverInfo);
  printf("pfm.iReserved=%x\n",pfm.iReserved);
}
#endif
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Main purpose of these structures is to set up a translation table which
allows the driver to translate the font from the character set indicated in
the dfCharset field into the printer-specific character set. */

#define AVGSIZE  (30 * 1024)

VOID SetDriverInfo()
{
  INT i;
  long sumWidth = 0L;

  for (i = afm.iFirstChar; i <= afm.iLastChar; i++)
      sumWidth = sumWidth + (long)afm.rgcm[i].iWidth;

  d.epSize = sizeof(DRIVERINFO);
  d.epVersion = DRIVERINFO_VERSION;
  d.epMemUsage = (long) ( ((sumWidth+7L) >> 3) * (long)pfm.iPixHeight + 63L );
  d.xtbl.symbolSet = pclinfo.symbolsetNum;
  d.xtbl.offset = 0L;
  d.xtbl.len = 0;
  d.xtbl.firstchar = 0;
  d.xtbl.lastchar = 0;
  pclinfo.epEscapeSequence = GetEscapeSequence();
}
/*----------------------------------------------------------------------------*/
VOID PutDriverInfo(pcl)
INT pcl;
{
  pfmext.oDriverInfo = cbBuffer;
  if (pcl) {
    SetDriverInfo();
    PutWord(d.epSize);
    PutWord(d.epVersion);
    PutLong(d.epMemUsage);
    PutLong(d.epEscape);
    PutWord((WORD)d.xtbl.symbolSet);
    PutLong(d.xtbl.offset);
    PutWord(d.xtbl.len);
    PutByte(d.xtbl.firstchar);
    PutByte(d.xtbl.lastchar);
    d.epEscape = cbBuffer;
    PutString(pclinfo.epEscapeSequence);
  } else
    PutString(afm.szFont);
}

/*--------------------------------------------------------------------------*/
LPSZ GetEscapeSequence()
{
  static char escapeStr[80];
  char fixedPitch[2], pitch[10], height[10], *cp;
  int enc;
  float size;

  size = (float) afm.iPtSize;
  if( afm.fWasVariablePitch == TRUE ) {
      STRCPY(fixedPitch, "1");
      enc = ISPACE;
      }
  else {
      STRCPY(fixedPitch, "");
      enc = afm.iFirstChar;
      }
  sprintf(pitch, "%1.3f", 300.0 / (float)afm.rgcm[enc].iWidth);
  if( cp = strchr(pitch, '.') ) cp[3] = '\0';

  sprintf(height, "%1.2f", size);

  sprintf(escapeStr, "\x01B&l%dO\x01B(%s\x01B(s%sp%sh%sv%ds%db%uT",
          pclinfo.orientation, pclinfo.symbolsetStr,
          fixedPitch, pitch, height,
          pclinfo.style, pclinfo.strokeWeight, pclinfo.typeface);
  return(escapeStr);
}

/*----------------------------------------------------------------------------*/
#if DEBUG_MODE
VOID DumpDriverInfo()
{
  printf("\nDUMP DRIVERINFO STRUCTURE\n");
  printf("d.epSize: %d\n", d.epSize);
  printf("d.epVersion: %d\n", d.epVersion);
  printf("d.epMemUsage: %ld\n", d.epMemUsage);
  printf("d.epEscape: %ld\n", d.epEscape);
  printf("d.xtbl.symbolSet: %d\n", d.xtbl.symbolSet);
  printf("d.xtbl.offset: %ld\n", d.xtbl.offset);
  printf("d.xtbl.len: %d\n", d.xtbl.len);
  printf("d.xtbl.firstchar: %d\n", d.xtbl.firstchar);
  printf("d.xtbl.lastchar: %d\n", d.xtbl.lastchar);
  printf("d.epEscapeSequence: %s\n", d.epEscapeSequence);
}
#endif

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Convert from PostScript to extended text metrics */
VOID AfmToEtm(pcl)
BOOL pcl;  /* true if this is a PCL type device */
{
  etm.iSize = 52;
  /* point size in twips */
  etm.iPointSize = afm.iPtSize * 20;
  etm.iOrientation = (pcl) ? pclinfo.orientation + 1 : 0;
  etm.iMasterHeight = (pcl) ? pfm.iPixHeight : 1000;
  etm.iMinScale = (pcl) ? etm.iMasterHeight : 3;
  etm.iMaxScale = (pcl) ? etm.iMasterHeight : 1000;

  etm.iMasterUnits = (pcl) ? etm.iMasterHeight : 1000;

  /* in general need to worry a little about what happens if these various
     glyphs are not present as in a decorative font. */

  etm.iCapHeight = afm.rgcm['H'].rc.top;
  etm.iXHeight = afm.rgcm['x'].rc.top;
  etm.iLowerCaseAscent =  afm.rgcm['d'].rc.top;
  etm.iLowerCaseDescent = - afm.rgcm['p'].rc.bottom;
  etm.iSlant = (pcl) ? afm.iItalicAngle * 10 : afm.iItalicAngle;
  etm.iSuperScript = (pcl) ? 0 : -500;
  etm.iSubScript = (pcl) ? 0 : 250;
  etm.iSuperScriptSize = (pcl) ? 0 : 500;
  etm.iSubScriptSize = (pcl) ? 0 : 500;
  etm.iUnderlineOffset = (pcl) ? 0 : afm.ulOffset;
  etm.iUnderlineWidth = (pcl) ? 1 : afm.ulThick;
  etm.iDoubleUpperUnderlineOffset = (pcl) ? 0 : afm.ulOffset / 2;
  etm.iDoubleLowerUnderlineOffset = (pcl) ? 0 : afm.ulOffset;
  etm.iDoubleUpperUnderlineWidth = (pcl) ? 1 : afm.ulThick / 2;
  etm.iDoubleLowerUnderlineWidth = (pcl) ? 1 : afm.ulThick / 2;
  etm.iStrikeOutOffset = (pcl) ? 0 : fiCapHeight / 2 - (afm.ulThick / 2);
  etm.iStrikeOutWidth = (pcl) ? 1 : afm.ulThick;
  etm.nKernPairs = afm.kp.cPairs;
  etm.nKernTracks = afm.kt.cTracks;
}
/*----------------------------------------------------------------------------*/
VOID PutEtm(pcl)
BOOL pcl;  /* true if this is a PCL type device */
{
  AfmToEtm(pcl);
  PutWord(etm.iSize);
  PutWord(etm.iPointSize);
  PutWord(etm.iOrientation);
  PutWord(etm.iMasterHeight);
  PutWord(etm.iMinScale);
  PutWord(etm.iMaxScale);
  PutWord(etm.iMasterUnits);
  PutWord(etm.iCapHeight);
  PutWord(etm.iXHeight);
  PutWord(etm.iLowerCaseAscent);
  PutWord(etm.iLowerCaseDescent);
  PutWord(etm.iSlant);
  PutWord(etm.iSuperScript);
  PutWord(etm.iSubScript);
  PutWord(etm.iSuperScriptSize);
  PutWord(etm.iSubScriptSize);
  PutWord(etm.iUnderlineOffset);
  PutWord(etm.iUnderlineWidth);
  PutWord(etm.iDoubleUpperUnderlineOffset);
  PutWord(etm.iDoubleLowerUnderlineOffset);
  PutWord(etm.iDoubleUpperUnderlineWidth);
  PutWord(etm.iDoubleLowerUnderlineWidth);
  PutWord(etm.iStrikeOutOffset);
  PutWord(etm.iStrikeOutWidth);
  PutWord(etm.nKernPairs);
  PutWord(etm.nKernTracks);
#if DEBUG_MODE
  DumpEtm();
#endif
}
/*----------------------------------------------------------------------------*/
#if DEBUG_MODE
VOID DumpEtm()
{
  printf("\nDUMP ETM STRUCTURE\n");
  printf("etm.iSize: %d\n", etm.iSize);
  printf("etm.iPointSize: %d\n", etm.iPointSize);
  printf("etm.iOrientation: %d\n", etm.iOrientation);
  printf("etm.iMasterHeight: %d\n", etm.iMasterHeight);
  printf("etm.iMinScale: %d\n", etm.iMinScale);
  printf("etm.iMaxScale: %d\n", etm.iMaxScale);
  printf("etm.iMasterUnits: %d\n", etm.iMasterUnits);
  printf("etm.iCapHeight: %d\n", etm.iCapHeight);
  printf("etm.iXHeight: %d\n", etm.iXHeight);
  printf("etm.iLowerCaseAscent: %d\n", etm.iLowerCaseAscent);
  printf("etm.iLowerCaseDescent: %d\n", etm.iLowerCaseDescent);
  printf("etm.iSlant: %d\n", etm.iSlant);
  printf("etm.iSuperScript: %d\n", etm.iSuperScript);
  printf("etm.iSubScript: %d\n", etm.iSubScript);
  printf("etm.iSuperScriptSize: %d\n", etm.iSuperScriptSize);
  printf("etm.iSubScriptSize: %d\n", etm.iSubScriptSize);
  printf("etm.iUnderlineOffset: %d\n", etm.iUnderlineOffset);
  printf("etm.iUnderlineWidth: %d\n", etm.iUnderlineWidth);
  printf("etm.iDoubleUpperUnderlineOffset: %d\n",
    etm.iDoubleUpperUnderlineOffset);
  printf("etm.iDoubleLowerUnderlineOffset: %d\n",
    etm.iDoubleLowerUnderlineOffset);
  printf("etm.iDoubleUpperUnderlineWidth: %d\n",
    etm.iDoubleUpperUnderlineWidth);
  printf("etm.iDoubleLowerUnderlineWidth: %d\n",
    etm.iDoubleLowerUnderlineWidth);
  printf("etm.iStrikeOutOffset: %d\n", etm.iStrikeOutOffset);
  printf("etm.iStrikeOutWidth: %d\n", etm.iStrikeOutWidth);
  printf("etm.nKernPairs: %d\n", etm.nKernPairs);
  printf("etm.nKernTracks: %d\n", etm.nKernTracks);
}
#endif
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/**************************************************************
* Name: StartParse()
***************************************************************/
VOID StartParse()
{
  fEOF = FALSE;
  fUnGetLine = FALSE;
  cbBuffer = 0;
}

/**************************************************************
* Name: szIsEqual()
* Action: Compare two NULL terminated strings.
* Returns: TRUE if they are equal FALSE if they are different
***************************************************************/
BOOL szIsEqual(sz1, sz2)
LPSZ sz1;
LPSZ sz2;
{
  while (*sz1 && *sz2)
      if (*sz1++ != *sz2++) return(FALSE);
  return(*sz1 == *sz2);
}

/**************************************************************
* Name: szMove()
* Action: Copy a string.  This function will copy at most the
*   number of bytes in the destination area - 1.
***************************************************************/
VOID szMove(szDst, szSrc, cbDst)
LPSZ szDst;   /* Ptr to the destination area */
LPSZ szSrc;   /* Ptr to the source area */
INT cbDst;     /* The size of the destination area */
{
  while (*szDst++ = *szSrc++)
      if (--cbDst <= 0) {
          *(szDst-1) = 0;
          break;
          }
}

/*****************************************************************
* Name: GetBuffer()
* Action: Read a new buffer full of text from the input file.
******************************************************************/
BOOL GetBuffer(hfile)
INT hfile;
{
  cbBuffer = 0;
  if (!fEOF) {
      cbBuffer = READ_BLOCK(hfile, rgbBuffer, sizeof(rgbBuffer));
      if (cbBuffer<=0) {
          cbBuffer = 0;
          fEOF = TRUE;
          }
      }
  pbBuffer = rgbBuffer;
  return(!fEOF);
}

/*****************************************************************
* Name: UnGetLine()
* Action: This routine pushes the most recent line back into the
*   input buffer.
*******************************************************************/
VOID UnGetLine()
{
  fUnGetLine = TRUE;
  szLine = rgbLine;
}

/******************************************************************
* Name: GetLine()
* Action: This routine gets the next line of text out of the
*   input buffer.  Handles both binary & text mode.
********************************************************************/
BOOL GetLine(hfile)
INT hfile;
{
  CHAR szWord[10];

  // WriteDots();
  szLine = rgbLine;
  do {                                            /* skip comment lines */
      if( !_GetLine(hfile) ) return(FALSE);
      GetWord(szWord, sizeof(szWord));
      } while( szIsEqual("Comment", szWord) );
  szLine = rgbLine;
  return(TRUE);
}

BOOL _GetLine(hfile)
INT hfile;
{
  INT cbLine;
  CHAR bCh;

  if( fUnGetLine ) {
      szLine = rgbLine;
      fUnGetLine = FALSE;
      return(TRUE);
      }

  cbLine = 0;
  szLine = rgbLine;
  *szLine = 0;
  if( !fEOF )
  {
      while( TRUE )
      {
          if ( cbBuffer <= 0 )
              if( !GetBuffer(hfile) ) return(FALSE);
          while( --cbBuffer >= 0 )
          {
              bCh = *pbBuffer++;
              if( bCh=='\n' || ++cbLine > (sizeof(rgbLine)-1) )
              {
                  *szLine = 0;
                  szLine = rgbLine;
                  EatWhite();
                  if( *szLine != 0 ) goto DONE;
                  szLine = rgbLine;
                  cbLine = 0;
                  continue;
              }
              else if( bCh >= ' ' )
              {
                *szLine++ = bCh;
              }
          }
      }
  }
  *szLine = 0;

DONE:
  szLine = rgbLine;
  return(!fEOF);
}

/****************************************************************
* Name: EatWhite()
* Action: This routine moves the input buffer pointer forward to
*   the next non-white character.
******************************************************************/
VOID EatWhite()
{
  while (*szLine && (*szLine==' ' || *szLine=='\t'))
  ++szLine;
}

/*******************************************************************
* Name: GetWord()
* Action: This routine gets the next word delimited by white space
*   from the input buffer.
*********************************************************************/
VOID GetWord(szWord, cbWord)
LPSZ szWord;   /* Ptr to the destination area */
INT cbWord;     /* The size of the destination area */
{
  CHAR bCh;

  EatWhite();
  while (--cbWord>0) {
      switch(bCh = *szLine++) {
          case 0:
          case ' ':
          case '\t': --szLine;
                     goto DONE;
          case ';':  *szWord++ = bCh;
                     goto DONE;
          default:   *szWord++ = bCh;
                     break;
          }
      }
DONE:
  *szWord = 0;
}

/*******************************************************************
* Name: GetString()
* Action: This routine gets the next word delimited by parentheses
*   from the input buffer.
*********************************************************************/
BOOL GetString(szWord, cbWord)
LPSZ szWord;   /* Ptr to the destination area */
INT   cbWord;   /* The size of the destination area */
{
  CHAR bCh;
  BOOL result = TRUE;

  EatWhite();
  if( *szLine == '(' ) szLine++;
  else result = FALSE;
  while (--cbWord>0) {
      switch(bCh = *szLine++) {
          case 0:   result = FALSE;
                    goto DONE;
          case ')': --szLine;
                    goto DONE;
          default:  *szWord++ = bCh;
                    break;
          }
      }
DONE:
  *szWord = 0;
  return(result);
}

/************************************************************
* Name: GetNumber()
* Action: This routine parses an ASCII decimal number from the
*   input file stream and returns its value.
***************************************************************/
BOOL GetNumber(piVal)
SHORT *piVal;
{
  INT iVal;
  BOOL fNegative;

  fNegative = FALSE;

  iVal = 0;
  EatWhite();

  if (*szLine=='-') {
      fNegative = TRUE;
      ++szLine;
      }

  if (*szLine<'0' || *szLine>'9') {
      *piVal = 0;
      return(FALSE);
      }

  while (*szLine>='0' && *szLine<='9')
      iVal = iVal * 10 + (*szLine++ - '0');

  if (fNegative) iVal = - iVal;
  if (*szLine==0 || *szLine==' ' || *szLine=='\t' || *szLine==';') {
      *piVal = (SHORT)iVal;
      return(TRUE);
      }
  else {
      return(FALSE);
  }
}

/******************************************************************
* Name: GetFloat()
* Action: This routine parses an ASCII floating point decimal number
*   from the input file stream and returns its value scaled
*   by a specified amount.
*********************************************************************/
BOOL GetFloat(pScale, piVal)
float *pScale;     /* The amount to scale the value by */
SHORT *piVal;
{
  float scale;
  long lVal;
  long lDivisor;
  BOOL fNegative;

  scale = *pScale;
  EatWhite();
  fNegative = FALSE;
  lVal = 0L;

  if (*szLine=='-') {
      fNegative = TRUE;
      ++szLine;
      }

  if (*szLine<'0' || *szLine>'9') {
      *piVal = 0;
      return(FALSE);
      }

  while (*szLine>='0' && *szLine<='9') lVal = lVal * 10 + (*szLine++ - '0');

  lDivisor = 1L;
  if (*szLine=='.') {
      ++szLine;
      while (*szLine>='0' && *szLine<='9') {
          lVal = lVal * 10 + (*szLine++ - '0');
          lDivisor = lDivisor * 10;
          }
      }
  lVal = (lVal * (long) scale) / lDivisor;
  if (fNegative) lVal = - lVal;
  if (*szLine==0 || *szLine==' ' || *szLine=='\t' || *szLine==';') {
      *piVal = (INT) lVal;
      return(TRUE);
      }
   else {
      return(FALSE);
   }
}

/***************************************************************
* Name: MapToken()
* Action: This routine maps an ascii key word into an integer token.
* Returns: The token value.
******************************************************************/
INT MapToken(szWord, map)
LPSZ szWord;      /* Ptr to the ascii keyword string */
KEY *map;
{
  KEY *pkey;

  pkey = map;
  while (pkey->szKey) {
      if( szIsEqual(szWord, pkey->szKey) ) return(pkey->iValue);
      ++pkey;
      }
  return(TK_UNDEFINED);
}

/*********************************************************************
* Name: GetToken()
* Action: Get the next token from the input stream.
***********************************************************************/
INT GetToken(hfile, map)
INT hfile;
KEY *map;
{
  CHAR szWord[80];

  if (*szLine==0)
      if( !GetLine(hfile) ) return(TK_EOF);
  GetWord(szWord, sizeof(szWord));
  return(MapToken(szWord, map));
}

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
GlyphName *AllocateGlyphArray(arraymax)

INT arraymax;
{
  GlyphName *p;
  INT i;

  p = (GlyphName *) AllocateMem( (UINT) (sizeof(LPSZ) * (arraymax+2)) );
  if( p == NULL ) {
      ; // PostError(str(MSG_PFM_BAD_MALLOC));
      return(NULL);
      }
  for(i=0; i<=arraymax; i++)
      p[i] = notdef;
  p[i] = NULL;
  return(p);
}

/*--------------------------------------------------------------------------*/
VOID PutGlyphName(array, index, glyph)

GlyphName *array;
INT index;
LPSZ glyph;
{
  LPSZ p;

  if ( !STRCMP(glyph, ".notdef") )
      array[index] = notdef;
  else {
      p = (LPSZ) AllocateMem((UINT) (strlen(glyph)+1));
      if (p)
      {
          STRCPY(p, glyph);
          array[index] = p;
      }
  }
}

/*--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\fwriter.c ===
/***
**
**   Module: T1Parser
**
**   Description:
**  This is a module of the T1 to TT font converter. The module
**  contains functions that is used by the Builder moduler, to
**  manage the lowlevel writing to the TT font file, as well as
**  generic check sum, table length and table offset computations.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
/*-none-*/

/* Special types and definitions. */
#include "types.h"

/* Module dependent types and prototypes. */
#include "fileio.h"
#include "fwriter.h"



/***** LOCAL TYPES */
/*-none-*/



/***** CONSTANTS */
static const char *dir[] = {
   "OS/2",
   "cmap",
   "cvt ",
   "fpgm",
   "gasp",
   "glyf",
   "head",
   "hhea",
   "hmtx",
   "kern",
   "loca",
   "maxp",
   "name",
   "post",
   "prep",
};

#define MAGIC_CHECKSUM  0xB1B0AFBA


/***** MACROS */
/*-none-*/



/***** STATIC FUNCTIONS */
/***
** Function: SumCheckSum
**
** Description:
**   This function computes the check sum of
**   a section of the output file.
***/
static ULONG SumCheckSum(OutputFile *file, long length)
{
   ULONG sum = 0;
   UBYTE tbl[32];


   /* Unwrap the loop a bit. */
   while (length>16) {
      (void)io_ReadBytes(tbl, (USHORT)16, file);
      sum += MkLong(tbl[0],  tbl[1],  tbl[2],  tbl[3]);
      sum += MkLong(tbl[4],  tbl[5],  tbl[6],  tbl[7]);
      sum += MkLong(tbl[8],  tbl[9],  tbl[10], tbl[11]);
      sum += MkLong(tbl[12], tbl[13], tbl[14], tbl[15]);
      length -= 16;
   }

   /* Do the sentinel DWORDS. */
   while (length>0) {
      (void)io_ReadBytes(tbl, (USHORT)4, file);
      sum += MkLong(tbl[0], tbl[1], tbl[2], tbl[3]);
      length -= 4;
   }

   return sum;
}



/***** FUNCTIONS */


/***
** Function: WriteLong
**
** Description:
**   This function writes a 32-bit integer in the
**   Big Endian byte order, regardless of the
**   used byte order.
***/
void WriteLong(const ULONG val, OutputFile *file)
{
   UBYTE bytes[4];

   bytes[0] = (UBYTE)((val>>24)&0xff);
   bytes[1] = (UBYTE)((val>>16)&0xff);
   bytes[2] = (UBYTE)((val>>8)&0xff);
   bytes[3] = (UBYTE)((val)&0xff);
   (void)WriteBytes(bytes, (USHORT)4, file);
}



/***
** Function: WriteShort
**
** Description:
**   This function writes a 16-bit integer in the
**   Big Endian byte order, regardless of the used
**   byte order.
***/
void WriteShort(const USHORT val, OutputFile *file)
{
   UBYTE bytes[2];

   bytes[0] = (UBYTE)((val>>8)&0xff); 
   bytes[1] = (UBYTE)((val)&0xff);
   (void)WriteBytes(bytes, (USHORT)2, file);
}



/***
** Function: WriteByte
**
** Description:
**   This function writes an 8-bit integer in the
**   Big Endian byte order, regardless of used
**   byte order.
***/
void WriteByte(const UBYTE byte, OutputFile *file)
{
   (void)WriteBytes(&byte, (USHORT)1, file);
}




/***
** Function: CompleteTable
**
** Description:
**   This function completes a TT font file table,
**   by computing the check sum and writing it, the
**   table length and table offset to the table directory
**   of the TT font file.
**
**   Please note the dependency that this function must
**   be called right after the last byte of the contents
**   of the table have been written.
***/
errcode CompleteTable(const long offset,
                      const USHORT num,
                      OutputFile *file)
{
   long end;
   long length;
   ULONG sum = 0;
   long curr;
   short i;

   /* Determine the end of the table. */
   end = FileTell(file);

   /* Write pad bytes. */
   length = end - offset;
   if (length%4)
      for (i=0; i<(4-(long)(length%4)); i++)
         WriteByte(0, file);

   /* Record end of file position. */
   curr = io_FileTell(file);

   /* Compute the check sum */
   (void)io_FileSeek(file, offset);
   sum = SumCheckSum(file, end - offset);

   /* Write table directory entry */
   (void)io_FileSeek(file, (ULONG)(12L + TBLDIRSIZE*num + 4L));
   WriteLong(sum, file);
   WriteLong((ULONG)offset, file);
   WriteLong((ULONG)length, file);

   /* Go to end of file. */
   (void)io_FileSeek(file, curr);

   return FileError(file);
}



/***
** Function: WriteChecksum
**
** Description:
**   This function completes the whole TT font file,
**   by computing the check sum of the whole file and writing
**   it at the designated place.
***/
void WriteChecksum(const long offset, OutputFile *file)
{
   long end;
   ULONG sum = 0;

   end = io_FileTell(file);
   (void)io_FileSeek(file, 0L);
   sum = SumCheckSum(file, end);
   sum = MAGIC_CHECKSUM - sum;
   (void)io_FileSeek(file, offset);
   WriteLong(sum, file);
}




/***
** Function: WriteTableHeader
**
** Description:
**   This function initiates a TT font file, by initiating 
**   a handle used when writing the tables and by writing
**   the leading table dictionary of the file.
***/
void WriteTableHeader(OutputFile *file)
{
   USHORT segcount;
   USHORT i;


   /* Count the segcount */ /*lint -e650 */
   for (segcount=0; (1UL<<(segcount+1)) <= NUMTBL; segcount++)
      continue; /*lint +e650*/

   /* Write the offset table. */
   WriteLong(0x00010000L, file);
   WriteShort((USHORT)NUMTBL, file);
   WriteShort((USHORT)((1<<segcount)*16), file);
   WriteShort(segcount, file);
   WriteShort((USHORT)(NUMTBL*16-(1<<segcount)*16), file);

   /* Write the table directory entries. */
   for (i=0; i<NUMTBL; i++) {
      (void)WriteBytes((UBYTE*)&(dir[i][0]), (USHORT)4, file);
      WriteLong(0L, file);
      WriteLong(0L, file);
      WriteLong(0L, file);
   }
}



/***
** Function: OpenOutputFile
**
** Description:
***/
OutputFile *OpenOutputFile(const  char *name)
{
   return io_OpenFile(name, READWRITE);
}



/***
** Function: CloseOutputFile
**
** Description:
***/
errcode CloseOutputFile(OutputFile *fp)
{
   return io_CloseFile(fp);
}


/***
** Function: WriteBytes
**
** Description:
***/
USHORT WriteBytes(const UBYTE *buf,
                  const USHORT len,
                  OutputFile *fp)
{
   return io_WriteBytes(buf, len, fp);
}



/***
** Function: FileError
**
** Description:
***/
boolean FileError(OutputFile *fp)
{
   return io_FileError(fp);
}



/***
** Function: FileTell
**
** Description:
***/
long FileTell(OutputFile *fp)
{
   return io_FileTell(fp);
}



/***
** Function: FileSeek
**
** Description:
***/
long FileSeek(OutputFile *fp,
              const long where)
{
   return io_FileSeek(fp, where);
}


/***
** Function: RemoveFile
**
** Description:
**  Removes an already closed output file.
***/
void RemoveFile(const char *name)
{
   io_RemoveFile(name);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\makepfm.h ===
// *------------------------------------------------------------------------*
// * makepfm.h
// *------------------------------------------------------------------------*
//
//      Copyright 1990, 1991 -- Adobe Systems, Inc.
//      PostScript is a trademark of Adobe Systems, Inc.
//
// NOTICE:  All information contained herein or attendant hereto is, and
// remains, the property of Adobe Systems, Inc.  Many of the intellectual
// and technical concepts contained herein are proprietary to Adobe Systems,
// Inc. and may be covered by U.S. and Foreign Patents or Patents Pending or
// are protected as trade secrets.  Any dissemination of this information or
// reproduction of this material are strictly forbidden unless prior written
// permission is obtained from Adobe Systems, Inc.
//
//---------------------------------------------------------------------------


typedef char *LPSZ;

#define OPEN        FileOpen
#define CLOSE       _lclose
#define READ_BLOCK  _lread
#define WRITE_BLOCK _lwrite
#define STRCPY      lstrcpy
#define STRCAT      lstrcat
#define STRCMP      lstrcmp



/*--------------------------------------------------------------------------*/
#define DEBUG_MODE      0  

typedef struct {      /* A lookup table for converting strings to tokens */
  char *szKey;        /* Ptr to the string */
  int iValue;         /* The corresponding token value */
} KEY;

#define TK_UNDEFINED       0    /* tokens for ReadFontInfo */
#define TK_EOF             1
#define TK_MSMENUNAME      2
#define TK_VPSTYLE         3
#define TK_PI              4
#define TK_SERIF           5
#define TK_PCLSTYLE        6
#define TK_PCLSTROKEWEIGHT 7
#define TK_PCLTYPEFACEID   8
#define TK_INF_CAPHEIGHT   9
#define LAST_FI_TOKEN      9
#define TK_ANGLE           10   // added for ATM ( GetINFFontDescription )
#define TK_PSNAME          11   // added for ATM ( GetINFFontDescription )

/*----------------------------------------------------------------------------*/
/* EM describes the basic character cell dimension (in Adobe units) */
#define EM 1000

/*----------------------------------------------------------------------------*/
#define ANSI_CHARSET   0
#define SYMBOL_CHARSET 2
#define OEM_CHARSET    255
#define PCL_PI_CHARSET 181

#define PS_FONTTYPE    0x0081
#define PCL_FONTTYPE   0x0080

#define FW_NORMAL      400
#define FW_BOLD        700

/* GDI font families. */
#define WIN30
#ifdef WIN30
#define FF_DONTCARE   (0<<4) /* Don't care or don't know. */
#define FF_ROMAN      (1<<4) /* Variable stroke width, serifed. Times Roman, Century Schoolbook, etc. */
#define FF_SWISS      (2<<4) /* Variable stroke width, sans-serifed. Helvetica, Swiss, etc. */
#define FF_MODERN     (3<<4) /* Const stroke width, serifed or sans-serifed. Pica, Elite, Courier, etc. */
#define FF_SCRIPT     (4<<4) /* Cursive, etc. */
#define FF_DECORATIVE (5<<4) /* Old English, etc. */
#endif

typedef struct
{
  SHORT left;
  SHORT bottom;
  SHORT right;
  SHORT top;
} BBOX;

typedef struct {
  SHORT capHeight;
  SHORT xHeight;
  SHORT loAscent;        /* Lower-case ascent */
  SHORT loDescent;       /* Lower-case descent */
  SHORT ulOffset;        /* The underline offset */
  SHORT ulThick;         /* The underline thickness */
  SHORT iSlant;          /* The italic angle */
  BBOX  rcBounds;      /* The font bounding box */
} EMM;

typedef struct {
  char szFont[32];     /* The PostScript font name */
  char szFace[32];     /* The face name of the font */
  BOOL fEnumerate;     /* TRUE if the font should be enumerated */
  BOOL fItalic;        /* TRUE if this is an italic font */
  BOOL fSymbol;        /* TRUE if the font is decorative */
  SHORT iFamily;       /* The fonts family */
  WORD  iWeight;       /* TRUE if this is a bold font */
  SHORT iFirstChar;    /* The first character in the font */
  SHORT iLastChar;     /* The last character in the font */
  SHORT rgWidths[256]; /* Character widths from 0x020 to 0x0ff */
} FONT;

extern void PutByte(SHORT);
extern void PutWord(SHORT);
extern void PutLong(long);

typedef struct
{
  WORD iKey;
  SHORT iKernAmount;
} KX, *PKX;

typedef struct
{
  WORD cPairs;           /* The number of kerning pairs */
  PKX rgPairs;
} KP;

/* The info for a single kern track */
typedef struct
{
  SHORT iDegree;         /* The degree of kerning */
  SHORT iPtMin;          /* The minimum point size */
  SHORT iKernMin;        /* The minimum kern amount */
  SHORT iPtMax;          /* The maximum point size */
  SHORT iKernMax;        /* The maximum kern amount */
} TRACK;

#define MAXTRACKS 16
/* The track kerning table for a font */
typedef struct
{
  SHORT cTracks;              /* The number of kern tracks */
  TRACK rgTracks[MAXTRACKS];  /* The kern track information */
} KT;

/* Character metrics */
typedef struct
{
  BBOX rc;
  SHORT iWidth;
} CM;

typedef struct
{
  WORD  iPtSize;
  SHORT iFirstChar;
  SHORT iLastChar;
  SHORT iAvgWidth;
  SHORT iMaxWidth;
  SHORT iItalicAngle;
  SHORT iFamily;
  SHORT ulOffset;
  SHORT ulThick;
  SHORT iAscent;
  SHORT iDescent;
  BOOL fVariablePitch;
  BOOL fWasVariablePitch;
  char szFile[MAX_PATH + 4]; // +1 for nul term, +3 for alignment.
  char szFont[80];
  char szFace[80];
  SHORT iWeight;
  KP kp;
  KT kt;
  BBOX rcBBox;
  CM rgcm[256];        /* The character metrics */
} AFM;

/*----------------------------------------------------------------------------*/

typedef struct
{
  SHORT iSize;
  SHORT iPointSize;
  SHORT iOrientation;
  SHORT iMasterHeight;
  SHORT iMinScale;
  SHORT iMaxScale;
  SHORT iMasterUnits;
  SHORT iCapHeight;
  SHORT iXHeight;
  SHORT iLowerCaseAscent;
  SHORT iLowerCaseDescent;
  SHORT iSlant;
  SHORT iSuperScript;
  SHORT iSubScript;
  SHORT iSuperScriptSize;
  SHORT iSubScriptSize;
  SHORT iUnderlineOffset;
  SHORT iUnderlineWidth;
  SHORT iDoubleUpperUnderlineOffset;
  SHORT iDoubleLowerUnderlineOffset;
  SHORT iDoubleUpperUnderlineWidth;
  SHORT iDoubleLowerUnderlineWidth;
  SHORT iStrikeOutOffset;
  SHORT iStrikeOutWidth;
  WORD nKernPairs;
  WORD nKernTracks;
} ETM;

/*----------------------------------------------------------------------------*/

typedef struct
{
  WORD iVersion;
  DWORD iSize;
  CHAR szCopyright[60];
  WORD iType;
  WORD iPoints;
  WORD iVertRes;
  WORD iHorizRes;
  WORD iAscent;
  WORD iInternalLeading;
  WORD iExternalLeading;
  BYTE iItalic;
  BYTE iUnderline;
  BYTE iStrikeOut;
  WORD iWeight;
  BYTE iCharSet;
  WORD iPixWidth;
  WORD iPixHeight;
  BYTE iPitchAndFamily;
  WORD iAvgWidth;
  WORD iMaxWidth;
  BYTE iFirstChar;
  BYTE iLastChar;
  BYTE iDefaultChar;
  BYTE iBreakChar;
  WORD iWidthBytes;
  DWORD oDevice;
  DWORD oFace;
  DWORD oBitsPointer;
  DWORD oBitsOffset;
} PFM;

typedef struct
{
  WORD oSizeFields;
  DWORD oExtMetricsOffset;
  DWORD oExtentTable;
  DWORD oOriginTable;
  DWORD oPairKernTable;
  DWORD oTrackKernTable;
  DWORD oDriverInfo;
  DWORD iReserved;
} PFMEXT;

/*----------------------------------------------------------------------------*/

typedef enum    {
        epsymUserDefined,
        epsymRoman8,
        epsymKana8,
        epsymMath8,
        epsymUSASCII,
        epsymLineDraw,
        epsymMathSymbols,
        epsymUSLegal,
        epsymRomanExt,
        epsymISO_DenNor,
        epsymISO_UK,
        epsymISO_France,
        epsymISO_German,
        epsymISO_Italy,
        epsymISO_SwedFin,
        epsymISO_Spain,
        epsymGENERIC7,
        epsymGENERIC8,
        epsymECMA94
} SYMBOLSET;

typedef struct
        {
        SYMBOLSET symbolSet;            /* kind of translation table */
        DWORD offset;                           /* location of user-defined table */
        WORD len;                                       /* length (in bytes) of table */
        BYTE firstchar, lastchar;       /* table ranges from firstchar to lastchar */
        } TRANSTABLE;

typedef struct
        {
        WORD epSize;                            /* size of this data structure */
        WORD epVersion;                         /* number indicating version of struct */
        DWORD epMemUsage;                       /* amt of memory font takes up in printer */
        DWORD epEscape;                         /* pointer to escape that selects the font */
        TRANSTABLE xtbl;                        /* character set translation info */
        } DRIVERINFO;

/*----------------------------------------------------------------------------*/

#define POSTSCRIPT  (1)
#define PCL         (2)

/*----------------------------------------------------------------------------*/

typedef enum    { PORTRAIT, LANDSCAPE } ORIENTATION;

#define ASCII_SET   ("0U")
#define ROMAN8_SET  ("8U")
#define WINANSI_SET ("9U")
#define PI_SET      ("15U")

typedef struct
{
  ORIENTATION orientation;
  char symbolsetStr[4];
  SYMBOLSET symbolsetNum;
  SHORT style;
  SHORT strokeWeight;
  SHORT typefaceLen;
  WORD typeface;
  char *epEscapeSequence;       /* escape sequence that selects the font */
} PCLINFO;

/*--------------------------------------------------------------------------*/
#define EOS        '\0'
#define FNAMEMAX   (80)

/*--------------------------------------------------------------------------*/

#define BUFFLEN 80
#define MANDATORY       1
#define CookedReadMode  "r"
#define FATALEXIT  (2)



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\mreader.h ===
/***
**
**   Module: MReader
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



/***
** Function: ReadFontMetrics
**
** Description:
**  Read a font metrics file that associated to a type 1 font.
***/
errcode   ReadFontMetrics   _ARGS((IN   char *metrics,
                                   OUT  struct T1Metrics *t1m));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\mreader.c ===
/***
**
**   Module: MReader
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"

/* Module dependent types and prototypes. */
#include "pfm.h"



/***** CONSTANTS */
/*-none-*/



/***** LOCAL TYPES */
enum MType {t1_afm, t1_pfm, t1_unknown};



/***** MACROS */
/*-none-*/


/***** STATIC FUNCTIONS */

/***
** Function: MetricsType
**
** Description:
**   This function determines the type of the
**   metrics file that is associated to the 
**   main Adobe Type 1 outline file. 
***/
static enum MType MetricsType(const char *metrics)
{
   enum MType type;

   if (metrics==NULL || strlen(metrics)<5)
      type = t1_unknown;
   else if (!_strnicmp(&metrics[strlen(metrics)-3], "AFM", 3))
      type = t1_afm;
   else if (!_strnicmp(&metrics[strlen(metrics)-3], "PFM", 3))
      type = t1_pfm;
   else
      type = t1_unknown;

   return type;
}

/***** FUNCTIONS */

/***
** Function: ReadFontMetrics
**
** Description:
**  Read a font metrics file that associated to a type 1 font.
***/
errcode ReadFontMetrics(const char *metrics, struct T1Metrics *t1m)
{
   errcode status = SUCCESS;

   switch(MetricsType(metrics)) {
      case t1_pfm:
         status = ReadPFMMetrics(metrics, t1m);
         break;
      case t1_afm:
         /* status = ReadAFMMetrics(metrics, t1m); */
         break;
      case t1_unknown:
      default:
         status = BADMETRICS;
         break;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\metrics.h ===
#ifndef METRICS_H
#define METRICS_H



#define ONOFFSIZE(n)	((((n+7)/8)+sizeof(long)-1)/sizeof(long)*sizeof(long))
#define OnCurve(arr, n)  !((arr[(USHORT)(n)>>5]) & (ULONG)(1UL<<((USHORT)(n) % 32UL)))
#define SetOffPoint(arr, n)  arr[(unsigned)(n)/sizeof(arr[0])/8] |= \
                              1UL<<((unsigned)(n) % (sizeof(arr[0])*8))
#define SetOnPoint(arr, n)   arr[(unsigned)(n)/sizeof(arr[0])/8] &= \
                              ~(1UL<<((unsigned)(n) % (sizeof(arr[0])*8UL)))

#define USEMETRICS      0
#define DEFAULTMETRICS  1
#define F8D8            256
#define MAXSNAP         (USHORT)12
#define MAXBLUE         (USHORT)20
#define UNDEF_CVT			0
#define ENDOFPATH			-1
#define NORANGE			-2
#define ARGSIZE                 2000
#define PGMSIZE			3000
#define DEFAULTMATRIX	NULL
#define F16D16BASE		(1L<<19L)
#define F16D16HALF		(1L<<18L)
#define F16D16PPM			524




typedef int funit;
typedef struct {
	funit x;
	funit y;
} Point;

typedef struct Outline {
	struct Outline *next;	 /* Next path of the glyph. */
	USHORT count;		 /* Number of 'pts', 'onoff' and 'map'. */
	Point *pts;		 /* X/Y coordinates. */
	ULONG *onoff;		 /* On/Off curve point bit flags. */
} Outline;

typedef struct StemS {
        struct StemS *next;
        funit offset;
        funit width;
        short i1;
        short i2;
} Stem;

typedef struct Stem3S {
        struct Stem3S *next;
        Stem stem1;
        Stem stem2;
        Stem stem3;
} Stem3;

typedef struct FlexS {
   struct FlexS *next;
   funit civ;
   Point pos;
   Point midpos;
   Point startpos;
   USHORT start;
   USHORT mid;
   USHORT end;
} Flex;

typedef struct {
        Stem *vstems;
        Stem *hstems;
        Stem3 *vstems3;
        Stem3 *hstems3;
   Flex *flex;
} Hints;
        
        
typedef struct Composite {
   struct Composite *next;
   funit asbx;
   funit aw;
   funit adx;
   funit ady;
   const char *achar;
   const char *bchar;
   char *cchar;
   struct encoding *oenc;
} Composite;
   

typedef struct T1Glyph {
   char *name;

   Point lsb;
   Point width;

   Outline *paths;

   Hints hints;

} T1Glyph;
   

typedef struct StemWidth {
   funit width;
   USHORT storage;
} StemWidth;


typedef struct WeightControl {
   StemWidth *vwidths;
   USHORT cnt_vw;
   USHORT max_vw;
   StemWidth *hwidths;
   USHORT cnt_hw;
   USHORT max_hw;
   USHORT storage;
} WeightControl;

struct CVTPos {
   funit y;
   USHORT cvt;
};

typedef struct StemPos {
   struct CVTPos *pos;
   USHORT cnt;
   USHORT blue_cvt;
} StemPos;

typedef struct AlignmentControl {
   StemPos top[MAXBLUE/2];
   StemPos bottom[MAXBLUE/2];
   USHORT cvt;
} AlignmentControl;   

typedef struct Blues {
   funit bluevalues[MAXBLUE];
   USHORT blue_cnt;
   funit otherblues[MAXBLUE];
   USHORT oblue_cnt;
   funit familyblues[MAXBLUE];
   USHORT family_cvt[MAXBLUE/2];
   USHORT fblue_cnt;
   funit familyotherblues[MAXBLUE];
   USHORT familyother_cvt[MAXBLUE/2];
   USHORT foblue_cnt;
   short blueShift;      /*  /BlueShift * F8D8 */
   UBYTE blueFuzz;
   UBYTE blueScale;      /* /BlueScale * 1000 */
   AlignmentControl align;
} Blues;

struct kerning {
	UBYTE left;
	UBYTE right;
	funit delta;
};


struct T1Metrics {
   char *date;
   char *copyright;
   char *name;
   char *id;
   char *notice;
   char *fullname;
   char *weight;
   char *family;
   struct {
      USHORT ver;
      USHORT rev;
   } version;
   f16d16 angle;
   funit avgCharWidth;
   funit underline;
   funit uthick;
   funit stdhw;
   funit stdvw;
   funit defstdhw;
   funit defstdvw;
   funit stemsnaph[MAXSNAP];
   USHORT snaph_cnt;
   funit stemsnapv[MAXSNAP];
   USHORT snapv_cnt;
   UBYTE forcebold;
   UBYTE pitchfam;
   USHORT fixedPitch;
   USHORT flags;
   USHORT tmweight;
   funit ascent;
   funit descent;
   funit intLeading;
   funit extLeading;
   funit superoff;
   funit supersize;
   funit suboff;
   funit subsize;
   funit strikeoff;
   funit strikesize;
   UBYTE firstChar;
   UBYTE lastChar;
   UBYTE DefaultChar;
   UBYTE BreakChar;
   UBYTE CharSet;
   funit *widths;       /* Advance widths. */
   struct kerning *kerns;
   USHORT kernsize;
   WeightControl stems;
   Blues blues;
   funit upem;
   f16d16 *fmatrix;
   UBYTE pgm[PGMSIZE];
   short args[ARGSIZE];
   struct encoding *encoding;
   USHORT encSize;


   Composite *seac;
   Composite *used_seac;
};   



/****** MACROS */
#define GetUPEM(t1m)             (t1m->upem)
#define GetFontMatrix(t1m)       (t1m->fmatrix)
#define GetStdVW(t1m)            (t1m->stdvw)
#define GetStdHW(t1m)            (t1m->stdhw)
#define GetDefStdVW(t1m)         (t1m->defstdvw)
#define GetDefStdHW(t1m)         (t1m->defstdhw)
#define SetDefStdVW(t1m, width)  t1m->defstdvw = width
#define SetDefStdHW(t1m, width)  t1m->defstdhw = width
#define GetCodeStack(t1m)        t1m->pgm
#define GetArgStack(t1m)         t1m->args
#define GetWeight(t1m)           &(t1m->stems)
#define ForceBold(t1m)           t1m->forcebold
#define GetAlignment(t1m)        &(t1m->blues.align)
#define GetBlues(t1m)            &(t1m->blues)
#define CurrentEncoding(t1m)     t1m->encoding
#define EncodingSize(t1m)        t1m->encSize
#define Composites(t1m)          t1m->seac
#define SyntheticOblique(t1m)    (t1m->fmatrix && t1m->fmatrix[2])
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\pfm.h ===
/***
**
**   Module: PFM
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in a PFM file.
**
**      Please note the all data stored in a PFM file is represented
**      in the little-endian order.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

struct T1Metrics;


/***
** Function: ReadPFMMetrics
**
** Description:
**   This function parses a Printer Font Metrics
**   (*.pfm) file. 
***/
errcode  ReadPFMMetrics    _ARGS((IN      char *metrics,
                                  OUT     struct T1Metrics *t1m));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\pfb.h ===
/***
**
**   Module: PFB
**
**   Description:
**        This is a module of the T1 to TT font converter. The module
**        contains functions that manages the "printer binary file" file
**        format (Adobe Type 1 for MS-Windows).
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASCALL
#  endif
#endif

struct t1file;

/***
** Function: PFBAllocIOBlock
**
** Description:
**   Initiate an I/O stream for a PFB font file.
***/
struct t1file     *PFBAllocIOBlock  _ARGS((IN      char *name));


/***
** Function: PFBFreeIOBlock
**
** Description:
**   Free an I/O stream for a PFB font file.
***/
errcode FASTCALL  PFBFreeIOBlock    _ARGS((INOUT   struct t1file *io));


/***
** Function: PFBFileError
**
** Description:
**   Check if an I/O stream is ok.
***/
boolean FASTCALL  PFBFileError      _ARGS((IN      struct t1file *io));

/***
** Function: PFBGetByte
**
** Description:
**   Pull one byte from the opened PFB font file.
**   Please note that this function does not check
**   if it succeedes it reading a byte or not. It is
**   up to the calling module to manage the  error
**   checkes by using the FileError() function when
**   appropriate.
**
***/
short FASTCALL    PFBGetByte        _ARGS((INOUT   struct t1file *io));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\pfm.c ===
/***
**
**   Module: PFM
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in a PFM file.
**
**      Please note that all data stored in a PFM file is represented
**      in the little-endian order.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "fileio.h"



/***** CONSTANTS */
/*-none-*/


/***** LOCAL TYPES */
/*-none-*/


/***** MACROS */
/*-none-*/


/***** STATIC FUNCTIONS */

/***
** Function: GetNextWord
**
** Description:
**   This function pulls two bytes from a file
**   and convert them into a 16-bit integer.
***/
static short GetNextWord(struct ioFile *file)
{
   short iWord;

   iWord = (short)io_ReadOneByte(file);
   iWord |= (short)(io_ReadOneByte(file) * 256);

   return(iWord);
}


/***
** Function: GetLong
**
** Description:
**   This function pulls four bytes from a file
**   and convert them into a 32-bit integer.
***/
static long GetLong(struct ioFile *file)
{
   short low;
   short high;


   low = GetNextWord(file);
   high = GetNextWord(file);

   return (long)((long)low+((long)high * 65535L));
}



/***
** Function: ReadString
**
** Description:
**   This function pulls a null terminated
**   string from the file.
***/
static void ReadString(UBYTE *dst, int size, struct ioFile *file)
{
   int i;

   i=0;
   while (io_FileError(file)==SUCCESS && i<size) {
      dst[i] = (UBYTE)io_ReadOneByte(file);
      if (dst[i]=='\0')
         break;
      i++;
   }
}






/***** FUNCTIONS */

/***
** Function: ReadPFMMetrics
**
** Description:
**   This function parses a Printer Font Metrics
**   (*.pfm) file. 
***/
errcode ReadPFMMetrics(const char *metrics, struct T1Metrics *t1m)
{
   errcode status = SUCCESS;
   struct ioFile *file;
   UBYTE buf[256];
   long kernoffset;
   long widthoffset;
   long etmoffset;
   long faceoffset;
   short ver;
   short i;

   if (metrics==NULL || (file = io_OpenFile(metrics, READONLY))==NULL) {
      status = NOMETRICS;
   } else {

      (void)io_ReadOneByte(file);     /* Skip the revision number. */
      ver = (short)io_ReadOneByte(file);

      if (ver>3) {
         SetError(status=UNSUPPORTEDFORMAT);
      } else {

         (void)GetLong(file);        /* dfSize */

         /* Get Copyright */
         if (t1m->copyright)
            Free(t1m->copyright);
         if ((t1m->copyright = Malloc(60))==NULL) {
            SetError(status=NOMEM);
         } else {
            (void)io_ReadBytes((UBYTE *)t1m->copyright, (USHORT)60, file);

            (void)GetNextWord(file);                      /* dfType */
            (void)GetNextWord(file);                      /* dfPoints */
            (void)GetNextWord(file);                      /* dfVertRes */
            (void)GetNextWord(file);                      /* dfHorizRes */
            t1m->ascent = GetNextWord(file);              /* dfAscent */
            t1m->intLeading = GetNextWord(file);          /* dfInternalLeading */
            t1m->extLeading = GetNextWord(file);          /* dfExternalLeading */
            (void)io_ReadOneByte(file);               /* dfItalic */
            (void)io_ReadOneByte(file);               /* dfUnderline */
            (void)io_ReadOneByte(file);               /* dfStrikeOut */
            t1m->tmweight = (USHORT)GetNextWord(file);    /* dfWeight */
            t1m->CharSet = (UBYTE)io_ReadOneByte(file);   /* dfCharSet */
            (void)GetNextWord(file);                      /* dfPixWidth */
            (void)GetNextWord(file);                      /* dfPixHeight */
            t1m->pitchfam = (UBYTE)io_ReadOneByte(file);/* dfPitchAndFamily */
            t1m->avgCharWidth = GetNextWord(file);        /* dfAvgWidth */
            (void)GetNextWord(file);                      /* dfMaxWidth */
            t1m->firstChar = (UBYTE)io_ReadOneByte(file);   /* dfFirstChar */
            t1m->lastChar = (UBYTE)io_ReadOneByte(file);    /* dfLastChar */
            t1m->DefaultChar = (UBYTE)io_ReadOneByte(file); /* dfDefaultChar */
            t1m->BreakChar   = (UBYTE)io_ReadOneByte(file); /* dfBreakChar */
            (void)GetNextWord(file);                      /* dfWidthBytes */
            (void)GetLong(file);                      /* dfDevice */
	    faceoffset = GetLong(file);             /* dfFace */
            (void)GetLong(file);                      /* dfBitsPointer */
            (void)GetLong(file);                      /* dfBitsOffset */
            (void)GetNextWord(file);                      /* dfSizeFields */
            etmoffset = GetLong(file);                /* dfExtMetricsOffset */
            widthoffset = GetLong(file);              /* dfExtentTable */
            (void)GetLong(file);                      /* dfOriginTable */
            kernoffset = GetLong(file);               /* dfPairKernTable */
            (void)GetLong(file);                      /* dfTrackKernTable */
	    (void)GetLong(file);                      /* dfDriverInfo */
            (void)GetLong(file);                      /* dfReserved */

            if (io_FileError(file)!=SUCCESS) {
               SetError(status = BADMETRICS);
            }

            /* Get extended type metrics */
            (void)io_FileSeek(file, etmoffset);

            (void)GetNextWord(file);             /* etmSize */
            (void)GetNextWord(file);             /* etmPointSize */
            (void)GetNextWord(file);             /* etmOrientation */
            (void)GetNextWord(file);             /* etmMasterHeight */
            (void)GetNextWord(file);             /* etmMinScale */
            (void)GetNextWord(file);             /* etmMaxScale */
            (void)GetNextWord(file);             /* etmMasterUnits */
            (void)GetNextWord(file);             /* etmCapHeight */
            (void)GetNextWord(file);             /* etmXHeight */
            (void)GetNextWord(file);             /* etmLowerCaseAscent */
            t1m->descent = GetNextWord(file);    /* etmLowerCaseDecent */
            (void)GetNextWord(file);             /* etmSlant */
            t1m->superoff = GetNextWord(file);   /* etmSuperScript */
            t1m->suboff = GetNextWord(file);     /* etmSubScript */
            t1m->supersize = GetNextWord(file);  /* etmSuperScriptSize */
            t1m->subsize = GetNextWord(file);    /* etmSubScriptSize */
            (void)GetNextWord(file);             /* etmUnderlineOffset */
            (void)GetNextWord(file);             /* etmUnderlineWidth */
            (void)GetNextWord(file);             /* etmDoubleUpperUnderlineOffset*/
            (void)GetNextWord(file);             /* etmDoubleLowerUnderlineOffset*/
            (void)GetNextWord(file);             /* etmDoubleUpperUnderlineWidth */
            (void)GetNextWord(file);             /* etmDoubleLowerUnderlineWidth */
            t1m->strikeoff = GetNextWord(file);  /* etmStrikeOutOffset */
            t1m->strikesize = GetNextWord(file); /* etmStrikeOutWidth */
            (void)GetNextWord(file);             /* etmNKernPairs */
            (void)GetNextWord(file);             /* etmNKernTracks */

            /* Get the advance width for the characters. */
            if ((t1m->widths = Malloc(sizeof(funit)*
                                      (t1m->lastChar -
                                       t1m->firstChar + 1)))==NULL) {
               SetError(status=NOMEM);
            } else {
               (void)io_FileSeek(file, widthoffset);
               for (i=0; i<=t1m->lastChar-t1m->firstChar; i++)
                  t1m->widths[i] = GetNextWord(file);

               if (io_FileError(file)!=SUCCESS) {
                  SetError(status = BADMETRICS);
               }
            }

            /* Get the face name. */
            if ((status==SUCCESS) && faceoffset) {
               (void)io_FileSeek(file, faceoffset);
               if (t1m->family)
                  Free(t1m->family);
               ReadString(buf, sizeof(buf), file);
               if (io_FileError(file)) {
                  SetError(status = BADMETRICS);
               } else {
                  if ((t1m->family = Strdup((char*)buf))==NULL) {
                     SetError(status=NOMEM);
                  }
               }
            }

            /* Get the pair-kerning the typeface. */
            if ((status==SUCCESS) && kernoffset) {
               (void)io_FileSeek(file, kernoffset);
               t1m->kernsize = (USHORT)GetNextWord(file);
               if (io_FileError(file)!=SUCCESS) {
                  SetError(status = BADMETRICS);
               } else {
                  if ((t1m->kerns = Malloc(sizeof(struct kerning)*
                                            t1m->kernsize))==NULL) {
                     SetError(status=NOMEM);
                  } else {
                     for (i=0; i<(int)t1m->kernsize; i++) {
                        t1m->kerns[i].left = (UBYTE)io_ReadOneByte(file);
                        t1m->kerns[i].right = (UBYTE)io_ReadOneByte(file);
                        t1m->kerns[i].delta = GetNextWord(file);
                     }

                     if (io_FileError(file)!=SUCCESS) {
                        SetError(status = BADMETRICS);
                     }
                  }
               }
            }
         }
      }

      if (io_CloseFile(file)!=SUCCESS)
         status = BADMETRICS;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\safemem.h ===
/* Prototypes for "safe" (but slow) malloc/free routines to be used
 * in development of Large model Windows applications.
 *
 * lenoxb  5/28/93
 */

#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



/***********
 ** Debug version of memory management functions.
 **
 */

#if TRACEMEM

void* SafeMalloc        _ARGS((INOUT   size_t,
                               INOUT   char *,
                               INOUT   short));
void* SafeReAlloc       _ARGS((INOUT   void*,
                               INOUT   size_t,
                               INOUT   char *,
                               INOUT   short));
void  SafeFree          _ARGS((INOUT   void*));
void  SafeListMemLeak   _ARGS((INOUT   void));
char* SafeStrdup        _ARGS((IN      char*,
                               INOUT   char *,
                               INOUT   short));

#define Malloc(size)          SafeMalloc(size, __FILE__, __LINE__)
#define Realloc(ptr, size)    SafeReAlloc(ptr, size, __FILE__, __LINE__)
#define Free(ptr)             SafeFree(ptr)
#define Strdup(ptr)           SafeStrdup(ptr, __FILE__, __LINE__)
#define ListMemLeak           SafeListMemLeak




#else
/***********
 ** Run-time version of memory management functions.
 **
 */


/*#include <stddef.h>*/
#include <stdlib.h>

#define Malloc(size)       malloc(size)
#define Realloc(ptr,size)  realloc(ptr, (size_t)(size))
#define Free               free
#define Strdup             _strdup
#define ListMemLeak()      ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\pfb.c ===
/***
**
**   Module: PFB
**
**   Description:
**        This is a module of the T1 to TT font converter. The module
**        contains functions that manages the "printer binary file" file
**        format (Adobe Type 1 for MS-Windows).
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <ctype.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"

/* Module dependent types and prototypes. */
#include "fileio.h"



/***** LOCAL TYPES */
struct t1file {
   struct ioFile *file;
   enum blocktype {none=0, ascii, encoded} type;
   long size;
   long curr;
};



/***** CONSTANTS */
/*-none-*/



/***** MACROS */
#define HEXDIGIT(c)  (((c)>='a') ? ((c) - 'a' + 10) : ((c) - '0')) 
#define HEX(c1,c2)   (HEXDIGIT(c1)*16+HEXDIGIT(c2))



/***** STATIC FUNCTIONS */
/*-none-*/



/***** FUNCTIONS */

/***
** Function: PFBAllocIOBlock
**
** Description:
**   Initiate an I/O stream for a PFB font file.
***/
struct t1file *PFBAllocIOBlock(const char *name)
{
   struct t1file *pfb;

   if ((pfb=Malloc(sizeof(struct t1file)))!=NULL) {

      if ((pfb->file = io_OpenFile(name, READONLY))==NULL) {
         Free(pfb);
         pfb = NULL;
      } else {
         pfb->type = none;
         pfb->size = 0;
         pfb->curr = 0;
      }
   }

   return pfb;
}


/***
** Function: PFBFreeIOBlock
**
** Description:
**   Free an I/O stream for a PFB font file.
***/
errcode FASTCALL PFBFreeIOBlock(struct t1file *pfb)
{
   errcode status = SUCCESS;

   status = io_CloseFile(pfb->file);
   Free(pfb);

   return status;
}


/***
** Function: PFBFileError
**
** Description:
**   Check if an I/O stream is ok.
***/
boolean FASTCALL PFBFileError(const struct t1file *pfb)
{
   return io_FileError(pfb->file);
}


/***
** Function: PFBGetByte
**
** Description:
**   Pull one byte from the opened PFB font file.
**   Please note that this function does not check
**   if it succeedes it reading a byte or not. It is
**   up to the calling module to manage the  error
**   checkes by using the FileError() function when
**   appropriate.
**
***/
short FASTCALL PFBGetByte(struct t1file *pfb)
{
   short b, c1, c2;

   /* Enter a new PFB block? */
   if (pfb->curr>=pfb->size) {
      UBYTE type[2];
      UBYTE size[4];

      type[0]=(UBYTE)io_ReadOneByte(pfb->file);
      type[1]=(UBYTE)io_ReadOneByte(pfb->file);

      size[0]=(UBYTE)io_ReadOneByte(pfb->file);
      size[1]=(UBYTE)io_ReadOneByte(pfb->file);
      size[2]=(UBYTE)io_ReadOneByte(pfb->file);
      size[3]=(UBYTE)io_ReadOneByte(pfb->file);

      pfb->curr = 0;
      pfb->size = (long)MkLong(size[3], size[2], size[1], size[0]);
      pfb->type = ((type[0]==0x80 && (type[1]==0x01 ||
                                      type[1]==0x02)) ? ascii : encoded);
   }


   /* Read a byte. */
   switch (pfb->type) {
      case ascii:
         b = (short)io_ReadOneByte(pfb->file);
         pfb->curr++;
         break;
      case encoded:
         c1 = (short)tolower(io_ReadOneByte(pfb->file));
         c2 = (short)tolower(io_ReadOneByte(pfb->file));
         b = (short)HEX(c1, c2);
         pfb->curr += 2;
         break;
      case none:
      default:
         b = (short)-1;
         break;
   }

   return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\t1instal.h ===
#if defined(__cplusplus)
extern "C" {
#endif

#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#include "fvscodes.h"  // FVS_xxxxxx (font validation status) codes and macros.

#define MAXERRORS          -14
#define NOCOPYRIGHT        -13
#define ARGSTACK           -12
#define TTSTACK            -11
#define NOMETRICS          -10
#define UNSUPPORTEDFORMAT  -9
#define BADMETRICS         -8
#define BADT1HYBRID        -7
#define BADCHARSTRING      -6
#define BADINPUTFILE       -5
#define BADOUTPUTFILE      -4
#define BADT1HEADER        -3
#define NOMEM              -2
#define FAILURE            -1
#define SUCCESS            0
#define DONE               1
#define SKIP               2

#define MAYBE              2

#ifdef _MSC_VER
#define STDCALL  __stdcall
#else
#define STDCALL
#endif

#ifndef UNICODE
#  define ConvertTypeface  ConvertTypefaceA
#  define IsType1          IsType1A
#endif

short STDCALL ConvertTypefaceA   _ARGS((IN char *szPfb,
                                        IN char *szPfm,
                                        IN char *szTtf,
                                        IN void (STDCALL *Proc)(short,void*),
                                        INOUT   void *arg));

BOOL STDCALL CheckType1A (char *pszKeyFile,
                           DWORD cjDesc,
                           char *pszDesc,
                           DWORD cjPFM,
                           char *pszPFM,
                           DWORD cjPFB,
                           char *pszPFB,
                           BOOL *pbCreatedPFM,
                           char *pszFontPath
                           );

short STDCALL CheckCopyrightA    _ARGS((IN      char *szPFB,
                                        IN      DWORD wSize,
                                        INOUT   char *szVendor));


//
// Function CheckType1WithStatusA performs the same operation as
// CheckType1A except that it returns an encoded status value
// rather than merely TRUE/FALSE.  See fvscodes.h for a description
// of the "Font Validation Status" encodings.
// Since the original CheckType1A interface is exported from T1INSTAL.DLL
// by name, it was left unchanged so that existing applications that
// might use it don't break.
//
short STDCALL CheckType1WithStatusA (char *pszKeyFile,
                                     DWORD cjDesc,
                                     char *pszDesc,
                                     DWORD cjPFM,
                                     char *pszPFM,
                                     DWORD cjPFB,
                                     char *pszPFB,
                                     BOOL *pbCreatedPFM,
                                     char *pszFontPath
                                     );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\t1local.h ===
#define STR_APPNAME              "Type 1 Installer"
#define SUBKEY_TYPE1INSTAL       "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer"
#define SUBKEY_TYPE1COPYRIGHTS   SUBKEY_TYPE1INSTAL "\\Copyrights"
#define SUBKEY_LOGFILE           "Log events"   



#define IDS_CAPTION	1
#define IDS_RECOGNIZE1  2
#define IDS_RECOGNIZE2  3
#define IDS_MAINMSG     4


#define ALERT				MB_OK | MB_DEFBUTTON1 | MB_ICONSTOP
#define INFO				MB_OK | MB_DEFBUTTON1 | MB_ICONEXCLAMATION
#define QUERY				MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\t1instal.c ===
/***
 **
 **   Module: T1Instal
 **
 **   Description:
 **      This is the Win32 DLL (t1instal.dll) interface to the
 **      font converter. All window specific code is located in
 **      this module and the error hadler module (errors.c).
 **
 **   Author: Michael Jansson
 **   Created: 12/18/93
 **
 ***/

/***** INCLUDES */

#include "windows.h"

#include <string.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>

#undef IN

#include "titott.h"
#include "types.h"
#include "t1local.h"
#include "t1instal.h"
#include "fileio.h"
#include "safemem.h"
#include "t1msg.h"

#undef UNICODE


/* The CopyrightCheck/MAYBEOK case always succeeds for now. */
#define MAYBEOK   SUCCESS


/***** LOCAL TYPES */
struct callFrame {
   const void (STDCALL *Progress)(short, void*);
   void *arg;
   int last;
   int done;
};


static short lastCP = FALSE;
static char lastVendor[256] = "Unknown.";

/***** CONSTANTS */
#define MIN_PROGRESS    3
#define DELIMITERS      " ,"
#define COPYSIGN        169
#define TRUE            1
#define FALSE           0
#define DFFACE          139
#define DFDRIVERINFO    101

#define VERSTR "Converter: Windows Type 1 Installer V1.0d.\n" \
               "Font: V"

const char version[] = "\n$VER: 1.0d\n";

#ifndef NOANSIWINMAC
const char *winmac[] = {
   "A",
   "AE",
   "Aacute",
   "Acircumflex",
   "Adieresis",
   "Agrave",
   "Aring",
   "Atilde",
   "B",
   "C",
   "Cacute",
   "Ccaron",
   "Ccedilla",
   "D",
   "Delta",
   "E",
   "Eacute",
   "Ecircumflex",
   "Edieresis",
   "Egrave",
   "Eth",
   "F",
   "G",
   "Gbreve",
   "H",
   "I",
   "Iacute",
   "Icircumflex",
   "Idieresis",
   "Idot",
   "Igrave",
   "J",
   "K",
   "L",
   "Lslash",
   "M",
   "N",
   "Ntilde",
   "O",
   "OE",
   "Oacute",
   "Ocircumflex",
   "Odieresis",
   "Ograve",
   "Oslash",
   "Otilde",
   "P",
   "Q",
   "R",
   "S",
   "Scaron",
   "Scedilla",
   "T",
   "Thorn",
   "U",
   "Uacute",
   "Ucircumflex",
   "Udieresis",
   "Ugrave",
   "V",
   "W",
   "X",
   "Y",
   "Yacute",
   "Ydieresis",
   "Z",
   "a",
   "aacute",
   "acircumflex",
   "acute",
   "adieresis",
   "ae",
   "agrave",
   "ampersand",
   "approxequal",
   "aring",
   "asciicircum",
   "asciitilde",
   "asterisk",
   "at",
   "atilde",
   "b",
   "backslash",
   "bar",
   "braceleft",
   "braceright",
   "bracketleft",
   "bracketright",
   "breve",
   "brokenbar",
   "bullet",
   "c",
   "cacute",
   "caron",
   "ccaron",
   "ccedilla",
   "cedilla",
   "cent",
   "circumflex",
   "colon",
   "comma",
   "copyright",
   "currency",
   "d",
   "dagger",
   "daggerdbl",
   "degree",
   "dieresis",
   "divide",
   "dmacron",
   "dollar",
   "dotaccent",
   "dotlessi",
   "e",
   "eacute",
   "ecircumflex",
   "edieresis",
   "egrave",
   "eight",
   "ellipsis",
   "emdash",
   "endash",
   "equal",
   "eth",
   "exclam",
   "exclamdown",
   "f",
   "fi",
   "five",
   "fl",
   "florin",
   "four",
   "fraction",
   "franc",
   "g",
   "gbreve",
   "germandbls",
   "grave",
   "greater",
   "greaterequal",
   "guillemotleft",
   "guillemotright",
   "guilsinglleft",
   "guilsinglright",
   "h",
   "hungerumlaut",
   "hyphen",
   "i",
   "iacute",
   "icircumflex",
   "idieresis",
   "igrave",
   "infinity",
   "integral",
   "j",
   "k",
   "l",
   "less",
   "lessequal",
   "logicalnot",
   "lozenge",
   "lslash",
   "m",
   "macron",
   "middot",
   "minus",
   "mu",
   "multiply",
   "n",
   "nbspace",
   "nine",
   "notequal",
   "ntilde",
   "numbersign",
   "o",
   "oacute",
   "ocircumflex",
   "odieresis",
   "oe",
   "ogonek",
   "ograve",
   "ohm",
   "one",
   "onehalf",
   "onequarter",
   "onesuperior",
   "ordfeminine",
   "ordmasculine",
   "oslash",
   "otilde",
   "overscore",
   "p",
   "paragraph",
   "parenleft",
   "parenright",
   "partialdiff",
   "percent",
   "period",
   "periodcentered",
   "perthousand",
   "pi",
   "plus",
   "plusminus",
   "product",
   "q",
   "question",
   "questiondown",
   "quotedbl",
   "quotedblbase",
   "quotedblleft",
   "quotedblright",
   "quoteleft",
   "quoteright",
   "quotesinglbase",
   "quotesingle",
   "r",
   "radical",
   "registered",
   "ring",
   "s",
   "scaron",
   "scedilla",
   "section",
   "semicolon",
   "seven",
   "sfthyphen",
   "six",
   "slash",
   "space",
   "sterling",
   "summation",
   "t",
   "thorn",
   "three",
   "threequarters",
   "threesuperior",
   "tilde",
   "trademark",
   "two",
   "twosuperior",
   "u",
   "uacute",
   "ucircumflex",
   "udieresis",
   "ugrave",
   "underscore",
   "v",
   "w",
   "x",
   "y",
   "yacute",
   "ydieresis",
   "yen",
   "z",
   "zero"
};

#define GLYPHFILTER  &win
const struct GlyphFilter win = {
   sizeof(winmac) / sizeof(winmac[0]),
   winmac
};

#else
#define GLYPHFILER (struct GlyphFilter *)0
#endif /* NOANSIWINMAC */


/***** PROTOTYPES */
extern int __cdecl sprintf(char *, const char *, ...);


/***** MACROS */

#define ReadLittleEndianDword(file,dw)  {          \
        dw  = (DWORD)io_ReadOneByte(file) ;        \
        dw |= (DWORD)io_ReadOneByte(file) << 8;    \
        dw |= (DWORD)io_ReadOneByte(file) << 16;   \
        dw |= (DWORD)io_ReadOneByte(file) << 24;   \
        }
				
#ifndef try
#define try __try
#define except __except
#endif


/***** GLOBALS */
HANDLE hInst;



/***** STATIC FUNCTIONS */


/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
static DWORD CSum(char *str)
{
   DWORD sum = 0;

   while (*str)
      sum += *str++;

   return sum;
}


/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
static char *Encrypt(char *str, char *out)
{
   const USHORT c1 = 52845;
   const USHORT c2 = 22719;
   UBYTE cipher;
   USHORT r = 8366;
   int i;
   
   for (i=0; i<(int)strlen(str); i++) {
      cipher = (UBYTE)(str[i] ^ (r>>8));
      r = (USHORT)((cipher + r) * c1 + c2);
      out[i] = (char)((cipher & 0x3f) + ' ');

      /* Unmap 'bad' characters, that the Registry DB doesn't like. */
      if (out[i]=='=' || out[i]==' ' || out[i]=='@' || out[i]=='"')
         out[i] = 'M';
   }
   out[i] = '\0';

   return out;
}


static char *stristr(char *src, char *word)
{
	int len = strlen(word);
	char *tmp = src;

	while (*src) {
		if (!_strnicmp(src, word, len))
			break;
		src++;
	}

	return src;
}


/***
 ** Function: GetCompany
 **
 ** Description:
 **   Extract the company name out of a copyright string.
 ***/
char *GetCompany(char *buf)
{
   char *company = NULL;
   int done = FALSE;
   UBYTE *token;
   UBYTE *tmp1;
   UBYTE *tmp2;
   UBYTE *tmp3;
   UBYTE *tmp4;
   int i;

   token = buf;

   while (token && !done) {

	   /* Locate the start of the copyright string. */
	   tmp1 = stristr(token, "copyright");
	   tmp2 = stristr(token, "(c)");
	   tmp3 = stristr(token, " c ");
	   if ((tmp4 = strchr(token, COPYSIGN))==NULL)
		   tmp4 = &token[strlen(token)];
	   if (*tmp1==0 && *tmp2==0 && *tmp3==0 && *tmp4==0) {
		   token = NULL;
		   break;
	   } else if (tmp1<tmp2 && tmp1<tmp3 && tmp1<tmp4)
		   token = tmp1;
	   else if (tmp2<tmp3 && tmp2<tmp4)
		   token = tmp2;
	   else if (tmp3<tmp4)
		   token = tmp3;
	   else
		   token = tmp4;

      /* Skip the leading copyright strings/character. */
      if (token[0]==COPYSIGN && token[1]!='\0') {
         token += 2;
      } else if (!_strnicmp(token, "copyright", strlen("copyright"))) {
		  token += strlen("copyright");
	  } else {
		  token += strlen("(c)");
	  }

	  /* Skip blanks. */
	  while(*token && isspace(*token) || *token==',')
		  token++;

	  /* Another copyright word? */
	  if (!_strnicmp((char*)token, "(c)", strlen("(c)")) ||
		  !_strnicmp((char*)token, "copyright", strlen("copyright")) ||
		  token[0]==COPYSIGN)
		  continue;

      /* Skip the years. */
	  company = token;
      if (isdigit(token[0])) {
         while (isdigit(*company) || isspace(*company) ||
				ispunct(*company) || (*company)=='-')
            company++;

         if (*company=='\0')
            break;

         /* Skip strings like "by", up to the beginning of a name that */
         /* starts with an upper case letter. */         
         while (*company && (company[0]<'A' || company[0]>'Z'))
            company++;

         done = TRUE;
      } else {
         continue;
      }
   } 


   /* Did we find it? */
   if (company) {
      while (*company && isspace(*company))
         company++; 


      if (*company=='\0') {
         company=NULL;
      } else {

         /* Terminate the company name. */
         if ((token = (UBYTE*)strchr(company, '.'))!=NULL) {

            /* Period as an initial delimiter, e.g. James, A. B. ?*/
            if (token[-1]>='A' && token[-1]<='Z') {
               if (strchr((char*)&token[1], '.'))
                  token = (UBYTE*)strchr((char*)&token[1], '.');

               /* Check for "James A. Bently, " */
               else if (strchr((char*)&token[1], ',')) {
                  token = (UBYTE*)strchr((char*)&token[1], ',');
                  token[0] = '.';
               }
            }
			token[1] = '\0';
         } else {
			 /* Name ending with a ';'? */
			 if ((token = (UBYTE*)strrchr(company, ';'))) {
				 *token = '\0';
			 }
		 }

		 /* Truncate some common strings. */
		 tmp1 = stristr(company, "all rights reserved");
		 *tmp1 = '\0';

		 /* Remove trailing punctuation character. */
		 for (i=strlen(company)-1; i>0 &&
				(ispunct(company[i]) || isspace(company[i])); i--) {
			 company[i] = 0;
		 }
      }
   }      
              

   return company;
}




/**** FUNCTIONS */

/***
 ** Function: ConvertAnyway
 **
 ** Description:
 **   Ask the user if it is ok to convert. 
 ***/
static errcode ConvertAnyway(const char *vendor, const char *facename)
{
   char tmp[256];
   char msg[1024];
   errcode answer;

   if (vendor==NULL || strlen(vendor)==0) {
      LoadString(hInst, IDS_RECOGNIZE1, tmp, sizeof(tmp));
      sprintf(msg, tmp, facename);
   } else {
      LoadString(hInst, IDS_RECOGNIZE2, tmp, sizeof(tmp));
      sprintf(msg, tmp, facename, vendor);
   }      
   LoadString(hInst, IDS_MAINMSG, tmp, sizeof(tmp));
   strcat(msg, tmp);
   LoadString(hInst, IDS_CAPTION, tmp, sizeof(tmp));
   answer = (errcode)MessageBox(NULL, msg, tmp, QUERY);
   SetLastError(0);

   return answer;
}



/***
 ** Function: CheckCopyright
 **
 ** Description:
 **   This is the callback function that verifies that
 **   the converted font is copyrighted by a company who
 **   has agreed to having their fonts converted by
 **   this software. These companies are registered in the
 **   registry data base.
 ***/


static errcode CheckCopyright(const char *facename,
                              const char *copyright,
                              const char *notice)
{
#ifdef NOCOPYRIGHTS
   return SKIP;
#else
   HKEY key;
   char tmp[256];
   char *company = NULL;
   char buf[1024];
   int done = FALSE;
   short result = FAILURE;
   

   /* Access the REG data base. */
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SUBKEY_TYPE1COPYRIGHTS, 0,
                    KEY_QUERY_VALUE, &key)==ERROR_SUCCESS) { 


      /* Look for the company name in the /notice string. */
      if (notice && notice[0]) {
         strcpy(buf, notice);
         company = GetCompany(buf);
      }

      /* Look in the /copyright string if the company name was not found. */
      if (company==NULL && copyright && copyright[0]) {
         strcpy(buf, copyright);
         company = GetCompany(buf);
      }


#ifdef SHOWCOPYRIGHTS
      LogError(MSG_INFO, MSG_Copyright, company);
      Encrypt(company, tmp);
      sprintf(&tmp[strlen(tmp)], "(%d)\n", CSum(tmp));
      LogError(MSG_INFO, MSG_Encoding, tmp);
#else

      /* Did not find a company name? */
      if (company==NULL &&
          ((notice==NULL || notice[0]=='\0'||
            strstr(notice, "Copyright")==NULL) &&
           (copyright==NULL || copyright[0]=='\0' ||
            strstr(copyright, "Copyright")==NULL))) {

         /* No known copyright. */
         LogError(MSG_WARNING, MSG_NOCOPYRIGHT, NULL);
         result = MAYBEOK;

      /* Strange copyright format? */
      } else if (company==NULL || company[0]=='\0') {
         if (notice || notice[0])
            LogError(MSG_WARNING, MSG_BADFORMAT, notice);
         else
            LogError(MSG_WARNING, MSG_BADFORMAT, copyright);

         result = MAYBEOK;

      /* Found copyright! */
      } else {
         DWORD size;
         DWORD csum;

         size = 4;
         if (RegQueryValueEx(key, Encrypt(company, tmp), NULL, NULL,
                             (LPBYTE)&csum, &size)==ERROR_SUCCESS) {
            
            /* A positive match -> ok to convert. */
            if (CSum(tmp)==csum) {
               LogError(MSG_INFO, MSG_COPYRIGHT, company);
               result = SUCCESS;
            } else {
               LogError(MSG_ERROR, MSG_BADCOPYRIGHT, company);
               result = SKIP;
            }
         } else {
            LogError(MSG_WARNING, MSG_BADCOPYRIGHT, company);
            result = MAYBEOK;
         }
      }               
#endif

      RegCloseKey(key);

      /* Give the user the final word. */
      if (result==FAILURE) {
         if (ConvertAnyway(company, facename)==TRUE)
            result = SUCCESS;
      }


   /* No copyright key in the registry? */
   } else {
      LogError(MSG_ERROR, MSG_NODB, NULL);
      result = FAILURE;
   }   


   return result;
#endif
}



/***
 ** Function: NTCheckCopyright
 **
 ** Description:
 **   This is the callback function that verifies that
 **   the converted font is copyrighted by a company who
 **   has agreed to having their fonts converted by
 **   this software. These companies are registered in the
 **   registry data base.
 ***/
static errcode NTCheckCopyright(const char *facename,
                                const char *copyright,
                                const char *notice)
{
   HKEY key;
   char tmp[256];
   char *company = NULL;
   char buf[1024];
   int done = FALSE;
   short result = FAILURE;
   

   /* Access the REG data base. */
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SUBKEY_TYPE1COPYRIGHTS, 0,
                    KEY_QUERY_VALUE, &key)==ERROR_SUCCESS) { 


      /* Look for the company name in the /notice string. */
      if (notice && notice[0]) {
         strcpy(buf, notice);
         company = GetCompany(buf);
      }

      /* Look in the /copyright string if the company name was not found. */
      if (company==NULL && copyright && copyright[0]) {
         strcpy(buf, copyright);
         company = GetCompany(buf);
      }

      /* Did not find a company name? */
      if (company==NULL &&
          ((notice==NULL || notice[0]=='\0'||
            strstr(notice, "Copyright")==NULL) &&
           (copyright==NULL || copyright[0]=='\0' ||
            strstr(copyright, "Copyright")==NULL))) {

         /* No known copyright. */
         result = MAYBE;

      /* Strange copyright format? */
      } else if (company==NULL || company[0]=='\0') {
         result = MAYBE;

      /* Found copyright! */
      } else {
         DWORD size;
         DWORD csum;

         /* remember for future use. */
         strncpy(lastVendor, company, 256);
         lastVendor[MIN(255, strlen(company))] = '\0';

         size = 4;
         if (RegQueryValueEx(key, Encrypt(company, tmp), NULL, NULL,
                             (LPBYTE)&csum, &size)==ERROR_SUCCESS) {
            
            /* A positive match -> ok to convert. */
            if (CSum(tmp)==csum) {
               result = SUCCESS;
            } else {
               result = FAILURE;
            }
         } else {
            result = MAYBE;
         }
      }               

      RegCloseKey(key);


   /* No copyright key in the registry? */
   } else {
      result = FAILURE;
   }   


   lastCP = result;

   return FAILURE;
}


/***
 ** Function: _Progress
 **
 ** Description:
 **   This is the internal progress callback function that 
 **   computes an percentage-done number, based on the
 **   number of converted glyphs.
 ***/
static void _Progress(short type, void *generic, void *arg)
{
   struct callFrame *f = arg;

   /* Processing glyphs or wrapping up? */
   if (type==0 || type==1) 
      f->done++;
   else
      f->done = MIN(sizeof(winmac)/sizeof(winmac[0]), f->done+10);
   
   if ((f->done-f->last)>MIN_PROGRESS) {
      f->Progress((short)(f->done*100/(sizeof(winmac)/sizeof(winmac[0]))),
                  f->arg);
      f->last = f->done;
   }
   
   UNREFERENCED_PARAMETER(type);
   UNREFERENCED_PARAMETER(generic);
   SetLastError(0L);
}
            
static BOOL ReadStringFromOffset(struct ioFile *file,
                                 const DWORD dwOffset, 
                                 char *pszString,
                                 int cLen,
                                 BOOL bStrip)
{
    BOOL result = TRUE;
    DWORD offset;

    /* Get offset to string. */
    io_FileSeek(file, dwOffset);

    /* Read the offset. */

    ReadLittleEndianDword(file, offset);

    /*  Get the string. */
    (void)io_FileSeek(file, offset);
    if (io_FileError(file) != SUCCESS) {
        result = FALSE;
    } else {
        int i;

        i=0;
        while (io_FileError(file)==SUCCESS && i<cLen) {
            pszString[i] = (UBYTE)io_ReadOneByte(file);
            if (pszString[i]=='\0')
                break;

            /* Replace all dashes with spaces. */
            if (bStrip && pszString[i]=='-')
                pszString[i]=' ';
            i++;
        }
    }

    return TRUE;
}
                                 



/**** FUNCTIONS */

/***
 ** Function: ConvertTypeFaceA
 **
 ** Description:
 **   Convert a T1 font into a TT font file. This is the
 **   simplified interface used by the Win32 DLL, with the
 **   ANSI interface.
 ***/
short STDCALL ConvertTypefaceAInternal(const char *type1,
                               const char *metrics,
                               const char *truetype,
                               const void (STDCALL *Progress)(short, void*),
                               void *arg)
{                        
   struct callFrame f;
   struct callProgress p;
   struct T1Arg t1Arg;
   struct TTArg ttArg;
   short status;


   /* Check parameters. */
   if (type1==NULL || metrics==NULL)
      return FAILURE;

   /* Set up arguments to ConvertTypefaceA() */
   t1Arg.filter = GLYPHFILTER;
   t1Arg.upem = (short)2048;
   t1Arg.name = (char *)type1;
   t1Arg.metrics = (char *)metrics;
   ttArg.precision = (short)50;
   ttArg.name = (char *)truetype;
   ttArg.tag = VERSTR;

   /* Use progress gauge */
   if (Progress) {
      LogError(MSG_INFO, MSG_STARTING, type1);

      f.Progress = Progress;
      f.done = 0;
      f.last = 0;
      f.arg = arg;
      p.arg = &f;
      p.cb = _Progress;
      status = ConvertT1toTT(&ttArg, &t1Arg, CheckCopyright, &p);
      Progress(100, arg);
   } else {
      status = ConvertT1toTT(&ttArg, &t1Arg, CheckCopyright, NULL);
   }

   
   return status;
}



short STDCALL ConvertTypefaceA(const char *type1,
                               const char *metrics,
                               const char *truetype,
                               const void (STDCALL *Progress)(short, void*),
                               void *arg)
{

    short bRet;

    try
    {
        bRet = ConvertTypefaceAInternal(type1,
                                        metrics,
                                        truetype,
                                        Progress,
                                        arg);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
    #if 0
        ASSERTGDI(
            GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR,
            "ttfd!ttfdSemLoadFontFile, strange exception code\n"
            );
    #endif

        bRet = BADINPUTFILE;

    }

    return bRet;
}


short STDCALL FindPfb (
    char *pszPFM,
    char *achPFB
);


/***
** Function: CheckPfmA
**
** Description:
**   This function determines if there is a pfm/pfb pair of
**   files that makes up an Adobe Type 1 font, and determins
**   the descriptive face name of it.
**
** Returns: 16-bit encoded value indicating error and type of file where
**          error occurred.  (see fvscodes.h) for definitions.
**          The following table lists the "status" portion of the codes
**          returned.
**
**           FVS_SUCCESS           
**           FVS_INVALID_FONTFILE  
**           FVS_FILE_OPEN_ERR   
**           FVS_INVALID_ARG
**           FVS_FILE_IO_ERR
**           FVS_BAD_VERSION
***/

short STDCALL CheckPfmA(
    char  *pszPFM,
    DWORD  cjDesc,
    char  *pszDesc,
    DWORD  cjPFB,
    char  *pszPFB
)
{
   struct ioFile *file;
   char szDriver[MAX_PATH];
   short result = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
   short ver;

   char achPFB[MAX_PATH];

   char  *psz_PFB;
   DWORD  cjPFB1;

   if (pszPFB)
   {
       psz_PFB = pszPFB;
       cjPFB1 = cjPFB;
   }
   else
   {
       psz_PFB = (char *)achPFB;
       cjPFB1 = MAX_PATH;
   }

   /* Check parameter. */
   if (pszPFM==NULL || ((strlen(pszPFM)+3) >= cjPFB1))
      return FVS_MAKE_CODE(FVS_INVALID_ARG, FVS_FILE_UNK);

   // check if pfb file exists and find the path to it:

    result = FindPfb(pszPFM, psz_PFB);
    if (FVS_STATUS(result) != FVS_SUCCESS)
        return result;

   /****
    * Locate the pszDescriptive name of the font.
    */

   if ((file = io_OpenFile(pszPFM, READONLY))==NULL)
      return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_PFM);

   (void)io_ReadOneByte(file);     /* Skip the revision number. */
   ver = (short)io_ReadOneByte(file);

   if (ver > 3) {
      /*  ERROR - unsupported format */
      result = FVS_MAKE_CODE(FVS_BAD_VERSION, FVS_FILE_PFM);
   } else {

      /* Read the driver name. */
      if (!ReadStringFromOffset(file, DFDRIVERINFO, szDriver, 
                                    sizeof(szDriver), FALSE))
      {
          result = FVS_MAKE_CODE(FVS_FILE_IO_ERR, FVS_FILE_PFM);
      }
      /* Is it "PostScript" ? */
      else if (_stricmp(szDriver, "PostScript"))
      {
          result = FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_PFM);
      }
      /* Only get description if asked to do so. */
      else if (pszDesc && !ReadStringFromOffset(file, DFFACE, pszDesc, cjDesc, TRUE))
      {
          result = FVS_MAKE_CODE(FVS_FILE_IO_ERR, FVS_FILE_PFM);
      }
   }

   (void)io_CloseFile(file);

   return result;
}


/***
 ** Function: DllMain
 **
 ** Description:
 **   Main function of the DLL. Use to cache the module handle,
 **   which is needed to pop-up messages and peek in the registry.
 ***/
BOOL WINAPI DllMain(PVOID hmod,
                    ULONG ulReason,
                    PCONTEXT pctx OPTIONAL)
{
   if (ulReason == DLL_PROCESS_ATTACH) {
      hInst = hmod;
      DisableThreadLibraryCalls(hInst);
   }


   UNREFERENCED_PARAMETER(pctx);

   return TRUE;
}


/***
** Function: CheckCopyrightsA
**
** Description:
**   This function verifies that it is ok to convert the font. This is
**   done by faking an installation.
***/
short STDCALL CheckCopyrightAInternal(const char *szPFB,
                              const DWORD wSize,
                              char *szVendor)
{
   struct T1Arg t1Arg;
   struct TTArg ttArg;
   
   /* Set up arguments to ConvertTypefaceA() */
   t1Arg.metrics = NULL;
   t1Arg.upem = (short)2048;
   t1Arg.filter = GLYPHFILTER;
   t1Arg.name = szPFB;
   ttArg.precision = (short)200;
   ttArg.tag = NULL;
   ttArg.name = "NIL:";
   lastCP = FAILURE;
   strcpy(lastVendor, "");
   (void)ConvertT1toTT(&ttArg, &t1Arg, NTCheckCopyright, NULL);
   strncpy(szVendor, lastVendor, wSize);
   szVendor[MIN(wSize, strlen(lastVendor))] = '\0';
  
   return lastCP;
}


short STDCALL CheckCopyrightA(const char *szPFB,
                              const DWORD wSize,
                              char *szVendor)
{
    short iRet;

    try
    {
        iRet = CheckCopyrightAInternal(szPFB,wSize,szVendor);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        iRet = BADINPUTFILE;
    }
    return iRet;

}






/******************************Public*Routine******************************\
*
* short STDCALL CheckInfA (
*
* If pfm and inf files are in the same directory only pfm is recognized
* and inf file is ignored.
*
* History:
*  27-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR  
*           FVS_FILE_EXISTS
*           FVS_INSUFFICIENT_BUF
*
\**************************************************************************/


short CreatePFM(char *pszINF, char *pszAFM, char *pszPFM);
BOOL bGetDescFromInf(char * pszINF, DWORD cjDesc, char *pszDesc);

BOOL bFileExists(char *pszFile)
{
    HFILE hf;

    if ((hf = _lopen(pszFile, OF_READ)) != -1)
    {
        _lclose(hf);
        return TRUE;
    }

    return FALSE;
}

short STDCALL CheckInfA (
    char *pszINF,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath
)
{
    char achPFM[MAX_PATH];
    char achPFB[MAX_PATH];
    char achAFM[MAX_PATH];

    DWORD  cjKey;
    char *pszParent = NULL; // points to the where parent dir of the inf file is
    char *pszBare = NULL; // "bare" .inf name, initialization essential
    short result = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
    BOOL bAfmExists = FALSE;
    BOOL bPfbExists = FALSE;

    //
    // This is a real hack use of pbCreatedPFM.
    // It's the best solution with the time we have.
    //
    BOOL bCheckForExistingPFM = *pbCreatedPFM;

    *pbCreatedPFM = FALSE;

// example:
// if pszINF -> "c:\psfonts\fontinfo\foo_____.inf"
// then pszParent -> "fontinfo\foo_____.inf"

    cjKey = strlen(pszINF) + 1;

    if (cjKey < 5)          // 5 = strlen(".pfm") + 1;
        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_INF);

// check if a pfm file exists in the SAME directory.
// Use the buffer on the stack to produce the path for the pfm file:

    strcpy(achPFM, pszINF);
    strcpy(&achPFM[cjKey - 5],".PFM");

// try to open pfm file to check if it exists:

    if (bCheckForExistingPFM && bFileExists(achPFM))
    {
    // we found the pfm file, therefore we do not report this .inf file.

        return FVS_MAKE_CODE(FVS_FILE_EXISTS, FVS_FILE_PFM);
    }

// pfm file is NOT found, go on to check if .afm and .pfb files exists:
// We will first check if .afm and .pfb files exists in the same dir as .inf

    strcpy(achAFM, pszINF);
    strcpy(&achAFM[cjKey - 5],".AFM");

    strcpy(achPFB, pszINF);
    strcpy(&achPFB[cjKey - 5],".PFB");

    bAfmExists = bFileExists(achAFM);
    bPfbExists = bFileExists(achPFB);

    if (!bAfmExists || !bPfbExists)
    {
    // we did not find the .afm and .pfb files in the same dir as .inf
    // we will check two more directories for the .afm and .pfb files
    // 1) the parent directory of the .inf file for .pfb file
    // 2) the afm subdirectory of the .inf parent directory for .afm file
    //
    // This is meant to handle the standard configuration of files produced
    // on user's hard drive by unlocking fonts from Adobe's CD or from a
    // previous installation of atm manager on this machine.
    // This configuration is as follows:
    // c:\psfonts\           *.pfb files are here
    // c:\psfonts\afm        *.afm files are here
    // c:\psfonts\fontinfo   *.inf files are here
    // c:\psfonts\pfm        *.pfm files that are created on the fly
    //                         are PUT here by atm.
    // We will instead put the files in windows\system dir where all other
    // fonts are, it may not be possible to write pmf files on the media
    // from where we are installing fonts

        pszBare = &pszINF[cjKey - 5];
        for ( ; pszBare > pszINF; pszBare--)
        {
            if ((*pszBare == '\\') || (*pszBare == ':'))
            {
                pszBare++; // found it
                break;
            }
        }

    // check if full path to .inf file was passed in or a bare
    // name itself was passed in to look for .inf file in the current dir

        if ((pszBare > pszINF) && (pszBare[-1] == '\\'))
        {
        // skip '\\' and search backwards for another '\\':

            for (pszParent = &pszBare[-2]; pszParent > pszINF; pszParent--)
            {
                if ((*pszParent == '\\') || (*pszParent == ':'))
                {
                    pszParent++; // found it
                    break;
                }
            }

        // create .pfb file name in the .inf parent directory:

            strcpy(&achPFB[pszParent - pszINF], pszBare);
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");

        // create .afm file name in the afm subdirectory of the .inf
        // parent directory:

            strcpy(&achAFM[pszParent - pszINF], "afm\\");
            strcpy(&achAFM[pszParent - pszINF + 4], pszBare);
            strcpy(&achAFM[strlen(achAFM) - 4], ".AFM");

        }
        else if (pszBare == pszINF)
        {
        // bare name was passed in, to check for the inf file in the "." dir:

            strcpy(achPFB, "..\\");
            strcpy(&achPFB[3], pszBare);   // 3 == strlen("..\\")
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");

            strcpy(achAFM, "..\\afm\\");
            strcpy(&achAFM[7], pszBare);   // 7 == strlen("..\\afm\\")
            strcpy(&achAFM[strlen(achAFM) - 4], ".AFM");
        }
        else
        {
            return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);
        }

   // check again if we can find the files, if not fail.

       if (!bAfmExists && !bFileExists(achAFM))
          return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_AFM);
       if (!bPfbExists && !bFileExists(achPFB))
          return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_PFB);
    }

// now we have paths to .inf .afm and .pfb files. Now let us see
// what the caller wants from us:

    if (pszDesc)
    {
    // we need to return description string in the buffer supplied

        if (!bGetDescFromInf(pszINF, (DWORD)cjDesc, pszDesc))
            return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_INF);
    }

// copy pfb file path out if requested

    if (pszPFB)
    {
        if ((strlen(achPFB) + 1) < cjPFB)
            strcpy(pszPFB,achPFB);
        else
            return FVS_MAKE_CODE(FVS_INSUFFICIENT_BUF, FVS_FILE_UNK); 
    }

// the caller wants a pfm file created from inf,afm files
// For now and probably for ever we will put this file in
// the %windir%\system, or %windir%\fonts for the secure system.

    if (pszPFM)
    {
        UINT cjSystemDir;
        char *pszAppendHere;  // append "bare" name here

    // copy the first directory of the font path into the buffer provided
    // It is expected that this routine will get something like
    // "c:\foo" pointing to font path

        strcpy(achPFM,pszFontPath);
        pszAppendHere = &achPFM[strlen(pszFontPath) - 1];

        if (*pszAppendHere != '\\')
        {
             pszAppendHere++;
            *pszAppendHere = '\\';
        }
        pszAppendHere++;

    // find bare name of the .inf file if we do not have already:

        if (!pszBare)
        {
            pszBare = &pszINF[cjKey - 5];
            for ( ; pszBare > pszINF; pszBare--)
            {
                if ((*pszBare == '\\') || (*pszBare == ':'))
                {
                    pszBare++; // found it
                    break;
                }
            }
        }

    // append Bare name to the %windir%system\ path

        strcpy(pszAppendHere, pszBare);

    // finally change .inf extension to .pfm extension

        strcpy(&pszAppendHere[strlen(pszAppendHere) - 4], ".PFM");

    // copy out:

        strcpy(pszPFM, achPFM);
        
        result = CreatePFM(pszINF, achAFM, pszPFM);
        *pbCreatedPFM = (FVS_STATUS(result) == FVS_SUCCESS);

        if (!(*pbCreatedPFM))
            return result;
    }

    return FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
}


/******************************Public*Routine******************************\
*
* short STDCALL CheckType1AInternal
*
* Effects: See if we are going to report this as a valid type 1 font
*
* Warnings:
*
* History:
*  29-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR
*           FVS_INVALID_ARG
*           FVS_FILE_IO_ERR
*           FVS_BAD_VERSION
*           FVS_FILE_EXISTS
*           FVS_INSUFFICIENT_BUF
*
\**************************************************************************/


short STDCALL CheckType1AInternal (
    char *pszKeyFile,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath

)
{
    DWORD  cjKey;

    *pbCreatedPFM = FALSE; // initialization is essential.

    cjKey = strlen(pszKeyFile) + 1;

    if (cjKey < 5)          // 5 = strlen(".pfm") + 1;
        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);

    if (!_strcmpi(&pszKeyFile[cjKey - 5], ".PFM"))
    {
    // copy out pfm string when asked to do so:

        if (pszPFM && (cjKey < cjPFM))
        {
            if (cjKey < cjPFM)
                strcpy(pszPFM, pszKeyFile);
            else
                return FVS_MAKE_CODE(FVS_INSUFFICIENT_BUF, FVS_FILE_UNK);
        }

        return CheckPfmA(
                   pszKeyFile,
                   cjDesc,
                   pszDesc,
                   cjPFB,
                   pszPFB
                   );
    }
    else if (!_strcmpi(&pszKeyFile[cjKey - 5], ".INF"))
    {
        return CheckInfA (
                   pszKeyFile,
                   cjDesc,
                   pszDesc,
                   cjPFM,
                   pszPFM,
                   cjPFB,
                   pszPFB,
                   pbCreatedPFM,
                   pszFontPath
                   );
    }
    else
    {
    // this font is not our friend

        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);
    }
}


/******************************Public*Routine******************************\
*
* CheckType1WithStatusA, try / except wrapper
*
* Effects:
*
* Warnings:
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR
*           FVS_INVALID_ARG
*           FVS_FILE_IO_ERR
*           FVS_BAD_VERSION
*           FVS_FILE_EXISTS
*           FVS_INSUFFICIENT_BUF
*           FVS_EXCEPTION
*         
\**************************************************************************/

short STDCALL CheckType1WithStatusA (
    char *pszKeyFile,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath
)
{
    short status;
    try
    {
        status = CheckType1AInternal (
                   pszKeyFile,
                   cjDesc,
                   pszDesc,
                   cjPFM,
                   pszPFM,
                   cjPFB,
                   pszPFB,
                   pbCreatedPFM,
                   pszFontPath);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = FVS_MAKE_CODE(FVS_EXCEPTION, FVS_FILE_UNK);
    }

    return status;
}

/******************************Public*Routine******************************\
*
* CheckType1A, try / except wrapper
*
* Effects:
*
* Warnings:
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL STDCALL CheckType1A (
    char *pszKeyFile,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath
)
{
    short status = CheckType1WithStatusA(pszKeyFile,
                                         cjDesc,
                                         pszDesc,
                                         cjPFM,
                                         pszPFM,
                                         cjPFB,
                                         pszPFB,
                                         pbCreatedPFM,
                                         pszFontPath);

    return (FVS_STATUS(status) == FVS_SUCCESS);
}


/******************************Public*Routine******************************\
*
* FindPfb, given pfm file, see if pfb file exists in the same dir or in the
* parent directory of the pfm file
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*
\**************************************************************************/


short STDCALL FindPfb (
    char *pszPFM,
    char *achPFB
)
{
    DWORD  cjKey;
    char *pszParent = NULL; // points to the where parent dir of the inf file is
    char *pszBare = NULL;   // "bare" .inf name, initialization essential

// example:
// if pszPFM -> "c:\psfonts\pfm\foo_____.pfm"
// then pszParent -> "pfm\foo_____.pfm"

    cjKey = strlen(pszPFM) + 1;

    if (cjKey < 5)          // 5 = strlen(".pfm") + 1;
        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_PFM);

// go on to check if .pfb file exists:
// We will first check .pfb file exists in the same dir as .pfm

    strcpy(achPFB, pszPFM);
    strcpy(&achPFB[cjKey - 5],".PFB");

    if (!bFileExists(achPFB))
    {
    // we did not find the .pfb file in the same dir as .pfm
    // Now check the parent directory of the .pfm file

        pszBare = &pszPFM[cjKey - 5];
        for ( ; pszBare > pszPFM; pszBare--)
        {
            if ((*pszBare == '\\') || (*pszBare == ':'))
            {
                pszBare++; // found it
                break;
            }
        }

    // check if full path to .pfm was passed in or a bare
    // name itself was passed in to look for .pfm file in the current dir

        if ((pszBare > pszPFM) && (pszBare[-1] == '\\'))
        {
        // skip '\\' and search backwards for another '\\':

            for (pszParent = &pszBare[-2]; pszParent > pszPFM; pszParent--)
            {
                if ((*pszParent == '\\') || (*pszParent == ':'))
                {
                    pszParent++; // found it
                    break;
                }
            }

        // create .pfb file name in the .pfm parent directory:

            strcpy(&achPFB[pszParent - pszPFM], pszBare);
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");

        }
        else if (pszBare == pszPFM)
        {
        // bare name was passed in, to check for the inf file in the "." dir:

            strcpy(achPFB, "..\\");
            strcpy(&achPFB[3], pszBare);   // 3 == strlen("..\\")
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");
        }
        else
        {
            return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_PFM); // We should never get here.
        }

   // check again if we can find the file, if not fail.

       if (!bFileExists(achPFB))
       {
           return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_PFB);
       }
    }

// now we have paths to .pfb file in the buffer provided by the caller.

    return FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\testt1.c ===
#include <stdio.h>
#include <stdlib.h>
#include "t1instal.h"

#define DEFAULT_STR  (void*)"Converting with pfb: "
#define PFM_STR      (void*)"Converting with pfb+pfm: "
#define FULL_STR     (void*)"Converting with pfb+pfm+ttf: "

#ifdef _MSC_VER
#  define CDECL  __cdecl
#else
#  define CDECL
#endif


#ifdef PROGRESS
const void STDCALL PrintProgress(short percent, void *arg)
{
   char *str = arg;
   
   printf("\r%s%d%%  ", str, percent);
}
#else
#define PrintProgress 0L
#endif

void CDECL main(int argc, char **argv)
{
   short res;
   char buf[128];

   if (argc==2)
      res = ConvertTypeface(argv[1], 0L, 0L,
                            PrintProgress, DEFAULT_STR);
   else if (argc==3) {
      if (IsType1(argv[2], sizeof(buf), buf)) {
         printf("Converting typeface: %s\n", buf);
         res = ConvertTypeface(argv[1], argv[2], 0L,
                               PrintProgress, PFM_STR);
      } else {
         printf("Not a valid Adobe Type 1 typeface.\n");
      }
         
   } else if (argc==4) {
      if (IsType1(argv[2], sizeof(buf), buf)) {
         printf("Converting typeface: %s\n", buf);
         res = ConvertTypeface(argv[1], argv[2], argv[3],
                               PrintProgress, PFM_STR);
      } else {
         printf("Not a valid Adobe Type 1 typeface.\n");
      }
   }

   if (res!=SUCCESS)
      puts("\nConversion failed!");

   exit((int)res);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\t1parser.c ===
/***
**
**   Module: T1Parser
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font file, by parsing
**      the data/commands found in PFB, PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>
#include "types.h"

/* Special types and definitions. */
#include "safemem.h"
#include "encoding.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "titott.h"
#include "t1parser.h"
#include "charstr.h"
#include "freader.h"
#include "mreader.h"


/***** CONSTANTS */
#define ONE       (USHORT)1
#define BUFLEN    (USHORT)512

#define PS_ANGLE              "/ItalicAngle"
#define PS_ARRAY              "array"
#define PS_BEGIN              "begin"
#define PS_BLUEFUZZ           "/BlueFuzz"
#define PS_BLUESCALE          "/BlueScale"
#define PS_BLUESHIFT          "/BlueShift"
#define PS_BLUEVALUES         "/BlueValues"
#define PS_CHARSTRINGS        "/CharStrings"
#define PS_COPYRIGHT          "/Copyright"
#define PS_DATE               "%%CreationDate:"
#define PS_DUP                "dup"
#define PS_ENCODING           "/Encoding"
#define PS_END                "end"
#define PS_FAMILY             "/FamilyName"
#define PS_FAMILYBLUES        "/FamilyBlues"
#define PS_FAMILYOTHERBLUES   "/FamilyOtherBlues"
#define PS_FONTMATRIX         "/FontMatrix"
#define PS_FORCEBOLD          "/ForceBold"
#define PS_FULLNAME           "/FullName"
#define PS_HYBRID             "hires"
#define PS_ISFIXED            "/isFixedPitch"
#define PS_LENIV              "/lenIV"
#define PS_NAME               "/FontName"
#define PS_NOACCESS           "noaccess"
#define PS_NOTICE             "/Notice"
#define PS_OTHERBLUES         "/OtherBlues"
#define PS_SNAPH              "/StemSnapH"
#define PS_SNAPV              "/StemSnapV"
#define PS_STDENCODING        "StandardEncoding"
#define PS_STDVW              "/StdVW"
#define PS_STDHW              "/StdHW"
#define PS_SUBRS              "/Subrs"
#define PS_UNDERLINE          "/UnderlinePosition"
#define PS_UTHICK             "/UnderlineThickness"
#define PS_ID                 "/UniqueID"
#define PS_VERSION            "/version"
#define PS_WEIGHT             "/Weight"



/***** LOCAL TYPES */

struct T1Handle {
   struct FontFile *ff;

   struct PSState *ps;

   struct Subrs stdenc[256];

   USHORT numsubrs;
   struct Subrs *subrs;
   USHORT leniv;
   struct T1Metrics t1m;
};


/***** MACROS */
/*-none-*/


/***** PROTOTYPES */
/*-none-*/

/***** STATIC FUNCTIONS */


/***
** Function: StrToFix
**
** Description:
**   This is a "strtod" function, that converts from
**   ascii to fixpoint numbers.
***/
static long StrToFix(char *str, char **out, const long base)
{
   char *fstr;
   long num = 0, frac = 0, exp = 0;

   if (out)
      (*out) = str;

   /* Skip white space. */
   while (*str && (*str==' ' || *str=='\t'))
      str++;

   /* A number? */
   if (*str && ((*str>='0' && *str<='9') || *str=='-') || *str=='.') {

      num = atoi(str)*base;

      /* Fraction? */
      fstr = strchr(str, '.');
      if (fstr!=NULL && (strchr(str, ' ')==NULL || fstr<strchr(str, ' '))) {

         do {
            fstr++;
         } while (*fstr>='0' && *fstr<='9');

         /* Exponent? */
         if (*fstr=='E')
            exp = atoi(fstr+1);
         else
            exp = 0;

         fstr--;
         while (*fstr!='.') {
            frac += ((*fstr)-'0')*base;
            frac /= 10;
            fstr--;
         }
         if (num<0)
            num -= frac;
         else
            num += frac;

         /* Handle exponent. */
         if (exp>0) {
            do {
               num *= 10;
            } while (--exp);
         } else if (exp<0) {
            do {
               num /= 10;
            } while (++exp);
         }
      }

      /* Skip digits. */
      while (*str && ((*str>='0' && *str<='9') ||
                      *str=='.' || *str=='-' || *str=='E'))
         str++;

      if (out)
         (*out) = str;
   }

   return num;
}



/***
** Function: FreeT1Composite
**
** Description:
**   This function frees the memory used to represent
**   a composite acented T1 glyph.
***/
static void FreeT1Composite(Composite *comp)
{
   if (comp) {
      if (comp->cchar)
         Free(comp->cchar);
      Free(comp);
   }
}


/***
** Function: UseGlyph
**
** Description:
**   This function determines whether a glyph should be
**   converted or not, based on the name of the glyph
**   and a specification of the desired glyphs.
***/
static int CDECL compare(const void *arg1, const void *arg2)
{
	return strcmp( *((const char **)arg1), *((const char **)arg2) );
}
static boolean UseGlyph(const struct GlyphFilter *filter,
                        Composite *comp,
                        const char *name)
{
   boolean found = FALSE;
   char **result;

   /* Check if the glyph is explicitly specified. */
   if (filter) {

      result = (char **)bsearch((char *)&name,
                                (char *)filter->name, filter->num,
                                sizeof(char *),
                                compare);


      found = (boolean)(result!=NULL);

      /* Check if the glyph is specified indirectly through an accented */
      /* composite glyph. */
      if (!found) {
         Composite *c;

         for (c=comp; c &&
                strcmp(name, c->achar) &&
                strcmp(name, c->bchar); c = c->next);
         found = (boolean)(c!=NULL);
      }
   } else {
      found = TRUE;
   }

   return found;
}



/***
** Function: ReadFontMatrix
**
** Description:
**   Read the command sequence "/FontMatrix[%d %d %d %d]" and
**   record the transformation matrix in the T1 handle.
***/
static errcode ReadFontMatrix(struct T1Handle *t1,
                              char *str,
                              const USHORT len)
{
   errcode status=SUCCESS;
   f16d16 fmatrix[6];
   USHORT i;

   if (GetSeq(t1->ff, str, len)) {
      for (i=0; i<6; i++)
         fmatrix[i] = StrToFix(str, &str, F16D16BASE);

      /* Check if we have the default matrix. */ /*lint -e771 */
      if (fmatrix[2]!=0 ||
          fmatrix[4]!=0 ||
          fmatrix[1]!=0 ||
          fmatrix[5]!=0 ||
          fmatrix[0]!=F16D16PPM ||
          fmatrix[3]!=F16D16PPM ||
          t1->t1m.upem!=2048) {  /*lint +e771 */ /* fmatrix[] IS initialized */

          if ((t1->t1m.fmatrix = Malloc(sizeof(f16d16)*6))==NULL) {
              SetError(status = NOMEM);
          } else {
            t1->t1m.fmatrix[0] = fmatrix[0];
            t1->t1m.fmatrix[1] = fmatrix[1];
            t1->t1m.fmatrix[2] = fmatrix[2];
            t1->t1m.fmatrix[3] = fmatrix[3];
            t1->t1m.fmatrix[4] = fmatrix[4];
            t1->t1m.fmatrix[5] = fmatrix[5];
         }
      } else {
         t1->t1m.fmatrix = NULL;
      }
   } else {
      SetError(status = BADINPUTFILE);
   }

   return status;
}


/***
** Function: ReadEncodingArray
**
** Description:
**   Read the command sequence "/Encoding %d array ..." and
**   build an encoding table, or read "/Encoding StdEncoding def"
**   and used the standard encoding table.
***/
static errcode ReadEncodingArray(struct T1Handle *t1,
                                 char *str,
                                 const USHORT len)
{
   errcode status = SUCCESS;
   USHORT codes[ENC_MAXCODES];
   char *glyph_name = NULL;
   USHORT i, index;

   if (Get_Token(t1->ff, str, len)==NULL) {
      SetError(status = BADINPUTFILE);
   } else {
      if (strcmp(str, PS_STDENCODING) &&
          ((t1->t1m.encSize=(USHORT)atoi(str))!=0)) {
         if ((t1->t1m.encoding = AllocEncodingTable(t1->t1m.encSize))==NULL) {
            SetError(status = NOMEM);
         } else {

            /* Skip leading proc. */
            while (Get_Token(t1->ff, str, len) && strcmp(str, PS_DUP));

            /* Read the encoding entries: "<n> <str> put <comment>\n dup" */
            for (i=0; i<t1->t1m.encSize; i++) {

               /* Get character code. */
               (void)Get_Token(t1->ff, str, len);
               if (str[0]=='8' && str[1]=='#') {   /* Octal? */
                  index = (USHORT)atoi(&str[2]);
                  index = (USHORT)((index/10)*8 + (index%8));
               } else {
                  index = (USHORT)atoi(str);
               }

               /* Get character name. */
               (void)Get_Token(t1->ff, str, len);

               codes[ENC_MSWINDOWS] = index;
               codes[ENC_UNICODE] = index;

               if (index<256) {
                  codes[ENC_STANDARD] = index;
                  codes[ENC_MACCODES] = index;
               } else {
                  codes[ENC_STANDARD] = NOTDEFCODE;
                  codes[ENC_MACCODES] = NOTDEFCODE;
               }
               if ((glyph_name = Strdup(&str[1]))!=NULL)
                  SetEncodingEntry(t1->t1m.encoding, i,
                                   glyph_name,
                                   ENC_MAXCODES,
                                   codes);
               else {
                  status = NOMEM;
                  break;
               }
               
               (void)Get_Token(t1->ff, str, len);   /* Pop "dup" */
               (void)Get_Token(t1->ff, str, len);   /* Pop "put" or comment. */
               if (str[0]=='%') {
                  (void)GetNewLine(t1->ff, str, len);
                  (void)Get_Token(t1->ff, str, len);   /* Pop "put". */
               }

               if (strcmp(str, PS_DUP))
                  break;
            }
            t1->t1m.encSize = (USHORT)(i+1);

            /* Rehash the table. */
            RehashEncodingTable(t1->t1m.encoding, t1->t1m.encSize);
         }
      }
   }

   return status;
}


/***
** Function: ReadArray
**
** Description:
**   Read an array.
***/
static errcode ReadArray(struct T1Handle *t1,
                         char *str,
                         const USHORT len,
                         funit *array,
                         USHORT maxarr,
                         USHORT *cnt)
{
   errcode status;
   char *nxt;

   if (GetSeq(t1->ff, str, len)) {
      (*cnt)=0;
      do {
         array[(*cnt)] = (funit)(((StrToFix(str, &nxt, 4L)+8002)>>2) - 2000);
         if (nxt==str)
            break;
         str = nxt;
      } while (++(*cnt)<maxarr);
      status=SUCCESS;
   } else {
      SetError(status = BADINPUTFILE);
   }

   return status;
}



/***
** Function: ReadFontSubrs
**
** Description:
**   Read the command sequence "/Subrs %d array dup %d %d RD %x ND ...",
**   decode and decrypt the subroutines and store them in the T1
**   handle.
***/
static errcode ReadFontSubrs(struct T1Handle *t1,
                             char *str, const USHORT len)
{
   errcode status = SUCCESS;
   USHORT index,i,j;
   USHORT count = 0;
   USHORT r;
   short b;

   /* Get the number of subroutines. */
   if (Get_Token(t1->ff, str, len)==NULL) {
      SetError(status = BADINPUTFILE);
   } else {
      count = (USHORT)atoi(str);

      /* Get the "array" keyword". */
      if ((Get_Token(t1->ff, str, len)==NULL) || strcmp(str, PS_ARRAY)) {
         SetError(status = BADINPUTFILE);
      } else {
         if ((t1->subrs = Malloc((USHORT)sizeof(struct Subrs)*count))==NULL) {
            SetError(status = NOMEM);
         } else {
            memset(t1->subrs, '\0', sizeof(struct Subrs)*count);
            t1->numsubrs = count;
            for (i=0; i<count; i++) {

               if (Get_Token(t1->ff, str, len)==NULL) {  /* Get "dup" */
                  SetError(status = BADINPUTFILE);
                  break;
               }
               if (strcmp(str, PS_DUP)) {
                  SetError(status = BADT1HEADER);
                  break;
               }

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get Subr index. */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               index = (USHORT)atoi(str);
               if (t1->subrs[index].code) {
                  LogError(MSG_WARNING, MSG_DBLIDX, NULL);
                  Free(t1->subrs[index].code);
               }

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get length. */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               t1->subrs[index].len = (USHORT)(atoi(str) - t1->leniv);
               if ((t1->subrs[index].code
                    = Malloc(t1->subrs[index].len))==NULL) {
                  SetError(status = NOMEM);
                  break;
               }

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get RD + space */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               /* Skip space. */
               (void)GetByte(t1->ff);

               /* Skip lenIV */
               r = 4330;
               for (j=0; j<t1->leniv; j++) {
                  b=GetByte(t1->ff);
                  (void)Decrypt(&r, (UBYTE)b);
               }
               if (status!=SUCCESS)
                  break;

               /* Get code. */
               for (j=0; j<t1->subrs[index].len; j++) {
                  b=GetByte(t1->ff);
                  t1->subrs[index].code[j] = Decrypt(&r, (UBYTE)b);
               }
               if (status!=SUCCESS)
                  break;

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get ND */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               /* Check for non-ATM compatible equivalent to 'ND' */
               if (!strcmp(str, PS_NOACCESS)) {
                  (void)Get_Token(t1->ff, str, len);
               }

            }
         }
      }
   }

   return status;
}





/***** FUNCTIONS */


/***
** Function: FlushWorkspace
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
void FlushWorkspace(struct T1Handle *t1)
{
   USHORT i;

   /* Free /Subrs */
   if (t1->subrs) {
      for (i=0; i<t1->numsubrs; i++) {
         Free(t1->subrs[i].code);
      }
      Free(t1->subrs);
   }
   t1->subrs = NULL;
}   


/***
** Function: CleanUpT1
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
errcode CleanUpT1(struct T1Handle *t1)
{
   errcode status = SUCCESS;
   AlignmentControl *align;
   Composite *next;
   Blues *blues;
   USHORT i;

   if (t1) {

      /* Free the PSState */
      if (t1->ps)
         FreePSState(t1->ps);

      /* Free /Subrs */
      if (t1->subrs) {
         for (i=0; i<t1->numsubrs; i++) {
            Free(t1->subrs[i].code);
         }
         Free(t1->subrs);
      }

      /* Clean up font file reader. */
      status = FRCleanUp(t1->ff);

      /* Clean up font matrix. */
      if (t1->t1m.fmatrix)
         Free(t1->t1m.fmatrix);

      /* Clean up seac. */
      while (t1->t1m.used_seac) {
         next = t1->t1m.used_seac->next;
         FreeT1Composite(t1->t1m.used_seac);
         t1->t1m.used_seac = next;
      }
      while (t1->t1m.seac) {
         next = t1->t1m.seac->next;
         FreeT1Composite(t1->t1m.seac);
         t1->t1m.seac = next;
      }

      /* Clean up stdenc. */
      for (i=0; i<256; i++) {
         if (t1->stdenc[i].code) {
            Free(t1->stdenc[i].code);
            t1->stdenc[i].code = NULL;
            t1->stdenc[i].len = 0;
         }
      }

      /* Clean up encoding table. */
      if (t1->t1m.encoding)
         FreeEncoding(t1->t1m.encoding, t1->t1m.encSize);

      /* Free strings */
      if (t1->t1m.date)
         Free(t1->t1m.date);
      if (t1->t1m.copyright)
         Free(t1->t1m.copyright);
      if (t1->t1m.name)
         Free(t1->t1m.name);
      if (t1->t1m.id)
         Free(t1->t1m.id);
      if (t1->t1m.notice)
         Free(t1->t1m.notice);
      if (t1->t1m.fullname)
         Free(t1->t1m.fullname);
      if (t1->t1m.weight)
         Free(t1->t1m.weight);
      if (t1->t1m.family)
         Free(t1->t1m.family);
      if (t1->t1m.widths)
         Free(t1->t1m.widths);
                if (t1->t1m.kerns)
                        Free(t1->t1m.kerns);
      if (t1->t1m.stems.vwidths)
         Free(t1->t1m.stems.vwidths);
      if (t1->t1m.stems.hwidths)
         Free(t1->t1m.stems.hwidths);
      blues = &(t1->t1m.blues);
      align = &(t1->t1m.blues.align);
      for (i=0; i<blues->blue_cnt/2; i++) {
         Free(align->top[i].pos);
      }
      for (i=0; i<blues->oblue_cnt/2; i++) {
         Free(align->bottom[i].pos);
      }

      /* Free handle. */
      Free(t1);
   }

   return status;
}



/***
** Function: InitT1Input
**
** Description:
**   Allocate and initiate a handle for a T1 font file, including
**   extracting data from the font prolog that is needed to
**   read the glyphs, such as /FontMatrix, /Subrs and /lenIV.
***/
errcode InitT1Input(const struct T1Arg *arg,
                    struct T1Handle **t1ref,
                    struct T1Metrics **t1mref,
                    const short (*check)(const char *,
                                         const char *,
                                         const char *))
{
   errcode status = SUCCESS;
   struct T1Handle *t1;
   struct PSState *ps;
   Blues *blues;
   boolean hybrid = FALSE;
   struct T1Metrics *t1m = NULL;
   char str[BUFLEN];
   USHORT i;

   /* Allocate the handle. */
   if (((*t1ref)=Malloc((USHORT)sizeof(struct T1Handle)))==NULL ||
       (ps = AllocPSState())==NULL) {
      if ((*t1ref))
         Free((*t1ref));
      SetError(status = NOMEM);
   } else {

      /* Initiate the T1 record. */
      t1 = (*t1ref);
      t1m = &t1->t1m;
      (*t1mref) = t1m;
      blues = GetBlues(t1m);
      memset(t1, '\0', sizeof(*t1));
      t1->ps = ps;
      t1->leniv = 4;
      t1m->upem = arg->upem;
      t1m->defstdhw = 70;
      t1m->defstdvw = 80;

      blues->blueScale = 39;   /* Should really be 39.625 */
      blues->blueFuzz = 1;
      blues->blueShift = 7 * F8D8;
      blues->align.cvt = 3;
      t1m->stems.storage = 15;

      /* Initiate font file reader. */
      if ((status=FRInit(arg->name, pfb_file, &t1->ff))==SUCCESS) {

         /* Read /FontMatrix and /Subrs. */
         while (status==SUCCESS) {
            if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
               SetError(status=BADINPUTFILE);

               /**** /ForceBold true def ****/
            } else if (!strcmp(str, PS_FORCEBOLD)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  if (!strcmp(str, "true") || !strcmp(str, "True"))
                     t1m->forcebold = TRUE;
                  else
                     t1m->forcebold = FALSE;
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /BlueFuzz 1 def ****/
            } else if (!strcmp(str, PS_BLUEFUZZ)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  blues->blueFuzz = (UBYTE)atoi(str);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /BlueScale 0.043625 def ****/
            } else if (!strcmp(str, PS_BLUESCALE)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  str[5] = '\0';
                  blues->blueScale = (UBYTE)atoi(&str[2]);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /BlueShift 7 def ****/
            } else if (!strcmp(str, PS_BLUESHIFT)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  blues->blueShift = (short)StrToFix(str, NULL, (long)F8D8);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /Encoding StandardEncodind def ****/
            } else if (!strcmp(str, PS_ENCODING)) {
               status = ReadEncodingArray(t1, str, BUFLEN);

               /**** /StdVW [118] def ****/
            } else if (!strcmp(str, PS_STDVW)) {
               USHORT dummy;
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stdvw, ONE, &dummy);


               /**** /StdHW [118] def ****/
            } else if (!strcmp(str, PS_STDHW)) {
               USHORT dummy;
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stdhw, ONE, &dummy);

               /**** /StemSnapV [118 120] def ****/
            } else if (!strcmp(str, PS_SNAPV)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stemsnapv[0],
                                  MAXSNAP, &t1m->snapv_cnt);

               /* Add space for the snap enties in the CV table. */
               if (status==SUCCESS)
                  blues->align.cvt = (USHORT)(blues->align.cvt +
                                             t1m->snapv_cnt);

               /**** /StemSnapH [118 120] def ****/
            } else if (!strcmp(str, PS_SNAPH)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stemsnaph[0],
                                  MAXSNAP, &t1m->snaph_cnt);

               /* Add space for the snap enties in the CV table. */
               if (status==SUCCESS)
                  blues->align.cvt = (USHORT)(blues->align.cvt +
                                              t1m->snaph_cnt);

               /**** /BlueValues [-15 0] def ****/
            } else if (!strcmp(str, PS_BLUEVALUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->bluevalues[0]),
                                  MAXBLUE, &(blues->blue_cnt));
               if (blues->blue_cnt%2)
                  SetError(status = BADINPUTFILE);

               /**** /OtherBlues [-15 0] def ****/
            } else if (!strcmp(str, PS_OTHERBLUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->otherblues[0]),
                                  MAXBLUE, &(blues->oblue_cnt));
               if (blues->oblue_cnt%2)
                  SetError(status = BADINPUTFILE);

               /**** /FamilyBlues [-15 0] def ****/
            } else if (!strcmp(str, PS_FAMILYBLUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->familyblues[0]),
                                  MAXBLUE, &(blues->fblue_cnt));

               /**** /FamilyOtherBlues [-15 0] def ****/
            } else if (!strcmp(str, PS_FAMILYOTHERBLUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->familyotherblues[0]),
                                  MAXBLUE, &(blues->foblue_cnt));

               /**** /CharString ... */
            } else if (!strcmp(str, PS_CHARSTRINGS)) {
               break;

               /**** /FontMatrix [0 0.001 0 0.001 0] def ****/
            } else if (GetFontMatrix(t1m)==NULL &&
                       !strcmp(str, PS_FONTMATRIX)) {
               status = ReadFontMatrix(t1, str, BUFLEN);
            } else if (!strcmp(str, PS_SUBRS)) {
               /* Discard prior lores /Subrs. */
               FlushWorkspace(t1);

               /* Read new subrs. */
               status = ReadFontSubrs(t1,str, BUFLEN);

               /**** /lenIV 4 def ****/
            } else if (!strcmp(str, PS_LENIV)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  t1->leniv = (USHORT)atoi(str);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }
            } else if (t1m->date==NULL && !strcmp(str, PS_DATE)) {
               if ((GetNewLine(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->date=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->copyright==NULL &&
                       !strcmp(str, PS_COPYRIGHT)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->copyright=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->name==NULL && !strcmp(str, PS_NAME)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->name=Strdup(&str[1]))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->id==NULL && !strcmp(str, PS_ID)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->id=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->version.ver==0 && !strcmp(str, PS_VERSION)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else {
                  t1m->version.ver = (USHORT)atoi(str);
                  if (strchr(str, '.'))
                     t1m->version.rev = (USHORT)atoi(strchr(str, '.')+1);
                  else
                     t1m->version.rev = 0;
               }
            } else if (t1m->notice==NULL && !strcmp(str, PS_NOTICE)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->notice=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->fullname==NULL && !strcmp(str, PS_FULLNAME)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->fullname=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->family==NULL && !strcmp(str, PS_FAMILY)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->family=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->weight==NULL && !strcmp(str, PS_WEIGHT)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->weight=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->angle==0 && !strcmp(str, PS_ANGLE)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else 
                  t1m->angle = StrToFix(str, NULL, F16D16BASE);
            } else if (t1m->underline==0 && !strcmp(str, PS_UNDERLINE)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else
                  t1m->underline = (funit)StrToFix(str, NULL, 1L);
            } else if (t1m->uthick==0 && !strcmp(str, PS_UTHICK)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else
                  t1m->uthick = (funit)StrToFix(str, NULL, 1L);
            } else if (!strcmp(str, PS_ISFIXED)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else
                  if (!strcmp(str, "true") ||
                      !strcmp(str, "True") ||
                      !strcmp(str, "TRUE"))
                     t1m->fixedPitch = TRUE;
            } else if (!strcmp(str, PS_HYBRID)) {
               hybrid = TRUE;
            }
         }

         /* Change the baseline zone into an OtherBlues[] zone. */
         if (blues->blue_cnt) {
            blues->otherblues[blues->oblue_cnt++] = blues->bluevalues[0];
            blues->otherblues[blues->oblue_cnt++] = blues->bluevalues[1];
            for (i=2; i<blues->blue_cnt; i++)
               blues->bluevalues[i-2] = blues->bluevalues[i];
            blues->blue_cnt -= 2;
         }
         if (blues->fblue_cnt) {
            blues->familyotherblues[blues->foblue_cnt++]
                  = blues->familyblues[0];
            blues->familyotherblues[blues->foblue_cnt++]
                  = blues->familyblues[1];
            for (i=2; i<blues->fblue_cnt; i++)
               blues->familyblues[i-2] = blues->familyblues[i];
            blues->fblue_cnt -= 2;
         }

         /* Allocate the space for the blue buckets. */
         for (i=0; i<blues->blue_cnt; i+=2) {
            USHORT size = (USHORT)((ABS(blues->bluevalues[i+1] -
                                        blues->bluevalues[i]) +
                                    1 + 2*blues->blueFuzz)*
                                   (USHORT)sizeof(struct CVTPos));
            if ((blues->align.top[i/2].pos = Malloc(size))==NULL) {
               SetError(status = NOMEM);
               break;
            }

            /* Make sure that first value is larger than second value. */
            if (blues->bluevalues[i] > blues->bluevalues[i+1]) {
               LogError(MSG_WARNING, MSG_INVBLUES, NULL);
               SWAPINT(blues->bluevalues[i], blues->bluevalues[i+1]);
            }
         }
         for (i=0; i<blues->oblue_cnt; i+=2) {
            USHORT size = (USHORT)((ABS(blues->otherblues[i+1] -
                                        blues->otherblues[i]) +
                                    1 + 2*blues->blueFuzz)*
                                   (USHORT)sizeof(struct CVTPos));
            if ((blues->align.bottom[i/2].pos = Malloc(size))==NULL) {
               SetError(status = NOMEM);
               break;
            }

            /* Make sure that first value is larger than second value. */
            if (blues->otherblues[i] > blues->otherblues[i+1]) {
               LogError(MSG_WARNING, MSG_INVBLUES, NULL);
               SWAPINT(blues->otherblues[i], blues->otherblues[i+1]);
            }
         }


         /* Advance to the first glyph. */
         if (status==SUCCESS) {
            while (Get_Token(t1->ff, str, BUFLEN) &&
                   strcmp(str, PS_BEGIN));

            if (strcmp(str, PS_BEGIN)) {
               SetError(status = BADT1HEADER);
            }

            /* Skip lores chars if hybrid font. */
            if (status==SUCCESS && hybrid) {
               USHORT count;

               /* Skip Charstring dictionary. */
               do {
                  /* Glyph name, or end. */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }
                  if (!strcmp(str, PS_END))
                     break;

                  /* Charstring length. */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }
                  count = (USHORT)(atoi(str)+1);

                  /* Delimiter. */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }

                  /* Charstring */
                  for (i=0; i<count; i++)
                     (void)GetByte(t1->ff);

                  /* Delimiter */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }
               } while (status==SUCCESS);

               /* Skip to the beginning of next charstring. */
               while (Get_Token(t1->ff, str, BUFLEN) &&
                      strcmp(str, PS_BEGIN));

               if (strcmp(str, PS_BEGIN)) {
                  SetError(status = BADT1HYBRID);
               }
            }
         }
      }
   }

   if ((status==SUCCESS) && t1m && check(t1m->name,
                                         t1m->copyright,
                                         t1m->notice)!=SUCCESS)
      status = NOCOPYRIGHT;

   return status;
}



/***
** Function: GetT1Glyph
**
** Description:
**   The current file position of the T1 font file must be
**   at the begining of an entry in the /CharStrings dictionary.
**   The function will decode the font commands, parse them, and
**   finally build a representation of the glyph.
***/
errcode GetT1Glyph(struct T1Handle *t1,
                   struct T1Glyph *glyph,
                   const struct GlyphFilter *filter)
{
   errcode status = SUCCESS;
   /* struct encoding *enc; */
   char  str[BUFLEN];
   UBYTE *code;
   USHORT len;
   USHORT i;
   USHORT r = 4330;   
   short b;

   /* Get glyph name or end. */
   if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
      SetError(status = BADINPUTFILE);
   } else if (!strcmp(str, PS_END)) {
      status = DONE;
   } else if (str[0]!='/') {
      SetError(status = BADCHARSTRING);
   } else {
      if ((glyph->name = Strdup(&str[1]))==NULL) {
         SetError(status = NOMEM);
      } else {

         /* Get length of charstring. */
         (void)Get_Token(t1->ff, str, BUFLEN);
         len = (USHORT)atoi(str);

         /* Get RD + space */
         (void)Get_Token(t1->ff, str, BUFLEN);
         (void)GetByte(t1->ff);

         /* Get commands. */
         if (len<BUFLEN)
            code = (UBYTE *)str;
         else
            if ((code = Malloc(len*sizeof(UBYTE)))==NULL) {
               SetError(status = NOMEM);
            }

         if (code) {
            for (i=0; i<len; i++) {
               b = GetByte(t1->ff);
               code[i] = (UBYTE)Decrypt(&r, (UBYTE)b);
            }

            /* Parse commands. */
            if (status==SUCCESS) {
               if (t1->t1m.encoding!=NULL ||
                   UseGlyph(filter, t1->t1m.seac, glyph->name)) {
                  InitPS(t1->ps);
                  status = ParseCharString(glyph,
                                           &t1->t1m.seac,
                                           t1->ps,
                                           t1->subrs,
                                           &code[t1->leniv],
                                           (USHORT)(len-t1->leniv));

                  /* Skip normal conversion for the ".notdef" glyph. */
                  if (!strcmp(glyph->name, ".notdef"))
                     status = SKIP;

               } else {
                  status = SKIP;

               /***

               Two approaches are implemented for the management of
               composite glyphs:

               1) It is up to the client to specify a GlyphFilter such
               that all 'seac' characters has their dependent base and
               accent character in the filter as well.

               2) The converter manages a list of the dependent characters,
               which are converted when found.

               Approach 2) will typically cause the converter to use more
               memory than what is available in the small memory model,
               which is why the default is to disabled it.

               ***/


#if 0

                  /* Record StandardEncoding glyphs, for 'seac' */
                  if ((enc = LookupPSName(t1->t1m.encoding,
                                          t1->t1m.encSize,
                                          glyph->name)) &&
                      (i = LookupCharCode(enc, ENC_STANDARD))!=0) {
                     if ((t1->stdenc[i].code
                          = Malloc(len-t1->leniv))==NULL) {
                        SetError(status = NOMEM);
                     } else {
                        memcpy(t1->stdenc[i].code,
                               &code[t1->leniv],
                               sizeof(UBYTE) * (len - t1->leniv));
                        t1->stdenc[i].len = len - t1->leniv;
                     }
                  }
#endif
               }

               if (code!=(UBYTE *)str)
                  Free(code);

               /* Get ND */
               (void)Get_Token(t1->ff, str, BUFLEN);
            }
         }
      }
   }


   return status;
}



/***
** Function: FreeT1Glyph
**
** Description:
**   This function frees the memory used to represent
**   a glyph that has been translated.
***/
void FreeT1Glyph(T1Glyph *glyph)
{
   Flex *flex;
   Stem *stem;
   Stem3 *stem3;


   if (glyph->name)
      Free(glyph->name);
   while (glyph->hints.vstems) {
      stem = glyph->hints.vstems->next;
      Free(glyph->hints.vstems);
      glyph->hints.vstems = stem;
   }
   while (glyph->hints.hstems) {
      stem = glyph->hints.hstems->next;
      Free(glyph->hints.hstems);
      glyph->hints.hstems = stem;
   }
   while (glyph->hints.vstems3) {
      stem3 = glyph->hints.vstems3->next;
      Free(glyph->hints.vstems3);
      glyph->hints.vstems3 = stem3;
   }
   while (glyph->hints.hstems3) {
      stem3 = glyph->hints.hstems3->next;
      Free(glyph->hints.hstems3);
      glyph->hints.hstems3 = stem3;
   }
   while (glyph->hints.flex) {
      flex = glyph->hints.flex->next;
      Free(glyph->hints.flex);
      glyph->hints.flex = flex;
   }
   while (glyph->paths) {
      Outline *path = glyph->paths;
      glyph->paths = path->next;
      if (path->count) {
         Free(path->onoff);
         Free(path->pts);
      }
      Free(path);
   }
   memset((void *)glyph, '\0', sizeof(T1Glyph));
}



/***
** Function: GetT1Composite
**
** Description:
**   This function unlinks the first composite glyph
**   from the list of recorded composite glyphs, which
**   is returned to the caller.
***/
struct Composite  *GetT1Composite(struct T1Handle *t1)
{
   struct Composite *comp;

   comp = t1->t1m.seac;
   if (comp) {
      t1->t1m.seac = comp->next;
      comp->next = t1->t1m.used_seac;
      t1->t1m.used_seac = comp;
   }

   return comp;
}



/***
** Function: GetT1BaseGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   base character of a composite character, if that glyph
**   is not already converted.
***/
errcode GetT1BaseGlyph(struct T1Handle *t1,
                       const struct Composite *comp,
                       struct T1Glyph *glyph)
{
   struct encoding *enc;
   struct Subrs *subr;
   errcode status = SUCCESS;

   if ((enc = LookupPSName(t1->t1m.encoding,
                           t1->t1m.encSize,
                           comp->bchar))==NULL) {
       LogError(MSG_WARNING, MSG_BADENC, comp->bchar);
       return SKIP;
   }

   subr = &t1->stdenc[LookupCharCode(enc, ENC_STANDARD)];

   if (subr->len==0) {
      status = SKIP; /* Missing or already done. */
   } else {
      InitPS(t1->ps);
      if ((glyph->name = Strdup((char*)comp->achar))==NULL) {
         SetError(status = NOMEM);
      } else {
         status = ParseCharString(glyph,
                                  &t1->t1m.seac,
                                  t1->ps,
                                  t1->subrs,
                                  subr->code,
                                  subr->len);
      }
      Free(subr->code);
      subr->code = NULL;
      subr->len = 0;
   }
   return status;
}



/***
** Function: GetT1AccentGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   accent character of a composite character, if that glyph
**   is not already converted.
***/
errcode GetT1AccentGlyph(struct T1Handle *t1,
                         const struct Composite *comp,
                         struct T1Glyph *glyph)
{
   struct encoding *enc;
   struct Subrs *subr;
   errcode status = SUCCESS;

   if ((enc = LookupPSName(t1->t1m.encoding,
                           t1->t1m.encSize,
                           comp->achar))==NULL) {
       LogError(MSG_WARNING, MSG_BADENC, comp->achar);
       return SKIP;
   }

   subr = &t1->stdenc[LookupCharCode(enc, ENC_STANDARD)];

   if (subr->len==0) {
      status = SKIP; /* Missing or already done. */
   } else {
      InitPS(t1->ps);
      if ((glyph->name = Strdup((char *)comp->achar))==NULL) {
         SetError(status = NOMEM);
      } else {
         status = ParseCharString(glyph,
                                  &t1->t1m.seac,
                                  t1->ps,
                                  t1->subrs,
                                  subr->code,
                                  subr->len);
      }
      Free(subr->code);
      subr->code = NULL;
      subr->len = 0;
   }
   return status;
}



/***
** Function: ReadOtherMetrics
**
** Description:
**   Return font level information about the T1 font (mostly
**   metrics).
***/
errcode ReadOtherMetrics(struct T1Metrics *t1m,
                         const char *metrics)
{
   errcode status = SUCCESS;

   if ((status = ReadFontMetrics(metrics, t1m))==NOMETRICS) {
      t1m->flags = DEFAULTMETRICS;
      status = SUCCESS;
   } else {
      t1m->flags = USEMETRICS;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\t1parser.h ===
/***
**
**   Module: T1Parser
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font file, by parsing
**      the data/commands found in PFB, PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



struct T1Arg;
struct T1Info;
struct T1Glyph;
struct T1Handle;
struct T1Metrics;
struct Composite;
struct GlyphFilter;



/***
** Function: InitT1Input
**
** Description:
**   Allocate and initiate a handle for a T1 font file, including
**   extracting data from the font prolog that is needed to
**   read the glyphs, such as /FontMatrix, /Subrs and /lenIV.
***/
errcode           InitT1Input       _ARGS((IN      struct T1Arg *,
                                           OUT     struct T1Handle **,
                                           OUT     struct T1Metrics **,
                                           IN      short (*cb)(IN char *,
                                                               IN char *,
                                                               IN char *)));
/***
** Function: CleanUpT1
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
errcode           CleanUpT1         _ARGS((INOUT   struct T1Handle *));


/***
** Function: ReadOtherMetrics
**
** Description:
**   Return font level information about the T1 font (mostly
**   metrics).
***/
errcode           ReadOtherMetrics  _ARGS((INOUT   struct T1Metrics *,
                                           IN      char *metrics));

/***
** Function: GetT1Glyph
**
** Description:
**   The current file position of the T1 font file must be
**   at the begining of an entry in the /CharStrings dictionary.
**   The function will decode the font commands, parse them, and
**   finally build a representation of the glyph.
***/
errcode           GetT1Glyph        _ARGS((INOUT   struct T1Handle *,
                                           OUT     struct T1Glyph *,
                                           IN      struct GlyphFilter *));
/***
** Function: FreeT1Glyph
**
** Description:
**   This function frees the memory used to represent
**   a glyph that has been translated.
***/
void              FreeT1Glyph       _ARGS((INOUT   struct T1Glyph *));


/***
** Function: GetT1Composite
**
** Description:
**   This function unlinks the first composite glyph
**   from the list of recorded composite glyphs, which
**   is returned to the caller.
***/
struct Composite  *GetT1Composite   _ARGS((INOUT   struct T1Handle *));


/***
** Function: GetT1AccentGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   accent character of a composite character, if that glyph
**   is not already converted.
***/
errcode           GetT1AccentGlyph  _ARGS((INOUT   struct T1Handle *,
                                           IN      struct Composite *,
                                           OUT     struct T1Glyph *));
/***
** Function: GetT1BaseGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   base character of a composite character, if that glyph
**   is not already converted.
***/
errcode           GetT1BaseGlyph    _ARGS((INOUT   struct T1Handle *,
                                           IN      struct Composite *,
                                           OUT     struct T1Glyph *));
/***
** Function: FlushWorkspace
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
void              FlushWorkspace    _ARGS((INOUT   struct T1Handle *t1));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\titott.h ===
/***
 **
 **   Module: TItoTT
 **
 **   Description:
 **      This is the internal interface for the Adobe Type 1 to
 **      TrueType font converter.
 **
 **   Author: Michael Jansson
 **   Created: 5/26/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#define MAXERRORS          -14
#define NOCOPYRIGHT        -13
#define ARGSTACK           -12
#define TTSTACK            -11
#define NOMETRICS          -10
#define UNSUPPORTEDFORMAT  -9
#define BADMETRICS         -8
#define BADT1HYBRID        -7
#define BADCHARSTRING      -6
#define BADINPUTFILE       -5
#define BADOUTPUTFILE      -4
#define BADT1HEADER        -3
#define NOMEM              -2
#define FAILURE            -1
#define SUCCESS            0
#define DONE               1
#define SKIP               2

struct GlyphFilter {
   const unsigned short num;
   const char **name;
};

struct T1Arg {
   const char *name;
   const char *metrics;
   const struct GlyphFilter *filter;
   int upem;
};

struct TTArg {
   char *name;
   char *tag;
   short precision;
};

struct callProgress {
   const void (*cb)(short, void *, void *);
   void *arg;
};
   

/***
 ** Function: ConvertT1toTT
 **
 ** Description:
 **   Convert a T1 font into a TT font file.
 ***/
short ConvertT1toTT _ARGS((IN struct TTArg *ttArg,
                           IN struct T1Arg *t1Arg,
                           IN short (*check)(IN char *facename,
                                             IN char *copyright,
                                             IN char *notice),
                           INOUT struct callProgress *cp));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\trans.c ===
/***
**
**   Module: Trans
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      contains functions that will convert T1 specific data into
**      corresponding TT data, such as hints and font metrics.
**
**   Author: Michael Jansson
**
**   Created: 5/28/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "trig.h"
#include "metrics.h"
#include "encoding.h"
#include "builder.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "trans.h"
#include "hints.h"


/***** CONSTANTS */

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

#define SWISS_LEADING       0x21
#define ROMAN_LEADING       0x11

#define NOCARE_PANOSE   0
#define NO_PANOSE       1
#define COVE_PANOSE     2
#define TEXT_PANOSE     2
#define DECORATIVE_PANOSE 4
#define SCRIPT_PANOSE   3
#define SANS_PANOSE     11
#define FIXED_PANOSE    9



#define BUFMARG      64
#define CLIMIT    8
#define CLIMIT2      4

#define SUBDIVIDE 0
#define CONVERT      1

#define FW_THIN         100
#define FW_EXTRALIGHT   200
#define FW_LIGHT  300
#define FW_NORMAL 400
#define FW_MEDIUM 500
#define FW_SEMIBOLD     600
#define FW_BOLD         700
#define FW_BLACK  900

#define FWIDTH_ULTRA_CONDENSED   1
#define FWIDTH_EXTRA_CONDENSED   2
#define FWIDTH_CONDENSED         3
#define FWIDTH_SEMI_CONDENSED    4
#define FWIDTH_NORMAL            5
#define FWIDTH_SEMI_EXPANDED     6
#define FWIDTH_EXPANDED          7
#define FWIDTH_EXTRA_EXPANDED    8
#define FWIDTH_ULTRA_EXPANDED    9

#define MAC_ITALIC   0x01
#define MAC_BOLD  0x02

#define FS_ITALIC 0x01
#define FS_BOLD      0x20
#define FS_NORMAL 0x40

#define CVTSIZE     5


/***** LOCAL TYPES */
/* None */


/***** MACROS */
#define ATMSCALE(v)  (((v)*31)/32)
#define IP(v,x1,x2,x1p,x2p)   /*lint -e776 */(short)((long)(v-x1)*(long)(x2p-x1p)/(long)(x2-x1)+(long)x1p)/*lint +e776*/

#define ADDCVT(val)   ttm->cvt[ttm->cvt_cnt++] = (short)(val)

#define SGN(v)   ((v)>0 ? 1 : -1)
#define DIR(v,w)  (char)((ABS((v)-(w))<16) ? 0 : SGN((w) - (v)))


/***** PROTOTYPES */
static USHORT SplitSpline(Point *pts, ULONG *onoff,
                          int i, USHORT length,
                          const funit x0, const funit y0,
                          const funit x1, const funit y1, 
                          const funit x2, const funit y2, 
                          const funit x3, const funit y3,
                          const int delta);


/***** STATIC FUNCTIONS */

/***
** Function: LookupComposite
**
** Description:
**   
***/
static struct encoding *LookupComposite(struct Composite *comp, char *name)
{
   while (comp) {
      if (comp->oenc && !strcmp(LookupCharName(comp->oenc), name))
         return comp->oenc;
      comp=comp->next;
   }

   return NULL;
}



/***
** Function: norm
**
** Description:
**   Normalize an angle so that it falls within the
**   range ~[-pi, pi]
***/
static int norm(int a)
{
   if (a>PI)
      a -= 2*PI;
   if (a<-PI)
      a += 2*PI;

   return ABS(a)/16;
}


/***
** Function: CompareCurves
**
** Description:
**   Make a estimate of the error between a cubic
**   and a quadric curve, given four control points,
**   and suggest an action (sub-division or convertion).
***/
static boolean FASTCALL CompareCurves(const funit x0, const funit y0,
                                      const funit x1, const funit y1, 
                                      const funit x2, const funit y2, 
                                      const funit x3, const funit y3,
                                      const funit nx, const funit ny,
                                      const int delta)
{
   int a, b;



   if ((ABS(ny-y0)>CLIMIT || ABS(nx-x0)>CLIMIT) &&
       (ABS(ny-y3)>CLIMIT || ABS(nx-x3)>CLIMIT)) {

      if (y0!=y1 || x0!=x1)
         a = norm(Atan2(ny-y0, nx-x0) - Atan2(y1-y0, x1-x0))
             * (ABS(ny-y0) + ABS(nx-x0));
      else if (y0!=y2 || x2!=x0)
         a = norm(Atan2(ny-y0, nx-x0) - Atan2(y2-y0, x2-x0))
             * (ABS(ny-y0) + ABS(nx-x0));
      else
         a = 0;

      if (a>=delta)
         return SUBDIVIDE;



      if (y2!=y3 || x2!=x3)
         b = norm(Atan2(y3-ny, x3-nx) - Atan2(y3-y2, x3-x2))
             * (ABS(ny-y0) + ABS(nx-x0));
      else if (y1!=y3 || x1!=x3)
         b = norm(Atan2(y3-ny, x3-nx) - Atan2(y3-y1, x3-x1))
             * (ABS(ny-y0) + ABS(nx-x0));
      else
         b = 0;


      if (b>=delta)    /* angle too big. */
         return SUBDIVIDE;
   }

   return CONVERT;
}



/***
** Function: ConvertSpline
**
** Description:
**   This function adds a spline to the current contour, by first
**   converting it from a cubic to a quadric spline.
***/
static USHORT ConvertSpline(Point *pts, ULONG *onoff,
                            USHORT length, int i,
                            const funit x0, const funit y0,
                            const funit x1, const funit y1, 
                            const funit x2, const funit y2, 
                            const funit x3, const funit y3,
                            const int delta)
{
   funit nx, ny;
   int oi = i;
   USHORT n = 0;

   ny = (funit)(((-y0+y1+y2+((y1+y2)<<1)-y3 + 4002)/4) - (short)1000);
   nx = (funit)(((-x0+x1+x2+((x1+x2)<<1)-x3 + 4002)/4) - (short)1000);
   if (CompareCurves(x0, y0,
                     x1, y1,
                     x2, y2,
                     x3, y3,
                     nx, ny, delta)==SUBDIVIDE) {
      n = SplitSpline(pts, onoff, i, length,
                      x0, y0, x1, y1, x2, y2, x3, y3, delta);
   } else /* CONVERT */ {
      if (i>1 && !OnCurve(onoff, i-2) &&
          (short)(pts[i-1].x >= pts[i-2].x) != (short)(pts[i-1].x >= nx) &&
          (short)(pts[i-1].y >= pts[i-2].y) != (short)(pts[i-1].y >= ny) &&
          (short)(pts[i-1].x >  pts[i-2].x) != (short)(pts[i-1].x > nx) &&
          (short)(pts[i-1].y >  pts[i-2].y) != (short)(pts[i-1].y > ny) &&
          ABS(pts[i-1].x - (nx+pts[i-2].x)/2)<CLIMIT2 && 
          ABS(pts[i-1].y - (ny+pts[i-2].y)/2)<CLIMIT2) {
      }
      SetOffPoint(onoff, i);
      pts[i].y = ny;
      pts[i].x = nx;
      i++;
      SetOnPoint(onoff, i);
      pts[i].y = y3;
      pts[i].x = x3;
      i++;

      n = (USHORT)(i-oi);
   }

   return n;
}



/***
** Function: SplitSpline
**
** Description:
**   This function converts a cubic spline by first
**   creating two new cubic splines, using de Casteljau's
**   algorithm, and then adding the two new splines to the
**   current path.
***/
static USHORT SplitSpline(Point *pts, ULONG *onoff,
                          int i, USHORT length,
                          const funit x0, const funit y0,
                          const funit x1, const funit y1, 
                          const funit x2, const funit y2, 
                          const funit x3, const funit y3,
                          const int delta)
{
   funit xt, yt;
   funit nx1, ny1;
   funit nx2, ny2;
   funit nx3, ny3;
   funit nx4, ny4;
   funit nx5, ny5;
   USHORT cnt;

   xt = (funit)(((x1+x2+8001)/2)-4000);
   yt = (funit)(((y1+y2+8001)/2)-4000);
   nx1 = (funit)(((x0+x1+8001)/2)-4000);
   ny1 = (funit)(((y0+y1+8001)/2)-4000);
   nx2 = (funit)(((nx1+xt+8001)/2)-4000);
   ny2 = (funit)(((ny1+yt+8001)/2)-4000);
   nx5 = (funit)(((x2+x3+8001)/2)-4000);
   ny5 = (funit)(((y2+y3+8001)/2)-4000);
   nx4 = (funit)(((nx5+xt+8001)/2)-4000);
   ny4 = (funit)(((ny5+yt+8001)/2)-4000);
   nx3 = (funit)(((nx2+nx4+8001)/2)-4000);
   ny3 = (funit)(((ny2+ny4+8001)/2)-4000);

   cnt = ConvertSpline(pts, onoff, length, i,
                       x0, y0,
                       (funit)nx1, (funit)ny1,
                       (funit)nx2, (funit)ny2,
                       (funit)nx3, (funit)ny3,
                       delta);
   cnt = (USHORT)(cnt + ConvertSpline(pts, onoff, length, i+cnt,
                                      (funit)nx3, (funit)ny3,
                                      (funit)nx4, (funit)ny4,
                                      (funit)nx5, (funit)ny5,
                                      x3, y3,
                                      delta));

   return cnt;
}




/***
** Function: FreeOutline
**
** Description:
**   This function frees the memory allocated for one 
**   contour.
**   
***/
static void FreeOutline(Outline *path)
{
   Outline *tmp;

   while (path) {
      tmp = path;
      path=path->next;
      Free(tmp->pts);
      Free(tmp->onoff);
      Free(tmp);
   }
}



/***
** Function: ConvertOutline
**
** Description:
**   This function converts an outline by replacing the
**   cubic splines with quadric splines, and by scaling the
**   coordinates to the desired em-height.
**   
***/
static errcode ConvertOutline(const struct T1Metrics *t1m,
                              Outline *src, Outline **dst,
                              const int delta,
                              short *sideboard)
{
   errcode status = SUCCESS;
   f16d16 *fmatrix;
   Outline *path;
   ULONG *onoff = NULL;
   Point *pts = NULL;
   USHORT count;
   USHORT i,j,n;
   USHORT tot = 0;
   USHORT t1tot = 0;


   /* Get the T1 font transformation matrix. */
   fmatrix = GetFontMatrix(t1m);

   while (src) {

      /* Skip paths with less than three points. */
      if (src->count<3) {
         t1tot = (USHORT)(t1tot + src->count);
         src = src->next;
         continue;
      }

      /* Allocate the needed resources */
      count = (USHORT)((src->count+BUFMARG)&~0x0f);
      path = Malloc(sizeof(Outline));
      pts = Malloc(count*sizeof(Point));
      onoff = Malloc(ONOFFSIZE(count));
      if (path==NULL || pts==NULL || onoff==NULL) {
         if (path)
            Free(path);
         if (pts)
            Free(pts);
         if (onoff)
            Free(onoff);
         FreeOutline((*dst));
         (*dst) = NULL;
         SetError(status = NOMEM);
         break;
      }
      memset(onoff, '\0', ONOFFSIZE(count));

      /* Convert the splines. */ /*lint -e771 */
      i=0;
      j=0;
      while (i<src->count) {
         char prev = DIR(src->pts[(i-2+src->count)%src->count].y,
                         src->pts[(i-1+src->count)%src->count].y);
         char this = DIR(src->pts[(i-1+src->count)%src->count].y,
                         src->pts[i].y);

         /* Double the local extremas so that diag-cntrl will work. */
         if (prev && this && prev!=this)
            pts[j++] = src->pts[(i-1+src->count)%src->count];

         if (OnCurve(src->onoff, i)) {
            pts[j++] = src->pts[i++];
         } else {
            /* pts[j] = pts[j-1]; j++; */
            n = ConvertSpline(pts, onoff, count, (int)j,
                              src->pts[i-1].x, src->pts[i-1].y,
                              src->pts[i-0].x, src->pts[i-0].y,
                              src->pts[i+1].x, src->pts[i+1].y,
                              src->pts[i+2].x, src->pts[i+2].y,
                              delta);

            /* Enforce horizontal and vertical tangents. */
            if (OnCurve(onoff, j-1)) {
               if (src->pts[i-1].x==src->pts[i-0].x)
                  pts[j].x = (funit)((pts[j].x + pts[j-1].x)/2);
               if (src->pts[i-1].y==src->pts[i-0].y)
                  pts[j].y = (funit)((pts[j].y + pts[j-1].y)/2);
            }
            if (src->pts[i+1].x==src->pts[i+2].x)
               pts[j+n-2].x = (funit)((pts[j+n-1].x + pts[j+n-2].x)/2);
            if (src->pts[i+1].y==src->pts[i+2].y)
               pts[j+n-2].y = (funit)((pts[j+n-2].y + pts[j+n-1].y)/2);

            j = (USHORT)(j + n);
            i += 3;
         }

         /* Both a line and a curve end with an on-curve point. */
         sideboard[t1tot+i-1] = (short)(j-1+tot);

         /* Extend the pts/onoff arrays. */
         if (j+BUFMARG/2>=count) {
            Point *newpts = NULL;
            ULONG *newonoff = NULL;

            count += BUFMARG;
            newpts = Realloc(pts, count*sizeof(Point));
            newonoff = Realloc(onoff, ONOFFSIZE(count));
            if (newpts==NULL || newonoff==NULL) {
               if (newonoff)
                  Free(newonoff);
               if (newpts)
                  Free(newpts);
               /*lint -e644 */
               if (onoff)
                  Free(onoff);
               if (pts)
                  Free(pts);
               /*lint +e644 */
               FreeOutline((*dst));
               (*dst) = NULL;
               SetError(status=NOMEM);
               break;
            }
            pts = newpts;
            onoff = newonoff;
         }
      }

      if (status!=SUCCESS)
         break;

      /* Scale the points. */
      TransAllPoints(t1m, pts, j, fmatrix);

      t1tot = (USHORT)(t1tot + src->count);
      src = src->next;

      (*dst) = path;
      path->next = NULL;
      path->pts = pts;
      path->onoff = onoff;
      path->count = (USHORT)j;  /*lint +e771 */
      dst = &(path->next);

      tot = (USHORT)(tot + j);
   }

   return status;
}

#ifdef MSDOS
#pragma auto_inline(off)
#endif
static long Mul2(long a, long b, long c, long d)
{
   return a*b+c*d;
}
#ifdef MSDOS
#pragma auto_inline(on)
#endif


/***** FUNCTIONS */

/***
** Function: TransAllPoints
**
** Description:
**   Translate a coordinate according to a transformation matrix.
***/
void FASTCALL TransAllPoints(const struct T1Metrics *t1m,
                             Point *pts,
                             const USHORT cnt,
                             const f16d16 *fmatrix)
{
   if (fmatrix==NULL) {
      register Point *p;
      register int i;

      i = cnt;
      p = pts;
      while (i--) {
         p->x = (funit)((p->x<<1)+(((p->x<<1)+
                                    p->x+(p->x/16)+
                                    8224)/64) - 128);
         p++;
      }
      i = cnt;
      p = pts;
      while (i--) {
         p->y = (funit)((p->y<<1)+(((p->y<<1)+
                                    p->y+
                                    (p->y/16)+
                                    8224)/64) - 128);
         p++;
      }

   } else {
      Point *p;
      int i;
      long u,v;

      i = cnt;
      p = pts;
      while (i--) {
         v = (GetUPEM(t1m) * (Mul2(fmatrix[0], (long)p->x,
                                   fmatrix[2], (long)p->y) +
                              fmatrix[4]) + F16D16HALF) / 524288L;
         u = (GetUPEM(t1m) * (Mul2(fmatrix[1], (long)p->x,
                                   fmatrix[3], (long)p->y) +
                              fmatrix[5]) + F16D16HALF) / 524288L;
         p->x = (funit)v;
         p->y = (funit)u;
         p++;
      }
   }
}



/***
** Function: TransX
**
** Description:
**   Translate a horizontal coordinate according to a transformation matrix.
***/
funit FASTCALL TransX(const struct T1Metrics *t1m, const funit x)
{
   f16d16 *fmatrix = GetFontMatrix(t1m);
   funit pos;

   if (fmatrix) {
      pos = (funit)((GetUPEM(t1m)* ATMSCALE(fmatrix[0] * x) +
                     F16D16HALF) / F16D16BASE);
   } else {
      pos = (funit)(((int)x<<1)-((((int)x+((int)x/64)+8224)/64) - 128));
   }

   return pos;
}


/***
** Function: TransY
**
** Description:
**   Translate a vertical coordinate according to a transformation matrix.
***/
funit FASTCALL TransY(const struct T1Metrics *t1m, const funit y)
{
   f16d16 *fmatrix = GetFontMatrix(t1m);
   funit pos;

   if (fmatrix) {
      pos = (funit)((GetUPEM(t1m)*fmatrix[3] * y +
                     F16D16HALF) / F16D16BASE);
   } else {
      pos = (funit)(((int)y<<1)+((((int)y<<1)+
                                  (int)y+
                                  ((int)y/16)+
                                  8224)/64) - 128);
   }

   return pos;
}


/***
** Function: ConvertGlyph
**
** Description:
**   This function convertes the data associated to a T1 font glyph
**   into the corresponding data used in a TT font glyph.
***/
errcode FASTCALL ConvertGlyph(struct T1Metrics *t1m,
                              const struct T1Glyph *t1glyph,
                              struct TTGlyph **ttglyph,
                              const int delta)
{
   errcode status = SUCCESS;
   struct encoding *code;

   if ((code = LookupPSName(CurrentEncoding(t1m),
                            EncodingSize(t1m),
                            t1glyph->name))==NULL &&
       (code = LookupComposite(Composites(t1m), t1glyph->name))==NULL &&
       strcmp(t1glyph->name, ".notdef")) {
      LogError(MSG_INFO, MSG_BADENC, t1glyph->name);
      status = SUCCESS;
   } else {

      if (((*ttglyph) = Malloc(sizeof(struct TTGlyph)))==NULL) {
         SetError(status = NOMEM);
      } else {
         short *sideboard = NULL;
         Outline *path;
         USHORT tot;

         memset((*ttglyph), '\0', sizeof(struct TTGlyph));
         if (t1glyph->width.y!=0) {
            LogError(MSG_WARNING, MSG_BADAW, NULL);
         }
         (*ttglyph)->aw = TransY(t1m, t1glyph->width.x);
         (*ttglyph)->lsb = TransY(t1m, t1glyph->lsb.x);
         (*ttglyph)->code = code;
         (*ttglyph)->num = 0;
         (*ttglyph)->twilights = 0;

         /* Initiate the side board. */
         for (path=t1glyph->paths, tot=0; path; path=path->next)
            tot = (USHORT)(tot + path->count);
         if (tot && (sideboard = Malloc((unsigned)tot*sizeof(short)))==NULL) {
            SetError(status=NOMEM);
         } else if ((status = ConvertOutline(t1m, t1glyph->paths,
                                             &((*ttglyph)->paths),
                                             delta,
                                             sideboard))==SUCCESS)
            status = ConvertHints(t1m,
                                  &t1glyph->hints,
                                  t1glyph->paths,
                                  (*ttglyph)->paths,
                                  sideboard,
                                  &(*ttglyph)->hints,
                                  &(*ttglyph)->num,
                                  &(*ttglyph)->stack,
                                  &(*ttglyph)->twilights);

         if (sideboard)
            Free(sideboard);


         /* Pick default std widths. */
         if (t1glyph->name[0]=='l' && t1glyph->name[1]=='\0') {
            if (GetStdVW(t1m)==0 && t1glyph->hints.vstems)
               SetDefStdVW(t1m, t1glyph->hints.vstems->width);
         }
         if (t1glyph->name[0]=='z' && t1glyph->name[1]=='\0') {
            if (GetStdHW(t1m)==0) {
               if (t1glyph->hints.hstems && t1glyph->hints.hstems->width)
                  SetDefStdHW(t1m, t1glyph->hints.hstems->width);
               else if (t1glyph->hints.vstems && t1glyph->hints.vstems->width)
                  SetDefStdHW(t1m, t1glyph->hints.vstems->width);
            }
         }
      }
   } 

   return status;
}


/***
** Function: ConvertComposite
**
** Description:
**   This function convertes the data associated to a T1 font seac glyph
**   into the corresponding data used in a TT font composite glyph.
**
***/
errcode FASTCALL ConvertComposite(struct T1Metrics *t1m,
                                  const struct Composite *comp,
                                  struct TTComposite *ttcomp)
{
   Point pt;

   pt.x = comp->adx;
   pt.y = comp->ady;
   TransAllPoints(t1m, &pt, 1, GetFontMatrix(t1m));
   ttcomp->dx = pt.x + (pt.x - TransX(t1m, comp->adx));
   ttcomp->dy = pt.y;
   ttcomp->aw = TransY(t1m, comp->aw);
   ttcomp->lsb = TransY(t1m, comp->asbx);
   ttcomp->aenc = LookupPSName(CurrentEncoding(t1m),
                               EncodingSize(t1m), comp->achar);
   ttcomp->benc = LookupPSName(CurrentEncoding(t1m),
                               EncodingSize(t1m), comp->bchar);
   if ((ttcomp->cenc = LookupPSName(CurrentEncoding(t1m),
                                    EncodingSize(t1m), comp->cchar))==NULL) {
      LogError(MSG_INFO, MSG_BADENC, comp->cchar);
   }
   ttcomp->oenc = comp->oenc;

   if (ttcomp->aenc && ttcomp->benc)
      return SUCCESS;
   return SKIP;
}





/***
** Function: ConvertMetrics
**
** Description:
**
***/
errcode FASTCALL ConvertMetrics(const struct TTHandle *tt,
                                struct T1Metrics *t1m,
                                struct TTMetrics *ttm,
                                const char *tag)
{
   const AlignmentControl *align;
   const Blues *blues;
   USHORT prep_size;
   UBYTE *prep = NULL;
   errcode status = SUCCESS;
   Point bbox[2];
   funit em;
   funit PostAsc;
   USHORT i, j;


   ttm->Encoding = CurrentEncoding(t1m);
   ttm->encSize = EncodingSize(t1m);
   ttm->version.ver = t1m->version.ver;
   ttm->version.rev = t1m->version.rev;

   if ((ttm->verstr = Malloc(strlen(tag)+4+1+4+1))==NULL) {
      SetError(status = NOMEM);
   } else {
      strcpy(ttm->verstr, tag);
      (void)_itoa((int)ttm->version.ver, &ttm->verstr[strlen(ttm->verstr)], 4);
      strcat(ttm->verstr, ".");
      (void)_itoa((int)ttm->version.rev, &ttm->verstr[strlen(ttm->verstr)], 4);
      ttm->created.a = 0;
      ttm->created.b = 0;
      ttm->family = t1m->family;
      ttm->copyright = t1m->copyright;
      ttm->name = t1m->name;
      ttm->id = t1m->id;
      ttm->notice = t1m->notice;
      ttm->fullname = t1m->fullname;
      ttm->weight = t1m->weight;
      ttm->angle = t1m->angle;
      ttm->underline = TransY(t1m, t1m->underline);
      ttm->uthick = TransY(t1m, t1m->uthick);
      ttm->usWidthClass = (USHORT)(strstr(t1m->fullname, "Ultra-condensed")
                                   ? FWIDTH_ULTRA_CONDENSED :
         ((strstr(t1m->fullname, "Extra-condensed") ? FWIDTH_EXTRA_CONDENSED :
            ((strstr(t1m->fullname, "Condensed") ? FWIDTH_CONDENSED :
               ((strstr(t1m->fullname, "Semi-condensed") ? FWIDTH_SEMI_CONDENSED :
                  ((strstr(t1m->fullname, "Semi-expanded")
                    ? FWIDTH_SEMI_EXPANDED :
                     ((strstr(t1m->fullname, "Expanded")
                       ? FWIDTH_EXPANDED :
                        ((strstr(t1m->fullname, "Extra-expanded")
                          ? FWIDTH_EXTRA_EXPANDED :
                           ((strstr(t1m->fullname, "Ultra-expanded")
                             ? FWIDTH_ULTRA_EXPANDED :
                              FWIDTH_NORMAL)))))))))))))));


      /* Window based metrics. */

      // ps driver does not compute asc and desc based on the
      // windows charset. So, we will not do it either. We will
      // also use the all glyhs supported in the font.
      // Ps driver acutally trusts the values found in .pfm file.
      // These values, according to afm->pfm converter code, are computed
      // over all glyphs. However, some vendors ship buggy pfm's with
      // zero ascenders or negative descenders. If we took these values
      // literally, as ps driver does, the true type driver would
      // shave off portions of glyphs and the conversion would appear broken.
      // Pcl printing and screen output would be totally broken.
      // Turns out that for these buggy fonts ATM on win31 also
      // corrects the value from .pfm files for screen and pcl printer.
      // [bodind]


      // total bbox: [bodind], replaced WindowsBBox function:

      GlobalBBox(tt, bbox);

      ttm->winAscender = ABS(bbox[1].y);
      ttm->winDescender = ABS(bbox[0].y);


      ttm->panose[0] = NOCARE_PANOSE;
      ttm->panose[1] = NOCARE_PANOSE;
      ttm->panose[2] = NOCARE_PANOSE;
      ttm->panose[3] = NOCARE_PANOSE;
      ttm->panose[4] = NOCARE_PANOSE;
      ttm->panose[5] = NOCARE_PANOSE;
      ttm->panose[6] = NOCARE_PANOSE;
      ttm->panose[6] = NOCARE_PANOSE;
      ttm->panose[7] = NOCARE_PANOSE;
      ttm->panose[8] = NOCARE_PANOSE;
      ttm->panose[9] = NOCARE_PANOSE;
      /* Fixed pitch fonts are not given a panose by ATM. */
      if (!(t1m->fixedPitch)) {
         switch (t1m->pitchfam & 0xf0) {
            case FF_DECORATIVE:
               ttm->panose[0] = (UBYTE)DECORATIVE_PANOSE;
               ttm->panose[1] = (UBYTE)NO_PANOSE;
               break;
            case FF_ROMAN:
               ttm->panose[0] = (UBYTE)TEXT_PANOSE;
               ttm->panose[1] = (UBYTE)COVE_PANOSE;
               break;
            case FF_SWISS:
               ttm->panose[0] = (UBYTE)TEXT_PANOSE;
               ttm->panose[1] = (UBYTE)SANS_PANOSE;
               break;
            case FF_SCRIPT:
               ttm->panose[0] = (UBYTE)SCRIPT_PANOSE;
               ttm->panose[1] = (UBYTE)SANS_PANOSE;
               break;
            case FF_MODERN:
               ttm->panose[0] = (UBYTE)TEXT_PANOSE;
               ttm->panose[1] = (UBYTE)SANS_PANOSE;
               break;
         }
      } 
      ttm->isFixPitched = t1m->fixedPitch;
      ttm->panose[2] = (UBYTE)((t1m->tmweight - 500) * 12 / 900 + 6);

      /* Mac based metrics. */
      MacBBox(tt, bbox);
      ttm->macLinegap = TransY(t1m, (funit)(t1m->extLeading +
                                            (ttm->winAscender +
                                             ttm->winDescender) -
                                            (bbox[1].y-bbox[0].y)));

      /* Typographical metrics. */
      ttm->emheight = GetUPEM(t1m);
      if (t1m->flags==DEFAULTMETRICS) {
         ttm->usWeightClass = (USHORT)(strstr(t1m->fullname, "Thin") ? FW_THIN :
            ((strstr(t1m->fullname, "light") ? FW_EXTRALIGHT :
               ((strstr(t1m->fullname, "Light") ? FW_LIGHT :
                  ((strstr(t1m->fullname, "Medium") ? FW_MEDIUM :
                     ((strstr(t1m->fullname, "emi-bold") ? FW_SEMIBOLD :
                        ((strstr(t1m->fullname, "Bold") ? FW_BOLD :
                           ((strstr(t1m->fullname, "Black") ? FW_BLACK :
                              FW_NORMAL)))))))))))));
         ttm->macStyle = (USHORT)(((ttm->usWeightClass>FW_MEDIUM)?MAC_BOLD : 0) |
                         ((ttm->angle != 0) ? MAC_ITALIC : 0));
         ttm->fsSelection = (USHORT)(((ttm->angle != 0) ? FS_ITALIC : 0) |
                            ((ttm->usWeightClass > FW_MEDIUM) ? FS_BOLD : 0) |
                            ((ttm->usWeightClass==FW_NORMAL)
                                     ? FS_NORMAL : 0));
         ttm->typAscender = TypographicalAscender(tt);
         ttm->typDescender = TypographicalDescender(tt);
         em = ttm->typAscender - ttm->typDescender;
         ttm->superoff.y = (funit)(em / 2);
         ttm->superoff.x = 0;
         ttm->supersize.y = (funit)(em * 2 / 3);
         ttm->supersize.x = (funit)(em * 3 / 4);
         ttm->suboff.y = (funit)(em / 5);
         ttm->suboff.x = 0;
         ttm->subsize.y = (funit)(em * 2 / 3);
         ttm->subsize.x = (funit)(em * 3 / 4);
         ttm->strikeoff = (funit)(ttm->typAscender / 2);
         ttm->strikesize = (funit)(ttm->typAscender / 10);
      } else {
         ttm->usWeightClass = t1m->tmweight;
         ttm->macStyle = (USHORT)(((t1m->tmweight>FW_MEDIUM)?MAC_BOLD : 0) |
                         ((ttm->angle != 0) ? MAC_ITALIC : 0));
         ttm->fsSelection = (USHORT)(((ttm->angle != 0) ? FS_ITALIC : 0) |
                            ((ttm->usWeightClass > FW_MEDIUM) ? FS_BOLD : 0) |
                            ((ttm->usWeightClass==FW_NORMAL)
                                     ? FS_NORMAL : 0));
         ttm->typAscender = TransY(t1m, (funit)(t1m->ascent -
                                                t1m->intLeading));
         ttm->typDescender = (funit)(-TransY(t1m, t1m->descent)-1);
         ttm->typLinegap = TransY(t1m, (funit)(t1m->intLeading +
                                               t1m->extLeading));
         ttm->superoff.y = ABS(TransY(t1m, t1m->superoff));
         ttm->superoff.x = 0;
         ttm->supersize.y = TransY(t1m, t1m->supersize);
         ttm->supersize.x = (funit)(TransY(t1m, t1m->supersize) * 3 / 4);
         ttm->suboff.y = ABS(TransY(t1m, t1m->suboff));
         ttm->suboff.x = 0;
         ttm->subsize.y = TransY(t1m, t1m->subsize);
         ttm->subsize.x = (funit)(TransY(t1m, t1m->subsize) * 3 / 4);
         ttm->strikeoff = ABS(TransY(t1m, t1m->strikeoff));
         ttm->strikesize = TransY(t1m, t1m->strikesize);

         // Adjust usWinAscent so that internal leading matches up.
         // For fonts that do not have buggy pfm files, this adjustment
         // will do nothing, for those for which intLeading is
         // incorrectly set to zero, taking max means that the tops will not
         // be chopped off in the converted font. ttfd shaves off anything
         // that extends beyond ascender or descender. For fonts with buggy
         // pfm's, tt conversions may have bogus internal leadings, but this
         // is better than having glyph bottoms or tops shaved off. [bodind]

         PostAsc = ttm->emheight + TransY(t1m, t1m->intLeading) - ttm->winDescender;

         if (PostAsc > ttm->winAscender)
            ttm->winAscender  = PostAsc;
      }

      /* Gray-scale threshold. */
      if (GetStdVW(t1m)!=0 || GetDefStdVW(t1m)!=0) {
         ttm->onepix = (USHORT)(1 + GetUPEM(t1m)*3/2 /
                                TransY(t1m, ((GetStdVW(t1m) ?
                                              GetStdVW(t1m) :
                                              GetDefStdVW(t1m)))));
      }

      // needed in producing the correct ifimetrics for tt conversion

      ttm->DefaultChar = t1m->DefaultChar;
      ttm->BreakChar   = t1m->BreakChar;
      ttm->CharSet     = t1m->CharSet;  // essential for correct font mapping

      /* Character widths. */
      if (t1m->flags!=DEFAULTMETRICS) {
         ttm->FirstChar   = t1m->firstChar;
         ttm->LastChar    = t1m->lastChar;
         if ((ttm->widths = Malloc(sizeof(funit)*
                                   (t1m->lastChar-t1m->firstChar+1)))==NULL) {
            SetError(status = NOMEM);
         } else {
            for (i=0; i<=(unsigned)(t1m->lastChar-t1m->firstChar); i++) {
               ttm->widths[i] = TransY(t1m, t1m->widths[i]);
            }
         }
      }

      /* Pair kerning. */
      if (t1m->flags!=DEFAULTMETRICS &&
          t1m->kerns!=NULL) {
         if ((ttm->kerns = Malloc(sizeof(struct kerning)*
                                  t1m->kernsize))==NULL) {
            SetError(status = NOMEM);
         } else {
            for (i=0; i<t1m->kernsize; i++) {
               ttm->kerns[i].left = t1m->kerns[i].left;
               ttm->kerns[i].right = t1m->kerns[i].right;
               ttm->kerns[i].delta = TransY(t1m, t1m->kerns[i].delta);
            }
            ttm->kernsize = t1m->kernsize;
         }
      }

      /* Pre program. */
      if ((prep = GetPrep(PREPSIZE))!=NULL &&
          (prep_size = BuildPreProgram(t1m,
                                       GetWeight(t1m),
                                       GetBlues(t1m),
                                       GetAlignment(t1m),
                                       &prep, PREPSIZE,
                                       &(ttm->maxprepstack)))>0) {

         /* Store the pre-program. */
         UsePrep(ttm, prep, prep_size);
      }

      /* CVT entries. */
      blues = GetBlues(t1m);
      if (status!=NOMEM &&
          (ttm->cvt = Malloc(blues->align.cvt * CVTSIZE)) == NULL) {
         SetError(status = NOMEM);
      } else {
         ADDCVT(0);  /* TMPCVT */
         ADDCVT((GetStdVW(t1m)==0) ?
                TransX(t1m, GetDefStdVW(t1m))/2 :
            TransX(t1m, GetStdVW(t1m))/2);
         ADDCVT((GetStdHW(t1m)==0) ?
                TransY(t1m, GetDefStdHW(t1m))/2 :
            TransY(t1m, GetStdHW(t1m))/2);
         for (i=0; i<t1m->snapv_cnt; i++)
            ADDCVT(TransY(t1m, t1m->stemsnapv[i])/2);
         for (i=0; i<t1m->snaph_cnt; i++)
            ADDCVT(TransY(t1m, t1m->stemsnaph[i])/2);

         /* Align the top zones. */
         align = GetAlignment(t1m);
         for (i=0; i<blues->blue_cnt/2; i++) {
            /* Skip empty zones. */
            if (align->top[i].cnt==0)
               continue;
            
            ttm->cvt[align->top[i].blue_cvt]
                  = (short)TransY(t1m, blues->bluevalues[i*2]);
            ttm->cvt[align->top[i].blue_cvt+1]
                  = (short)TransY(t1m, blues->bluevalues[i*2+1]);
            for (j=0; j<align->top[i].cnt; j++) {
               funit pos;
               int k;

               /* Get the closest family. */
               k = MatchingFamily(blues->bluevalues[i*2],
                                  blues->familyblues,
                                  blues->fblue_cnt);

               /* Compute the position in the zone w.r.t. the family blues. */
               if (blues->bluevalues[i*2] != blues->bluevalues[i*2+1])
                  pos = IP(align->top[i].pos[j].y,
                           blues->bluevalues[i*2],
                           blues->bluevalues[i*2+1],
                           blues->familyblues[k],
                           blues->familyblues[k+1]);
               else
                  pos = blues->familyblues[k];

               ttm->cvt[align->top[i].pos[j].cvt]
                     = (short)TransY(t1m, align->top[i].pos[j].y);
               ttm->cvt[align->top[i].pos[j].cvt+1]
                     = (short)TransY(t1m, pos);
            }
         }

         /* Align the bottom zones. */
         for (i=0; i<blues->oblue_cnt/2; i++) {
            /* Skip empty zones. */
            if (align->bottom[i].cnt==0)
               continue;
            
            ttm->cvt[align->bottom[i].blue_cvt]
                  = (short)TransY(t1m, blues->otherblues[i*2+1]);
            for (j=0; j<align->bottom[i].cnt; j++) {
               funit pos;
               int k;

               /* Get the closest family. */
               k = MatchingFamily(blues->otherblues[i*2],
                                  blues->familyotherblues,
                                  blues->foblue_cnt);

               /* Compute the position in the zone w.r.t. the family blues. */
               if (blues->otherblues[i*2] != blues->otherblues[i*2+1])
                  pos = IP(align->bottom[i].pos[j].y,
                           blues->otherblues[i*2],
                           blues->otherblues[i*2+1],
                           blues->familyotherblues[k],
                           blues->familyotherblues[k+1]);
               else
                  pos = blues->familyotherblues[k];

               ttm->cvt[align->bottom[i].pos[j].cvt]
                     = (short)TransY(t1m, align->bottom[i].pos[j].y);
               ttm->cvt[align->bottom[i].pos[j].cvt+1]
                     = (short)TransY(t1m, pos);
            }
         }

         /* Add the family zones. */
         for (i=0; i<blues->fblue_cnt/2; i++) {
            if (blues->family_cvt[i]!=UNDEF_CVT) {
               ttm->cvt[blues->family_cvt[i]]
                     = (short)TransY(t1m, blues->familyblues[i*2]);
               ttm->cvt[blues->family_cvt[i]+1]
                     = (short)TransY(t1m, blues->familyblues[i*2+1]);
            }
         }

         /* Add the family other zones. */
         for (i=0; i<blues->foblue_cnt/2; i++) {
            if (blues->familyother_cvt[i]!=UNDEF_CVT) {
               ttm->cvt[blues->familyother_cvt[i]]
                     = (short)TransY(t1m, blues->familyotherblues[i*2+1]);
            }
         }

         ttm->cvt_cnt = blues->align.cvt;
         ttm->maxstorage = t1m->stems.storage;

         /* Store the font-program. */
         SetFPGM(ttm, GetFontProg(), GetFontProgSize(), GetNumFuns());
      }
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\trans.h ===
/***
**
**   Module: Trans
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      contains functions that will convert T1 specific data into
**      corresponding TT data, such as hints and font metrics.
**
**   Author: Michael Jansson
**
**   Created: 5/28/93
**
***/



#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif


struct TTMetrics;
struct T1Metrics;
struct TTHandle;
struct T1Glyph;
struct TTGlyph;
struct TTComposite;
struct Composite;


/***
** Function: ConvertComposite
**
** Description:
**   This function convertes the data associated to a T1 font seac glyph
**   into the corresponding data used in a TT font composite glyph.
**
***/
errcode FASTCALL  ConvertComposite  _ARGS((INOUT   struct T1Metrics *,
                                           IN      struct Composite *,
                                           OUT     struct TTComposite *));
/***
** Function: ConvertGlyph
**
** Description:
**   This function convertes the data associated to a T1 font glyph
**   into the corresponding data used in a TT font glyph.
***/
errcode FASTCALL  ConvertGlyph      _ARGS((INOUT   struct T1Metrics *,
                                           IN      struct T1Glyph *,
                                           OUT     struct TTGlyph **,
                                           IN      int));
/***
** Function: ConvertMetrics
**
** Description:
**
***/
errcode FASTCALL  ConvertMetrics    _ARGS((IN      struct TTHandle *,
                                           INOUT   struct T1Metrics *,
                                           OUT     struct TTMetrics *,
                                           IN      char *tag));

/***
** Function: TransX
**
** Description:
**   Translate a horizontal coordinate according to a transformation matrix.
***/
funit FASTCALL    TransX            _ARGS((IN      struct T1Metrics *t1,
                                           IN      funit x));

/***
** Function: TransY
**
** Description:
**   Translate a vertical coordinate according to a transformation matrix.
***/
funit FASTCALL    TransY            _ARGS((IN      struct T1Metrics *t1,
                                           IN      funit y));

/***
** Function: TransAllPoints
**
** Description:
**   Translate a coordinate according to a transformation matrix.
***/
void  FASTCALL    TransAllPoints    _ARGS((IN      struct T1Metrics *t1,
                                           INOUT   Point *pts,
                                           IN      USHORT cnt,
                                           IN      f16d16 *fmatrix));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\titott.c ===
/***
 **
 **   Module: TItoTT
 **
 **   Description:
 **      This is the main module of the Postscript Type I to TrueType
 **      font converter.
 **
 **   Author: Michael Jansson
 **   Created: 5/26/93
 **
 ***/


/***** INCLUDES */
#include <string.h>
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "titott.h"
#include "t1parser.h"
#include "builder.h"
#include "trans.h"


/***** LOCAL TYPES */
/*-none-*/


/***** CONSTANTS */
#define NOTDEFNAME  ".notdef"

static const struct TTGlyph null = {
   NULL,
   0, 0, 0, NULL,
   NULL,
   0, 0
};
static Point mpo3[] = {
   {1150, 10}, {1150, 30}, {1160, 30}, {1170, 20}, {1180, 30}, {1190, 30}, 
   {1190, 10}, {1180, 10}, {1180, 20}, {1170, 10}, {1160, 20}, {1160, 10}
};
static Point mpo2[] = {
   {60, 40}, {60, 1560}, {1160, 1560}, {1160, 40}
};
static Point mpo1[] = {
   {20, 0}, {1200, 0}, {1200, 1600}, {20, 1600}
};
static ULONG onoff[1] = {0L};
static Outline p1 = {
   NULL,
   sizeof(mpo3)/sizeof(mpo3[0]),
   &mpo3[0],
   &onoff[0]
};
static Outline p2 = {
   &p1,
   sizeof(mpo2)/sizeof(mpo2[0]),
   &mpo2[0],
   &onoff[0]
};
static Outline missingPath = {
   &p2,
   sizeof(mpo1)/sizeof(mpo1[0]),
   &mpo1[0],
   &onoff[0]
};

static struct TTGlyph missing = {
   NULL,
   MAXNOTDEFSIZE, 0, 0, NULL,
   &missingPath,
   1500, 0
};


/***** MACROS */
/*-none-*/


/***** GLOBALS */
/*-none-*/


/***** STATIC FUNCTIONS */
/*-none-*/


/**** FUNCTIONS */

/***
 ** Function: ConvertT1toTT
 **
 ** Description:
 **   Convert a T1 font into a TT font file.
 ***/
errcode ConvertT1toTT(const struct TTArg *ttArg,
                      const struct T1Arg *t1Arg,
                      const short (*check)(const char *copyright,
                                           const char *notice,
                                           const char *facename),
                      struct callProgress *cp)
{
   /* Resources */
   struct T1Handle  *t1 = NULL;
   struct TTHandle  *tt = NULL;
   struct T1Metrics *t1m = NULL;

   /* Temporary variables. */
   struct T1Glyph  glyph;
   struct TTGlyph *ttglyph;
   struct Composite *comp;
   struct TTComposite ttcomp;
   struct TTMetrics ttm;
   boolean fStdEncoding;
   boolean done;
   errcode status;

   /* Initiate variables. */
   ttglyph = NULL;
   memset(&glyph, '\0', sizeof(glyph));
   memset(&ttm, '\0', sizeof(ttm));

   /* Inititate input and output */
   if ((status = InitT1Input(t1Arg, &t1, &t1m, check))==SUCCESS &&
       (status = InitTTOutput(ttArg, &tt))==SUCCESS) {
     
      done = FALSE;

      fStdEncoding = (CurrentEncoding(t1m)==NULL);

      /* Create the missing and the null glyph. */
      if ((missing.hints = Malloc(MAXNOTDEFSIZE))==NULL) {
         status = NOMEM;
         done = TRUE;
      } else {
         memset(missing.hints, 0x22, MAXNOTDEFSIZE);
         (void)PutTTGlyph(tt, &missing, fStdEncoding);
         (void)PutTTGlyph(tt, &null, fStdEncoding);
         Free(missing.hints);
      }

      /* Convert the simple glyphs. */
      while(!done) {
         status = GetT1Glyph(t1, &glyph, t1Arg->filter);
         if (status == SUCCESS) {
            if ((status = ConvertGlyph(t1m,
                                       &glyph,
                                       &ttglyph,
                                       (int)ttArg->precision))!=SUCCESS ||
                (status = PutTTGlyph(tt, ttglyph, fStdEncoding))!=SUCCESS) {
               done = TRUE;
            } else {

               FreeTTGlyph(ttglyph);
               ttglyph=NULL;
               if (cp)
                  cp->cb((short)0, &glyph, cp->arg);
            }
         } else if (status<=FAILURE || status==DONE) {
            done = TRUE;
         } else {
            /* Handle the missing glyph ".notdef" */
            if (!strcmp(glyph.name, NOTDEFNAME)) {
               if ((status = ConvertGlyph(t1m,
                                          &glyph,
                                          &ttglyph,
                                          (int)ttArg->precision))!=SUCCESS ||
                   (status = PutTTNotDefGlyph(tt, ttglyph))!=SUCCESS) {
                  done = TRUE;
               } else {
                  FreeTTGlyph(ttglyph);
                  ttglyph=NULL;
                  if (cp)
                     cp->cb((short)0, &glyph, cp->arg);
               }
            }
         }
         FreeT1Glyph(&glyph);
      }
      
      if (status==DONE) {

         /* Convert the composite glyphs. */
         while ((comp = GetT1Composite(t1))!=NULL) {

            /* Check if the base glyph is converted */
            if ((status = GetT1BaseGlyph(t1, comp, &glyph))==SUCCESS) {
               if ((status = ConvertGlyph(t1m,
                                          &glyph,
                                          &ttglyph,
                                          (int)ttArg->precision))!=SUCCESS ||
                   (status = PutTTGlyph(tt, ttglyph, fStdEncoding))!=SUCCESS) {
                  break;
               }
               FreeTTGlyph(ttglyph);
               ttglyph=NULL;
               if (cp)
                  cp->cb((short)0, &glyph, cp->arg);
            } else if (status<=FAILURE)
               break;
            FreeT1Glyph(&glyph);

            /* Check if the base accent is converted */
            if ((status = GetT1AccentGlyph(t1, comp, &glyph))==SUCCESS) {
               if ((status = ConvertGlyph(t1m,
                                          &glyph,
                                          &ttglyph,
                                          (int)ttArg->precision))!=SUCCESS ||
                   (status = PutTTGlyph(tt, ttglyph, fStdEncoding))!=SUCCESS) {
                  break;
               }
               FreeTTGlyph(ttglyph);
               ttglyph=NULL;
               if (cp)
                  cp->cb((short)0, &glyph, cp->arg);
            } else if (status<=FAILURE)
               break;
            FreeT1Glyph(&glyph);


            /* Convert and store accented glyph. */
            if (status>=SUCCESS && 
                ((status = ConvertComposite(t1m, comp, &ttcomp))!=SUCCESS ||
                 (status = PutTTComposite(tt, &ttcomp))!=SUCCESS)) {
               break;
            }
            if (cp)
               cp->cb((short)1, &comp, cp->arg);
         }

         /* Flush out un-used work space. */
         FlushWorkspace(t1);

         /* Convert the metrics. */
         if (status==SUCCESS || status==DONE || status==SKIP) {
            if ((status = ReadOtherMetrics(t1m,
                                           t1Arg->metrics))==SUCCESS &&
                (status = ConvertMetrics(tt, t1m, &ttm,
                                         ttArg->tag))==SUCCESS) {
               if (cp)
                  cp->cb((short)2, NULL, cp->arg);
               status = PutTTOther(tt, &ttm);
            }
         }
      }
   }                               

   /* More progress. */
   if (cp)
      cp->cb((short)3, NULL, cp->arg);

   FreeTTMetrics(&ttm);
   FreeTTGlyph(ttglyph);
   FreeT1Glyph(&glyph);
   if (CleanUpTT(tt, ttArg, status)!=SUCCESS && status==SUCCESS)
      status = BADINPUTFILE;
   if (CleanUpT1(t1)!=SUCCESS && status==SUCCESS)
      status = BADINPUTFILE;

   /* All done! */
   if (cp)
      cp->cb((short)4, NULL, cp->arg);


   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\ttprog.h ===
/**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of Hint module. This modules deals with the 
**      the font program fo the font.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#define HIBYTE(v)	(UBYTE)((USHORT)(v)>>8)
#define LOBYTE(v)	(UBYTE)((USHORT)(v)&0xff)

#define TWILIGHT  0
#define GLYPHZONE 1

#define TMPCVT 0L
#define TMPPNT 0L
#define TMPPNT1 1L

#define STORAGE_DIAG 3

#define ONEPIXEL    64L

#define INFINITY	   (USHORT)SHRT_MAX


#define MAXPTS 10         /* Max num of pts on a stem hint side. */


/* IP bucket - Used for collecting points that should be
interpolated within the zones defined by the stem hints. */
typedef struct Extremas {
   short rp1;
   short rp2;
   short n;
   short pts[MAXPTS];
} Extremas;



enum aligntype  {
   at_side1,
   at_side2,
   at_relative1,
   at_relative2,
   at_centered
};



/***
**
**   Description:
**      This file contains op-codes for a sub-set of the
**      TrueType instruction set.
**
**   Author: Michael Jansson
**
**   Created: 10/14/93
**
***/


/* TrueType sub-op codes. */
#define SUBOP_Y         0x00
#define SUBOP_X         0x01

#define SUBOP_R         0x01

#define SUBOP_MOVE      0x10
#define SUBOP_MINDIST   0x08
#define SUBOP_ROUND     0x04
#define SUBOP_GRAY      0x00

#define SUBOP_mMRGR  SUBOP_MINDIST | SUBOP_ROUND | SUBOP_GRAY
#define SUBOP_MmRGR  SUBOP_MOVE | SUBOP_ROUND | SUBOP_GRAY


/* TrueType op codes. */
enum {        
   op_mps = 0x4c,
   op_spvtl = 0x07,
   op_roll = 0x8a,
   op_gteq = 0x53,
   op_cindex =  0x25,
   op_rtdg = 0x3d,
   op_clear = 0x22,
   op_szp0 = 0x13,
   op_szp1 = 0x14,
   op_szp2 = 0x15,
   op_szps = 0x16,
   op_loopcall = 0x2a,
   op_shz = 0x36,
   op_smd = 0x1a,
   op_rutg = 0x7c,
   op_rdtg = 0x7d,
   op_pop = 0x21,
   op_abs = 0x64,
   op_scvtci = 0x1d,
   op_rs = 0x43,
   op_spvfs = 0x0a,
   op_shp = 0x33,
   op_roff = 0x7a,
   op_md = 0x49,
   op_ssw = 0x1f,
   op_mul = 0x63,
   op_odd = 0x56,
   op_gc = 0x46,
   op_dup = 0x20,
   op_min = 0x8c,
   op_max = 0x8b,
   op_neg = 0x65,
   op_sfvtl = 0x08,
   op_spvtca =  0x06,
   op_swap = 0x23,
   op_mdrp = 0xc0,
   op_mdap = 0x2e,
   op_miap = 0x3e,
   op_mirp = 0xe0,
   op_alignrp = 0x3c,
   op_iup = 0x30,
   op_svcta = 0x00,
   op_sloop = 0x17,
   op_npushb = 0x40,
   op_npushw = 0x41,
   op_mppem = 0x4b,
   op_lt = 0x50,
   op_gt = 0x52,
   op_if = 0x58,
   op_scfs = 0x48,
   op_else = 0x1b,
   op_wcvtf = 0x70,
   op_wcvtp = 0x44,
   op_pushw1 = 0xb8,
   op_pushb1 = 0xb0,
   op_eif = 0x59,
   op_shpix = 0x38,
   op_srp0 = 0x10,
   op_srp1 = 0x11,
   op_srp2 = 0x12,
   op_ip = 0x39,
   op_rcvt = 0x45,
   op_round = 0x68,
   op_rtg = 0x18,
   op_rthg = 0x19,
   op_add = 0x60,
   op_div = 0x62,
   op_scanctrl = 0x85,
   op_ws = 0x42,
   op_sswci = 0x1e,
   op_scantype = 0x8d,
   op_sub = 0x61,
   op_fdef = 0x2c,
   op_endf = 0x2d,
   op_call = 0x2b,
   op_getinfo = 0x88
};



/***
** Function: GetTopPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short	       GetTopPos	    _ARGS((IN	   Blues *blues,
					   INOUT   AlignmentControl *align,
					   IN	   funit pos));
/***
** Function: GetBottomPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short	       GetBottomPos	    _ARGS((IN	   Blues *blues,
					   INOUT   AlignmentControl *align,
					   IN	   funit pos));
/***
** Function: CutInSize
**
** Description:
**   This function computes the cut in size
**   of a stem, given a master width and the
**   width of the stem. This is done with the
**   StdVW==2.0 pixel treshold and the thinn
**   and wide cut in values.
***/
USHORT	       CutInSize	    _ARGS((IN	   funit width,
					   IN	   funit master,
					   IN	   USHORT tresh,
					   IN	   funit upem));

/***
** Function: SnapStemArgs
**
** Description:
**   
***/
USHORT	       SnapStemArgs	    _ARGS((OUT	   short *args,
					   INOUT   USHORT ta,
					   IN	   funit width,
					   IN	   USHORT std_cvt,
					   IN	   USHORT snap_cvt,
					   IN	   USHORT std_ci,
					   IN	   USHORT snap_ci,
					   IN	   USHORT storage));
/***
** Function: StdStemArgs
**
** Description:
**   
***/
USHORT	       StdStemArgs	    _ARGS((OUT	   short *args,
					   INOUT   USHORT ta,
					   IN	   funit width,
					   IN	   USHORT std_cvt,
					   IN	   USHORT std_ci,
					   IN	   USHORT storage));
/***
** Function: CreateStdStems
**
** Description:
**   
***/
USHORT	       CreateStdStems	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   USHORT tp,
					   IN	   short cnt));
/***
** Function: CreateSnapStems
**
** Description:
**   
***/
USHORT	       CreateSnapStems	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   USHORT tp,
					   IN	   short cnt));
/***
** Function: tt_GetFontProg
**
** Description:
**   This function returns the static font
**   font program.
***/
const UBYTE    *tt_GetFontProg	    _ARGS((void));


/***
** Function: tt_GetNumFuns
**
** Description:
**   This function returns the number of functions
**   defined in the static font program.
***/
USHORT	       tt_GetNumFuns	    _ARGS((void));


/***
** Function: tt_GetFontProgSize
**
** Description:
**   This function returns the size of the
**   static font program.
***/
USHORT	       tt_GetFontProgSize   _ARGS((void));


/***
** Function: SetZone
**
** Description:
**   This function initiate an alignment zone
**   by creating an appropriate point in the
**   twilight zone.
***/
USHORT	       SetZone		    _ARGS((INOUT   UBYTE *prep,
					   INOUT   USHORT tp,
					   IN	   short cvt));
/***
** Function: CopyZone
**
** Description:
**   This function copies a cvt entry, representing an
**   alignment zone, to the cvt used for a particular hstem.
***/
USHORT	       CopyZone		    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: CopyFamilyBlue
**
** Description:
**   This function copies a cvt entry, representing a
**   family blue zone, to the cvt used for a particular hstem.
***/
USHORT	       CopyFamilyBlue	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: AlignFlat
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT	       AlignFlat	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: AlignOvershoot
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT	       AlignOvershoot	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: EmitFlex
**
** Description:
**   Convert a T1 flex hint into a TrueType IP[] 
**   intruction sequence that will reduce a flex
**   that is flatter than a given height.
***/
errcode	       EmitFlex		    _ARGS((INOUT   short *args,
					   INOUT   short *pcd,
					   IN	   funit height,
					   IN	   short start,
					   IN	   short mid,
					   IN	   short last));
/***
** Function: ReduceDiagonals
**
** Description:
**   This function generates the TT instructions
**   that will shrink the outline, in order to
**   control the width of diagonals. This implementation
**   can probably be improved.
***/
short	       ReduceDiagonals	    _ARGS((IN	   Outline *paths,
					   INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: ScaleDown3
**
** Description:
**   This function generates the TT instructions
**   that will scale down points 3%.
***/
void	       ScaleDown3	    _ARGS((IN	   Extremas *extr,
					   IN	   short xcnt, 
					   INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: EmitIP
**
** Description:
**   This function generates the TT instructions
**   that will interpolate points that are either
**   within or between stem sides.
***/
void	       EmitIP		    _ARGS((IN	   Extremas *extr,
					   IN	   short xcnt, 
					   INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   IN	   short scale3offset));
/***
** Function: EmitVerticalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void	       EmitVerticalStems    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: EmitHorizontalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void	       EmitHorizontalStems  _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: EmitVStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a vstem.
***/
errcode	       EmitVStem	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   INOUT   struct T1Metrics *t1m,
					   IN	   funit width,
					   IN      funit real_side1,
					   IN      funit real_side2,
					   IN      funit side1,
					   IN      funit side2,
					   IN      short rp,
					   IN      enum aligntype align,
					   IN      short ref));
/***
** Function: EmitHStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a hstem.
***/
errcode	       EmitHStem	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   INOUT   struct T1Metrics *t1m,
					   IN	   funit width,
					   IN      funit side1,
					   IN      funit side2,
					   IN      short rp,
					   IN      enum aligntype align,
					   IN      short ref));
/***
** Function: FamilyCutIn
**
** Description:
**   This function generates a branch in the
**   pre-program. 
***/
USHORT	       FamilyCutIn	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   USHORT tp,
					   IN	   short cis));
/***
** Function: SetProjection
**
** Description:
**   This function generates the TrueType code that
**   changes the projection vector in oblique typefaces.
***/
void	       SetProjection	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   IN	   funit x,
					   IN	   funit y));
/***
** Function: AssembleArgs
**
** Description:
**   This function takes a sequence of arguments and
**   assembles them into a sequence of PUSHB1[], PUSHW1[],
**   NPUSHB[] and NPUSHW[] instructions.
***/
void           AssembleArgs         _ARGS((INOUT   short *args,
                                           IN      short pcd,
                                           OUT     UBYTE *is,
                                           INOUT   short *cnt));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\trig.h ===
/***
 **
 **   Module: Trig
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains a look-up table for computing atan2() faster, and
 **    with less precision than that of the c run-time library.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/



#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif

#define PI    1024
#define PI2   512
#define PI4   256



/***
** Function: Atan2
**
** Description:
**   Compute atan2()
***/
int FASTCALL Atan2   _ARGS((IN int dy, IN int dx));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\trig.c ===
/***
 **
 **   Module: Trig
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains a look-up table for computing atan2() faster, and
 **    with less precision than that of the c run-time library.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/



#include "types.h"
#include "metrics.h"
#include "trig.h"

static const unsigned char atan_tbl[] = {
   0,
   2, 5, 7, 10, 12, 15, 17, 20, 22, 25, 27, 30, 32, 35, 38, 40, 
   43, 45, 48, 50, 53, 55, 57, 60, 62, 65, 67, 70, 72, 75, 77, 79, 
   82, 84, 87, 89, 91, 94, 96, 98, 101, 103, 105, 107, 110, 112, 114, 116, 
   119, 121, 123, 125, 127, 130, 132, 134, 136, 138, 140, 142, 144, 147, 149, 151, 
   153, 155, 157, 159, 161, 163, 165, 167, 168, 170, 172, 174, 176, 178, 180, 182, 
   183, 185, 187, 189, 191, 192, 194, 196, 198, 199, 201, 203, 204, 206, 208, 209, 
   211, 212, 214, 216, 217, 219, 220, 222, 223, 225, 226, 228, 229, 231, 232, 234, 
   235, 237, 238, 239, 241, 242, 244, 245, 246, 248, 249, 250, 252, 253, 254, 255
};


/***
** Function: Atan2
**
** Description:
**   Compute atan2()
***/
int FASTCALL Atan2(const funit dy, const funit dx)
{
   funit du, dv;
   int a = 0;

   /* Normalize the sign. */
   if (ABS(dx)>ABS(dy)) {
      du = ABS(dx);
      dv = ABS(dy);

      if (du==0) {
         a = PI4;
      } else {

         /* Normalize for the size of the table. */
         while (dv>256) {
            dv = (dv+1)>>1;
            du = (du+1)>>1;
         }
         dv = ((dv<<7)+(du>>1))/du;

         /* Lookup the angle. */
         if (dv==1) 
            a = (int)((long)PI4 * (long)ABS(dx) / (long)ABS(dy));
         if (du!=dv)
            a = (int)atan_tbl[dv];
      }

   } else {
      du = ABS(dy);
      dv = ABS(dx);

      if (du==0) {
         a = PI4;
      } else {

         /* Normalize for the size of the table. */
         while (dv>256) {
            dv = (dv+1)>>1;
            du = (du+1)>>1;
         }
         dv = ((dv<<7)+(du>>1))/du;

         /* Lookup the angle. */
         if (dv==1) 
            a = (int)((long)PI4 * (long)ABS(dy) / (long)ABS(dx));
         if (du!=dv)
            a = PI2 - (int)atan_tbl[dv];
      }
   }


   /* pick the right quadrant. */
   if (dx>0) {
      if (dy>0) {
         /* NOOP */
      } else {
         a = -a;
      }
   } else {
      if (dy>0) {
         a = PI - a;
      } else {
         a = a - PI;
      }
   }

   return a;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\version.h ===
/* All version strings and release dates are located in this file. */

char vFoundry[] = "3.20";
char dFoundry[] = "09/15/92";

char vMakebit[] = "3.20";
char dMakebit[] = "09/15/92";  /* bc14 with newptr bug fixed in cscan.c*/

char vMakeabf[] = "3.20";
char dMakeabf[] = "09/15/92";

char vMakeljf[] = "3.20";
char dMakeljf[] = "09/15/92";

char vMakepfm[] = "3.20";
char dMakepfm[] = "09/15/92";

char vMakevfm[] = "3.20";
char dMakevfm[] = "09/15/92";

char vMakewp5[] = "3.20";
char dMakewp5[] = "09/15/92";

char vMakeword[] = "3.20";
char dMakeword[] = "09/15/92";

char vMakefon[] = "3.20";
char dMakefon[] = "09/15/92";

char vMakepfon[] = "3.20";
char dMakepfon[] = "10/02/89";

char vUpdatwin[] = "3.20";
char dUpdatwin[] = "09/15/92";

char vCheckcnf[] = "3.20";
char dCheckcnf[] = "09/15/92";



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\types.h ===
#ifndef TYPES_H
#define TYPES_H


/***********/
/* Macros. */
#define MAX(v,w)  ((v)>=(w) ? (v) : (w))
#define MIN(v,w)  ((v)<(w) ? (v) : (w))
#define ABS(v)	  (((v)>=0) ? (v) : -(v))
#define SWAPINT(a,b)   {(a)^=(b); (b)^=(a); (a)^=(b);}
#define MkLong(c1,c2,c3,c4)	 (((ULONG)(c1)<<24L) + ((ULONG)(c2)<<16L) + \
				 ((ULONG)(c3)<<8L) + ((ULONG)(c4)))



/**************/
/* Constants. */
#define TRUE   1
#define FALSE  0



/**********/
/* Types. */
typedef short errcode;
typedef unsigned char UBYTE;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef unsigned char boolean;
typedef long f16d16;


/* Microsoft C specific stuff. */
#ifndef CDECL
#ifdef _MSC_VER
#  define CDECL  __cdecl
#else
#  define CDECL
#endif
#endif


/*** Error handling. */
void LogError(const long type, const long id, const char *arg);

#if _DEBUG
#ifdef MSDOS
int _cdecl sprintf(char *, const char *, ...);
#else
int sprintf(char *, const char *, ...);
#endif
#define SetError(c)  {char tmp[64];  (void)sprintf(tmp,\
	"Error %d at %s, line %d.\n", c, __FILE__, __LINE__); LogError(MSG_ERROR, MSG_DB, tmp);}
#else
#define SetError(c)  {c;}
#endif

/* Message types */
#define MSG_INFO     0L
#define MSG_WARNING  1L
#define MSG_ERROR    2L

	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\winio.c ===
/***
**
**   Module: FileIO
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      is the interface towards all low level I/O functions that are
**      are available on the current platform.
**      This version of the module is written specifically for Win32,
**      and is based on "memory mapped files".
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <windows.h>

#undef IN

/* Special types and definitions. */
#include "t1instal.h"
#include "types.h"
#include "safemem.h"
#include "fileio.h"

/* Module dependent types and prototypes. */
/*-none-*/


/***** LOCAL TYPES */
struct ioFile {
   HANDLE file;
   HANDLE mapping;
   LPVOID data;
   UBYTE  *ptr;
   UBYTE  *max;
   DWORD  length;
   boolean output;
};


/***** CONSTANTS */
#define FILESIZE     65535L
#define BUFSIZE      8L * 1024L
#define BADSET_ERROR 0xffffffff

/***** MACROS */
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif
#define TRY if (1)
#define EXCEPT(v) else



/***** STATIC FUNCTIONS */
/*-none-*/




/***** FUNCTIONS */

struct ioFile *io_OpenFile(const char *name, const int mode)
{
   DWORD access;
   DWORD create;
   DWORD attr;
   DWORD prot;
   DWORD lowsize;
   DWORD mapaccess;
   SECURITY_ATTRIBUTES sa;
   struct ioFile *file;

   if ((file = Malloc(sizeof(struct ioFile)))!=NULL) {
      file->file = NULL;
      file->mapping = NULL;
      file->data = NULL;
      file->ptr = NULL;
      file->length = 0;

      if (mode == READONLY) {
         access = GENERIC_READ;
         create = OPEN_EXISTING;
         attr = FILE_ATTRIBUTE_NORMAL /*FILE_FLAG_SEQUENTIAL_SCAN*/;
         prot = PAGE_READONLY;
         lowsize = 0;
         mapaccess = FILE_MAP_READ;
         file->output = FALSE;
      } else {
         access = GENERIC_READ | GENERIC_WRITE;
         create = CREATE_ALWAYS;
         attr = FILE_ATTRIBUTE_NORMAL;
         prot = PAGE_READWRITE;
         lowsize = FILESIZE;
         mapaccess = FILE_MAP_ALL_ACCESS;
         file->output = TRUE;
      }
      sa.nLength = sizeof(sa);
      sa.lpSecurityDescriptor = NULL;
      sa.bInheritHandle = FALSE;
      if ((file->file = CreateFile(name, access, 0, &sa, create,
                                   attr, NULL))==INVALID_HANDLE_VALUE) {
         (void)io_CloseFile(file);
         SetLastError(0);
         file = NULL;
      } else {
         if ((file->mapping = CreateFileMapping(file->file, NULL,
                                                prot, 0, lowsize,
                                                NULL))==INVALID_HANDLE_VALUE) {
            (void)io_CloseFile(file);
            file = NULL;
         } else {
            if ((file->data = MapViewOfFile(file->mapping,
                                            mapaccess, 0, 0, 0))==NULL) {
               (void)io_CloseFile(file);
               file = NULL;
            } else {
               file->ptr = (UBYTE *)file->data;
               file->max = file->ptr;
               file->max = file->max + GetFileSize(file->file, NULL);
            }
         }
      }
   }

   return file;
}

errcode io_CloseFile(struct ioFile *file)
{
   errcode status = SUCCESS;

   if (file==NULL || file->data==NULL || file->file==0)
      status = FAILURE;


   if (file) {
      if ((DWORD)(file->ptr - (UBYTE *)file->data)>file->length)
         file->length = (long)(file->ptr - (UBYTE *)file->data);

      if (file->data){
         UnmapViewOfFile(file->data);
         file->data = NULL;
      }

      if (file->mapping) {
         CloseHandle(file->mapping);
         file->mapping = NULL;
      }

      if (file->file) {
         if (file->output) {
            if (SetFilePointer(file->file,
                               file->length,
                               0,
                               FILE_BEGIN)==BADSET_ERROR)
               status = FAILURE;
            else if (SetEndOfFile(file->file)==FALSE)
               status = FAILURE;

         }

         CloseHandle(file->file);
         file->file = NULL;
      }

      Free(file);
   }

   return status;
}


USHORT FASTCALL io_ReadOneByte(struct ioFile *file)
{
   USHORT byte;

   if (file->ptr<=file->max) {
      byte = (USHORT)*(file->ptr++);
   } else {
      SetLastError(ERROR_READ_FAULT);
      byte = ERROR_READ_FAULT;
   }

   return byte;
}

USHORT FASTCALL io_WriteBytes(const UBYTE *buf,
                              USHORT len,
                              struct ioFile *file)
{
   if ((file->ptr+len)<=file->max) {
      memcpy(file->ptr, buf, len);
      file->ptr = file->ptr + len;
   } else if (file->data) {
      long pos = io_FileTell(file);
      long size = MAX(GetFileSize(file->file, NULL),
                      MAX(file->length, (ULONG)(file->ptr -
                                                (UBYTE *)file->data)));

      /* Get rid of the old file mapping. */
      UnmapViewOfFile(file->data);
      file->data = NULL;
      CloseHandle(file->mapping);
      file->mapping = NULL;

      /* Get a new file mapping. */
      if ((file->mapping = CreateFileMapping(file->file, NULL,
                                               PAGE_READWRITE, 0,
                                               size + BUFSIZE,
                                               NULL))==INVALID_HANDLE_VALUE) {
         SetLastError(ERROR_WRITE_FAULT);
         file->ptr = file->max;
         len = 0;
      } else if ((file->data = MapViewOfFile(file->mapping,
                                             FILE_MAP_ALL_ACCESS,
                                             0, 0, 0))==NULL) {
         SetLastError(ERROR_WRITE_FAULT);
         file->ptr = file->max;
         len = 0;
      } else {
         file->ptr = (UBYTE *)file->data;
         file->max = (UBYTE *)file->data;
         file->max = file->max + size + BUFSIZE;
         io_FileSeek(file, pos);
         io_WriteBytes(buf, len, file);
      }
   }

   return len;
}

USHORT FASTCALL io_ReadBytes(UBYTE *buf, USHORT len, struct ioFile *file)
{
   if ((file->ptr+len)<=file->max) {
      memcpy(buf, file->ptr, len);
      file->ptr = file->ptr + len;
   } else {
      SetLastError(ERROR_READ_FAULT);
      len = 0;
   }

   return len;
}

boolean io_FileError(struct ioFile *file)
{
   return (boolean)GetLastError();
}


long FASTCALL io_FileTell(struct ioFile *file)
{
   return (long)(file->ptr - (UBYTE *)file->data);
}


long FASTCALL io_FileSeek(struct ioFile *file, long where)
{
   DWORD oldpos = (DWORD)(file->ptr - (UBYTE *)file->data);

   /* Keep track of the length of the file. */
   if (oldpos>file->length)
      file->length = oldpos;

   /* Fail if file is not mapped, or if we are jumping out of bounds. */
   if (file->data && (where>=0) &&
       ((UBYTE *)file->data+where) <= file->max) {
      file->ptr = (UBYTE *)file->data;
      file->ptr = file->ptr + where;
   } else {
      SetLastError(ERROR_SEEK);
   }

   return (long)oldpos;
}


/***
** Function: FileSeek
**
** Description:
***/
void FASTCALL io_RemoveFile(const char *name)
{
   DeleteFile(name);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\t1instal\ttprog.c ===
/***
**
**   Module: ttprog
**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of Hint module. This modules deals with the 
**      the font program fo the font.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <limits.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
/*#include "hints.h"*/
#include "ttprog.h"



/***** MACROS */
/*-none-*/



/***** CONSTANTS */
#define MAXIP			100

#define CURVEPHASE      6

#define MAXTHINPNTS     512

#define UNDEF        -1

#define SMALL_LOWER     21L
#define SMALL_UPPER     50L
#define LARGE_LOWER     21L
#define LARGE_UPPER     21L

#define BUFSIZE         20

#define TTFUN_SET_ZONE           1 
#define TTFUN_COPY_ZONE          2 
#define TTFUN_STEM_SNAP_WIDTH    3 
#define TTFUN_STEM_STD_WIDTH     4 
#define TTFUN_SHIFT_BLUE_ZONE    5 
#define TTFUN_ALIGN_BLUE_ZONE    6 
#define TTFUN_COPY_FAMILY        7 
#define TTFUN_WRITE_STEM         8 
#define TTFUN_VERTICAL           9 
#define TTFUN_HORIZONTAL         10
#define TTFUN_VCENTER            11
#define TTFUN_HCENTER            12
#define TTFUN_RELATIVE1V         13
#define TTFUN_RELATIVE2V         14
#define TTFUN_RELATIVE1H         15
#define TTFUN_RELATIVE2H         16
#define TTFUN_SIDE1              17    
#define TTFUN_SIDE2              18
#define TTFUN_FLEX               19
#define TTFUN_SCALE3             20
#define TTFUN_SHIFT1             21
#define TTFUN_SHIFT2             22
#define TTFUN_IP1                23  
#define TTFUN_IP2                24
#define TTFUN_IPN                25
#define TTFUN_SHP1               26  
#define TTFUN_SHP2               27
#define TTFUN_SHPN               28
#define TTFUN_RANGE              29
#define TTFUN_OBLIQUE            30
#define TTFUN_NUM                31    /* 1..30 */


#define FDEF(name)            op_pushb1, name, op_fdef,
#define ENDF                  op_endf,
#define CALL(name)            op_pushb1, name, op_call
#define WCVT(name)            op_pushb1, name, op_swap, op_wcvtf
#define PUSH1(v)              op_pushb1, (v)
#define PUSH2(v1, v2)         op_pushb1+1, (v1), (v2)
#define PUSH3(v1, v2, v3)     op_pushb1+2, (v1), (v2), (v3)
#define PUSH4(v1, v2, v3, v4) op_pushb1+3, (v1), (v2), (v3), (v4)
#define PUSH5(v1,v2,v3,v4,v5) op_pushb1+4, (v1), (v2), (v3), (v4), (v5)


static const UBYTE FontProg[] = {


   
/******* SET ZONE FUNCTION
 *
 * Args: flat_pos
 *
 */
FDEF(TTFUN_SET_ZONE)
   PUSH1(TMPPNT),
   op_swap,
   op_miap,
   PUSH1(TMPPNT),
   op_mdap | SUBOP_R,
ENDF




/******* COPY ZONE FUNCTION
 *
 * Args: from_cvt, to_cvt
 *
 */
FDEF(TTFUN_COPY_ZONE)
   op_rcvt,
   op_round,
   op_wcvtp,
ENDF





/******* STEM SNAP WIDTH FUNCTION
 *
 * Args: std_ci, std_cvt, snap_ci, snap_cvt, width, storage
 *
 */
FDEF(TTFUN_STEM_SNAP_WIDTH)
   op_mppem,
   op_gteq,
   op_if,

      /* Use std */
      op_rcvt,
      op_round,
      PUSH1(ONEPIXEL/2),
      op_max,
      op_swap, op_pop, op_swap, op_pop, op_swap, op_pop,
      CALL(TTFUN_WRITE_STEM),
      
   op_else,
      op_pop,
      op_mppem,
      op_gteq,
      op_if,
   
         /* Use snap */
         op_rcvt,
         op_round,
         PUSH1(ONEPIXEL/2),
         op_max,
    op_swap,
         op_pop, 
         CALL(TTFUN_WRITE_STEM),
         
      /* Use real width. */
      op_else,
         op_pop,
         WCVT(TMPCVT),
         PUSH1(TMPCVT),
         op_rcvt,
         op_round,
         PUSH1(ONEPIXEL/2),
         op_max,
         CALL(TTFUN_WRITE_STEM),
      op_eif,
   
   op_eif,
ENDF



   

/******* STEM STD WIDTH FUNCTION
 *
 * Args: std_ci, std_cvt, width, storage
 *
 */
FDEF(TTFUN_STEM_STD_WIDTH)
   op_mppem,
   op_gteq,
   op_if,
   
      /* Use std */
      op_rcvt,
      op_round,
      PUSH1(ONEPIXEL/2),
      op_max,
      op_swap,
      op_pop,
      CALL(TTFUN_WRITE_STEM),
      
   /* Use real width. */
   op_else,
      op_pop,
      WCVT(TMPCVT),
      PUSH1(TMPCVT),
      op_rcvt,
      op_round,
      PUSH1(ONEPIXEL/2),
      op_max,
      CALL(TTFUN_WRITE_STEM),
   op_eif,
   
ENDF





/******* SHIFT BLUE ZONE FUNCTION
 *
 * Args: cvt
 *
 */
FDEF(TTFUN_SHIFT_BLUE_ZONE)
   PUSH5(TMPPNT1, TMPPNT1, TMPPNT, TMPPNT1, 5),
   op_cindex,
   op_miap,
   op_srp0,
   op_mdrp | SUBOP_mMRGR,
   op_gc,
   op_wcvtp,
ENDF





/******* ALIGN BLUE ZONE FUNCTION
 *
 * Args: cvt
 *
 */
FDEF(TTFUN_ALIGN_BLUE_ZONE)
   PUSH5(TMPPNT1, TMPPNT1, TMPPNT, TMPPNT1, 5),
   op_cindex,
   op_miap,
   op_srp0,
   op_mdrp | SUBOP_ROUND,
   op_gc,
   op_wcvtp,
ENDF





/******* COPY FAMILY FUNCTION
 *
 * Args: base_cvt
 *
 */
FDEF(TTFUN_COPY_FAMILY)
   op_dup,
   PUSH1(1),
   op_add,
   op_rcvt,
   op_wcvtp,
ENDF





/******* WRITE STEM FUNCTION
 *
 * Args: width, storage
 *
 */
FDEF(TTFUN_WRITE_STEM)
   op_dup,    /* -| width, width, storage */
   op_dup,    /* -| width, width, width, storage */
   op_add,    /* -| 2*width, width, storage, */
   op_odd,    /* -| odd/even, width, storage */
   PUSH2(1, 4),     /* -| 4, 1, odd/even, width, storage */
   op_cindex,     /* -| storage, 1, odd/even, width, storage */
   op_add,
   op_swap,   /* -| odd/even, storage+1, width, storage */
   op_ws,
   op_ws,
ENDF





/******* VERTICAL FUNCTION
 *
 * Args: -*none*-
 *
 */
FDEF(TTFUN_VERTICAL)
   op_svcta | SUBOP_X,
   PUSH1(TWILIGHT),
   op_szps,
ENDF





/******* HORIZONTAL FUNCTION
 *
 * Args: -*none*-
 *
 */
FDEF(TTFUN_HORIZONTAL)
   PUSH1(TWILIGHT),
   op_svcta,
   op_szps,
ENDF





/******* CENTER VSTEM FUNCTION
 *
 * Args: p1, p2, p3, p4, c, tz1, width
 *
 */
FDEF(TTFUN_VCENTER)

   /* Set rounding state for the center. */
   PUSH2(1, 8),
   op_cindex,
   op_add,
   op_rs,
   op_if,
       op_rthg,
   op_else,
       op_rtg,
   op_eif,

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 6),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 6),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 2, 5),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 3, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round center. */
   WCVT(TMPCVT),     /* c */
   PUSH2(TMPPNT, TMPCVT),
   op_miap| SUBOP_R,
   op_rtg,

   /* Align all points to the center. */
   op_dup, op_dup, PUSH1(1), op_add,
   op_alignrp, op_alignrp,   /* tz1, tz1+1 */


   /* Compute the width. */
   op_swap,
   op_rs,
   PUSH1(CURVEPHASE),
   op_sub,
   op_swap,


   /* -| tz1, width */
   op_dup,
   op_dup,
   op_dup,
   op_srp0,
   PUSH1(4), op_cindex,
   op_neg,     /* -| (-width/2), tz1, tz1, tz1, width */
   op_shpix,      
   PUSH1(2),
   op_add,
   op_alignrp,    /* -| tz1+2, tz1, width */


   /* Do the other side. */
   /* -| tz1, width */
   PUSH1(1),
   op_add,
   op_dup,
   op_dup,     /* -| tz1+1, tz1+1, tz1+1, width */
   op_srp0,
   op_roll,    /* -| width, tz1+1, tz1+1 */
   op_shpix,      
   PUSH1(2),
   op_add,
   op_alignrp,    /* -| tz1+3 */

   /* Done. */
ENDF






/******* CENTER HSTEM FUNCTION
 *
 * Args: p1, p2, c, tz1, width
 *
 */
FDEF(TTFUN_HCENTER)

   /* Set,rounding state for the center. */
   PUSH2(1, 6),
   op_cindex,
   op_add,
   op_rs,
   op_if,
       op_rthg,
   op_else,
       op_rtg,
   op_eif,

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round center. */
   WCVT(TMPCVT),  /* c */
   PUSH2(TMPPNT, TMPCVT),
   op_miap| SUBOP_R,
   op_rtg,

   /* Align all points to the center. */
   op_dup, op_dup, PUSH1(1), op_add,
   op_alignrp, op_alignrp,   /* tz1, tz1+1 */


   /* Compute the width. */
   op_swap,
   op_rs,
   PUSH1(CURVEPHASE),
   op_sub,
   op_swap,


   /* -| tz1, width */
   op_dup,
   PUSH1(3), op_cindex,
   op_neg,     /* -| -width, tz1, tz1, width */
   op_shpix,      

   /* Do the other side. */
   /* -| tz1, width */
   PUSH1(1),
   op_add,
   op_swap,    /* -| width, tz1+1 */
   op_shpix,      

   /* Done. */
ENDF





/******* RELATIVE1V STEM FUNCTION
 *
 * Args: p1, p2, p3, p4, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE1V)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 6),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 6),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 2, 5),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 3, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   /* Move/round side. */
   op_srp0,
   op_dup,
   op_mdrp | SUBOP_MmRGR,

   /* Align points on the left side. */
   op_dup, PUSH1(1), op_add, op_dup, op_dup, op_dup,
   PUSH1(1), op_add,  /* -| tz1+2, tz1+1, tz1+1, tz+1, tz, width */
   op_alignrp,
   op_alignrp,

   /* Align right side */
   op_srp0,    /* -| tz1+1, tz1, width */
   op_roll,
   op_rs,
   op_dup,
   op_add,     /* -| width*2, tz1+1, tz1 */
   op_shpix,
   PUSH1(3),
   op_add,
   op_alignrp,    /* -| tz1+3 */

ENDF





/******* RELATIVE2V STEM FUNCTION
 *
 * Args: p1, p2, p3, p4, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE2V)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 6),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 6),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 2, 5),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 3, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round side. */
   op_srp0,
   op_dup,
   PUSH1(1), op_add,
   op_mdrp | SUBOP_MmRGR,

   /* Align points on the left side. */
   op_dup, op_dup, op_dup, op_dup,
   PUSH1(3), op_add,  /* -| tz1+3, tz1, tz1, tz1, tz1, width */
   op_alignrp,
   op_alignrp,


   /* Align left side */
   op_srp0,    /* -| tz1, tz1, width */
   op_roll,
   op_rs,
   op_dup,
   op_add,
   op_neg,
   op_shpix,      /* -| -2*width, tz1, tz1 */
   PUSH1(2), op_add,
   op_alignrp,    /* -| tz1+2 */

ENDF





/******* RELATIVE1H STEM FUNCTION
 *
 * Args: p1, p2, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE1H)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   /* Move/round side. */
   op_srp0,
   op_dup,
   op_mdrp | SUBOP_MmRGR,


   /* Align all point to the lower side. */
   PUSH1(1), op_add, op_dup,
   op_alignrp,

   /* Align right side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   op_shpix,

ENDF





/******* RELATIVE2H STEM FUNCTION
 *
 * Args: p1, p2, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE2H)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round side. */
   op_srp0,
   op_dup,
   PUSH1(1), op_add,
   op_mdrp | SUBOP_MmRGR,

   /* Align all points to the center. */
   op_dup, op_alignrp,

   /* Align left side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   op_neg,
   op_shpix,

ENDF





/******* SIDE1 STEM FUNCTION
 *
 * Args: p1, p2, zone, tz1, width
 *
 */
FDEF(TTFUN_SIDE1)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   /* Move/round side. */
   PUSH2(TMPPNT, TMPPNT),
   op_srp0, op_swap, op_miap | SUBOP_R,

   /* Align all points to the side. */
   op_dup, PUSH1(1), op_add, op_dup, op_roll,
   op_alignrp, op_alignrp,

   /* Align first side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   PUSH1(CURVEPHASE),
   op_sub,
   op_shpix,

ENDF





/******* SIDE2 STEM FUNCTION
 *
 * Args:  p1, p2, zone, tz1, width
 *
 */
FDEF(TTFUN_SIDE2)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round side. */
   PUSH2(TMPPNT, TMPPNT),
   op_srp0, op_swap, op_miap | SUBOP_R,

   /* Align all points to the side. */
   op_dup, op_dup, PUSH1(1), op_add, 
   op_alignrp, op_alignrp,

   /* Align second side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   PUSH1(CURVEPHASE),
   op_sub,
   op_neg,
   op_shpix,

ENDF


    


/******* FLEX FUNCTION
 *
 * Args on the stack: pnt_start, pnt_mid, ref_pos, pnt_mid,
 *       pnt_start, pnt_mid, cnt, p1, p2, ....
 *
 */
FDEF(TTFUN_FLEX)
   op_srp0,
   op_alignrp,
   op_wcvtf,
   op_rcvt,
   op_shpix,
   op_srp1,
   op_srp2,
   op_sloop,
   op_ip,
ENDF





/******* SCALE3 FUNCTION
 *
 * Args: cnt, p1, p2, ... 
 *
 */
FDEF(TTFUN_SCALE3)
   PUSH4(GLYPHZONE, TMPPNT1, TMPPNT, TMPPNT1),
   op_pushw1, HIBYTE(-31), LOBYTE(-31),
   PUSH3(TMPPNT, 0, TMPPNT1),
   op_pushw1, HIBYTE(1000), LOBYTE(1000),
   op_scfs,
   op_scfs,
   op_shpix,
   op_srp1,
   op_srp2,
   op_szp2,
   op_sloop,
   op_ip,
ENDF





/******* SHIFT1 FUNCTION
 *
 * Args: cnt reduction p1 p2 ...
 *
 */
FDEF(TTFUN_SHIFT1)
   op_sloop,
   op_rs,
   op_neg,
   op_shpix,
ENDF




   
/******* SHIFT2 FUNCTION
 *
 * Args: cnt reduction p1 p2 ...
 *
 */
FDEF(TTFUN_SHIFT2)
   op_sloop,
   op_rs,
   op_shpix,
ENDF





/******* IP1 FUNCTION
 *
 * Args: rp1, rp2, p1
 *
 */
FDEF(TTFUN_IP1)
   op_srp1,
   op_srp2,
   op_ip,
ENDF





/******* IP2 FUNCTION
 *
 * Args: rp1, rp2, p1, p2
 *
 */
FDEF(TTFUN_IP2)
   op_srp1,
   op_srp2,
   op_ip,
   op_ip,
ENDF





/******* IPN FUNCTION
 *
 * Args: rp1, rp2, cnt, p1, p2
 *
 */
FDEF(TTFUN_IPN)
   op_srp1,
   op_srp2,
   op_sloop,
   op_ip,
ENDF





/******* SHP1 FUNCTION
 *
 * Args: rp, p
 *
 */
FDEF(TTFUN_SHP1)
   op_srp1,
   op_shp,
ENDF





/******* SHP2 FUNCTION
 *
 * Args: rp, p1, p2
 *
 */
FDEF(TTFUN_SHP2)
   op_srp1,
   op_shp,
   op_shp,
ENDF


    

    
/******* SHPN FUNCTION
 *
 * Args: rp, cnt, p1, p2
 *
 */
FDEF(TTFUN_SHPN)
   op_srp1,
   op_sloop,
   op_shp,
ENDF





/******* RANGE FUNCTION
 *
 * Args: p
 *
 */
FDEF(TTFUN_RANGE)
   op_dup,
   PUSH1(1),
   op_add,
ENDF




/******* RANGE FUNCTION
 *
 * Args: pos_x, pos_y,
 *
 */
FDEF(TTFUN_OBLIQUE)
   op_svcta | SUBOP_Y,
   PUSH1(TMPPNT1),
   op_swap,
   op_scfs,
   PUSH2(TMPPNT, 0),
   op_scfs,
   op_svcta | SUBOP_X,
   PUSH1(TMPPNT1),
   op_swap,
   op_scfs,
   PUSH2(TMPPNT, 0),
   op_scfs,
   PUSH2(TMPPNT, TMPPNT1),
   op_spvtl,
ENDF

};


/***** LOCAL TYPES */


/***** STATIC FUNCTIONS */

/***
** Function: GetVStemWidth
**
** Description:
**   This function allocates a storage entry for the 
**   width of a vertical stem;
***/
static short GetVStemWidth(WeightControl *weight, const funit width)
{
   StemWidth *newwidths = NULL;
   short entry = 0;
   USHORT j;

   if (weight->cnt_vw >= weight->max_vw) {
      newwidths = Realloc(weight->vwidths,
                          sizeof(StemWidth)*(weight->max_vw+BUFSIZE));
      if (newwidths == NULL) {
         entry = NOMEM;
      } else {
         weight->vwidths = newwidths;
         weight->max_vw += BUFSIZE;
      }
   }

   if (entry != NOMEM) {
      for (j=0; j<weight->cnt_vw; j++) {
         if (weight->vwidths[j].width==width) {
            entry = (short)weight->vwidths[j].storage;
            break;
         }
      }

      if (j==weight->cnt_vw) {
         weight->vwidths[weight->cnt_vw].storage = weight->storage;
         weight->vwidths[weight->cnt_vw].width = width;
         entry = (short)weight->storage;
         weight->storage += 2;
         weight->cnt_vw++;
      }
   }

   return entry;
}


/***
** Function: GetHStemWidth
**
** Description:
**   This function allocates a storage entry for the 
**   width of a vertical stem;
***/
static short GetHStemWidth(WeightControl *weight, const funit width)
{
   StemWidth *newwidths = NULL;
   short entry = 0;
   USHORT j;

   if (weight->cnt_hw >= weight->max_hw) {
      newwidths = Realloc(weight->hwidths,
                          sizeof(StemWidth)*(weight->max_hw+BUFSIZE));
      if (newwidths == NULL) {
         entry = NOMEM;
      } else {
         weight->hwidths = newwidths;
         weight->max_hw += BUFSIZE;
      }
   }

   if (entry != NOMEM) {
      for (j=0; j<weight->cnt_hw; j++) {
         if (weight->hwidths[j].width==width) {
            entry = (short)weight->hwidths[j].storage;
            break;
         }
      }

      if (j==weight->cnt_hw) {
         weight->hwidths[weight->cnt_hw].storage = weight->storage;
         weight->hwidths[weight->cnt_hw].width = width;
         entry = (short)weight->storage;
         weight->storage += 2;
         weight->cnt_hw++;
      }
   }

   return entry;
}




/***** GLOBAL FUNCTIONS */

/***
** Function: SetZone
**
** Description:
**   This function initiate an alignment zone
**   by creating an appropriate point in the
**   twilight zone.
***/
USHORT SetZone(UBYTE *prep, USHORT tp, const short cvt)
{
   /* Set up the zone. */
   if (cvt>255) {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cvt);
      prep[tp++] = LOBYTE(cvt);
      prep[tp++] = op_pushb1;
      prep[tp++] = TTFUN_SET_ZONE;
   } else {
      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = (UBYTE)cvt;
      prep[tp++] = TTFUN_SET_ZONE;
   }
   prep[tp++] = op_call;

   return tp;
}



/***
** Function: CopyZone
**
** Description:
**   This function copies a cvt entry, representing an
**   alignment zone, to the cvt used for a particular hstem.
***/
USHORT CopyZone(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_COPY_ZONE;
   args[1] = (short)((ta-2)/2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}



/***
** Function: CopyFamilyBlue
**
** Description:
**   This function copies a cvt entry, representing a
**   family blue zone, to the cvt used for a particular hstem.
***/
USHORT CopyFamilyBlue(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_COPY_FAMILY;
   args[1] = (short)(ta-2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}



/***
** Function: AlignFlat
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT AlignFlat(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_ALIGN_BLUE_ZONE;
   args[1] = (short)(ta-2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}



/***
** Function: AlignOvershoot
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT AlignOvershoot(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_SHIFT_BLUE_ZONE;
   args[1] = (short)(ta-2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}


/***
** Function: GetTopPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short GetTopPos(const Blues *blues,
                AlignmentControl *align,
                const funit pos)
{
   short entry = UNDEF;
   const funit *bluevals;
   short fuzz;
   USHORT i, j;

   bluevals = &(blues->bluevalues[0]);
   fuzz = blues->blueFuzz;

   /* Check if it is within a zone. */
   for (i=0; i<blues->blue_cnt; i+=2) {
      if (((bluevals[i]-fuzz)<=pos) && ((bluevals[i+1]+fuzz)>=pos))
         break;
   }

   /* Record the position? */
   if (i!=blues->blue_cnt) {
      i /= 2;

      /* Is the position already mapped to a cvt entry? */
      for (j=0; j<align->top[i].cnt; j++) {
         if (align->top[i].pos[j].y==pos) {
            entry = (short)align->top[i].pos[j].cvt;
            break;
         }
      }

      if (j==align->top[i].cnt) {

         /* Allocate the BlueZone cvt's */
         if (align->top[i].cnt==0) {
            align->top[i].blue_cvt = align->cvt;
            align->cvt +=2;
         }

         align->top[i].pos[align->top[i].cnt].cvt = align->cvt;
         align->top[i].pos[align->top[i].cnt].y = pos;
         entry = (short)align->cvt;
         align->cvt+=2;
         align->top[i].cnt++;
      }
   }

   return entry;
}


/***
** Function: GetBottomPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short GetBottomPos(const Blues *blues,
                   AlignmentControl *align,
                   const funit pos)
{
   short entry = UNDEF;
   const funit *bluevals;
   short fuzz;
   USHORT i, j;

   bluevals = &(blues->otherblues[0]);
   fuzz = blues->blueFuzz;

   /* Check if it is within a zone. */
   for (i=0; i<blues->oblue_cnt; i+=2) {
      if (((bluevals[i]-fuzz)<=pos) && ((bluevals[i+1]+fuzz)>=pos))
         break;
   }


   /* Record the position? */
   if (i!=blues->oblue_cnt) {
      i /= 2;

      /* Is the position already mapped to a cvt entry? */
      for (j=0; j<align->bottom[i].cnt; j++) {
         if (align->bottom[i].pos[j].y==pos) {
            entry = (short)align->bottom[i].pos[j].cvt;
            break;
         }
      }

      if (j==align->bottom[i].cnt) {

         /* Allocate the BlueZone and FamilyBlue cvt's */
         if (align->bottom[i].cnt==0) {
            align->bottom[i].blue_cvt = align->cvt++;
         }

         align->bottom[i].pos[align->bottom[i].cnt].cvt = align->cvt;
         align->bottom[i].pos[align->bottom[i].cnt].y = pos;
         entry = (short)align->cvt;
         align->cvt+=2;
         align->bottom[i].cnt++;
      }
   }

   return entry;
}


/***
** Function: CutInSize
**
** Description:
**   This function computes the cut in size
**   of a stem, given a master width and the
**   width of the stem. This is done with the
**   StdVW==2.0 pixel treshold and the thinn
**   and wide cut in values.
***/
USHORT CutInSize(const funit width,
                 const funit master,
                 const USHORT tresh,
                 const funit upem)
{
   USHORT cis, ci1, ci2;

   /*lint -e776 */
   if (width > master) {
      ci1 = (USHORT)((long)upem * SMALL_UPPER / ONEPIXEL /
                     (long)(width - master));
      ci2 = (USHORT)((long)upem * LARGE_UPPER / ONEPIXEL /
                     (long)(width - master));
   } else if (width < master) {
      ci1 = (USHORT)((long)upem * SMALL_LOWER / ONEPIXEL /
                     (long)(master - width));
      ci2 = (USHORT)((long)upem * LARGE_LOWER / ONEPIXEL /
                     (long)(master - width));
   } else {
      ci1 = INFINITY;  
      ci2 = INFINITY;
   }
   /*lint +e776 */

   if (ci1 < tresh) {
      cis = ci1;
   } else if (ci2 < tresh) {
      cis = tresh;
   } else {
      cis = ci2;
   }

   return cis;
}


/***
** Function: SnapStemArgs
**
** Description:
**   
***/
USHORT SnapStemArgs(short *args, USHORT ta,
                    const funit width,
                    const USHORT std_cvt,
                    const USHORT snap_cvt,
                    const USHORT std_ci,
                    const USHORT snap_ci,
                    const USHORT storage)
{
   args[ta++] = (short)std_ci;
   args[ta++] = (short)std_cvt;
   args[ta++] = (short)snap_ci;
   args[ta++] = (short)snap_cvt;
   args[ta++] = (short)(width/2);
   args[ta++] = (short)storage;

   return ta;
}



/***
** Function: StdStemArgs
**
** Description:
**   
***/
USHORT StdStemArgs(short *args, USHORT ta,
                   const funit width,
                   const USHORT std_cvt,
                   const USHORT std_ci,
                   const USHORT storage)
{
   args[ta++] = (short)std_ci;
   args[ta++] = (short)std_cvt;
   args[ta++] = (short)(width/2);
   args[ta++] = (short)storage;

   return ta;
}



/***
** Function: CreateStdStems
**
** Description:
**   
***/
USHORT CreateStdStems(UBYTE *prep, USHORT tp, const short cnt)
{
   if (cnt>255) {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cnt);
      prep[tp++] = LOBYTE(cnt);
      prep[tp++] = op_pushb1;
      prep[tp++] = TTFUN_STEM_STD_WIDTH;
   } else {
      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = (UBYTE)cnt;
      prep[tp++] = TTFUN_STEM_STD_WIDTH;
   }

   prep[tp++] = op_loopcall;

   return tp;
}



/***
** Function: CreateSnapStems
**
** Description:
**   
***/
USHORT CreateSnapStems(UBYTE *prep, USHORT tp, const short cnt)
{
   if (cnt>255) {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cnt);
      prep[tp++] = LOBYTE(cnt);
      prep[tp++] = op_pushb1;
      prep[tp++] = TTFUN_STEM_SNAP_WIDTH;
   } else {
      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = (UBYTE)cnt;
      prep[tp++] = TTFUN_STEM_SNAP_WIDTH;
   }

   prep[tp++] = op_loopcall;

   return tp;
}




/***
** Function: tt_GetFontProg
**
** Description:
**   This function returns the static font
**   font program.
***/
const UBYTE *tt_GetFontProg(void)
{
   return FontProg;
}




/***
** Function: tt_GetFontProgSize
**
** Description:
**   This function returns the size of the
**   static font program.
***/
USHORT tt_GetFontProgSize(void)
{
   return (USHORT)sizeof(FontProg);
}




/***
** Function: tt_GetNumFuns
**
** Description:
**   This function returns the number of functions
**   defined in the static font program.
***/
USHORT tt_GetNumFuns(void)
{
   return (USHORT)TTFUN_NUM;
}



/***
** Function: EmitFlex
**
** Description:
**   Convert a T1 flex hint into a TrueType IP[] 
**   intruction sequence that will reduce a flex
**   that is flatter than a given height.
***/
errcode EmitFlex(short *args,
                 short *pcd,
                 const funit height,
                 const short start,
                 const short mid,
                 const short last)
{
   errcode status = SUCCESS;
   int i;

   /* Enough space for the instructions? */
   args[(*pcd)++] = TTFUN_FLEX;
   args[(*pcd)++] = start;
   args[(*pcd)++] = mid;
   args[(*pcd)++] = (short)height;
   args[(*pcd)++] = TMPCVT;
   args[(*pcd)++] = TMPCVT;
   args[(*pcd)++] = mid;
   args[(*pcd)++] = start;
   args[(*pcd)++] = mid;

   /* Push the flex points onto the stack. */
   args[(*pcd)++] = (short)(last-start-2);
   for (i=start+(short)1; i<last; i++)
      if (i!=mid)
         args[(*pcd)++] = (short)i;

   return status;
}




/***
** Function: ReduceDiagonals
**
** Description:
**   This function generates the TT instructions
**   that will shrink the outline, in order to
**   control the width of diagonals. This implementation
**   can probably be improved.
***/
short ReduceDiagonals(const Outline *paths,
                      UBYTE *pgm, short *pc,
                      short *args,  short *pcd)
{
   short cw[MAXTHINPNTS];
   short ccw[MAXTHINPNTS];
   short targ[MAXTHINPNTS];
   const Outline *path;
   Point *pts;
   short i,j;
   short cwi = 0, ccwi = 0;
   short prev;
   short n,m;
   short prev_cw, prev_ccw;
   short ta;



   /* Collect points on left and right side that are diagonals. */
   i = 0;
   for (path = paths; path && ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS;
   path=path->next) {

      pts = &path->pts[0];
      prev_cw = FALSE;
      prev_ccw = FALSE;

      /* Are the first and last point coinciding? */
      if (pts[path->count-1].x!=pts[0].x ||
          pts[path->count-1].y!=pts[0].y)
         prev = (short)(path->count-(short)1);
      else
         prev = (short)(path->count-(short)2);

      /* Special case the first point. */
      if (!OnCurve(path->onoff, prev) ||
          (pts[0].x != pts[prev].x &&
           ABS(pts[0].x - pts[prev].x) < ABS(pts[0].y - pts[prev].y)*8)) {
         if (pts[0].y>pts[prev].y+20) {
            if (pts[prev].y<=pts[prev-1].y)
               cw[cwi++] = (short)(i+(short)path->count-1);
            cw[cwi++] = i;
            prev_cw = TRUE;
            prev_ccw = FALSE;
         } else if (pts[0].y<pts[prev].y-20) {
            if (pts[prev].y>=pts[prev-1].y)
               ccw[ccwi++] = (short)(i+(short)path->count-1); 
            ccw[ccwi++] = i;
            prev_cw = FALSE;
            prev_ccw = TRUE;
         }
      }


      for (j=1; j<(short)path->count &&
             ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS; j++) {
         i++;
         if (!OnCurve(path->onoff, j-1) ||
             (pts[j].x != pts[j-1].x &&
              ABS(pts[j].x - pts[j-1].x) < ABS(pts[j].y - pts[j-1].y)*8)) {
            if (pts[j].y>pts[j-1].y+20) {
               if (!prev_cw)
                  cw[cwi++] = (short)(i-1);
               cw[cwi++] = i;
               prev_cw = TRUE; 
               prev_ccw = FALSE;
            } else if (pts[j].y<pts[j-1].y-20) {
               if (!prev_ccw)
                  ccw[ccwi++] = (short)(i-1);
               ccw[ccwi++] = i;
               prev_cw = FALSE;
               prev_ccw = TRUE;
            } else {
               prev_cw = FALSE;
               prev_ccw = FALSE;
            }
         } else {
            prev_cw = FALSE;
            prev_ccw = FALSE;
         }
      }
      i++;
   }


   /* Did we get all points? */
   if (ccwi>=MAXTHINPNTS || cwi>=MAXTHINPNTS) {
      LogError(MSG_WARNING, MSG_DIAG, NULL);
   }


   /* Any points to shift? */
   if (cwi || ccwi) {
      args[(*pcd)++] = STORAGE_DIAG;
      pgm[(*pc)++] = op_rs;
      pgm[(*pc)++] = op_if;
      pgm[(*pc)++] = op_svcta + SUBOP_X;

      /* Switch over to GLYPHZONE */
      pgm[(*pc)++] = op_szp2;
      args[(*pcd)++] = 1;


      ta = 3;

      /* Disable "cw[m] may not have been initialized".*/ /*lint -e644 */
      for (n=0; n<cwi; n=m) {
         for (m=(short)(n+1); m<cwi && cw[m]==cw[m-1]+1; m++); /*lint +e644 */
         if (m-n<=4) {
            for (i=n; i<m; i++)
               targ[ta++] = cw[i];
         } else {
            targ[0] = TTFUN_RANGE;
            targ[1] = (short)(m-n-1);
            targ[2] = cw[n];
            AssembleArgs(targ, ta, pgm, pc);
            pgm[(*pc)++] = op_loopcall;
            ta = 3;
         }
      }
      targ[0] = TTFUN_SHIFT1;
      targ[1] = cwi;
      targ[2] = STORAGE_DIAG;
      AssembleArgs(targ, ta, pgm, pc);
      pgm[(*pc)++] = op_call;


      /************ Shift back the left side of the glyph. */

      ta = 3;

      /* Disable "ccw[m] may not have been initialized".*/ /*lint -e644 */
      for (n=0; n<ccwi; n=m) {
         for (m=(short)(n+1); m<ccwi && ccw[m]==ccw[m-1]+1; m++); /*lint +e644 */
         if (m-n<=4) {
            for (i=n; i<m; i++)
               targ[ta++] = ccw[i];
         } else {
            targ[0] = TTFUN_RANGE;
            targ[1] = (short)(m-n-1);
            targ[2] = ccw[n];
            AssembleArgs(targ, ta, pgm, pc);
            pgm[(*pc)++] = op_loopcall;
            ta = 3;
         }
      }
      targ[0] = TTFUN_SHIFT2;
      targ[1] = ccwi;
      targ[2] = STORAGE_DIAG;
      AssembleArgs(targ, ta, pgm, pc);
      pgm[(*pc)++] = op_call;


#ifdef SYMETRICAL_REDUCTION

      /* The amount that the outline is shrunk is computed once at
      each size, in the pre-program. The outline is shrunk
      symetrically by the amount: 1/16 + (12 Funits)*size/UPEm.

      This approach yields more symmetrical results than shrinking
      the outline horizontally alone (see separate papers on the topic). */


      /* Same thing for the height... */
      i = 0;
      cwi = 0;
      ccwi = 0;
      for (path = paths; path && ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS;
      path=path->next) {

         pts = &path->pts[0];

         /* Are the first and last point coinciding? */
         if (pts[path->count-1].y!=pts[0].y ||
             pts[path->count-1].x!=pts[0].x)
            prev = path->count-1;
         else
            prev = path->count-2;

         if (!OnCurve(path->onoff, prev) ||
             (pts[0].y != pts[prev].y &&
              ABS(pts[0].y - pts[prev].y) < ABS(pts[0].x - pts[prev].x)*8)) {
            if (pts[0].x>pts[prev].x+20) {
               if (pts[prev].x<=pts[prev-1].x)
                  cw[cwi++] = i+path->count-1;
               cw[cwi++] = i;
            } else if (pts[0].x<pts[prev].x-20) {
               if (pts[prev].x>=pts[prev-1].x)
                  ccw[ccwi++] = i+path->count-1; 
               ccw[ccwi++] = i;
            }
         }


         for (j=1; j<path->count && ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS; j++) {
            i++;
            if (!OnCurve(path->onoff, j-1) ||
                (pts[j].y != pts[j-1].y &&
                 ABS(pts[j].y - pts[j-1].y) < ABS(pts[j].x - pts[j-1].x)*8)) {
               if (pts[j].x>pts[j-1].x+20) {
                  if (!cwi || cw[cwi-1]!=i-1)
                     cw[cwi++] = i-1;
                  cw[cwi++] = i;
               } else if (pts[j].x<pts[j-1].x-20) {
                  if (!ccwi || ccw[ccwi-1]!=i-1)
                     ccw[ccwi++] = i-1;
                  ccw[ccwi++] = i;
               }
            }
         }
         i++;
      }


      if (ccwi>=MAXTHINPNTS || cwi>=MAXTHINPNTS) {
         LogError(MSG_WARNING, MSG_DIAG, NULL);
      }


      /* Any points to shift? */
      if (cwi || ccwi) {
         pgm[(*pc)++] = op_svcta + SUBOP_Y;


         for (n=0; n<cwi; n=m) {
            for (m=n+1; m<cwi && cw[m]==cw[m-1]+1; m++);
            pgm[(*pc)++] = op_pushb1 + 2;
            pgm[(*pc)++] = cw[n];
            pgm[(*pc)++] = (UBYTE)(m-n-1);
            pgm[(*pc)++] = TTFUN_RANGE;
            pgm[(*pc)++] = op_loopcall;
         }
         pgm[(*pc)++] = op_pushb1+2;
         pgm[(*pc)++] = STORAGE_DIAG;
         pgm[(*pc)++] = cwi;
         pgm[(*pc)++] = TTFUN_SHIFT2;
         pgm[(*pc)++] = op_call;



         /************ Shift back the left side of the glyph. */


         for (n=0; n<ccwi; n=m) {
            for (m=n+1; m<ccwi && ccw[m]==ccw[m-1]+1; m++);
            pgm[(*pc)++] = op_pushb1 + 2;
            pgm[(*pc)++] = (UBYTE)ccw[n];
            pgm[(*pc)++] = (UBYTE)(m-n-1);
            pgm[(*pc)++] = TTFUN_RANGE;
            pgm[(*pc)++] = op_loopcall;
         }
         pgm[(*pc)++] = op_pushb1+2;
         pgm[(*pc)++] = STORAGE_DIAG;
         pgm[(*pc)++] = (UBYTE)ccwi;
         pgm[(*pc)++] = TTFUN_SHIFT1;
         pgm[(*pc)++] = op_call;
      }
#endif

      pgm[(*pc)++] = op_eif;
   }

   /* Args + num of args + function number. */
   return (short)(MAX(cwi, ccwi)+2); 
}




/***
** Function: ScaleDown3
**
** Description:
**   This function generates the TT instructions
**   that will scale down points 3%.
***/
void ScaleDown3(const Extremas *extr, const short xcnt, 
                UBYTE *pgm, short *pc,
                short *args, short *pcd)
{
   short i,j,offset, opc, opcd;

   /* Remember the state of the stacks. */
   opc = (*pc);
   opcd = (*pcd);

   args[(*pcd)++] = TTFUN_SCALE3;

   offset = (*pcd)++;
   args[offset] = 0;
   for (i=0; i<xcnt; i++) {
      if ((extr[i].rp1==UNDEF || extr[i].rp2==UNDEF)) {
         for (j=0; j<extr[i].n; j++) {
            args[(*pcd)++] = extr[i].pts[j];
         }
         args[offset] = (short)(args[offset] + extr[i].n);
      }
   }
   if (args[offset]>0) {
      pgm[(*pc)++] = op_call;
   } else {
      /* Back track. */
      (*pc) = opc;
      (*pcd) = opcd;
   }
}


/***
** Function: EmitIP
**
** Description:
**   This function generates the TT instructions
**   that will interpolate points that are either
**   within or between stem sides.
***/
void EmitIP(const Extremas *extr, const short xcnt, 
            UBYTE *pgm, short *pc,
            short *args, short *pcd,
            const short scale3offset)
{
   short i,j,num;
   short ones[MAXIP], twoes[MAXIP], nths[MAXIP];
   short cnt1, cnt2, cntn;


   /*lint -e530 -e644 */
   /* Shift extrems. */
   cnt1 = 0; cnt2 = 0; cntn = 0; num = 0;
   for (i=0; i<xcnt; i++) {
      short rp;

      /* Skip interpolations. */
      if (extr[i].rp1!=UNDEF && extr[i].rp2!=UNDEF)
         continue;

      /* Set the reference points. */
      if (extr[i].rp1!=UNDEF) {
         rp = (short)(extr[i].rp1+scale3offset);
      }  else {
         rp = (short)(extr[i].rp2+scale3offset);
      }

      if (extr[i].n==1) {
         if ((cnt1+2)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_SHP1;
            args[(*pcd)++] = (short)(cnt1/2);
            for (j=0; j<cnt1; j++)
               args[(*pcd)++] = (short)ones[j];
            cnt1 = 0;
         }
         ones[cnt1++] = rp;
         ones[cnt1++] = extr[i].pts[0];
      } else if (extr[i].n==2) {
         if ((cnt2+3)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_SHP2;
            args[(*pcd)++] = (short)(cnt2/3);
            for (j=0; j<cnt2; j++)
               args[(*pcd)++] = (short)twoes[j];
            cnt2 = 0;
         }
         twoes[cnt2++] = rp;
         twoes[cnt2++] = extr[i].pts[0];
         twoes[cnt2++] = extr[i].pts[1];
      } else {
         if ((cntn+2+extr[i].n)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_SHPN;
            args[(*pcd)++] = num;
            for (j=0; j<cntn; j++)
               args[(*pcd)++] = (short)nths[j];
            cntn = 0;
            num = 0;
         }
         nths[cntn++] = rp;
         nths[cntn++] = extr[i].n;
         for (j=0; j<extr[i].n; j++) {
            nths[cntn++] = extr[i].pts[j];
         }
         num++;
      }
   }

   if (cnt1) {
      if (cnt1>2) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_SHP1;
         args[(*pcd)++] = (short)(cnt1/2);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_SHP1;
      }
      for (i=0; i<cnt1; i++)
         args[(*pcd)++] = ones[i];
   }
   if (cnt2) {
      if (cnt2>3) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_SHP2;
         args[(*pcd)++] = (short)(cnt2/3);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_SHP2;
      }
      for (i=0; i<cnt2; i++)
         args[(*pcd)++] = twoes[i];
   }
   if (cntn) {
      if (num>1) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_SHPN;
         args[(*pcd)++] = num;
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_SHPN;
      }
      for (i=0; i<cntn; i++)
         args[(*pcd)++] = (short)nths[i];
   }


   /* Interpolate the extrems. */
   cnt1 = 0; cnt2 = 0; cntn = 0; num = 0;
   for (i=0; i<xcnt; i++) {

      /* Skip interpolations. */
      if (extr[i].rp1==UNDEF || extr[i].rp2==UNDEF)
         continue;

      if (extr[i].n==1) {
         if ((cnt1+3)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_IP1;
            args[(*pcd)++] = (short)(cnt1/2);
            for (j=0; j<cnt1; j++)
               args[(*pcd)++] = (short)ones[j];
            cnt1 = 0;
         }
         ones[cnt1++] = extr[i].rp1;
         ones[cnt1++] = extr[i].rp2;
         ones[cnt1++] = extr[i].pts[0];
      } else if (extr[i].n==2) {
         if ((cnt2+4)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_IP2;
            args[(*pcd)++] = (short)(cnt2/3);
            for (j=0; j<cnt2; j++)
               args[(*pcd)++] = (short)twoes[j];
            cnt2 = 0;
         }
         twoes[cnt2++] = extr[i].rp1;
         twoes[cnt2++] = extr[i].rp2;
         twoes[cnt2++] = extr[i].pts[0];
         twoes[cnt2++] = extr[i].pts[1];
      } else {
         if ((cntn+3+extr[i].n)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_IPN;
            args[(*pcd)++] = num;
            for (j=0; j<cntn; j++)
               args[(*pcd)++] = (short)nths[j];
            cntn = 0;
            num = 0;
         }
         nths[cntn++] = extr[i].rp1;
         nths[cntn++] = extr[i].rp2;
         nths[cntn++] = extr[i].n;
         for (j=0; j<extr[i].n; j++) {
            nths[cntn++] = extr[i].pts[j];
         }
         num++;
      }
   }

   if (cnt1) {
      if (cnt1>3) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_IP1;
         args[(*pcd)++] = (short)(cnt1/3);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_IP1;
      }
      for (i=0; i<cnt1; i++)
         args[(*pcd)++] = (short)ones[i];
   }
   if (cnt2) {
      if (cnt2>4) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_IP2;
         args[(*pcd)++] = (short)(cnt2/4);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_IP2;
      }
      for (i=0; i<cnt2; i++)
         args[(*pcd)++] = (short)twoes[i];
   }
   if (cntn) {
      if (num>1) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_IPN;
         args[(*pcd)++] = num;
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_IPN;
      }
      for (i=0; i<cntn; i++)
         args[(*pcd)++] = (short)nths[i];
   }
   /*lint +e530 +e644 */
}




/***
** Function: EmitVerticalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void EmitVerticalStems(UBYTE *pgm, short *pc, short *args, short *pcd)
{
   pgm[(*pc)++] = op_call;
   args[(*pcd)++] = TTFUN_VERTICAL;
}





/***
** Function: EmitHorizontalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void EmitHorizontalStems(UBYTE *pgm, short *pc, short *args, short *pcd)
{
   pgm[(*pc)++] = op_call;
   args[(*pcd)++] = TTFUN_HORIZONTAL;
}





/***
** Function: EmitVStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a vstem.
***/
errcode EmitVStem(UBYTE *pgm, short *pc,
                  short *args, short *pcd,
                  struct T1Metrics *t1m,
                  const funit width,
                  const funit real_side1,
                  const funit real_side2,
                  const funit side1,
                  const funit side2,
                  const short rp,
                  const enum aligntype align,
                  const short ref)
{
                     errcode status = SUCCESS;
                     short w_storage;

                     if ((w_storage = GetVStemWidth(GetWeight(t1m), width))==NOMEM) {
                        SetError(status = NOMEM);
                     } else {

                        pgm[(*pc)++] = op_call;
                        switch (align) {
                           case at_centered:
                              args[(*pcd)++] = TTFUN_VCENTER;
                              args[(*pcd)++] = (short)real_side1;
                              args[(*pcd)++] = (short)real_side2;
                              args[(*pcd)++] = (short)side1;
                              args[(*pcd)++] = (short)side2;
                              args[(*pcd)++] = (short)((side1+side2)/2);
                              args[(*pcd)++] = rp;
                              args[(*pcd)++] = w_storage;
                              break;

                           case at_relative1:
                              args[(*pcd)++] = TTFUN_RELATIVE1V;
                              args[(*pcd)++] = (short)real_side1;
                              args[(*pcd)++] = (short)real_side2;
                              args[(*pcd)++] = (short)side1;
                              args[(*pcd)++] = (short)side2;
                              args[(*pcd)++] = ref;
                              args[(*pcd)++] = rp;
                              args[(*pcd)++] = w_storage;
                              break;

                           case at_relative2:
                              args[(*pcd)++] = TTFUN_RELATIVE2V;
                              args[(*pcd)++] = (short)real_side1;
                              args[(*pcd)++] = (short)real_side2;
                              args[(*pcd)++] = (short)side1;
                              args[(*pcd)++] = (short)side2;
                              args[(*pcd)++] = ref;
                              args[(*pcd)++] = rp;
                              args[(*pcd)++] = w_storage;
                              break;

                           case at_side1:
                           case at_side2:
                              LogError(MSG_WARNING, MSG_ALIGN, NULL);
                              break;
                        }
                     }

                     return status;
} 




/***
** Function: EmitHStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a hstem.
***/
errcode EmitHStem(UBYTE *pgm, short *pc,
                  short *args, short *pcd,
                  struct T1Metrics *t1m,
                  const funit width,
                  const funit side1,
                  const funit side2,
                  const short rp,
                  const enum aligntype align,
                  const short ref)
{
   errcode status = SUCCESS;
   short w_storage;

   if ((w_storage = GetHStemWidth(GetWeight(t1m), width))==NOMEM) {
      SetError(status = NOMEM);
   } else {

      pgm[(*pc)++] = op_call;
      switch (align) {

         case at_side1:
            args[(*pcd)++] = TTFUN_SIDE1;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_side2:
            args[(*pcd)++] = TTFUN_SIDE2;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_relative1:
            args[(*pcd)++] = TTFUN_RELATIVE1H;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_relative2:
            args[(*pcd)++] = TTFUN_RELATIVE2H;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_centered:
         default:
            args[(*pcd)++] = TTFUN_HCENTER;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = (short)((side1+side2)/2);
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;
      }
   }

   return status;
}






/***
** Function: FamilyCutIn
**
** Description:
**   This function generates a branch in the
**   pre-program. 
***/
USHORT FamilyCutIn(UBYTE *prep,
                   USHORT tp,
                   const short cis)
{
   prep[tp++] = op_mppem;
   if (cis<256) {
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)cis;
   } else {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cis);
      prep[tp++] = LOBYTE(cis);
   }
   prep[tp++] = op_lt;
   prep[tp++] = op_if;

   return tp;
}




/***
** Function: SetProjection
**
** Description:
**   This function generates the TrueType code that
**   changes the projection vector in oblique typefaces.
***/
void SetProjection(UBYTE *pgm, short *pc,
                   short *args, short *pcd,
                   const funit x, const funit y)
{
   pgm[(*pc)++] = op_call;
   args[(*pcd)++] = TTFUN_OBLIQUE;
   args[(*pcd)++] = (short)y;
   args[(*pcd)++] = (short)x;
}


/***
** Function: AssembleArgs
**
** Description:
**   This function takes a sequence of arguments and
**   assembles them into a sequence of PUSHB1[], PUSHW1[],
**   NPUSHB[] and NPUSHW[] instructions.
***/
void AssembleArgs(short *args, const short pcd, UBYTE *is, short *cnt)
{
   short bytes;
   short i,j;


   if ((args[pcd-1] <= UCHAR_MAX && args[pcd-1]>=0)) {
      bytes = 1;
   } else {
      bytes = 0;
   }

   for (i=0, j=0; j<pcd; i++) {

      /* Pack a sequence of bytes? */
      if (bytes) {
         if ((i-j)>=255 || i==pcd ||
             (args[pcd-i-1]>UCHAR_MAX || args[pcd-i-1]<0)) {
            bytes = 0;
            if ((i-j)<=8) {
               is[(*cnt)++] = (UBYTE)(op_pushb1 + (i-j) - 1);
            } else {
               is[(*cnt)++] = op_npushb;
               is[(*cnt)++] = (UBYTE)(i-j);
            }
            while (j<i)
               is[(*cnt)++] = (UBYTE)args[pcd-1-j++];
         }

         /* Pack a sequence of words? */
      } else {
         if ((i-j)>=255 || i==pcd || 
             (args[pcd-i-1]<=UCHAR_MAX && args[pcd-i-1]>=0)) {
            bytes = 1;
            if ((i-j)<=8) {
               is[(*cnt)++] = (UBYTE)(op_pushw1 + (i-j) - 1);
            } else {
               is[(*cnt)++] = op_npushw;
               is[(*cnt)++] = (UBYTE)(i-j);
            }
            while (j<i) {
               is[(*cnt)++] = HIBYTE(args[pcd-j-1]);
               is[(*cnt)++] = LOBYTE(args[pcd-j-1]);
               j++;
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\ups\cphelp.h ===
#define IDH_HELPFIRST        5000
#define IDH_SYSMENU     (IDH_HELPFIRST + 2000)
#define IDH_MBFIRST     (IDH_HELPFIRST + 2001)
#define IDH_DLG_FONT2   (IDH_HELPFIRST + 2002)
#define IDH_MBLAST      (IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST    (IDH_HELPFIRST + 3000)
#define IDH_SCRNSAVE    (IDH_HELPFIRST + 4000)


#define IDH_SPOOLER_OFFSET 5000

#define IDH_MENU_SCHHELP    (IDH_HELPFIRST + MENU_SCHHELP)
#define IDH_MENU_INDHELP    (IDH_HELPFIRST + MENU_INDHELP)
#define IDH_MENU_USEHELP    (IDH_HELPFIRST + MENU_USEHELP)
#define IDH_MENU_ABOUT      (IDH_HELPFIRST + MENU_ABOUT )
#define IDH_MENU_EXIT       (IDH_HELPFIRST + MENU_EXIT)
#define IDH_CHILD_COLOR     (IDH_HELPFIRST + CHILD_COLOR)
#define IDH_CHILD_PRINTER   (IDH_HELPFIRST + CHILD_PRINTER)
#define IDH_CHILD_FONT      (IDH_HELPFIRST + CHILD_FONT )
#define IDH_CHILD_INTL      (IDH_HELPFIRST + CHILD_INTL )
#define IDH_CHILD_PORTS     (IDH_HELPFIRST + CHILD_PORTS)
#define IDH_CHILD_KEYBOARD  (IDH_HELPFIRST + CHILD_KEYBOARD )
#define IDH_CHILD_MOUSE     (IDH_HELPFIRST + CHILD_MOUSE)
#define IDH_CHILD_DATETIME  (IDH_HELPFIRST + CHILD_DATETIME )
#define IDH_CHILD_DESKTOP   (IDH_HELPFIRST + CHILD_DESKTOP)
#define IDH_CHILD_SOUND     (IDH_HELPFIRST + CHILD_SOUND)
#define IDH_CHILD_NETWORK   (IDH_HELPFIRST + CHILD_NETWORK)
#define IDH_CHILD_SYSTEM    (IDH_HELPFIRST + CHILD_SYSTEM)
#define IDH_CHILD_MIDI      (IDH_HELPFIRST + 122)           // MM midi
#define IDH_CHILD_SND       (IDH_HELPFIRST + 121)           // MM sound
#define IDH_CHILD_DRIVERS   (IDH_HELPFIRST + 120)           // MM drivers

#define IDH_DLG_CONFLICT    (IDH_DLGFIRST + DLG_CONFLICT)
#define IDH_DLG_ADDFILE     (IDH_DLGFIRST + DLG_ADDFILE)
#define IDH_DLG_INTLDATE    (IDH_DLGFIRST + DLG_INTLDATE)
#define IDH_DLG_INTLTIME    (IDH_DLGFIRST + DLG_INTLTIME)
#define IDH_DLG_INTLNUM     (IDH_DLGFIRST + DLG_INTLNUM)
#define IDH_DLG_INTLCUR     (IDH_DLGFIRST + DLG_INTLCUR)
#define IDH_DLG_NETPRINT    (IDH_DLGFIRST + DLG_NETPRN)

#define IDH_DLG_PATTERN     (IDH_DLGFIRST + DLG_PATTERN)
#define IDH_DLG_PORTS2      (IDH_DLGFIRST + DLG_PORTS2)
#define IDH_DLG_PORTS3      (IDH_DLGFIRST + DLG_PORTS3)
#define IDH_DLG_MOUSE       (IDH_DLGFIRST + DLG_MOUSE)

#define IDH_DLG_COLORSAVE   (IDH_DLGFIRST + DLG_COLORSAVE)
#define IDH_DLG_COLORDEFINE (IDH_DLGFIRST + DLG_COLORDEFINE)
#define IDH_DLG_CONFIGURE   (IDH_DLGFIRST + DLG_CONFIGURE)
#define IDH_DLG_INSTALL     (IDH_DLGFIRST + DLG_INSTALL)
#define IDH_DLG_UNLIST      (IDH_DLGFIRST + DLG_UNLIST)
#define IDH_DLG_REMOVEFONT  (IDH_DLGFIRST + DLG_REMOVEFONT)
#define IDH_DLG_TRUETYPE    (IDH_DLGFIRST + DLG_TRUETYPE)
#define IDH_DLG_BROWSE      (IDH_DLGFIRST + DLG_BROWSE)

#define IDH_DLG_SYSTEM      (IDH_DLGFIRST + DLG_SYSTEM)
#define IDH_DLG_ADDOS       (IDH_DLGFIRST + DLG_ADDOS)

#define IDH_DLG_PREVIOUSCON (IDH_DLGFIRST + DLG_PREVIOUSCON)

// pen win help constants

#define IDH_DLG_ROT              (IDH_DLGFIRST + 200)
#define IDH_DLG_CAL              (IDH_DLGFIRST + 201)
#define IDH_DLG_CAL_ACCEPT       (IDH_DLGFIRST + 202)


// MM midi  dialogs
#define IDH_DLG_MIDI_SETUPEDIT  (IDH_DLGFIRST + 404)
#define IDH_DLG_MIDI_PATCHEDIT  (IDH_DLGFIRST + 504)
#define IDH_DLG_MIDI_KEYEDIT    (IDH_DLGFIRST + 604)
#define IDH_DLG_MIDI_SETUPNEW   (IDH_DLGFIRST + 704)
#define IDH_DLG_MIDI_PATCHNEW   (IDH_DLGFIRST + 804)
#define IDH_DLG_MIDI_KEYNEW     (IDH_DLGFIRST + 904)

// MM sound dialogs
#define IDH_DLG_NEWSND          (IDH_DLGFIRST + 503)

// MM drivers dialogs
#define IDH_DLG_ADD_DRIVERS     (IDH_DLGFIRST + 403)
#define IDH_DLG_INSERT_DISK     (IDH_DLGFIRST + 703)
#define IDH_DLG_ADD_UNKNOWN     (IDH_DLGFIRST + 803)
#define IDH_DLG_FILE_ERROR      (IDH_DLGFIRST + 903)

#define IDH_DLG_CHANGEPASS      (IDH_SCRNSAVE)
#define IDH_DLG_MARQUE          (IDH_SCRNSAVE + 1)
#define IDH_DLG_MYSTIFY         (IDH_SCRNSAVE + 2)
#define IDH_DLG_STARSIM         (IDH_SCRNSAVE + 3)
#define IDH_DLG_MARQUEE_FONT    (IDH_SCRNSAVE + 4)

#define IDH_DLG_PRINTER         (IDH_DLGFIRST + DLG_PRINTER)

// We need to change the help stuff when called by the spooler.
#define IDH_PRINTER               (IDH_DLG_PRINTER + IDH_SPOOLER_OFFSET)
#define IDH_DLG_CONNECT           (IDH_DLG_CONFIGURE + IDH_SPOOLER_OFFSET)
#define IDH_DLG_NETCONNECT        (IDH_DLG_NETPRINT + IDH_SPOOLER_OFFSET)
#define IDH_DLG_PREVCON           (IDH_DLG_PREVIOUSCON + IDH_SPOOLER_OFFSET)
#define IDH_DLG_UNLISTED_PRINTER  (IDH_DLG_UNLIST + IDH_SPOOLER_OFFSET)
// #define IDH_DLG_INSTALL_PRINTER   (IDH_DLG_INSTALL + IDH_SPOOLER_OFFSET)
#define IDH_DLG_COM_SET           (IDH_DLG_PORTS2 + IDH_SPOOLER_OFFSET)                
#define IDH_DLG_ADVANCED_COMSET   (IDH_DLG_PORTS3 + IDH_SPOOLER_OFFSET)                
#define IDH_DLG_PRINTER_BROWSE    (IDH_DLG_BROWSE + IDH_SPOOLER_OFFSET)
#define IDH_DLG_INS_PRINTER_DISK  (IDH_DLG_INSERT_DISK + IDH_SPOOLER_OFFSET)


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\ups\cpl.c ===
/** FILE: cpl.c ************ Module Header ********************************
 *
 *  Initialization module and UPS Control Panel applet procedure.
 *  Additionally, this file also contains the "CPlApplet" procedure which
 *  complies with and services the ".CPL" protocol between the Control
 *  Panel main window procedure and its' applets.
 *
 * History:
 *  12:30 on Tues  23 Apr 1991  -by-  Steve Cathcart   [stevecat]
 *        Took base code from Win 3.1 source
 *  10:30 on Tues  04 Feb 1992  -by-  Steve Cathcart   [stevecat]
 *        Updated code to latest Win 3.1 sources
 *  10:00 on Thur Aug 27 1992   -by-  Congpa You       [congpay]
 *        Specialize the code for UPS.
 ***************************************************************************/
//==========================================================================
//                                Include files
//==========================================================================
#include "ups.h"
#include "cpl.h"

//==========================================================================
//                            Local Definitions
//==========================================================================

typedef struct {
    int idIcon;
    int idName;
    int idInfo;
    int idChild;
    BOOL bEnabled;
    DWORD dwContext;
    PSTR pszHelp;
} APPLET_INFO;

//==========================================================================
//                            External Declarations
//==========================================================================
/*  functions  */
extern INT_PTR APIENTRY UPSDlg     (HWND, UINT, WPARAM, LPARAM);
extern BOOL RegisterArrowClass(HANDLE);


//==========================================================================
//                            Data Declarations
//==========================================================================
HANDLE  hModule = NULL;

char szSetupInfPath[PATHMAX];

char szErrLS[133];
char szErrMem[133];
char szCtlPanel[30];

char szWinCom[PATHMAX];             /* Path to WIN.COM directory */
char szSystemIniPath[PATHMAX];      /* Path to SYSTEM.INI */
char szCtlIni[PATHMAX];             /* Path to CONTROL.INI */

char szCONTROLINI[]  = "control.ini";

// REVIEW change to lower case.
char szSYSTEMINI[]    = "SYSTEM.INI";
char szSETUPINF[]     = "SETUP.INF";

DWORD   dwContext = 0L;

char szControlHlp[] = "control.hlp";

UINT wHelpMessage;

char szCplApplet[] = "CPlApplet";

APPLET_INFO applets[] = {
    { UPSICON   , CHILDREN     , INFO     , CHILD_UPS   , TRUE,
      IDH_CHILD_UPS   , szControlHlp },
};

#define NUM_APPLETS (sizeof(applets)/sizeof(applets[0]))


//==========================================================================
//                            Local Function Prototypes
//==========================================================================

void RunApplet(HWND hwnd, int cmd);


//==========================================================================
//                                Functions
//==========================================================================

//  Win32 NT Dll Initialization procedure

BOOL DllInitialize(
IN PVOID hmod,
IN ULONG ulReason,
IN PCONTEXT pctx OPTIONAL)
{
    if (ulReason != DLL_PROCESS_ATTACH)
    {
        return TRUE;
    }
    else
    {
        hModule = hmod;
    }

    return TRUE;

    UNREFERENCED_PARAMETER(pctx);
}


//---------------------------------------------------------------------------
BOOL InitControlPanel(HWND hwndParent)
{
    OFSTRUCT os;

    if (!RegisterArrowClass(hModule))
    {
        return FALSE;
    }

    LoadString (hModule,   ERRMEM,     szErrMem,       sizeof (szErrMem));
    LoadString (hModule,   LSFAIL,     szErrLS,        sizeof (szErrLS));
    LoadString (hModule,   CPCAPTION,  szCtlPanel,     sizeof (szCtlPanel));

    wsprintf (szSystemIniPath, "%s%s", (LPSTR)szWinCom, (LPSTR)szSYSTEMINI);
    wsprintf (szCtlIni,        "%s%s", (LPSTR)szWinCom, (LPSTR)szCONTROLINI);

    if (OpenFile (szSETUPINF, &os, OF_EXIST) >= 0)
        strcpy (szSetupInfPath, os.szPathName);
    else
        strcpy (szSetupInfPath, szSETUPINF);    // not found, use this anyway?

    wHelpMessage = RegisterWindowMessage("ShellHelp");

    return TRUE;

    UNREFERENCED_PARAMETER(hwndParent);
}


void TermControlPanel()
{
    UnRegisterArrowClass (hModule);
    return;
}


LONG APIENTRY CPlApplet(HWND hWnd, UINT Msg, LPARAM lParam1, LPARAM lParam2)
{
    int i, count;
    LPNEWCPLINFO lpCPlInfo;
    LPCPLINFO lpOldCPlInfo;
    static iInitCount = 0;

    switch (Msg)
    {
    case CPL_INIT:
        if (!iInitCount)
        {
            if (!InitControlPanel(hWnd))
                return FALSE;
        }

        iInitCount++;
        return TRUE;

    case CPL_GETCOUNT:
        for (i = count = 0; i < NUM_APPLETS; i++)
            if (applets[i].bEnabled)
                count++;

        return (LONG)count;

    case CPL_INQUIRE:

        lpOldCPlInfo = (LPCPLINFO)lParam2;

        // find the proper applet not counting those that are disabled
        for (i = count = 0; i < NUM_APPLETS; i++)
        {
            if (applets[i].bEnabled)
            {
                if (count == (int)lParam1)
                    break;
                count++;
            }
        }

        lpOldCPlInfo->idIcon = applets[i].idIcon;
        lpOldCPlInfo->idName = applets[i].idName;
        lpOldCPlInfo->idInfo = applets[i].idInfo;
        lpOldCPlInfo->lData = (LONG)applets[i].idChild;
        return TRUE;

    case CPL_NEWINQUIRE:

        lpCPlInfo = (LPNEWCPLINFO)lParam2;

        // find the proper applet not counting those that are disabled
        for (i = count = 0; i < NUM_APPLETS; i++)
        {
            if (applets[i].bEnabled)
            {
                if (count == (int)lParam1)
                    break;
                count++;
            }
        }

        lpCPlInfo->hIcon = LoadIcon(hModule, MAKEINTRESOURCE(applets[i].idIcon));
        LoadString(hModule, applets[i].idName, lpCPlInfo->szName, sizeof(lpCPlInfo->szName));

        if (!LoadString(hModule, applets[i].idInfo, lpCPlInfo->szInfo,
                                sizeof(lpCPlInfo->szInfo)))
            lpCPlInfo->szInfo[0] = 0;

        lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
        lpCPlInfo->lData  = (LONG)applets[i].idChild;
        lpCPlInfo->dwHelpContext = applets[i].dwContext;
        strcpy(lpCPlInfo->szHelpFile, applets[i].pszHelp);

        return TRUE;

    case CPL_DBLCLK:
        dwContext = applets[(int)lParam1].dwContext;
        RunApplet(hWnd, (int)lParam2);
        break;

    case CPL_EXIT:
        iInitCount--;
        if (!iInitCount)
            TermControlPanel();
        break;

    default:
        break;
    }
    return 0L;
}


void RunApplet(HWND hwnd, int cmd)
{
    switch (cmd)
    {
    case CHILD_UPS:
        DialogBox(hModule, MAKEINTRESOURCE(DLG_UPS), hwnd, UPSDlg);
        break;
    }

}


void CPHelp (HWND hWnd)
{
    WinHelp (hWnd, szControlHlp, HELP_CONTEXT, dwContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\ups\memutil.c ===
/* ---File: memutil.c -----------------------------------------------------
 *
 *  Description:
 *    Contains Control Panel memory allocation routines.
 *
 *    This document contains confidential/proprietary information.
 *    Copyright (c) 1990-1992 Microsoft Corporation, All Rights Reserved.
 *
 * Revision History:
 *
 * ---------------------------------------------------------------------- */
/* Notes -

    Global Functions:

        AllocMem () -
        AllocStr () -
        FreeMem () -
        FreeStr () -
        ReallocMem () -
        ReallocStr () -

    Local Functions:

 */
//==========================================================================
//                              Include files
//==========================================================================
// C Runtime
#include <string.h>
#include <memory.h>

// Application specific
#include "ups.h"


LPVOID AllocMem (DWORD cb)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LPDWORD  pMem;
    DWORD    cbNew;
    LPVOID   pRet = NULL;

    cbNew = cb+2*sizeof(DWORD);
    if (cbNew & 3)
        cbNew += sizeof(DWORD) - (cbNew & 3);

//    pMem = (LPDWORD)HeapAlloc (hHeap, 0, cbNew);

    pMem = (LPDWORD)LocalAlloc (LMEM_FIXED, cbNew);
    if (pMem)
    {
        memset (pMem, 0, cbNew);     // This might go later if done in NT
        *pMem = cb;
        *(LPDWORD)((LPTSTR)pMem+cbNew-sizeof(DWORD)) = 0xdeadbeef;

        pRet = (LPVOID)(pMem+1);
    }
    return pRet;
}


BOOL FreeMem (LPVOID pMem, DWORD  cb)
{
    DWORD   cbNew;
    LPDWORD pNewMem;

    if (!pMem)
        return TRUE;

    pNewMem = pMem;
    pNewMem--;

    cbNew = cb+2*sizeof(DWORD);
    if (cbNew & 3)
        cbNew += sizeof(DWORD) - (cbNew & 3);

#ifdef DEBU
    if ((*pNewMem != cb) ||
       (*(LPDWORD)((LPTSTR)pNewMem + cbNew - sizeof(DWORD)) != 0xdeadbeef))
    {
	OutputDebugStringA("Corrupt Memory in Control Panel : %0lx\n");
        DbgBreakPoint();
    }
#endif
    return (((HLOCAL) pNewMem == LocalFree ((LPVOID)pNewMem)));
}

LPTSTR AllocStr (LPTSTR lpStr)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    lpStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
   LPTSTR lpMem;

   if (!lpStr)
      return 0;

   if (lpMem = AllocMem (strlen (lpStr) + sizeof(TCHAR)))
      strcpy (lpMem, lpStr);

   return lpMem;
}


BOOL FreeStr (LPTSTR lpStr)
{
   return lpStr ? FreeMem (lpStr, strlen (lpStr) + sizeof(TCHAR)) : FALSE;
}


BOOL ReallocStr (LPTSTR *plpStr, LPTSTR lpStr)
{
   FreeStr (*plpStr);
   *plpStr = AllocStr (lpStr);

   return TRUE;
}

int MyMessageBox (HWND hWnd, DWORD wText, DWORD wCaption, DWORD wType, ...)
{
    char szText[256+PATHMAX], szCaption[256];
    int ival;
    va_list parg;

    va_start (parg, wType);

    if (wText == LSFAIL)
        goto NoMem;

    if (!LoadString(hModule, wText, szCaption, sizeof (szCaption)))
        goto NoMem;

    wvsprintf(szText, szCaption, parg);

    if (!LoadString(hModule, wCaption, szCaption, sizeof (szCaption)))
        goto NoMem;

    if ((ival = MessageBox(hWnd, szText, szCaption, wType)) == 0)
        goto NoMem;

    return(ival);

NoMem:
    va_end (parg);

    ErrLoadString(hWnd);
    return 0;
}

void ErrLoadString (HWND hParent)
{
    MessageBox (hParent, szErrLS, szCtlPanel, MB_OK | MB_ICONHAND | MB_SYSTEMMODAL);
}

void ErrMemDlg (HWND hParent)
{
    MessageBox (hParent, szErrMem, szCtlPanel, MB_OK | MB_ICONHAND | MB_SYSTEMMODAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\ups\arrow.c ===
/** FILE: arrow.c ********** Module Header ********************************
 *
 * Control panel utility library routines for managing "cpArrow" window
 * class/spinner controls used in applet dialogs.
 *
 * History:
 *  15:30 on Thur  25 Apr 1991  -by-  Steve Cathcart   [stevecat]
 *        Took base code from Win 3.1 source
 *  10:30 on Tues  04 Feb 1992  -by-  Steve Cathcart   [stevecat]
 *        Updated code to latest Win 3.1 sources
 *  12:00 on Fri   07 Aug 1992  -by-  Steve Cathcart   [stevecat]
 *        Implemented new drawing scheme for spinner/arrow control
 *
 *  Copyright (C) 1990-1992 Microsoft Corporation
 *
 *************************************************************************/
//==========================================================================
//                        Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <windowsx.h>

// Application specific
#include "ups.h"

//==========================================================================
//                        Local Definitions
//==========================================================================

//  Offsets to use with GetWindowLong
#define GWL_SPINNERSTATE    0

//  Control state flags.
#define SPINNERSTATE_GRAYED      0x0001
#define SPINNERSTATE_HIDDEN      0x0002
#define SPINNERSTATE_MOUSEOUT    0x0004
#define SPINNERSTATE_UPCLICK     0x0008
#define SPINNERSTATE_DOWNCLICK   0x0010

//  Combination of click states.
#define SPINNERSTATE_CLICKED   (SPINNERSTATE_UPCLICK | SPINNERSTATE_DOWNCLICK)

//  Combination of state flags.
#define SPINNERSTATE_ALL         0x001F

//  Sinner Control color indices
#define SPINNERCOLOR_FACE        0
#define SPINNERCOLOR_ARROW       1
#define SPINNERCOLOR_SHADOW      2
#define SPINNERCOLOR_HIGHLIGHT   3
#define SPINNERCOLOR_FRAME       4

#define CCOLORS                  5

//==========================================================================
//                        External Declarations
//==========================================================================


//==========================================================================
//                        Local Data Declarations
//==========================================================================

/*
 * Macros to change the control state given the state flag(s)
 */
#define StateSet(dwState, wFlags)    (dwState |=  (wFlags))
#define StateClear(dwState, wFlags)  (dwState &= ~(wFlags))
#define StateTest(dwState, wFlags)   (dwState &   (wFlags))


//Array of default colors, matching the order of SPINNERCOLOR_* values.
DWORD rgColorDef[CCOLORS]={
                         COLOR_BTNFACE,             //  SPINNERCOLOR_FACE
                         COLOR_BTNTEXT,             //  SPINNERCOLOR_ARROW
                         COLOR_BTNSHADOW,           //  SPINNERCOLOR_SHADOW
                         COLOR_BTNHIGHLIGHT,        //  SPINNERCOLOR_HIGHLIGHT
                         COLOR_WINDOWFRAME          //  SPINNERCOLOR_FRAME
                         };

BOOL   bArrowTimed = FALSE;
BOOL   bRight;
HANDLE hParent;


//==========================================================================
//                        Local Function Prototypes
//==========================================================================
void Draw3DButtonRect (HDC hDC, HPEN hPenHigh, HPEN hPenShadow, int x1,
                       int y1, int x2, int y2, BOOL fClicked);
LONG SpinnerPaint (HWND hWnd, DWORD dwSpinnerState);


//==========================================================================
//                            Functions
//==========================================================================

/*BOOL OddArrowWindow(HWND hArrowWnd)
{
    HWND hParent;
    RECT rResize;
    BOOL bResize;

// [stevecat] NULL this out for testing new drawing scheme 8/7/92
    return(TRUE);

#ifdef  OLD_CODE
    GetWindowRect(hArrowWnd, (LPRECT) &rResize);
    if (!(bResize = (rResize.right - rResize.left) % 2))
    {
        rResize.right++;
        ScreenToClient(hParent = GetParent(hArrowWnd), (LPPOINT) & rResize.left);
        ScreenToClient(hParent, (LPPOINT) & rResize.right);
        MoveWindow(hArrowWnd, rResize.left, rResize.top,
                             (rResize.right - rResize.left),
                             (rResize.bottom - rResize.top), FALSE);
    }
    return(bResize);
#endif  //  OLD_CODE
}
*/


VOID ArrowTimerProc(HWND hWnd, UINT wMsg, UINT_PTR nID, DWORD dwTime)
{
    WORD  wScroll;
    DWORD dwSpinnerState;

    dwSpinnerState = (DWORD) GetWindowLong (hWnd, GWL_SPINNERSTATE);

    if (StateTest(dwSpinnerState, SPINNERSTATE_CLICKED))
    {
        wScroll = (StateTest(dwSpinnerState, SPINNERSTATE_DOWNCLICK)) ?
                                                    SB_LINEDOWN : SB_LINEUP;
        if (bRight == WM_RBUTTONDOWN)
            wScroll += SB_PAGEUP - SB_LINEUP;

            SendMessage(hParent, WM_VSCROLL,
                        MAKELONG(wScroll, GetWindowLong(hWnd, GWL_ID)),
                        (LPARAM) hWnd);
    }

    //  Don't need to call KillTimer(), because SetTimer will
    //  reset the right one

    SetTimer(hWnd, nID, 50, ArrowTimerProc);

    return ;

    wMsg = wMsg;
    dwTime = dwTime;
}


/*
 * ClickedRectCalc
 *
 * Description:
 *  Calculates the rectangle of the clicked region based on the
 *  state flags SPINNERSTATE_UPCLICK and SPINNERSTATE_DOWNCLICK.
 *
 * Parameter:
 *  hWnd            HWND handle to the control window.
 *  lpRect          LPRECT rectangle structure to fill.
 *
 * Return Value:
 *  void
 *
 */

void ClickedRectCalc(HWND hWnd, DWORD dwState, LPRECT lpRect)
{
    int  cx, cy;

    GetClientRect (hWnd, lpRect);

    cx = lpRect->right  >> 1;
    cy = lpRect->bottom >> 1;

    if (StateTest(dwState, SPINNERSTATE_DOWNCLICK))
        lpRect->top = cy;
    else
        lpRect->bottom = 1+cy;

    return;
}

/*
 * ArrowControlProc
 *
 * Description:
 *
 *  Window Procedure for the Spinner/Arrow custom control.  Handles all
 *  messages like WM_PAINT just as a normal application window would.
 *  State information about the control is maintained ALL drawing is
 *  handled during WM_PAINT message processing.
 *
 */
LRESULT APIENTRY ArrowControlProc(HWND hArrow, UINT message, WPARAM wParam, LPARAM lParam)
{
    WORD    wScroll;
    POINT   pt;
    RECT    rect;
    int     x, y;
    int     cy;
    DWORD   dwSpinnerState, dwState;


    dwSpinnerState = (DWORD) GetWindowLong (hArrow, GWL_SPINNERSTATE);

    switch (message)
    {
    case WM_CREATE:
        dwSpinnerState = 0;
        SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState);
        break;


    case WM_ENABLE:
        //  Handles disabling/enabling case.  Example of a
        //  change-state-and-repaint strategy since we let the
        //  painting code take care of the visuals.

        if (wParam)
            StateClear(dwSpinnerState, SPINNERSTATE_GRAYED);
        else
            StateSet(dwSpinnerState, SPINNERSTATE_GRAYED);

        SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState);

        //  Force a repaint since the control will look different.

        InvalidateRect (hArrow, NULL, TRUE);
        UpdateWindow (hArrow);
        break;


    case WM_SHOWWINDOW:
        //  Set or clear the hidden flag. Windows will
        //  automatically force a repaint if we become visible.

        if (wParam)
            StateClear(dwSpinnerState, SPINNERSTATE_HIDDEN);
        else
            StateSet(dwSpinnerState, SPINNERSTATE_HIDDEN);

        SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState);
        break;


    case WM_CANCELMODE:
        //  IMPORTANT MESSAGE!  WM_CANCELMODE means that a
        //  dialog or some other modal process has started.
        //  we must make sure that we cancel any clicked state
        //  we are in, kill the timers, and release the capture.

        StateClear(dwSpinnerState, SPINNERSTATE_CLICKED);
        if (bArrowTimed)
        {
            SendMessage (hParent, WM_VSCROLL, MAKELONG(SB_ENDSCROLL,
                           GetWindowLong (hArrow, GWL_ID)), (LPARAM) hArrow);
            KillTimer (hArrow, GetWindowLong (hArrow, GWL_ID));
            bArrowTimed = FALSE;
        }
        ReleaseCapture();
        break;

    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
        //  When we get a mouse down message, we know that the mouse
        //  is over the control.  We then do the following steps
        //  to set up the new state:
        //   1.  Hit-test the coordinates of the click to
        //       determine in which half the click occurred.
        //   2.  Set the appropriate SPINNERSTATE_*CLICK state
        //       and repaint that clicked half.  This is another
        //       example of a change-state-and-repaint strategy.
        //   3.  Send an initial scroll message.
        //   4.  Set the mouse capture.
        //   5.  Set the initial delay timer before repeating
        //       the scroll message.

        if (bRight)
            break;

        bRight = message;

        hParent = GetParent (hArrow);

        //  Get the mouse coordinates.
        x = GET_X_LPARAM(lParam);
        y = GET_Y_LPARAM(lParam);

        //  Only need to hit-test the upper half
        //  Then change-state-and-repaint

        GetClientRect (hArrow, &rect);
        cy = rect.bottom >> 1;

        if (y > cy)
        {
            StateSet(dwSpinnerState, SPINNERSTATE_DOWNCLICK);
            rect.top = cy;
            wScroll = SB_LINEDOWN;
        }
        else
        {
            StateSet(dwSpinnerState, SPINNERSTATE_UPCLICK);
            rect.bottom = cy + 1;
            wScroll = SB_LINEUP;
        }

        SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState);

        InvalidateRect (hArrow, &rect, TRUE);
        UpdateWindow (hArrow);

        SetCapture (hArrow);

        //  Process SHIFT key state along with button message

        if (wParam & MK_SHIFT)
        {
            if (message != WM_RBUTTONDOWN)
                wScroll += (WORD) (SB_TOP - SB_LINEUP);
            else
                wScroll += (WORD) (SB_THUMBPOSITION - SB_LINEUP);
        }
        else
        {
            if (message == WM_RBUTTONDOWN)
                wScroll += SB_PAGEUP - SB_LINEUP;

            bArrowTimed = SetTimer (hArrow, GetWindowLong (hArrow, GWL_ID),
                                    200, ArrowTimerProc) != 0;
        }
        SendMessage (hParent, WM_VSCROLL, MAKELONG(wScroll,
                              GetWindowLong (hArrow, GWL_ID)), (LONG_PTR) hArrow);
        break;

    case WM_MOUSEMOVE:
        //  On WM_MOUSEMOVE messages we want to know if the mouse
        //  has moved out of the control when the control is in
        //  a clicked state.  If the control has not been clicked,
        //  then we have nothing to do.  Otherwise we want to set
        //  the SPINNERSTATE_MOUSEOUT flag and repaint so the button
        //  visually comes up.

        if (!StateTest(dwSpinnerState, SPINNERSTATE_CLICKED))
            break;

        //  Save copy of original state
        dwState = dwSpinnerState;

        //  Get the mouse coordinates.
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        //  Get the area we originally clicked and the new POINT
        ClickedRectCalc (hArrow, dwSpinnerState, &rect);

        //  Hit-Test the rectange and change the state if necessary.
        if (PtInRect(&rect, pt))
            StateClear(dwSpinnerState, SPINNERSTATE_MOUSEOUT);
        else
            StateSet(dwSpinnerState, SPINNERSTATE_MOUSEOUT);

        SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState);

        //  If the state changed, repaint the appropriate part of
        //  the control.
        if (dwState != dwSpinnerState)
        {
            InvalidateRect (hArrow, &rect, TRUE);
            UpdateWindow (hArrow);
        }

        break;


    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
        //  A mouse button up event is much like WM_CANCELMODE since
        //  we have to clean out whatever state the control is in:
        //   1.  Kill any repeat timers we might have created.
        //   2.  Release the mouse capture.
        //   3.  Clear the clicked states and repaint, another example
        //       of a change-state-and-repaint strategy.

        if ((UINT) (bRight - WM_LBUTTONDOWN + WM_LBUTTONUP) == message)
        {
            bRight = 0;
            ReleaseCapture();

            if (bArrowTimed)
            {
                SendMessage (hParent, WM_VSCROLL, MAKELONG(SB_ENDSCROLL,
                               GetWindowLong (hArrow, GWL_ID)), (LPARAM) hArrow);
                KillTimer (hArrow, GetWindowLong (hArrow, GWL_ID));
                bArrowTimed = FALSE;
            }

            //  Repaint if necessary, only if we are clicked AND the mouse
            //  is still in the boundaries of the control.

            if (StateTest(dwSpinnerState, SPINNERSTATE_CLICKED) &&
                StateTest(dwSpinnerState, ~SPINNERSTATE_MOUSEOUT))
            {
                //  Calculate the rectangle before clearing states.
                ClickedRectCalc (hArrow, dwSpinnerState, &rect);

                //  Clear the states so we repaint properly.
                StateClear(dwSpinnerState, SPINNERSTATE_CLICKED | SPINNERSTATE_MOUSEOUT);

                SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState);
                InvalidateRect (hArrow, &rect, TRUE);
                UpdateWindow (hArrow);
            }
        }
        break;


    case WM_PAINT:
        return SpinnerPaint (hArrow, dwSpinnerState);


    default:
        return (DefWindowProc (hArrow, message, wParam, lParam));
        break;
    }
    return(0L);
}


/*
 * SpinnerPaint
 *
 * Description:
 *
 *  Handles all WM_PAINT messages for the control and paints
 *  the control for the current state, whether it be clicked
 *  or disabled.
 *
 * Parameters:
 *  hWnd            HWND Handle to the control.
 *  dwSpinnerState  DWORD Spinner control status flags
 *
 * Return Value:
 *  LONG            0L.
 */

LONG SpinnerPaint (HWND hWnd, DWORD dwSpinnerState)
{
    PAINTSTRUCT ps;
    LPRECT      lpRect;
    RECT        rect;
    HDC         hDC;
    COLORREF    rgCr[CCOLORS];
    HPEN        rgHPen[CCOLORS];
    int         iColor;

    HBRUSH      hBrushArrow;
    HBRUSH      hBrushFace;
    HBRUSH      hBrushBlack;

    POINT       rgpt1[3];
    POINT       rgpt2[3];

    int         xAdd1=0, yAdd1=0;
    int         xAdd2=0, yAdd2=0;

    int         cx,  cy;        //  Whole dimensions
    int         cx2, cy2;       //  Half dimensions
    int         cx4, cy4;       //  Quarter dimensions

    lpRect = &rect;

    hDC = BeginPaint (hWnd, &ps);
    GetClientRect (hWnd, lpRect);

    //  Get colors that we'll need.  We do not want to cache these
    //  items since we may our top-level parent window may have
    //  received a WM_WININICHANGE message at which time the control
    //  is repainted.  Since this control never sees that message,
    //  we cannot assume that colors will remain the same throughout
    //  the life of the control.

    for (iColor = 0; iColor < CCOLORS; iColor++)
    {
        rgCr[iColor] = GetSysColor (rgColorDef[iColor]);

        rgHPen[iColor] = CreatePen (PS_SOLID, 1, rgCr[iColor]);
    }

    hBrushFace  = CreateSolidBrush (rgCr[SPINNERCOLOR_FACE]);
    if (hBrushFace)
    {
        hBrushArrow = CreateSolidBrush (rgCr[SPINNERCOLOR_ARROW]);
        if (hBrushArrow)
        {
            hBrushBlack = GetStockObject (BLACK_BRUSH);
            if (hBrushBlack)
            {
                //  These values are extremely cheap to calculate for the amount
                //  we are going to use them.

                cx  = lpRect->right  - lpRect->left;
                cy  = lpRect->bottom - lpRect->top;
                cx2 = cx  >> 1;
                cy2 = cy  >> 1;
                cx4 = cx2 >> 1;
                cy4 = cy2 >> 1;

                //  If one half is depressed, set the x/yAdd varaibles that we use
                //  to shift the small arrow image down and right.

                if (!StateTest(dwSpinnerState, SPINNERSTATE_MOUSEOUT))
                {
                    if (StateTest(dwSpinnerState, SPINNERSTATE_UPCLICK))
                    {
                        xAdd1 = 1;
                        yAdd1 = 1;
                    }
                    else if (StateTest(dwSpinnerState, SPINNERSTATE_DOWNCLICK))
                    {
                        xAdd2 = 1;
                        yAdd2 = 1;
                    }
                }

                //  Draw the face color and the outer frame
                SelectObject (hDC, hBrushFace);
                SelectObject (hDC, rgHPen[SPINNERCOLOR_FRAME]);

                Rectangle (hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);

                //  Draw the horizontal center line.
                MoveToEx (hDC, 0, cy2, NULL);
                LineTo (hDC, cx, cy2);

                //  We do one of three modifications for drawing the borders:
                //   1) Both halves un-clicked.
                //   2) Top clicked,   bottom unclicked.
                //   3) Top unclicked, bottom clicked.
                //
                //  Case 1 is xAdd1==xAdd2==0
                //  Case 2 is xAdd1==1, xAdd2=0
                //  Case 3 is xAdd1==0, xAdd2==1

                //  Draw top and bottom buttons borders.
                Draw3DButtonRect (hDC, rgHPen[SPINNERCOLOR_HIGHLIGHT],
                                  rgHPen[SPINNERCOLOR_SHADOW],
                                  0,  0,  cx-1, cy2,  (BOOL) xAdd1);

                Draw3DButtonRect (hDC, rgHPen[SPINNERCOLOR_HIGHLIGHT],
                                  rgHPen[SPINNERCOLOR_SHADOW],
                                  0, cy2, cx-1, cy-1, (BOOL) xAdd2);


                //  Select default line color.
                SelectObject (hDC, rgHPen[SPINNERCOLOR_ARROW]);

                //  Draw the arrows depending on the enable state.
                if (StateTest (dwSpinnerState, SPINNERSTATE_GRAYED))
                {
                    //  Draw arrow color lines in the upper left of the
                    //  top arrow and on the top of the bottom arrow.
                    //  Pen was already selected as a default.

                    MoveToEx (hDC, cx2,   cy4-2, NULL);      //Top arrow
                    LineTo   (hDC, cx2-3, cy4+1);
                    MoveToEx (hDC, cx2-3, cy2+cy4-2, NULL);  //Bottom arrow
                    LineTo   (hDC, cx2+3, cy2+cy4-2);

                    //  Draw highlight color lines in the bottom of the
                    //  top arrow and on the lower right of the bottom arrow.

                    SelectObject (hDC, rgHPen[SPINNERCOLOR_HIGHLIGHT]);
                    MoveToEx (hDC, cx2-3, cy4+1, NULL);      //Top arrow
                    LineTo   (hDC, cx2+3, cy4+1);
                    MoveToEx (hDC, cx2+3, cy2+cy4-2, NULL);  //Bottom arrow
                    LineTo   (hDC, cx2,   cy2+cy4+1);
                    SetPixel (hDC, cx2,   cy2+cy4+1, rgCr[SPINNERCOLOR_HIGHLIGHT]);
                }
                else
                {
                    //  Top arrow polygon
                    rgpt1[0].x = xAdd1 + cx2;
                    rgpt1[0].y = yAdd1 + cy4 - 2;
                    rgpt1[1].x = xAdd1 + cx2 - 3;
                    rgpt1[1].y = yAdd1 + cy4 + 1;
                    rgpt1[2].x = xAdd1 + cx2 + 3;
                    rgpt1[2].y = yAdd1 + cy4 + 1;

                    //  Bottom arrow polygon
                    rgpt2[0].x = xAdd2 + cx2;
                    rgpt2[0].y = yAdd2 + cy2 + cy4 + 1;
                    rgpt2[1].x = xAdd2 + cx2 - 3;
                    rgpt2[1].y = yAdd2 + cy2 + cy4 - 2;
                    rgpt2[2].x = xAdd2 + cx2 + 3;
                    rgpt2[2].y = yAdd2 + cy2 + cy4 - 2;

                    //  Draw the arrows
                    SelectObject (hDC, hBrushArrow);
                    Polygon (hDC, (LPPOINT)rgpt1, 3);
                    Polygon (hDC, (LPPOINT)rgpt2, 3);
                }

                //  Clean up
                EndPaint(hWnd, &ps);
            }
            DeleteObject (hBrushArrow);
        }
        DeleteObject (hBrushFace);
    }

    for (iColor = 0; iColor < CCOLORS; iColor++)
    {
        if (rgHPen[iColor])
            DeleteObject (rgHPen[iColor]);
    }

    return 0L;
}


/*
 * Draw3DButtonRect
 *
 * Description:
 *  Draws the 3D button look within a given rectangle.  This rectangle
 *  is assumed to be bounded by a one pixel black border, so everything
 *  is bumped in by one.
 *
 * Parameters:
 *  hDC         DC to draw to.
 *  hPenHigh    HPEN highlight color pen.
 *  hPenShadow  HPEN shadow color pen.
 *  x1          int Upper left corner x.
 *  y1          int Upper left corner y.
 *  x2          int Lower right corner x.
 *  y2          int Lower right corner y.
 *  fClicked    BOOL specifies if the button is down or not (TRUE==DOWN)
 *
 * Return Value:
 *  void
 *
 */

void Draw3DButtonRect (HDC hDC, HPEN hPenHigh, HPEN hPenShadow, int x1,
                       int y1, int x2, int y2, BOOL fClicked)
{
    HPEN  hPenOrg;

    //  Shrink the rectangle to account for borders.
    x1+=1;
    x2-=1;
    y1+=1;
    y2-=1;

    hPenOrg = SelectObject (hDC, hPenShadow);

    if (fClicked)
    {
        //  Shadow on left and top edge when clicked.
        MoveToEx (hDC, x1, y2, NULL);
        LineTo (hDC, x1, y1);
        LineTo (hDC, x2+1, y1);
    }
    else
    {
        //  Lowest shadow line.
        MoveToEx (hDC, x1, y2, NULL);
        LineTo (hDC, x2, y2);
        LineTo (hDC, x2, y1-1);

        //  Upper shadow line.
        MoveToEx (hDC, x1+1, y2-1, NULL);
        LineTo (hDC, x2-1, y2-1);
        LineTo (hDC, x2-1, y1);

        SelectObject (hDC, hPenHigh);

        //  Upper highlight line.
        MoveToEx (hDC, x1, y2-1, NULL);
        LineTo (hDC, x1, y1);
        LineTo (hDC, x2, y1);
    }

    if (hPenOrg)
        SelectObject (hDC, hPenOrg);

    return;
}


BOOL RegisterArrowClass (HANDLE hModule)
{
    WNDCLASS wcArrow;

    wcArrow.lpszClassName = "upsArrow";
    wcArrow.hInstance     = hModule;
    wcArrow.lpfnWndProc   = ArrowControlProc;
    wcArrow.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcArrow.hIcon         = NULL;
    wcArrow.lpszMenuName  = NULL;
    wcArrow.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wcArrow.style         = CS_HREDRAW | CS_VREDRAW;
    wcArrow.cbClsExtra    = 0;
    wcArrow.cbWndExtra    = sizeof(DWORD);

    return(RegisterClass((LPWNDCLASS) &wcArrow));
}


VOID UnRegisterArrowClass (HANDLE hModule)
{
    UnregisterClass("upsArrow", hModule);
}


/*
short ArrowVScrollProc(wScroll, nCurrent, lpAVS)

wScroll is an SB_* message
nCurrent is the base value to change
lpAVS is a far pointer to the structure containing change amounts
      and limits to be used, along with a flags location for errors

returns a short value of the final amount
        the flags element in the lpAVS struct is
                0 if no problems found
         OVERFLOW set if the change exceeded upper limit (limit is returned)
        UNDERFLOW set if the change exceeded lower limit (limit is returned)
   UNKNOWNCOMMAND set if wScroll is not a known SB_* message

NOTE: Only one of OVERFLOW or UNDERFLOW may be set.  If you send in values
      that would allow both to be set, that's your problem.  Either can
      be set in combination with UNKNOWNCOMMAND (when the command is not
      known and the input value is out of bounds).
*/

short ArrowVScrollProc(short wScroll, short nCurrent, LPARROWVSCROLL lpAVS)
{
    short    nDelta;

/* Find the message and put the relative change in nDelta.  If the
   message is an absolute change, put 0 in nDelta and set nCurrent
   to the value specified.  If the command is unknown, set error
   flag, set nDelta to 0, and proceed through checks.
*/

    switch (wScroll)
    {
    case SB_LINEUP:
        nDelta = lpAVS->lineup;
        break;
    case SB_LINEDOWN:
        nDelta = lpAVS->linedown;
        break;
    case SB_PAGEUP:
        nDelta = lpAVS->pageup;
        break;
    case SB_PAGEDOWN:
        nDelta = lpAVS->pagedown;
        break;
    case SB_TOP:
        nCurrent = lpAVS->top;
        nDelta = 0;
        break;
    case SB_BOTTOM:
        nCurrent = lpAVS->bottom;
        nDelta = 0;
        break;
    case SB_THUMBTRACK:
        nCurrent = lpAVS->thumbtrack;
        nDelta = 0;
        break;
    case SB_THUMBPOSITION:
        nCurrent = lpAVS->thumbpos;
        nDelta = 0;
        break;
    case SB_ENDSCROLL:
        nDelta = 0;
        break;
    default:
        lpAVS->flags = UNKNOWNCOMMAND;
        nDelta = 0;
        break;
    }
    if (nCurrent + nDelta > lpAVS->top)
    {
        nCurrent = lpAVS->top;
        nDelta = 0;
        lpAVS->flags = OVERFLOW;
    }
    else if (nCurrent + nDelta < lpAVS->bottom)
    {
        nCurrent = lpAVS->bottom;
        nDelta = 0;
        lpAVS->flags = UNDERFLOW;
    }
    else
        lpAVS->flags = 0;
    return(nCurrent + nDelta);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\ups\ups.h ===
// NT UPS Applet
#define IDD_UPS_EXISTS              1000
#define IDD_UPS_PORTCB              1001
#define IDD_UPS_PFSIGNAL            1002
#define IDD_UPS_BATTERYLIFE         1003
#define IDD_UPS_BLTEXT1             1004
#define IDD_UPS_BLTEXT2             1005
#define IDD_UPS_RECHARGEPERMINUTE   1006
#define IDD_UPS_RPMTEXT1            1007
#define IDD_UPS_RPMTEXT2            1008
#define IDD_UPS_LOWBATTERY          1009
#define IDD_UPS_TURNOFF             1010
#define IDD_UPS_FIRSTWARNING        1012
#define IDD_UPS_WARNINGINTERVAL     1013
#define IDD_UPS_PFSIGNALHIGH        1014
#define IDD_UPS_PFSIGNALLOW         1015
#define IDD_UPS_LOWBATTERYHIGH      1016
#define IDD_UPS_LOWBATTERYLOW       1017
#define IDD_UPS_TURNOFFHIGH         1018
#define IDD_UPS_TURNOFFLOW          1019
#define IDD_UPS_TEXT                1020
#define IDD_UPS_SIGN                1021
#define IDD_UPS_FWTEXT1             1022
#define IDD_UPS_FWTEXT2             1023
#define IDD_UPS_WITEXT1             1024
#define IDD_UPS_WITEXT2             1025
#define IDD_UPS_UPSGROUP            1026
#define IDD_UPS_BLEDIT              1027
#define IDD_UPS_RPMEDIT             1028
#define IDD_UPS_FWEDIT              1029
#define IDD_UPS_WIEDIT              1030
#define IDD_UPS_CHARACTER           1031
#define IDD_UPS_SERVICE             1032
#define IDD_UPS_STATUS_TITLE        1033
#define IDD_UPS_STATUS              1034
#define IDD_UPS_BLANKGROUP          1035
#define IDD_UPS_COMMANDFILE         1036
#define IDD_UPS_FILETEXT            1037
#define IDD_UPS_FILENAME            1038

#define UPS_INSTALLED               0x00000001
#define UPS_POWERFAILSIGNAL         0x00000002
#define UPS_LOWBATTERYSIGNAL        0x00000004
#define UPS_CANTURNOFF              0x00000008
#define UPS_POWERFAIL_LOW           0x00000010
#define UPS_LOWBATTERY_LOW          0x00000020
#define UPS_TURNOFF_LOW             0x00000040
#define UPS_COMMANDFILE             0X00000080

#define UPSICON      100
#define CHILD_UPS       100
#define IDH_CHILD_UPS   (IDH_HELPFIRST + 200)
#define DLG_UPS       100

#define DEFAULTBATTERYLIFE          2
#define DEFAULTRECHARGEPERMINUTE    100
#define DEFAULTFIRSTWARNING         5
#define DEFAULTWARNINGINTERVAL      120

#define UPS_STATUS_ERROR            31
#define UPS_OPTIONS_ERROR           32
#define UPS_ACCESS_ERROR            33
#define UPS_REGISTRY_ERROR          34
#define UPS_SERVICE_ERROR           35
#define UPS_START_MSG               36
#define UPS_FW_WARNING              37
#define UPS_DELAY_WARNING           38
#define UPS_RESTART_MSG             39
#define UPS_STOP_MSG                40
#define UPS_FWRange                 41
#define UPS_WIRange                 42
#define UPS_BLRange                 43
#define UPS_RPMRange                44
#define UPS_PENDING_MSG             45
#define UPS_STARTFAIL_MSG           46
#define UPS_STOPFAIL_MSG            47
#define UPS_UNKNOWNSTATE_MSG        49
#define UPS_INVALID_PATH            50
#define UPS_INVALID_FILENAME        51
#define UPS_FILE_NOT_EXIST          52
#define UPS_CANT_FIND_SYSDIR        53

#define SERVICE_ACCESS_DENIED       0
/* INCLUDE FILES */

#include <windows.h>

/* DEFINATION FILES */
#define IDH_HELPFIRST        5000
#define LSFAIL               10
#define CPCAPTION            11
#define ERRMEM               12
#define _STOPPED             20
#define _START_PENDING       21
#define _STOP_PENDING        22
#define _RUNNING             23
#define _CONTINUE_PENDING    24
#define _PAUSE_PENDING       25
#define _PAUSED              26
#define _UNKNOWN             27
#define CHILDREN             48
#define INFO                 600
#define IDD_HELP             119
#define MAX_LDF_SEP          4
#define MENU_INDHELP         40

/* CONSTANT USED BY UPS.C */
#define KEYBZ 4096
#define SHORTBZ 16
#define MIDBZ 256
#define LONGBZ 1024
#define MASK 0x0E

typedef struct tagLDF {
  WORD Leadin;
  char LeadinSep[MAX_LDF_SEP];
  WORD Order[3];
  char Sep[2][MAX_LDF_SEP];
  } LDF;

typedef LDF NEAR *PLDF;

#define PATHMAX 158        /* path length max - used for Get...Directory() calls */
#define PORTLEN 128        /* COM port string lenght.
#define DESCMAX 129          /* max description in newexe header */
#define MODNAMEMAX 20       /* max module name in newexe header */

extern HANDLE hModule;
extern char szErrMem[133];
extern char szErrLS[133];
extern char szCtlPanel[30];
extern UINT     wHelpMessage;           // stuff for help

#ifndef NOARROWS
typedef struct
  {
    short lineup;             /* lineup/down, pageup/down are relative */
    short linedown;           /* changes.  top/bottom and the thumb    */
    short pageup;             /* elements are absolute locations, with */
    short pagedown;           /* top & bottom used as limits.          */
    short top;
    short bottom;
    short thumbpos;
    short thumbtrack;
    BYTE  flags;              /* flags set on return                   */
  } ARROWVSCROLL;
typedef ARROWVSCROLL NEAR     *NPARROWVSCROLL;
typedef ARROWVSCROLL FAR     *LPARROWVSCROLL;

#define UNKNOWNCOMMAND 1
#define OVERFLOW       2
#define UNDERFLOW      4

#endif

/* const used by ups.c */
#define MAXTRIES        3
#define SLEEP_TIME      2500L

typedef int (*PFNGETNAME)(LPSTR pszName, LPSTR pszInf);

/* FUNCTION PROTOTYPES */

/* ups.c */
void HourGlass(BOOL bOn);

/* memutil.c */
void   ErrLoadString (HWND hParent);
int    MyMessageBox (HWND hWnd, DWORD wText, DWORD wCaption, DWORD wType, ...);
LPVOID AllocMem   (DWORD cb);
BOOL   FreeMem    (LPVOID pMem, DWORD  cb);
LPSTR  AllocStr   (LPSTR lpStr);
BOOL   FreeStr    (LPSTR lpStr);
BOOL   ReallocStr (LPSTR *plpStr, LPSTR lpStr);

/* arrow.c */
short ArrowVScrollProc (short wScroll, short nCurrent, LPARROWVSCROLL lpAVS);
BOOL  OddArrowWindow (HWND);
VOID  UnRegisterArrowClass (HANDLE hModule);

/* cpl.c */
extern void  CPHelp (HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\convgrp\convgrp.c ===
/****************************************************************************/
/*                                                                          */
/*  CONVGRP.H -                                                             */
/*                                                                          */
/*      Conversion from Win3.1 16 bit .grp file to NT 32bit .grp files for  */
/*      the Program Manager                                                 */
/*                                                                          */
/*  Created: 10-15-92   Johanne Caron                                       */
/*                                                                          */
/****************************************************************************/
#include "convgrp.h"
#include <shellapi.h>
#include <shlapip.h>

#if DBG
void DbgPrint(char *, ...);
#define KdPrint(_x_) DbgPrint _x_
#else
#define KdPrint(_x_)
#endif

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MyDwordAlign() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

WORD MyDwordAlign(int wStrLen)
{
    return ((WORD)((wStrLen + 3) & ~3));
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SizeofGroup() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

DWORD SizeofGroup(LPGROUPDEF lpgd)
{
    LPPMTAG lptag;
    WORD cbSeg;
    WORD cb;

    cbSeg = (WORD)GlobalSize(lpgd);

    lptag = (LPPMTAG)((LPSTR)lpgd+lpgd->cbGroup);

    if ((WORD)((PCHAR)lptag - (PCHAR)lpgd +MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb))+4) <= cbSeg
        && lptag->wID == ID_MAGIC
        && lptag->wItem == (int)0xFFFF
        && lptag->cb == (WORD)(MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)) + 4)
        && *(PLONG)lptag->rgb == PMTAG_MAGIC)
      {
        while ((cb = (WORD)((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)))) <= cbSeg)
          {
            if (lptag->wID == ID_LASTTAG)
                return (DWORD)cb;
            (LPSTR)lptag += lptag->cb;
          }
      }
    return lpgd->cbGroup;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddUpGroupFile() -                                                      */
/*                                                                          */
/* Calculates the group file's checksum.                                    */
/*--------------------------------------------------------------------------*/

WORD AddUpGroupFile(LPGROUPDEF lpgd)
{
    LPINT lpW;
    LPINT save_lpW;
    DWORD wSum = 0;
    DWORD cbFile;

    cbFile = SizeofGroup(lpgd);

    for (save_lpW = lpW = (LPINT)lpgd, cbFile >>= 2; cbFile; cbFile--, lpW++)
        wSum += *lpW;

    return (WORD)((DWORD_PTR)lpW - (DWORD_PTR)save_lpW);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddThing() -                                                            */
/*                                                                          */
/* in:                                                                      */
/*	hGroup	group handle, must not be discardable                           */
/*	lpStuff	pointer to data or NULL to init data to zero                    */
/*	cbStuff	count of item (may be 0) if lpStuff is a string                 */
/*                                                                          */
/* Adds an object to the group segment and returns its offset.	Will        */
/* reallocate the segment if necessary.                                     */
/*                                                                          */
/* Handle passed in must not be discardable                                 */
/*                                                                          */
/* returns:                                                                 */
/*	0	failure                                                             */
/*	> 0	offset to thing in the segment                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

WORD AddThing(HANDLE hGroup, LPSTR lpStuff, WORD cbStuff)
{
    WORD        cb;
    LPGROUPDEF  lpgd;
    WORD        offset;
    LPSTR       lpT;
    WORD        cbStuffSize;
    WORD        cbGroupSize;
    WORD        myOffset;

    if (cbStuff == 0xFFFF) {
        return 0xFFFF;
    }

    if (!cbStuff) {
        cbStuff = (WORD)(1 + lstrlen(lpStuff));
    }

    cbStuffSize = (WORD)MyDwordAlign((int)cbStuff);

    lpgd = (LPGROUPDEF)GlobalLock(hGroup);
    cb = (WORD)SizeofGroup(lpgd);
    cbGroupSize = (WORD)MyDwordAlign((int)cb);

    offset = lpgd->cbGroup;
    myOffset = (WORD)MyDwordAlign((int)offset);

    GlobalUnlock(hGroup);

    if (!GlobalReAlloc(hGroup,(DWORD)(cbGroupSize + cbStuffSize), GMEM_MOVEABLE))
        return 0;

    lpgd = (LPGROUPDEF)GlobalLock(hGroup);

    /*
     * Slide the tags up
     */
    memmove((LPSTR)lpgd + myOffset + cbStuffSize, (LPSTR)lpgd + myOffset,
            (WORD)(cbGroupSize - myOffset));
    lpgd->cbGroup += cbStuffSize;

    lpT = (LPSTR)((LPSTR)lpgd + myOffset);
    if (lpStuff) {
        memmove(lpT, lpStuff, cbStuff);

    } else {
        /*
         * Zero it
         */
        while (cbStuffSize--) {
            *lpT++ = 0;
        }
    }

    GlobalUnlock(hGroup);

    return myOffset;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FindTag() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LPPMTAG FindTag(LPGROUPDEF lpgd, int item, WORD id)
{
    LPPMTAG lptag;
    int cbSeg;
    int cb;

    cbSeg = (int)GlobalSize(lpgd);

    lptag = (LPPMTAG)((LPSTR)lpgd+lpgd->cbGroup);

    if ((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)) + 4 <= cbSeg
        && lptag->wID == ID_MAGIC
        && lptag->wItem == (int)0xFFFF
        && lptag->cb == (WORD)(MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb)) +4)
        && *(LONG FAR *)lptag->rgb == PMTAG_MAGIC) {

        while ((cb = (int)((PCHAR)lptag - (PCHAR)lpgd) + MyDwordAlign(sizeof(PMTAG))-MyDwordAlign(sizeof(lptag->rgb))) <= cbSeg)
        {
            if ((item == lptag->wItem)
                && (id == 0 || id == lptag->wID)) {
                return lptag;
            }

            if (lptag->wID == ID_LASTTAG)
                return NULL;

            (LPSTR)lptag += lptag->cb;
        }
    }
    return NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddTag() -                                                              */
/*                                                                          */
/* in:                                                                      */
/*	h	group handle, must not be discardable!                              */
/*                                                                          */
/* returns:                                                                 */
/*  0	failure                                                             */
/*	1	success                                                             */
/*--------------------------------------------------------------------------*/
INT AddTag(HANDLE h, int item, WORD id, LPSTR lpbuf, int cb)
{
    LPPMTAG lptag;
    WORD fAddFirst;
    LPGROUPDEF lpgd;
    int cbNew;
    int cbMyLen;
    LPGROUPDEF lpgdOld;

    if (!cb && lpbuf) {
        cb = lstrlen(lpbuf) + 1;
    }
    cbMyLen = MyDwordAlign(cb);

    if (!lpbuf) {
        cb = 0;
        cbMyLen = 0;
    }

    lpgd = (LPGROUPDEF)GlobalLock(h);

    lptag = FindTag(lpgd, (int)0xFFFF, (WORD)ID_LASTTAG);

    if (!lptag) {
        /*
         * In this case, there are no tags at all, and we have to add
         * the first tag, the interesting tag, and the last tag
         */
        cbNew = 3 * (MyDwordAlign(sizeof(PMTAG)) - MyDwordAlign(sizeof(lptag->rgb))) + 4 + cbMyLen;

        fAddFirst = TRUE;
        lptag = (LPPMTAG)((LPSTR)lpgd + lpgd->cbGroup);

    } else {
        /*
         * In this case, only the interesting tag needs to be added
         * but we count in the last because the delta is from lptag
         */
        cbNew = 2 * (MyDwordAlign(sizeof(PMTAG)) - MyDwordAlign(sizeof(lptag->rgb))) + cbMyLen;
        fAddFirst = FALSE;
    }


    cbNew += (int)((PCHAR)lptag -(PCHAR)lpgd);
    lpgdOld = lpgd;
    GlobalUnlock(h);
    if (!GlobalReAlloc(h, (DWORD)cbNew, GMEM_MOVEABLE)) {
        return 0;
    }

    lpgd = (LPGROUPDEF)GlobalLock(h);
    lptag = (LPPMTAG)((LPSTR)lpgd + ((LPSTR)lptag - (LPSTR)lpgdOld));
    if (fAddFirst) {
        /*
         * Add the first tag
         */
        lptag->wID = ID_MAGIC;
        lptag->wItem = (int)0xFFFF;
        *(LONG FAR *)lptag->rgb = PMTAG_MAGIC;
        lptag->cb = (WORD)(MyDwordAlign(sizeof(PMTAG)) - MyDwordAlign(sizeof(lptag->rgb)) + 4);
        (LPSTR)lptag += lptag->cb;
    }

    /*
     * Add the tag
     */
    lptag->wID = id;
    lptag->wItem = item;
    lptag->cb = (WORD)(MyDwordAlign(sizeof(PMTAG)) - MyDwordAlign(sizeof(lptag->rgb)) + cbMyLen);
    if (lpbuf) {
        memmove(lptag->rgb, lpbuf, (WORD)cb);
    }
    (LPSTR)lptag += lptag->cb;

    /*
     * Add the end tag
     */
    lptag->wID = ID_LASTTAG;
    lptag->wItem = (int)0xFFFF;
    lptag->cb = 0;

    GlobalUnlock(h);

    return 1;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddItemIconResource() -                                                 */
/*                                                                          */
/*  Adds the icon resource to the group item. Returns TRUE if the icon      */
/*  resource was extracted ok and it was added ok.                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL AddItemIconResource(HANDLE hNewGroup, LPITEMDEF lpid, WORD iItem, LPSTR lpIconPath)
{
    LPGROUPDEF lpgd;
    LPBYTE lpIconRes = NULL;
    HANDLE hIconRes;
    HANDLE hModule;
    HICON hIcon;
    CHAR szIconExe[MAX_PATH];
    WORD id;
    WORD offset;
    DWORD OldErrorMode;

    lpid->cbIconRes = 0;

    id = lpid->indexIcon;
    lstrcpy(szIconExe, lpIconPath);
    CharLower(szIconExe);
    if (id > 7 && strstr(szIconExe, "progman")) {
        //
        // There's one more icon in the NT progman.exe than in the Win3.1
        // progman.exe and it's inserted at the 8th icon position. So if
        // the icon index is 9 in Win3.1 then it will be the 10th icon in
        // NT progman.exe, etc
        //
        id++;
    }

    hIcon = ExtractAssociatedIcon(hInst, szIconExe, &id);
    if (!hIcon) {
        goto Failed;
    }
    DestroyIcon(hIcon);
    lpid->idIcon = id;

    OldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    if (hModule = LoadLibrary(szIconExe)) {

        SetErrorMode(OldErrorMode);

            //
            // It's a 32bit .exe
            //
        hIconRes = FindResource(hModule, MAKEINTRESOURCE(id), MAKEINTRESOURCE(RT_ICON));
        if (hIconRes) {
            lpid->wIconVer = 3;  // resource version is windows 3.x
            lpid->cbIconRes = (WORD)SizeofResource(hModule, hIconRes);
            if (hIconRes = LoadResource(hModule, hIconRes))
                lpIconRes = LockResource(hIconRes);
        }
    }
    else {

        SetErrorMode(OldErrorMode);

            //
            // It's a 16bit .exe
            //
        if (lpid->wIconVer = ExtractIconResInfo(hInst,
                                                szIconExe,
                                                lpid->indexIcon,
                                                &lpid->cbIconRes,
                                                &hIconRes)){

            lpIconRes = GlobalLock(hIconRes);
        }
    }



    //
    // Add the item's Icon resource.
    //
    if (!lpid->cbIconRes) {
        goto Failed;
    }
    offset = AddThing(hNewGroup, lpIconRes, lpid->cbIconRes);

    GlobalUnlock(hIconRes);
    GlobalFree(hIconRes);

    lpgd = (LPGROUPDEF)GlobalLock(hNewGroup);
    lpid = ITEM(lpgd, iItem);
    if (!offset) {
        GlobalUnlock(hNewGroup);
        KdPrint(("ConvGrp: AddThing lpIconRes failed for item %d \n", iItem));
        goto Failed;
    }
    lpid->pIconRes = offset;

    GlobalUnlock(hNewGroup);
    return(TRUE);

Failed:
    KdPrint(("ConvGrp: AddItemIconResource failed to extract icon for item %d \n", iItem));
    return(FALSE);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateNewGroup() -                                                      */
/*                                                                          */
/*  This function creates a new, empty group.                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

HANDLE CreateNewGroup(LPGROUPDEF16 lpGroup16)
{
    HANDLE      hT;
    LPGROUPDEF  lpgd;
    int         i;
    int         cb;
    int         cItems;          // number of items in 16bit group
    LPSTR       pGroupName;      // 16bit group name
    INT         wGroupNameLen;   //length of pGroupName DWORD aligned.

    pGroupName = PTR(lpGroup16, lpGroup16->pName);
    wGroupNameLen = MyDwordAlign(lstrlen(pGroupName) + 1);
    cItems = lpGroup16->cItems;
    cb = sizeof(GROUPDEF) + (cItems * sizeof(WORD)) +  wGroupNameLen;

    //
    // In CreateNewGroup before GlobalAlloc.
    //
    hT = GlobalAlloc(GHND, (DWORD)cb);
    if (!hT) {
        return NULL;
    }

    lpgd = (LPGROUPDEF)GlobalLock(hT);

    //
    // use the 16bit .grp file settings for what we can.
    //
    lpgd->nCmdShow = lpGroup16->nCmdShow;
    lpgd->wIconFormat = lpGroup16->wIconFormat;
    lpgd->cxIcon = lpGroup16->cxIcon;
    lpgd->cyIcon = lpGroup16->cyIcon;
    lpgd->ptMin.x = (INT)lpGroup16->ptMin.x;
    lpgd->ptMin.y = (INT)lpGroup16->ptMin.y;
    SetRect(&(lpgd->rcNormal),
            (INT)lpGroup16->rcNormal.Left,
            (INT)lpGroup16->rcNormal.Top,
            (INT)lpGroup16->rcNormal.Right,
            (INT)lpGroup16->rcNormal.Bottom);


    lpgd->dwMagic = GROUP_MAGIC;
    lpgd->wCheckSum = 0;           /* adjusted later... */
    lpgd->cbGroup = (WORD)cb;
    lpgd->pName = sizeof(GROUPDEF) + cItems * sizeof(WORD);

    lpgd->cItems = (WORD)cItems;

    for (i = 0; i < cItems; i++) {
        lpgd->rgiItems[i] = 0;
    }

    lstrcpy((LPSTR)lpgd + sizeof(GROUPDEF) + cItems * sizeof(WORD),
            pGroupName);

    lpgd->wCheckSum = -(AddUpGroupFile(lpgd));

    GlobalUnlock(hT);
    return(hT);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Create32bitGroupFormat() -                                              */
/*
/*  returns the size of the new 32bit group.
/*                                                                          */
/*--------------------------------------------------------------------------*/

int Create32bitGroupFormat(LPGROUPDEF16 lpGroup16,
                           int cbGroup16Size,
                           LPHANDLE lphNewGroup)
{
    HANDLE hNewGroup;
    LPGROUPDEF lpgd;
    LPITEMDEF lpid;
    LPBYTE lpid16;
    LPBYTE lptag16;
    LPSTR lpTagValue;
    WORD wTagId;
    LPSTR lpT;
    WORD offset;
    int cb;
    int i;

    hNewGroup = CreateNewGroup(lpGroup16);
    if (!hNewGroup) {
        return(0);
    }

    //
    // Add all items to the new formatted group.
    //
    for (i = 0; (i < (int)lpGroup16->cItems) && (i < CITEMSMAX); i++) {

        //
        // Get the pointer to the 16bit item
        //
        lpid16 = ITEM16(lpGroup16, i);

        //
        // Create the item.
        //
        offset = AddThing(hNewGroup, NULL, sizeof(ITEMDEF));
        if (!offset) {
            KdPrint(("ConvGrp: Addthing ITEMDEF failed for item %d \n", i));
            goto QuitThis;
        }

        lpgd = (LPGROUPDEF)GlobalLock(hNewGroup);

        lpgd->rgiItems[i] = offset;
        lpid = ITEM(lpgd, i);

        //
        // Set the item's position.
        //
        lpid->pt.x = *(LPWORD)lpid16;
        lpid->pt.y = *((LPWORD)lpid16 + 1);

        //
        // Add the item's Name.
        //
        GlobalUnlock(hNewGroup);
        lpT = PTR(lpGroup16, *((LPWORD)lpid16 + 9));
        offset = AddThing(hNewGroup, lpT, 0);
        if (!offset) {
            KdPrint(("ConvGrp: Addthing pName failed for item %d \n", i));
            goto PuntCreation;
        }
        lpgd = (LPGROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pName = offset;

        //
        // Add the item's Command line.
        //
        GlobalUnlock(hNewGroup);
        lpT = PTR(lpGroup16, *((LPWORD)lpid16 + 10));
        offset = AddThing(hNewGroup, lpT, 0);
        if (!offset) {
            KdPrint(("ConvGrp: Addthing pCommand failed for item %d \n", i));
            goto PuntCreation;
        }
        lpgd = (LPGROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pCommand = offset;

        //
        // Add the item's Icon path.
        //
        GlobalUnlock(hNewGroup);
        lpT = PTR(lpGroup16, *((LPWORD)lpid16 + 11));
        offset = AddThing(hNewGroup, lpT, 0);
        if (!offset) {
            KdPrint(("ConvGrp: Addthing pIconPath failed for item %d \n", i));
            goto PuntCreation;
        }
        lpgd = (LPGROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pIconPath = offset;

        //
        // Get the item's icon resource using the Icon path and the icon index.
        // And add the item's Icon resource.
        //
        GlobalUnlock(hNewGroup);
        lpid->indexIcon = *((LPWORD)lpid16 + 2);
        if (!AddItemIconResource(hNewGroup, lpid, (WORD)i, lpT)) {
            KdPrint(("ConvGrp: AddItemIconResource failed for item %d \n", i));
            goto PuntCreation;
        }

    }

    /*
     * Copy all the tags to the new group format.
     */
    lptag16 = (LPSTR)lpGroup16 + lpGroup16->cbGroup;

    if (*(UNALIGNED WORD *)lptag16 == ID_MAGIC &&
        *((UNALIGNED WORD *)(lptag16+1)) == 0xFFFF &&
        *(UNALIGNED DWORD *)((UNALIGNED WORD *)(lptag16+3)) == PMTAG_MAGIC) {

        //
        // This is the first tag id, goto start of item tags.
        //
        lptag16 += *((LPWORD)lptag16+2);

        while (*(LPWORD)lptag16 != ID_LASTTAG) {

            wTagId = *(LPWORD)lptag16;
            if (wTagId == ID_MINIMIZE) {
                lpTagValue = NULL;
            }
            else {
                lpTagValue = (LPSTR)((LPWORD)lptag16 + 3);
            }

            if (! AddTag( hNewGroup,
                          (int)*((LPWORD)lptag16 + 1),   // wItem
                          wTagId,                        // wID
                          lpTagValue,                    // rgb : tag value
                          *((LPWORD)lptag16 + 2) - (3 * sizeof(WORD))  // cb - sizeof tag
                        )) {

                KdPrint(("ConvGrp: AddTag wItem=%d, wID=%d failed \n",
                              *((LPWORD)lptag16 + 1),
                              *(LPWORD)lptag16));
            }

            lptag16 += *((LPWORD)lptag16 + 2);      //  go to next tag
        }
    }

    lpgd = GlobalLock(hNewGroup);
    cb = SizeofGroup(lpgd);
    GlobalUnlock(hNewGroup);
    *lphNewGroup = hNewGroup;
    return(cb);

PuntCreation:
QuitThis:
    if (hNewGroup) {
        GlobalFree(hNewGroup);
    }
    return(0);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReadGroup() -                                                           */
/*                                                                          */
/*  Read in the 16bit group file.                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

int ReadGroup(LPSTR pszPath, LPHANDLE lphGroup)

{
    HANDLE     hGroup;
    LPBYTE     lpgd;
    int        cbGroup;
    int        fh;
    PSTR       psz;


    //
    // Find and open the group file.
    //
    fh = _open(pszPath, O_RDONLY | O_BINARY);
    if (fh == -1) {
        KdPrint(("ConvGrp: Could NOT open file %s \n", pszPath));
        fprintf(stderr, "ConvGrp: Could NOT open file %s \n", pszPath);
        goto LGError1;
    }

    //
    // Find the size of the file by seeking to the end.
    //
    cbGroup = (WORD)_lseek(fh, 0L, SEEK_END);
    if (cbGroup < sizeof(GROUPDEF)) {
        KdPrint(("ConvGrp: bad group file - %s\n", pszPath));
        fprintf(stderr, "ConvGrp: bad group file - %s\n", pszPath);
        goto LGError2;
    }

    _lseek(fh, 0L, SEEK_SET);

    //
    // Allocate some memory for the thing.
    //
    if (!(hGroup = GlobalAlloc(GMEM_MOVEABLE|GMEM_DISCARDABLE, (DWORD)cbGroup))) {
        KdPrint(("ConvGrp: Alloc failed for input file %s\n", pszPath));
        psz = NULL;
        goto LGError2;
    }

    lpgd = (LPBYTE)GlobalLock(hGroup);

    //
    // Read the whole group file into memory.
    //
    if (_read(fh, (PSTR)lpgd, cbGroup) != cbGroup) {
        fprintf(stderr, "ConvGrp: Could NOT read file %s\n", pszPath);
        goto LGError3;
    }

    //
    // Validate the group file by checking the magic bytes and the checksum.
    //
    if (*((LPWORD)lpgd + 3) > (WORD)cbGroup) {
        fprintf(stderr, "ConvGrp: Invalid group file - %s\n", pszPath);
        goto LGError3;
    }

    if (*(LPDWORD)lpgd != GROUP_MAGIC) {
        fprintf(stderr, "ConvGrp: Invalid group file - %s\n", pszPath);
        goto LGError3;
    }

    //
    // Test if this is an NT .grp file
    //

    if ( (((LPGROUPDEF)lpgd)->rcNormal.left == (INT)(SHORT)((LPGROUPDEF)lpgd)->rcNormal.left) &&
         (((LPGROUPDEF)lpgd)->rcNormal.right == (INT)(SHORT)((LPGROUPDEF)lpgd)->rcNormal.right) &&
         (((LPGROUPDEF)lpgd)->rcNormal.top == (INT)(SHORT)((LPGROUPDEF)lpgd)->rcNormal.top) &&
         (((LPGROUPDEF)lpgd)->rcNormal.bottom == (INT)(SHORT)((LPGROUPDEF)lpgd)->rcNormal.bottom) ){

        //
        // it's an NT .grp file, not valid for conversion
        //
        fprintf(stderr, "ConvGrp: Invalid group file - %s\n", pszPath);
        goto LGError3;
    }

    _close(fh);


    GlobalUnlock(hGroup);
    *lphGroup = hGroup;
    return(cbGroup);

LGError3:
    GlobalUnlock(hGroup);
    GlobalDiscard(hGroup);

LGError2:
    _close(fh);

LGError1:
    *lphGroup = NULL;
    return(0);
}

#define S_IREAD     0000400         /* read permission, owner */
#define S_IWRITE    0000200         /* write permission, owner */

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Write32bitGroup() -                                                           */
/*                                                                          */
/*  Write out the 32bit group file.                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL Write32bitGroup(LPGROUPDEF lpgd, int cbGroup, LPSTR pszPath)
{
    int fh;
    DWORD Error = 0;


    fh = _open(pszPath, O_CREAT | O_WRONLY | O_BINARY, S_IREAD | S_IWRITE);
    if (fh == -1) {
        Error = GetLastError();
        fprintf(stderr, "ConvGrp: Could NOT open output file - %s\n", pszPath);
        goto Exit1;
    }

    if (_write(fh, (PSTR)lpgd, cbGroup) != (int)cbGroup) {
        Error = GetLastError();
        fprintf(stderr, "ConvGrp: Could NOT write to output file - %s\n", pszPath);
    }

    _write(fh, NULL, 0);        // truncate if getting smaller

    _close(fh);

Exit1:

    if (Error) {
        KdPrint(("         Error = %d \n", Error));
    }
    return (Error == 0);
}


int __cdecl main(
    int argc,
    char *argv[],
    char *envp[])
{
    HANDLE h16bitGroup;
    HANDLE h32bitGroup;
    LPGROUPDEF16 lp16bitGroup;
    LPGROUPDEF lp32bitGroup;
    LPSTR lp16bitGroupFile;
    LPSTR lp32bitGroupFile;
    int cbGroup;
    BOOL bRet = FALSE;

    hInst = GetModuleHandle(NULL);

    //
    // We need the name of the 16bit .grp file and the name of the
    // 32bit .grp file. The first being the 16bit .grp file
    if (argc != 3) {
       fprintf(stderr, "ConvGrp: Invalid number of paramters, should have 2 filenames\n");
       fprintf(stderr, "\nusage: convgrp <Win3.1 .grp filename> <NT .grp filename>\n");
       return(FALSE);
    }

    //
    // The first argument is the name of the 16bit group file,
    // the second argument is the filename for the 32bit group file.
    //
    //
    lp16bitGroupFile = argv[1];
    lp32bitGroupFile = argv[2];

    cbGroup = ReadGroup(lp16bitGroupFile, &h16bitGroup);
    if (!cbGroup) {
        return(FALSE);
    }

    if (!(lp16bitGroup = (LPGROUPDEF16)GlobalLock(h16bitGroup))) {
        KdPrint(("ConvGrp: GlobalLock failed on %s\n", "h16bitGroup"));
        goto Exit;;
    }

    cbGroup = Create32bitGroupFormat(lp16bitGroup, cbGroup, &h32bitGroup);

    if (cbGroup) {
        lp32bitGroup = (LPGROUPDEF)GlobalLock(h32bitGroup);
        bRet = Write32bitGroup(lp32bitGroup, cbGroup, lp32bitGroupFile);
        GlobalUnlock(h32bitGroup);
        GlobalFree(h32bitGroup);
    }

Exit:

    if (h16bitGroup) {
        GlobalFree(h16bitGroup);
    }

    if (bRet) {
       fprintf(stderr, "ConvGrp: group successfully converted\n");
    }
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\convgrp\convgrp.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

/****************************************************************************/
/*                                                                          */
/*  CONVGRP.H -                                                             */
/*                                                                          */
/*      Conversion from Win3.1 16 bit .grp file to NT 32bit .grp files for  */
/*      the Program Manager                                                 */
/*                                                                          */
/*  Created: 10-15-92   Johanne Caron                                       */
/*                                                                          */
/****************************************************************************/
#include <setjmp.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <io.h>
#include <stdio.h>
#include <errno.h>
#include <ctype.h>
#include <windows.h>



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Typedefs                                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*
 * .GRP File format structures -
 */
typedef struct tagGROUPDEF {
    DWORD   dwMagic;        /* magical bytes 'PMCC' */
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    cbGroup;        /* length of group segment */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    nCmdShow;       /* min, max, or normal state */
    WORD    pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */

    WORD    cItems;         /* number of items in group */
    WORD    rgiItems[1];    /* array of ITEMDEF offsets */
} GROUPDEF, *PGROUPDEF;
typedef GROUPDEF *LPGROUPDEF;

typedef struct tagITEMDEF {
    POINT   pt;             /* location of item icon in group */
    WORD    idIcon;         /* id of item icon */
    WORD    wIconVer;       /* icon version */
    WORD    cbIconRes;      /* size of icon resource */
    WORD    indexIcon;      /* index of item icon */
    WORD    dummy2;         /* - not used anymore */
    WORD    pIconRes;       /* offset of icon resource */
    WORD    dummy3;         /* - not used anymore */
    WORD    pName;          /* offset of name string */
    WORD    pCommand;       /* offset of command string */
    WORD    pIconPath;      /* offset of icon path */
} ITEMDEF, *PITEMDEF;
typedef ITEMDEF *LPITEMDEF;


/* the pointers in the above structures are short pointers relative to the
 * beginning of the segments.  This macro converts the short pointer into
 * a long pointer including the proper segment/selector value.        It assumes
 * that its argument is an lvalue somewhere in a group segment, for example,
 * PTR(lpgd->pName) returns a pointer to the group name, but k=lpgd->pName;
 * PTR(k) is obviously wrong as it will use either SS or DS for its segment,
 * depending on the storage class of k.
 */
#define PTR(base, offset) (LPSTR)((PBYTE)base + offset)

/* PTR2 is used for those cases where a variable already contains an offset
 * (The "case that doesn't work", above)
 */
#define PTR2(lp,offset) ((LPSTR)MAKELONG(offset,HIWORD(lp)))

/* this macro is used to retrieve the i-th item in the group segment.  Note
 * that this pointer will NOT be NULL for an unused slot.
 */
#define ITEM(lpgd,i) ((LPITEMDEF)PTR(lpgd, lpgd->rgiItems[i]))

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Tag Stuff                                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

typedef struct _tag
  {
    WORD wID;                   // tag identifier
    WORD dummy1;                // need this for alignment!
    int wItem;                  // (unde the covers 32 bit point!)item the tag belongs to
    WORD cb;                    // size of record, including id and count
    WORD dummy2;                // need this for alignment!
    BYTE rgb[1];
  } PMTAG, FAR * LPPMTAG;

#define GROUP_MAGIC 0x43434D50L  /* 'PMCC' */
#define PMTAG_MAGIC GROUP_MAGIC

    /* range 8000 - 80FF > global
     * range 8100 - 81FF > per item
     * all others reserved
     */

#define ID_MAINTAIN             0x8000
    /* bit used to indicate a tag that should be kept even if the writer
     * doesn't recognize it.
     */

#define ID_MAGIC                0x8000
    /* data: the string 'TAGS'
     */

#define ID_WRITERVERSION        0x8001
    /* data: string in the form [9]9.99[Z].99
     */

#define ID_APPLICATIONDIR       0x8101
    /* data: ASCIZ string of directory where application may be
     * located.
     * this is defined as application dir rather than default dir
     * since the default dir is explicit in the 3.0 command line and
     * must stay there.  The true "new information" is the application
     * directory.  If not present, search the path.
     */

#define ID_HOTKEY               0x8102
    /* data: WORD hotkey index
     */

#define ID_MINIMIZE             0x8103
    /* data none
     */

#define ID_LASTTAG              0xFFFF
    /* the last tag in the file
     */


    /*
     * Maximium number of items allowed in a group
     */
#define CITEMSMAX 50

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/

//
// This is the structure of the .grp files in Windows3.1
//

/* .GRP File format structures -
 */
typedef struct tagGROUPDEF16
  {
    DWORD	  dwMagic;	      /* magical bytes 'PMCC' */
    WORD	  wCheckSum;	      /* adjust this for zero sum of file */
    WORD	  cbGroup;	      /* length of group segment */
    WORD	  nCmdShow;	      /* min, max, or normal state */
    SMALL_RECT rcNormal;	      /* rectangle of normal window */
    POINTS	  ptMin;	      /* point of icon */
    WORD	  pName;	      /* name of group */
				    /* these four change interpretation */
    WORD	  cxIcon;	      /* width of icons */
    WORD	  cyIcon;	      /* hieght of icons */
    WORD	  wIconFormat;	      /* planes and BPP in icons */
    WORD	  wReserved;	      /* This word is no longer used. */

    WORD	  cItems;	      /* number of items in group */
    WORD	  rgiItems[1];	      /* array of ITEMDEF offsets */
  } GROUPDEF16;
typedef GROUPDEF16 *LPGROUPDEF16;

/* this macro is used to retrieve the i-th item in the group segment.  Note
 * that this pointer will NOT be NULL for an unused slot.
 */
#define ITEM16(lpgd16,i) ((LPBYTE)PTR(lpgd16, lpgd16->rgiItems[i]))

#if 0
//
// These structures are not needed for the conversion but it is useful to
// understand what is going on.
//
typedef struct tagITEMDEF16
  {
    POINTS    pt;		      /* location of item icon in group */
                                      // NB This is read when a group is
                                      // loaded and updated when a group is
                                      // written.  All painting/moving is
                                      // done using the icon and title rects
                                      // in an ITEM.  So if you want to know
                                      // where an item is use it's icon rect
                                      // not it's point.
    WORD	  iIcon;	      /* index of item icon */
    WORD	  cbHeader;	      /* size of icon header */
    WORD	  cbANDPlane;	      /* size of and part of icon */
    WORD	  cbXORPlane;	      /* size of xor part of icon */
    WORD	  pHeader;	      /* file offset of icon header */
    WORD	  pANDPlane;	      /* file offset of AND plane */
    WORD	  pXORPlane;	      /* file offset of XOR plane */
    WORD	  pName;	      /* file offset of name string */
    WORD	  pCommand;	      /* file offset of command string */
    WORD	  pIconPath;	      /* file offset of icon path */
  } ITEMDEF16;
typedef ITEMDEF16 *LPITEMDEF16;

typedef struct _tag16
  {
    WORD wID;			// tag identifier
    WORD wItem; 		// item the tag belongs to
    WORD cb;			// size of record, including id and count
    BYTE rgb[1];
  } TAG16, * LPTAG16;

#endif

//
// Globals
//

HANDLE hInst;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\control\ups\ups.c ===
/** FILE: ups.c ********* Module Header ********************************
 *
 *  Control panel applet for UPS configuration.
 *  This applet let the user to specify the ups capabilities, including:
 *      - signalling on power failure
 *      - ability to turn itself off
 *      - signal low battery power
 *      - battery life and recharge time
 *      - signal voltage
 *  It also allows the user to specify the time of first notification
 *  and the notification interval thereafter
 *
 * History:
 *  1pm on Wed  08 Apr 1992  -by- Mark Cliggett [markcl]
 *        Created
 *  Saturday   05 Sept 1992  -by- Congpa You    [congpay]
 *        Rewrite the code for the new UPS dialog.
 *
 *  Copyright (C) 1992 Microsoft Corporation
 *
 *************************************************************************/
//==========================================================================
//                              Include files
//==========================================================================
// C Runtime
#define _CTYPE_DISABLE_MACROS
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Application specific
#include "ups.h"


//==========================================================================
//                              Local Functions
//==========================================================================

/* EnableCONFIG enable/disable the UPS configuration groupbox
 * and the comport combobox if bVal = TRUE/FALSE.
 */
void EnableCONFIG (HWND hDlg, BOOL bVal)
{
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_PORTCB), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_UPSGROUP), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_TEXT), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_PFSIGNAL), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_LOWBATTERY), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_TURNOFF), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_COMMANDFILE), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_SIGN), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_TURNOFFHIGH), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_TURNOFFLOW), bVal);
}

/* EnablePFSINGNAL deals with power failure signal checkbox and radiobutton. */
void EnablePFSIGNAL (HWND hDlg, BOOL bVal)
{
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_PFSIGNALHIGH), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_PFSIGNALLOW), bVal);
}

/* EnableLOWBATTERY deals with low battery signal checkbox and radiobutton. */
void EnableLOWBATTERY (HWND hDlg, BOOL bVal)
{
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_LOWBATTERYHIGH), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_LOWBATTERYLOW), bVal);
}

/* EnableFILENAME deals with the Filename text field. */
void EnableFILENAME (HWND hDlg, BOOL bVal)
{
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_FILETEXT), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_FILENAME), bVal);
}

/* EnableCHARACTER deals with the UPS characteristics groupbox. */
void EnableCHARACTER (HWND hDlg, BOOL bVal)
{
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_CHARACTER), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_BLTEXT1), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_BLEDIT), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_BATTERYLIFE), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_BLTEXT2), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_RPMTEXT1), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_RPMEDIT), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_RECHARGEPERMINUTE), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_RPMTEXT2), bVal);
}

/* EnableSERVICE deals with the UPS service groupbox. */
void EnableSERVICE (HWND hDlg, BOOL bVal)
{
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_SERVICE), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_FWTEXT1), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_FWEDIT), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_FIRSTWARNING), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_FWTEXT2), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_WITEXT1), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_WIEDIT), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_WARNINGINTERVAL), bVal);
    EnableWindow (GetDlgItem (hDlg, IDD_UPS_WITEXT2), bVal);
}

/* Show draws the UPS dialog according to the UPS configuation.
 * There are only 8 cases because there are three check box in
 * UPS configuration groupbox.
 */
void Show (HWND hDlg, ULONG ulOptions)
{
    switch (ulOptions) {
    case UPS_POWERFAILSIGNAL:
        CheckDlgButton (hDlg, IDD_UPS_PFSIGNAL, TRUE);
        EnablePFSIGNAL (hDlg, TRUE);
        EnableLOWBATTERY (hDlg, FALSE);
        EnableCHARACTER (hDlg, TRUE);
        EnableSERVICE (hDlg, TRUE);
        break;
    case UPS_LOWBATTERYSIGNAL:
        CheckDlgButton (hDlg, IDD_UPS_LOWBATTERY, TRUE);
        EnablePFSIGNAL (hDlg, FALSE);
        EnableLOWBATTERY (hDlg, TRUE);
        EnableCHARACTER (hDlg, FALSE);
        EnableSERVICE (hDlg, FALSE);
        break;
    case UPS_CANTURNOFF:
        CheckDlgButton (hDlg, IDD_UPS_TURNOFF, TRUE);
        EnablePFSIGNAL (hDlg, FALSE);
        EnableLOWBATTERY (hDlg, FALSE);
        EnableCHARACTER (hDlg, FALSE);
        EnableSERVICE (hDlg, FALSE);
        break;
    case UPS_POWERFAILSIGNAL | UPS_LOWBATTERYSIGNAL:
        CheckDlgButton (hDlg, IDD_UPS_PFSIGNAL, TRUE);
        CheckDlgButton (hDlg, IDD_UPS_LOWBATTERY, TRUE);
        EnablePFSIGNAL (hDlg, TRUE);
        EnableLOWBATTERY (hDlg, TRUE);
        EnableCHARACTER (hDlg, FALSE);
        EnableSERVICE (hDlg, TRUE);
        break;
    case UPS_POWERFAILSIGNAL | UPS_CANTURNOFF:
        CheckDlgButton (hDlg, IDD_UPS_PFSIGNAL, TRUE);
        CheckDlgButton (hDlg, IDD_UPS_TURNOFF, TRUE);
        EnablePFSIGNAL (hDlg, TRUE);
        EnableLOWBATTERY (hDlg, FALSE);
        EnableCHARACTER (hDlg, TRUE);
        EnableSERVICE (hDlg, TRUE);
        break;
    case UPS_LOWBATTERYSIGNAL | UPS_CANTURNOFF:
        CheckDlgButton (hDlg, IDD_UPS_LOWBATTERY, TRUE);
        CheckDlgButton (hDlg, IDD_UPS_TURNOFF, TRUE);
        EnablePFSIGNAL (hDlg, FALSE);
        EnableLOWBATTERY (hDlg, TRUE);
        EnableCHARACTER (hDlg, FALSE);
        EnableSERVICE (hDlg, FALSE);
        break;
    case UPS_POWERFAILSIGNAL | UPS_LOWBATTERYSIGNAL | UPS_CANTURNOFF:
        CheckDlgButton (hDlg, IDD_UPS_PFSIGNAL, TRUE);
        CheckDlgButton (hDlg, IDD_UPS_LOWBATTERY, TRUE);
        CheckDlgButton (hDlg, IDD_UPS_TURNOFF, TRUE);
        EnablePFSIGNAL (hDlg, TRUE);
        EnableLOWBATTERY (hDlg, TRUE);
        EnableCHARACTER (hDlg, FALSE);
        EnableSERVICE (hDlg, TRUE);
        break;
    default: // All checkboxes in configuration groupbox are not checked.
        EnablePFSIGNAL (hDlg, FALSE);
        EnableLOWBATTERY (hDlg, FALSE);
        EnableCHARACTER (hDlg, FALSE);
        EnableSERVICE (hDlg, FALSE);
    }
}

// Local function. Used by UPSDlg. and ErrorOut.
void ShowError (HWND hDlg,
                DWORD dwError)
{
    TCHAR   szErrorMessage[LONGBZ];
    if (!FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        dwError,
                        0,
                        szErrorMessage,
                        LONGBZ,
                        NULL))
    {
        MessageBox (hDlg, szErrMem, szCtlPanel, MB_OK|MB_ICONSTOP); //szErrMem is loaded in cpl.c.
    }
    else
    {
        MessageBox (hDlg, szErrorMessage, szCtlPanel, MB_OK|MB_ICONSTOP);
    }
}

// Local Function. Used by UPSDlg.
BOOL ErrorOut (HWND      hDlg,
               DWORD     dwError,
               SC_HANDLE hups,
               SC_HANDLE hsc,
               HKEY      vhKey)
{
    ShowError(hDlg, dwError);
    CloseServiceHandle(hups);
    CloseServiceHandle(hsc);
    RegCloseKey(vhKey);
    EndDialog(hDlg, 0L);
    return(FALSE);
}

// Called after trying to start or stop service. Return TRUE if it gets to
// the final state. Otherwise return FALSE

BOOL FinishCheck (DWORD            dwFinalState,
                  SERVICE_STATUS * pss,
                  SC_HANDLE        hups)
{
    int     max_tries = MAXTRIES;
    int     i = 0;
    DWORD   sleep_time;
    DWORD   old_checkpoint = 0;
    DWORD   new_checkpoint = 0;
    DWORD   dwStartState;
    DWORD   dwPendingState;

    if (dwFinalState == SERVICE_STOPPED)
    {
        dwStartState = SERVICE_RUNNING;
        dwPendingState = SERVICE_STOP_PENDING;
    }
    else if (dwFinalState == SERVICE_RUNNING)
    {
        dwStartState = SERVICE_STOPPED;
        dwPendingState = SERVICE_START_PENDING;
    }
    else
        return(FALSE);

    while ((pss->dwCurrentState != dwFinalState) &&
           (i++ < max_tries))
    {
        if (!QueryServiceStatus (hups, pss))
            return(FALSE);

        if (pss->dwCurrentState != dwPendingState)
            break;

        new_checkpoint = pss->dwCheckPoint;

        if (old_checkpoint != new_checkpoint)
        {
            sleep_time = pss->dwWaitHint;
            if (sleep_time > SLEEP_TIME)
            {
                max_tries = ((3 * sleep_time)/SLEEP_TIME);
                sleep_time = SLEEP_TIME;
                i = 0;
            }
        }
        else
            sleep_time = SLEEP_TIME;

        old_checkpoint = new_checkpoint;

        Sleep (sleep_time);
    }

    if (pss->dwCurrentState != dwFinalState)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL IsFilename (TCHAR * szFilename)
{
    if (strchr (szFilename, '\\') == NULL)
        return(TRUE);
    else
        return(FALSE);
}

BOOL IsExecutable (TCHAR * szFilename)
{
    szFilename += (strlen(szFilename) -4);
    if ((_strnicmp (szFilename, ".cmd", 5) == 0) ||
        (_strnicmp (szFilename, ".com", 5) == 0) ||
        (_strnicmp (szFilename, ".exe", 5) == 0) ||
        (_strnicmp (szFilename, ".bat", 5) == 0))
    {
        return(TRUE);
    }
    else
        return(FALSE);
}


//==========================================================================
//                     Local Data Declarations
//==========================================================================
TCHAR szUpsReg[]        = "System\\CurrentControlSet\\Services\\UPS";
TCHAR szPort[]       = "Port";
TCHAR szPortDefault[]= "COM1:";
TCHAR szOptions[]    = "Options";
TCHAR szBatteryLife[]       = "BatteryLife";
TCHAR szRechargePerMinute[] = "RechargeRate";
TCHAR szFirstWarning[]      = "FirstMessageDelay";
TCHAR szWarningInterval[]   = "MessageInterval";
TCHAR szCommandFile[]       = "CommandFile";
TCHAR  szCOM[] = "COM";
TCHAR  szCOLON[] = ":";
HKEY    vhKey;                  // handle to registry node
WNDPROC lpDefWndProc;

ARROWVSCROLL avs[4] = { { 1, -1, 5, -5, 720, 2, 12, 12 },
                        { 1, -1, 5, -5, 250, 1, 30, 30 },
                        { 1, -1, 5, -5, 120, 0, 30, 30 },
                        { 1, -1, 4, -4, 300, 5, 0, 0 } };

LRESULT NewEditWndProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CHAR:
        if ((wParam < L'0' || wParam > L'9') &&
            (wParam != VK_BACK) &&
            (wParam != VK_DELETE) &&
            (wParam != VK_END) &&
            (wParam != VK_HOME))
        {
            MessageBeep (0);
            return TRUE;
        }

    default:
        break;
    }

    return(CallWindowProc(lpDefWndProc, hDlg, message, wParam, lParam));
}

//==========================================================================
//                     UPSDlg is the dlgproc for ups dialog.
//==========================================================================
INT_PTR UPSDlg (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    int     n;
    int     selection;
    int     num;
    int     focusid;
    int     id;
    int     i;
    int     RetVal;
    int     rc;
    DWORD   ulOptions;
    DWORD   ulBatteryLife;
    DWORD   ulRechargePerMinute;
    DWORD   ulFirstWarning;
    DWORD   ulWarningInterval;
    DWORD   cb;
    DWORD   dwStart;
    DWORD   dwError;
    DWORD   type;
    TCHAR * pMemory;
    TCHAR * pszKeyName;
    TCHAR * pszAug;
    TCHAR   szTemport[PORTLEN];
    TCHAR   szTemp[LONGBZ];
    TCHAR   szFilename[PATHMAX];
    TCHAR   szErrorMessage[10*LONGBZ];
    TCHAR   szSysDir[PATHMAX];
    TCHAR   szNum[SHORTBZ];
    TCHAR   szStatus[MIDBZ];
    BOOL    bOK;
    BOOL    fUpsSelected = FALSE;
    static BOOL    bPFSIGNAL = FALSE;
    static BOOL    bLOWBATTERY = FALSE;
    static BOOL    bTURNOFF = FALSE;
    static BOOL    bFILENAME = FALSE;
    SC_HANDLE hsc;
    SC_HANDLE hups;
    SERVICE_STATUS ss;
    WIN32_FIND_DATA ffd;
    HANDLE hFile;
    LONG   lpfnWndProc;

    switch (message)
    {
    case WM_INITDIALOG:

        HourGlass (TRUE);

        //  Read UPS info from registry

        //rc = RegOpenKey(HKEY_LOCAL_MACHINE, szUpsReg, &vhKey);
        rc = RegOpenKey(HKEY_LOCAL_MACHINE, szUpsReg, &vhKey);

        if (rc == ERROR_ACCESS_DENIED)
            {
                MyMessageBox (hDlg, UPS_ACCESS_ERROR, CPCAPTION, MB_OK|MB_ICONSTOP);
                RegCloseKey (vhKey);
                EndDialog (hDlg, 0L);
                return(FALSE);
            }

        else if (rc)
        {
            HourGlass (FALSE);
            MyMessageBox (hDlg, UPS_REGISTRY_ERROR, CPCAPTION, MB_OK|MB_ICONSTOP);
            RegCloseKey (vhKey);
            EndDialog (hDlg, 0L);
            return(FALSE);
        }

        // get UPS values
        cb = sizeof(ULONG);
        if (RegQueryValueEx(vhKey, szOptions, NULL, &type,
                (LPTSTR)&ulOptions, &cb))

            // if no data exists, UPS is not installed
            ulOptions = 0;

        cb = sizeof(ulOptions);
        if (RegQueryValueEx(vhKey, szBatteryLife, NULL, &type,
             (LPTSTR)&ulBatteryLife, &cb))
            ulBatteryLife = DEFAULTBATTERYLIFE;

        cb = sizeof(ulOptions);
        if (RegQueryValueEx(vhKey, szRechargePerMinute, NULL, &type,
                            (LPTSTR)&ulRechargePerMinute, &cb))
            ulRechargePerMinute = DEFAULTRECHARGEPERMINUTE;

        cb = sizeof(ulOptions);
        if (RegQueryValueEx(vhKey, szFirstWarning, NULL, &type,
                            (LPTSTR)&ulFirstWarning, &cb))
            ulFirstWarning = DEFAULTFIRSTWARNING;

        cb = sizeof(ulOptions);
        if (RegQueryValueEx(vhKey, szWarningInterval, NULL, &type,
                            (LPTSTR)&ulWarningInterval, &cb))
            ulWarningInterval = DEFAULTWARNINGINTERVAL;

        cb = sizeof (szTemport) / sizeof (szTemport[0]);
        if (RegQueryValueEx(vhKey, szPort, NULL, &type, szTemport, &cb))
            szTemport[0] = 0;

        cb = sizeof (szFilename) / sizeof (szFilename[0]);
        if (RegQueryValueEx(vhKey, szCommandFile, NULL, &type, szFilename, &cb))
            szFilename[0] = 0;

        // check to see if the current user can change settings
        if (RegSetValueEx(vhKey, szOptions, 0, REG_DWORD,
                              (LPSTR)&ulOptions, sizeof(ulOptions)) ==
                            ERROR_ACCESS_DENIED)
            {
                MyMessageBox(hDlg, UPS_ACCESS_ERROR, CPCAPTION, MB_OK|MB_ICONSTOP);
                RegCloseKey (vhKey);
                EndDialog (hDlg, 0L);
                return(FALSE);
            }

        SetDlgItemText (hDlg, IDD_UPS_FILENAME, szFilename);

        // Show recorded time values in registry.
        _itoa (ulBatteryLife, szNum, 10);
        SetDlgItemText (hDlg, IDD_UPS_BLEDIT, (LPSTR)szNum);
        _itoa (ulRechargePerMinute, szNum, 10);
        SetDlgItemText (hDlg, IDD_UPS_RPMEDIT, (LPSTR)szNum);
        _itoa (ulFirstWarning, szNum, 10);
        SetDlgItemText (hDlg, IDD_UPS_FWEDIT, (LPSTR)szNum);
        _itoa (ulWarningInterval, szNum, 10);
        SetDlgItemText (hDlg, IDD_UPS_WIEDIT, (LPSTR)szNum);


        // Show recorded signal voltage.
        CheckRadioButton(hDlg, IDD_UPS_PFSIGNALHIGH, IDD_UPS_PFSIGNALLOW,
                          ulOptions & UPS_POWERFAIL_LOW ?
                            IDD_UPS_PFSIGNALLOW : IDD_UPS_PFSIGNALHIGH);
        CheckRadioButton(hDlg, IDD_UPS_LOWBATTERYHIGH, IDD_UPS_LOWBATTERYLOW,
                          ulOptions & UPS_LOWBATTERY_LOW ?
                            IDD_UPS_LOWBATTERYLOW : IDD_UPS_LOWBATTERYHIGH);
        CheckRadioButton(hDlg, IDD_UPS_TURNOFFHIGH, IDD_UPS_TURNOFFLOW,
                          ulOptions & UPS_TURNOFF_LOW ?
                            IDD_UPS_TURNOFFLOW : IDD_UPS_TURNOFFHIGH);

        // Show port names from WIN.INI [ports] section
        SendDlgItemMessage (hDlg, IDD_UPS_PORTCB, CB_RESETCONTENT, 0, 0L);

        if (!(pszKeyName = pMemory = AllocMem(KEYBZ)))
        {
            MessageBox (hDlg, szErrMem, szCtlPanel, MB_OK|MB_ICONSTOP);
            RegCloseKey (vhKey);
            EndDialog (hDlg, 0L);
            return(FALSE);
        }

        GetProfileString ("ports", NULL, (LPSTR) szPortDefault, (LPSTR) pszKeyName, KEYBZ);

        n = selection = 0;
        while (*pszKeyName)
        {
            // Check if the string is COM?:
            if ((_strnicmp (pszKeyName, szCOM, 3) == 0) &&
                (isdigit (*(pszKeyName + 3))) &&
                (_strnicmp (pszKeyName + 4, szCOLON, 1) == 0))
            {
                SendDlgItemMessage(hDlg, IDD_UPS_PORTCB, CB_INSERTSTRING,
                                   (WPARAM)-1, (LPARAM)pszKeyName);
                if (!strcmp (pszKeyName, szTemport))
                    selection = n;
                n++;
            }

            SendMessage (GetDlgItem(hDlg, IDD_UPS_PORTCB),
                          CB_SETCURSEL, selection, 0L);

            /* Point to next string in buffer */
            pszKeyName += strlen (pszKeyName) + sizeof(TCHAR);
        }


        FreeMem(pMemory, KEYBZ);

        // Display other fields properly.
        if (ulOptions & UPS_INSTALLED)
        {
            CheckDlgButton (hDlg, IDD_UPS_EXISTS, TRUE);
            EnableCONFIG (hDlg, TRUE);

            // MASK gets the choice in configuration groupbox.
            Show (hDlg, ulOptions & MASK);

            // Enable command file selection?
            if (ulOptions & UPS_COMMANDFILE)
            {
                CheckDlgButton (hDlg, IDD_UPS_COMMANDFILE, TRUE);
                EnableFILENAME (hDlg, TRUE);
            }
            else
                EnableFILENAME (hDlg, FALSE);
        }

        // Set the ranges of the edit fields
        SendMessage(GetDlgItem(hDlg, IDD_UPS_FILENAME),
                    EM_LIMITTEXT,
                    PATHMAX-1,
                    0L);

        SendMessage(GetDlgItem(hDlg, IDD_UPS_BLEDIT),
                    EM_LIMITTEXT,
                    3,
                    0L);
        SendMessage(GetDlgItem(hDlg, IDD_UPS_RPMEDIT),
                    EM_LIMITTEXT,
                    3,
                    0L);
        SendMessage(GetDlgItem(hDlg, IDD_UPS_FWEDIT),
                    EM_LIMITTEXT,
                    3,
                    0L);
        SendMessage(GetDlgItem(hDlg, IDD_UPS_WIEDIT),
                    EM_LIMITTEXT,
                    3,
                    0L);

        // Change the window proc of the edit fields.
        lpDefWndProc = (WNDPROC)GetWindowLongPtr(GetDlgItem(hDlg, IDD_UPS_BLEDIT),
                                                 GWLP_WNDPROC);

        SetWindowLongPtr (GetDlgItem(hDlg, IDD_UPS_BLEDIT),
                          GWLP_WNDPROC,
                          (LONG_PTR)NewEditWndProc);

        SetWindowLongPtr (GetDlgItem(hDlg, IDD_UPS_RPMEDIT),
                          GWLP_WNDPROC,
                          (LONG_PTR)NewEditWndProc);

        SetWindowLongPtr (GetDlgItem(hDlg, IDD_UPS_FWEDIT),
                          GWLP_WNDPROC,
                          (LONG_PTR)NewEditWndProc);

        SetWindowLongPtr (GetDlgItem(hDlg, IDD_UPS_WIEDIT),
                          GWLP_WNDPROC,
                          (LONG_PTR)NewEditWndProc);

        if (!(ulOptions & UPS_INSTALLED))
        {
            EnableCONFIG (hDlg, FALSE);
            EnablePFSIGNAL (hDlg, FALSE);
            EnableLOWBATTERY (hDlg, FALSE);
            EnableCHARACTER (hDlg, FALSE);
            EnableSERVICE (hDlg, FALSE);
            EnableFILENAME (hDlg, FALSE);
            EnableWindow (GetDlgItem (hDlg, IDD_UPS_SIGN), FALSE);
        }

        HourGlass (FALSE);
        break;

    case WM_VSCROLL:
        focusid = GetWindowLong(GetFocus(), GWL_ID);
        switch (HIWORD(wParam))
        {
        case IDD_UPS_BATTERYLIFE:
            id = IDD_UPS_BLEDIT;
            i = 0;
            break;
        case IDD_UPS_RECHARGEPERMINUTE:
            id = IDD_UPS_RPMEDIT;
            i = 1;
            break;
        case IDD_UPS_FIRSTWARNING:
            id = IDD_UPS_FWEDIT;
            i = 2;
            break;
        case IDD_UPS_WARNINGINTERVAL:
            id = IDD_UPS_WIEDIT;
            i = 3;
            break;
        default:
            return (FALSE);
        }

        if (focusid != id)
            SetFocus(GetDlgItem(hDlg, id));

        switch(LOWORD(wParam))
        {
        case SB_THUMBTRACK:
        case SB_ENDSCROLL:
            return (TRUE);
            break;

        default:

            num = GetDlgItemInt (hDlg, id, &bOK, FALSE);
            num = ArrowVScrollProc (LOWORD(wParam), (short)num,
                                            (LPARROWVSCROLL) (avs + i));
            _itoa (num, szNum, 10);
            SetDlgItemText (hDlg, id, (LPSTR)szNum);
            SendDlgItemMessage (hDlg, id, EM_SETSEL, 0, -1L);

            break;
        }

        break;

    case WM_COMMAND:
        // Initialize ulOptions to 0 in order to avoid side effect.
        ulOptions = 0;

        switch (LOWORD(wParam))
        {
        case IDD_UPS_EXISTS:
            // Enable/Disable UPS options controls.

            if (!IsDlgButtonChecked (hDlg, IDD_UPS_EXISTS))
            {

                if (IsDlgButtonChecked (hDlg, IDD_UPS_PFSIGNAL))
                {
                    bPFSIGNAL = TRUE;
                }
                if (IsDlgButtonChecked (hDlg, IDD_UPS_LOWBATTERY))
                {
                    bLOWBATTERY = TRUE;
                }
                if (IsDlgButtonChecked (hDlg, IDD_UPS_TURNOFF))
                {
                    bTURNOFF = TRUE;
                }
                if (IsDlgButtonChecked (hDlg, IDD_UPS_COMMANDFILE))
                {
                    bFILENAME = TRUE;
                }
                SendMessage (GetDlgItem (hDlg, IDD_UPS_PFSIGNAL), BM_SETCHECK, FALSE, 0L);
                SendMessage (GetDlgItem (hDlg, IDD_UPS_LOWBATTERY), BM_SETCHECK, FALSE, 0L);
                SendMessage (GetDlgItem (hDlg, IDD_UPS_TURNOFF), BM_SETCHECK, FALSE, 0L);
                SendMessage (GetDlgItem (hDlg, IDD_UPS_COMMANDFILE), BM_SETCHECK, FALSE, 0L);
                EnableCONFIG (hDlg, FALSE);
                EnablePFSIGNAL (hDlg, FALSE);
                EnableLOWBATTERY (hDlg, FALSE);
                EnableCHARACTER (hDlg, FALSE);
                EnableSERVICE (hDlg, FALSE);
                EnableFILENAME (hDlg, FALSE);
            }
            else
            {
                EnableCONFIG (hDlg, TRUE);
                if (bPFSIGNAL)
                {
                    ulOptions |= UPS_POWERFAILSIGNAL;
                }
                if (bLOWBATTERY)
                {
                    ulOptions |= UPS_LOWBATTERYSIGNAL;
                }
                if (bTURNOFF)
                {
                    ulOptions |= UPS_CANTURNOFF;
                }
                Show (hDlg, (ulOptions & MASK));
                CheckDlgButton (hDlg, IDD_UPS_COMMANDFILE, bFILENAME);
                EnableFILENAME (hDlg, bFILENAME);
            }
            break;

        case IDD_UPS_PFSIGNAL:
        case IDD_UPS_LOWBATTERY:
        case IDD_UPS_TURNOFF:
            // Show the config properly.
            if (IsDlgButtonChecked (hDlg, IDD_UPS_PFSIGNAL))
            {
                bPFSIGNAL = TRUE;
                ulOptions |= UPS_POWERFAILSIGNAL;
            }
            else
                bPFSIGNAL = FALSE;
            if (IsDlgButtonChecked (hDlg, IDD_UPS_LOWBATTERY))
            {
                bLOWBATTERY = TRUE;
                ulOptions |= UPS_LOWBATTERYSIGNAL;
            }
            else
                bLOWBATTERY = FALSE;
            if (IsDlgButtonChecked (hDlg, IDD_UPS_TURNOFF))
            {
                bTURNOFF = TRUE;
                ulOptions |= UPS_CANTURNOFF;
            }
            else
                bTURNOFF = FALSE;
            Show (hDlg, (ulOptions & MASK));
            break;

        case IDD_UPS_COMMANDFILE:
            if (IsDlgButtonChecked (hDlg, IDD_UPS_COMMANDFILE))
            {
                bFILENAME = TRUE;
                ulOptions |= UPS_COMMANDFILE;
                EnableFILENAME (hDlg, TRUE);
            }
            else
            {
                bFILENAME = FALSE;
                EnableFILENAME (hDlg, FALSE);
            }
            break;

        case IDD_UPS_PFSIGNALHIGH:
        case IDD_UPS_PFSIGNALLOW:
        case IDD_UPS_LOWBATTERYHIGH:
        case IDD_UPS_LOWBATTERYLOW:
        case IDD_UPS_TURNOFFHIGH:
        case IDD_UPS_TURNOFFLOW:
        case IDD_UPS_BATTERYLIFE:
        case IDD_UPS_RECHARGEPERMINUTE:
        case IDD_UPS_FIRSTWARNING:
        case IDD_UPS_WARNINGINTERVAL:
            break;

        case IDOK:
            ulOptions = 0;
            HourGlass (TRUE);

            // Get the current status of UPS service.
            if (!(hsc = OpenSCManager(NULL, NULL, GENERIC_ALL)) ||
                !(hups = OpenService(hsc, "UPS", GENERIC_ALL)) ||
                !(QueryServiceStatus(hups, &ss)) )
            {
                dwError = GetLastError();
                return( ErrorOut (hDlg, dwError, hups, hsc, vhKey));
            }

            // Check whether the parameters are set correctly.
            if (IsDlgButtonChecked (hDlg, IDD_UPS_EXISTS)) // If UPS is selected.
            {
                // If neither Power failure signal nor Low battery signal is select,
                // popup a message box to tell the use to select one.
                if (!(IsDlgButtonChecked (hDlg, IDD_UPS_PFSIGNAL)) &&
                    !(IsDlgButtonChecked (hDlg, IDD_UPS_LOWBATTERY)))
                {
                    MyMessageBox(hDlg, UPS_OPTIONS_ERROR, CPCAPTION, MB_OK|MB_ICONSTOP);
                    break;
                }
            }
            else // If UPS is not selected set static variable bPFSIGNAL etc to 0.
            {
                bPFSIGNAL = FALSE;
                bLOWBATTERY = FALSE;
                bTURNOFF = FALSE;
                bFILENAME = FALSE;
            }

            //Get ulOptions
            if (IsDlgButtonChecked (hDlg, IDD_UPS_PFSIGNAL))
                ulOptions |= UPS_POWERFAILSIGNAL;
            if (IsDlgButtonChecked (hDlg, IDD_UPS_LOWBATTERY))
                ulOptions |= UPS_LOWBATTERYSIGNAL;
            if (IsDlgButtonChecked (hDlg, IDD_UPS_TURNOFF))
                ulOptions |= UPS_CANTURNOFF;
            if (IsDlgButtonChecked (hDlg, IDD_UPS_PFSIGNALLOW))
                ulOptions |= UPS_POWERFAIL_LOW;
            if (IsDlgButtonChecked (hDlg, IDD_UPS_LOWBATTERYLOW))
                ulOptions |= UPS_LOWBATTERY_LOW;
            if (IsDlgButtonChecked (hDlg, IDD_UPS_TURNOFFLOW))
                ulOptions |= UPS_TURNOFF_LOW;
            if (IsDlgButtonChecked (hDlg, IDD_UPS_COMMANDFILE))
                ulOptions |= UPS_COMMANDFILE;

            fUpsSelected = IsDlgButtonChecked (hDlg, IDD_UPS_EXISTS);
            if (fUpsSelected)
            {
                ulOptions |= UPS_INSTALLED;
            }

            //Get the UPS parameters
            GetDlgItemText(hDlg, IDD_UPS_PORTCB, szTemport, PORTLEN);
            GetDlgItemText(hDlg, IDD_UPS_FWEDIT, szNum, 10);
            ulFirstWarning = atoi(szNum);
            GetDlgItemText(hDlg, IDD_UPS_WIEDIT, szNum, 10);
            ulWarningInterval = atoi(szNum);
            GetDlgItemText(hDlg, IDD_UPS_BLEDIT, szNum, 10);
            ulBatteryLife = atoi(szNum);
            GetDlgItemText(hDlg, IDD_UPS_RPMEDIT, szNum, 10);
            ulRechargePerMinute = atoi(szNum);

            if (fUpsSelected && (ulOptions & UPS_POWERFAILSIGNAL))
            {
                // Give warning if ulFirstWarning is not in the valid range.
                if ((ulFirstWarning < (ULONG) avs[2].bottom) | (ulFirstWarning > (ULONG) avs[2].top))
                {
                    MyMessageBox (hDlg, UPS_FWRange, CPCAPTION, MB_OK|MB_ICONSTOP);
                    SetFocus (GetDlgItem (hDlg, IDD_UPS_FWEDIT));
                    SendMessage(GetDlgItem (hDlg, IDD_UPS_FWEDIT),
                                EM_SETSEL,
                                0,
                                -1L);
                    break;
                }

                // Give warning if ulWarningInterval is not in the valid range.
                if ((ulWarningInterval < (ULONG) avs[3].bottom) | (ulWarningInterval > (ULONG) avs[3].top))
                {
                    MyMessageBox (hDlg, UPS_WIRange, CPCAPTION, MB_OK|MB_ICONSTOP);
                    SetFocus (GetDlgItem (hDlg, IDD_UPS_WIEDIT));
                    SendMessage(GetDlgItem (hDlg, IDD_UPS_WIEDIT),
                                EM_SETSEL,
                                0,
                                -1L);
                    break;
                }
            }

            if (fUpsSelected &&
                (ulOptions & UPS_POWERFAILSIGNAL) &&
                !(ulOptions & UPS_LOWBATTERYSIGNAL))
            {
                // Give warning if ulBatteryLife is not in the valid range.
                if ((ulBatteryLife <  (ULONG) avs[0].bottom) | (ulBatteryLife > (ULONG) avs[0].top))
                {
                    MyMessageBox (hDlg, UPS_BLRange, CPCAPTION, MB_OK|MB_ICONSTOP);
                    SetFocus (GetDlgItem (hDlg, IDD_UPS_BLEDIT));
                    SendMessage(GetDlgItem (hDlg, IDD_UPS_BLEDIT),
                                EM_SETSEL,
                                0,
                                -1L);
                    break;
                }

                // Give warning if ulRechargePerMinute is not in the valid range.
                if ((ulRechargePerMinute < (ULONG) avs[1].bottom) | (ulRechargePerMinute > (ULONG) avs[1].top))
                {
                    MyMessageBox (hDlg, UPS_RPMRange, CPCAPTION, MB_OK|MB_ICONSTOP);
                    SetFocus (GetDlgItem (hDlg, IDD_UPS_RPMEDIT));
                    SendMessage(GetDlgItem (hDlg, IDD_UPS_RPMEDIT),
                                EM_SETSEL,
                                0,
                                -1L);
                    break;
                }

                // Give warning if set first warning comes later then battery life.
                if (ulFirstWarning > ulBatteryLife * 60)
                {
                    MyMessageBox(hDlg, UPS_FW_WARNING, CPCAPTION, MB_OK|MB_ICONSTOP);
                    SetFocus (GetDlgItem (hDlg, IDD_UPS_FWEDIT));
                    SendMessage(GetDlgItem (hDlg, IDD_UPS_FWEDIT),
                                EM_SETSEL,
                                0,
                                -1L);
                    break;
                }

                // Give warning if set warning interval time longer than battery life.
                if (ulWarningInterval > ulBatteryLife * 60)
                {
                    MyMessageBox(hDlg, UPS_DELAY_WARNING, CPCAPTION, MB_OK|MB_ICONSTOP);
                    SetFocus (GetDlgItem (hDlg, IDD_UPS_WIEDIT));
                    SendMessage(GetDlgItem (hDlg, IDD_UPS_WIEDIT),
                                EM_SETSEL,
                                0,
                                -1L);
                    break;
                }
            }

            if (fUpsSelected && (ulOptions & UPS_COMMANDFILE))
            {
                GetDlgItemText(hDlg, IDD_UPS_FILENAME, szFilename, PATHMAX);
                if (!IsFilename (szFilename))
                {
                    MyMessageBox(hDlg, UPS_INVALID_PATH, CPCAPTION, MB_OK|MB_ICONSTOP);
                    SetFocus (GetDlgItem (hDlg, IDD_UPS_FILENAME));
                    SendMessage(GetDlgItem (hDlg, IDD_UPS_FILENAME),
                                EM_SETSEL,
                                0,
                                -1L);
                    break;
                }

                if (!IsExecutable (szFilename))
                {
                    MyMessageBox(hDlg, UPS_INVALID_FILENAME, CPCAPTION, MB_OK|MB_ICONSTOP);
                    SetFocus (GetDlgItem (hDlg, IDD_UPS_FILENAME));
                    SendMessage(GetDlgItem (hDlg, IDD_UPS_FILENAME),
                                EM_SETSEL,
                                0,
                                -1L);
                    break;
                }

                // Check if the file is in the system directory.
                n = GetSystemDirectory(szSysDir, PATHMAX);
                if ((n == 0) || (n > PATHMAX))
                {
                    MyMessageBox(hDlg, UPS_CANT_FIND_SYSDIR, CPCAPTION, MB_OK|MB_ICONSTOP);
                    break;
                }
                else
                {
                    strcpy (szTemp, szSysDir);
                    strcat (szTemp, "\\");
                    strcat (szTemp, szFilename);
                    hFile = FindFirstFile (szTemp, &ffd);
                    if (hFile == INVALID_HANDLE_VALUE)
                    {
                        if (!LoadString (hModule, UPS_FILE_NOT_EXIST, szTemp, sizeof(szTemp)))
                        {
                            ErrLoadString (hDlg);
                            break;
                        }

                        pszAug = szSysDir;

                        if (!FormatMessage (FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                            szTemp,
                                            0,
                                            0,
                                            szErrorMessage,
                                            LONGBZ,
                                            (va_list *)&(pszAug)))
                        {
                            ShowError (hDlg, GetLastError());
                        }
                        else
                        {
                            MessageBox (hDlg, szErrorMessage, szCtlPanel, MB_OK|MB_ICONSTOP);
                        }
                        SetFocus (GetDlgItem (hDlg, IDD_UPS_FILENAME));
                        SendMessage(GetDlgItem (hDlg, IDD_UPS_FILENAME),
                                    EM_SETSEL,
                                    0,
                                    -1L);
                        break;
                    }
                    else
                    {
                        FindClose (hFile);
                    }
                }

                RegSetValueEx(vhKey, szCommandFile, 0, REG_SZ, szFilename, (strlen(szFilename)+1));
            }

            // Write the configuration to registry.
            RegSetValueEx(vhKey, szPort, 0, REG_SZ, szTemport, (strlen(szTemport)+1));

            RegSetValueEx(vhKey, szOptions, 0, REG_DWORD,
                          (LPSTR)&ulOptions, sizeof(ulOptions));
            RegSetValueEx(vhKey, szBatteryLife, 0, REG_DWORD,
                          (LPSTR)&ulBatteryLife, sizeof(ulBatteryLife));
            RegSetValueEx(vhKey, szRechargePerMinute, 0, REG_DWORD,
                          (LPSTR)&ulRechargePerMinute, sizeof(ulRechargePerMinute));
            RegSetValueEx(vhKey, szFirstWarning, 0, REG_DWORD,
                          (LPSTR)&ulFirstWarning, sizeof(ulFirstWarning));
            RegSetValueEx(vhKey, szWarningInterval, 0, REG_DWORD,
                          (LPSTR)&ulWarningInterval, sizeof(ulWarningInterval));

            // Start or stop the service according to user's choice.

            // If user select UPS, and the service is not running, start it.
            if (ss.dwCurrentState == SERVICE_STOPPED && fUpsSelected)
            {
                RetVal = MyMessageBox (hDlg, UPS_START_MSG, CPCAPTION, MB_YESNOCANCEL|MB_ICONINFORMATION);

                if (RetVal == IDCANCEL)
                {
                    break;
                }

                if (RetVal == IDYES)
                {
                    if (!StartService (hups, 0, NULL))
                    {
                        dwError = GetLastError();
                        return (ErrorOut (hDlg, dwError, hups, hsc, vhKey));
                    }

                    if (!FinishCheck (SERVICE_RUNNING, &ss, hups))
                    {
                        if (MyMessageBox (hDlg, UPS_STARTFAIL_MSG, CPCAPTION, MB_OKCANCEL|MB_ICONSTOP)
                            == IDOK)
                        {
                            break;
                        }
                    }
                }
            }

            // If the service is running, stop it first.
            else if ((ss.dwCurrentState == SERVICE_RUNNING) ||
                     (ss.dwCurrentState == SERVICE_PAUSED))
            {
                RetVal = MyMessageBox (hDlg,
                                       fUpsSelected? UPS_RESTART_MSG: UPS_STOP_MSG,
                                       CPCAPTION,
                                       MB_YESNOCANCEL|MB_ICONINFORMATION);

                if (RetVal == IDCANCEL)
                {
                    break;
                }

                if (RetVal == IDYES)
                {
                    // Stop the service first.
                    if (!ControlService (hups, SERVICE_CONTROL_STOP, &ss))
                    {
                        dwError = GetLastError();
                        return( ErrorOut (hDlg, dwError, hups, hsc, vhKey));
                    }

                    if (!FinishCheck (SERVICE_STOPPED, &ss, hups))
                    {
                        if (MyMessageBox (hDlg, UPS_STOPFAIL_MSG, CPCAPTION, MB_OKCANCEL|MB_ICONSTOP)
                            == IDCANCEL)
                        {
                            break;
                        }
                        else
                            fUpsSelected = FALSE; // For error break out.
                    }

                    // If user selected UPS, start it again. Otherwise exit.
                    if (fUpsSelected)
                    {
                        if (!StartService (hups, 0, NULL))
                        {
                            dwError = GetLastError();
                            return (ErrorOut (hDlg, dwError, hups, hsc, vhKey));
                        }

                        if (!FinishCheck (SERVICE_RUNNING, &ss, hups))
                        {
                            if (MyMessageBox (hDlg, UPS_STARTFAIL_MSG, CPCAPTION, MB_OKCANCEL|MB_ICONSTOP)
                                == IDOK)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            // If the service is in pending state. ask user to use Services applet.
            else if ((ss.dwCurrentState == SERVICE_START_PENDING)    ||
                     (ss.dwCurrentState == SERVICE_STOP_PENDING)     ||
                     (ss.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                     (ss.dwCurrentState == SERVICE_PAUSE_PENDING))
            {
                if (MyMessageBox (hDlg, UPS_PENDING_MSG, CPCAPTION, MB_OKCANCEL|MB_ICONSTOP)
                    == IDCANCEL)
                    break;
            }

            // If the service in Unknow state, report error.
            else
                MyMessageBox (hDlg, UPS_UNKNOWNSTATE_MSG, CPCAPTION, MB_OK|MB_ICONSTOP);

            // Set UPS service to be auto start if the UPS installed box is checked.
            // Set UPS service to be manual start if the installed box is not checked.
            dwStart = fUpsSelected? SERVICE_AUTO_START : SERVICE_DEMAND_START;

            if (!ChangeServiceConfig (hups,
                                      SERVICE_NO_CHANGE,
                                      dwStart,
                                      SERVICE_ERROR_NORMAL,
                                      NULL,
                                      NULL,
                                      NULL,
				      NULL,
				      NULL,
                                      NULL,
                                      NULL))
            {
                dwError = GetLastError();
                return (ErrorOut (hDlg, dwError, hups, hsc, vhKey));
            }

            // Close opened services handles.
            CloseServiceHandle(hups);
            CloseServiceHandle(hsc);

            // Close registry handle and exit dialog.
            RegCloseKey(vhKey);
            EndDialog (hDlg, 0L);
            break;

        case IDCANCEL:
            RegCloseKey(vhKey);
            EndDialog (hDlg, 0L);
            break;

        case IDD_HELP:
            CPHelp(hDlg);
            break;

        default:
            break;
        }
        break;

    default:
        if (message == wHelpMessage)
        {
            CPHelp(hDlg);
        }
        else
            return FALSE;
        break;
    }
  return(TRUE);
}

// Turn hourglass on or off

void HourGlass (BOOL bOn)
{
   if (!GetSystemMetrics(SM_MOUSEPRESENT))
      ShowCursor(bOn);

   SetCursor(LoadCursor(NULL, bOn ? IDC_WAIT : IDC_ARROW));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\access.h ===
/******************************************************************************
Module name: Access.h
Purpose: defines for all accstat
******************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <cpl.h>
//#include <shellapi.h>
#include <commctrl.h>

#include "acchelp.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////////


#define ARRAY_SIZE(a)      (sizeof(a) / sizeof((a)[0]))
#define MEMBER_SIZE(s,m)   sizeof(((s *)0)->m)

// Debugging defs
#if defined(DEBUG) || defined(MEMCHECK) || defined(_DEBUG)

//Assert based on boolean f.
#define Assert(f) assert(f)

#else

#define Assert(f) ((void)0)

#endif


//////////////////////////////////////////////////////////////////////////////

extern BOOL g_SPISetValue;
extern HINSTANCE g_hinst;
extern BOOL      g_fWinNT;       // TRUE if we're running on NT and must disable
                                 // some features.

extern const DWORD g_aIds[];     // array mapping control id's to help id's

// This functions makes it easy to access the registry.
int  WINAPI RegQueryInt(int nDefault, HKEY hkey, LPTSTR lpSubKey, LPTSTR lpValueName);
BOOL WINAPI RegSetInt(HKEY hkey, LPTSTR lpSubKey, LPTSTR lpValueName, int nVal);

void WINAPI RegQueryStr(
    LPTSTR lpDefault, 
    HKEY hkey, 
    LPTSTR lpSubKey, 
    LPTSTR lpValueName,
    LPTSTR lpszValue, 
    DWORD cbData);

BOOL RegSetStr(HKEY hkey, LPCTSTR lpSection, LPCTSTR lpKeyName, LPCTSTR lpString);

DWORD WINAPI RegQueryStrDW(
    DWORD dwDefault,
    HKEY hkey, 
    LPTSTR lpSubKey, 
    LPTSTR lpValueName);

BOOL RegSetStrDW(HKEY hkey, LPTSTR lpSection, LPCTSTR lpKeyName, DWORD dwValue);

   // This function takes the current state of the variables below
// and updates the system settings.
void WINAPI SetAccessibilitySettings (void);

// These values are declared in General.c
extern BOOL  g_fSaveSettings;
extern BOOL  g_fShowWarnMsgOnFeatureActivate;
extern BOOL  g_fPlaySndOnFeatureActivate;
// Admin options in general
extern BOOL  g_fCopyToLogon;
extern BOOL  g_fCopyToDefault;

// Keyboard property page
extern STICKYKEYS     g_sk;
extern FILTERKEYS     g_fk;
   // g_dwLastBounceKeySetting is part of FilterKeys
   extern DWORD g_dwLastBounceKeySetting;
   extern DWORD g_nLastRepeatDelay;
   extern DWORD g_nLastRepeatRate;
   extern DWORD g_nLastWait;

extern TOGGLEKEYS     g_tk;
extern BOOL           g_fExtraKeyboardHelp;

// Sound Property page
extern SOUNDSENTRY    g_ss;
extern BOOL           g_fShowSounds;

// Display Property page
#define BLINK           1000
#define BLINK_OFF       -1

#define CURSORMIN       200
#define CURSORMAX       1300
#define CURSORSUM       (CURSORMIN + CURSORMAX)
#define CURSORRANGE     (CURSORMAX - CURSORMIN)

typedef struct CARET_SETTINGS {
    DWORD dwCaretBlinkRate;
    DWORD dwCaretWidth;
    DWORD dwNewCaretBlinkRate;
    DWORD dwNewCaretWidth;
} CARET_SETTINGS;
extern HIGHCONTRAST   g_hc;
extern CARET_SETTINGS g_cs;
extern TCHAR          g_szScheme[256];

// Mouse Property page
extern MOUSEKEYS      g_mk;

// General Property page
extern ACCESSTIMEOUT  g_ato;
extern SERIALKEYS     g_serk;
extern TCHAR          g_szActivePort[MAX_PATH];
//extern TCHAR        g_szPort[MAX_PATH];  // Currently reserved, should be NULL.


//////////////////////////////////////////////////////////////////////////////


// AccessSystemParametersInfo is actually defined in AccRare.c and is
// a replacement for SysParamInfoBugFix

BOOL AccessSystemParametersInfo(
	UINT wFlag,
	DWORD wParam,
	PVOID lParam,
	UINT flags);

//////////////////////////////////////////////////////////////////////////////


// Define strings for registry.
#define GENERAL_KEY           __TEXT("Control Panel\\Accessibility")
#define FILTER_KEY            __TEXT("Control Panel\\Accessibility\\Keyboard Response")
#define HC_KEY                __TEXT("Control Panel\\Accessibility\\HighContrast")
#define CONTROL_KEY           __TEXT("Control Panel\\Appearance\\Schemes")
#define WARNING_SOUNDS        __TEXT("Warning Sounds")
#define SOUND_ON_ACTIVATION   __TEXT("Sound on Activation")
#define APPLY_GLOBALLY        __TEXT("Restore Settings")
#define NORMALSCHEME          __TEXT("Current Normal Scheme")
#define HIGHCONTRAST_SCHEME   __TEXT("High Contrast Scheme")
#define VOLATILE_SCHEME       __TEXT("Volital HC Scheme")
#define WHITEBLACK_HC         __TEXT("High Contrast Black (large)")
#define LAST_BOUNCE_SETTING   __TEXT("Last BounceKey Setting")
#define LAST_REPEAT_RATE      __TEXT("Last Valid Repeat")
#define LAST_REPEAT_DELAY     __TEXT("Last Valid Delay")
#define LAST_WAIT             __TEXT("Last Valid Wait")
#define CURR_HC_SCHEME        __TEXT("High Contrast Scheme")
#define APPEARANCE_KEY        __TEXT("Control Panel\\Appearance")
#define CURR_NONHC_SCHEME     __TEXT("Current")


#define IDSENG_BLACKWHITE_SCHEME   __TEXT("High Contrast White (large)")
#define IDSENG_WHITEBLACK_SCHEME   __TEXT("High Contrast Black (large)")



//////////////////////////////////////////////////////////////////////////////


// Define prototypes
INT_PTR WINAPI HighContrastDlg (HWND, UINT , WPARAM , LPARAM);
INT_PTR WINAPI ToggleKeySettingsDlg (HWND, UINT, WPARAM, LPARAM);
INT_PTR WINAPI StickyKeyDlg (HWND, UINT , WPARAM, LPARAM);
INT_PTR WINAPI FilterKeyDlg (HWND, UINT , WPARAM, LPARAM);
INT_PTR WINAPI MouseKeyDlg (HWND, UINT, WPARAM, LPARAM);
INT_PTR WINAPI SerialKeyDlg (HWND, UINT, WPARAM, LPARAM);

int HandleScroll (HWND hwnd, WPARAM wParam, HWND hwndScroll);


DWORD SaveDefaultSettings(BOOL saveL, BOOL saveU);
BOOL IsDefaultWritable(void);


typedef
LANGID (WINAPI *pfnGetUserDefaultUILanguage)(void);

typedef
LANGID (WINAPI *pfnGetSystemDefaultUILanguage)(void);

BOOL IsMUI_Enabled();




///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\acchelp.h ===
//
// Help file equates.
//

#define NO_HELP						((DWORD) -1)

#define IDH_ACCESS_CONFIRMHOTKEY	1000
#define IDH_ACCESS_SOUNDONHOTKEY	1010
#define IDH_ACCESS_TIMEOUT		1015
#define	IDH_ACCESS_TIMEOUT_MINUTES	1016
#define IDH_FILTERKEYS_BEEPONKEYPRESS	1020
#define IDH_FILTERKEYS_BKSETTINGS 1024
#define IDH_FILTERKEYS_SETTINGS_REPEAT	1025
#define IDH_FILTERKEYS_DELAY            1030
#define IDH_REPEAT_DELAY                1031
#define IDH_FILTERKEYS_ENABLE		1035
#define IDH_FILTERKEYS_HOTKEY		1040
#define IDH_FILTERKEYS_IGNORE_REPEAT	1045
#define IDH_FILTERKEYS_KEYSPEED		1050
#define IDH_FILTERKEYS_NO_REPEAT	1055
#define IDH_FILTERKEYS_RATE		1060
#define IDH_FILTERKEYS_REPEATKEYS	1065
#define IDH_FILTERKEYS_SETTINGS		1070
#define IDH_FILTERKEYS_BOUNCEKEYS	1075
#define IDH_FILTERKEYS_SETTINGS_QUICK	1080
#define IDH_FILTERKEYS_SLOW		1085
#define IDH_FILTERKEYS_SPAWNSTATUSAPP	1090
#define IDH_FILTERKEYS_TEST1		1095
#define IDH_FILTERKEYS_TEST2		1100
#define IDH_FILTERKEYS_TESTBOX		1105
#define IDH_HIGHCONTRAST_DEFAULTSCHEME	1110
#define IDH_HC_NONHCSCHEME          1111
#define IDH_HIGHCONTRAST_ENABLE		1115
#define IDH_HIGHCONTRAST_HOTKEY		1120
#define IDH_KCURSOR_RATE            1121
#define IDH_KCURSOR_WIDTH           1122
#define IDH_KCURSOR_OPTS            1123

#define IDH_HIGHCONTRAST_SETTINGS	1125
#define IDH_MOUSEKEYS_ACCELERATION	1130
#define IDH_MOUSEKEYS_ENABLE		1135
#define IDH_MOUSEKEYS_HOTKEY		1140
#define IDH_MOUSEKEYS_MAXSPEED		1145
#define IDH_MOUSEKEYS_NUMLOCKMODE	1150
#define IDH_MOUSEKEYS_SETTINGS		1155
#define IDH_MOUSEKEYS_SPAWNSTATUSAPP	1160
#define IDH_MOUSEKEYS_USEMODIFIERKEYS	1165
#define IDH_SERIALKEYS_BAUD		1170
#define IDH_SERIALKEYS_ENABLE		1175
#define IDH_SERIALKEYS_SERIAL		1180
#define IDH_SERIALKEYS_SETTINGS		1185
#define IDH_SHOWSOUNDS_ENABLE		1190
#define IDH_SOUNDSENTRY_ENABLE		1195
#define IDH_SOUNDSENTRY_GRAPHICS	1200
#define IDH_SOUNDSENTRY_WINDOWED	1215
#define IDH_STICKYKEYS_2KEYS		1220
#define IDH_STICKYKEYS_ENABLE		1225
#define IDH_STICKYKEYS_HOTKEY		1230
#define IDH_STICKYKEYS_LOCK		1235
#define IDH_STICKYKEYS_SETTINGS		1240
#define IDH_STICKYKEYS_SOUND		1245
#define IDH_STICKYKEYS_STATUS		1250
#define IDH_TOGGLEKEYS_ENABLE		1255
#define IDH_TOGGLEKEYS_HOTKEY		1260
#define IDH_TOGGLEKEYS_SETTINGS		1265
#define IDH_VALID_KEY_TIME		1068
#define IDH_REPEAT_RATE			1067
#define IDH_IDLE_TIMEOUT		1038
#define IDH_KEY_PRESS_TIME		1056

// New helps from new dialogs

// #define IDH_SLOWKEYS_ACCEPTDELAY	2000
// #define IDH_SLOWKEYS_ENABLEREPEAT	2001
// #define IDH_SLOWKEYS_DELAYTIME		2002
// #define IDH_SLOWKEYS_REPEATTIME		2003
// #define IDH_BOUNCKEYS_BOUNCETIME	2004

#define IDH_ACCESS_FILTER_KEYS		2006
#define IDH_ACCESS_MOUSE_KEYS		2007
#define IDH_ACCESS_STICKY_KEYS		2008
#define IDH_SHOW_KEYBOARD_HELP		2009
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\access.c ===
// **************************************************************************
// Access.c
//
// Accessability Property sheet page creator
//
// **************************************************************************

#include "Access.h"

#ifdef  UNICODE     // Windows uses UNICODE
#define _UNICODE    // but tchar.h uses _UNICODE
#endif

DWORD g_dwOrigFKFlags;
BOOL g_bFKOn;

#include <stdlib.h>
#include <stddef.h>
#include <tchar.h>

#define OLDDISABLED     32760

#ifndef FKF_VALID
#define FKF_VALID           0x0000007F
#endif

#ifndef SKF_VALID
#define SKF_VALID           0x000001FF
#endif

#ifndef MKF_VALID
#define MKF_VALID           0x000000FF
#endif

#ifndef ATF_VALID
#define ATF_VALID           0x00000003
#endif

#ifndef SSF_VALID
#define SSF_VALID           0x00000007
#endif

#ifndef TKF_VALID
#define TKF_VALID           0x0000003F
#endif

//////////////////////////////////////////////////////////////////////////

// collection of data that represents the saved accessability state
typedef struct ACCSTATE   // as
{
    // Keyboard property page
    STICKYKEYS     sk;
    FILTERKEYS     fk;
    TOGGLEKEYS     tk;
    BOOL           fExtraKeyboardHelp;

    // Sound Property page
    SOUNDSENTRY    ss;
    BOOL           fShowSounds;

    // Display Property page
    HIGHCONTRAST   hc;
    TCHAR          szDefaultScheme[256];  // hc.lpszDefaultScheme
    CARET_SETTINGS cs;

    // Mouse Property page
    MOUSEKEYS      mk;

    // General Property page
    BOOL               fShowWarnMsgOnFeatureActivate;
    BOOL               fPlaySndOnFeatureActivate;

    ACCESSTIMEOUT  ato;
    SERIALKEYS     serk;
    TCHAR          szActivePort[MAX_PATH];  // serk.szActivePort
    TCHAR          szPort[MAX_PATH];                // serk.szPort
} ACCSTATE, *PACCSTATE;


//////////////////////////////////////////////////////////////////////////
extern BOOL g_SPISetValue = FALSE;

static ACCSTATE s_asOrg;          // original settings from app start-up
static ACCSTATE s_asPrev;         // previous saved settings

extern BOOL  g_fWinNT = -1;       // TRUE if we're running on NT and must
                                  // disable some features

extern BOOL  g_fSaveSettings = TRUE;
extern BOOL  g_fShowWarnMsgOnFeatureActivate = TRUE;
extern BOOL  g_fPlaySndOnFeatureActivate = TRUE;
extern BOOL  g_fCopyToLogon = FALSE;
extern BOOL  g_fCopyToDefault = FALSE;
// Keyboard property page
// extern STICKYKEYS     g_sk = {0};
STICKYKEYS     g_sk;
FILTERKEYS     g_fk;
   // g_dwLastBounceKeySetting, g_nLastRepeatDelay, g_nLastRepeatRate
   //  and g_nLastWait are part of FilterKeys
   DWORD g_dwLastBounceKeySetting = 0;
   DWORD g_nLastRepeatDelay = 0;
   DWORD g_nLastRepeatRate = 0;
   DWORD g_nLastWait = 0;

TOGGLEKEYS     g_tk;
BOOL           g_fExtraKeyboardHelp = TRUE;

// Sound Property page
SOUNDSENTRY    g_ss;
BOOL           g_fShowSounds;

// Display Property page
HIGHCONTRAST   g_hc;
CARET_SETTINGS g_cs;

// Mouse Property page
MOUSEKEYS      g_mk;

// General Property page
ACCESSTIMEOUT  g_ato;
SERIALKEYS     g_serk;
TCHAR          g_szActivePort[MAX_PATH];
TCHAR          g_szPort[MAX_PATH];

#define CONTROL_PANEL_DESKTOP TEXT("Control Panel\\Desktop")
#define CURSOR_BLINK_RATE TEXT("CursorBlinkRate")
#define DEFAULT_BLINK_RATE 530

//////////////////////////////////////////////////////////////////////////

void CopyHighContrast(LPHIGHCONTRAST phcDest, LPHIGHCONTRAST phcSrc)
{
    LPTSTR lpszDefaultScheme = phcDest->lpszDefaultScheme;

    memcpy(phcDest, phcSrc, sizeof(*phcDest));
    phcDest->lpszDefaultScheme = lpszDefaultScheme;

    if (NULL != phcDest->lpszDefaultScheme)
    {
        lstrcpy(phcDest->lpszDefaultScheme, phcSrc->lpszDefaultScheme);
    }
}

//////////////////////////////////////////////////////////////////////////

BOOL IsHighContrastEqual(LPHIGHCONTRAST phcDest, LPHIGHCONTRAST phcSrc)
{
    BOOL fIsEqual = FALSE;
    LPTSTR lpszDefaultScheme = phcDest->lpszDefaultScheme;

    // Temporarily make the pointers match
    phcDest->lpszDefaultScheme = phcSrc->lpszDefaultScheme;

    // match the bits of the structures and the pointed to data
    fIsEqual = (0 == memcmp(phcDest, phcSrc, sizeof(*phcDest)) &&
                0 == lstrcmp(lpszDefaultScheme, phcSrc->lpszDefaultScheme));

    phcDest->lpszDefaultScheme = lpszDefaultScheme;

    return(fIsEqual);
}


//////////////////////////////////////////////////////////////////////////

void CopySerialKeys(LPSERIALKEYS pskDest, LPSERIALKEYS pskSrc)
{
    LPTSTR lpszActivePort = pskDest->lpszActivePort;
    LPTSTR lpszPort = pskDest->lpszPort;

    memcpy(pskDest, pskSrc, sizeof(*pskDest));
    pskDest->lpszActivePort = lpszActivePort;

    if (NULL != pskDest->lpszActivePort)
    {
        lstrcpy(pskDest->lpszActivePort, pskSrc->lpszActivePort);
    }

    pskDest->lpszPort = lpszPort;
    if (NULL != pskDest->lpszPort)
    {
        lstrcpy(pskDest->lpszPort, pskSrc->lpszPort);
    }
}

//////////////////////////////////////////////////////////////////////////

BOOL IsSerialKeysEqual(LPSERIALKEYS pskDest, LPSERIALKEYS pskSrc)
{
    BOOL fIsEqual = FALSE;
    LPTSTR lpszActivePort = pskDest->lpszActivePort;
    LPTSTR lpszPort = pskDest->lpszPort;

    // Temporarily make the pointers match
    pskDest->lpszActivePort = pskSrc->lpszActivePort;
    pskDest->lpszPort = pskSrc->lpszPort;

    // match the bits of the structures and the pointed to data
    fIsEqual = (0 == memcmp(pskDest, pskSrc, sizeof(*pskDest)) &&
        (NULL == lpszActivePort ||
                0 == lstrcmp(lpszActivePort, pskSrc->lpszActivePort)) &&
        (NULL == lpszPort ||
                0 == lstrcmp(lpszPort, pskSrc->lpszPort)));

    pskDest->lpszActivePort = lpszActivePort;
    pskDest->lpszPort = lpszPort;

    return(fIsEqual);
}

//////////////////////////////////////////////////////////////////////////

BOOL IsAccStateEqual(PACCSTATE pasDest, PACCSTATE pasSrc)
{
    BOOL fIsEqual = FALSE;
    HIGHCONTRAST   hc = pasDest->hc;
    SERIALKEYS     serk = pasDest->serk;
    int nLen;

    // Clear out the unused sections of the string buffers
    nLen = lstrlen(pasDest->szDefaultScheme);
    memset(&pasDest->szDefaultScheme[nLen], 0,
        sizeof(pasDest->szDefaultScheme)-nLen*sizeof(*pasDest->szDefaultScheme));

    nLen = lstrlen(pasDest->szActivePort);
    memset(&pasDest->szActivePort[nLen], 0,
        sizeof(pasDest->szActivePort)-nLen*sizeof(*pasDest->szActivePort));

    nLen = lstrlen(pasDest->szPort);
    memset(&pasDest->szPort[nLen], 0,
            sizeof(pasDest->szPort)-nLen*sizeof(*pasDest->szPort));

    nLen = lstrlen(pasSrc->szDefaultScheme);
    memset(&pasSrc->szDefaultScheme[nLen], 0,
            sizeof(pasSrc->szDefaultScheme)-nLen*sizeof(*pasSrc->szDefaultScheme));

    nLen = lstrlen(pasSrc->szActivePort);
    memset(&pasSrc->szActivePort[nLen], 0,
            sizeof(pasSrc->szActivePort)-nLen*sizeof(*pasSrc->szActivePort));

    nLen = lstrlen(pasSrc->szActivePort);
    memset(&pasSrc->szPort[nLen], 0,
            sizeof(pasSrc->szPort)-nLen*sizeof(*pasSrc->szPort));

    // Temporarily make the elements with pointers match
    pasDest->hc = pasSrc->hc;
    pasDest->serk = pasSrc->serk;

    // match the bits of the structures and the elements with pointers
    fIsEqual = (0 == memcmp(pasDest, pasSrc, sizeof(*pasDest)) &&
            IsHighContrastEqual(&hc, &pasSrc->hc) &&
            IsSerialKeysEqual(&serk, &pasSrc->serk));

    pasDest->hc = hc;
    pasDest->serk = serk;

    return(fIsEqual);
}


//////////////////////////////////////////////////////////////////////////


int WINAPI RegQueryInt (int nDefault, HKEY hkey, LPTSTR lpSubKey, LPTSTR lpValueName) {

   DWORD dwType;
   DWORD dwVal = nDefault;
   DWORD cbData = sizeof(int);
   if (ERROR_SUCCESS == RegOpenKeyEx(hkey, lpSubKey, 0, KEY_QUERY_VALUE, &hkey)) {
      RegQueryValueEx(hkey, lpValueName, NULL, &dwType, (PBYTE) &dwVal, &cbData);
      RegCloseKey(hkey);
   }
   return(dwVal);
}


//////////////////////////////////////////////////////////////////////////


BOOL WINAPI RegSetInt (HKEY hkey, LPTSTR lpSubKey, LPTSTR lpValueName, int nVal) {
   BOOL fOk = FALSE;
   DWORD dwDisposition;
   LONG lRet;

   if (ERROR_SUCCESS == RegCreateKeyEx(hkey, lpSubKey, 0, NULL, REG_OPTION_NON_VOLATILE,
      KEY_SET_VALUE, NULL, &hkey, &dwDisposition)) {

      lRet = RegSetValueEx(hkey, lpValueName, 0, REG_DWORD, (CONST BYTE *) &nVal, sizeof(nVal));
      fOk = (ERROR_SUCCESS == lRet);
      RegCloseKey(hkey);
   }
   return fOk;
}


//////////////////////////////////////////////////////////////////////////


void WINAPI RegQueryStr(
   LPTSTR lpDefault,
   HKEY hkey,
   LPTSTR lpSubKey,
   LPTSTR lpValueName,
   LPTSTR lpszValue,
   DWORD cbData) // note this is bytes, not characters.
{
   DWORD dwType;

   lstrcpy(lpszValue, lpDefault);
   if (ERROR_SUCCESS == RegOpenKeyEx(hkey, lpSubKey, 0, KEY_QUERY_VALUE, &hkey)) {
      RegQueryValueEx(hkey, lpValueName, NULL, &dwType, (PBYTE) lpszValue, &cbData);
      RegCloseKey(hkey);
   }
}

/***************************************************************************\
**AccessWriteProfileString
*
* History:
* 12-19-95 a-jimhar 	Created (was called AccessWriteProfileString)
* 02-08-95 a-jimhar     revised and moved from accrare.c to access.c
\***************************************************************************/
BOOL RegSetStr(
    HKEY hkey,
    LPCTSTR lpSection,
    LPCTSTR lpKeyName,
    LPCTSTR lpString)
{
    BOOL fRet = FALSE;
    LONG lErr;
    DWORD dwDisposition;

    lErr = RegCreateKeyEx(
            hkey,
            lpSection,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hkey,
            &dwDisposition);

    if (ERROR_SUCCESS == lErr)
    {
        if (NULL != lpString)
        {
            lErr = RegSetValueEx(
                    hkey,
                    lpKeyName,
                    0,
                    REG_SZ,
                    (CONST BYTE *)lpString,
                    (lstrlen(lpString) + 1) * sizeof(*lpString));
        }
        else
        {
            lErr = RegSetValueEx(
                    hkey,
                    lpKeyName,
                    0,
                    REG_SZ,
                    (CONST BYTE *)__TEXT(""),
                    1 * sizeof(*lpString));
        }

        if (ERROR_SUCCESS == lErr)
        {
            fRet = TRUE;
        }
        RegCloseKey(hkey);
    }
    return(fRet);
}


DWORD WINAPI RegQueryStrDW(
    DWORD dwDefault,
    HKEY hkey,
    LPTSTR lpSubKey,
    LPTSTR lpValueName)
{
    DWORD dwRet = dwDefault;
    TCHAR szTemp[40];
    TCHAR szDefault[40];

    const LPTSTR pwszd = __TEXT("%d");

    wsprintf(szDefault, pwszd, dwDefault);

    RegQueryStr(
        szDefault,
        hkey,
        lpSubKey,
        lpValueName,
        szTemp,
        sizeof(szTemp));

    dwRet = _ttol(szTemp);

    return dwRet;
}


BOOL RegSetStrDW(
    HKEY hkey,
    LPTSTR lpSection,
    LPCTSTR lpKeyName,
    DWORD dwValue)
{
    BOOL fRet;
    TCHAR szTemp[40];
    const LPTSTR pwszd = __TEXT("%d");

    wsprintf(szTemp, pwszd, dwValue);
    fRet = RegSetStr(hkey, lpSection, lpKeyName, szTemp);

    return fRet;
}


//////////////////////////////////////////////////////////////////////////


/*------------------------------------------------------------------
 * Function void KillAccStat()
 *
 * Purpose     Check if accstat is already running.  If it is we need
 *             to check to see if it should be.  It should only be running
 *             if each feature that is on also has the 'show status on
 *             screen flag checked.  If not we want to kill accstat.
 *
 * Params:     None
 *
 * Return:     TRUE if we had to kill accstat
 *             FALSE if accstat not running/valid session
 *------------------------------------------------------------------*/

void KillAccStat (void) {
   BOOL fCanTurnOff = FALSE;     // Can we turn off accstat due to invalid feature?
   BOOL fValidFeature = FALSE;   // Are there any valid features?

   // Accstat may be running.  Determine if it should be running
   // We need to check the FilterKeys, MouseKeys and StickyKeys
   if (g_sk.dwFlags & SKF_STICKYKEYSON)
      if (!(g_sk.dwFlags & SKF_INDICATOR))
         fCanTurnOff = TRUE;   // A mismatched flag - we MAY be able to turn off.
      else
         fValidFeature = TRUE; // A valid feature - we CAN't turn off accstat.

   if (g_fk.dwFlags & FKF_FILTERKEYSON)
      if (!(g_fk.dwFlags & FKF_INDICATOR))
         fCanTurnOff = TRUE;   // A mismatched flag - we MAY be able to turn off.
      else
         fValidFeature = TRUE; // A valid feature - we CAN't turn off accstat.

   if (g_mk.dwFlags & MKF_MOUSEKEYSON)
      if (!(g_mk.dwFlags & MKF_INDICATOR))
         fCanTurnOff = TRUE;   // A mismatched flag - we MAY be able to turn off.
      else
         fValidFeature = TRUE; // A valid feature - we CAN't turn off accstat.

   // Now we have two flags: fCanTurnOff is TRUE if there is a mismatched flag set
   // ie, feature on, indicator off.  ValidFeature is TRUE if any feature has
   // ON and INDICATOR set which implies accstat must remain active.
   if (!fValidFeature && fCanTurnOff) {
      TCHAR szBuf[256];
      HWND hwndAccStat;
      LoadString(g_hinst, IDS_ACCSTAT_WINDOW_TITLE, szBuf, ARRAY_SIZE(szBuf));
      if (IsWindow(hwndAccStat = FindWindow(NULL, szBuf))) {
         // Note sending 1 as the lParam tells accstat to shutup and
         // go away NOW.
         SendMessage(hwndAccStat, WM_SYSCOMMAND, SC_CLOSE, 1);
      }
   }
}


//////////////////////////////////////////////////////////////////////////


void WINAPI GetAccessibilitySettings (void) {
   BOOL fUpdate;

   if (g_fWinNT == -1) {
      OSVERSIONINFO osvi;
      osvi.dwOSVersionInfoSize = sizeof(osvi);
      GetVersionEx(&osvi);
      g_fWinNT = (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);
   }

   g_fShowWarnMsgOnFeatureActivate = (BOOL) RegQueryInt(TRUE, HKEY_CURRENT_USER,
      GENERAL_KEY, WARNING_SOUNDS);

   s_asPrev.fShowWarnMsgOnFeatureActivate = g_fShowWarnMsgOnFeatureActivate;

   // Query the Sound On Activation entry
   g_fPlaySndOnFeatureActivate = (BOOL) RegQueryInt(TRUE, HKEY_CURRENT_USER,
      GENERAL_KEY, SOUND_ON_ACTIVATION);

   s_asPrev.fPlaySndOnFeatureActivate = g_fPlaySndOnFeatureActivate;

   g_fSaveSettings = TRUE;

   // Keyboard property page
   g_sk.cbSize = sizeof(g_sk);
   AccessSystemParametersInfo(SPI_GETSTICKYKEYS, sizeof(g_sk), &g_sk, 0);
   s_asPrev.sk = g_sk;

   g_fk.cbSize = sizeof(g_fk);
   AccessSystemParametersInfo(SPI_GETFILTERKEYS, sizeof(g_fk), &g_fk, 0);
   g_fk.dwFlags |= FKF_AVAILABLE;

   // FILTERKEYS used to use OLDDISABLED as it's "unused" flag.  This doesn't
   // work very well on NT (SPI_SETFILTERKEYS calls fail).  We now use 0
   // for disabled values.  Take this opertunity to change any OLDDISABLED
   // values to 0 and save if needed.

   fUpdate = FALSE;

   if (OLDDISABLED == g_fk.iBounceMSec)
   {
      g_fk.iBounceMSec = 0;
      fUpdate = TRUE;
   }
   if (OLDDISABLED == g_fk.iDelayMSec)
   {
      g_fk.iDelayMSec = 0;
      fUpdate = TRUE;
   }
   if (OLDDISABLED == g_fk.iRepeatMSec)
   {
      g_fk.iRepeatMSec = 0;
      fUpdate = TRUE;
   }
   if (OLDDISABLED == g_fk.iWaitMSec)
   {
       g_fk.iWaitMSec = 0;
       fUpdate = TRUE;
   }

   if (fUpdate)
   {
        AccessSystemParametersInfo(
                SPI_SETFILTERKEYS, sizeof(g_fk), &g_fk, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
   }

   s_asPrev.fk = g_fk;
   // fix Filter keys bug
   g_dwOrigFKFlags = g_fk.dwFlags;
   g_bFKOn = g_fk.dwFlags & FKF_FILTERKEYSON;

   // g_dwLastBounceKeySetting, g_nLastRepeatDelay, g_nLastRepeatRate
   // and g_nLastWait are part of FilterKeys

   if (0 != g_fk.iBounceMSec) {
      // Bounce keys enabeled
      g_fk.iDelayMSec = 0;
      g_fk.iRepeatMSec = 0;
      g_fk.iWaitMSec = 0;

      g_dwLastBounceKeySetting = g_fk.iBounceMSec;
      g_nLastRepeatDelay = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_DELAY);
      g_nLastRepeatRate = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_RATE);
      g_nLastWait = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_WAIT);
   }
   else
   {
      if (0 == g_fk.iDelayMSec)
      {
          g_fk.iRepeatMSec = 0;
      }
      g_dwLastBounceKeySetting = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_BOUNCE_SETTING);
      g_nLastRepeatDelay = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_DELAY);
      g_nLastRepeatRate = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_RATE);
      if (0 != g_fk.iWaitMSec)
      {
         g_nLastWait = g_fk.iWaitMSec;
      }
      else
      {
         g_nLastWait = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_WAIT);
      }
   }

   g_tk.cbSize = sizeof(g_tk);
   AccessSystemParametersInfo(SPI_GETTOGGLEKEYS, sizeof(g_tk), &g_tk, 0);
   s_asPrev.tk = g_tk;

   AccessSystemParametersInfo(SPI_GETKEYBOARDPREF, 0, &g_fExtraKeyboardHelp, 0);
   s_asPrev.fExtraKeyboardHelp = g_fExtraKeyboardHelp;

   // Sound Property page
   g_ss.cbSize = sizeof(g_ss);
   AccessSystemParametersInfo(SPI_GETSOUNDSENTRY, sizeof(g_ss), &g_ss, 0);
   s_asPrev.ss = g_ss;

   SystemParametersInfo(SPI_GETSHOWSOUNDS, 0, &g_fShowSounds, 0);

   // BUG, BUG GetSystemMetrics() is not updating value on reboot :a-anilk
   // g_fShowSounds = GetSystemMetrics(SM_SHOWSOUNDS);
   s_asPrev.fShowSounds = g_fShowSounds;

   // Display Property page
   g_hc.cbSize = sizeof(g_hc);
   AccessSystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(g_hc), &g_hc, 0);

   // Currently NT will not store these flags.  We fake them so we
   // can tell if they actually changed.

   s_asPrev.hc.lpszDefaultScheme = s_asPrev.szDefaultScheme;
   CopyHighContrast(&s_asPrev.hc, &g_hc);

   SystemParametersInfo(SPI_GETCARETWIDTH, 0, (PVOID)&g_cs.dwCaretWidth, 0);
   g_cs.dwCaretBlinkRate = RegQueryStrDW(
								 DEFAULT_BLINK_RATE
							   , HKEY_CURRENT_USER
							   , CONTROL_PANEL_DESKTOP
							   , CURSOR_BLINK_RATE);
   if (g_cs.dwCaretBlinkRate == BLINK_OFF)
       g_cs.dwCaretBlinkRate = CURSORMAX;
   s_asPrev.cs.dwCaretBlinkRate = g_cs.dwCaretBlinkRate;
   s_asPrev.cs.dwCaretWidth = g_cs.dwCaretWidth;

   // Mouse Property page
   g_mk.cbSize = sizeof(g_mk);
   AccessSystemParametersInfo(SPI_GETMOUSEKEYS, sizeof(g_mk), &g_mk, 0);
   s_asPrev.mk = g_mk;

   // General Property page
   g_ato.cbSize = sizeof(g_ato);
   AccessSystemParametersInfo(SPI_GETACCESSTIMEOUT, sizeof(g_ato), &g_ato, 0);
   s_asPrev.ato = g_ato;

   g_serk.cbSize = sizeof(g_serk);
   g_serk.lpszActivePort = g_szActivePort;
   g_serk.lpszPort = g_szPort;
   AccessSystemParametersInfo(SPI_GETSERIALKEYS, sizeof(g_serk), &g_serk, 0);

   s_asPrev.serk.lpszActivePort = s_asPrev.szActivePort;
   s_asPrev.serk.lpszPort = s_asPrev.szPort;
   CopySerialKeys(&s_asPrev.serk, &g_serk);

   if (NULL == s_asOrg.hc.lpszDefaultScheme)
   {
      // s_asOrg has not yet been initialized
      s_asOrg = s_asPrev;
      s_asOrg.hc.lpszDefaultScheme = s_asOrg.szDefaultScheme;
      s_asOrg.serk.lpszActivePort = s_asOrg.szActivePort;
      s_asOrg.serk.lpszPort = s_asOrg.szPort;
   }
}


//////////////////////////////////////////////////////////////////////////

//a-anilk: Change, Admin options, Keyboard flags: 05/06/99
void WINAPI SetAccessibilitySettings (void) {
   HKEY hkey;
   DWORD dwDisposition;
   UINT fWinIni = SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE;
   BOOL fAnyNotifyChange = FALSE;

   g_SPISetValue = TRUE;

   SetCursor(LoadCursor(NULL, IDC_WAIT));

   if (g_fShowWarnMsgOnFeatureActivate) {
      g_hc.dwFlags |= HCF_CONFIRMHOTKEY;
      g_fk.dwFlags |= FKF_CONFIRMHOTKEY;
      g_sk.dwFlags |= SKF_CONFIRMHOTKEY;
      g_mk.dwFlags |= MKF_CONFIRMHOTKEY;
      g_tk.dwFlags |= TKF_CONFIRMHOTKEY;
   } else {
      g_hc.dwFlags &= ~HCF_CONFIRMHOTKEY;
      g_fk.dwFlags &= ~FKF_CONFIRMHOTKEY;
      g_sk.dwFlags &= ~SKF_CONFIRMHOTKEY;
      g_mk.dwFlags &= ~MKF_CONFIRMHOTKEY;
      g_tk.dwFlags &= ~TKF_CONFIRMHOTKEY;
   }

   if (g_fPlaySndOnFeatureActivate) {
      g_hc.dwFlags  |= HCF_HOTKEYSOUND;
      g_fk.dwFlags  |= FKF_HOTKEYSOUND;
      g_sk.dwFlags  |= SKF_HOTKEYSOUND;
      g_mk.dwFlags  |= MKF_HOTKEYSOUND;
      g_tk.dwFlags  |= TKF_HOTKEYSOUND;
      g_ato.dwFlags |= ATF_ONOFFFEEDBACK;
   } else {
      g_hc.dwFlags  &= ~HCF_HOTKEYSOUND;
      g_fk.dwFlags  &= ~FKF_HOTKEYSOUND;
      g_sk.dwFlags  &= ~SKF_HOTKEYSOUND;
      g_mk.dwFlags  &= ~MKF_HOTKEYSOUND;
      g_tk.dwFlags  &= ~TKF_HOTKEYSOUND;
      g_ato.dwFlags &= ~ATF_ONOFFFEEDBACK;
   }


   // Keyboard property page

   if (0 != memcmp(&g_sk, &s_asPrev.sk, sizeof(g_sk)))
   {
      if (g_fWinNT)
      {
         g_sk.dwFlags &= SKF_VALID;
      }
      AccessSystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(g_sk), &g_sk, fWinIni);
      s_asPrev.sk = g_sk;
      fAnyNotifyChange = TRUE;
   }

	if (g_bFKOn)
		g_fk.dwFlags |= FKF_FILTERKEYSON;
	else
		g_fk.dwFlags &= ~FKF_FILTERKEYSON;

	g_dwOrigFKFlags = g_fk.dwFlags;

   if (0 != memcmp(&g_fk, &s_asPrev.fk, sizeof(g_fk)))
   {
      if (g_fWinNT)
      {
         g_fk.dwFlags &= FKF_VALID;
      }

      // g_dwLastBounceKeySetting, g_nLastRepeatDelay, g_nLastRepeatRate
      // and g_nLastWait are part of FilterKeys

      if (0 != g_fk.iBounceMSec) {
         // Bounce keys enabeled
         g_fk.iDelayMSec = 0;
         g_fk.iRepeatMSec = 0;
         g_fk.iWaitMSec = 0;

         g_dwLastBounceKeySetting = g_fk.iBounceMSec;
      }
      else
      {
         g_nLastWait = g_fk.iWaitMSec;
         if (0 != g_fk.iDelayMSec)
         {
            // Slow key enabled
            g_nLastRepeatDelay = g_fk.iDelayMSec;
            g_nLastRepeatRate = g_fk.iRepeatMSec;
         }
         else
         {
            // neither Bounce or Slow
            g_fk.iRepeatMSec = 0;
         }
      }

      AccessSystemParametersInfo(SPI_SETFILTERKEYS, sizeof(g_fk), &g_fk, fWinIni);
      s_asPrev.fk = g_fk;

      fAnyNotifyChange = TRUE;
   }

   // always save these
   RegSetInt(HKEY_CURRENT_USER, FILTER_KEY, LAST_BOUNCE_SETTING, g_dwLastBounceKeySetting);
   RegSetInt(HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_DELAY, g_nLastRepeatDelay);
   RegSetInt(HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_RATE, g_nLastRepeatRate);
   RegSetInt(HKEY_CURRENT_USER, FILTER_KEY, LAST_WAIT, g_nLastWait);

   if (0 != memcmp(&g_tk, &s_asPrev.tk, sizeof(g_tk)))
   {
      if (g_fWinNT)
      {
         g_tk.dwFlags &= TKF_VALID;
      }
      AccessSystemParametersInfo(SPI_SETTOGGLEKEYS, sizeof(g_tk), &g_tk, fWinIni);
      s_asPrev.tk = g_tk;
      fAnyNotifyChange = TRUE;
   }

   if (g_fExtraKeyboardHelp != s_asPrev.fExtraKeyboardHelp)
   {
	   // Set this too. Some controls check this flag...0x100B
      AccessSystemParametersInfo(SPI_SETKEYBOARDCUES, 0, IntToPtr(g_fExtraKeyboardHelp), fWinIni);

      AccessSystemParametersInfo(SPI_SETKEYBOARDPREF, g_fExtraKeyboardHelp, 0, fWinIni);
      s_asPrev.fExtraKeyboardHelp = g_fExtraKeyboardHelp;
      fAnyNotifyChange = TRUE;
   }

   // Display Property page

   // BUGBUG a-jimhar 03-22-96 verify changes to display property page save
   // code when display page is added back in on NT

   if (!IsHighContrastEqual(&g_hc, &s_asPrev.hc))
   {
      AccessSystemParametersInfo(SPI_SETHIGHCONTRAST, sizeof(g_hc), &g_hc, fWinIni);
      if (ERROR_SUCCESS == RegCreateKeyEx(
         HKEY_CURRENT_USER,
         HC_KEY,
         0,
         __TEXT(""),
         REG_OPTION_NON_VOLATILE,
         KEY_SET_VALUE,
         NULL,
         &hkey,
         &dwDisposition))
      {
         RegSetValueEx(hkey, HIGHCONTRAST_SCHEME, 0, REG_SZ, (PBYTE) g_hc.lpszDefaultScheme,
            (lstrlen(g_hc.lpszDefaultScheme) + 1) * sizeof(*g_hc.lpszDefaultScheme));
         RegSetValueEx(hkey, VOLATILE_SCHEME, 0, REG_SZ, (PBYTE) g_hc.lpszDefaultScheme,
            (lstrlen(g_hc.lpszDefaultScheme) + 1) * sizeof(*g_hc.lpszDefaultScheme));
         RegCloseKey(hkey);
         hkey = NULL;
      }
      CopyHighContrast(&s_asPrev.hc, &g_hc);
      fAnyNotifyChange = TRUE;
   }

   if (g_cs.dwCaretBlinkRate != s_asPrev.cs.dwCaretBlinkRate)
   {
       DWORD dwCaretBlinkRate = (g_cs.dwCaretBlinkRate < CURSORMAX)?g_cs.dwCaretBlinkRate:BLINK_OFF;

	   // Set the blink rate for this session
       SetCaretBlinkTime(dwCaretBlinkRate);

	   // and persist it to the registry
	   RegSetStrDW(HKEY_CURRENT_USER, CONTROL_PANEL_DESKTOP, CURSOR_BLINK_RATE, dwCaretBlinkRate);
   }

   if (g_cs.dwCaretWidth != s_asPrev.cs.dwCaretWidth)
       AccessSystemParametersInfo(SPI_SETCARETWIDTH, 0, IntToPtr(g_cs.dwCaretWidth), fWinIni);

   s_asPrev.cs = g_cs;

   // Mouse Property page
   if (0 != memcmp(&g_mk, &s_asPrev.mk, sizeof(g_mk)))
   {
      if (g_fWinNT)
      {
         g_mk.dwFlags &= MKF_VALID;
      }
      AccessSystemParametersInfo(SPI_SETMOUSEKEYS, sizeof(g_mk), &g_mk, fWinIni);
      s_asPrev.mk = g_mk;
      fAnyNotifyChange = TRUE;
   }

   // General Property page
   if (g_fPlaySndOnFeatureActivate) {
      g_ato.dwFlags |= ATF_ONOFFFEEDBACK;
   } else {
      g_ato.dwFlags &= ~ATF_ONOFFFEEDBACK;
   }

   if (0 != memcmp(&g_ato, &s_asPrev.ato, sizeof(g_ato)))
   {
      if (g_fWinNT)
      {
         g_ato.dwFlags &= ATF_VALID;
      }
      AccessSystemParametersInfo(SPI_SETACCESSTIMEOUT, sizeof(g_ato), &g_ato, fWinIni);
      s_asPrev.ato = g_ato;
      fAnyNotifyChange = TRUE;
   }

   if (!IsSerialKeysEqual(&g_serk, &s_asPrev.serk))
   {
      AccessSystemParametersInfo(SPI_SETSERIALKEYS, sizeof(g_serk), &g_serk, fWinIni);
      CopySerialKeys(&s_asPrev.serk, &g_serk);
      fAnyNotifyChange = TRUE;
   }

   if (g_fSaveSettings) {
      if (RegCreateKeyEx(HKEY_CURRENT_USER, GENERAL_KEY, 0, __TEXT(""), REG_OPTION_NON_VOLATILE,
         KEY_SET_VALUE, NULL, &hkey, &dwDisposition) == ERROR_SUCCESS) {

         // Save the Warning Sounds entry
          if (g_fShowWarnMsgOnFeatureActivate != s_asPrev.fShowWarnMsgOnFeatureActivate)
          {
               RegSetValueEx(hkey, WARNING_SOUNDS, 0, REG_DWORD, (PBYTE) &g_fShowWarnMsgOnFeatureActivate,
                  sizeof(g_fShowWarnMsgOnFeatureActivate));
               s_asPrev.fShowWarnMsgOnFeatureActivate = g_fShowWarnMsgOnFeatureActivate;
          }

         // Save the Sound On Activation entry
          if (g_fPlaySndOnFeatureActivate != s_asPrev.fPlaySndOnFeatureActivate)
          {
              RegSetValueEx(hkey, SOUND_ON_ACTIVATION, 0, REG_DWORD, (PBYTE) &g_fPlaySndOnFeatureActivate,
                sizeof(g_fPlaySndOnFeatureActivate));
              s_asPrev.fPlaySndOnFeatureActivate = g_fPlaySndOnFeatureActivate;
          }
         RegCloseKey(hkey);
         hkey = NULL;
      }
   }

   // Sound Property page
   if (0 != memcmp(&g_ss, &s_asPrev.ss, sizeof(g_ss)))
   {
      if (g_fWinNT)
      {
         g_ss.dwFlags &= SSF_VALID;
      }
      AccessSystemParametersInfo(SPI_SETSOUNDSENTRY, sizeof(g_ss), &g_ss, fWinIni);
      s_asPrev.ss = g_ss;
      fAnyNotifyChange = TRUE;
   }


   // We do the sound property page last because the SPI_SETSHOWSOUNDS call is used
   // to send out notifications.  We make this call if either g_fShowSounds changed
   // or we need to send out notifications
   // Changed Nov.18 '98 to send out WM_SETTINGSCHANGE Seperately.

   if (g_fShowSounds != s_asPrev.fShowSounds /*||
      (fAnyNotifyChange && g_fSaveSettings)*/)
   {
      // if (g_fSaveSettings) fWinIni |= SPIF_SENDWININICHANGE;

      AccessSystemParametersInfo(SPI_SETSHOWSOUNDS, g_fShowSounds, NULL, fWinIni);
      s_asPrev.fShowSounds = g_fShowSounds;
   }

   g_SPISetValue = FALSE;

   // Do Admin options
   SaveDefaultSettings(g_fCopyToLogon, g_fCopyToDefault);

   SetCursor(LoadCursor(NULL, IDC_ARROW));
}


//////////////////////////////////////////////////////////////////////////


INT_PTR WINAPI KeyboardDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR WINAPI SoundDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR WINAPI GeneralDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR WINAPI DisplayDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR WINAPI MouseDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#define MAX_PAGES 10


// ************************************************************************
// OpenAccessPropertySheet
// Opens property sheet
// ************************************************************************

BOOL OpenAccessPropertySheet (HWND hwnd, int nID) {
   HPROPSHEETPAGE rPages[MAX_PAGES];
   PROPSHEETPAGE psp;
   PROPSHEETHEADER psh;
   INT_PTR nPsRet;

   KillAccStat();
   GetAccessibilitySettings();

   // Simple errorchecking - only allow control to move to tabs 0-4.
   // Any tab request greater than 4 is invalid - so default to tab 0
   if ((nID < 0) || (nID > 4)) nID = 0;

   // Initialize the property sheets
   psh.dwSize = sizeof(psh);
   // SteveDon 5-26-98
   // no longer use PSH_PROPTITLE because we want it to read "Accessibility Options"
   // rather than "Accessibility Properties" or "Properties for Accessibility"
   psh.dwFlags = 0;     // psh.dwFlags = PSH_PROPTITLE; // | PSH_PROPSHEETPAGE | PSP_USEICONID;
   psh.hwndParent = hwnd;
   psh.hInstance = g_hinst;
   psh.pszCaption = MAKEINTRESOURCE(IDS_PROPERTY_TITLE); //ACCESSIBILITY);
   psh.pszIcon = MAKEINTRESOURCE(IDI_ACCESS);
   psh.nPages = 0;
   psh.nStartPage = 0;
   psh.phpage = rPages;

   // Add First Sheet, keyboard
   psp.dwSize = sizeof(psp);
   psp.dwFlags = PSP_DEFAULT;
   psp.hInstance = g_hinst;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_KEYBOARD);
   psp.pfnDlgProc = KeyboardDlg;
   psp.lParam = 0;

   psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
   if (psh.phpage[psh.nPages]) psh.nPages++;

   // Add second sheet, Sound
   psp.dwSize = sizeof(psp);
   psp.dwFlags = PSP_DEFAULT;
   psp.hInstance = g_hinst;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_SOUND);
   psp.pfnDlgProc = SoundDlg;
   psp.lParam = 0;

   psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
   if (psh.phpage[psh.nPages]) psh.nPages++;

   // Add third sheet, Display
   psp.dwSize = sizeof(psp);
   psp.dwFlags = PSP_DEFAULT;
   psp.hInstance = g_hinst;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_DISPLAY);
   psp.pfnDlgProc = DisplayDlg;
   psp.lParam = 0;

   psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
   if (psh.phpage[psh.nPages]) psh.nPages++;

   // Add fourth sheet, Mouse
   psp.dwSize = sizeof(psp);
   psp.dwFlags = PSP_DEFAULT;
   psp.hInstance = g_hinst;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_MOUSE);
   psp.pfnDlgProc = MouseDlg;
   psp.lParam = 0;

   psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
   if (psh.phpage[psh.nPages]) psh.nPages++;

   // Add fifth sheet, General
   psp.dwSize = sizeof(psp);
   psp.dwFlags = PSP_DEFAULT;
   psp.hInstance = g_hinst;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_GENERAL);
   psp.pfnDlgProc = GeneralDlg;
   psp.lParam = 0;

   psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
   if (psh.phpage[psh.nPages]) psh.nPages++;

   // Simple errorchecking - only allow control to move to tabs 0 to psh.nPages
   // Any tab request greater than psh.nPages is invalid
   if (0 <= nID && nID < (int)psh.nPages)
   {
      psh.nStartPage = nID;
   }

   nPsRet = PropertySheet(&psh);

   if ( nPsRet <= 0 )
       return FALSE;
   else
       return TRUE;
}

///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\accrare.c ===
/****************************** Module Header ******************************\
* Module Name: accrare.c
*
* Copyright (c) 1985-95, Microsoft Corporation
*
* History:
* 12-18-95 a-jimhar 	Created based on rare.c
\***************************************************************************/


#include "Access.h"

#define REGSTR_PATH_SERIALKEYS  __TEXT("Control Panel\\Accessibility\\SerialKeys")
#define REGSTR_VAL_ACTIVEPORT   __TEXT("ActivePort")
#define REGSTR_VAL_BAUDRATE     __TEXT("BaudRate")
#define REGSTR_VAL_FLAGS        __TEXT("Flags")
#define REGSTR_VAL_PORTSTATE    __TEXT("PortState")

#define PMAP_STICKYKEYS            __TEXT("Control Panel\\Accessibility\\StickyKeys")
#define PMAP_KEYBOARDRESPONSE  __TEXT("Control Panel\\Accessibility\\Keyboard Response")
#define PMAP_MOUSEKEYS		   __TEXT("Control Panel\\Accessibility\\MouseKeys")
#define PMAP_TOGGLEKEYS 	   __TEXT("Control Panel\\Accessibility\\ToggleKeys")
#define PMAP_TIMEOUT		   __TEXT("Control Panel\\Accessibility\\TimeOut")
#define PMAP_SOUNDSENTRY	   __TEXT("Control Panel\\Accessibility\\SoundSentry")
#define PMAP_SHOWSOUNDS 	   __TEXT("Control Panel\\Accessibility\\ShowSounds")

#define ISACCESSFLAGSET(s, flag) ((s).dwFlags & flag)

#define SK_SPI_INITUSER -1

typedef int (*PSKEY_SPI)(
	UINT uAction, 
	UINT uParam, 
	LPSERIALKEYS lpvParam, 
	BOOL fuWinIni);


/****************************************************************************/

BOOL AccessSKeySystemParametersInfo(
	UINT uAction, 
	UINT uParam, 
	LPSERIALKEYS psk, 
	BOOL fu)
{
	BOOL fRet = FALSE;
    static PSKEY_SPI s_pSKEY_SystemParametersInfo =NULL;
    static BOOL s_fSKeySPIAttemptedLoad = FALSE;
#ifdef UNICODE
	static BOOL s_fMustConvert = FALSE;
	CHAR szActivePort[MAX_PATH]; 
	CHAR szPort[MAX_PATH]; 
	PWSTR pszActivePort = NULL; 
	PWSTR pszPort = NULL; 

	Assert(sizeof(szActivePort) == sizeof(g_szActivePort));
    Assert(sizeof(szPort) == sizeof(g_szPort));

#endif


	if (NULL == s_pSKEY_SystemParametersInfo && !s_fSKeySPIAttemptedLoad)
	{
		BOOL fRc = FALSE;
		HINSTANCE hinst = LoadLibrary(__TEXT("SKDLL.DLL"));

		if (NULL != hinst) 
		{

#ifdef UNICODE

			s_pSKEY_SystemParametersInfo = (PSKEY_SPI)GetProcAddress(
				(HMODULE)hinst, "SKEY_SystemParametersInfoW");
			if (NULL == s_pSKEY_SystemParametersInfo) 
			{
				s_pSKEY_SystemParametersInfo = (PSKEY_SPI)GetProcAddress(
					(HMODULE)hinst, "SKEY_SystemParametersInfo");
				s_fMustConvert = TRUE;
			}

#else
			s_pSKEY_SystemParametersInfo = (PSKEY_SPI)GetProcAddress(
				(HMODULE)hinst, "SKEY_SystemParametersInfo");

#endif // UNICODE

			// We don't bother calling FreeLibrary(hinst), the library will be freed
			// when the app terminates
		}
        s_fSKeySPIAttemptedLoad = TRUE;
	}

    if (NULL != s_pSKEY_SystemParametersInfo)
    {

#ifdef UNICODE

		if (s_fMustConvert) 
		{
            memset(szActivePort, 0, sizeof(szActivePort));
            memset(szPort, 0, sizeof(szPort));
            
	        pszActivePort = psk->lpszActivePort; 
            pszPort = psk->lpszPort; 

			if (NULL != psk->lpszActivePort)
			{
				psk->lpszActivePort = (PTSTR)szActivePort;
			}

			if (NULL != psk->lpszPort)
			{
				psk->lpszPort = (PTSTR)szPort; 
			}

            if (SPI_SETSERIALKEYS == uAction)
			{
				if (NULL != psk->lpszActivePort)
				{					
                    WideCharToMultiByte(
						CP_ACP, 0, pszActivePort, -1, 
						(PCHAR)psk->lpszActivePort, MAX_PATH, NULL, NULL);
				}
				if (NULL != psk->lpszPort)
				{				    
					WideCharToMultiByte(
						CP_ACP, 0, pszPort, -1, 
						(PCHAR)psk->lpszPort, MAX_PATH, NULL, NULL);
				}
			}
		}
#endif // UNICODE

		fRet = (BOOL)(*s_pSKEY_SystemParametersInfo)(
    		uAction, 
			uParam, 
			psk, 
			fu);
#ifdef UNICODE

		if (s_fMustConvert && SPI_GETSERIALKEYS == uAction) 
		{

			if (NULL != psk->lpszActivePort)
			{
				MultiByteToWideChar(
					CP_ACP, 0, (PCHAR)psk->lpszActivePort, -1,
					pszActivePort, MAX_PATH);
			}
			if (NULL != psk->lpszPort)
			{
				MultiByteToWideChar(
					CP_ACP, 0, (PCHAR)psk->lpszPort, -1,
					pszPort, MAX_PATH);
			}
		}
		if (NULL != psk->lpszActivePort)
		{
			psk->lpszActivePort = pszActivePort;
		}

		if (NULL != psk->lpszPort)
		{
			psk->lpszPort = pszPort; 
		}

#endif // UNICODE

    }
    return(fRet);
}


/***************************************************************************\
* FixupAndRetrySystemParametersInfo
*
* Used by access but not implemented by NT's SPI:
*
* SPI_GETKEYBOARDPREF
* SPI_SETKEYBOARDPREF
*
* SPI_GETHIGHCONTRAST
* SPI_SETHIGHCONTRAST
*
* SPI_GETSERIALKEYS
* SPI_SETSERIALKEYS
*
*
* History:
* 12-18-95 a-jimhar 	Created, derived from xxxSystemParametersInfo
* 01-22-95 a-jimhar 	Removed old code that worked around NT bugs
*
* On NT this function fixes the parameters and calls SystemParametersInfo
*
\***************************************************************************/

static BOOL FixupAndRetrySystemParametersInfo(
	UINT wFlag,
	DWORD wParam,
	PVOID lParam,
	UINT flags)	// we ignoring this flag 
				// could add support for SPIF_UPDATEINIFILE and SPIF_SENDCHANGE
{
	BOOL fRet = FALSE;
	BOOL fCallSpi = FALSE;
	BOOL fChanged = FALSE;

	if (NULL != (PVOID)lParam)
	{
		switch (wFlag) {


		// Fake support
		case SPI_GETKEYBOARDPREF:
			{
				*(PBOOL) lParam = FALSE;
				fRet = TRUE;
				fCallSpi = FALSE;
			}
			break;

		case SPI_GETSERIALKEYS:
            {
		        LPSERIALKEYS psk = (LPSERIALKEYS)lParam;

			    if (NULL != psk &&
			       (sizeof(*psk) == psk->cbSize || 0 == psk->cbSize))
			    {
					fRet = AccessSKeySystemParametersInfo(
						wFlag, 
						0, 
						psk, 
						TRUE);
                }
                fCallSpi = FALSE;
            }
			break;

		case SPI_SETSERIALKEYS:
            {
		        LPSERIALKEYS psk = (LPSERIALKEYS)lParam;

			    if (NULL != psk &&
			       (sizeof(*psk) == psk->cbSize || 0 == psk->cbSize))
			    {
					fRet = AccessSKeySystemParametersInfo(
						wFlag, 
						0, 
						psk, 
						TRUE);
	    			fChanged = TRUE;
                }
		        fCallSpi = FALSE;
            }
			break;

		default:
			// This function is only for fix-up and second chance calls.
			// We didn't fix anything, don't call SPI.
			fCallSpi = FALSE;
			fRet = FALSE;
			break;
		}
	}

	if (fCallSpi)
	{
		fRet = SystemParametersInfo(wFlag, wParam, lParam, flags);
	}
	else if (fChanged && (flags & SPIF_SENDCHANGE))
	{
        DWORD_PTR dwResult;

        SendMessageTimeout(
			HWND_BROADCAST, 
			WM_WININICHANGE, 
			wFlag, 
			(LONG_PTR)NULL,
            SMTO_NORMAL, 
			100, 
			&dwResult);
	}
	return(fRet);
}

/***************************************************************************\
* AccessSystemParametersInfo
*
* History:
* 12-18-95 a-jimhar 	Created.
\***************************************************************************/

BOOL AccessSystemParametersInfo(
	UINT wFlag,
	DWORD wParam,
	PVOID lParam,
	UINT flags)
{
	BOOL fRet;

	// first give the system SPI a chance

	fRet = SystemParametersInfo(wFlag, wParam, lParam, flags);

	if (!fRet && g_fWinNT)
	{
		// the system SPI failed, fixup the params and try again

		fRet = FixupAndRetrySystemParametersInfo(wFlag, wParam, lParam, flags);
	}

	return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\keybd.c ===
/*******************************************************************
 *    DESCRIPTION: Keyboard Dialog handler
 *******************************************************************/


#include "Access.h"
extern GetAccessibilitySettings();
extern BOOL g_SPISetValue;

extern BOOL g_bFKOn;
extern DWORD g_dwOrigFKFlags ;

// *******************************************************************
// KeyboardDialog handler
// *******************************************************************
BOOL WINAPI KeyboardDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
   STICKYKEYS sk;       // Tmp holder for settings.
   FILTERKEYS fk;
   TOGGLEKEYS tk;
   BOOL fProcessed = TRUE;

   switch (uMsg) {
      case WM_INITDIALOG:
         CheckDlgButton(hwnd, IDC_STK_ENABLE, (g_sk.dwFlags & SKF_STICKYKEYSON) ? TRUE : FALSE);
         if (!(g_sk.dwFlags & SKF_AVAILABLE)) {
            EnableWindow(GetDlgItem(hwnd, IDC_STK_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_STK_ENABLE), FALSE);
         }

         CheckDlgButton(hwnd, IDC_FK_ENABLE, (g_fk.dwFlags & FKF_FILTERKEYSON) ? TRUE : FALSE);
         CheckDlgButton(hwnd, IDC_TK_ENABLE, (g_tk.dwFlags & TKF_TOGGLEKEYSON) ? TRUE : FALSE);
         if (!(g_tk.dwFlags & TKF_AVAILABLE)) {
            EnableWindow(GetDlgItem(hwnd, IDC_TK_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_TK_ENABLE), FALSE);
         }

         CheckDlgButton(hwnd, IDC_SHOWEXTRAKYBDHELP, g_fExtraKeyboardHelp);
         break;

    case WM_HELP:  // F1
         WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
         break;

    case WM_CONTEXTMENU:   // right mouse click
         WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
         break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDC_STK_ENABLE:
               g_sk.dwFlags ^= SKF_STICKYKEYSON;
               SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;

            case IDC_FK_ENABLE:
               g_fk.dwFlags ^= FKF_FILTERKEYSON;
               SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
			   g_bFKOn = !g_bFKOn;
               break;

            case IDC_TK_ENABLE:
               g_tk.dwFlags ^= TKF_TOGGLEKEYSON;
               SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;

            case IDC_STK_SETTINGS:
               sk = g_sk;
               if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_STICKYSETTINGS), hwnd, StickyKeyDlg) == IDCANCEL)
                  g_sk = sk;
               else SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;

            case IDC_FK_SETTINGS:
               fk = g_fk;
               if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_FILTERSETTINGS), hwnd, FilterKeyDlg) == IDCANCEL)
                  g_fk = fk;
               else SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;

            case IDC_TK_SETTINGS:
               tk = g_tk;
               if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_TOGGLESETTINGS), hwnd, ToggleKeySettingsDlg) == IDCANCEL) {
                  g_tk = tk;
               } else SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;

            case IDC_SHOWEXTRAKYBDHELP:
               g_fExtraKeyboardHelp = !g_fExtraKeyboardHelp;
               CheckDlgButton(hwnd, IDC_SHOWEXTRAKYBDHELP, g_fExtraKeyboardHelp);
               SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;
         }
         break;

        case WM_SETTINGCHANGE:

            // This is because, When you setting the values could generate this
           /* if ( FALSE == g_SPISetValue )
            {
                // This needs to be monitered, as in the cases where settings chnage (say in 
                // case of hotkey press. The settings are re-loaded. This is done here so that
                // Keyboard dialog is shown first. a-anilk
                // NOTE: But if you get this up from system tary icons. BUG still EXISTS!!!
                GetAccessibilitySettings();
            }*/
            break;

      case WM_NOTIFY:
         switch (((NMHDR *)lParam)->code) {
            case PSN_APPLY: SetAccessibilitySettings(); break;
         }
         break;

      default: fProcessed = FALSE; break;
   }

   return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\fltrkeys.c ===
// **************************************************************************
// Filterkeys dialogs
// Process the filterkeys dialogs
// **************************************************************************


#include "Access.h"

extern DWORD g_dwOrigFKFlags;
extern BOOL g_bFKOn;

#define SWAP(A, B)   ( A ^= B, B ^= A, A ^= B )

// Prototypes
INT_PTR WINAPI BKDlg (HWND, UINT, WPARAM, LPARAM);
INT_PTR WINAPI RKDlg (HWND, UINT, WPARAM, LPARAM);
BOOL WINAPI NotificationDlg (HWND, UINT, WPARAM, LPARAM);
BOOL SubclassFilterKeysTestBox (UINT uIdTestBox,HWND hDlg);
BOOL SubclassRepeatKeysTestBox (UINT uIdTestBox,HWND hDlg);

// All these are for subclassing, so that pressing TAB stops at the next 
// control after test areas. a-anilk
LRESULT CALLBACK SubclassWndProcFKPrev(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
LRESULT CALLBACK SubclassWndProcFKNext(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
LRESULT CALLBACK SubclassWndProcRKPrev(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
LRESULT CALLBACK SubclassWndProcRKNext(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

// Times are in milliseconds
#define DELAYSIZE	5
UINT uDelayTable[] = { 300, 700, 1000, 1500, 2000 };

// Times are in milliseconds
#define RATESIZE 6
UINT uRateTable[] = { 300, 500, 700, 1000, 1500, 2000 };

// Times are in milliseconds
#define BOUNCESIZE 5
UINT uBounceTable[] = { 500, 700, 1000, 1500, 2000 };

// Times are in milliseconds
// TODO 5, 10, and 20 sec needs change to kernel code (SystemParametersInfo)
#define ACCEPTSIZE 10
UINT uAcceptTable[] = { 0, 300, 500, 700, 1000, 1400, 2000, 5000, 10000, 20000 };

// these are wndprocs for subclassed windows to ignore repeated tab keys in
// some situations.
WNDPROC g_WndProcFKPrev = NULL;
WNDPROC g_WndProcFKNext = NULL;
WNDPROC g_WndProcRKPrev = NULL;
WNDPROC g_WndProcRKNext = NULL;

// other definitions for the keyboard
// UP means key was up before this message, DOWN means key was down
// PRESS means the key is being pressed, RELEASE means key being released

#define KEY_UP      0
#define KEY_DOWN    1

#define KEY_PRESS   0
#define KEY_RELEASE 1

// Macros to look at the lParam of keyboard messages
//
#define SCAN_CODE(theParam)  (LOBYTE (HIWORD(theParam)))
#define EXTENDED(theParam)   ( (HIWORD (theParam) & 0x0100) > 0)
#define SYSKEY(theParam)     ( (HIWORD (theParam) & 0x2000) > 0)
#define MENUMODE(theParam)   ( (HIWORD (theParam) & 0x1000) > 0)
#define PREV_STATE(theParam) ( (HIWORD (theParam) & 0x4000) > 0)
#define TRAN_STATE(theParam) ( (HIWORD (theParam) & 0x8000) > 0)

#define MAKE(theParam)    (TRAN_STATE(theParam) == KEY_PRESS)
#define BREAK(theParam)   (TRAN_STATE(theParam) == KEY_RELEASE)
#define WASUP(theParam)   (PREV_STATE(theParam) == KEY_UP)
#define WASDOWN(theParam) (PREV_STATE(theParam) == KEY_DOWN)

#define FIRSTHIT(theParam) (WASUP(theParam) && MAKE(theParam))

// *************************************************************************
// Process the scrolling messages from our trackbars.
// GENERIC CODE - called for any TrackBar handler.
// Passed in the hwnd, wParam, hwndScroll
// 	we can do all handling and return the new trackbar value without
//    knowing what control it is.
// Returns -1 to mean don't do anything 
// *************************************************************************

int HandleScroll (HWND hwnd, WPARAM wParam, HWND hwndScroll) {
    int nCurSliderPos = (int) SendMessage(
            hwndScroll, TBM_GETPOS, 0, 0);
    int nMaxVal = (int) SendMessage(
                            hwndScroll, TBM_GETRANGEMAX, 0, 0);
    int nMinVal = (int) SendMessage(
                            hwndScroll, TBM_GETRANGEMIN, 0, 0);

    switch (LOWORD(wParam)) {
    case TB_LINEUP:
    case TB_LINEDOWN:
    case TB_THUMBTRACK:
    case TB_THUMBPOSITION:
    case SB_ENDSCROLL:
        break;

    case TB_BOTTOM:
        nCurSliderPos = nMaxVal;
        break;

    case TB_TOP:
        nCurSliderPos = nMinVal;
        break;
    }

    if (nCurSliderPos < nMinVal)
    {
        nCurSliderPos = nMinVal;
    }

    if (nCurSliderPos > nMaxVal)
    {
        nCurSliderPos = nMaxVal;
    }

   SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
   return(nCurSliderPos);
}

// Helper functions

__inline WriteFloat(LPTSTR pszBuf, UINT uVal, LPCTSTR pszUnits)
{
    wsprintf(pszBuf, TEXT("%d.%d %s"), uVal/1000, (uVal % 1000)/100, pszUnits);
}

__inline void HandleSelection(HWND hwnd, UINT *puTable, DWORD *pdwNewValue)
{
    LRESULT i = SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    *pdwNewValue = (i != CB_ERR)?puTable[i]:0;
}

int GetIndex(DWORD dwValue, UINT *puTable, int cSize)
{
    int i;
    for (i = 0; i < cSize; i++) 
    {
        if (puTable[i] >= dwValue) 
            break;
    }

    if (i >= cSize) 
        i = cSize - 1;

    return i;
}

void FillAndSetCombo(HWND hwnd, UINT *puTable, int cItems, int iCurPos, LPCTSTR pszUnits)
{
    int i;
    TCHAR pszItem[100];

    SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
    for (i=0;i<cItems;i++)
    {
        WriteFloat(pszItem, puTable[i], pszUnits);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)pszItem);
    }
    SendMessage(hwnd, CB_SETCURSEL, iCurPos, 0);
}

void TestFilterKeys (BOOL fTurnTestOn)
{
	if (fTurnTestOn) 
	{
		g_fk.dwFlags &= ~FKF_INDICATOR;
		g_fk.dwFlags |= FKF_FILTERKEYSON;
	} 
	else 
	{
		if (g_dwOrigFKFlags & FKF_FILTERKEYSON)
		{
			g_fk.dwFlags |= FKF_FILTERKEYSON;
		}
		else
		{
			g_fk.dwFlags &= ~FKF_FILTERKEYSON;
		}

		if (g_dwOrigFKFlags & FKF_INDICATOR)
		{
			g_fk.dwFlags |= FKF_INDICATOR;
		}
		else
		{
			g_fk.dwFlags &= ~FKF_INDICATOR;
		}
	}

	AccessSystemParametersInfo(SPI_SETFILTERKEYS, sizeof(g_fk), &g_fk, 0);
}


// ****************************************************************************
// Main filter keys dialog handler
// ****************************************************************************

INT_PTR WINAPI FilterKeyDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    FILTERKEYS fk;
    BOOL fProcessed = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
        // Setup hotkey
        CheckDlgButton(hwnd, IDC_FK_HOTKEY, (g_fk.dwFlags & FKF_HOTKEYACTIVE) ? TRUE : FALSE);

        // Setup the radio buttons for SLOW vs BOUNCE keys
        if (0 != g_fk.iBounceMSec) {
            // Bounce keys enabeled
            CheckRadioButton(hwnd, IDC_FK_BOUNCE, IDC_FK_REPEAT, IDC_FK_BOUNCE);
            EnableWindow(GetDlgItem(hwnd, IDC_BK_SETTINGS), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_RK_SETTINGS), FALSE);
        }
        else
        {
            // Slow key enabled
            CheckRadioButton(hwnd, IDC_FK_BOUNCE, IDC_FK_REPEAT, IDC_FK_REPEAT);
            EnableWindow(GetDlgItem(hwnd, IDC_BK_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_RK_SETTINGS), TRUE);
        }

        CheckDlgButton(hwnd, IDC_FK_SOUND, (g_fk.dwFlags & FKF_CLICKON) ? TRUE : FALSE);
        CheckDlgButton(hwnd, IDC_FK_STATUS, (g_fk.dwFlags & FKF_INDICATOR) ? TRUE : FALSE);
        // 
        // SteveDon 5/15/98
        // If the focus is in the TestBox and "Ignore Quick Keystrokes" is on,
        // you have to hold down tab to get out. But as soon as focus leaves,
        // Ignore Quick Keystrokes gets turned off and the tab keys ends up
        // autorepeating very quickly, which (usually) lands you back in the 
        // TestBox. 
        // Solution: ignore repeated tabs in this dialog.
        // Problem: keys don't go to the dialog, they go to the focused
        // control. So: we can try to ignore repeated tab keys for the controls
        // just after the test box and just before the test box, which means 
        // that we need to subclass those window procs.
        if (!SubclassFilterKeysTestBox (IDC_FK_TESTBOX,hwnd))
            return (FALSE);

        break;

    case WM_HELP:
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
        break;
         
    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
               break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_FK_HOTKEY:
            g_fk.dwFlags ^= FKF_HOTKEYACTIVE;
            break;

        case IDC_FK_REPEAT:
            g_fk.iBounceMSec = 0;

            if (g_fk.iDelayMSec == 0)
            {
               g_fk.iDelayMSec = g_nLastRepeatDelay;
               g_fk.iRepeatMSec = g_nLastRepeatRate;
               g_fk.iWaitMSec = g_nLastWait;
            }

            CheckRadioButton(hwnd, IDC_FK_REPEAT, IDC_FK_BOUNCE, IDC_FK_REPEAT);
            EnableWindow(GetDlgItem(hwnd, IDC_BK_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_RK_SETTINGS), TRUE);
            break;

        case IDC_FK_BOUNCE:
            g_fk.iDelayMSec = 0;
            g_fk.iRepeatMSec = 0;
            g_fk.iWaitMSec = 0;

            if (g_fk.iBounceMSec == 0)
            {
                g_fk.iBounceMSec = g_dwLastBounceKeySetting;
            }

            CheckRadioButton(hwnd, IDC_FK_REPEAT, IDC_FK_BOUNCE, IDC_FK_BOUNCE);
            EnableWindow(GetDlgItem(hwnd, IDC_BK_SETTINGS), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_RK_SETTINGS), FALSE);
            break;

        // Settings dialogs
        case IDC_RK_SETTINGS:  // This is RepeatKeys
            fk = g_fk;
            if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_ADVCHARREPEAT), hwnd, RKDlg) == IDCANCEL) {
                    g_fk = fk;
            }
            break;

        case IDC_BK_SETTINGS:    // This is BounceKeys
            fk = g_fk;
            if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_ADVKEYBOUNCE), hwnd, BKDlg) == IDCANCEL) {
                    g_fk = fk;
            }
            break;

        case IDC_FK_SOUND:
            g_fk.dwFlags ^= FKF_CLICKON;
            break;

        case IDC_FK_STATUS:
            g_fk.dwFlags ^= FKF_INDICATOR;
            break;

        // The test edit box is a special control for us.  When we get the
        // focus we turn on the current filterkeys settings, when we
        // leave the text box, we turn them back to what they were.
        case IDC_FK_TESTBOX:
            switch (HIWORD(wParam)) {
            case EN_SETFOCUS:  TestFilterKeys(TRUE); break;
            case EN_KILLFOCUS: TestFilterKeys(FALSE); break;
            }
            break;

        case IDOK:
            if (g_dwLastBounceKeySetting == 0)
                g_dwLastBounceKeySetting = uBounceTable[0];
            EndDialog(hwnd, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        }
        break;

    default:
        fProcessed = FALSE; break;
    }
    return(fProcessed);
}


void PutNumInEdit (HWND hwndEdit, int nNum) 
{
   TCHAR szBuf[10], szBuf2[20];
   wsprintf(szBuf, __TEXT("%d.%d"), nNum / 1000, (nNum % 1000) / 100);
   GetNumberFormat(LOCALE_USER_DEFAULT, 0, szBuf, NULL, szBuf2, 20);
   SetWindowText(hwndEdit, szBuf2);
}


// **************************************************************************
// BKDlg
// Process the BounceKeys dialog.
// **************************************************************************
INT_PTR WINAPI BKDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    int     i;
    BOOL fProcessed = TRUE;
    TCHAR pszSeconds[50];
    int ctch;
   
    switch (uMsg) {
    case WM_INITDIALOG:
        ctch = LoadString(g_hinst, IDS_SECONDS, pszSeconds, ARRAY_SIZE(pszSeconds));
        Assert(ctch);
        // Determine the bounce.  Make sure its a valide value.
        if (g_dwLastBounceKeySetting == 0)
            g_dwLastBounceKeySetting = 500;

        if (g_fk.iBounceMSec == 0)
            g_fk.iBounceMSec = g_dwLastBounceKeySetting;

        i = GetIndex(g_fk.iBounceMSec, uBounceTable, BOUNCESIZE);
        FillAndSetCombo(GetDlgItem(hwnd, IDC_CMB_BK_BOUNCERATE), uBounceTable, BOUNCESIZE, i, pszSeconds);
        break;

    case WM_HELP:      // F1
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        // The test edit box is a special control for us.  When we get the
        // focus we turn on the current filterkeys settings, when we
        // leave the text box, we turn them back to what they were.
        case IDC_BK_TESTBOX:
            switch (HIWORD(wParam)) {
            case EN_SETFOCUS:  TestFilterKeys(TRUE); break;
            case EN_KILLFOCUS: TestFilterKeys(FALSE); break;
            }
            break;
        
        case IDC_CMB_BK_BOUNCERATE:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                HandleSelection(GetDlgItem(hwnd, IDC_CMB_BK_BOUNCERATE), uBounceTable, &g_fk.iBounceMSec);
                break;
            }
            break;

        case IDOK:
            // Save the last known valid setting.
            g_dwLastBounceKeySetting = g_fk.iBounceMSec;
            EndDialog(hwnd, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        }
        break;

    default: fProcessed = FALSE; break;
    }
    return(fProcessed);
}

// **************************************************************************
// RKDlg
// Process the RepeatKeys dialog.
// **************************************************************************

INT_PTR WINAPI RKDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    int     i;
    BOOL  fProcessed = TRUE;
    static s_fRepeating = TRUE;
    static DWORD s_nLastRepeatDelayOld;
    static DWORD s_nLastRepeatRateOld;
    static DWORD s_nLastWaitOld;
    TCHAR pszItem[100];
    TCHAR pszSeconds[50];
    int ctch;
    LPARAM lParamT;

    switch(uMsg) {
    case WM_INITDIALOG:
        ctch = LoadString(g_hinst, IDS_SECONDS, pszSeconds, ARRAY_SIZE(pszSeconds));
        Assert(ctch);

        s_nLastRepeatDelayOld = g_nLastRepeatDelay;
        s_nLastRepeatRateOld = g_nLastRepeatRate;
        s_nLastWaitOld = g_nLastWait;

        s_fRepeating = (0 != g_fk.iDelayMSec);
        CheckRadioButton(hwnd, IDC_RK_NOREPEAT, IDC_RK_REPEAT,
             s_fRepeating ? IDC_RK_REPEAT : IDC_RK_NOREPEAT);

        if (!s_fRepeating) {
            // Set FilterKey values to LastRepeat values
            // so the sliders will still get initialized correctly
            g_fk.iDelayMSec = g_nLastRepeatDelay;
            g_fk.iRepeatMSec = g_nLastRepeatRate;
        }

        // Initialize the Acceptance combo box to last valid state
        i = GetIndex(g_fk.iWaitMSec, uAcceptTable, ACCEPTSIZE);
        FillAndSetCombo(GetDlgItem(hwnd, IDC_CMB_RK_ACCEPTRATE), uAcceptTable, ACCEPTSIZE, i, pszSeconds);
        g_fk.iWaitMSec = uAcceptTable[i];

        // Initialize the Delay combo box
        i = GetIndex(g_fk.iDelayMSec, uDelayTable, DELAYSIZE);
        FillAndSetCombo(GetDlgItem(hwnd, IDC_CMB_RK_DELAYRATE), uDelayTable, DELAYSIZE, i, pszSeconds);
        g_fk.iDelayMSec = uDelayTable[i];

        // Initialize the Repeat Rate Slider  Note -1 is set via the checkbox.
        i = GetIndex(g_fk.iRepeatMSec, uRateTable, RATESIZE);
        FillAndSetCombo(GetDlgItem(hwnd, IDC_CMB_RK_REPEATRATE), uRateTable, RATESIZE, i, pszSeconds);
        g_fk.iRepeatMSec = uRateTable[i];

        // Now cleanup from initialization. Disable controls
        // that usable... Swap back any params needed
        if (!s_fRepeating) 
        {
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_REPEATRATE), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_DELAYRATE), FALSE);

            // If we're not repeating, now set the value to 0
            // which indicates max repeat rate.
            g_fk.iDelayMSec = 0;
            g_fk.iRepeatMSec = 0;
        }
        // 
        // SteveDon 5/15/98
        // If the focus is in the TestBox and "Ignore Quick Keystrokes" is on,
        // you have to hold down tab to get out. But as soon as focus leaves,
        // Ignore Quick Keystrokes gets turned off and the tab keys ends up
        // autorepeating very quickly, which (usually) lands you back in the 
        // TestBox. 
        // Solution: ignore repeated tabs in this dialog.
        // Problem: keys don't go to the dialog, they go to the focused
        // control. So: we can try to ignore repeated tab keys for the controls
        // just after the test box and just before the test box, which means 
        // that we need to subclass those window procs.
        if (!SubclassRepeatKeysTestBox (IDC_RK_TESTBOX,hwnd))
            return (FALSE);
        break;

    case WM_HELP:      // F1
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        // Turn on repeat keys - We're disabling via CPL rather than any flags in the call
        case IDC_RK_REPEAT:
            if (!s_fRepeating) {
                g_fk.iDelayMSec = g_nLastRepeatDelay;
                g_fk.iRepeatMSec = g_nLastRepeatRate;
            }

            // Now that we have valid parameters, continue with setting the sliders.
            s_fRepeating = TRUE;
            CheckRadioButton(hwnd, IDC_RK_NOREPEAT, IDC_RK_REPEAT, IDC_RK_REPEAT);
            if (g_fk.iRepeatMSec == 0) 
                g_fk.iRepeatMSec = uRateTable[0];
            if (g_fk.iDelayMSec == 0)
                g_fk.iDelayMSec = uDelayTable[0];

            i = GetIndex(g_fk.iRepeatMSec, uRateTable, RATESIZE);
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_REPEATRATE), TRUE);
            SendDlgItemMessage(hwnd, IDC_CMB_RK_REPEATRATE, CB_SETCURSEL, i, 0);
            i = GetIndex(g_fk.iDelayMSec, uDelayTable, DELAYSIZE);
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_DELAYRATE), TRUE);
            SendDlgItemMessage(hwnd, IDC_CMB_RK_DELAYRATE, CB_SETCURSEL, i, 0);
            break;

        // Turn OFF repeat keys
        case IDC_RK_NOREPEAT:
            s_fRepeating = FALSE;
            CheckRadioButton(hwnd, IDC_RK_NOREPEAT, IDC_RK_REPEAT, IDC_RK_NOREPEAT);
            g_fk.iDelayMSec = 0;
            g_fk.iRepeatMSec = 0;
            SendDlgItemMessage(hwnd, IDC_CMB_RK_DELAYRATE, CB_SETCURSEL, -1, 0);
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_DELAYRATE), FALSE);
            SendDlgItemMessage(hwnd, IDC_CMB_RK_REPEATRATE, CB_SETCURSEL, -1, 0);
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_REPEATRATE), FALSE);
            break;

        // Process the test box - turnon filterkeys while inside it.
        case IDC_RK_TESTBOX:
            switch (HIWORD(wParam)) {
            case EN_SETFOCUS:  TestFilterKeys(TRUE); break;
            case EN_KILLFOCUS: TestFilterKeys(FALSE); break;
            }
            break;
        
        case IDC_CMB_RK_DELAYRATE:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                HandleSelection(GetDlgItem(hwnd, IDC_CMB_RK_DELAYRATE), uDelayTable, &g_fk.iDelayMSec);
                break;
            }
            break;
        
        case IDC_CMB_RK_REPEATRATE:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                HandleSelection(GetDlgItem(hwnd, IDC_CMB_RK_REPEATRATE), uRateTable, &g_fk.iRepeatMSec);
                break;
            }
            break;
        
        case IDC_CMB_RK_ACCEPTRATE:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                HandleSelection(GetDlgItem(hwnd, IDC_CMB_RK_ACCEPTRATE), uAcceptTable, &g_fk.iWaitMSec);
                break;
            }
            break;

        case IDOK:
            // Save off repeating values to registry
            EndDialog(hwnd, IDOK);
            break;

        case IDCANCEL:
            g_nLastRepeatDelay = s_nLastRepeatDelayOld;
            g_nLastRepeatRate = s_nLastRepeatRateOld;
            g_nLastWait = s_nLastWaitOld;

            EndDialog(hwnd, IDCANCEL);
            break;
        }

        break;

    default:
        fProcessed = FALSE;
        break;
    }
    return(fProcessed);
}

// **************************************************************************
// SubclassFilterKeysTestBox
//
// This takes the dialog ID of an edit field, and then finds the controls
// near the edit field (the controls 2 windows before and 2 windows after the 
// edit control in the z-order). These are the nearest controls that get
// keyboard messages. It subclasses both of these controls
// so that they ignore any WM_KEYDOWN messages when the key being pressed is
// the tab key and the key is already down (i.e. this is a repeated message)
//
// **************************************************************************
BOOL SubclassFilterKeysTestBox (UINT uIdTestBox,HWND hDlg)
{
	HWND	hwndPrev,
			hwndNext,
			hwndTestBox;

    hwndTestBox = GetDlgItem (hDlg,uIdTestBox);
	// BE CAREFUL IF DIALOG CHANGES! Right now the 
	// Previous Previous window is the "S&ettings" push button,
	// and the Next Next is the "&Beep when keys pressed..."
	// checkbox. If the order changes, this code might have to change too.
	// Could make it more general where it searches for controls before
	// and after that can get keyboard focus.
    hwndPrev = GetNextDlgTabItem (hDlg,hwndTestBox,TRUE);
    if (!hwndPrev)
        return FALSE;

	g_WndProcFKPrev = (WNDPROC) GetWindowLongPtr (hwndPrev, GWLP_WNDPROC);
	SetWindowLongPtr (hwndPrev,GWLP_WNDPROC,(LPARAM)SubclassWndProcFKPrev);

    hwndNext = GetNextDlgTabItem (hDlg,hwndTestBox,FALSE);
    if (!hwndNext)
        return FALSE;

	g_WndProcFKNext = (WNDPROC) GetWindowLongPtr (hwndNext, GWLP_WNDPROC);
	SetWindowLongPtr (hwndNext,GWLP_WNDPROC,(LPARAM)SubclassWndProcFKNext);
	
	return TRUE;
}

// **************************************************************************
// SubclassWndProcFKPrev
//
//  This is the WndProc used to ignore repeated presses of the tab key for 
//  the first focusable control that precedes the test box.
//
// **************************************************************************
LRESULT CALLBACK SubclassWndProcFKPrev(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
		case WM_KEYDOWN:
			if ((int)wParam == VK_TAB)
			{
				if (WASDOWN (lParam))
				{
					return (0);
				}
				// if not a repeat, need to move the focus. For some reason,
				// just calling CallWindowProc won't do it for us.
				if (GetKeyState(VK_SHIFT) < 0)
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,1,0);
				}
				else
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,0,0);
				}
			}
			break;
		
		case WM_GETDLGCODE:
			return (DLGC_WANTTAB | CallWindowProc (g_WndProcFKPrev,hwnd,uMsg,wParam,lParam));
			break;
    }
    return (CallWindowProc(g_WndProcFKPrev,hwnd,uMsg,wParam,lParam));
}

// **************************************************************************
// SubclassWndProcFKNext
//
//  This is the WndProc used to ignore repeated presses of the tab key for 
//  the first focusable control that follows the test box.
//
// **************************************************************************
LRESULT CALLBACK SubclassWndProcFKNext(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
		case WM_KEYDOWN:
			if ((int)wParam == VK_TAB)
			{
				if (WASDOWN(lParam))
				{
					return (0);
				}
				// if not a repeat, need to move the focus. For some reason,
				// just calling CallWindowProc won't do it for us.
				if (GetKeyState(VK_SHIFT) < 0)
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,1,0);
				}
				else
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,0,0);
				}
			}
			break;
		
		case WM_GETDLGCODE:
			return (DLGC_WANTTAB | CallWindowProc (g_WndProcFKNext,hwnd,uMsg,wParam,lParam));
			break;
    }
    return (CallWindowProc(g_WndProcFKNext,hwnd,uMsg,wParam,lParam));
}

// **************************************************************************
// SubclassRepeatKeysTestBox
//
//  Same as SubclassFilterKeysTestBox, but keeps it's info in different
//  globals so that one doesn't overwrite the other.
//
// **************************************************************************
BOOL SubclassRepeatKeysTestBox (UINT uIdTestBox,HWND hDlg)
{
	HWND	hwndPrev,
			hwndNext,
			hwndTestBox;

    hwndTestBox = GetDlgItem (hDlg,uIdTestBox);
	// BE CAREFUL IF DIALOG CHANGES! Right now the 
	// Previous Previous window is the "S&ettings" push button,
	// and the Next Next is the "&Beep when keys pressed..."
	// checkbox. If the order changes, this code might have to change too.
	// Could make it more general where it searches for controls before
	// and after that can get keyboard focus.
    hwndPrev = GetNextDlgTabItem (hDlg,hwndTestBox,TRUE);
	g_WndProcRKPrev = (WNDPROC) GetWindowLongPtr (hwndPrev,GWLP_WNDPROC);
	SetWindowLongPtr (hwndPrev,GWLP_WNDPROC,(LPARAM)SubclassWndProcRKPrev);

    hwndNext = GetNextDlgTabItem (hDlg,hwndTestBox,FALSE);
	g_WndProcRKNext = (WNDPROC) GetWindowLongPtr (hwndNext,GWLP_WNDPROC);
	SetWindowLongPtr (hwndNext,GWLP_WNDPROC,(LPARAM)SubclassWndProcRKNext);
	
	return (TRUE);
}

// **************************************************************************
// SubclassWndProcRKPrev
//
// **************************************************************************
LRESULT CALLBACK SubclassWndProcRKPrev(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
		case WM_KEYDOWN:
			if ((int)wParam == VK_TAB)
			{
				if (WASDOWN (lParam))
				{
					return (0);
				}
				// if not a repeat, need to move the focus. For some reason,
				// just calling CallWindowProc won't do it for us.
				if (GetKeyState(VK_SHIFT) < 0)
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,1,0);
				}
				else
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,0,0);
				}
			}
			break;
		
		case WM_GETDLGCODE:
			return (DLGC_WANTTAB | CallWindowProc (g_WndProcRKPrev,hwnd,uMsg,wParam,lParam));
			break;
    }
    return (CallWindowProc(g_WndProcRKPrev,hwnd,uMsg,wParam,lParam));
}

// **************************************************************************
// SubclassWndProcRKNext
//
// **************************************************************************
LRESULT CALLBACK SubclassWndProcRKNext(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
		case WM_KEYDOWN:
			if ((int)wParam == VK_TAB)
			{
				if (WASDOWN(lParam))
				{
					return (0);
				}
				// if not a repeat, need to move the focus. For some reason,
				// just calling CallWindowProc won't do it for us.
				if (GetKeyState(VK_SHIFT) < 0)
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,1,0);
				}
				else
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,0,0);
				}
			}
			break;
		
		case WM_GETDLGCODE:
			return (DLGC_WANTTAB | CallWindowProc (g_WndProcRKNext,hwnd,uMsg,wParam,lParam));
			break;
    }
    return (CallWindowProc(g_WndProcRKNext,hwnd,uMsg,wParam,lParam));
}

///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\display.c ===
/******************************************************************************
Module name: Display.C
Purpose: Display Dialog handler
******************************************************************************/


#include "Access.h"
#include "winuserp.h"

static BOOL s_fBlink = TRUE;
static RECT s_rCursor;

//////////////////////////////////////////////////////////////////////////////
/*******************************************************************
 *	  DESCRIPTION: High Contrast dialog handler
 *******************************************************************/

VOID FillCustonSchemeBox (HWND hwndCB) {
    HKEY hkey;
    int i;
    DWORD dwDisposition;

    // Get the class name and the value count.
    if (RegCreateKeyEx(HKEY_CURRENT_USER, CONTROL_KEY, 0, __TEXT(""),
        REG_OPTION_NON_VOLATILE, KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
        NULL, &hkey, &dwDisposition) != ERROR_SUCCESS) return;

    // Enumerate the child keys.
    for (i = 0; ; i++) {
        DWORD cbValueName;
        TCHAR szValueName[MAX_SCHEME_NAME_SIZE];
        LONG l;

        cbValueName = MAX_SCHEME_NAME_SIZE;
        l = RegEnumValue(hkey, i, szValueName, &cbValueName, NULL, NULL, NULL, NULL);
        if (ERROR_NO_MORE_ITEMS == l) break;

        // Add each value to a combobox.
        if (lstrlen(szValueName) == 0) lstrcpy(szValueName, __TEXT("<NO NAME>"));
        ComboBox_AddString(hwndCB, ((szValueName[0] == 0) ? __TEXT("<NO NAME>") : szValueName));
    }
    RegCloseKey(hkey);
}



// ****************************************************************************
// Main HC Dialog handler
// ****************************************************************************
INT_PTR WINAPI HighContrastDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    HKEY  hkey;
    HWND  hwndCB = GetDlgItem(hwnd, IDC_HC_DEFAULTSCHEME);
    int   i;
    DWORD dwDisposition;
    BOOL  fProcessed = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
        CheckDlgButton(hwnd, IDC_HC_HOTKEY, (g_hc.dwFlags & HCF_HOTKEYACTIVE) ? TRUE : FALSE);

        //
        // Put possible high contrast schemes in combo
        // box and show the current one
        //
        // ISSUE: If MUI is enabled then displaying the strings from the registry may
        //        be incorrect.  It should be in the language currently selected.

        FillCustonSchemeBox(hwndCB);

        // Set the proper selection in the combobox (handle case where it's not set yet)
        if (g_hc.lpszDefaultScheme[0] == 0) 
        {
            if (!IsMUI_Enabled())
            {
                // get scheme name from resources if not MUI enabled
                LoadString(g_hinst, IDS_WHITEBLACK_SCHEME, g_hc.lpszDefaultScheme, 200);
            }
            else
            {
                // else set scheme name in english
                lstrcpy(g_hc.lpszDefaultScheme, IDSENG_WHITEBLACK_SCHEME);
            }
        }
        if (ComboBox_SelectString(hwndCB, -1, g_hc.lpszDefaultScheme) == CB_ERR) {
            // Not found, select the 1st one 
            // TODO this is bad! When MUI enabled we will rarely find the correct scheme!
            ComboBox_SetCurSel(hwndCB, 0);
        }
        break;

    case WM_HELP:         // F1
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_CONTEXTMENU:  // right mouse click
        WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
        break;

   // Handle the generic commands
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_HC_HOTKEY:
               g_hc.dwFlags ^=  HCF_HOTKEYACTIVE;
               break;

        case IDC_HC_DEFAULTSCHEME:
               if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE) {
                       // Get the current string into our variable
                       i = ComboBox_GetCurSel(hwndCB);
                       ComboBox_GetLBText(hwndCB, i, g_hc.lpszDefaultScheme);
               }
               break;

        case IDOK:
               // Save the current custom scheme to the registry.
               if (ERROR_SUCCESS == RegCreateKeyEx(
                      HKEY_CURRENT_USER,
                      HC_KEY,
                      0,
                      __TEXT(""),
                      REG_OPTION_NON_VOLATILE,
                      KEY_EXECUTE | KEY_QUERY_VALUE | KEY_SET_VALUE,
                      NULL,
                      &hkey,
                      &dwDisposition)) {

                      TCHAR szCust[MAX_SCHEME_NAME_SIZE];

                      i = ComboBox_GetCurSel(hwndCB);
                      ComboBox_GetLBText(hwndCB, i, szCust);
                      // Abandon "Last Custom Scheme" (never written correctly (#954))
                      RegSetValueEx(hkey
                          , CURR_HC_SCHEME
                          , 0, REG_SZ
                          , (PBYTE) szCust
                          , lstrlen(szCust)*sizeof(TCHAR));
               }
               EndDialog(hwnd, IDOK);
               break;

        case IDCANCEL:
               EndDialog(hwnd, IDCANCEL);
               break;
        }
        break;

        default:
               fProcessed = FALSE; break;
   }
   return((INT_PTR) fProcessed);
}

void DrawCaret(HWND hwnd, BOOL fClearFirst)
{
    HWND hwndCursor = GetDlgItem(hwnd, IDC_KCURSOR_BLINK);
    HDC hDC = GetDC(hwnd);
    if (hDC)
    {
        HBRUSH hBrush;
        if (fClearFirst)
        {
            hBrush = GetSysColorBrush(COLOR_MENU);
            if (hBrush)
            {
                RECT rect;
                GetWindowRect(hwndCursor, &rect);
                MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&rect, 2);
                FillRect(hDC, &rect, hBrush);
                InvalidateRect(hwndCursor, &rect, TRUE);
            }
        }
        hBrush = GetSysColorBrush(COLOR_BTNTEXT);
        if (hBrush)
        {
            FillRect(hDC, &s_rCursor, hBrush);
            InvalidateRect(hwndCursor, &s_rCursor, TRUE);
        }
        ReleaseDC(hwnd,hDC);
    }
}

void OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    if (wParam == BLINK)
    {
        BOOL fNoBlinkRate = (g_cs.dwNewCaretBlinkRate == CURSORMAX)?TRUE:FALSE;
        if (s_fBlink || fNoBlinkRate)
        {
            DrawCaret(hwnd, fNoBlinkRate);
        }
        else
	    {
            InvalidateRect(GetDlgItem(hwnd, IDC_KCURSOR_BLINK), NULL, TRUE);
	    }

        if (fNoBlinkRate)
            KillTimer(hwnd, wParam);

        s_fBlink = !s_fBlink;
    }
}

void OnHScroll( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    if ((HWND)lParam == GetDlgItem(hwnd, IDC_KCURSOR_RATE))
    {
        // blink rate setting

        int nCurrent = (int)SendMessage( (HWND)lParam, TBM_GETPOS, 0, 0L );
        g_cs.dwNewCaretBlinkRate = CURSORSUM - (nCurrent * 100);

        // reset the bink rate timer

        SetTimer(hwnd, BLINK, g_cs.dwNewCaretBlinkRate, NULL);

        if (g_cs.dwNewCaretBlinkRate == CURSORMAX) // draw the caret immediately; if we wait
            DrawCaret(hwnd, TRUE);      // for the timer there is a visible delay
        
        SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
    }
    else if ((HWND)lParam == GetDlgItem(hwnd, IDC_KCURSOR_WIDTH))
    {
        // cursor width setting

        g_cs.dwNewCaretWidth = (int)SendMessage( (HWND)lParam, TBM_GETPOS, 0, 0L );
	    
	    s_rCursor.right = s_rCursor.left + g_cs.dwNewCaretWidth;
        DrawCaret(hwnd, (g_cs.dwNewCaretBlinkRate == CURSORMAX));
        SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
    }
}

void InitCursorCtls(HWND hwnd)
{
    g_cs.dwNewCaretWidth = g_cs.dwCaretWidth;
    g_cs.dwNewCaretBlinkRate = g_cs.dwCaretBlinkRate;

    // Update the Caret UI
    SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_WIDTH), TBM_SETRANGE, 0, MAKELONG(1, 20));
    SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_WIDTH), TBM_SETPOS, TRUE, (LONG)g_cs.dwCaretWidth);

    SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_RATE), TBM_SETRANGE, 0, MAKELONG(CURSORMIN / 100, CURSORMAX / 100));
    SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_RATE), TBM_SETPOS, TRUE, (LONG)(CURSORSUM - g_cs.dwCaretBlinkRate) / 100);

    // Update Blink and caret size
    GetWindowRect(GetDlgItem(hwnd, IDC_KCURSOR_BLINK), &s_rCursor);
    MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&s_rCursor, 2);
    s_rCursor.right = s_rCursor.left + g_cs.dwCaretWidth;
}

// *******************************************************************
// DisplayDialog handler
// *******************************************************************
INT_PTR WINAPI DisplayDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
   HIGHCONTRAST hc;
   TCHAR szScheme[MAX_SCHEME_NAME_SIZE];
   BOOL fProcessed = TRUE;

   switch (uMsg) {
   case WM_INITDIALOG:
	  CheckDlgButton(hwnd, IDC_HC_ENABLE,
		 (g_hc.dwFlags & HCF_HIGHCONTRASTON) ? TRUE : FALSE);

	  if (!(g_hc.dwFlags & HCF_AVAILABLE)) {
		 EnableWindow(GetDlgItem(hwnd, IDC_HC_SETTINGS), FALSE);
		 EnableWindow(GetDlgItem(hwnd,IDC_HC_ENABLE), FALSE);
	  }
      InitCursorCtls(hwnd);
	  break;

   case WM_TIMER:
      OnTimer(hwnd, wParam, lParam);
      break;

   case WM_HSCROLL:
      OnHScroll(hwnd, wParam, lParam);
      break;

   case WM_HELP:
	  WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
	  break;

   case WM_CONTEXTMENU:
	  WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
	  break;

    // sliders don't get this message so pass it on
	case WM_SYSCOLORCHANGE:
		SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_WIDTH), WM_SYSCOLORCHANGE, 0, 0);
		SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_RATE), WM_SYSCOLORCHANGE, 0, 0);
		break;

   case WM_COMMAND:
	  switch (GET_WM_COMMAND_ID(wParam, lParam)) {
	  case IDC_HC_ENABLE:
		 g_hc.dwFlags ^= HCF_HIGHCONTRASTON;
		 SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
		 break;

	  case IDC_HC_SETTINGS:
          {
              INT_PTR RetValue;

              hc = g_hc;
              lstrcpy(szScheme, g_hc.lpszDefaultScheme);
              RetValue = DialogBox(g_hinst, MAKEINTRESOURCE(IDD_HIGHCONSETTINGS), hwnd, HighContrastDlg);
              
              if ( RetValue == IDCANCEL) 
              {
                  g_hc = hc;
                  lstrcpy(g_hc.lpszDefaultScheme, szScheme);
              } 
              else 
              {
                  SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
              }
          }
          break;
	  }
	  break;

   case WM_NOTIFY:
	  switch (((NMHDR *)lParam)->code) {
	  case PSN_APPLY: SetAccessibilitySettings(); break;
      case PSN_KILLACTIVE: 
         KillTimer(hwnd, BLINK); 
         g_cs.dwCaretBlinkRate = g_cs.dwNewCaretBlinkRate;
         g_cs.dwCaretWidth = g_cs.dwNewCaretWidth;
         break;

      case PSN_SETACTIVE:
         SetTimer(hwnd
                , BLINK
                , (g_cs.dwNewCaretBlinkRate < CURSORMAX)?g_cs.dwNewCaretBlinkRate:0
                , NULL);
         break;
	  }
	  break;

   default:
	  fProcessed = FALSE;
	  break;
   }

   return(fProcessed);
}

BOOL IsMUI_Enabled()
{

    OSVERSIONINFO verinfo;
    LANGID        rcLang;
    HMODULE       hModule;
    pfnGetUserDefaultUILanguage gpfnGetUserDefaultUILanguage;     
    pfnGetSystemDefaultUILanguage gpfnGetSystemDefaultUILanguage; 
    static        g_bPFNLoaded=FALSE;
    static        g_bMUIStatus=FALSE;


    if(g_bPFNLoaded)
       return g_bMUIStatus;

    g_bPFNLoaded = TRUE;

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);    
    GetVersionEx( &verinfo) ;

    if (verinfo.dwMajorVersion == 5)        
    {   

       hModule = GetModuleHandle(TEXT("kernel32.dll"));
       if (hModule)
       {
          gpfnGetSystemDefaultUILanguage =
          (pfnGetSystemDefaultUILanguage)GetProcAddress(hModule,"GetSystemDefaultUILanguage");
          if (gpfnGetSystemDefaultUILanguage)
          {
             rcLang = (LANGID) gpfnGetSystemDefaultUILanguage();
             if (rcLang == 0x409 )
             {  
                gpfnGetUserDefaultUILanguage =
                (pfnGetUserDefaultUILanguage)GetProcAddress(hModule,"GetUserDefaultUILanguage");
                
                if (gpfnGetUserDefaultUILanguage)
                {
                   if (rcLang != (LANGID)gpfnGetUserDefaultUILanguage() )
                   {
                       g_bMUIStatus = TRUE;
                   }

                }
             }
          }
       }
    }
    return g_bMUIStatus;
}



///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\main.c ===
// ********************************************************************
// Main.c
// Main init entry into the Human Accessibilities Control panel applet
// ********************************************************************

#include <assert.h>

#pragma comment(lib, "comctl32.lib")

#include "Access.h"

HINSTANCE g_hinst = NULL;

BOOL OpenAccessPropertySheet (HWND, int);

// Define our help data structure
const DWORD g_aIds[] = {
#if 1
   IDC_NO_HELP_1,			NO_HELP,
   IDC_STK_ENABLE,			IDH_STICKYKEYS_ENABLE,
   IDC_SK_TEXT,             IDH_STICKYKEYS_ENABLE,
   IDC_STK_SETTINGS,		IDH_STICKYKEYS_SETTINGS,
   IDC_FK_ENABLE,			IDH_FILTERKEYS_ENABLE,
   IDC_FK_TEXT,             IDH_FILTERKEYS_ENABLE,
   IDC_FK_SETTINGS,			IDH_FILTERKEYS_SETTINGS,
   IDC_TK_ENABLE,			IDH_TOGGLEKEYS_ENABLE,
   IDC_TK_TEXT,             IDH_TOGGLEKEYS_ENABLE,
   IDC_TK_SETTINGS,			IDH_TOGGLEKEYS_SETTINGS,
   IDC_STK_HOTKEY,			IDH_STICKYKEYS_HOTKEY,
   IDC_STK_TEXT,            IDH_STICKYKEYS_HOTKEY,
   IDC_STK_LOCK,			IDH_STICKYKEYS_LOCK,
   IDC_STK_2KEYS,			IDH_STICKYKEYS_2KEYS,
   IDC_STK_SOUNDMOD,		IDH_STICKYKEYS_SOUND,
   IDC_STK_STATUS,			IDH_STICKYKEYS_STATUS,
   IDC_FK_HOTKEY,			IDH_FILTERKEYS_HOTKEY,
   IDC_FK_TEXT1,            IDH_FILTERKEYS_HOTKEY,
   IDC_FK_REPEAT,			IDH_FILTERKEYS_REPEATKEYS,
   IDC_BK_SETTINGS,                     IDH_FILTERKEYS_BKSETTINGS,
   IDC_FK_BOUNCE,			IDH_FILTERKEYS_BOUNCEKEYS,
   IDC_RK_SETTINGS,			IDH_FILTERKEYS_SETTINGS_REPEAT,
   IDC_FK_TESTBOX,			IDH_FILTERKEYS_TESTBOX,
   IDC_FK_SOUND,			IDH_FILTERKEYS_BEEPONKEYPRESS,
   IDC_FK_STATUS,			IDH_FILTERKEYS_SPAWNSTATUSAPP,
   IDC_RK_NOREPEAT,			IDH_FILTERKEYS_NO_REPEAT,
   IDC_RK_REPEAT,			IDH_FILTERKEYS_SLOW,
   IDC_RK_DELAYRATE_LBL,        IDH_REPEAT_DELAY,
   IDC_CMB_RK_DELAYRATE,        IDH_FILTERKEYS_DELAY,
   IDC_RK_REPEATRATE_LBL,   IDH_REPEAT_RATE,
   IDC_CMB_RK_REPEATRATE,           IDH_FILTERKEYS_RATE,
   IDC_RK_ACCEPTRATE_LBL,       IDH_VALID_KEY_TIME,
   IDC_CMB_RK_ACCEPTRATE,		IDH_FILTERKEYS_KEYSPEED,
   IDC_RK_TESTBOX,			IDH_FILTERKEYS_TEST1,
   IDC_BK_TIME_LBL1,            IDH_FILTERKEYS_IGNORE_REPEAT,
   IDC_BK_TIME_LBL2,            IDH_KEY_PRESS_TIME,
   IDC_CMB_BK_BOUNCERATE,           IDH_FILTERKEYS_IGNORE_REPEAT,
   IDC_BK_TESTBOX,			IDH_FILTERKEYS_TEST2,
   IDC_TK_HOTKEY,			IDH_TOGGLEKEYS_HOTKEY,
   IDC_TK_TEXT1,            IDH_TOGGLEKEYS_HOTKEY,
   IDC_SS_ENABLE_SOUND,		IDH_SOUNDSENTRY_ENABLE,
   IDC_SS_TEXT,             IDH_SOUNDSENTRY_ENABLE,
   IDC_SS_ENABLE_SHOW,		IDH_SHOWSOUNDS_ENABLE,
   IDC_SS_TEXT1,            IDH_SHOWSOUNDS_ENABLE,
   IDC_SS_WINDOWED,			IDH_SOUNDSENTRY_WINDOWED,
   IDC_SS_CHOOSE,           IDH_SOUNDSENTRY_WINDOWED,
   IDC_HC_ENABLE,			IDH_HIGHCONTRAST_ENABLE,
   IDC_HC_TEXT,             IDH_HIGHCONTRAST_ENABLE,
   IDC_HC_SETTINGS,			IDH_HIGHCONTRAST_SETTINGS,
   IDC_HC_HOTKEY,			IDH_HIGHCONTRAST_HOTKEY,
   IDC_HC_TEXT1,            IDH_HIGHCONTRAST_HOTKEY,
   IDC_KCURSOR_RATE,            IDH_KCURSOR_RATE,
   IDC_KCUR_TEXT_RATE,          IDH_KCURSOR_RATE,
   IDC_KCUR_TEXT_NONE,               IDH_KCURSOR_RATE,
   IDC_KCUR_TEXT_FAST,               IDH_KCURSOR_RATE,
   IDC_KCURSOR_WIDTH,           IDH_KCURSOR_WIDTH,
   IDC_KCUR_TEXT_WIDTH,         IDH_KCURSOR_WIDTH,
   IDC_KCUR_TEXT_NARR,              IDH_KCURSOR_WIDTH,
   IDC_KCUR_TEXT_WIDE,              IDH_KCURSOR_WIDTH,
   IDC_KCURSOR_OPTS,        IDH_KCURSOR_OPTS,
   IDC_HC_DEFAULTSCHEME,	IDH_HIGHCONTRAST_DEFAULTSCHEME,
   IDC_HC_CURSCHEME,        IDH_HIGHCONTRAST_DEFAULTSCHEME,
   IDC_MK_ENABLE,			IDH_MOUSEKEYS_ENABLE,
   IDC_MK_TEXT,             IDH_MOUSEKEYS_ENABLE,
   IDC_MK_SETTINGS,			IDH_MOUSEKEYS_SETTINGS,
   IDC_MK_HOTKEY,			IDH_MOUSEKEYS_HOTKEY,
   IDC_MK_TEXT1,            IDH_MOUSEKEYS_HOTKEY,
   IDC_MK_TOPSPEED,			IDH_MOUSEKEYS_MAXSPEED,
   IDC_MK_SPEED,             IDH_MOUSEKEYS_MAXSPEED,
   IDC_MK_SPEED_LOW,         IDH_MOUSEKEYS_MAXSPEED,
   IDC_MK_SPEED_HIGH,        IDH_MOUSEKEYS_MAXSPEED,
   IDC_MK_ACCEL,			IDH_MOUSEKEYS_ACCELERATION,
   IDC_MK_ACCELER,  		IDH_MOUSEKEYS_ACCELERATION,
   IDC_MK_ACCELER_SLOW,     IDH_MOUSEKEYS_ACCELERATION,
   IDC_MK_ACCELER_FAST,     IDH_MOUSEKEYS_ACCELERATION,
   IDC_MK_USEMODKEYS,		IDH_MOUSEKEYS_USEMODIFIERKEYS,
   IDC_MK_NLOFF,			IDH_MOUSEKEYS_NUMLOCKMODE,
   IDC_MK_NLON,				IDH_MOUSEKEYS_NUMLOCKMODE,
   IDC_MK_TEXT2,            IDH_MOUSEKEYS_NUMLOCKMODE,
   IDC_MK_STATUS,			IDH_MOUSEKEYS_SPAWNSTATUSAPP,
//   IDC_SAVE_SETTINGS,           IDH_ACCESS_SAVESETTINGS,
   IDC_TO_ENABLE,			IDH_ACCESS_TIMEOUT,
   IDC_TO_TIMEOUTVAL,                   IDH_ACCESS_TIMEOUT,
   IDC_WARNING_SOUND,		IDH_ACCESS_CONFIRMHOTKEY,
   IDC_SOUND_ONOFF,			IDH_ACCESS_SOUNDONHOTKEY,
   IDC_SK_ENABLE,			IDH_SERIALKEYS_ENABLE,
   IDC_SERKEY_TEXT,         IDH_SERIALKEYS_ENABLE,
   IDC_SK_SETTINGS,			IDH_SERIALKEYS_SETTINGS,
   IDC_SK_PORT,				IDH_SERIALKEYS_SERIAL,
   IDC_SK_PORTEXT,          IDH_SERIALKEYS_SERIAL,
   IDC_SK_BAUD,				IDH_SERIALKEYS_BAUD,
   IDC_SK_BAUD_TEXT,        IDH_SERIALKEYS_BAUD,
   IDC_CHECK1,                          IDH_SHOW_KEYBOARD_HELP,
   IDC_ADMIN_LOGON,          2010,
   IDC_ADMIN_DEFAULT,        2011,
#endif
   0, 0
} ;

// ************************************************************************
// Our entry point...
// ************************************************************************
BOOL WINAPI DllMain (HANDLE hinstDll, DWORD dwReason, LPVOID lpReserved) {
	switch (dwReason) {
      case DLL_PROCESS_ATTACH:   g_hinst = hinstDll; break;
      case DLL_PROCESS_DETACH:   break;
      case DLL_THREAD_DETACH:    break;
      case DLL_THREAD_ATTACH:    break;
   }
   return(TRUE);
}

#define SPI_OFF(T, M) \
{ \
	T s; \
	s.cbSize = sizeof(T); \
	if (!SystemParametersInfo(SPI_GET##T, s.cbSize, &s, 0)) \
		return E_FAIL; \
 \
	if (s.dwFlags & M) \
	{ \
		s.dwFlags &= ~M; \
		if (!SystemParametersInfo(SPI_SET##T, s.cbSize, &s, 0)) \
			return E_FAIL; \
	} \
}

HRESULT WINAPI DllUnregisterServer(void)
{
	SPI_OFF(FILTERKEYS, FKF_HOTKEYACTIVE)
	SPI_OFF(HIGHCONTRAST, HCF_HOTKEYACTIVE)
	SPI_OFF(MOUSEKEYS, MKF_HOTKEYACTIVE)
	SPI_OFF(STICKYKEYS, SKF_HOTKEYACTIVE)
	SPI_OFF(TOGGLEKEYS, TKF_HOTKEYACTIVE)
	return S_OK;
}

HRESULT WINAPI DllRegisterServer(void)
{
	return S_OK;
}


// This is the RUNDLLPROC prototype
// I got it from Win95 source code \WIN\CORE\SHELL\CPLS\MSPRINT\MSPRINT\MSPRINT.C
// It should be in some Windows header file but I could not find it!
typedef VOID (WINAPI *RUNDLLPROC)(HWND, HINSTANCE, LPTSTR, int);

VOID WINAPI DebugMain (HWND hwnd, HINSTANCE hinstExe, LPSTR pszCmdLine, int nCmdShow) {
   OpenAccessPropertySheet(hwnd, 0);
}


/////////////////////////////////////////////////////////////////////////////
// CplApplet:
// The main applet information manager.
/////////////////////////////////////////////////////////////////////////////
LONG WINAPI CPlApplet (HWND hwnd, UINT uMsg, LPARAM lParam1, LPARAM lParam2) {

   LONG lRetVal = TRUE;

   switch (uMsg) {
      case CPL_INIT:
         // If initialization is successful, return TRUE; else FALSE
         break;

      case CPL_GETCOUNT:
         // There is only 1 applet in this DLL
         lRetVal = 1;
         break;

      case CPL_INQUIRE:
         Assert(lParam1 == 0);   // Applet number in the DLL
         #define lpOldCPlInfo ((LPCPLINFO) lParam2)
         lpOldCPlInfo->idIcon = IDI_ACCESS;
         lpOldCPlInfo->idName = IDS_ACCESS;
         lpOldCPlInfo->idInfo = IDS_ACCESSINFO;
         lpOldCPlInfo->lData = 0;
         break;

      case CPL_NEWINQUIRE:
         Assert(lParam1 == 0);   // Applet number in the DLL
         #define lpCPlInfo ((LPNEWCPLINFO) lParam2)
         lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
         lpCPlInfo->dwFlags = 0;
         lpCPlInfo->dwHelpContext = 0;
         lpCPlInfo->lData = 0;
         lpCPlInfo->hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ACCESS));
         LoadString(g_hinst, IDS_ACCESS, lpCPlInfo->szName, ARRAY_SIZE(lpCPlInfo->szName));
         LoadString(g_hinst, IDS_ACCESSINFO, lpCPlInfo->szInfo, ARRAY_SIZE(lpCPlInfo->szInfo));
         lpCPlInfo->szHelpFile[0] = 0;
         #undef lpCPlInfo
         lRetVal = 1;      // Tell the system that we responded to this message
         // Returning 1 causes the system to NOT send the CPL_INQUIRE message
         break;

      case CPL_STARTWPARMS:
         Assert(lParam1 == 0);   // Applet number in the DLL
         OpenAccessPropertySheet(hwnd, (int) ((* (PBYTE) lParam2) - 0x31));
         lRetVal = TRUE;
         break;

      case CPL_DBLCLK:
         Assert(lParam1 == 0);   // Applet number in the DLL
         OpenAccessPropertySheet(hwnd, 0);
         lRetVal = 0;      // Success
         break;

      case CPL_EXIT:
         // Free up any allocations of resources made.
         // If de-initialization is successful, return TRUE; else FALSE
         break;
   }
   return(lRetVal);
}

// ***********************************************************************
// FeatureUnavailible
// Show the "I can't do that" dialog box for features that are currently
// disabled.
// ***********************************************************************

void FeatureUnavailible (HWND hwnd) {
   TCHAR szTitle[100];
   TCHAR szText[256];

   if (LoadString(g_hinst, IDS_UNAVAIL_TITLE, szTitle, ARRAY_SIZE(szTitle)))
      if (LoadString(g_hinst, IDS_UNAVAIL_TEXT, szText, ARRAY_SIZE(szText)))
         MessageBox(hwnd, szText, szTitle, MB_OK);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\mouse.c ===
/*******************************************************************
 *
 *    DESCRIPTION: Mouse Dialog handler
 *
 *    HISTORY:    			 
 *
 *******************************************************************/

#include <assert.h>

/*******************************************************************
 *
 *    DESCRIPTION: Mouse Keys Dialog handler
 *
 *    HISTORY:    			 
 *
 *******************************************************************/

#include "Access.h"

#define TICKCOUNT 9

INT_PTR WINAPI MouseKeyDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    static UINT uSpeedTable[TICKCOUNT] = 
              { 10, 20, 30, 40, 60, 80, 120, 180, 360 };

    int  i;
    BOOL fProcessed = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
        CheckDlgButton(hwnd, IDC_MK_HOTKEY, (g_mk.dwFlags & MKF_HOTKEYACTIVE) ? TRUE : FALSE);

        // Determine settings on our scroll bars for accel and top speed.

        for (i = 0;
            i < ARRAY_SIZE(uSpeedTable) && uSpeedTable[i] < g_mk.iMaxSpeed;
                i++)
        {
        }

        if (ARRAY_SIZE(uSpeedTable) <= i)
        {
                i = ARRAY_SIZE(uSpeedTable);
        }

        SendDlgItemMessage(
                hwnd,
                IDC_MK_TOPSPEED,
                TBM_SETRANGE,
                TRUE,
                MAKELONG(0, ARRAY_SIZE(uSpeedTable)-1));

        SendDlgItemMessage(
                hwnd, IDC_MK_TOPSPEED, TBM_SETPOS, TRUE, i);

        // Acceleration
        i = (TICKCOUNT+1) - g_mk.iTimeToMaxSpeed/500;
        if (i > TICKCOUNT-1)
        {
                i = TICKCOUNT-1;
        }
        if (i < 0)
        {
                i = 0;
        }

        SendDlgItemMessage(
                hwnd,
                IDC_MK_ACCEL,
                TBM_SETRANGE,
                TRUE,
                MAKELONG(0, TICKCOUNT-1));

        SendDlgItemMessage(
                hwnd,
                IDC_MK_ACCEL,
                TBM_SETPOS,
                TRUE,
                i);

        // Hold down Ctrl to speed up and Shift to slow down
        CheckDlgButton(hwnd, IDC_MK_USEMODKEYS, (g_mk.dwFlags & MKF_MODIFIERS) ? TRUE : FALSE);

        // Use MouseKeys when NumLock is on/off
        if (g_mk.dwFlags & MKF_REPLACENUMBERS)
            CheckRadioButton(hwnd, IDC_MK_NLOFF, IDC_MK_NLON, IDC_MK_NLON);
        else
            CheckRadioButton(hwnd, IDC_MK_NLOFF, IDC_MK_NLON, IDC_MK_NLOFF);

         // Show MouseKey status on screen
        CheckDlgButton(hwnd, IDC_MK_STATUS, (g_mk.dwFlags & MKF_INDICATOR) ? TRUE : FALSE);

       // 3/15/95 -
       // Always init the control speed to 1/8 of the screen width/
       g_mk.iCtrlSpeed = GetSystemMetrics(SM_CXSCREEN) / 16;
       break;

    case WM_HSCROLL:
    {
        int nScrollCode = (int) LOWORD(wParam); // scroll bar value
        int nPos = (short int) HIWORD(wParam);  // scroll box position
        HWND hwndScrollBar = (HWND) lParam;     // handle of scroll bar

        // Set the scrolls position
        i = HandleScroll(hwnd, wParam, hwndScrollBar);
        if (-1 != i)
        {
            // Update it.
            switch(GetWindowLong(hwndScrollBar, GWL_ID))
            {
            case IDC_MK_TOPSPEED:
                g_mk.iMaxSpeed = uSpeedTable[i];
                break;
            case IDC_MK_ACCEL:
                g_mk.iTimeToMaxSpeed = (TICKCOUNT+1-i) * 500;
                break;
            default:
                Assert(!"Got WM_HSCROLL from unknown control");
                break;
            }
        }
    }
        break;

    case WM_HELP:      // F1
                      WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
                      break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
        break;

              // Handle the generic commands
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_MK_HOTKEY:
                g_mk.dwFlags ^= MKF_HOTKEYACTIVE; break;

        case IDC_MK_STATUS:
                g_mk.dwFlags ^= MKF_INDICATOR; break;

        case IDC_MK_USEMODKEYS:
                g_mk.dwFlags ^= MKF_MODIFIERS; break;

        case IDC_MK_NLOFF:
                g_mk.dwFlags &= ~MKF_REPLACENUMBERS;
                CheckRadioButton(hwnd, IDC_MK_NLOFF, IDC_MK_NLON, IDC_MK_NLOFF);
                break;

        case IDC_MK_NLON:
                g_mk.dwFlags |= MKF_REPLACENUMBERS;
                CheckRadioButton(hwnd, IDC_MK_NLOFF,IDC_MK_NLON, IDC_MK_NLON);
                break;

        case IDOK:
                EndDialog(hwnd, IDOK);
                break;

        case IDCANCEL:
                EndDialog(hwnd, IDCANCEL);
                break;

        }
        break;

        default: fProcessed = FALSE; break;
    }
    return(fProcessed);
}



// *******************************************************************
// Mouse Dialog handler
// *******************************************************************
INT_PTR WINAPI MouseDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    MOUSEKEYS mk;
    BOOL fProcessed = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
        CheckDlgButton(hwnd, IDC_MK_ENABLE, (g_mk.dwFlags & MKF_MOUSEKEYSON) ? TRUE : FALSE);
        if (!(g_mk.dwFlags & MKF_AVAILABLE)) {
            EnableWindow(GetDlgItem(hwnd, IDC_MK_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_MK_ENABLE), FALSE);
        }
        break;

    case WM_HELP:      // F1
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
                      break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_MK_ENABLE:
            g_mk.dwFlags ^= MKF_MOUSEKEYSON;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
                                    break;

        case IDC_MK_SETTINGS:
            mk = g_mk;  // Save settings before letting the user play with global
            if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_MOUSESETTINGS), hwnd, MouseKeyDlg) == IDCANCEL) {
              // User cancelled, restore settings.
                g_mk = mk;
            } else SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        case PSN_APPLY: SetAccessibilitySettings(); break;
        }
        break;

    default: fProcessed = FALSE; break;
    }

    return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\general.c ===
/*******************************************************************
 *    DESCRIPTION: General Dialog handler
 *******************************************************************/

#include "Access.h"

extern INT_PTR WINAPI SerialKeyDlg(HWND, UINT, WPARAM, LPARAM);

// *******************************************************************
// GeneralDialog handler
// *******************************************************************
INT_PTR WINAPI GeneralDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
   int i;
   SERIALKEYS serk;
   BOOL fProcessed = TRUE;
   char tempPort[10];   // Max 10 characters for a port name
   BOOL isAdmin = TRUE;

	switch (uMsg) {
		case WM_INITDIALOG:
        {
            TCHAR szMinutes[50];
            int ctch = LoadString(g_hinst, IDS_MINUTES, szMinutes, ARRAY_SIZE(szMinutes));
            Assert(ctch);
			CheckDlgButton(hwnd, IDC_TO_ENABLE, (g_ato.dwFlags & ATF_TIMEOUTON) ? TRUE : FALSE);

			// Init the timeout combobox
			for (i= 0; i < 6; i++) {
				TCHAR szBuf[256];
				wsprintf(szBuf, __TEXT("%d %s"), ((i + 1) * 5), szMinutes);
				ComboBox_AddString(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL), szBuf);
			}
			ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL), g_ato.iTimeOutMSec / (1000 * 60 * 5) - 1);
			if (!(g_ato.dwFlags & ATF_TIMEOUTON))
				EnableWindow(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL), FALSE);

            // Notification: Give wanring...         
			CheckDlgButton(hwnd, IDC_WARNING_SOUND, g_fShowWarnMsgOnFeatureActivate);				

            // Notification: Make a sound...
			CheckDlgButton(hwnd, IDC_SOUND_ONOFF, g_fPlaySndOnFeatureActivate);				

            // Support SerialKey devices
			CheckDlgButton(hwnd, IDC_SK_ENABLE, (g_serk.dwFlags & SERKF_SERIALKEYSON) ? TRUE : FALSE);
			if (!(g_serk.dwFlags & SERKF_AVAILABLE)) {
				EnableWindow(GetDlgItem(hwnd, IDC_SK_SETTINGS), FALSE);
				EnableWindow(GetDlgItem(hwnd, IDC_SK_ENABLE), FALSE);
			}

            // JMR: What is this for?
            CheckDlgButton(hwnd, IDC_SAVE_SETTINGS, !g_fSaveSettings);

		    // Administrative options: 
		    // Enable/Disable all admin options.
		    isAdmin = IsDefaultWritable();
		    EnableWindow(GetDlgItem(hwnd, IDC_GEN_GROUP_4), isAdmin);
		    EnableWindow(GetDlgItem(hwnd, IDC_ADMIN_LOGON), isAdmin);
		    EnableWindow(GetDlgItem(hwnd, IDC_ADMIN_DEFAULT), isAdmin);
        }
        break;

      case WM_HELP:
			WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
			break;

      case WM_CONTEXTMENU:
         WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
			break;

    	case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))  {
				case IDC_WARNING_SOUND:
					g_fShowWarnMsgOnFeatureActivate = !g_fShowWarnMsgOnFeatureActivate;
	    	      SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SOUND_ONOFF:
					g_fPlaySndOnFeatureActivate = !g_fPlaySndOnFeatureActivate;
	    	      SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SAVE_SETTINGS:
					g_fSaveSettings = !g_fSaveSettings;
	    	      SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_TO_ENABLE:
					g_ato.dwFlags ^= ATF_TIMEOUTON;
					if (!(g_ato.dwFlags & ATF_TIMEOUTON))
						EnableWindow(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL), FALSE);
					else
						EnableWindow(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL), TRUE);
	    	      SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SK_ENABLE:
					g_serk.dwFlags ^= SERKF_SERIALKEYSON;
	    	      SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SK_SETTINGS:

                    // HACK. Here the pointers are copied. So, When you change 
                    // in the dialog. temporary variable 'serk' looses its original value
                    // Save that in tempPort and use that instead a-anilk
					 serk = g_serk;
                     lstrcpy((LPTSTR)tempPort, g_serk.lpszActivePort);

					if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_SERKEYSETTING), hwnd, SerialKeyDlg) == IDCANCEL) 
                    {
                         g_serk = serk;
                         lstrcpy(g_serk.lpszActivePort, (LPCTSTR)tempPort);
                    }
					else SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_TO_TIMEOUTVAL:
					switch(HIWORD(wParam)) {
						case CBN_CLOSEUP:
							i = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL));
							g_ato.iTimeOutMSec = (ULONG) ((long) ((i + 1) * 5) * 60 * 1000);
		                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
							break;
					}					
					break;
				case IDC_ADMIN_LOGON:
					g_fCopyToLogon = !g_fCopyToLogon;
					SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_ADMIN_DEFAULT:
					g_fCopyToDefault = !g_fCopyToDefault;
					SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;
			}
			break;

        case WM_NOTIFY:
			switch (((NMHDR *)lParam)->code) {
				case PSN_APPLY: SetAccessibilitySettings(); break;
			}
			break;

		default:
			fProcessed = FALSE;
			break;
	}
	return(fProcessed);
}

///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by access.rc
//
#define IDS_ACCESSIBILITY               1
#define IDS_ACCESS                      4
#define IDS_ACCESSINFO                  5
#define IDS_WINDOWED                    6
#define IDS_STRING7                     7
#define IDS_WINDOWED1                   7
#define IDS_STRING8                     8
#define IDS_WINDOWED2                   8
#define IDS_STRING9                     9
#define IDS_WINDOWED3                   9
#define IDS_TEXT                        10
#define IDS_STRING11                    11
#define IDS_TEXT1                       11
#define IDS_STRING12                    12
#define IDS_TEXT2                       12
#define IDS_STRING15                    13
#define IDS_TEXT3                       13
#define IDS_GRAPHICS                    14
#define IDS_STRING14                    15
#define IDS_GRAPHICS1                   15
#define IDS_COMPORT                     16
#define IDS_UNAVAIL_TITLE               24
#define IDS_UNAVAIL_TEXT                25
#define IDS_BLACKWHITE_SCHEME           27
#define IDS_WHITEBLACK_SCHEME           28
#define IDS_PROPERTY_TITLE              29
#define IDS_ACCSTAT_WINDOW_TITLE        30
#define IDS_SAVE_DEFAULT_TITLE          32
#define IDS_SAVE_DEFAULT_TEXT           33
#define IDS_SECONDS                     34
#define IDS_MINUTES                     35
#define IDI_ACCESS                      110
#define IDD_KEYBOARD                    201
#define IDD_SOUND                       202
#define IDD_GENERAL                     203
#define IDD_DISPLAY                     204
#define IDD_MOUSE                       205
#define IDD_STICKYSETTINGS              206
#define IDD_FILTERSETTINGS              207
#define IDD_TOGGLESETTINGS              208
#define IDD_ADVCHARREPEAT               209
#define IDD_MOUSESETTINGS               210
#define IDD_SOUNDSETTINGS               211
#define IDD_HIGHCONSETTINGS             212
#define IDD_SERKEYSETTING               214
#define IDD_ADVKEYBOUNCE                217
#define IDC_MK_TOPSPEED                 603
#define IDC_MK_ACCEL                    604
#define IDC_CHECK1                      1000
#define IDC_SHOWEXTRAKYBDHELP           1000
#define IDC_MK_HOTKEY                   1001
#define IDC_MK_USEMODKEYS               1002
#define IDC_MK_SETTINGS                 1003
#define IDC_MK_STATUS                   1004
#define IDC_STK_SOUNDMOD                1007
#define IDC_SK_ENABLE                   1010
#define IDC_STK_STATUS                  1011
#define IDC_SK_PORT                     1013
#define IDC_MK_NLOFF                    1018
#define IDC_MK_NLON                     1019
#define IDC_RK_TESTBOX                  1021
#define IDC_STK_ENABLE                  1031
#define IDC_STK_SETTINGS                1032
#define IDC_TK_SETTINGS                 1033
#define IDC_HC_ENABLE                   1034
#define IDC_HC_SETTINGS                 1035
#define IDC_SAVE_SETTINGS               1036
#define IDC_TO_ENABLE                   1037
#define IDC_TO_TIMEOUTVAL               1038
#define IDC_WARNING_SOUND               1039
#define IDC_SOUND_ONOFF                 1040
#define IDC_SK_SETTINGS                 1041
#define IDC_TK_ENABLE                   1042
#define IDC_STK_HOTKEY                  1043
#define IDC_STK_LOCK                    1044
#define IDC_STK_2KEYS                   1045
#define IDC_FK_HOTKEY                   1046
#define IDC_FK_BOUNCE                   1047
#define IDC_FK_REPEAT                   1048
#define IDC_FK_TESTBOX                  1049
#define IDC_FK_SETTINGS                 1050
#define IDC_FK_ENABLE                   1055
#define IDC_BK_TESTBOX                  1058
#define IDC_BK_SETTINGS                 1059
#define IDC_RK_NOREPEAT                 1060
#define IDC_RK_REPEAT                   1061
#define IDC_RK_SETTINGS                 1066
#define IDC_FK_SOUND                    1069
#define IDC_FK_STATUS                   1070
#define IDC_HC_HOTKEY                   1071
#define IDC_HC_DEFAULTSCHEME            1075
#define IDC_TK_HOTKEY                   1076
#define IDC_SS_ENABLE_SOUND             1077
#define IDC_SS_CHOOSE                   1078
#define IDC_SS_ENABLE_SHOW              1079
#define IDC_SS_WINDOWED                 1080
#define IDC_MK_ENABLE                   1081
#define IDC_SK_BAUD                     1082
#define IDC_NO_HELP_1                   1086
#define IDC_BK_TIME_LBL1                1087
#define IDC_BK_TIME_LBL2                1088
#define IDC_RK_DELAYRATE_LBL            1111
#define IDC_RK_REPEATRATE_LBL           1112
#define IDC_RK_ACCEPTRATE_LBL           1113
#define IDC_CMB_RK_DELAYRATE            1115
#define IDC_CMB_RK_REPEATRATE           1116
#define IDC_CMB_RK_ACCEPTRATE           1117
#define IDC_ADMIN_LOGON                 1114
#define IDC_CMB_BK_BOUNCERATE           1118
#define IDC_ADMIN_DEFAULT               1119
#define IDC_GEN_GROUP_4                 1120
#define IDC_KCURSOR_BLINK               1121
#define IDC_KCURSOR_RATE                1122
#define IDC_KCURSOR_WIDTH               1123
#define IDC_KCUR_TEXT_NARR              1126
#define IDC_KCUR_TEXT_WIDE              1127
#define IDC_KCUR_TEXT_NONE              1128
#define IDC_KCUR_TEXT_FAST              1129
#define IDC_KCURSOR_OPTS                1130
#define IDC_SK_TEXT                     1132
#define IDC_FK_TEXT                     1133
#define IDC_TK_TEXT                     1134
#define IDC_SS_TEXT                     1135
#define IDC_SS_TEXT1                    1136
#define IDC_SERKEY_TEXT                 1137
#define IDC_HC_TEXT                     1138
#define IDC_KCUR_TEXT_RATE              1139
#define IDC_KCUR_TEXT_WIDTH             1140
#define IDC_MK_TEXT                     1141
#define IDC_STK_TEXT                    1142
#define IDC_TK_TEXT1                    1143
#define IDC_MK_TEXT1                    1144
#define IDC_MK_SPEED                    1145
#define IDC_MK_SPEED_LOW                1146
#define IDC_MK_SPEED_HIGH               1147
#define IDC_MK_ACCELER                  1148
#define IDC_MK_ACCELER_SLOW             1149
#define IDC_MK_ACCELER_FAST             1150
#define IDC_MK_TEXT2                    1151
#define IDC_HC_TEXT1                    1152
#define IDC_HC_CURSCHEME                1153
#define IDC_SK_PORTEXT                  1154
#define IDC_SK_BAUD_TEXT                1155
#define IDC_FK_TEXT1                    1156

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        235
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1157
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\reg.c ===
/****************************** Module Header ******************************\
* Module Name: reg.c
*
* Copyright (c) 1985-95, Microsoft Corporation
*
* History:
* 01-02-96 a-jimhar 	Created based on reg.c from access351.exe
\***************************************************************************/

/*
1. on startup, check to see if we're administrator
  a) use RegOpenKeyEx on HKEY_USERS\.DEFAULT\Software with read/write
    access writes.  if it fails, we're not administrator
  b) if not, grey menu option
2. on startup
  a) use RegOpenKeyEx on HKEY_CURRENTUSER\Software...
  b) if it fails, create these keys with default values.
3. creating keys
  a) RegCreateKeyEx
  b) RegSetValue
  c) RegCloseKey

*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "Access.h"

BOOL DoAccessRegEntriesExist( HKEY hkeyRoot );
BOOL CheckRegEntry( HKEY hkeyRoot, LPSTR lpsz, REGSAM sam );
LONG OpenAccessRegKeyW( HKEY hkeyRoot, LPSTR lpstr, PHKEY phkey );
BOOL CloseAccessRegKey( HKEY hkey );
BOOL SetRegString( HKEY hkey, LPSTR lpszEntry, LPSTR lpszValue );

DWORD CopyKey( HKEY hkeySrc, HKEY hkeyDst, LPSTR szKey );


char szAccessRegPath[] = "Control Panel\\Accessibility";
char szHcColorRegPath[] = "Control Panel\\Colors";
char szHcDeskRegPath[] = "Control Panel\\Desktop";

/********************************************************************/
//
BOOL IsDefaultWritable( void )
{
    return CheckRegEntry( HKEY_USERS, ".Default", KEY_ALL_ACCESS );
}

/********************************************************************/
BOOL DoAccessRegEntriesExist( HKEY hkeyRoot )
{
    char sz[128];
    strcpy( sz, szAccessRegPath );
    strcat( sz, "\\StickyKeys" );
    return CheckRegEntry( hkeyRoot, sz, KEY_READ ); // execute means readonly
}

/********************************************************************/
BOOL CheckRegEntry( HKEY hkeyRoot, LPSTR lpsz, REGSAM sam )
{
    HKEY hkey;
    BOOL fOk = (ERROR_SUCCESS == RegOpenKeyExA( hkeyRoot, lpsz, 0, sam, &hkey ));

    if(fOk)
    {
        RegCloseKey(hkey);
    }
    
	return fOk;
}

/********************************************************************/
LONG OpenAccessRegKeyW( HKEY hkeyRoot, LPSTR lpstr, PHKEY phkey )
{
    LONG dw;
    LONG dwDisposition;
    char sz[128];
    strcpy( sz, szAccessRegPath );
    strcat( sz, "\\" );
    strcat( sz, lpstr );
//    dw = RegOpenKey( hkeyRoot, sz, phkey );
//    dw = RegOpenKey( hkeyRoot, "\\Software", phkey );
//    dw = RegOpenKey( hkeyRoot, "\\FOOBAR", phkey );
//    dw = RegOpenKey( hkeyRoot, "Software", phkey );
//    dw = RegOpenKey( hkeyRoot, "FOOBAR", phkey );
//    dw = RegOpenKey( hkeyRoot, "Software\\Microsoft\\Accessibility\\StickyKeys", phkey );
    dw = RegCreateKeyExA( hkeyRoot,
            sz,
            0,
            NULL,                // CLASS NAME??
            0,                   // by default is non-volatile
            KEY_ALL_ACCESS,
            NULL,                // default security descriptor
            phkey,
            &dwDisposition );    // yes we throw this away
    if( dw != ERROR_SUCCESS )
    {
        // should do something
    }
    return dw;
}

/********************************************************************/
BOOL CloseAccessRegKey( HKEY hkey )
{
    DWORD dw;
    dw = RegCloseKey( hkey );
    if( dw == ERROR_SUCCESS )
        return TRUE;
    else
        return FALSE;
}

/********************************************************************/
BOOL SetRegString( HKEY hkey, LPSTR lpszEntry, LPSTR lpszValue )
{
    DWORD dwResult;
    dwResult = RegSetValueExA( hkey,
                              lpszEntry,
                              0,
                              REG_SZ,
                              lpszValue,
                              strlen( lpszValue ) + sizeof( TCHAR ) );
    if( dwResult != ERROR_SUCCESS )
    {
        ; // should do something like print a message
        return FALSE;
    }
    else
        return TRUE;
}

/***********************************************************************/
#define TEMP_PROFILE     "Temp profile (access.cpl)"

typedef BOOL (*PFNGETDEFAULTUSERPROFILEDIRECTORYA)(LPSTR lpProfile, LPDWORD dwSize);

DWORD SaveDefaultSettings( BOOL saveL, BOOL saveU )
{
    NTSTATUS Status;
    DWORD iStatus = ERROR_SUCCESS;
    DWORD dwSize;
    HKEY hkeyDst;
    BOOLEAN WasEnabled;
    char acFile[MAX_PATH];
    HANDLE hInstDll;
    PFNGETDEFAULTUSERPROFILEDIRECTORYA pfnGetDefaultUserProfileDirectory;

    // If save to Logon
    if ( saveL )
    {
        iStatus  = RegOpenKeyA( HKEY_USERS, ".DEFAULT", &hkeyDst );
        if( iStatus != ERROR_SUCCESS )
            return iStatus;
        iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szAccessRegPath );
    
        // a-anilk 
        // Now copy the colors and Desktop to .Default required for HighContrast setting
        iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szHcColorRegPath );
        iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szHcDeskRegPath );

        RegCloseKey( hkeyDst );
    }

    if ( saveU )
    {
        hInstDll = LoadLibrary (TEXT("userenv.dll"));

        if (!hInstDll) {
            return (GetLastError());
        }
        pfnGetDefaultUserProfileDirectory = (PFNGETDEFAULTUSERPROFILEDIRECTORYA)GetProcAddress (hInstDll,
                                            "GetDefaultUserProfileDirectoryA");

        if (!pfnGetDefaultUserProfileDirectory) {
            FreeLibrary (hInstDll);
            return (GetLastError());
        }

        dwSize = MAX_PATH;
        if (!pfnGetDefaultUserProfileDirectory(acFile, &dwSize)) {
            FreeLibrary (hInstDll);
            return (GetLastError());
        }

        FreeLibrary (hInstDll);

        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

        if (!NT_SUCCESS(Status)) return iStatus;

        strcat(acFile,"\\ntuser.dat");
        iStatus = RegLoadKeyA(HKEY_USERS, TEMP_PROFILE, acFile);

        if (iStatus == ERROR_SUCCESS) {

            iStatus  = RegOpenKeyA( HKEY_USERS, TEMP_PROFILE, &hkeyDst );
            if( iStatus == ERROR_SUCCESS ) {

                iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szAccessRegPath );
                // a-anilk 
                // Now copy the colors and Desktop to .Default required for HighContrast setting
                iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szHcColorRegPath );
                iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szHcDeskRegPath );

                RegCloseKey( hkeyDst );
            }

            RegUnLoadKeyA(HKEY_USERS, TEMP_PROFILE);
        }
        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    }
    return iStatus;
}

/***********************************************************************/
// CopyKey( hKey, hKeyDst, name )
//     create the destination key
//     for each value
//         CopyValue
//     for each subkey
//         CopyKey

DWORD CopyKey( HKEY hkeySrc, HKEY hkeyDst, LPSTR szKey )
{
    HKEY hkeyOld, hkeyNew;
    char szValue[128];
    char szData[128];
    char szBuffer[128];
    DWORD iStatus;
    UINT nValue, nKey;
    UINT iValueLen, iDataLen;
	DWORD dwType;

    iStatus = RegOpenKeyA( hkeySrc, szKey, &hkeyOld );
    if( iStatus != ERROR_SUCCESS )
        return iStatus;
    iStatus = RegOpenKeyA( hkeyDst, szKey, &hkeyNew );
    if( iStatus != ERROR_SUCCESS )
    {
        iStatus = RegCreateKeyA( hkeyDst, szKey, &hkeyNew );
        if( iStatus != ERROR_SUCCESS )
        {
            RegCloseKey( hkeyOld );
            return iStatus;
        }
    }
    //*********** copy the values **************** //

    for( nValue = 0, iValueLen=sizeof szValue, iDataLen=sizeof szValue;
         ERROR_SUCCESS == (iStatus = RegEnumValueA(hkeyOld,
                                                  nValue,
                                                  szValue,
                                                  &iValueLen,
                                                  NULL, // reserved
                                                  &dwType, // don't need type
                                                  szData,
                                                  &iDataLen ) );
         nValue ++, iValueLen=sizeof szValue, iDataLen=sizeof szValue )
     {
         iStatus = RegSetValueExA( hkeyNew,
                                  szValue,
                                  0, // reserved
                                  dwType,
                                  szData,
                                  iDataLen);
     }
    if( iStatus != ERROR_NO_MORE_ITEMS )
    {
        RegCloseKey( hkeyOld );
        RegCloseKey( hkeyNew );
        return iStatus;
    }

    //*********** copy the subtrees ************** //

    for( nKey = 0;
         ERROR_SUCCESS == (iStatus = RegEnumKeyA(hkeyOld,nKey,szBuffer,sizeof(szBuffer)));
         nKey ++ )
     {
         iStatus = CopyKey( hkeyOld, hkeyNew, szBuffer );
         if( iStatus != ERROR_NO_MORE_ITEMS && iStatus != ERROR_SUCCESS )
            {
                RegCloseKey( hkeyOld );
                RegCloseKey( hkeyNew );
                return iStatus;
            }
     }
    RegCloseKey( hkeyOld );
    RegCloseKey( hkeyNew );
    if( iStatus == ERROR_NO_MORE_ITEMS )
        return ERROR_SUCCESS;
    else
        return iStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\serlkey.c ===
/*******************************************************************
 *
 *    DESCRIPTION: Serial Keys Dialog handler
 *
 *    HISTORY:    			
 *
 *******************************************************************/

#include "Access.h"

#define NUMPORTS 8
#define NUMRATES 6


INT_PTR WINAPI SerialKeyDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	int  i;
	UINT uBaud;
   UINT uBaudRates[] = { 300, 1200, 2400, 4800, 9600, 19200 };
	TCHAR szBuf[256];
   BOOL fProcessed = TRUE;

	switch (uMsg) {
		case WM_INITDIALOG:
  			LoadString(g_hinst, IDS_COMPORT, szBuf, ARRAY_SIZE(szBuf));
			for (i=1; i <= 4; i++) {
				TCHAR szBuf2[256];

				// Make a correct port name and add it to the list box.
				wsprintf(szBuf2, __TEXT("%s%d"), szBuf, i);
				ComboBox_AddString(GetDlgItem(hwnd, IDC_SK_PORT), szBuf2);									
			}

			// Select the current com port.
			if (g_serk.lpszActivePort[0] != '\0') {
				int cport;

				// For now we assume that the format of the string is
				// com[digit].  So comport[3] = the com port number
				// Set all invalid ports to 'COM1'
				cport = g_serk.lpszActivePort[3] - '1';
				if (cport < 0) cport = 0;
				if (cport > 4) cport = 0;

				// Set the active port.
				ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SK_PORT), cport);				
			} else {
				// Else default to COM1.
				ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SK_PORT), 0);
				lstrcpy(g_serk.lpszActivePort, __TEXT("COM1"));
			}

			// Fill in the BAUD RATE options
			uBaud = 1;		// Default baud rate.

			for (i = 0; i < NUMRATES; i++) {
				TCHAR szBuf[256];
				wsprintf(szBuf, __TEXT("%d"), uBaudRates[i]);
				ComboBox_AddString(GetDlgItem(hwnd, IDC_SK_BAUD), szBuf);				
				if (g_serk.iBaudRate == uBaudRates[i]) uBaud = i;	
			}
			ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SK_BAUD), uBaud);
			break;

      case WM_HELP:	 // F1
			WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
			break;

      case WM_CONTEXTMENU:	// right mouse click
         WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
			break;

		case WM_COMMAND:
      	switch (GET_WM_COMMAND_ID(wParam, lParam)) {
				// Watch for combobox changes.
				case IDC_SK_BAUD:
					switch (HIWORD(wParam)) {
						case CBN_CLOSEUP:
						case CBN_SELCHANGE:
							i = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_SK_BAUD));
                     g_serk.iBaudRate = uBaudRates[i];
		    	         SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
							break;
					}					
					break;

				case IDC_SK_PORT:
					switch (HIWORD(wParam)) {
						case CBN_SELCHANGE:
							i = 1 + ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_SK_PORT));
                     wsprintf(g_serk.lpszActivePort, __TEXT("COM%d"), i);
                     EnableWindow(GetDlgItem(hwnd, IDC_SK_BAUD), TRUE);
							break;
					}					
					break;

				case IDOK: case IDCANCEL:
					EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
					break;
			}
			break;

		default:
			fProcessed = FALSE; break;
	}
	return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\sound.c ===
/*******************************************************************
 *    DESCRIPTION: Sound Dialog handler
 *******************************************************************/

#include "Access.h"

// *******************************************************************
// SoundDialog handler
// *******************************************************************
INT_PTR CALLBACK SoundDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    SOUNDSENTRY ss;
    BOOL fSSOn;
    BOOL fProcessed = TRUE;
    TCHAR szBuf[100];
    int i;
				
	switch (uMsg) {
		case WM_INITDIALOG:
            // init sound sentry options

			for (i= 0; i < 4; i++) 
            {
				LoadString(g_hinst, IDS_WINDOWED + i, szBuf, ARRAY_SIZE(szBuf));
				ComboBox_AddString(GetDlgItem(hwnd, IDC_SS_WINDOWED), szBuf);				
            }

            // init controls based on current settings

            fSSOn = g_ss.dwFlags & SSF_SOUNDSENTRYON;
			CheckDlgButton(hwnd, IDC_SS_ENABLE_SOUND, (fSSOn) ? TRUE : FALSE);

			if (!(g_ss.dwFlags & SSF_AVAILABLE)) 
            {
				EnableWindow(GetDlgItem(hwnd, IDC_SS_ENABLE_SOUND), FALSE);
				EnableWindow(GetDlgItem(hwnd, IDC_SS_WINDOWED), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_SS_CHOOSE), FALSE);
			    ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SS_WINDOWED), -1);			
            }
			if (!fSSOn) 
            {
				EnableWindow(GetDlgItem(hwnd, IDC_SS_WINDOWED), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_SS_CHOOSE), FALSE);
                g_ss.iWindowsEffect = 0;
			    ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SS_WINDOWED), g_ss.iWindowsEffect);				
            } else
            {
			    // Select the correct items from the comboboxes.
			    ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SS_WINDOWED), g_ss.iWindowsEffect);				
            }
            CheckDlgButton(hwnd, IDC_SS_ENABLE_SHOW, g_fShowSounds);

			break;

      case WM_HELP:	 // F1
			WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
			break;

      case WM_CONTEXTMENU:	// right mouse click
         WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
			break;

    	case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))  {
				case IDC_SS_ENABLE_SOUND:
					g_ss.dwFlags ^= SSF_SOUNDSENTRYON;
                    if (!(g_ss.dwFlags & SSF_SOUNDSENTRYON))
                    {
                        EnableWindow(GetDlgItem(hwnd, IDC_SS_CHOOSE), FALSE);
				        EnableWindow(GetDlgItem(hwnd, IDC_SS_WINDOWED), FALSE);
                        g_ss.iWindowsEffect = 0;
                    } else
                    {
                        EnableWindow(GetDlgItem(hwnd, IDC_SS_CHOOSE), TRUE);
				        EnableWindow(GetDlgItem(hwnd, IDC_SS_WINDOWED), TRUE);
                        g_ss.iWindowsEffect = 1;
                    }
			        ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SS_WINDOWED), g_ss.iWindowsEffect);
                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SS_ENABLE_SHOW:
					g_fShowSounds = !g_fShowSounds;
                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SS_WINDOWED:
					switch (HIWORD(wParam)) 
                    {
                        DWORD dw;
						case CBN_CLOSEUP:
                            dw = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_SS_WINDOWED));
							if (dw != g_ss.iWindowsEffect)
                            {
                                g_ss.iWindowsEffect = dw;
                                SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
                            }
							break;
					}					
					break;
			}
			break;

		case WM_NOTIFY:
			switch (((NMHDR *)lParam)->code) {				
				case PSN_APPLY: SetAccessibilitySettings(); break;
					break;
			}
			break;

		default: fProcessed = FALSE; break;
	}
	return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\alertpg\alertpg.c ===
//
//  ALERT.C        Application installation wizard CPL
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ravir 05/01/95
//

#include "alertpg.h"
#include <cpl.h>


HINSTANCE hInst = NULL;


BOOL APIENTRY LibMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        hInst = hDll;
    }

    return TRUE;
}


LONG CALLBACK CPlApplet(HWND hwnd, UINT Msg, LPARAM lParam1, LPARAM lParam2 )
{
    UINT nStartPage;
    LPTSTR lpStartPage;

    switch (Msg)
    {
       case CPL_INIT:
           return TRUE;

       case CPL_GETCOUNT:
           return 1;

       case CPL_INQUIRE:
            #define lpCPlInfo ((LPCPLINFO)lParam2)
            lpCPlInfo->idIcon = IDI_ALERTICON;
            lpCPlInfo->idName = IDS_NAME;
            lpCPlInfo->idInfo = IDS_INFO;
            lpCPlInfo->lData  = 0;
            #undef lpCPlInfo
           break;

       case CPL_DBLCLK:
       case CPL_STARTWPARMS:
           return LoadComputerObjectAlertPage(hwnd);

       default:
           return FALSE;
    }

    return TRUE;

}  // CPlApplet




BOOL LoadComputerObjectAlertPage(HWND hwnd)
{
    PASLOADCOMPUTEROBJECTALERTPAGE pfunc = NULL;
    HINSTANCE hInst = NULL;

    hInst = LoadLibrary(TEXT("alertsys.dll"));

    if (hInst == NULL)
    {
#ifdef DEBUG
        ShellMessageBox(hInst, hwnd, TEXT("LoadLibrary"), NULL,
            MB_OK | MB_ICONEXCLAMATION,
            TEXT("Failed to load library alertsys.dll. (%d)"),
            GetLastError());
#endif
        return FALSE;
    }

    pfunc = (PASLOADCOMPUTEROBJECTALERTPAGE)GetProcAddress(
                    (HMODULE)hInst, "AsLoadComputerObjectAlertPage");

    if (pfunc != NULL)
    {
        pfunc(hwnd);
    }
    else
    {
#ifdef DEBUG
        ShellMessageBox(hInst, hwnd, TEXT("GetProcAddress"), NULL,
            MB_OK | MB_ICONEXCLAMATION,
            TEXT("Failed to get AsLoadComputerObjectAlertPage's address. (%d)"),
            GetLastError());
#endif
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\stkykey.c ===
// **************************************************************************
// StickyKeys
// Process the StickyKeys dialog
// **************************************************************************
#include "Access.h"


INT_PTR WINAPI StickyKeyDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    BOOL fProcessed = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
        CheckDlgButton(hwnd, IDC_STK_HOTKEY,
            (g_sk.dwFlags & SKF_HOTKEYACTIVE) ? TRUE : FALSE);

        CheckDlgButton(hwnd, IDC_STK_LOCK,
                (g_sk.dwFlags & SKF_TRISTATE) ? TRUE : FALSE);

        CheckDlgButton(hwnd, IDC_STK_2KEYS,
                (g_sk.dwFlags & SKF_TWOKEYSOFF) ? TRUE : FALSE);

        CheckDlgButton(hwnd, IDC_STK_SOUNDMOD,
                (g_sk.dwFlags & SKF_AUDIBLEFEEDBACK) ? TRUE : FALSE);

        CheckDlgButton(hwnd, IDC_STK_STATUS,
                (g_sk.dwFlags & SKF_INDICATOR) ? TRUE : FALSE);

        break;

    case WM_HELP:      // F1
                      WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
                      break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
                      break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_STK_HOTKEY:
            g_sk.dwFlags ^= SKF_HOTKEYACTIVE;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;

        case IDC_STK_LOCK:
            g_sk.dwFlags ^= SKF_TRISTATE;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;

        case IDC_STK_2KEYS:
            g_sk.dwFlags ^= SKF_TWOKEYSOFF;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;

        case IDC_STK_SOUNDMOD:
            g_sk.dwFlags ^= SKF_AUDIBLEFEEDBACK;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;
        case IDC_STK_STATUS:
            g_sk.dwFlags ^= SKF_INDICATOR;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam)); break;
        }
        break;

        default: fProcessed = FALSE; break;
    }
    return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\access\tgglkeys.c ===
/*******************************************************************
 *    DESCRIPTION: ToggleKeys dialog
 *******************************************************************/

#include "Access.h"


// *******************************************************************
// Toggle Keys Settings handler
// *******************************************************************
INT_PTR CALLBACK ToggleKeySettingsDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
   BOOL fProcessed = TRUE;

	switch (uMsg) {
		case WM_INITDIALOG:
			CheckDlgButton(hwnd, IDC_TK_HOTKEY, 
				(g_tk.dwFlags & TKF_HOTKEYACTIVE)?TRUE:FALSE );
			break;

      case WM_HELP:
			WinHelp(((LPHELPINFO) lParam)->hItemHandle, __TEXT("access.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
			break;

      case WM_CONTEXTMENU:
         WinHelp((HWND) wParam, __TEXT("access.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
			break;

    	case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {											
				case IDC_TK_HOTKEY:				
					g_tk.dwFlags ^= MKF_HOTKEYACTIVE;
               SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDOK: case IDCANCEL:
					EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam)); break;
			}
			break;

		default: fProcessed = FALSE; break;
	}
	return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\alertpg\alertpg.h ===
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shell2.h>
#include <shlobj.h>
#include <prsht.h>

#include "id.h"



BOOL LoadComputerObjectAlertPage(HWND hwnd);


//
//  The following is used to display the alert page for the computer object.
//

typedef void (*PASLOADCOMPUTEROBJECTALERTPAGE)(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\alertpg\id.h ===
//
//  Icons
//
#define IDI_ALERTICON           5500


//
//  Message strings
//
#define IDS_NAME                5001
#define IDS_INFO                5002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batmeter\batmeter.inc ===
#
#  Common settings for batmeter
#

CCSHELL_DIR=$(PROJECT_ROOT)
!include $(PROJECT_ROOT)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(PROJECT_ROOT)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batmeter\batmeter.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       BATMETER.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*
*   Implements the battery meter of the PowerCfg or SysTray battery
*   meter windows. The battery meter has two display modes, single and
*   multi-battery. In single mode, a representation of the total of all battery
*   capacity in a system is displayed. In multi-battery mode, battery
*   information is displayed for each individual battery as well as the total.
*
*   The battery meter parent window receives notification from USER when
*   any battery status has changed through the WM_POWERBROADCAST,
*   PBT_APMPOWERSTATUSCHANGE message.
*
*   ??? We need to add perfmon support: Create and maintain keys/values
*   under HKEY_PERFORMANCE_DATA.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>

#include <dbt.h>
#include <objbase.h>
#include <initguid.h>
#include <ntpoapi.h>
#include <poclass.h>

#include <setupapi.h>
#include <syssetup.h>
#include <setupbat.h>
#include <ccstock.h>

#include <help.h>

#include "powrprofp.h"
#include "batmeter.h"
#include "bmresid.h"
#include "..\powercfg\PwrMn_cs.h"
#include "shfusion.h"

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

// Simulated battery only for debug build.
#ifndef DEBUG
#undef SIM_BATTERY
#endif


// Define some things for debug.h.  Required when you include ccstock.h in
// one and only one file.
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "BATMETER"
#define SZ_MODULE           "BATMETER"
#define DECLARE_DEBUG

#include <debug.h>



/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

HINSTANCE   g_hInstance;        // Global instance handle of this DLL.
HWND        g_hwndParent;       // Parent of the battery meter.
HWND        g_hwndBatMeter;     // Battery meter.

// The following constant global array is used to walk through the
// control ID's in the battery metter dialog box. It makes getting
// a control ID from a battery number easy.

#define BAT_ICON      0
#define BAT_STATUS    1
#define BAT_REMAINING 2
#define BAT_NUM       3
#define BAT_LAST      BAT_NUM+1

UINT g_iMapBatNumToID [NUM_BAT+1][4]={
    {IDC_POWERSTATUSICON,  IDC_POWERSTATUSBAR, IDC_REMAINING, IDC_BATNUM0},
    {IDC_POWERSTATUSICON1, IDC_STATUS1, IDC_REMAINING1, IDC_BATNUM1},
    {IDC_POWERSTATUSICON2, IDC_STATUS2, IDC_REMAINING2, IDC_BATNUM2},
    {IDC_POWERSTATUSICON3, IDC_STATUS3, IDC_REMAINING3, IDC_BATNUM3},
    {IDC_POWERSTATUSICON4, IDC_STATUS4, IDC_REMAINING4, IDC_BATNUM4},
    {IDC_POWERSTATUSICON5, IDC_STATUS5, IDC_REMAINING5, IDC_BATNUM5},
    {IDC_POWERSTATUSICON6, IDC_STATUS6, IDC_REMAINING6, IDC_BATNUM6},
    {IDC_POWERSTATUSICON7, IDC_STATUS7, IDC_REMAINING7, IDC_BATNUM7},
    {IDC_POWERSTATUSICON8, IDC_STATUS8, IDC_REMAINING8, IDC_BATNUM8}
};

// Global battery state list. This list has the composite system battery state
// as it's always present head. individual battery devices are linked to this
// head. Use WalkBatteryState(ALL, ... to walk the entire list, including the
// head. Use WalkBatteryState(DEVICES, ... to walk just the device list. If a
// battery is in this list, it's displayable. g_uiBatCount is the count of
// battery devices in this list. The composite battery is not counted. The
// g_pbs array provides a handy UI battery number to pbs conversion. The
// following three variables are only changed during DeviceChanged.

BATTERY_STATE   g_bs;
UINT            g_uiBatCount;
PBATTERY_STATE  g_pbs[NUM_BAT+1];
LPTSTR          g_lpszDriverNames[NUM_BAT];
UINT            g_uiDriverCount;
BOOL            g_bShowingMulti;

// The following array provides context sensitive help associations between
// resource control identifiers and help resource string identifiers.

const DWORD g_ContextMenuHelpIDs[] =
{
    IDC_BATMETERGROUPBOX,       IDH_COMM_GROUPBOX,
    IDC_BATMETERGROUPBOX1,      IDH_COMM_GROUPBOX,
    IDC_POWERSTATUSICON,        NO_HELP,
    IDC_POWERSTATUSICON1,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON2,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON3,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON4,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON5,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON6,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON7,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON8,       IDH_BATMETER_CHARGING_ICON,
    IDC_BATNUM1,                NO_HELP,
    IDC_BATNUM2,                NO_HELP,
    IDC_BATNUM3,                NO_HELP,
    IDC_BATNUM4,                NO_HELP,
    IDC_BATNUM5,                NO_HELP,
    IDC_BATNUM6,                NO_HELP,
    IDC_BATNUM7,                NO_HELP,
    IDC_BATNUM8,                NO_HELP,
    IDC_STATUS1,                NO_HELP,
    IDC_STATUS2,                NO_HELP,
    IDC_STATUS3,                NO_HELP,
    IDC_STATUS4,                NO_HELP,
    IDC_STATUS5,                NO_HELP,
    IDC_STATUS6,                NO_HELP,
    IDC_STATUS7,                NO_HELP,
    IDC_STATUS8,                NO_HELP,
    IDC_MOREINFO,               NO_HELP,
    IDC_CURRENTPOWERSOURCE,     IDH_BATMETER_CURPOWERSOURCE,
    IDC_BATTERYLEVEL,           IDH_BATMETER_CURPOWERSOURCE,
    IDC_TOTALBATPWRREMAINING,   IDH_BATMETER_TOTALBATPOWER,
    IDC_REMAINING,              IDH_BATMETER_TOTALBATPOWER,
    IDC_POWERSTATUSBAR,         IDH_BATMETER_TOTALBATPOWER,
    IDC_BARPERCENT,             IDH_BATMETER_TOTALBATPOWER,
    IDC_TOTALTIME,              IDH_BATMETER_TOTALTIME,
    IDC_TIMEREMAINING,          IDH_BATMETER_TOTALTIME,
    IDC_BATTERYNAME,            IDH_DETAILED_BATINFO_LABELS,
    IDC_DEVNAME,                IDH_DETAILED_BATINFO_LABELS,
    IDC_UNIQUEID,               IDH_DETAILED_BATINFO_LABELS,
    IDC_BATID,                  IDH_DETAILED_BATINFO_LABELS,
    IDC_MANUFACTURE,            IDH_DETAILED_BATINFO_LABELS,
    IDC_BATMANNAME,             IDH_DETAILED_BATINFO_LABELS,
    IDC_DATEMANUFACTURED,       IDH_DETAILED_BATINFO_LABELS,
    IDC_BATMANDATE,             IDH_DETAILED_BATINFO_LABELS,
    IDC_CHEMISTRY,              IDH_DETAILED_BATINFO_LABELS,
    IDC_CHEM,                   IDH_DETAILED_BATINFO_LABELS,
    IDC_POWERSTATE,             IDH_DETAILED_BATINFO_LABELS,
    IDC_STATE,                  IDH_DETAILED_BATINFO_LABELS,
    IDC_REFRESH,                IDH_DETAILED_BATINFO_REFRESH,
    0, 0
};

/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/

/*******************************************************************************
*
*  DllInitialize
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL DllInitialize(IN PVOID hmod, IN ULONG ulReason, IN PCONTEXT pctx OPTIONAL)
{
    UNREFERENCED_PARAMETER(pctx);

    switch (ulReason) {

        case DLL_PROCESS_ATTACH:
            g_hInstance = hmod;
            DisableThreadLibraryCalls(g_hInstance);
            SHFusionInitializeFromModuleID(hmod, 124);
            break;

        case DLL_PROCESS_DETACH:
            SHFusionUninitialize();
            break;
    }
    return TRUE;
}

/*******************************************************************************
*
*  PowerCapabilities
*
*  DESCRIPTION:
*   This public function is used to determine if the system has any power
*   management capabilities which require UI support. Return TRUE if power
*   management UI should be displayed.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL PowerCapabilities()
{
    SYSTEM_POWER_CAPABILITIES   spc;
    int   dummy;

#ifndef SIM_BATTERY
    if (GetPwrCapabilities(&spc)) {
        if ((spc.PowerButtonPresent) ||
            (spc.SleepButtonPresent) ||
            (spc.LidPresent) ||
            (spc.SystemS1) ||
            (spc.SystemS2) ||
            (spc.SystemS3) ||
            (spc.SystemS4) ||
            (spc.SystemS5) ||
            (spc.DiskSpinDown) ||
            (spc.SystemBatteriesPresent)) {
            return TRUE;
        }
        else {
            if (SystemParametersInfo(SPI_GETLOWPOWERACTIVE, 0, &dummy, 0)) {
                return TRUE;
            }
        }
    }
    return FALSE;
#else
    return TRUE;
#endif
}

/*******************************************************************************
*
*  BatMeterCapabilities
*
*  DESCRIPTION:
*   This public function is used to determine if the battery meter library
*   can run on the host machine. Return TRUE on success (battery meter can run).
*
*  PARAMETERS:
*   ppuiBatCount - Points to a pointer which will be filled in with a pointer
*                  to the global battery count.
*
*******************************************************************************/

BOOL BatMeterCapabilities(
    PUINT   *ppuiBatCount
)
{
#ifndef SIM_BATTERY
    SYSTEM_POWER_CAPABILITIES   spc;
#endif // SIM_BATTERY

    if (ppuiBatCount) {
        *ppuiBatCount = &g_uiBatCount;
    }
    g_uiBatCount = 0;

#ifndef SIM_BATTERY
    // Make sure we have batteries to query.
    if (GetPwrCapabilities(&spc)) {
        if (spc.SystemBatteriesPresent) {
            g_uiDriverCount = GetBatteryDriverNames(g_lpszDriverNames);
            if (g_uiDriverCount != 0) {
                g_uiBatCount = g_uiDriverCount;

                return TRUE;
            }
            else {
                DebugPrint( "BatMeterCapabilities, no battery drivers found.");
            }
        }
    }
    return FALSE;

#else // SIM_BATTERY
    g_uiBatCount = g_uiDriverCount = GetBatteryDriverNames(g_lpszDriverNames);
    return UpdateDriverList(g_lpszDriverNames, g_uiDriverCount);
#endif // SIM_BATTERY

}


/*******************************************************************************
*
*  CreateBatMeter
*
*  DESCRIPTION:
*   Create, fetch data for and draw the battery meter window. Returns a handle
*   to the newly created battery meter window on success, NULL on failure.
*
*  PARAMETERS:
*   hwndParent      - Parent of the battery meter dialog.
*   wndFrame        - Frame to locate the battery meter dialog.
*   bShowMulti      - Specifies the display mode (TRUE -> multiple battery).
*   pbsComposite    - Optional pointer to composite battery state.
*
*******************************************************************************/

HWND CreateBatMeter(
    HWND            hwndParent,
    HWND            hwndFrame,
    BOOL            bShowMulti,
    PBATTERY_STATE  pbsComposite
)
{
    INT iWidth, iHeight;
    RECT rFrame = {0};

    // Build the battery devices name list if hasn't already been built.
    if (!g_uiBatCount)
    {
        BatMeterCapabilities(NULL);
    }

    // Remember if we are showing details for each battery
    g_bShowingMulti = bShowMulti;

    // Make sure we have at least one battery.
    if (g_uiBatCount)
    {
        // Create the battery meter control.
        g_hwndParent = hwndParent;
        g_hwndBatMeter = CreateDialog(g_hInstance,
                                MAKEINTRESOURCE(IDD_BATMETER),
                                hwndParent,
                                BatMeterDlgProc);

        // Place the battery meter in the passed frame window.
        if ((g_hwndBatMeter) && (hwndFrame))
        {
            // Position the BatMeter dialog in the frame.
            if (!GetWindowRect(hwndFrame, &rFrame))
            {
                DebugPrint( "CreateBatMeter, GetWindowRect failed, hwndFrame: %08X", hwndFrame);
            }

            iWidth  = rFrame.right  - rFrame.left;
            iHeight = rFrame.bottom - rFrame.top;

            if (IsBiDiLocalizedSystemEx(NULL))
            {
                // Whistler #209400: On BIDI systems, ScreenToClient() wants the right
                // coord in the left location because everything is flipped.
                rFrame.left = rFrame.right;
            }

            if (!ScreenToClient(hwndParent, (LPPOINT)&rFrame))
            {
                DebugPrint( "CreateBatMeter, ScreenToClient failed");
            }

            if (!MoveWindow(g_hwndBatMeter,
                         rFrame.left,
                         rFrame.top,
                         iWidth,
                         iHeight,
                         FALSE))
            {
                DebugPrint( "CreateBatMeter, MoveWindow failed, %d, %d", rFrame.left, rFrame.top);
            }

            // Build the battery driver data list.
            if (!UpdateDriverList(g_lpszDriverNames, g_uiDriverCount))
            {
                return DestroyBatMeter(g_hwndBatMeter);
            }

            // Do the first update.
            UpdateBatMeter(g_hwndBatMeter, bShowMulti, TRUE, pbsComposite);
            ShowWindow(g_hwndBatMeter, SW_SHOWNOACTIVATE);
        }
    }

   return g_hwndBatMeter;
}

/*******************************************************************************
*
*  DestroyBatMeter
*
*  DESCRIPTION:
*
*******************************************************************************/

HWND DestroyBatMeter(HWND hWnd)
{
   SendMessage(hWnd, WM_DESTROYBATMETER, 0, 0);
   g_hwndBatMeter = NULL;
   return g_hwndBatMeter;
}

/*******************************************************************************
*
*  UpdateBatMeter
*
*  DESCRIPTION:
*   This function should be called when the battery meter parent window
*   receives a WM_POWERBROADCAST, PBT_APMPOWERSTATUSCHANGE message, it will
*   update the data in the global battery state list. If needed the display
*   will also be updated.
*
*  PARAMETERS:
*   HWND hwndBatMeter,          hWnd of the battery meter dialog
*   BOOL bShowMulti,            Specifies the display mode
*   BOOL bForceUpdate,          Forces a UI update
*   PBATTERY_STATE pbsComposite Optional pointer to composite battery state.
*
*******************************************************************************/

BOOL UpdateBatMeter(
    HWND            hWnd,
    BOOL            bShowMulti,
    BOOL            bForceUpdate,
    PBATTERY_STATE  pbsComposite
)
{
    BOOL bRet = FALSE;
    SYSTEM_POWER_STATUS sps;
    UINT uIconID;

    // Update the composite battery state.
    if (GetSystemPowerStatus(&sps) && hWnd) {
        if (sps.BatteryLifePercent > 100) {
            DebugPrint( "GetSystemPowerStatuse, set BatteryLifePercent: %d", sps.BatteryLifePercent);
        }

        // Fill in the composite battery state.
        SystemPowerStatusToBatteryState(&sps, &g_bs);

        // Update the information in the battery state list if we have a battery.
        if (g_hwndBatMeter) {

#ifndef SIM_BATTERY
           WalkBatteryState(DEVICES,
                            (WALKENUMPROC)UpdateBatInfoProc,
                            NULL,
                            (LPARAM)NULL,
                            (LPARAM)NULL);
#else
           WalkBatteryState(DEVICES,
                            (WALKENUMPROC)SimUpdateBatInfoProc,
                            NULL,
                            (LPARAM)NULL,
                            (LPARAM)NULL);
#endif

           // See if the current display mode matches the requested mode.
           if ((g_bShowingMulti != bShowMulti) || (bForceUpdate)) {
               g_bShowingMulti = SwitchDisplayMode(hWnd, bShowMulti);
               bForceUpdate  = TRUE;
           }

           if (g_bShowingMulti) {
               // Walk the bs list, and update all battery displays.
               WalkBatteryState(ALL,
                                (WALKENUMPROC)UpdateBatMeterProc,
                                hWnd,
                                (LPARAM)g_bShowingMulti,
                                (LPARAM)bForceUpdate);
           }
           else {
               // Display only the comosite battery information.
               UpdateBatMeterProc(&g_bs,
                                  hWnd,
                                  (LPARAM)g_bShowingMulti,
                                  (LPARAM)bForceUpdate);
           }
           bRet = TRUE;
        }
    }
    else {
        // Fill in default composite info.
        g_bs.ulPowerState     = BATTERY_POWER_ON_LINE;
        g_bs.ulBatLifePercent = (UINT) -1;
        g_bs.ulBatLifeTime    = (UINT) -1;

        uIconID = MapBatInfoToIconID(&g_bs);
        g_bs.hIconCache = GetBattIcon(hWnd, uIconID, g_bs.hIconCache, FALSE, 32);
        g_bs.hIconCache16 = GetBattIcon(hWnd, uIconID, g_bs.hIconCache16, FALSE, 16);
    }

    // If a pointer is provided, copy the composite battery state data.
    if (pbsComposite) {
        if (pbsComposite->ulSize == sizeof(BATTERY_STATE)) {
            memcpy(pbsComposite, &g_bs, sizeof(BATTERY_STATE));
        }
        else {
            DebugPrint( "UpdateBatMeter, passed BATTERY_STATE size is invalid");
        }
    }
    return bRet;
}

/*******************************************************************************
*
*                 P R I V A T E   F U N C T I O N S
*
*******************************************************************************/

/*******************************************************************************
*
*  LoadDynamicString
*
*  DESCRIPTION:
*     Wrapper for the FormatMessage function that loads a string from our
*     resource table into a dynamically allocated buffer, optionally filling
*     it with the variable arguments passed.
*
*  PARAMETERS:
*     uiStringID    - resource identifier of the string to use.
*     ...           - Optional parameters to use to format the string message.
*
*******************************************************************************/

LPTSTR CDECL LoadDynamicString(UINT uiStringID, ... )
{
    va_list Marker;
    TCHAR szBuf[256];
    LPTSTR lpsz;
    int   iLen;

    // va_start is a macro...it breaks when you use it as an assign...on ALPHA.
    va_start(Marker, uiStringID);

    iLen = LoadString(g_hInstance, uiStringID, szBuf, ARRAYSIZE(szBuf));

    if (iLen == 0) {
        DebugPrint( "LoadDynamicString: LoadString on: 0x%X failed", uiStringID);
        return NULL;
    }

    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                  (LPVOID) szBuf, 0, 0, (LPTSTR)&lpsz, 0, &Marker);

    return lpsz;
}

/*******************************************************************************
*
*  DisplayFreeStr
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

LPTSTR DisplayFreeStr(HWND hWnd, UINT uID, LPTSTR  lpsz, BOOL bFree)
{
    if (lpsz) {
        SetDlgItemText(hWnd, uID, lpsz);
        ShowWindow(GetDlgItem(hWnd, uID), SW_SHOWNOACTIVATE);
        if (bFree) {
            LocalFree(lpsz);
            return NULL;
        }
    }
    else {
        ShowWindow(GetDlgItem(hWnd, uID), SW_HIDE);
    }
    return lpsz;
}

/*******************************************************************************
*
*  ShowHideItem
*  ShowItem
*  HideItem
*
*  DESCRIPTION:
*     Handy helpers to show or hide dialog items in the battery meter dialog.
*
*  PARAMETERS:
*     hWnd - Battery meter dialog handle.
*     uID  - Control ID of control to be shown or hidden.
*
*******************************************************************************/

BOOL ShowHideItem(HWND hWnd, UINT uID, BOOL bShow)
{
    ShowWindow(GetDlgItem(hWnd, uID), (bShow)  ? SW_SHOWNOACTIVATE : SW_HIDE);
    return bShow;
}

void ShowItem(HWND hWnd, UINT uID)
{
    ShowWindow(GetDlgItem(hWnd, uID), SW_SHOWNOACTIVATE);
}

void HideItem(HWND hWnd, UINT uID)
{
    ShowWindow(GetDlgItem(hWnd, uID), SW_HIDE);
}

/*******************************************************************************
*
*  SwitchDisplayMode
*
*  DESCRIPTION:
*   Return TRUE if display is switched to multi battery mode.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL SwitchDisplayMode(HWND hWnd, BOOL bShowMulti)
{
    ULONG i, j;

    // Override request if multi-battery display is not possible.
    if ((bShowMulti) && (!g_uiBatCount)) {
        bShowMulti = FALSE;
    }

    if (!g_uiBatCount) {

        //
        // Hide all info if no batteries are installed
        //
        HideItem(hWnd, IDC_POWERSTATUSBAR);
        HideItem(hWnd, IDC_BARPERCENT);
        HideItem(hWnd, IDC_MOREINFO);

    } else if (bShowMulti) {
        HideItem(hWnd, IDC_POWERSTATUSBAR);
        HideItem(hWnd, IDC_BARPERCENT);
        ShowItem(hWnd, IDC_MOREINFO);

        for (i = 1; i <= g_uiBatCount; i++) {
            for (j = 0; j < BAT_LAST; j++) {
                ShowItem(hWnd, g_iMapBatNumToID[i][0]);
            }
        }
    }
    else {
        for (i = 1; i <= g_uiBatCount; i++) {
            for (j = 0; j < BAT_LAST; j++) {
                HideItem(hWnd, g_iMapBatNumToID[i][j]);
            }
        }

        ShowItem(hWnd, IDC_POWERSTATUSBAR);
        ShowItem(hWnd, IDC_BARPERCENT);
        HideItem(hWnd, IDC_MOREINFO);
    }
    return bShowMulti;
}

/*******************************************************************************
*
*  CleanupBatteryData
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void CleanupBatteryData(void)
{
   g_hwndBatMeter = NULL;

   // Mark all batteries as missing.
   memset(&g_pbs, 0, sizeof(g_pbs));

   // Walk the bs list, remove all devices and cleanup.
   WalkBatteryState(DEVICES,
                    (WALKENUMPROC)RemoveMissingProc,
                    NULL,
                    (LPARAM)NULL,
                    (LPARAM)REMOVE_ALL);

   // Free any old driver names.
   FreeBatteryDriverNames(g_lpszDriverNames);
   g_uiBatCount = 0;
}

/*******************************************************************************
*
*  BatMeterDlgProc
*
*  DESCRIPTION:
*   DialogProc for the Battery Meter control. Provide support for more battery
*   info.
*
*  PARAMETERS:
*
*******************************************************************************/

LRESULT CALLBACK BatMeterDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
#ifdef WINNT
    UINT i, j;
    PBATTERY_STATE pbsTemp;
#endif // WINNT

    UINT uiBatNum;

   switch (uMsg) {
      case WM_COMMAND:
         if ((HIWORD(wParam) == STN_CLICKED) ||
             (HIWORD(wParam) == BN_CLICKED)) {
            switch (LOWORD(wParam)) {
               case IDC_POWERSTATUSICON1:
               case IDC_POWERSTATUSICON2:
               case IDC_POWERSTATUSICON3:
               case IDC_POWERSTATUSICON4:
               case IDC_POWERSTATUSICON5:
               case IDC_POWERSTATUSICON6:
               case IDC_POWERSTATUSICON7:
               case IDC_POWERSTATUSICON8:
                  uiBatNum = LOWORD(wParam) - IDC_POWERSTATUSICON1 + 1;
                  // Allow battery details only for present batteries.
                  if ((g_pbs[uiBatNum]) &&
                      (g_pbs[uiBatNum]->ulTag != BATTERY_TAG_INVALID)) {
                     DialogBoxParam(g_hInstance,
                                    MAKEINTRESOURCE(IDD_BATDETAIL),
                                    hWnd,
                                    BatDetailDlgProc,
                                    (LPARAM)g_pbs[uiBatNum]);
                  }
                  break;
            }
         }
         break;

      case WM_DESTROYBATMETER:
         CleanupBatteryData();
         EndDialog(hWnd, wParam);
         break;

      case WM_DESTROY:
         CleanupBatteryData();
         break;

      case WM_DEVICECHANGE:
#ifdef WINNT
         if ((wParam == DBT_DEVICEQUERYREMOVE) || (wParam == DBT_DEVICEREMOVECOMPLETE)) {
            if ( ((PDEV_BROADCAST_HANDLE)lParam)->dbch_devicetype == DBT_DEVTYP_HANDLE) {

               //
               // Find Device that got removed
               //
               pbsTemp = DEVICES;
               while (pbsTemp) {
                  if (pbsTemp->hDevNotify == ((PDEV_BROADCAST_HANDLE)lParam)->dbch_hdevnotify) {
                     break;
                  }
                  pbsTemp = pbsTemp->bsNext;
               }
               if (!pbsTemp) {
                  break;
               }

               //
               // Close the handle to this device and release cached data.
               //
               RemoveBatteryStateDevice (pbsTemp);
               g_uiDriverCount--;
               g_uiBatCount = g_uiDriverCount;

               // Clear and rebuild g_pbs, the handy batttery number to pbs array.
               memset(&g_pbs, 0, sizeof(g_pbs));
               pbsTemp = &g_bs;
               for (i = 0; i <= g_uiBatCount; i++) {
                  if (pbsTemp) {
                     g_pbs[i] = pbsTemp;
                     pbsTemp->ulBatNum = i;
                     pbsTemp = pbsTemp->bsNext;
                  }
               }

               // Refresh display
               for (i = 1; i <= NUM_BAT; i++) {
                  for (j = 0; j < BAT_LAST; j++) {
                     HideItem(g_hwndBatMeter, g_iMapBatNumToID[i][j]);
                  }
               }

               g_bShowingMulti = SwitchDisplayMode (g_hwndBatMeter, g_bShowingMulti);
               if (g_bShowingMulti) {
                  // Walk the bs list, and update all battery displays.
                  WalkBatteryState(DEVICES,
                                   (WALKENUMPROC)UpdateBatMeterProc,
                                   g_hwndBatMeter,
                                   (LPARAM)g_bShowingMulti,
                                   (LPARAM)TRUE);
               }
            }
         }
#else
         if (wParam == DBT_DEVICEQUERYREMOVE) {
            if (g_hwndBatMeter) {
               // Close all of the batteries.
               CleanupBatteryData();
            }
         }
#endif
         return TRUE;

      case WM_HELP:             // F1
         WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_ContextMenuHelpIDs);
         return TRUE;

      case WM_CONTEXTMENU:      // right mouse click
         WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_ContextMenuHelpIDs);
         return TRUE;
   }
   return FALSE;
}

/*******************************************************************************
*
*  GetBattIcon
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

HICON PASCAL GetBattIcon(
    HWND    hWnd,
    UINT    uIconID,
    HICON   hIconCache,
    BOOL    bWantBolt,
    UINT    uiRes)
{
    static HIMAGELIST hImgLst32, hImgLst16;
    HIMAGELIST hImgLst;
    int ImageIndex;

    // Destroy the old cached icon.
    if (hIconCache) {
        DestroyIcon(hIconCache);
    }

    // Don't put the charging bolt over the top of IDI_BATGONE.
    if (uIconID == IDI_BATGONE) {
        bWantBolt = FALSE;
    }

    // Use the transparency color must match that in the bit maps.
    if (!hImgLst32 || !hImgLst16) {
        hImgLst32 = ImageList_LoadImage(g_hInstance,
                                        MAKEINTRESOURCE(IDB_BATTS),
                                        32, 0, RGB(255, 0, 255), IMAGE_BITMAP, 0);
        hImgLst16 = ImageList_LoadImage(g_hInstance,
                                        MAKEINTRESOURCE(IDB_BATTS16),
                                        16, 0, RGB(255, 0, 255), IMAGE_BITMAP, 0);
        ImageList_SetOverlayImage(hImgLst32, IDI_CHARGE-FIRST_ICON_IMAGE, 1);
        ImageList_SetOverlayImage(hImgLst16, IDI_CHARGE-FIRST_ICON_IMAGE, 1);
    }

    if (uiRes == 32) {
        hImgLst = hImgLst32;
    }
    else {
        hImgLst = hImgLst16;
    }

    ImageIndex = uIconID - FIRST_ICON_IMAGE;

    if (bWantBolt) {
        return ImageList_GetIcon(hImgLst, ImageIndex, INDEXTOOVERLAYMASK(1));
    }
    else {
        return ImageList_GetIcon(hImgLst, ImageIndex, ILD_NORMAL);
    }
}

/*******************************************************************************
*
*  CheckUpdateBatteryState
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

#define UPDATESTATUS_NOUPDATE        0
#define UPDATESTATUS_UPDATE          1
#define UPDATESTATUS_UPDATE_CHARGE   2

UINT CheckUpdateBatteryState(
    PBATTERY_STATE   pbs,
    BOOL             bForceUpdate
)
{
    UINT uiRetVal = UPDATESTATUS_NOUPDATE;

    // Check to see if anything in the battery status has changed
    // since last time.  If not then we have no work to do!

    if ((bForceUpdate) ||
        !((pbs->ulTag            == pbs->ulLastTag) &&
          (pbs->ulBatLifePercent == pbs->ulLastBatLifePercent) &&
          (pbs->ulBatLifeTime    == pbs->ulLastBatLifeTime) &&
          (pbs->ulPowerState     == pbs->ulLastPowerState))) {

        uiRetVal = UPDATESTATUS_UPDATE;

        //  Check for the special case where the charging state has changed.
        if ((pbs->ulPowerState     & BATTERY_CHARGING) !=
            (pbs->ulLastPowerState & BATTERY_CHARGING)) {
                uiRetVal |= UPDATESTATUS_UPDATE_CHARGE;
        }

        // Copy current battery state to last.
        pbs->ulLastTag            = pbs->ulTag;
        pbs->ulLastBatLifePercent = pbs->ulBatLifePercent;
        pbs->ulLastBatLifeTime    = pbs->ulBatLifeTime;
        pbs->ulLastPowerState     = pbs->ulPowerState;
    }
    return uiRetVal;
}

/*******************************************************************************
*
*  MapBatInfoToIconID
*
*  DESCRIPTION:
*    Map battery info to an Icon ID.
*
*  PARAMETERS:
*    ulBatNum - Zero implies composite system state
*
*******************************************************************************/

UINT MapBatInfoToIconID(PBATTERY_STATE pbs)
{
    UINT uIconID = IDI_BATDEAD;

    if (!pbs->ulBatNum) {
        if (pbs->ulPowerState & BATTERY_POWER_ON_LINE) {
            return IDI_PLUG;
        }
    }
    else {
        if (pbs->ulTag == BATTERY_TAG_INVALID) {
            return IDI_BATGONE;
        }
    }

    if  (pbs->ulPowerState & BATTERY_CRITICAL) {
        return IDI_BATDEAD;
    }

    if (pbs->ulBatLifePercent > 66) {
        uIconID = IDI_BATFULL;
    }
    else {
        if (pbs->ulBatLifePercent > 33) {
            uIconID = IDI_BATHALF;
        }
        else {
            if (pbs->ulBatLifePercent > 9) {
                uIconID = IDI_BATLOW;
            }
        }
    }

    return uIconID;
}

/*******************************************************************************
*
*  DisplayIcon
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void DisplayIcon(
    HWND            hWnd,
    UINT            uIconID,
    PBATTERY_STATE  pbs,
    ULONG           ulUpdateStatus
)
{
    BOOL    bBolt;
    UINT    uiMsg;

    // Only redraw the icon if it has changed OR
    // if it has gone from charging to not charging.
    if ((uIconID != pbs->uiIconIDcache) ||
        (ulUpdateStatus != UPDATESTATUS_NOUPDATE)) {

        pbs->uiIconIDcache = uIconID;
        bBolt = (pbs->ulPowerState & BATTERY_CHARGING);

        pbs->hIconCache   = GetBattIcon(hWnd, uIconID, pbs->hIconCache, bBolt, 32);
        pbs->hIconCache16 = GetBattIcon(hWnd, uIconID, pbs->hIconCache16, bBolt, 16);

        if (pbs->ulBatNum) {
            uiMsg = BM_SETIMAGE;
        }
        else {
            uiMsg = STM_SETIMAGE;
        }
        SendDlgItemMessage(hWnd, g_iMapBatNumToID[pbs->ulBatNum][BAT_ICON],
                           uiMsg, IMAGE_ICON, (LPARAM) pbs->hIconCache);
        ShowItem(hWnd, g_iMapBatNumToID[pbs->ulBatNum][BAT_ICON]);
    }
}

/*******************************************************************************
*
*  UpdateBatMeterProc
*
*  DESCRIPTION:
*    Updates the System and per battery UI elements if needed.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL UpdateBatMeterProc(
    PBATTERY_STATE pbs,
    HWND hWnd,
    LPARAM bShowMulti,
    LPARAM bForceUpdate
)
{
    UINT   uIconID, uiHour, uiMin;
    LPTSTR lpsz, lpszRemaining;
    ULONG  ulUpdateStatus;

    ulUpdateStatus = CheckUpdateBatteryState(pbs, (BOOL) bForceUpdate);

    // Make sure there is work to do.
    if (ulUpdateStatus == UPDATESTATUS_NOUPDATE) {
       return TRUE;
    }

    // Determine which icon to display.
    uIconID = MapBatInfoToIconID(pbs);
    DisplayIcon(hWnd, uIconID, pbs, ulUpdateStatus);

    // Are we looking for system power status ?
    if (!pbs->ulBatNum) {

        // Display the Current Power Source text
        lpsz = LoadDynamicString(((pbs->ulPowerState & BATTERY_POWER_ON_LINE) ?
                                   IDS_ACLINEONLINE : IDS_BATTERIES));
        DisplayFreeStr(hWnd, IDC_BATTERYLEVEL, lpsz, FREE_STR);

        if (pbs->ulBatLifePercent <= 100) {
            lpsz = LoadDynamicString(IDS_PERCENTREMAININGFORMAT,
                                        pbs->ulBatLifePercent);
        }
        else {
            lpsz = LoadDynamicString(IDS_UNKNOWN);
        }
        DisplayFreeStr(hWnd, IDC_REMAINING, lpsz, NO_FREE_STR);

        ShowHideItem(hWnd, IDC_CHARGING, pbs->ulPowerState & BATTERY_CHARGING);

        // Show and Update the PowerStatusBar only if in single battery mode and
        // there is al least one battery installed.
        if (!bShowMulti && g_uiBatCount) {
            SendDlgItemMessage(hWnd, IDC_POWERSTATUSBAR, PBM_SETPOS,
                               (WPARAM) pbs->ulBatLifePercent, 0);
            lpsz = DisplayFreeStr(hWnd, IDC_BARPERCENT, lpsz, FREE_STR);
        }

        if (lpsz) {
            LocalFree(lpsz);
        }

        if (pbs->ulBatLifeTime != (UINT) -1) {
            uiHour = pbs->ulBatLifeTime / 3600;
            uiMin  = (pbs->ulBatLifeTime % 3600) / 60;
            if (uiHour) {
                lpsz = LoadDynamicString(IDS_TIMEREMFORMATHOUR, uiHour, uiMin);
            }
            else {
                lpsz = LoadDynamicString(IDS_TIMEREMFORMATMIN, uiMin);
            }
            DisplayFreeStr(hWnd, IDC_TIMEREMAINING, lpsz, FREE_STR);
            ShowHideItem(hWnd, IDC_TOTALTIME, TRUE);
        }
        else {
            ShowHideItem(hWnd, IDC_TOTALTIME, FALSE);
            ShowHideItem(hWnd, IDC_TIMEREMAINING, FALSE);
        }
    }
    else {

        // Here when getting the power status of each individual battery
        // when in multi-battery display mode.
        lpsz = LoadDynamicString(IDS_BATNUM, pbs->ulBatNum);
        DisplayFreeStr(hWnd, g_iMapBatNumToID[pbs->ulBatNum][BAT_NUM],
                       lpsz, FREE_STR);

        if (pbs->ulTag != BATTERY_TAG_INVALID) {
            if (pbs->ulPowerState & BATTERY_CHARGING) {
                lpsz = LoadDynamicString(IDS_BATTCHARGING);
            }
            else {
                lpsz = NULL;
            }
            lpszRemaining  = LoadDynamicString(IDS_PERCENTREMAININGFORMAT,
                                               pbs->ulBatLifePercent);
        }
        else {
            lpsz = LoadDynamicString(IDS_NOT_PRESENT);
            lpszRemaining  = NULL;
        }
        DisplayFreeStr(hWnd, g_iMapBatNumToID[pbs->ulBatNum][BAT_STATUS],
                       lpsz, FREE_STR);

        DisplayFreeStr(hWnd, g_iMapBatNumToID[pbs->ulBatNum][BAT_REMAINING],
                       lpszRemaining, FREE_STR);
    }
    return TRUE;
}

/*******************************************************************************
*
*  FreeBatteryDriverNames
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID FreeBatteryDriverNames(LPTSTR *lpszDriverNames)
{
    UINT i;

    // Free any old driver names.
    for (i = 0; i < NUM_BAT; i++) {
        if (lpszDriverNames[i]) {
            LocalFree(lpszDriverNames[i]);
            lpszDriverNames[i] = NULL;
        }
    }
}

/*******************************************************************************
*
*  GetBatteryDriverNames
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

UINT GetBatteryDriverNames(LPTSTR *lpszDriverNames)
{
    UINT                                uiDriverCount, uiIndex;
    DWORD                               dwReqSize;
    HDEVINFO                            hDevInfo;
    SP_INTERFACE_DEVICE_DATA            InterfaceDevData;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    pFuncClassDevData;

    // Free any old driver names.
    FreeBatteryDriverNames(lpszDriverNames);
    uiDriverCount = 0;

#ifndef SIM_BATTERY
    // Use the SETUPAPI.DLL interface to get the
    // possible battery driver names.
    hDevInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVICE_BATTERY, NULL, NULL,
                                   DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);

    if (hDevInfo != INVALID_HANDLE_VALUE) {
        InterfaceDevData.cbSize = sizeof(SP_DEVINFO_DATA);

        uiIndex = 0;
        while (uiDriverCount < NUM_BAT) {
            if (SetupDiEnumInterfaceDevice(hDevInfo,
                                           0,
                                           (LPGUID)&GUID_DEVICE_BATTERY,
                                           uiIndex,
                                           &InterfaceDevData)) {

                // Get the required size of the function class device data.
                SetupDiGetInterfaceDeviceDetail(hDevInfo,
                                                &InterfaceDevData,
                                                NULL,
                                                0,
                                                &dwReqSize,
                                                NULL);

                pFuncClassDevData = LocalAlloc(0, dwReqSize);
                if (pFuncClassDevData != NULL) {
                    pFuncClassDevData->cbSize =
                        sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);

                    if (SetupDiGetInterfaceDeviceDetail(hDevInfo,
                                                        &InterfaceDevData,
                                                        pFuncClassDevData,
                                                        dwReqSize,
                                                        &dwReqSize,
                                                        NULL)) {

                        dwReqSize = (lstrlen(pFuncClassDevData->DevicePath) + 1) * sizeof(TCHAR);
                        lpszDriverNames[uiDriverCount] = LocalAlloc(0, dwReqSize);

                        if (lpszDriverNames[uiDriverCount]) {
                            lstrcpy(lpszDriverNames[uiDriverCount],
                                    pFuncClassDevData->DevicePath);
                            uiDriverCount++;
                        }
                    }
                    else {
                        DebugPrint("SetupDiGetInterfaceDeviceDetail, failed: %d", GetLastError());
                    }

                    LocalFree(pFuncClassDevData);
                }
            } else {
                if (ERROR_NO_MORE_ITEMS == GetLastError()) {
                    break;
                }
                else {
                    DebugPrint("SetupDiEnumInterfaceDevice, failed: %d", GetLastError());
                }
            }
            uiIndex++;
        }
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    else {
        DebugPrint("SetupDiGetClassDevs on GUID_DEVICE_BATTERY, failed: %d", GetLastError());
    }
#else
   // Simulate batteries.
   {
      UINT i;
      static UINT uiState = 1;

      for (i = 0; i <= uiState; i++) {
         lpszDriverNames[i] = LocalAlloc(0, STRSIZE(TEXT("SIMULATED_BATTERY_0")));
         wsprintf(lpszDriverNames[i], TEXT("SIMULATED_BATTERY_%d"), i);
      }
      uiState++;
      uiDriverCount = uiState;
      if (uiState >= NUM_BAT) {
         uiState = 0;
      }
   }
#endif
    return uiDriverCount;
}

/*******************************************************************************
*
*  UpdateDriverList
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL UpdateDriverList(
    LPTSTR *lpszDriverNames,
    UINT uiDriverCount
)
{
    UINT            i;
    PBATTERY_STATE  pbs;

    // Walk the bs list, and remove any devices which aren't in pszDeviceNames.
    WalkBatteryState(DEVICES,
                     (WALKENUMPROC)RemoveMissingProc,
                     NULL,
                     (LPARAM)g_lpszDriverNames,
                     (LPARAM)REMOVE_MISSING);

    // Scan the pszDeviceNames list and add any devices which aren't in bs.
    for (i = 0; i < uiDriverCount; i++) {

        if (WalkBatteryState(DEVICES,
                             (WALKENUMPROC)FindNameProc,
                             NULL,
                             (LPARAM)g_lpszDriverNames[i],
                             (LPARAM)NULL)) {

#ifndef SIM_BATTERY
            if (!AddBatteryStateDevice(g_lpszDriverNames[i], i + 1)) {
                // We weren't able get minimal info from driver, dec the
                // battery counts. g_uiBatCount should always be > 0.
                if (--g_uiDriverCount) {;
                    g_uiBatCount--;
                }
            }
#else
            SimAddBatteryStateDevice(g_lpszDriverNames[i], i + 1);
#endif
        }
    }

    // Clear and rebuild g_pbs, the handy batttery number to pbs array.
    memset(&g_pbs, 0, sizeof(g_pbs));
    pbs = &g_bs;
    for (i = 0; i <= g_uiBatCount; i++) {
        if (pbs) {
            g_pbs[i] = pbs;
            pbs = pbs->bsNext;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batmeter\bmresid.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       BMRESID.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*
*  Resource identifiers for the battery meter helper DLL.
*
*******************************************************************************/

#define IDC_STATIC                      -1

//  Dialog box control identifiers.
#define IDD_BATMETER                    100
#define IDD_BATDETAIL                   126
#define IDD_MOREINFO                    127

//  Control identifiers of IDD_BATMETER
#define IDC_BATTERYLEVEL                1001
#define IDC_REMAINING                   1002
#define IDC_POWERSTATUSICON             1003
#define IDC_POWERSTATUSBAR              1004
#define IDC_BARPERCENT                  1005
#define IDC_CHARGING                    1006
#define IDC_MOREINFO                    1007
#define IDC_BATNUM0                     1008
#define IDC_TOTALTIME                   1067
#define IDC_TIMEREMAINING               1068
#define IDC_CURRENTPOWERSOURCE          1069
#define IDC_TOTALBATPWRREMAINING        1070

// next eight must be consecutive...
#define IDC_POWERSTATUSICON1            1010
#define IDC_POWERSTATUSICON2            1011
#define IDC_POWERSTATUSICON3            1012
#define IDC_POWERSTATUSICON4            1013
#define IDC_POWERSTATUSICON5            1014
#define IDC_POWERSTATUSICON6            1015
#define IDC_POWERSTATUSICON7            1016
#define IDC_POWERSTATUSICON8            1017

// next eight must be consecutive...
#define IDC_REMAINING1                  1020
#define IDC_REMAINING2                  1021
#define IDC_REMAINING3                  1022
#define IDC_REMAINING4                  1023
#define IDC_REMAINING5                  1024
#define IDC_REMAINING6                  1025
#define IDC_REMAINING7                  1026
#define IDC_REMAINING8                  1027

// next eight must be consecutive...
#define IDC_STATUS1                     1030
#define IDC_STATUS2                     1031
#define IDC_STATUS3                     1032
#define IDC_STATUS4                     1033
#define IDC_STATUS5                     1034
#define IDC_STATUS6                     1035
#define IDC_STATUS7                     1036
#define IDC_STATUS8                     1037

// next eight must be consecutive...
#define IDC_BATNUM1                     1040
#define IDC_BATNUM2                     1041
#define IDC_BATNUM3                     1042
#define IDC_BATNUM4                     1043
#define IDC_BATNUM5                     1044
#define IDC_BATNUM6                     1045
#define IDC_BATNUM7                     1046
#define IDC_BATNUM8                     1047


//  Control identifiers of IDD_BATDETAIL
#define IDC_BAT_NUM_GROUP               1100
#define IDC_STATE                       1101
#define IDC_CHEM                        1102
#define IDC_DEVNAME                     1103
#define IDC_BATMANDATE                  1104
#define IDC_BATID                       1105
#define IDC_BATMANNAME                  1106
#define IDC_REFRESH                     1107
#define IDC_BATMETERGROUPBOX            1108
#define IDC_BATMETERGROUPBOX1           1109
#define IDC_BATTERYNAME                 1110
#define IDC_UNIQUEID                    1111
#define IDC_MANUFACTURE                 1112
#define IDC_DATEMANUFACTURED            1113
#define IDC_CHEMISTRY                   1114
#define IDC_POWERSTATE                  1115

// String identifiers of IDD_BATMETER.
#define IDS_ACLINEONLINE                        100
#define IDS_BATTERYLEVELFORMAT                  101
#define IDS_UNKNOWN                             102
#define IDS_PERCENTREMAININGFORMAT              104
#define IDS_TIMEREMFORMATHOUR                   105
#define IDS_TIMEREMFORMATMIN                    106
#define IDS_BATTERIES                           109
#define IDS_NOT_PRESENT                         110
#define IDS_BATTCHARGING                        111
#define IDS_BATNUM                              112
#define IDS_BATTERYNUMDETAILS                   113
#define IDS_BATTERY_POWER_ON_LINE               114
#define IDS_BATTERY_DISCHARGING                 115
#define IDS_BATTERY_CHARGING                    116
#define IDS_BATTERY_CRITICAL                    117

// Image identifiers for IDB_BATTS, the IDI_* values MUST be sequential
// and in this order. Images are contained in the IDB_BATTS resource.
#define IDI_BATFULL     200
#define IDI_BATHALF     201
#define IDI_BATLOW      202
#define IDI_BATDEAD     203
#define IDI_UNKNOWN     204
#define IDI_BATGONE     205
#define IDI_PLUG        206
#define IDI_CHARGE      207
#define IDI_BATTPLUG    208
#define IDI_BATTERY     209

// Bitmap identifiers of IDD_BATMETER.
#define IDB_BATTS                       300
#define IDB_BATTS16                     301

// Definitions for image list.
#define FIRST_ICON_IMAGE        IDI_BATFULL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batmeter\test\bmtest.c ===
//*****************************************************************************
//
// BMTEST.C
//
// DESCRIPTION:
//
//
//*****************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <initguid.h>
#include <devguid.h>
#include <commctrl.h>

typedef LONG NTSTATUS;

#include <cfgmgr32.h>
#include <devioctl.h>
#include <ntpoapi.h>
#include <poclass.h>

#include "batmeter.h"
#include "bmtresid.h"

ULONG _cdecl DbgPrint(PCH Format, ...);

HINSTANCE g_hInstance;

DWORD g_dwCurBat;   // Battery we're currently displaying/editing.
PUINT g_puiBatCount;
BOOL  g_bShowMulti;

LRESULT CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    BOOL     Result;
    DWORD    Version, dwByteCount;


    InitCommonControls();

    g_hInstance = hInstance;

    // Get the battery count.
    if (BatMeterCapabilities(&g_puiBatCount)) {
        DialogBox(hInstance,
                  MAKEINTRESOURCE(IDD_BMTEST),
                  0,
                  DlgProc);
    }
    return 0;
}

//*****************************************************************************
//
// DlgProc
//
// DESCRIPTION:
//
// PARAMETERS:
//
//*****************************************************************************

LRESULT CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndBatMeter;

    switch (uMsg) {
        case WM_INITDIALOG:
            if (*g_puiBatCount > 1) {
                CheckDlgButton(hDlg, IDC_ENABLEMULTI, g_bShowMulti);
            }
            else {
                // Battery meter will not run, disable the enable checkbox
                EnableWindow(GetDlgItem(hDlg, IDC_ENABLEMULTI), FALSE);
            }
            hwndBatMeter = CreateBatMeter(hDlg, GetDlgItem(hDlg, IDC_STATIC_FRAME),
                                          g_bShowMulti, NULL);
            return TRUE;

        case WM_COMMAND:
            switch (wParam) {

                case IDCANCEL:
                case IDOK:
                    EndDialog(hDlg, 0);
                    return TRUE ;

                case IDC_ENABLEMULTI:
                    if (IsDlgButtonChecked(hDlg, IDC_ENABLEMULTI)) {
                        g_bShowMulti = TRUE;
                    }
                    else {
                        g_bShowMulti = FALSE;
                    }
                    UpdateBatMeter(hwndBatMeter, g_bShowMulti, TRUE, NULL);

            } // switch (wParam)
            break;

        case WM_POWERBROADCAST:
            if (wParam == PBT_APMPOWERSTATUSCHANGE) {
                UpdateBatMeter(hwndBatMeter, g_bShowMulti, FALSE, NULL);
            }
            break;

        case WM_DEVICECHANGE:
            BatMeterDeviceChanged(0, 0);
            break;

    } // switch (uMsg)
 
    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batmeter\batstate.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       BATSTATE.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   BATSTATE.C contains helper function which maintain the global battery
*   state list.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>

#include <dbt.h>           
#include <devioctl.h>
#include <ntpoapi.h>
#include <poclass.h>

#include "powrprofp.h"
#include "batmeter.h"

// Simulated battery only for debug build.
#ifndef DEBUG
#undef SIM_BATTERY
#endif

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

// Global battery state list. This list has the composite system battery state
// as it's always present head. individual battery devices are linked to this
// head. Use WalkBatteryState(ALL, ... to walk the entire list, including the
// head. Use WalkBatteryState(DEVICES, ... to walk just the device list. If a
// battery is in this list, it's displayable. g_ulBatCount is the count of
// battery devices in this list. The composite battery is not counted.

extern BATTERY_STATE   g_bs;
extern ULONG           g_ulBatCount;
extern HWND            g_hwndBatMeter;

#ifdef WINNT
/*******************************************************************************
*
*  RegisterForDeviceNotification
*
*  DESCRIPTION:
*    Do registration for WM_DEVICECHANGED.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL RegisterForDeviceNotification(PBATTERY_STATE pbs)
{
   DEV_BROADCAST_HANDLE dbh;

   memset(&dbh, 0, sizeof(DEV_BROADCAST_HANDLE));

   dbh.dbch_size        = sizeof(DEV_BROADCAST_HANDLE);
   dbh.dbch_devicetype  = DBT_DEVTYP_HANDLE;
   dbh.dbch_handle      = pbs->hDevice;
   
   if (!g_hwndBatMeter) {
      DebugPrint( "RegisterForDeviceNotification, NULL g_hwndBatMeter");
      return FALSE;
   }

   pbs->hDevNotify = RegisterDeviceNotification(g_hwndBatMeter,
                                                &dbh, 
                                                DEVICE_NOTIFY_WINDOW_HANDLE);
   
   if (!pbs->hDevNotify) { 
      DebugPrint( "RegisterDeviceNotification failed");
      return FALSE;
   }
   return TRUE;
}

/*******************************************************************************
*
*  UnregisterForDeviceNotification
*
*  DESCRIPTION:
*    
*
*  PARAMETERS:
*
*******************************************************************************/

void UnregisterForDeviceNotification(PBATTERY_STATE pbs)
{
   if (pbs->hDevNotify) {
      UnregisterDeviceNotification(pbs->hDevNotify);
      pbs->hDevNotify = NULL;
   }
}
#endif

/*******************************************************************************
*
*  SystemPowerStatusToBatteryState
*
*  DESCRIPTION:
*   Fill in BATTERY_STATE fields based on passed SYSTEM_POWER_STATUS.
*
*  PARAMETERS:
*
*******************************************************************************/

void SystemPowerStatusToBatteryState(
    LPSYSTEM_POWER_STATUS lpsps,
    PBATTERY_STATE pbs
)
{
    pbs->ulPowerState = 0;
    if (lpsps->ACLineStatus == AC_LINE_ONLINE) {
        pbs->ulPowerState |= BATTERY_POWER_ON_LINE;
    }
    if (lpsps->BatteryFlag & BATTERY_FLAG_CHARGING) {
        pbs->ulPowerState |= BATTERY_CHARGING;
    }
    if (lpsps->BatteryFlag & BATTERY_FLAG_CRITICAL) {
        pbs->ulPowerState |= BATTERY_CRITICAL;
    }
    pbs->ulBatLifePercent = lpsps->BatteryLifePercent;
    pbs->ulBatLifeTime    = lpsps->BatteryLifeTime;
}

/*******************************************************************************
*
* WalkBatteryState
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL WalkBatteryState(
    PBATTERY_STATE pbsStart,
    WALKENUMPROC pfnWalkEnumProc,
    HWND hWnd,
    LPARAM lParam1,
    LPARAM lParam2
)
{
    PBATTERY_STATE pbsTmp;

    while (pbsStart) {
        // Save the next entry in case the current one is deleted.
        pbsTmp = pbsStart->bsNext;
        if (!pfnWalkEnumProc(pbsStart, hWnd, lParam1, lParam2)) {
            return FALSE;
        }
        pbsStart = pbsTmp;
    }

    return TRUE;
}

/*******************************************************************************
*
* UpdateBatInfoProc
*
*  DESCRIPTION:
*   Updates battery information for an individual battery device.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL UpdateBatInfoProc(
    PBATTERY_STATE pbs,
    HWND hWnd,
    LPARAM lParam1,
    LPARAM lParam2
)
{
    DWORD                       dwByteCount, dwIOCTL, dwWait;
    BATTERY_STATUS              bs;
    BATTERY_WAIT_STATUS         bws;
    BATTERY_INFORMATION         bi;
    BATTERY_QUERY_INFORMATION   bqi;

    if (pbs->hDevice == INVALID_HANDLE_VALUE) {
        DebugPrint( "UpdateBatInfoProc, Bad battery driver handle, LastError: 0x%X", GetLastError());
        return FALSE;
    }

    // If no tag, then don't update the battery info.
    dwIOCTL = IOCTL_BATTERY_QUERY_TAG;
    dwWait = 0;
    if (DeviceIoControl(pbs->hDevice, dwIOCTL,
                        &dwWait, sizeof(dwWait),
                        &(pbs->ulTag), sizeof(ULONG),
                        &dwByteCount, NULL)) {

        bqi.BatteryTag = pbs->ulTag;
        bqi.InformationLevel = BatteryInformation;
        bqi.AtRate = 0;
        
        dwIOCTL = IOCTL_BATTERY_QUERY_INFORMATION;
        if (DeviceIoControl(pbs->hDevice, dwIOCTL,
                            &bqi, sizeof(bqi),
                            &bi,  sizeof(bi),
                            &dwByteCount, NULL)) {

            if (bi.FullChargedCapacity != UNKNOWN_CAPACITY) {
                pbs->ulFullChargedCapacity = bi.FullChargedCapacity;
            }
            else {
                pbs->ulFullChargedCapacity = bi.DesignedCapacity;
            }

            memset(&bws, 0, sizeof(BATTERY_WAIT_STATUS));
            bws.BatteryTag = pbs->ulTag;
            dwIOCTL = IOCTL_BATTERY_QUERY_STATUS;
            if (DeviceIoControl(pbs->hDevice, dwIOCTL,
                                &bws, sizeof(BATTERY_WAIT_STATUS),
                                &bs,  sizeof(BATTERY_STATUS),
                                &dwByteCount, NULL)) {

                pbs->ulPowerState = bs.PowerState;
                if (pbs->ulFullChargedCapacity < bs.Capacity) {
                    pbs->ulFullChargedCapacity = bs.Capacity;
                    DebugPrint( "UpdateBatInfoProc, unable to calculate ulFullChargedCapacity");
                }
                if (pbs->ulFullChargedCapacity == 0) {
                    pbs->ulBatLifePercent = 0;
                }
                else {
                    pbs->ulBatLifePercent =
                        (100 * bs.Capacity) / pbs->ulFullChargedCapacity;
                }
                return TRUE;
            }
        }
    }
    else {
        pbs->ulTag = BATTERY_TAG_INVALID;

        // No battery tag, that's ok, the user may have removed the battery.
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        }
    }
    DebugPrint( "UpdateBatInfoProc, IOCTL: %X Failure, BatNum: %d, LastError: %d\n", dwIOCTL, pbs->ulBatNum, GetLastError());
    return FALSE;
}

/*******************************************************************************
*
* SimUpdateBatInfoProc
*
*  DESCRIPTION:
*   Simulate the update of battery information for an individual batter device.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL SimUpdateBatInfoProc(
    PBATTERY_STATE pbs,
    HWND hWnd,
    LPARAM lParam1,
    LPARAM lParam2
)
{
    pbs->ulTag = pbs->ulBatNum;
    if (pbs->ulBatNum == 1) {
        pbs->ulFullChargedCapacity  = 2000;
        pbs->ulFullChargedCapacity  = 1991;
        pbs->ulPowerState           = BATTERY_CHARGING | BATTERY_POWER_ON_LINE;
        pbs->ulBatLifePercent       =   75;
    }
    else {
        pbs->ulFullChargedCapacity  = 3000;
        pbs->ulFullChargedCapacity  = 2991;
        pbs->ulPowerState           = BATTERY_DISCHARGING | BATTERY_CRITICAL;
        pbs->ulBatLifePercent       =  3;
    }
    return TRUE;
}

/*******************************************************************************
*
*  AddBatteryStateDevice
*
*  DESCRIPTION:
*   Add only displayable batteries to the battery list. New entry is appended
*   to battery state list.
*
*  PARAMETERS:
*
*******************************************************************************/

PBATTERY_STATE AddBatteryStateDevice(LPTSTR lpszName, ULONG ulBatNum)
{
    PBATTERY_STATE  pbs, pbsTemp = &g_bs;
    LPTSTR          lpsz = NULL;

    if (!lpszName) {
        return NULL;
    }

    // Append to end of list
    while (pbsTemp->bsNext) {
        pbsTemp = pbsTemp->bsNext;
    }

    // Allocate storage for new battery device state.
    if (pbs = LocalAlloc(LPTR, sizeof(BATTERY_STATE))) {
        if (lpsz = LocalAlloc(0, STRSIZE(lpszName))) {
            lstrcpy(lpsz, lpszName);
            pbs->lpszDeviceName = lpsz;
            pbs->ulSize = sizeof(BATTERY_STATE);
            pbs->ulBatNum = ulBatNum;

            // Open a handle to the battery driver.
            pbs->hDevice = CreateFile(lpszName,
                                      GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL, OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL, NULL);
#ifdef WINNT
            // Setup for notification by PNP when battery goes away. 
            RegisterForDeviceNotification(pbs);
#endif
            // Get the current battery info from the battery driver.
            if (UpdateBatInfoProc(pbs, NULL, 0, 0)) {

                // Link the new battery device state into the list.
                pbsTemp->bsNext = pbs;
                pbs->bsPrev = pbsTemp;
                return pbs;
            }
            LocalFree(lpsz);
        }
        LocalFree(pbs);
    }
    return NULL;
}

/*******************************************************************************
*
*  SimAddBatteryStateDevice
*
*  DESCRIPTION:
*   Simulate the addition of displayable batteries to the battery list.
*   New entry is appended to battery state list.
*
*  PARAMETERS:
*
*******************************************************************************/

PBATTERY_STATE SimAddBatteryStateDevice(LPTSTR lpszName, ULONG ulBatNum)
{
    PBATTERY_STATE  pbs, pbsTemp = &g_bs;
    LPTSTR          lpsz = NULL;

    if (!lpszName) {
        return NULL;
    }

    // Append to end of list
    while (pbsTemp->bsNext) {
        pbsTemp = pbsTemp->bsNext;
    }

    // Allocate storage for new battery device state.
    if (pbs = LocalAlloc(LPTR, sizeof(BATTERY_STATE))) {
        if (lpsz = LocalAlloc(0, STRSIZE(lpszName))) {
            lstrcpy(lpsz, lpszName);
            pbs->lpszDeviceName = lpsz;
            pbs->ulSize = sizeof(BATTERY_STATE);
            pbs->ulBatNum = ulBatNum;

            // Open a handle to the battery driver.
            pbs->hDevice = (HANDLE) -1;

            // Get the current battery info from the battery driver.
            if (SimUpdateBatInfoProc(pbs, NULL, 0, 0)) {

                // Link the new battery device state into the list.
                pbsTemp->bsNext = pbs;
                pbs->bsPrev = pbsTemp;
                return pbs;
            }
            LocalFree(lpsz);
        }
        LocalFree(pbs);
    }
    return NULL;
}


/*******************************************************************************
*
* RemoveBatteryStateDevice
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL RemoveBatteryStateDevice(PBATTERY_STATE pbs)
{
    // Unlink
    if (pbs->bsNext) {
        pbs->bsNext->bsPrev = pbs->bsPrev;
    }
    if (pbs->bsPrev) {
        pbs->bsPrev->bsNext = pbs->bsNext;
    }

#ifdef winnt
    UnregisterForDeviceNotification(pbs);
#endif
    
    // Free the battery driver handle if one was opened.
    if (pbs->hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(pbs->hDevice);
    }

    // Free the device name.
    LocalFree(pbs->lpszDeviceName);

    // Destroy any icons.
    if (pbs->hIconCache) {
        DestroyIcon(pbs->hIconCache);
    }
    if (pbs->hIconCache16) {
        DestroyIcon(pbs->hIconCache16);
    }

    // Free the associated storage.
    LocalFree(pbs);

    return TRUE;
}

/*******************************************************************************
*
*  RemoveMissingProc
*
*  DESCRIPTION:
*   Remove a battery from the global battery state list.
*
*  PARAMETERS:
*   lParam2 - REMOVE_MISSING or REMOVE_ALL
*
*******************************************************************************/

BOOL RemoveMissingProc(
    PBATTERY_STATE   pbs,
    HWND             hWnd,
    LPARAM           lParam1,
    LPARAM           lParam2)
{
    UINT    i;
    LPTSTR  *pszDeviceNames;

    if (lParam2 == REMOVE_MISSING) {
        if ((pszDeviceNames = (LPTSTR *)lParam1) != NULL) {
            for (i = 0; i < NUM_BAT; i++) {
                if (pszDeviceNames[i]) {
                    if (!lstrcmp(pbs->lpszDeviceName, pszDeviceNames[i])) {
                        // Device found in device list, leave it alone.
                        return TRUE;
                    }
                }
                else {
                    continue;
                }
            }
        }
    }

    // Device not in the device names list, remove it.
    RemoveBatteryStateDevice(pbs);
    return TRUE;
}

/*******************************************************************************
*
* FindNameProc
*
*  DESCRIPTION:
*   Returns FALSE (stop searching) if we find the name, else TRUE.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL FindNameProc(PBATTERY_STATE pbs, HWND hWnd, LPARAM lParam1, LPARAM lParam2)
{
    if (lParam1) {
        if (!lstrcmp(pbs->lpszDeviceName, (LPTSTR)lParam1)) {
            // Device found in device list.
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batmeter\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)
!include ..\batmeter.inc

SOURCES_USED    = ..\batmeter.inc
!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217 


TARGETNAME      = batmeter
TARGETPATH      = obj
TARGETTYPE      = DYNLINK
DLLENTRY        = DllInitialize

TARGETLIBS      =                                               \
                  $(SDK_LIB_PATH)\advapi32.lib                  \
                  $(SHELL_LIB_PATH)\shfusion.lib                  \
                  $(SDK_LIB_PATH)\kernel32.lib                  \
                  $(SDK_LIB_PATH)\powrprof.lib                  \
                  $(SDK_LIB_PATH)\setupapi.lib                  \
                  $(SDK_LIB_PATH)\user32.lib                    \
                  $(SHELL_LIB_PATH)\shlwapip.lib                \
                  $(CCSHELL_DIR)\lib\$(O)\stock.lib             

!if defined(TARGET_WIN95)
USE_LIBCMT      = 1
!else
USE_MSVCRT=1
PASS1_PUBLISH={$(O)\batmeter.lib=$(DDK_LIB_PATH)\batmeter.lib}
!endif

DLLDEF          = $O\batmeter.def

SOURCES         = ..\batmeter.c      \
                  ..\batmeter.rc     \
                  ..\details.c       \
                  ..\batstate.c
 
 
# 
# Fusionized
# 
SXS_MANIFEST_RESOURCE_ID=124
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batmeter\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BATMETER.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1075
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batmeter\details.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       DETAILS.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Implements the Detailed Batery Information dialog.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>

#include <devioctl.h>
#include <ntpoapi.h>
#include <poclass.h>

#include "batmeter.h"
#include "bmresid.h"

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

extern HINSTANCE   g_hInstance;             // Global instance handle of this DLL.
extern const DWORD g_ContextMenuHelpIDs[];  //Help ID's.

/*******************************************************************************
*
*  AppendStrID
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL AppendStrID(LPTSTR lpszDest, UINT uiID, BOOLEAN bUseComma)
{
    LPTSTR lpsz;

    if (lpszDest) {
        lpsz = LoadDynamicString(uiID);
        if (lpsz) {
            if (bUseComma) {
                lstrcat(lpszDest, TEXT(", "));
            }
            lstrcat(lpszDest, lpsz);
            LocalFree(lpsz);
            return TRUE;
        }
    }
    return FALSE;
}
/*******************************************************************************
*
*  GetBatStatusDetails
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL GetBatStatusDetails(HWND hWnd, PBATTERY_STATE pbs)
{
    BATTERY_STATUS              bs;
    BATTERY_WAIT_STATUS         bws;
    DWORD                       dwByteCount;
    BATTERY_INFORMATION         bi;
    BATTERY_QUERY_INFORMATION   bqi;
    TCHAR                       szChem[5], szStatus[128];
    CHAR                        szaChem[5];
    LPTSTR                      lpsz;
    UINT                        uiIDS;
    BOOLEAN                     bUseComma;

    bqi.BatteryTag = pbs->ulTag;
    bqi.InformationLevel = BatteryInformation;
    bqi.AtRate = 0;

    if (DeviceIoControl(pbs->hDevice, IOCTL_BATTERY_QUERY_INFORMATION,
                        &bqi, sizeof(bqi),
                        &bi,  sizeof(bi),
                        &dwByteCount, NULL)) {

        // Set chemistry.
        memcpy(szaChem, bi.Chemistry, 4);
        szaChem[4] = 0;

        if (szaChem[0]) {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0, szaChem, -1, szChem, 5);
            SetDlgItemText(hWnd, IDC_CHEM, szChem);
#else
            SetDlgItemText(hWnd, IDC_CHEM, szaChem);
#endif
        }
        else {
            ShowWindow(GetDlgItem(hWnd, IDC_CHEM), SW_HIDE);
            ShowWindow(GetDlgItem(hWnd, IDC_CHEMISTRY), SW_HIDE);
        }

        // Set up BATTERY_WAIT_STATUS for immediate return.
        memset(&bws, 0, sizeof(BATTERY_WAIT_STATUS));
        bws.BatteryTag = pbs->ulTag;

        if (DeviceIoControl(pbs->hDevice, IOCTL_BATTERY_QUERY_STATUS,
                            &bws, sizeof(BATTERY_WAIT_STATUS),
                            &bs,  sizeof(BATTERY_STATUS),
                            &dwByteCount, NULL)) {

            szStatus[0] = '\0';
            bUseComma = FALSE;
            if (bs.PowerState & BATTERY_POWER_ON_LINE) {
                AppendStrID(szStatus, IDS_BATTERY_POWER_ON_LINE, bUseComma);
                bUseComma = TRUE;
            }
            if (bs.PowerState & BATTERY_DISCHARGING) {
                AppendStrID(szStatus, IDS_BATTERY_DISCHARGING, bUseComma);
                bUseComma = TRUE;
            }
            if (bs.PowerState & BATTERY_CHARGING) {
                AppendStrID(szStatus, IDS_BATTERY_CHARGING, bUseComma);
                bUseComma = TRUE;
            }
            if (bs.PowerState & BATTERY_CRITICAL) {
                AppendStrID(szStatus, IDS_BATTERY_CRITICAL, bUseComma);
                bUseComma = TRUE;
            }
            SetDlgItemText(hWnd, IDC_STATE, szStatus);
            return TRUE;
        }
    }
    return FALSE;
}

/*******************************************************************************
*
*  GetBatQueryInfo
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL GetBatQueryInfo(
    PBATTERY_STATE              pbs,
    PBATTERY_QUERY_INFORMATION  pbqi,
    PULONG                      pulData,
    ULONG                       ulSize
)
{
    DWORD dwByteCount;

    if (DeviceIoControl(pbs->hDevice, IOCTL_BATTERY_QUERY_INFORMATION,
                        pbqi, sizeof(BATTERY_QUERY_INFORMATION),
                        pulData,  ulSize,
                        &dwByteCount, NULL)) {
        return TRUE;
    }
    return FALSE;
}

/*******************************************************************************
*
*  GetAndSetBatQueryInfoText
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL GetAndSetBatQueryInfoText(
    HWND                        hWnd,
    PBATTERY_STATE              pbs,
    PBATTERY_QUERY_INFORMATION  pbqi,
    UINT                        uiIDS,
    UINT                        uiLabelID
)
{
    WCHAR szBatStr[MAX_BATTERY_STRING_SIZE];

    memset(szBatStr, 0, sizeof(szBatStr));
    if (GetBatQueryInfo(pbs, pbqi, (PULONG)szBatStr, sizeof(szBatStr))) {
#ifdef UNICODE
        if (lstrcmp(szBatStr, TEXT(""))) {
            SetDlgItemText(hWnd, uiIDS, szBatStr);
            return TRUE;
        }
#else
        CHAR szaBatStr[MAX_BATTERY_STRING_SIZE];

        szaBatStr[0] = '\0';
        WideCharToMultiByte(CP_ACP, 0, szBatStr, -1,
                            szaBatStr, MAX_BATTERY_STRING_SIZE, NULL, NULL);
        if (szaBatStr[0]) {
            SetDlgItemText(hWnd, uiIDS, szaBatStr);
            return TRUE;
        }
#endif
    }
    ShowWindow(GetDlgItem(hWnd, uiIDS), SW_HIDE);
    ShowWindow(GetDlgItem(hWnd, uiLabelID), SW_HIDE);
    return FALSE;
}

/*******************************************************************************
*
*  GetBatOptionalDetails
*
*  DESCRIPTION:
*   Get optional battery data and set the dialog control.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL GetBatOptionalDetails(HWND hWnd, PBATTERY_STATE pbs)
{
    BATTERY_QUERY_INFORMATION   bqi;
    ULONG                       ulData;
    LPTSTR                      lpsz = NULL;
    BATTERY_MANUFACTURE_DATE    bmd;
    TCHAR                       szDateBuf[128];
    SYSTEMTIME                  stDate;

    bqi.BatteryTag = pbs->ulTag;
    bqi.InformationLevel = BatteryManufactureDate;
    bqi.AtRate = 0;
    
    if (GetBatQueryInfo(pbs, &bqi, (PULONG)&bmd,
                        sizeof(BATTERY_MANUFACTURE_DATE))) {

        memset(&stDate, 0, sizeof(SYSTEMTIME));
        stDate.wYear  = (WORD) bmd.Year;
        stDate.wMonth = (WORD) bmd.Month;
        stDate.wDay   = (WORD) bmd.Day;

        GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE,
                      &stDate, NULL, szDateBuf, 128);
        SetDlgItemText(hWnd, IDC_BATMANDATE, szDateBuf);
    }
    else {
        ShowWindow(GetDlgItem(hWnd, IDC_BATMANDATE), SW_HIDE);
        ShowWindow(GetDlgItem(hWnd, IDC_DATEMANUFACTURED), SW_HIDE);
    }
    bqi.InformationLevel = BatteryDeviceName;
    GetAndSetBatQueryInfoText(hWnd, pbs, &bqi, IDC_DEVNAME, IDC_BATTERYNAME);

    bqi.InformationLevel = BatteryManufactureName;
    GetAndSetBatQueryInfoText(hWnd, pbs, &bqi, IDC_BATMANNAME, IDC_MANUFACTURE);

    bqi.InformationLevel = BatteryUniqueID;
    GetAndSetBatQueryInfoText(hWnd, pbs, &bqi, IDC_BATID, IDC_UNIQUEID);

    return TRUE;
}

/*******************************************************************************
*
*  InitBatDetailDlg
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL InitBatDetailDialogs(HWND hWnd, PBATTERY_STATE pbs)
{
    LPTSTR                      lpsz;
    DWORD                       dwByteCount;

    lpsz = LoadDynamicString(IDS_BATTERYNUMDETAILS, pbs->ulBatNum);
    if (lpsz) {
        SetWindowText(hWnd, lpsz);
        LocalFree(lpsz);
    }

    if (GetBatOptionalDetails(hWnd, pbs)) {
        return GetBatStatusDetails(hWnd, pbs);
    }
    return FALSE;
}

/*******************************************************************************
*
*  BatDetailDlgProc
*
*  DESCRIPTION:
*   DialogProc for the Detailed Battery Information dialog.
*
*  PARAMETERS:
*
*******************************************************************************/

LRESULT CALLBACK BatDetailDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT uiBatNum;
    static PBATTERY_STATE pbs;

    switch (uMsg) {
        case WM_INITDIALOG:
            pbs = (PBATTERY_STATE) lParam;
            return InitBatDetailDialogs(hWnd, pbs);

        case WM_COMMAND:
            switch (wParam) {
                case IDC_REFRESH:
                    GetBatStatusDetails(hWnd, pbs);
                    break;

                case IDCANCEL:
                case IDOK:
                    EndDialog(hWnd, wParam);
                    break;
            }
            break;

        case WM_HELP:             // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_ContextMenuHelpIDs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_ContextMenuHelpIDs);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batmeter\test\bmtresid.h ===
#define IDD_BMTEST                      101

#define IDC_ENABLEMETER                 1000
#define IDC_POWERSTATUSGROUPBOX         1001
#define IDC_ENABLEMULTI                 1002
#define IDC_STATIC_FRAME                1003

#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batmeter\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BMTEST.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batt\proj.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    proj.h

Abstract:

    Battery Class Installer header

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>

#include <ntpoapi.h>


#include <setupapi.h>       // PnP setup/installer services
#include <cfgmgr32.h>


#include "powrprof.h"

//
// Debug stuff
//

#if DBG > 0 && !defined(DEBUG)
#define DEBUG
#endif

#if DBG > 0 && !defined(FULL_DEBUG)
#define FULL_DEBUG
#endif


#define DEBUG_PRINT_BUFFER_LEN      1030
#define MAX_BUF                     260


//
// Trace flags
//

#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls




//
// Calling declarations
//
#define PUBLIC                      FAR PASCAL
#define CPUBLIC                     FAR CDECL
#define PRIVATE                     NEAR PASCAL


#ifdef DEBUG

void    
CPUBLIC 
CommonDebugMsgW(
    DWORD mask, 
    LPCSTR pszMsg, 
    ...
    );


void    
CPUBLIC 
CommonDebugMsgA(
    DWORD mask, 
    LPCSTR pszMsg, 
    ...
    );

#ifdef UNICODE
#define TRACE_MSG   CommonDebugMsgW
#else
#define TRACE_MSG   CommonDebugMsgA
#endif

extern DWORD    BattDebugPrintLevel;

#else   // !defined(DEBUG)

#define TRACE_MSG

#endif



//
// Prototypes
//

DWORD
PRIVATE
InstallCompositeBattery (
    IN     HDEVINFO                DevInfoHandle,
    IN     PSP_DEVINFO_DATA        DevInfoData,         OPTIONAL
    IN OUT PSP_DEVINSTALL_PARAMS   DevInstallParams
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\advdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    advdlg.c

Abstract:

    This module implements the advanced property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <windowsx.h>
#include <setupapi.h>
#include <syssetup.h>
#include "intlhlp.h"
#include "maxvals.h"




//
//  Context Help Ids.
//

static int aAdvancedHelpIds[] =
{
    IDC_GROUPBOX1,             IDH_COMM_GROUPBOX,
    IDC_GROUPBOX2,             IDH_COMM_GROUPBOX,
    IDC_GROUPBOX3,             IDH_COMM_GROUPBOX,
    IDC_CODEPAGES,             IDH_INTL_ADV_CODEPAGES,
    IDC_SYSTEM_LOCALE,         IDH_INTL_ADV_SYSTEM_LOCALE,
    IDC_SYSTEM_LOCALE_TEXT1,   IDH_INTL_ADV_SYSTEM_LOCALE,
    IDC_SYSTEM_LOCALE_TEXT2,   IDH_INTL_ADV_SYSTEM_LOCALE,
    IDC_DEFAULT_USER,          IDH_INTL_ADV_CHANGE,

    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ListViewCustomDraw
//
//  Processing for a list view NM_CUSTOMDRAW notification message.
//
////////////////////////////////////////////////////////////////////////////

void Advanced_ListViewCustomDraw(
    HWND hDlg,
    LPNMLVCUSTOMDRAW pDraw)
{
    LPCODEPAGE pNode;

    //
    //  Tell the list view to notify me of item draws.
    //
    if (pDraw->nmcd.dwDrawStage == CDDS_PREPAINT)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW);
        return;
    }

    //
    //  Handle the Item Prepaint.
    //
    pNode = (LPCODEPAGE)(pDraw->nmcd.lItemlParam);
    if ((pDraw->nmcd.dwDrawStage & CDDS_ITEMPREPAINT) &&
        (pNode) && (pNode != (LPCODEPAGE)(LB_ERR)))
    {
        if (pNode->wStatus & (ML_PERMANENT | ML_DISABLE))
        {
            pDraw->clrText = (pDraw->nmcd.uItemState & CDIS_SELECTED)
                               ? ((GetSysColor(COLOR_HIGHLIGHT) ==
                                   GetSysColor(COLOR_GRAYTEXT))
                                      ? GetSysColor(COLOR_HIGHLIGHTTEXT)
                                      : GetSysColor(COLOR_GRAYTEXT))
                               : GetSysColor(COLOR_GRAYTEXT);
        }
    }

    //
    //  Do the default action.
    //
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ListViewChanging
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_ListViewChanging(
    HWND hDlg,
    NM_LISTVIEW *pLV)
{
    LPCODEPAGE pNode;

    //
    //  Make sure it's a state change message.
    //
    if ((((*pLV).hdr).idFrom != IDC_CODEPAGES) ||
        (!(pLV->uChanged & LVIF_STATE)) ||
        ((pLV->uNewState & 0x3000) == 0))
    {
        return (FALSE);
    }

    //
    //  Get the item data for the currently selected item.
    //
    pNode = (LPCODEPAGE)(pLV->lParam);

    //
    //  Make sure we're not trying to change a permanent or disabled
    //  code page.  If so, return TRUE to prevent the change.
    //
    if ((pNode) && (pNode->wStatus & (ML_PERMANENT | ML_DISABLE)))
    {
        return (TRUE);
    }

    //
    //  Return FALSE to allow the change.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ListViewChanged
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_ListViewChanged(
    HWND hDlg,
    int iID,
    NM_LISTVIEW *pLV)
{
    HWND hwndLV = GetDlgItem(hDlg, iID);
    LPCODEPAGE pNode;
    BOOL bChecked;
    int iCount;

    //
    //  Make sure it's a state change message.
    //
    if ((((*pLV).hdr).idFrom != IDC_CODEPAGES) ||
        (!(pLV->uChanged & LVIF_STATE)) ||
        ((pLV->uNewState & 0x3000) == 0))
    {
        return (FALSE);
    }

    //
    //  Get the state of the check box for the currently selected item.
    //
    bChecked = ListView_GetCheckState(hwndLV, pLV->iItem) ? TRUE : FALSE;

    //
    //  Get the item data for the currently selected item.
    //
    pNode = (LPCODEPAGE)(pLV->lParam);

    //
    //  Make sure we're not trying to change a permanent or disabled
    //  code page.  If so, set the check box to its appropriate state.
    //
    if (pNode->wStatus & (ML_PERMANENT | ML_DISABLE))
    {
        if (pNode->wStatus & ML_PERMANENT)
        {
            if (bChecked == FALSE)
            {
                ListView_SetCheckState(hwndLV, pLV->iItem, TRUE);
            }
        }
        else            // ML_DISABLE only
        {
            if ((bChecked == FALSE) && (pNode->wStatus & ML_ORIG_INSTALLED))
            {
                ListView_SetCheckState(hwndLV, pLV->iItem, TRUE);
            }
            else if ((bChecked == TRUE) && (!(pNode->wStatus & ML_ORIG_INSTALLED)))
            {
                ListView_SetCheckState(hwndLV, pLV->iItem, FALSE);
            }
        }
        return (FALSE);
    }

    //
    //  Store the proper info in the code page structure.
    //
    pNode->wStatus &= (ML_ORIG_INSTALLED | ML_STATIC);
    pNode->wStatus |= ((bChecked) ? ML_INSTALL : ML_REMOVE);

    //
    //  Deselect all items.
    //
    iCount = ListView_GetItemCount(hwndLV);
    while (iCount > 0)
    {
        ListView_SetItemState( hwndLV,
                               iCount - 1,
                               0,
                               LVIS_FOCUSED | LVIS_SELECTED );
        iCount--;
    }

    //
    //  Make sure this item is selected.
    //
    ListView_SetItemState( hwndLV,
                           pLV->iItem,
                           LVIS_FOCUSED | LVIS_SELECTED,
                           LVIS_FOCUSED | LVIS_SELECTED );

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ListViewClick
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_ListViewClick(
    HWND hDlg,
    LPNMHDR lpNmHdr)
{
    LV_HITTESTINFO ht;
    HWND hwndList = GetDlgItem(hDlg, IDC_CODEPAGES);

    //
    //  Remove unnecessary processing.
    //
    if (lpNmHdr->idFrom != IDC_CODEPAGES)
    {
        return (FALSE);
    }

    //
    //  Get where we were hit and then translate it to our
    //  window.
    //
    GetCursorPos(&ht.pt);
    ScreenToClient(hwndList, &ht.pt);
    ListView_HitTest(hwndList, &ht);
    if ((ht.iItem >= 0) && ((ht.flags & LVHT_ONITEM) == LVHT_ONITEMLABEL))
    {
        UINT state;

        //
        //  The user clicked on the item label.  Simulate a
        //  state change so we can process it.
        //
        state = ListView_GetItemState( hwndList,
                                       ht.iItem,
                                       LVIS_STATEIMAGEMASK );
        state ^= INDEXTOSTATEIMAGEMASK(LVIS_SELECTED | LVIS_FOCUSED);

        //
        //  The state is either selected or focused.  Flip the
        //  bits.  The SetItemState causes the system to bounce
        //  back a notification for LVN_ITEMCHANGED and the
        //  code then does the right thing.  Note -- we MUST
        //  check for LVHT_ONITEMLABEL.  If we do this code for
        //  LVHT_ONITEMSTATEICON, the code will get 2
        //  ITEMCHANGED notifications, and the state will stay
        //  where it is, which is not good.  If we want this
        //  to also fire if the guy clicks in the empty space
        //  right of the label text, we need to look for
        //  LVHT_ONITEM as well as LVHT_ONITEMLABEL.
        //
        ListView_SetItemState( hwndList,
                               ht.iItem,
                               state,
                               LVIS_STATEIMAGEMASK );
   }

   return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_GetSupportedCodePages
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_GetSupportedCodePages()
{
    UINT CodePage;
    HANDLE hCodePage;
    LPCODEPAGE pCP;
    INFCONTEXT Context;
    TCHAR szSection[MAX_PATH];
    int LineCount, LineNum;
    CPINFOEX Info;

    //
    //  Get the number of supported code pages from the inf file.
    //
    LineCount = (UINT)SetupGetLineCount(g_hIntlInf, TEXT("CodePages"));
    if (LineCount <= 0)
    {
        return (FALSE);
    }

    //
    //  Go through all supported code pages in the inf file.
    //
    for (LineNum = 0; LineNum < LineCount; LineNum++)
    {
        if (SetupGetLineByIndex(g_hIntlInf, TEXT("CodePages"), LineNum, &Context) &&
            SetupGetIntField(&Context, 0, &CodePage))
        {
            //
            //  Create the new node.
            //
            if (!(hCodePage = GlobalAlloc(GHND, sizeof(CODEPAGE))))
            {
                return (FALSE);
            }
            pCP = GlobalLock(hCodePage);

            //
            //  Fill in the new node with the appropriate info.
            //
            pCP->wStatus = 0;
            pCP->CodePage = CodePage;
            pCP->hCodePage = hCodePage;
            (pCP->pszName)[0] = 0;

            //
            //  Get the appropriate display string.
            //
            if (GetCPInfoEx(CodePage, 0, &Info))
            {
                lstrcpy(pCP->pszName, Info.CodePageName);
            }
            else if (!SetupGetStringField(&Context, 1, pCP->pszName, MAX_PATH, NULL))
            {
                GlobalUnlock(hCodePage);
                GlobalFree(hCodePage);
                continue;
            }

            //
            //  See if this code page can be removed.
            //
            wsprintf(szSection, TEXT("%ws%d"), szCPRemovePrefix, CodePage);
            if ((CodePage == GetACP()) ||
                (CodePage == GetOEMCP()) ||
                (!SetupFindFirstLine( g_hIntlInf,
                                      szSection,
                                      TEXT("AddReg"),
                                      &Context )))
            {
                //
                //  Mark it as permanent.
                //  Also mark it as originally installed to avoid problems.
                //
                pCP->wStatus |= (ML_ORIG_INSTALLED | ML_PERMANENT);
            }

            //
            //  Add the code page to the front of the linked list.
            //
            pCP->pNext = pCodePages;
            pCodePages = pCP;
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_InitSystemLocales
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_InitSystemLocales(
    HWND hDlg)
{
    TCHAR szSystemBuf[SIZE_128];
    TCHAR szDefaultSystemBuf[SIZE_128];
    TCHAR szBuf[SIZE_128];
    DWORD dwIndex;
    HWND hSystemLocale = GetDlgItem(hDlg, IDC_SYSTEM_LOCALE);

    //
    //  Get the list of locales and fill in the system locale
    //  combo box.
    //
    Intl_EnumLocales(hDlg, hSystemLocale, TRUE);

    //
    //  Get the string for the system default setting.
    //  Special case Spanish.
    //
    if ((SysLocaleID == LCID_SPANISH_TRADITIONAL) ||
        (SysLocaleID == LCID_SPANISH_INTL))
    {
        LoadString(hInstance, IDS_SPANISH_NAME, szSystemBuf, SIZE_128);
    }
    else
    {
        GetLocaleInfo(SysLocaleID, LOCALE_SLANGUAGE, szSystemBuf, SIZE_128);
    }

    //
    //  Select the current system default locale id in the list.
    //
    dwIndex = ComboBox_FindStringExact(hSystemLocale, -1, szSystemBuf);
    if (dwIndex == CB_ERR)
    {
        dwIndex = ComboBox_FindStringExact(hSystemLocale, -1, szDefaultSystemBuf);
        if (dwIndex == CB_ERR)
        {
            GetLocaleInfo(US_LOCALE, LOCALE_SLANGUAGE, szBuf, SIZE_128);
            dwIndex = ComboBox_FindStringExact(hSystemLocale, -1, szBuf);
            if (dwIndex == CB_ERR)
            {
                dwIndex = 0;
            }
        }
    }
    ComboBox_SetCurSel(hSystemLocale, dwIndex);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_SetSystemLocale
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_SetSystemLocale(
    HWND hDlg)
{
    HWND hSystemLocale = GetDlgItem(hDlg, IDC_SYSTEM_LOCALE);
    DWORD dwLocale;
    LCID NewLocale;
    HCURSOR hcurSave;

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  Get the current selection.
    //
    dwLocale = ComboBox_GetCurSel(hSystemLocale);

    //
    //  Get the locale id for the current selection and save it.
    //
    NewLocale = (LCID)ComboBox_GetItemData(hSystemLocale, dwLocale);
    if (IsValidLocale(NewLocale, LCID_SUPPORTED))
    {
        SysLocaleID = NewLocale;
    }
    else
    {
        //
        //  This shouldn't happen, since the values in the combo box
        //  should already be installed via the language groups.
        //  Put up an error message just in case.
        //
        SetCursor(hcurSave);
        ShowMsg( NULL,
                 IDS_SETUP_STRING,
                 IDS_TITLE_STRING,
                 MB_OK_OOPS,
                 NULL );
        return (FALSE);
    }

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_InitCodePages
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_InitCodePages(
    HWND hDlg,
    BOOL bInitTime)
{
    HWND hwndCP = GetDlgItem(hDlg, IDC_CODEPAGES);
    LPCODEPAGE pCP;
    DWORD dwExStyle;
    RECT Rect;
    LV_COLUMN Column;
    LV_ITEM Item;
    int iIndex;

    //
    //  Open the Inf file.
    //
    g_hIntlInf = SetupOpenInfFile(szIntlInf, NULL, INF_STYLE_WIN4, NULL);
    if (g_hIntlInf == INVALID_HANDLE_VALUE)
    {
        return (FALSE);
    }

    if (!SetupOpenAppendInfFile(NULL, g_hIntlInf, NULL))
    {
        SetupCloseInfFile(g_hIntlInf);
        g_hIntlInf = NULL;
        return (FALSE);
    }

    //
    //  Get all supported code pages from the inf file.
    //
    if (Advanced_GetSupportedCodePages() == FALSE)
    {
        return (FALSE);
    }

    //
    //  Close the inf file.
    //
    SetupCloseInfFile(g_hIntlInf);
    g_hIntlInf = NULL;

    //
    //  Enumerate all installed code pages.
    //
    if (EnumSystemCodePages(Intl_EnumInstalledCPProc, CP_INSTALLED) == FALSE)
    {
        return (FALSE);
    }

    //
    //  We only want to do this the first time we setup the list view.
    //  Otherwise, we get multiple columns created.
    //
    if (bInitTime)
    {
        //
        //  Create a column for the list view.
        //
        GetClientRect(hwndCP, &Rect);
        Column.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        Column.fmt = LVCFMT_LEFT;
        Column.cx = Rect.right - GetSystemMetrics(SM_CYHSCROLL);
        Column.pszText = NULL;
        Column.cchTextMax = 0;
        Column.iSubItem = 0;
        ListView_InsertColumn(hwndCP, 0, &Column);

        //
        //  Set extended list view style to use the check boxes.
        //
        dwExStyle = ListView_GetExtendedListViewStyle(hwndCP);
        ListView_SetExtendedListViewStyle( hwndCP,
                                           dwExStyle |
                                             LVS_EX_CHECKBOXES |
                                             LVS_EX_FULLROWSELECT );
    }

    //
    //  Go through the list of code pages and add each one to the
    //  list view and set the appropriate state.
    //
    pCP = pCodePages;
    while (pCP)
    {
        //
        //  Insert the item into the list view.
        //
        Item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
        Item.iItem = 0;
        Item.iSubItem = 0;
        Item.state = 0;
        Item.stateMask = LVIS_STATEIMAGEMASK;
        Item.pszText = pCP->pszName;
        Item.cchTextMax = 0;
        Item.iImage = 0;
        Item.lParam = (LPARAM)pCP;

        iIndex = ListView_InsertItem(hwndCP, &Item);

        //
        //  Set the checked state.
        //
        //  There's a bug in the list view code such that the check mark
        //  isn't displayed when you set the state through InsertItem, so
        //  we have to set it explicitly using SetItemState.
        //
        if (iIndex >= 0)
        {
            ListView_SetItemState( hwndCP,
                                   iIndex,
                                   (pCP->wStatus & ML_ORIG_INSTALLED)
                                     ? INDEXTOSTATEIMAGEMASK(LVIS_SELECTED)
                                     : INDEXTOSTATEIMAGEMASK(LVIS_FOCUSED),
                                   LVIS_STATEIMAGEMASK );
        }

        //
        //  Advance to the next code page.
        //
        pCP = pCP->pNext;
    }

    //
    //  Deselect all items.
    //
    iIndex = ListView_GetItemCount(hwndCP);
    while (iIndex > 0)
    {
        ListView_SetItemState( hwndCP,
                               iIndex - 1,
                               0,
                               LVIS_FOCUSED | LVIS_SELECTED );
        iIndex--;
    }

    //
    //  Select the first one in the list.
    //
    ListView_SetItemState( hwndCP,
                           0,
                           LVIS_FOCUSED | LVIS_SELECTED,
                           LVIS_FOCUSED | LVIS_SELECTED );

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_FreeGlobalInfo
//
//  Processing for a WM_DESTROY message.
//
////////////////////////////////////////////////////////////////////////////

void Advanced_FreeGlobalInfo()
{
    LPCODEPAGE pPreCP, pCurCP;
    HANDLE hAlloc;

    //
    //  Remove Code Page info.
    //
    pCurCP = pCodePages;
    pCodePages = NULL;

    while (pCurCP)
    {
        pPreCP = pCurCP;
        pCurCP = pPreCP->pNext;
        hAlloc = pPreCP->hCodePage;
        GlobalUnlock(hAlloc);
        GlobalFree(hAlloc);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ClearValues
//
//  Reset each of the list boxes in the advanced property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Advanced_ClearValues(
    HWND hDlg)
{
    //
    //  Clear the system locale
    //
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SYSTEM_LOCALE));

    //
    //  Clear the Code Page list
    //
    ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_CODEPAGES));
    Advanced_FreeGlobalInfo();
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_SetValues
//
//  Initialize all of the controls in the advanced property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Advanced_SetValues(
    HWND hDlg,
    BOOL bInitTime)
{
    //
    //  Init system locale list.
    //
    Advanced_InitSystemLocales(hDlg);

    //
    //  Init code page list view.
    //
    Advanced_InitCodePages(hDlg, bInitTime);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ApplySettings
//
//  For every control that has changed (that affects the Locale settings),
//  call Set_Locale_Values to update the user locale information.  Notify
//  the parent of changes and reset the change flag stored in the property
//  sheet page structure appropriately.  Redisplay the time sample if
//  bRedisplay is TRUE.
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_ApplySettings(
    HWND hDlg)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;
    HWND hSystemLocale = GetDlgItem(hDlg, IDC_SYSTEM_LOCALE);
    DWORD dwLocale;
    LCID NewLocale;
    HCURSOR hcurSave;
    BOOL InvokeSysocmgr = FALSE;
    BOOL bReboot = FALSE;

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  See if there are any changes to the codepage conversions.
    //
    if (Changes & AD_CodePages)
    {
        LPCODEPAGE pCP;
        HINF hIntlInf;
        HSPFILEQ FileQueue;
        PVOID QueueContext;
        BOOL bInitInf = FALSE;
        BOOL fAdd;
        BOOL bRet = TRUE;
        TCHAR szSection[MAX_PATH];

        //
        //  Go through each code page node to see if anything needs to
        //  be done.
        //
        pCP = pCodePages;
        while (pCP)
        {
            //
            //  See if any changes are necessary for this code page.
            //
            if ((pCP->wStatus == ML_INSTALL) ||
                (pCP->wStatus == (ML_ORIG_INSTALLED | ML_REMOVE)))
            {
                //
                //  See if we're installing or removing.
                //
                fAdd = (pCP->wStatus == ML_INSTALL);

                //
                //  Initialize Inf stuff.
                //
                if ((!bInitInf) &&
                    (!Intl_InitInf(hDlg, &hIntlInf, szIntlInf, &FileQueue, &QueueContext)))
                {
                    SetCursor(hcurSave);
                    return (FALSE);
                }
                bInitInf = TRUE;

                //
                //  Get the inf section name.
                //
                wsprintf( szSection,
                          TEXT("%ws%d"),
                          fAdd ? szCPInstallPrefix : szCPRemovePrefix,
                          pCP->CodePage );

                //
                //  Enqueue the code page files so that they may be
                //  copied.  This only handles the CopyFiles entries in the
                //  inf file.
                //
                if (!SetupInstallFilesFromInfSection( hIntlInf,
                                                      NULL,
                                                      FileQueue,
                                                      szSection,
                                                      pSetupSourcePath,
                                                      SP_COPY_NEWER ))
                {
                    //
                    //  Setup failed to find the code page.
                    //  This shouldn't happen - the inf file is messed up.
                    //
                    ShowMsg( hDlg,
                             IDS_ML_COPY_FAILED,
                             0,
                             MB_OK_OOPS,
                             pCP->pszName );
                    pCP->wStatus = 0;
                }
            }

            //
            //  Go to the next code page node.
            //
            pCP = pCP->pNext;
        }

        if (bInitInf)
        {
            DWORD d;

            //
            //  See if we need to install any files.
            //
            //  d = 0: User wants new files or some files were missing;
            //         Must commit queue.
            //
            //  d = 1: User wants to use existing files and queue is empty;
            //         Can skip committing queue.
            //
            //  d = 2: User wants to use existing files, but del/ren queues
            //         not empty.  Must commit queue.  The copy queue will
            //         have been emptied, so only del/ren functions will be
            //         performed.
            //
            if ((SetupScanFileQueue( FileQueue,
                                     SPQ_SCAN_PRUNE_COPY_QUEUE |
                                       SPQ_SCAN_FILE_VALIDITY,
                                     GetParent(hDlg),
                                     NULL,
                                     NULL,
                                     &d )) && (d != 1))
            {
                //
                //  Copy the files in the queue.
                //
                if (!SetupCommitFileQueue( GetParent(hDlg),
                                           FileQueue,
                                           SetupDefaultQueueCallback,
                                           QueueContext ))
                {
                    //
                    //  This can happen if the user hits Cancel from within
                    //  the setup dialog.
                    //
                    ShowMsg( hDlg,
                             IDS_ML_SETUP_FAILED,
                             0,
                             MB_OK_OOPS,
                             NULL );
                    bRet = FALSE;
                    goto Advanced_CodepageConverionsSetupError;
                }
            }

            //
            //  Execute all of the other code page entries in the inf file.
            //
            pCP = pCodePages;
            while (pCP)
            {
                //
                //  See if any changes are necessary for this code page.
                //
                if ((pCP->wStatus == ML_INSTALL) ||
                    (pCP->wStatus == (ML_ORIG_INSTALLED | ML_REMOVE)))
                {
                    fAdd = (pCP->wStatus == ML_INSTALL);

                    //
                    //  Get the inf section name.
                    //
                    wsprintf( szSection,
                              TEXT("%ws%d"),
                              fAdd ? szCPInstallPrefix : szCPRemovePrefix,
                              pCP->CodePage );

                    //
                    //  Call setup to install other inf info for this
                    //  code page.
                    //
                    if (!SetupInstallFromInfSection( GetParent(hDlg),
                                                     hIntlInf,
                                                     szSection,
                                                     SPINST_ALL & ~SPINST_FILES,
                                                     NULL,
                                                     pSetupSourcePath,
                                                     0,
                                                     NULL,
                                                     NULL,
                                                     NULL,
                                                     NULL ))
                    {
                        //
                        //  Setup failed.
                        //
                        //  Already copied the code page file, so no need to
                        //  change the status of the code page info here.
                        //
                        //  This shouldn't happen - the inf file is messed up.
                        //
                        ShowMsg( hDlg,
                                 IDS_ML_INSTALL_FAILED,
                                 0,
                                 MB_OK_OOPS,
                                 pCP->pszName );
                    }

                    //
                    //  Reset the status to show the new state of this
                    //  code page.
                    //
                    pCP->wStatus &= (ML_STATIC);
                    if (fAdd)
                    {
                        pCP->wStatus |= ML_ORIG_INSTALLED;
                    }
                }

                //
                //  Clear out wStatus and go to the next code page node.
                //
                pCP->wStatus &= (ML_ORIG_INSTALLED | ML_STATIC);
                pCP = pCP->pNext;
            }

    Advanced_CodepageConverionsSetupError:
            //
            //  Close Inf stuff.
            //
            Intl_CloseInf(hIntlInf, FileQueue, QueueContext);
        }

        //
        //  Check if we need a reboot
        //
        if (RegionalChgState & AD_SystemLocale)
        {
            bReboot = TRUE;
        }
    }

    //
    //  See if there are any changes to the system locale.
    //
    if (Changes & AD_SystemLocale)
    {
        //
        //  Get the current selection.
        //
        dwLocale = ComboBox_GetCurSel(hSystemLocale);

        //
        //  Get the locale id for the current selection and save it.
        //
        NewLocale = (LCID)ComboBox_GetItemData(hSystemLocale, dwLocale);
        if (IsValidLocale(NewLocale, LCID_SUPPORTED))
        {
            SysLocaleID = NewLocale;
        }
        else
        {
            //
            //  This shouldn't happen, since the values in the combo box
            //  should already be installed via the language groups.
            //  Put up an error message just in case.
            //
            SetCursor(hcurSave);
            ShowMsg( NULL,
                     IDS_SETUP_STRING,
                     IDS_TITLE_STRING,
                     MB_OK_OOPS,
                     NULL );
            return (FALSE);
        }

        //
        //  See if the current selection is different from the original
        //  selection.
        //
        if (RegSysLocaleID != SysLocaleID)
        {
            //
            //  Call setup to install the option.
            //
            if (SetupChangeLocaleEx( hDlg,
                                     SysLocaleID,
                                     pSetupSourcePath,
                                     (g_bSetupCase)
                                       ? SP_INSTALL_FILES_QUIETLY
                                       : 0,
                                     NULL,
                                     0 ))
            {
                //
                //  If Setup fails, put up a message.
                //
                SetCursor(hcurSave);
                ShowMsg( NULL,
                         IDS_SETUP_STRING,
                         IDS_TITLE_STRING,
                         MB_OK_OOPS,
                         NULL );
                SysLocaleID = GetSystemDefaultLCID();
                return (FALSE);
            }

            //
            //  Check if we need to proceed with the Font Substitution
            //
            if (Intl_IsUIFontSubstitute() &&
                ((LANGID)LANGIDFROMLCID(SysLocaleID) == Intl_GetDotDefaultUILanguage()))
            {
                Intl_ApplyFontSubstitute(SysLocaleID);
            }

            //
            //  Reset the registry system locale value.
            //
            RegSysLocaleID = SysLocaleID;

            //
            //  Need to make sure the proper keyboard layout is installed.
            //
            Intl_InstallKeyboardLayout(hDlg, SysLocaleID, 0, FALSE, FALSE, TRUE);

            //
            //  See if we need to reboot.
            //
            if (SysLocaleID != GetSystemDefaultLCID())
            {
                bReboot = TRUE;
            }

            InvokeSysocmgr = TRUE;
        }
    }

    //
    //  If the system locale changed and we're not running
    //  in gui setup, then let's invoke sysocmgr.exe.
    //
    if (!g_bSetupCase && InvokeSysocmgr)
    {
        //
        //  Run any necessary apps (for FSVGA/FSNEC installation).
        //
        Intl_RunRegApps(c_szSysocmgr);
    }

    //
    //  Reset the property page settings.
    //
    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    Changes = AD_EverChg;

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  See if we need to display the reboot message.
    //
    if ((!g_bSetupCase) && (bReboot))
    {
        if(RegionalChgState & Process_Languages )
        {
            RegionalChgState &= ~(AD_CodePages | AD_SystemLocale);
        }
        else
        {
            if (ShowMsg( hDlg,
                         IDS_REBOOT_STRING,
                         IDS_TITLE_STRING,
                         MB_YESNO | MB_ICONQUESTION,
                         NULL ) == IDYES)
            {
                Intl_RebootTheSystem();
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= AD_EverChg)
    {
        return (TRUE);
    }

    //
    //  See if the system locale has changed.
    //
    if (Changes & AD_SystemLocale)
    {
        HWND hSystemLocale = GetDlgItem(hDlg, IDC_SYSTEM_LOCALE);
        DWORD dwLocale = ComboBox_GetCurSel(hSystemLocale);
        LCID NewLocale;

        //
        //  Get the locale id for the current selection and save it.
        //
        NewLocale = (LCID)ComboBox_GetItemData(hSystemLocale, dwLocale);
        if (IsValidLocale(NewLocale, LCID_SUPPORTED))
        {
            SysLocaleID = NewLocale;
        }
        else
        {
            //
            //  This shouldn't happen, since the values in the combo box
            //  should already be installed via the language groups.
            //  Put up an error message just in case.
            //
            ShowMsg( NULL,
                     IDS_SETUP_STRING,
                     IDS_TITLE_STRING,
                     MB_OK_OOPS,
                     NULL );
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Advanced_SetValues with the property
//  sheet handle to initialize all of the property sheet controls.  Limit
//  the length of the text in some of the ComboBoxes.
//
////////////////////////////////////////////////////////////////////////////

void Advanced_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    //
    //  The lParam holds a pointer to the property sheet page.  Save it
    //  for later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    //
    //  Set values.
    //
    if (pLanguageGroups == NULL)
    {
        Intl_LoadLanguageGroups(hDlg);
    }
    Advanced_SetValues(hDlg, TRUE);

    //
    //  If we are in setup mode, we need to disable the Default User
    //  Account UI.
    //
    if (g_bSetupCase)
    {
        HWND hUIDefUserBox = GetDlgItem(hDlg, IDC_GROUPBOX3);
        HWND hUIDefUser = GetDlgItem(hDlg, IDC_DEFAULT_USER);
    
        EnableWindow(hUIDefUserBox, FALSE);
        EnableWindow(hUIDefUser, FALSE);
        ShowWindow(hUIDefUserBox, SW_HIDE);
        ShowWindow(hUIDefUser, SW_HIDE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  AdvancedDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK AdvancedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch (message)
    {
        case ( WM_NOTIFY ) :
        {
            LPNMHDR lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Advanced)
                    {
                        Verified_Regional_Chg &= ~Process_Advanced;
                        Advanced_ClearValues(hDlg);
                        Advanced_SetValues(hDlg, FALSE);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                      DWLP_MSGRESULT,
                                      !Advanced_ValidatePPS(hDlg, lpPropSheet->lParam) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Advanced_ApplySettings(hDlg))
                    {
                        SetWindowLongPtr( hDlg,
                                          DWLP_MSGRESULT,
                                          PSNRET_NOERROR );

                        //
                        //  Zero out the AD_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                          DWLP_MSGRESULT,
                                          PSNRET_INVALID_NOCHANGEPAGE );
                    }


                    break;
                }
                case ( NM_CUSTOMDRAW ) :
                {
                    Advanced_ListViewCustomDraw(hDlg, (LPNMLVCUSTOMDRAW)lParam);
                    return (TRUE);
                }
                case ( LVN_ITEMCHANGING ) :
                {
                    Advanced_ListViewChanging(hDlg, (NM_LISTVIEW *)lParam);
                    break;
                }
                case ( LVN_ITEMCHANGED ) :
                {
                    //
                    //  Save the change to the code pages.
                    //
                    if (Advanced_ListViewChanged( hDlg,
                                                  IDC_CODEPAGES,
                                                  (NM_LISTVIEW *)lParam ))
                    {
                        //
                        //  Note that the code pages have changed and
                        //  enable the apply button.
                        //
                        lpPropSheet->lParam |= AD_CodePages;
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                        RegionalChgState |= AD_CodePages;
                    }
                    break;
                }
                case ( NM_CLICK ) :
                case ( NM_DBLCLK ) :
                {
                    Advanced_ListViewClick(hDlg, (NMHDR*)lParam);
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            Advanced_InitPropSheet(hDlg, lParam);
            break;
        }
        case ( WM_DESTROY ) :
        {
            Advanced_FreeGlobalInfo();
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aAdvancedHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aAdvancedHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_SYSTEM_LOCALE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        //
                        //  Set the AD_SystemLocale change flag.
                        //
                        lpPropSheet->lParam |= AD_SystemLocale;
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                        RegionalChgState |= AD_SystemLocale;
                    }
                    break;
                }
                case ( IDC_DEFAULT_USER ) :
                {
                    BOOL curState;

                    //
                    //  Verify the check box state.
                    //
                    if (IsDlgButtonChecked(hDlg, IDC_DEFAULT_USER))
                    {
                        ShowMsg( hDlg,
                                 IDS_DEF_USER_CONF,
                                 IDS_DEF_USER_CONF_TITLE,
                                 MB_OK_OOPS,
                                 NULL);
                                 
                        g_bDefaultUser = TRUE;
                    }
                    else
                    {
                        g_bDefaultUser = FALSE;
                    }

                    //
                    //  Set the AD_DefaultUser change flag.
                    //
                    if (g_bDefaultUser)
                    {
                        lpPropSheet->lParam |= AD_DefaultUser;
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                    else
                    {
                        lpPropSheet->lParam &= ~AD_DefaultUser;
                    }
                    break;
                }
            }

            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\curdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    curdlg.c

Abstract:

    This module implements the currency property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <tchar.h>
#include <windowsx.h>
#include "intlhlp.h"
#include "maxvals.h"


//
//  Global Variables.
//
static TCHAR sz_iCurrDigits[MAX_ICURRDIGITS+1];
static TCHAR sz_iCurrency[MAX_ICURRENCY+1];
static TCHAR sz_iNegCurr[MAX_INEGCURR+1];
static TCHAR sz_sCurrency[MAX_SCURRENCY+1];
static TCHAR sz_sMonDecimalSep[MAX_SMONDECSEP+1];
static TCHAR sz_sMonGrouping[MAX_SMONGROUPING+1];
static TCHAR sz_sMonThousandSep[MAX_SMONTHOUSEP+1];


//
//  Context Help Ids.
//
static int aCurrencyHelpIds[] =
{
    IDC_SAMPLELBL1,         IDH_INTL_CURR_POSVALUE,
    IDC_SAMPLE1,            IDH_INTL_CURR_POSVALUE,
    IDC_SAMPLELBL2,         IDH_INTL_CURR_NEGVALUE,
    IDC_SAMPLE2,            IDH_INTL_CURR_NEGVALUE,
    IDC_SAMPLELBL3,         IDH_COMM_GROUPBOX,
    IDC_POS_CURRENCY_SYM,   IDH_INTL_CURR_POSOFSYMBOL,
    IDC_CURRENCY_SYMBOL,    IDH_INTL_CURR_SYMBOL,
    IDC_NEG_NUM_FORMAT,     IDH_INTL_CURR_NEGNUMFMT,
    IDC_DECIMAL_SYMBOL,     IDH_INTL_CURR_DECSYMBOL,
    IDC_NUM_DECIMAL_DIGITS, IDH_INTL_CURR_DIGITSAFTRDEC,
    IDC_DIGIT_GROUP_SYMBOL, IDH_INTL_CURR_DIGITGRPSYMBOL,
    IDC_NUM_DIGITS_GROUP,   IDH_INTL_CURR_DIGITSINGRP,

    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  Currency_DisplaySample
//
//  Updates the currency sample.  It formats the currency based on the
//  user's current locale settings.  It displays either a positive value
//  or a negative value based on the Positive/Negative radio buttons.
//
////////////////////////////////////////////////////////////////////////////

void Currency_DisplaySample(
    HWND hDlg)
{
    TCHAR szBuf[MAX_SAMPLE_SIZE];
    int nCharCount;

    //
    //  Get the string representing the currency format for the positive sample
    //  currency and, if the the value is valid, display it.  Perform the same
    //  operations for the negative currency sample.
    //
    nCharCount = GetCurrencyFormat( UserLocaleID,
                                    0,
                                    szSample_Number,
                                    NULL,
                                    szBuf,
                                    MAX_SAMPLE_SIZE );
    if (nCharCount)
    {
        SetDlgItemText(hDlg, IDC_SAMPLE1, szBuf);
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }

    nCharCount = GetCurrencyFormat( UserLocaleID,
                                    0,
                                    szNegSample_Number,
                                    NULL,
                                    szBuf,
                                    MAX_SAMPLE_SIZE );
    if (nCharCount)
    {
        SetDlgItemText(hDlg, IDC_SAMPLE2, szBuf);
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_SaveValues
//
//  Save values in the case that we need to restore them.
//
////////////////////////////////////////////////////////////////////////////

void Currency_SaveValues()
{
    //
    //  Save values.
    //
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_ICURRDIGITS,
                        sz_iCurrDigits,
                        MAX_ICURRDIGITS + 1 ))
    {
        _tcscpy(sz_iCurrDigits, TEXT("2"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_ICURRENCY,
                        sz_iCurrency,
                        MAX_ICURRENCY + 1 ))
    {
        _tcscpy(sz_iCurrency, TEXT("0"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_INEGCURR,
                        sz_iNegCurr,
                        MAX_INEGCURR + 1 ))
    {
        _tcscpy(sz_iNegCurr, TEXT("0"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SCURRENCY,
                        sz_sCurrency,
                        MAX_SCURRENCY + 1 ))
    {
        _tcscpy(sz_sCurrency, TEXT("$"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SMONDECIMALSEP,
                        sz_sMonDecimalSep,
                        MAX_SMONDECSEP + 1 ))
    {
        _tcscpy(sz_sMonDecimalSep, TEXT("."));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SMONGROUPING,
                        sz_sMonGrouping,
                        MAX_SMONGROUPING + 1 ))
    {
        _tcscpy(sz_sMonGrouping, TEXT("3;0"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SMONTHOUSANDSEP,
                        sz_sMonThousandSep,
                        MAX_SMONTHOUSEP + 1 ))
    {
        _tcscpy(sz_sMonThousandSep, TEXT(","));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_RestoreValues
//
////////////////////////////////////////////////////////////////////////////

void Currency_RestoreValues()
{
    if (g_dwCustChange & Process_Curr)
    {
        SetLocaleInfo(UserLocaleID, LOCALE_ICURRDIGITS,     sz_iCurrDigits);
        SetLocaleInfo(UserLocaleID, LOCALE_ICURRENCY,       sz_iCurrency);
        SetLocaleInfo(UserLocaleID, LOCALE_INEGCURR,        sz_iNegCurr);
        SetLocaleInfo(UserLocaleID, LOCALE_SCURRENCY,       sz_sCurrency);
        SetLocaleInfo(UserLocaleID, LOCALE_SMONDECIMALSEP,  sz_sMonDecimalSep);
        SetLocaleInfo(UserLocaleID, LOCALE_SMONGROUPING,    sz_sMonGrouping);
        SetLocaleInfo(UserLocaleID, LOCALE_SMONTHOUSANDSEP, sz_sMonThousandSep);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_ClearValues
//
//  Reset each of the list boxes in the currency property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Currency_ClearValues(
    HWND hDlg)
{
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_CURRENCY_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_POS_CURRENCY_SYM));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NEG_NUM_FORMAT));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DECIMAL_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NUM_DECIMAL_DIGITS));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DIGIT_GROUP_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NUM_DIGITS_GROUP));
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_SetValues
//
//  Initialize all of the controls in the currency property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Currency_SetValues(
    HWND hDlg)
{
    HWND hCtrl1, hCtrl2;
    TCHAR szBuf[SIZE_128];
    int Index;
    const nMax_Array_Fill = (cInt_Str >= 10 ? 10 : cInt_Str);
    CURRENCYFMT cfmt;
    TCHAR szThousandSep[SIZE_128];
    TCHAR szEmpty[]  = TEXT("");
    TCHAR szSample[] = TEXT("123456789");

    //
    //  Initialize the dropdown box for the current locale setting for:
    //      Currency Symbol
    //      Currency Decimal Symbol
    //      Currency Grouping Symbol
    //
    DropDown_Use_Locale_Values(hDlg, LOCALE_SCURRENCY, IDC_CURRENCY_SYMBOL);
    DropDown_Use_Locale_Values(hDlg, LOCALE_SMONDECIMALSEP, IDC_DECIMAL_SYMBOL);
    DropDown_Use_Locale_Values(hDlg, LOCALE_SMONTHOUSANDSEP, IDC_DIGIT_GROUP_SYMBOL);

    //
    //  Fill in the Number of Digits after Decimal Symbol drop down list
    //  with the values of 0 through 10.  Get the user locale value and
    //  make it the current selection.  If GetLocaleInfo fails, simply
    //  select the first item in the list.
    //
    hCtrl1 = GetDlgItem(hDlg, IDC_NUM_DECIMAL_DIGITS);
    hCtrl2 = GetDlgItem(hDlg, IDC_NUM_DIGITS_GROUP);
    for (Index = 0; Index < nMax_Array_Fill; Index++)
    {
        ComboBox_InsertString(hCtrl1, -1, aInt_Str[Index]);
    }

    if (GetLocaleInfo(UserLocaleID, LOCALE_ICURRDIGITS, szBuf, SIZE_128))
    {
        ComboBox_SelectString(hCtrl1, -1, szBuf);
    }
    else
    {
        ComboBox_SetCurSel(hCtrl1, 0);
    }

    //
    //  Fill in the Number of Digits in "Thousands" Grouping's drop down
    //  list with the appropriate options.  Get the user locale value and
    //  make it the current selection.  If GetLocaleInfo fails, simply
    //  select the first item in the list.
    //
    cfmt.NumDigits = 0;                // no decimal in sample string
    cfmt.LeadingZero = 0;              // no decimal in sample string
    cfmt.lpDecimalSep = szEmpty;       // no decimal in sample string
    cfmt.NegativeOrder = 0;            // not a negative value
    cfmt.PositiveOrder = 0;            // prefix, no separation
    cfmt.lpCurrencySymbol = szEmpty;   // no currency symbol
    cfmt.lpThousandSep = szThousandSep;
    GetLocaleInfo(UserLocaleID, LOCALE_SMONTHOUSANDSEP, szThousandSep, SIZE_128);

    cfmt.Grouping = 0;
    if (GetCurrencyFormat(UserLocaleID, 0, szSample, &cfmt, szBuf, SIZE_128))
    {
        ComboBox_InsertString(hCtrl2, -1, szBuf);
    }
    cfmt.Grouping = 3;
    if (GetCurrencyFormat(UserLocaleID, 0, szSample, &cfmt, szBuf, SIZE_128))
    {
        ComboBox_InsertString(hCtrl2, -1, szBuf);
    }
    cfmt.Grouping = 32;
    if (GetCurrencyFormat(UserLocaleID, 0, szSample, &cfmt, szBuf, SIZE_128))
    {
        ComboBox_InsertString(hCtrl2, -1, szBuf);
    }

    if (GetLocaleInfo(UserLocaleID, LOCALE_SMONGROUPING, szBuf, SIZE_128) &&
        (szBuf[0]))
    {
        //
        //  Since only the values 0, 3;0, and 3;2;0 are allowed, simply
        //  ignore the ";#"s for subsequent groupings.
        //
        Index = 0;
        if (szBuf[0] == TEXT('3'))
        {
            if ((szBuf[1] == CHAR_SEMICOLON) && (szBuf[2] == TEXT('2')))
            {
                Index = 2;
            }
            else
            {
                Index = 1;
            }
        }
        else
        {
            //
            //  We used to allow the user to set #;0, where # is a value from
            //  0 - 9.  If it's 0, then fall through so that Index is 0.
            //
            if ((szBuf[0] > CHAR_ZERO) && (szBuf[0] <= CHAR_NINE) &&
                ((szBuf[1] == 0) || (lstrcmp(szBuf + 1, TEXT(";0")) == 0)))
            {
                cfmt.Grouping = szBuf[0] - CHAR_ZERO;
                if (GetCurrencyFormat(UserLocaleID, 0, szSample, &cfmt, szBuf, SIZE_128))
                {
                    Index = ComboBox_InsertString(hCtrl2, -1, szBuf);
                    if (Index >= 0)
                    {
                        ComboBox_SetItemData( hCtrl2,
                                              Index,
                                              (LPARAM)((DWORD)cfmt.Grouping) );
                    }
                    else
                    {
                        Index = 0;
                    }
                }
            }
        }
        ComboBox_SetCurSel(hCtrl2, Index);
    }
    else
    {
        ComboBox_SetCurSel(hCtrl2, 0);
    }

    //
    //  Initialize and Lock function.  If it succeeds, call enum function to
    //  enumerate all possible values for the list box via a call to EnumProc.
    //  EnumProc will call Set_List_Values for each of the string values it
    //  receives.  When the enumeration of values is complete, call
    //  Set_List_Values to clear the dialog item specific data and to clear the
    //  lock on the function.  Perform this set of operations for:
    //  Position of Currency Symbol and Negative Currency Format.
    //
    if (Set_List_Values(hDlg, IDC_POS_CURRENCY_SYM, 0))
    {
        EnumPosCurrency(EnumProcEx, UserLocaleID, 0);

        Set_List_Values(0, IDC_POS_CURRENCY_SYM, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_ICURRENCY, szBuf, SIZE_128))
        {
            ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_POS_CURRENCY_SYM),
                                Intl_StrToLong(szBuf) );
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }
    if (Set_List_Values(hDlg, IDC_NEG_NUM_FORMAT, 0))
    {
        EnumNegCurrency(EnumProcEx, UserLocaleID, 0);
        Set_List_Values(0, IDC_NEG_NUM_FORMAT, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_INEGCURR, szBuf, SIZE_128))
        {
            ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_NEG_NUM_FORMAT),
                                Intl_StrToLong(szBuf) );
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }

    //
    //  Display the current sample that represents all of the locale settings.
    //
    Currency_DisplaySample(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_ApplySettings
//
//  For every control that has changed (that affects the Locale settings),
//  call Set_Locale_Values to update the user locale information.  Notify
//  the parent of changes and reset the change flag stored in the property
//  sheet page structure appropriately.  Redisplay the currency sample
//  if bRedisplay is TRUE.
//
////////////////////////////////////////////////////////////////////////////

BOOL Currency_ApplySettings(
    HWND hDlg,
    BOOL bRedisplay)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;

    if (Changes & CC_SCurrency)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SCURRENCY,
                                IDC_CURRENCY_SYMBOL,
                                TEXT("sCurrency"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_CurrSymPos)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_ICURRENCY,
                                IDC_POS_CURRENCY_SYM,
                                TEXT("iCurrency"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_NegCurrFmt)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_INEGCURR,
                                IDC_NEG_NUM_FORMAT,
                                TEXT("iNegCurr"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_SMonDec)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SMONDECIMALSEP,
                                IDC_DECIMAL_SYMBOL,
                                0,
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_ICurrDigits)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_ICURRDIGITS,
                                IDC_NUM_DECIMAL_DIGITS,
                                TEXT("iCurrDigits"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_SMonThousand)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SMONTHOUSANDSEP,
                                IDC_DIGIT_GROUP_SYMBOL,
                                0,
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_DMonGroup)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SMONGROUPING,
                                IDC_NUM_DIGITS_GROUP,
                                0,
                                TRUE,
                                0,
                                TEXT(";0"),
                                NULL ))
        {
            return (FALSE);
        }
    }

    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    lpPropSheet->lParam = CC_EverChg;

    //
    //  Display the current sample that represents all of the locale settings.
    //
    if (bRedisplay)
    {
        Currency_ClearValues(hDlg);
        Currency_SetValues(hDlg);
    }

    //
    //  Changes made in the second level.
    //
    if (Changes)
    {
        g_dwCustChange |= Process_Curr;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Currency_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= CC_EverChg)
    {
        return (TRUE);
    }

    //
    //  If the currency symbol has changed, ensure that there are no digits
    //  contained in the new symbol.
    //
    if ((Changes & CC_SCurrency) &&
        Item_Has_Digits(hDlg, IDC_CURRENCY_SYMBOL, FALSE))
    {
        No_Numerals_Error(hDlg, IDC_CURRENCY_SYMBOL, IDS_LOCALE_CURR_SYM);
        return (FALSE);
    }

    //
    //  If the currency's decimal symbol has changed, ensure that there are
    //  no digits contained in the new symbol.
    //
    if ((Changes & CC_SMonDec) &&
        Item_Has_Digits(hDlg, IDC_DECIMAL_SYMBOL, FALSE))
    {
        No_Numerals_Error(hDlg, IDC_DECIMAL_SYMBOL, IDS_LOCALE_CDECIMAL_SYM);
        return (FALSE);
    }

    //
    //  If the currency's thousands grouping symbol has changed, ensure that
    //  there are no digits contained in the new symbol.
    //
    if ((Changes & CC_SMonThousand) &&
        Item_Has_Digits(hDlg, IDC_DIGIT_GROUP_SYMBOL, FALSE))
    {
        No_Numerals_Error(hDlg, IDC_DIGIT_GROUP_SYMBOL, IDS_LOCALE_CGROUP_SYM);
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Currency_SetValues with the property
//  sheet handle to initialize all of the property sheet controls.  Limit
//  the length of the text in some of the ComboBoxes.
//
////////////////////////////////////////////////////////////////////////////

void Currency_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    //
    //  The lParam holds a pointer to the property sheet page, save it
    //  for later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    Currency_SetValues(hDlg);

    ComboBox_LimitText(GetDlgItem(hDlg, IDC_CURRENCY_SYMBOL),    MAX_SCURRENCY);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_DECIMAL_SYMBOL),     MAX_SMONDECSEP);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_DIGIT_GROUP_SYMBOL), MAX_SMONTHOUSEP);
}


////////////////////////////////////////////////////////////////////////////
//
//  CurrencyDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK CurrencyDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch (message)
    {
        case ( WM_NOTIFY ) :
        {
            lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Curr)
                    {
                        Verified_Regional_Chg &= ~Process_Curr;
                        Currency_ClearValues(hDlg);
                        Currency_SetValues(hDlg);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                   DWLP_MSGRESULT,
                                   !Currency_ValidatePPS( hDlg,
                                                          lpPropSheet->lParam) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Currency_ApplySettings(hDlg, TRUE))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        //
                        //  Zero out the CC_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                       DWLP_MSGRESULT,
                                       PSNRET_INVALID_NOCHANGEPAGE );
                    }

                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            Currency_InitPropSheet(hDlg, lParam);
            Currency_SaveValues();

            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aCurrencyHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aCurrencyHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch ( LOWORD(wParam) )
            {
                case ( IDC_CURRENCY_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= CC_SCurrency;
                    }
                    break;
                }
                case ( IDC_POS_CURRENCY_SYM ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= CC_CurrSymPos;
                    }
                    break;
                }
                case ( IDC_NEG_NUM_FORMAT ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= CC_NegCurrFmt;
                    }
                    break;
                }
                case ( IDC_DECIMAL_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= CC_SMonDec;
                    }
                    break;
                }
                case ( IDC_NUM_DECIMAL_DIGITS ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= CC_ICurrDigits;
                    }
                    break;
                }
                case ( IDC_DIGIT_GROUP_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= CC_SMonThousand;
                    }
                    break;
                }
                case ( IDC_NUM_DIGITS_GROUP ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= CC_DMonGroup;
                    }
                    break;
                }
            }

            //
            //  Turn on ApplyNow button.
            //
            if (lpPropSheet->lParam > CC_EverChg)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            break;
        }

        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batt\util.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Battery Class Installer utility routines

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/


#include "proj.h"




#if defined(DEBUG)


DWORD   BattDebugPrintLevel = TF_ERROR | TF_WARNING;



void 
CPUBLIC
CommonDebugMsgW(
    DWORD       Flag,
    LPCSTR      Message,
    ...
    )

/*++

Routine Description:

    This is the wide char version of CommonDebugMsgA

Arguments:

    Flag                - Debug print level for message

    Message             - Format string for message

    ...                 - Arguments for the format string 

Return Value:

    

--*/
{
    WCHAR               tmpBuffer[DEBUG_PRINT_BUFFER_LEN];    // Largest path plus extra
    va_list             variableArgs;

    
    
    if (Flag & BattDebugPrintLevel)
    {
        int         wideCharCount;
        int         tmpInt;
        WCHAR       wideBuffer[MAX_BUF];

        lstrcpyW (tmpBuffer, L"BATTERY CLASS INSTALLER: ");
        wideCharCount = lstrlenW (tmpBuffer);
        va_start(variableArgs, Message);

        // (We convert the string, rather than simply input an 
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        tmpInt = MultiByteToWideChar(CP_ACP, 0, Message, lstrlenA (Message), wideBuffer, MAX_BUF);
        if (!tmpInt) {
            lstrcatW (tmpBuffer, L"Debug string too long to print\n");
        
        } else {
            wvsprintfW (&tmpBuffer[wideCharCount-sizeof(WCHAR)], wideBuffer, variableArgs);
        }

        va_end(variableArgs);
        OutputDebugStringW(tmpBuffer);
    }
}






void 
CPUBLIC
CommonDebugMsgA(
    DWORD       Flag,
    LPCSTR      Message,
    ...
    )

/*++

Routine Description:

    Debug spew

Arguments:

    Flag                - Debug print level for message

    Message             - Format string for message

    ...                 - Arguments for the format string 

Return Value:

    

--*/
{
    UCHAR               tmpBuffer[DEBUG_PRINT_BUFFER_LEN];    // Largest path plus extra
    va_list             variableArgs;

    
    if (Flag & BattDebugPrintLevel)
    {
        int         charCount;

        lstrcpyA (tmpBuffer, "BATTERY CLASS INSTALLER: ");
        charCount = lstrlenA (tmpBuffer);
        va_start(variableArgs, Message);

        wvsprintfA (&tmpBuffer[charCount-1], Message, variableArgs);
        va_end(variableArgs);
        OutputDebugStringA(tmpBuffer);
    }
}


#endif      // #if defined(DEBUG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\intl.h ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    intl.h

Abstract:

    This module contains the header information for the Regional Options
    applet.

Revision History:

--*/


#ifndef _INTL_H_
#define _INTL_H_



//
//  Include Files.
//

#include <windows.h>
#include <prsht.h>
#include <prshtp.h>
#include <shellapi.h>
#include <setupapi.h>
#include <winnls.h>
#include "intlid.h"
#include "util.h"
#include <shlwapi.h>


//
//  Enumeration
//
enum LANGCOLLECTION{
    BASIC_COLLECTION,
    COMPLEX_COLLECTION,
    CJK_COLLECTION,
};

//
//  Constant Declarations.
//

#define RMI_PRIMARY          (0x1)     // this should win in event of conflict

#define ARRAYSIZE(a)         (sizeof(a) / sizeof(a[0]))

#define US_LOCALE                (MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
#define LANG_SPANISH_TRADITIONAL (MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH))
#define LANG_SPANISH_INTL        (MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_MODERN))
#define LCID_SPANISH_TRADITIONAL (MAKELCID(LANG_SPANISH_TRADITIONAL, SORT_DEFAULT))
#define LCID_SPANISH_INTL        (MAKELCID(LANG_SPANISH_INTL, SORT_DEFAULT))

#define ML_ORIG_INSTALLED    0x0001
#define ML_PERMANENT         0x0002
#define ML_INSTALL           0x0004
#define ML_REMOVE            0x0008
#define ML_DEFAULT           0x0010
#define ML_DISABLE           0x0020

#define ML_STATIC            (ML_PERMANENT | ML_DEFAULT | ML_DISABLE)


//
//  Used in string and other array declarations.
//
#define cInt_Str             10        // length of the array of int strings
#define SIZE_64              64        // frequently used buffer size
#define SIZE_128             128       // frequently used buffer size
#define SIZE_300             300       // frequently used buffer size
#define MAX_SAMPLE_SIZE      100       // limit on Sample text for display


//
//  For the indicator on the tray.
//
#define IDM_NEWSHELL         249


//
//  Character constants.
//
#define CHAR_SML_D           TEXT('d')
#define CHAR_CAP_M           TEXT('M')
#define CHAR_SML_Y           TEXT('y')
#define CHAR_SML_G           TEXT('g')

#define CHAR_SML_H           TEXT('h')
#define CHAR_CAP_H           TEXT('H')
#define CHAR_SML_M           TEXT('m')
#define CHAR_SML_S           TEXT('s')
#define CHAR_SML_T           TEXT('t')

#define CHAR_NULL            TEXT('\0')
#define CHAR_QUOTE           TEXT('\'')
#define CHAR_SPACE           TEXT(' ')
#define CHAR_COMMA           TEXT(',')
#define CHAR_SEMICOLON       TEXT(';')
#define CHAR_COLON           TEXT(':')
#define CHAR_STAR            TEXT('*')
#define CHAR_HYPHEN          TEXT('-')
#define CHAR_DECIMAL         TEXT('.')
#define CHAR_INTL_CURRENCY   TEXT('')
#define CHAR_GRAVE           TEXT('`')

#define CHAR_ZERO            TEXT('0')
#define CHAR_NINE            TEXT('9')


//
//  Setup command line switch values.
//
#define SETUP_SWITCH_NONE    0x0000
#define SETUP_SWITCH_R       0x0001
#define SETUP_SWITCH_I       0x0002
#define SETUP_SWITCH_S       0x0004


//
//  Flags to assist in updating property sheet pages once the regional locale
//  setting has changed.  As pages are updated, their process flag value is
//  deleted from the Verified_Regional_Chg variable.
//
#define INTL_ALL_CHG         0x00ff    // change affects all pages
#define INTL_CHG             0x001f    // change affects customize pages

#define Process_Num          0x0001    // number page not yet updated
#define Process_Curr         0x0002    // currency page not yet updated
#define Process_Time         0x0004    // time page not yet updated
#define Process_Date         0x0008    // date page not yet updated
#define Process_Sorting      0x0010    // sorting page not yet updated

#define Process_Regional     0x0020    // regional options page not yet updated
#define Process_Advanced     0x0040    // advanced page not yet updated
#define Process_Languages    0x0080    // languages page not yet updated


//
//  Each of these change flags will be used to update the appropriate property
//  sheet pages change word when their associated combobox notifies the
//  property sheet of a change.  The change values are used to determine which
//  locale settings must be updated.
//

//
//  Region Change.
//
#define RC_EverChg           0x0001
#define RC_UserRegion        0x0002
#define RC_UserLocale        0x0004

//
//  Advanced Change
//
#define AD_EverChg           0x0001
#define AD_SystemLocale      0x0002
#define AD_CodePages         0x0004
#define AD_DefaultUser       0x0008

//
//  Number Change.
//
#define NC_EverChg           0x0001
#define NC_DSymbol           0x0002
#define NC_NSign             0x0004
#define NC_SList             0x0008
#define NC_SThousand         0x0010
#define NC_IDigits           0x0020
#define NC_DGroup            0x0040
#define NC_LZero             0x0080
#define NC_NegFmt            0x0100
#define NC_Measure           0x0200
#define NC_NativeDigits      0x0400
#define NC_DigitSubst        0x0800

//
//  Currency Change.
//
#define CC_EverChg           0x0001
#define CC_SCurrency         0x0002
#define CC_CurrSymPos        0x0004
#define CC_NegCurrFmt        0x0008
#define CC_SMonDec           0x0010
#define CC_ICurrDigits       0x0020
#define CC_SMonThousand      0x0040
#define CC_DMonGroup         0x0080

//
//  Time Change.
//
#define TC_EverChg           0x0001
#define TC_1159              0x0002
#define TC_2359              0x0004
#define TC_STime             0x0008
#define TC_TimeFmt           0x0010
#define TC_AllChg            0x001F
#define TC_FullTime          0x0031

//
//  Date Change.
//
#define DC_EverChg           0x0001
#define DC_ShortFmt          0x0002
#define DC_LongFmt           0x0004
#define DC_SDate             0x0008
#define DC_Calendar          0x0010
#define DC_Arabic_Calendar   0x0020
#define DC_TwoDigitYearMax   0x0040

//
//  Sorting Change.
//
#define SC_EverChg           0x0001
#define SC_Sorting           0x0002

//
//  Language Change
//
#define LG_EverChg           0x0001
#define LG_UILanguage        0x0002
#define LG_Change            0x0004
#define LG_Complex           0x0008
#define LG_CJK               0x0010


//
//  Global Variables.
//  Data that is shared betweeen the property sheets.
//

extern BOOL g_bCDROM;               // if setup from a CD-ROM

extern HANDLE g_hMutex;             // mutex handle
extern TCHAR szMutexName[];         // name of the mutex

extern HANDLE g_hEvent;             // event handle
extern TCHAR szEventName[];         // name of the event

extern BOOL  g_bAdmin_Privileges;   // Admin privileges
extern DWORD g_dwLastSorting;       // index of last sorting setting in combo box
extern DWORD g_dwCurSorting;        // index of current sorting setting in combo box
extern BOOL  g_bCustomize;          // in customize mode or second level tabs
extern DWORD g_dwCustChange;        // change made at the second level
extern BOOL  g_bDefaultUser;        // in default user settings
extern BOOL  g_bShowSortingTab;     // show the sorting tab or not
extern BOOL  g_bInstallComplex;     // Complex scripts language groups installation requested
extern BOOL  g_bInstallCJK;         // CJK language groups installation requested

extern TCHAR aInt_Str[cInt_Str][3]; // cInt_Str # of elements of int strings
extern TCHAR szSample_Number[];     // used for currency and number samples
extern TCHAR szNegSample_Number[];  // used for currency and number samples
extern TCHAR szTimeChars[];         // valid time characters
extern TCHAR szTCaseSwap[];         // invalid time chars to change case => valid
extern TCHAR szTLetters[];          // time NLS chars
extern TCHAR szSDateChars[];        // valid short date characters
extern TCHAR szSDCaseSwap[];        // invalid SDate chars to change case => valid
extern TCHAR szSDLetters[];         // short date NLS chars
extern TCHAR szLDateChars[];        // valid long date characters
extern TCHAR szLDCaseSwap[];        // invalid LDate chars to change case => valid
extern TCHAR szLDLetters[];         // long date NLS chars
extern TCHAR szStyleH[];            // date and time style H equivalent
extern TCHAR szStyleh[];            // date and time style h equivalent
extern TCHAR szStyleM[];            // date and time style M equivalent
extern TCHAR szStylem[];            // date and time style m equivalent
extern TCHAR szStyles[];            // date and time style s equivalent
extern TCHAR szStylet[];            // date and time style t equivalent
extern TCHAR szStyled[];            // date and time style d equivalent
extern TCHAR szStyley[];            // date and time style y equivalent
extern TCHAR szLocaleGetError[];    // shared locale info get error
extern TCHAR szIntl[];              // intl string

extern TCHAR szInvalidSDate[];      // invalid chars for date separator
extern TCHAR szInvalidSTime[];      // invalid chars for time separator

extern HINSTANCE hInstance;         // library instance
extern int Verified_Regional_Chg;   // used to determine when to verify
                                    //  regional changes in all prop sheet pgs
extern int RegionalChgState;        // used to determine when a page have changed
extern BOOL Styles_Localized;       // indicate whether or not style must be
                                    //  translated between NLS and local formats
extern LCID UserLocaleID;           // user locale
extern LCID SysLocaleID;            // system locale
extern LCID RegUserLocaleID;        // user locale stored in the registry
extern LCID RegSysLocaleID;         // system locale stored in the registry
extern BOOL bShowRtL;               // indicate if RTL date samples should be shown
extern BOOL bShowArabic;            // indicate if the other Arabic specific stuff should be shown
extern BOOL bHebrewUI;              // indicate if the UI language is Hebrew
extern BOOL bLPKInstalled;          // if LPK is installed
extern TCHAR szSetupSourcePath[];   // buffer to hold setup source string
extern LPTSTR pSetupSourcePath;     // pointer to setup source string buffer
extern TCHAR szSetupSourcePathWithArchitecture[]; // buffer to hold setup source string with architecture-specific extension.
extern LPTSTR pSetupSourcePathWithArchitecture;   // pointer to setup source string buffer with architecture-specific extension.


//
//  Global Variables.
//
static TCHAR szLayoutPath[]    = TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts");
static TCHAR szKbdPreloadKey[] = TEXT("Keyboard Layout\\Preload");
static TCHAR szKbdSubstKey[]   = TEXT("Keyboard Layout\\Substitutes");
static TCHAR szKbdToggleKey[]  = TEXT("Keyboard Layout\\Toggle");
static TCHAR szKbdPreloadKey_DefUser[] = TEXT(".DEFAULT\\Keyboard Layout\\Preload");
static TCHAR szKbdSubstKey_DefUser[]   = TEXT(".DEFAULT\\Keyboard Layout\\Substitutes");
static TCHAR szKbdToggleKey_DefUser[]  = TEXT(".DEFAULT\\Keyboard Layout\\Toggle");
static TCHAR szInternat[]      = TEXT("internat.exe");
static char  szInternatA[]     = "internat.exe";


extern BOOL g_bSetupCase;
extern BOOL g_bLog;
extern BOOL g_bProgressBarDisplay;
extern BOOL g_bSettingsChanged;
extern BOOL g_bUnttendMode;
extern BOOL g_bMatchUIFont;


extern const TCHAR c_szInstalledLocales[];
extern const TCHAR c_szLanguageGroups[];
extern const TCHAR c_szLIPInstalled[];
extern const TCHAR c_szMUILanguages[];
extern const TCHAR c_szFontSubstitute[];
extern const TCHAR c_szSetupKey[];
extern const TCHAR c_szCPanelIntl[];
extern const TCHAR c_szCPanelIntl_DefUser[];
extern const TCHAR c_szCtfmon[];
extern const TCHAR c_szCtfmon_DefUser[];
extern const TCHAR c_szCPanelDesktop[];
extern const TCHAR c_szCPanelDesktop_DefUser[];
extern const TCHAR c_szKbdLayouts[];
extern const TCHAR c_szKbdLayouts_DefUser[];
extern const TCHAR c_szInputMethod[];
extern const TCHAR c_szInputMethod_DefUser[];
extern const TCHAR c_szInputTips[];
extern const TCHAR c_szInputTips_DefUser[];
extern const TCHAR c_szMUIPolicyKeyPath[];
extern const TCHAR c_szMUIValue[];
extern const TCHAR c_szIntlRun[];
extern const TCHAR c_szSysocmgr[];

extern TCHAR szIntlInf[];
extern TCHAR szHelpFile[];
extern TCHAR szFontSubstitute[];
extern TCHAR szLocaleListPrefix[];
extern TCHAR szLGBasicInstall[];
extern TCHAR szLGComplexInstall[];
extern TCHAR szLGComplexRemove[];
extern TCHAR szLGExtInstall[];
extern TCHAR szLGExtRemove[];
extern TCHAR szCPInstallPrefix[];
extern TCHAR szCPRemovePrefix[];
extern TCHAR szKbdLayoutIds[];
extern TCHAR szInputLibrary[];       // Name of the library that contain the text input dlg

extern TCHAR szUIFontSubstitute[];
extern TCHAR szSetupInProgress[];
extern TCHAR szSetupUpgrade[];
extern TCHAR szMultiUILanguageId[];
extern TCHAR szMUILangPending[];
extern TCHAR szCtfmonValue[];

extern TCHAR szRegionalSettings[];
extern TCHAR szLanguageGroup[];
extern TCHAR szLanguage[];
extern TCHAR szSystemLocale[];
extern TCHAR szUserLocale[];
extern TCHAR szInputLocale[];
extern TCHAR szMUILanguage[];
extern TCHAR szUserLocale_DefUser[];
extern TCHAR szInputLocale_DefUser[];
extern TCHAR szMUILanguage_DefUSer[];

extern HINF g_hIntlInf;

extern LPLANGUAGEGROUP pLanguageGroups;
extern LPCODEPAGE pCodePages;

extern int g_NumAltSorts;
extern HANDLE hAltSorts;
extern LPDWORD pAltSorts;

extern HINSTANCE hInputDLL;
extern BOOL (*pfnInstallInputLayout)(LCID, DWORD, BOOL, HKL, BOOL, BOOL);
extern BOOL (*pfnUninstallInputLayout)(LCID, DWORD, BOOL);

//
//  Language group of UI languages.
//
extern UILANGUAGEGROUP UILangGroup;




//
//  Function Prototypes.
//

//
//  Callback functions for each of the propety sheet pages.
//
INT_PTR CALLBACK
GeneralDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
InputLocaleDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
LanguageDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
AdvancedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
NumberDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
CurrencyDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
TimeDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
DateDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
SortingDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

//
//  In regdlg.c.
//
void
Region_UpdateShortDate(VOID);

void
Region_DoUnattendModeSetup(
    LPCTSTR pUnattendFile);

//
//  In intl.c.
//
BOOL
IsRtLLocale(
    LCID iLCID);

//
//  Restore functions.
//
void
Date_RestoreValues();

void
Currency_RestoreValues();

void
Time_RestoreValues();

void
Number_RestoreValues();

void
Sorting_RestoreValues();


#endif //_INTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\datedlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    datedlg.c

Abstract:

    This module implements the date property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <windowsx.h>
#include <tchar.h>
#include <commctrl.h>
#include "intlhlp.h"
#include "maxvals.h"
#include "winnlsp.h"



//
//  Context Help Ids.
//

static int aDateHelpIds[] =
{
    IDC_GROUPBOX1,             IDH_COMM_GROUPBOX,
    IDC_GROUPBOX2,             IDH_COMM_GROUPBOX,
    IDC_GROUPBOX3,             IDH_COMM_GROUPBOX,
    IDC_SAMPLE1,               IDH_INTL_DATE_SHORTSAMPLE,
    IDC_SAMPLELBL1,            IDH_INTL_DATE_SHORTSAMPLE,
    IDC_SAMPLE1A,              IDH_INTL_DATE_SHORTSAMPLE_ARABIC,
    IDC_SAMPLELBL1A,           IDH_INTL_DATE_SHORTSAMPLE_ARABIC,
    IDC_SHORT_DATE_STYLE,      IDH_INTL_DATE_SHORTSTYLE,
    IDC_SEPARATOR,             IDH_INTL_DATE_SEPARATOR,
    IDC_SAMPLE2,               IDH_INTL_DATE_LONGSAMPLE,
    IDC_SAMPLELBL2,            IDH_INTL_DATE_LONGSAMPLE,
    IDC_SAMPLE2A,              IDH_INTL_DATE_LONGSAMPLE_ARABIC,
    IDC_SAMPLELBL2A,           IDH_INTL_DATE_LONGSAMPLE_ARABIC,
    IDC_LONG_DATE_STYLE,       IDH_INTL_DATE_LONGSTYLE,
    IDC_CALENDAR_TYPE_TEXT,    IDH_INTL_DATE_CALENDARTYPE,
    IDC_CALENDAR_TYPE,         IDH_INTL_DATE_CALENDARTYPE,
    IDC_TWO_DIGIT_YEAR_LOW,    IDH_INTL_DATE_TWO_DIGIT_YEAR,
    IDC_TWO_DIGIT_YEAR_HIGH,   IDH_INTL_DATE_TWO_DIGIT_YEAR,
    IDC_TWO_DIGIT_YEAR_ARROW,  IDH_INTL_DATE_TWO_DIGIT_YEAR,
    IDC_ADD_HIJRI_DATE,        IDH_INTL_DATE_ADD_HIJRI_DATE,
    IDC_ADD_HIJRI_DATE_TEXT,   IDH_INTL_DATE_ADD_HIJRI_DATE,

    0, 0
};



//
//  Global Variables.
//

TCHAR szNLS_LongDate[SIZE_128];
TCHAR szNLS_ShortDate[SIZE_128];

static TCHAR sz_iCalendarType[MAX_ICALTYPE + 1];
static TCHAR sz_sDate[MAX_SDATE + 1];
static TCHAR sz_sLongDate[MAX_SLONGDATE + 1];
static TCHAR sz_sShortDate[MAX_FORMAT + 1];


static const TCHAR c_szInternational[] = TEXT("Control Panel\\International");
static const TCHAR c_szAddHijriDate[]  = TEXT("AddHijriDate");
static const TCHAR c_szAddHijriDateTemp[] = TEXT("AddHijriDateTemp");
static const PTSTR c_szAddHijriDateValues[] =
{
  TEXT("AddHijriDate-2"),
  TEXT("AddHijriDate"),
  TEXT(""),
  TEXT("AddHijriDate+1"),
  TEXT("AddHijriDate+2")
};

static const TCHAR c_szTwoDigitYearKey[] = TEXT("Software\\Policies\\Microsoft\\Control Panel\\International\\Calendars\\TwoDigitYearMax");



//
//  Function Prototypes.
//

void Date_InitializeHijriDateComboBox(
    HWND hDlg);





////////////////////////////////////////////////////////////////////////////
//
//  Date_EnumerateDates
//
//  Enumerates the appropriate dates for the chosen calendar.
//
////////////////////////////////////////////////////////////////////////////

void Date_EnumerateDates(
    HWND hDlg,
    DWORD dwDateFlag)
{
    DWORD dwLocaleFlag;
    int nItemId;
    DWORD dwIndex;
    DWORD dwCalNum = 0;
    TCHAR szBuf[SIZE_128];
    HWND hCtrlDate;
    HWND hCtrlCal = GetDlgItem(hDlg, IDC_CALENDAR_TYPE);


    //
    //  Initialize variables according to the dwDateFlag parameter.
    //
    if (dwDateFlag == CAL_SSHORTDATE)
    {
        dwLocaleFlag = LOCALE_SSHORTDATE;
        nItemId = IDC_SHORT_DATE_STYLE;
    }
    else           // CAL_SLONGDATE
    {
        dwLocaleFlag = LOCALE_SLONGDATE;
        nItemId = IDC_LONG_DATE_STYLE;
    }
    hCtrlDate = GetDlgItem(hDlg, nItemId);

    //
    //  Initialize to reset the contents for the appropriate combo box.
    //
    if (!Set_List_Values(hDlg, nItemId, 0))
    {
        return;
    }

    //
    //  Reset the contents of the combo box.
    //
    ComboBox_ResetContent(hCtrlDate);

    //
    //  Get the currently selected calendar id.
    //
    dwIndex = ComboBox_GetCurSel(hCtrlCal);
    if (dwIndex != CB_ERR)
    {
        dwCalNum = (DWORD)ComboBox_GetItemData(hCtrlCal, dwIndex);
    }

    //
    //  Enumerate the dates for the currently selected calendar.
    //
    EnumCalendarInfo(EnumProc, UserLocaleID, dwCalNum, dwDateFlag);
    dwIndex = ComboBox_GetCount(hCtrlCal);
    if ((dwIndex == 0) || (dwIndex == CB_ERR))
    {
        EnumCalendarInfo(EnumProc, UserLocaleID, CAL_GREGORIAN, dwDateFlag);
    }

    //
    //  Add (if necesary) and select the current user setting in the
    //  combo box.
    //
    dwIndex = 0;
    if (GetLocaleInfo(UserLocaleID, dwLocaleFlag, szBuf, SIZE_128))
    {
        if ((dwIndex = ComboBox_FindStringExact(hCtrlDate, -1, szBuf)) == CB_ERR)
        {
            //
            //  Need to add this entry to the combo box.
            //
            Set_List_Values(0, 0, szBuf);
            if ((dwIndex = ComboBox_FindStringExact(hCtrlDate, -1, szBuf)) == CB_ERR)
            {
                dwIndex = 0;
            }
        }
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }
    Set_List_Values(0, nItemId, 0);

    Localize_Combobox_Styles(hDlg, nItemId, dwLocaleFlag);
    ComboBox_SetCurSel(hCtrlDate, dwIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_GetTwoDigitYearRangeFromPolicy
//
//  Read the two digit year from the Policy registry.
//
////////////////////////////////////////////////////////////////////////////

BOOL Date_GetTwoDigitYearRangeFromPolicy(
    CALID CalId)
{
    HKEY hKey;
    BYTE buf[MAX_PATH];
    TCHAR szCalId[MAX_PATH];
    DWORD dwResultLen = sizeof(buf), dwType;
    BOOL bRet = FALSE;


    //
    //  Convert CalendarId to a string.
    //
    wsprintf(szCalId, TEXT("%d"), CalId);

    if (RegOpenKey( HKEY_CURRENT_USER,
                    c_szTwoDigitYearKey,
                    &hKey ) == ERROR_SUCCESS)
    {
        if ((RegQueryValueEx( hKey,
                              szCalId,
                              NULL,
                              &dwType,
                              &buf[0],
                              &dwResultLen ) == ERROR_SUCCESS) &&
            (dwType == REG_SZ) &&
            (dwResultLen > 2))
        {
            bRet = TRUE;
        }

        RegCloseKey(hKey);
    }

    //
    //  Return the result.
    //
    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_GetTwoDigitYearRange
//
//  Fills in the two digit year range controls.
//
////////////////////////////////////////////////////////////////////////////

void Date_GetTwoDigitYearRange(
    HWND hDlg,
    CALID CalId)
{
    HWND hwndYearHigh = GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH);
    HWND hwndScroll = GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_ARROW);
    DWORD YearHigh, YearHighDefault;

    //
    //  Enable the high range control.
    //
    EnableWindow(hwndYearHigh, TRUE);
    EnableWindow(hwndScroll, TRUE);

    //
    //  Get the default two digit year upper boundary.
    //
    if (!GetCalendarInfo( LOCALE_USER_DEFAULT,
                          CalId,
                          CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER |
                            CAL_NOUSEROVERRIDE,
                          NULL,
                          0,
                          &YearHighDefault ))
    {
        YearHighDefault = 0;
    }

    //
    //  Disable the two digit year upper boundary control if it is
    //  enforced by a policy or if the default value is 99 or less.
    //
    if ((Date_GetTwoDigitYearRangeFromPolicy(CalId)) ||
        (YearHighDefault <= 99))
    {
        //
        //  Disable the two digit year max controls.
        //
        EnableWindow(hwndScroll, FALSE);
        EnableWindow(hwndYearHigh, FALSE);
    }

    //
    //  Get the two digit year upper boundary.  If the default is less
    //  than or equal to 99, then use the default value and ignore the
    //  registry.  This is done for calendars like the Japanese Era
    //  calendar where it doesn't make sense to have a sliding window.
    //
    if (YearHighDefault <= 99)
    {
        YearHigh = YearHighDefault;
    }
    else if (!GetCalendarInfo( LOCALE_USER_DEFAULT,
                               CalId,
                               CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                               NULL,
                               0,
                               &YearHigh ) ||
             (YearHigh < 99) || (YearHigh > 9999))
    {
        YearHigh = (YearHighDefault >= 99) ? YearHighDefault : 2029;
    }

    //
    //  Set the range on the controls.
    //
    SendMessage(hwndScroll, UDM_SETRANGE, 0, MAKELPARAM(9999, 99));
    SendMessage(hwndScroll, UDM_SETBUDDY, (WPARAM)hwndYearHigh, 0L);

    //
    //  Set the values of the controls.
    //
    SetDlgItemInt(hDlg, IDC_TWO_DIGIT_YEAR_LOW, (UINT)(YearHigh - 99), FALSE);
    SendMessage(hwndScroll, UDM_SETPOS, 0, MAKELONG((short)YearHigh, 0));
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_SetTwoDigitYearMax
//
//  Sets the two digit year max value in the registry.
//
////////////////////////////////////////////////////////////////////////////

BOOL Date_SetTwoDigitYearMax(
    HWND hDlg,
    CALID CalId)
{
    TCHAR szYear[SIZE_64];

    //
    //  Get the max year.
    //
    szYear[0] = 0;
    if (GetWindowText( GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH),
                       szYear,
                       SIZE_64 ) != 0)
    {
        //
        //  Set the two digit year upper boundary.
        //
        return (SetCalendarInfo( LOCALE_USER_DEFAULT,
                                 CalId,
                                 CAL_ITWODIGITYEARMAX,
                                 szYear ));
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_ChangeYear
//
//  Changes the lower bound based on the upper bound value.
//
////////////////////////////////////////////////////////////////////////////

void Date_ChangeYear(
    HWND hDlg)
{
    DWORD YearHigh;
    BOOL bSuccess;

    //
    //  Get the two digit year upper boundary.
    //
    YearHigh = GetDlgItemInt(hDlg, IDC_TWO_DIGIT_YEAR_HIGH, &bSuccess, FALSE);

    if ((!bSuccess) || (YearHigh < 99) || (YearHigh > 9999))
    {
        //
        //  Invalid value, so set the lower control to 0.
        //
        SetDlgItemInt(hDlg, IDC_TWO_DIGIT_YEAR_LOW, 0, FALSE);
    }
    else
    {
        //
        //  Set the value of the lower control.
        //
        SetDlgItemInt(hDlg, IDC_TWO_DIGIT_YEAR_LOW, (UINT)(YearHigh - 99), FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_DisplaySample
//
//  Updates the date samples.  It formats the date based on the user's
//  current locale settings.
//
////////////////////////////////////////////////////////////////////////////

void Date_DisplaySample(
    HWND hDlg)
{
    TCHAR szBuf[MAX_SAMPLE_SIZE];
    BOOL bNoError = TRUE;

    if (!bShowArabic) {
        // If user locale is not Arabic, make sure that the control for date samples are:
        //  * LTR reading orders for non-Hebrew locales
        //  * RTL reading orders for Hebrew locales.
        SetControlReadingOrder(bHebrewUI, GetDlgItem(hDlg, IDC_SAMPLE1));
        SetControlReadingOrder(bHebrewUI, GetDlgItem(hDlg, IDC_SAMPLE2));
    }

    // In Hebrew locale, we want to format the short date for left-to-right reading order.
    // If we make it right-to-left reading order, the Gregorian short date will display
    // in a complete different display order.  
    // The left-to-right reading order won't affect the Hebrew short date display.
    if (GetDateFormat( UserLocaleID,
                       (bHebrewUI ? DATE_LTRREADING :
                       (bShowRtL ? DATE_LTRREADING : 0)) | DATE_SHORTDATE,
                       NULL,
                       NULL,
                       szBuf,
                       MAX_SAMPLE_SIZE ))
    {
        SetDlgItemText(hDlg, IDC_SAMPLE1, szBuf);
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        bNoError = FALSE;
    }

    //
    //  Show or hide the Arabic info based on the current user locale id.
    //
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLELBL1A), bShowArabic ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLE1A), bShowArabic ? SW_SHOW : SW_HIDE);
    if (bShowArabic)
    {
        if (GetDateFormat( UserLocaleID,
                           DATE_RTLREADING | DATE_SHORTDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_SAMPLE1A, szBuf);
            SetDlgItemRTL(hDlg, IDC_SAMPLE1A);
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
            bNoError = FALSE;
        }
    }

    if (GetDateFormat( UserLocaleID,
                       (bHebrewUI ? DATE_RTLREADING :
                         (bShowRtL ? DATE_LTRREADING : 0)) | DATE_LONGDATE,
                       NULL,
                       NULL,
                       szBuf,
                       MAX_SAMPLE_SIZE ))
    {
        SetDlgItemText(hDlg, IDC_SAMPLE2, szBuf);
    }
    else if (bNoError)
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }

    //
    //  Show or hide the Right to left info based on the current user locale id.
    //
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLELBL2A), bShowArabic ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLE2A), bShowArabic ? SW_SHOW : SW_HIDE);
    if (bShowArabic)
    {
        if (GetDateFormat( UserLocaleID,
                           DATE_RTLREADING | DATE_LONGDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_SAMPLE2A, szBuf);
            SetDlgItemRTL(hDlg, IDC_SAMPLE2A);
        }
        else if (bNoError)
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_ClearValues
//
//  Reset each of the list boxes in the date property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Date_ClearValues(
    HWND hDlg)
{
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SHORT_DATE_STYLE));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_LONG_DATE_STYLE));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SEPARATOR));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_CALENDAR_TYPE));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_LOW));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH));
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_EnableHijriComboBox
//
//  Enables/Disables Show/Hides the Hijri date advance combo where necessary
//
////////////////////////////////////////////////////////////////////////////

void Date_EnableHijriComboBox(
    HWND hDlg,
    BOOL Status)
{
    HWND hAddHijriDateCB = GetDlgItem(hDlg, IDC_ADD_HIJRI_DATE);
    HWND hAddHijriDateText = GetDlgItem(hDlg, IDC_ADD_HIJRI_DATE_TEXT);
    INT iCount;

    //
    //  If the combo box is empty, then disable it.
    //
    iCount = (INT)SendMessage(hAddHijriDateCB, CB_GETCOUNT, 0L, 0L);
    if ((iCount == CB_ERR) || (iCount <= 0L))
    {
        Status = FALSE;
    }

    EnableWindow(hAddHijriDateCB, Status);
    ShowWindow(hAddHijriDateCB, Status ? SW_SHOW : SW_HIDE );

    EnableWindow(hAddHijriDateText, Status);
    ShowWindow(hAddHijriDateText, Status ? SW_SHOW : SW_HIDE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_SaveValues
//
//  Save values in the case that we need to restore them.
//
////////////////////////////////////////////////////////////////////////////

void Date_SaveValues()
{
    //
    //  Save registry values.
    //
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_ICALENDARTYPE,
                        sz_iCalendarType,
                        MAX_ICALTYPE + 1 ))
    {
        _tcscpy(sz_iCalendarType, TEXT("1"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SDATE,
                        sz_sDate,
                        MAX_SDATE + 1 ))
    {
        _tcscpy(sz_sDate, TEXT("/"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SLONGDATE,
                        sz_sLongDate,
                        MAX_SLONGDATE + 1 ))
    {
        _tcscpy(sz_sLongDate, TEXT("dddd, MMMM dd, yyyy"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SSHORTDATE,
                        sz_sShortDate,
                        MAX_SSHORTDATE + 1 ))
    {
        _tcscpy(sz_sShortDate, TEXT("M/d/yyyy"));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_RestoreValues
//
////////////////////////////////////////////////////////////////////////////

void Date_RestoreValues()
{
    if (g_dwCustChange & Process_Date)
    {
        SetLocaleInfo(UserLocaleID, LOCALE_ICALENDARTYPE, sz_iCalendarType);
        SetLocaleInfo(UserLocaleID, LOCALE_SDATE,         sz_sDate);
        SetLocaleInfo(UserLocaleID, LOCALE_SLONGDATE,     sz_sLongDate);
        SetLocaleInfo(UserLocaleID, LOCALE_SSHORTDATE,    sz_sShortDate);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_SetValues
//
//  Initialize all of the controls in the date property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Date_SetValues(
    HWND hDlg)
{
    TCHAR szBuf[SIZE_128];
    int i, nItem;
    HWND hCtrl;
    LONG CalId;

    //
    //  Initialize the dropdown box for the current locale setting for the
    //  date separator.
    //
    DropDown_Use_Locale_Values(hDlg, LOCALE_SDATE, IDC_SEPARATOR);

    //
    //  Initialize and Lock function.  If it succeeds, call enum function to
    //  enumerate all possible values for the list box via a call to EnumProc.
    //  EnumProc will call Set_List_Values for each of the string values it
    //  receives.  When the enumeration of values is complete, call
    //  Set_List_Values to clear the dialog item specific data and to clear
    //  the lock on the function.  Perform this set of operations for:
    //  Calendar Type, Short Date Sytle, and Long Date Style.
    //
    if (Set_List_Values(hDlg, IDC_CALENDAR_TYPE, 0))
    {
        hCtrl = GetDlgItem(hDlg, IDC_CALENDAR_TYPE);
        EnumCalendarInfo(EnumProc, UserLocaleID, ENUM_ALL_CALENDARS, CAL_SCALNAME);
        Set_List_Values(0, IDC_CALENDAR_TYPE, 0);
        EnumCalendarInfo(EnumProc, UserLocaleID, ENUM_ALL_CALENDARS, CAL_ICALINTVALUE);
        Set_List_Values(0, IDC_CALENDAR_TYPE, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_ICALENDARTYPE, szBuf, SIZE_128))
        {
            TCHAR szBufTmp[SIZE_128] = {0};
            int iTmp = 0;
            LONG CalIdTmp;

            if( GetLocaleInfo( UserLocaleID,
                               LOCALE_ICALENDARTYPE | LOCALE_NOUSEROVERRIDE,
                               szBufTmp,
                               SIZE_128))
            {
                //
                //  Convert the id to a number.
                //
                CalId = Intl_StrToLong(szBuf);
                CalIdTmp = Intl_StrToLong(szBufTmp);

                //
                //  Search for calendars
                //
                nItem = ComboBox_GetCount(hCtrl);
                for (i = 0; i < nItem; i++)
                {
                    if (ComboBox_GetItemData(hCtrl, i) == CalId)
                    {
                        break;
                    }

                    if (ComboBox_GetItemData(hCtrl, i) == CalIdTmp)
                    {
                        iTmp = i;
                    }
                }

                //
                //  Look if we find something.
                //
                if (i < nItem)
                {
                    ComboBox_SetCurSel(hCtrl, i);
                }
                else
                {
                    CalId = CalIdTmp;
                    ComboBox_SetCurSel(hCtrl, iTmp);  // Zero or something else.
                }

                //
                //  Enable/disable the Add Hijri date check box.
                //
                Date_InitializeHijriDateComboBox(hDlg);
                Date_EnableHijriComboBox(hDlg, (CalId == CAL_HIJRI));

                //
                //  Set the two digit year range.
                //
                Date_GetTwoDigitYearRange(hDlg, (CALID)CalId);

                //
                //  Subtract 1 from calendar value because calendars are one
                //  based, not zero based like all other locale values.
                //
            }
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }

        //
        //  If more than one selection, enable dropdown box.
        //  Otherwise, disable it.
        //
        if (ComboBox_GetCount(hCtrl) > 1)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE_TEXT), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE), TRUE);
            ShowWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE_TEXT), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE), SW_SHOW);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE_TEXT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE), FALSE);
            ShowWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE), SW_HIDE);
        }
    }
    Date_EnumerateDates(hDlg, CAL_SSHORTDATE);
    Date_EnumerateDates(hDlg, CAL_SLONGDATE);

    //
    //  Display the current sample that represents all of the locale settings.
    //
    Date_DisplaySample(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_SetHijriDate
//
//  Saves the Hijri date advance amount to the registry.
//
////////////////////////////////////////////////////////////////////////////

void Date_SetHijriDate(
    HWND hHijriComboBox)
{
    HKEY hKey;
    INT iIndex;

    //
    //  Get the string index to set.
    //
    iIndex = (INT)SendMessage(hHijriComboBox, CB_GETCURSEL, 0L, 0L);

    if (iIndex == CB_ERR)
    {
        return;
    }

    iIndex = (INT)SendMessage(hHijriComboBox, CB_GETITEMDATA, (WPARAM)iIndex, 0L);
    if (iIndex != CB_ERR)
    {
        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                          c_szInternational,
                          0,
                          KEY_READ | KEY_WRITE,
                          &hKey ) == ERROR_SUCCESS)
        {
            RegSetValueEx( hKey,
                           c_szAddHijriDate,
                           0,
                           REG_SZ,
                           (LPBYTE)c_szAddHijriDateValues[iIndex],
                           (lstrlen(c_szAddHijriDateValues[iIndex]) + 1) * sizeof(TCHAR) );

            RegCloseKey(hKey);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_ApplySettings
//
//  For every control that has changed (that affects the Locale settings),
//  call Set_Locale_Values to update the user locale information.  Notify
//  the parent of changes and reset the change flag stored in the property
//  sheet page structure appropriately.  Redisplay the date sample if
//  bRedisplay is TRUE.
//
////////////////////////////////////////////////////////////////////////////

BOOL Date_ApplySettings(
    HWND hDlg,
    BOOL bRedisplay)
{
    TCHAR szBuf[SIZE_128];
    CALID CalId = 0;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;
    HWND hwndYearHigh = GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH);

    if (Changes & DC_ShortFmt)
    {
        //
        //  szNLS_ShortDate is set in Date_ValidatePPS.
        //
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SSHORTDATE,
                                IDC_SHORT_DATE_STYLE,
                                TEXT("sShortDate"),
                                FALSE,
                                0,
                                0,
                                szNLS_ShortDate ))
        {
            return (FALSE);
        }

        //
        //  If the date separator field has also been changed by the user,
        //  then don't update now.  It will be updated below.
        //
        if (!(Changes & DC_SDate))
        {
            //
            //  Since the short date style changed, reset date separator
            //  list box.
            //
            ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SEPARATOR));
            DropDown_Use_Locale_Values(hDlg, LOCALE_SDATE, IDC_SEPARATOR);
            if (!Set_Locale_Values( hDlg,
                                    LOCALE_SDATE,
                                    IDC_SEPARATOR,
                                    TEXT("sDate"),
                                    FALSE,
                                    0,
                                    0,
                                    NULL ))
            {
                return (FALSE);
            }
        }
    }
    if (Changes & DC_LongFmt)
    {
        //
        //  szNLS_LongDate is set in Date_ValidatePPS.
        //
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SLONGDATE,
                                IDC_LONG_DATE_STYLE,
                                TEXT("sLongDate"),
                                FALSE,
                                0,
                                0,
                                szNLS_LongDate ))
        {
            return (FALSE);
        }
    }
    if (Changes & DC_SDate)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SDATE,
                                IDC_SEPARATOR,
                                TEXT("sDate"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }

        //
        //  Since the date separator changed, reset the short date style
        //  list box.
        //
        Date_EnumerateDates(hDlg, CAL_SSHORTDATE);
    }
    if (Changes & DC_Calendar)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_ICALENDARTYPE,
                                IDC_CALENDAR_TYPE,
                                0,
                                TRUE,
                                1,
                                0,
                                NULL ))
        {
            return (FALSE);
        }

        if (GetLocaleInfo(UserLocaleID, LOCALE_ICALENDARTYPE, szBuf, SIZE_128))
        {
            CalId = Intl_StrToLong(szBuf);
            Date_InitializeHijriDateComboBox(hDlg);
            Date_EnableHijriComboBox(hDlg, (CalId == CAL_HIJRI));
        }
    }

    if (Changes & DC_Arabic_Calendar)
    {
        Date_SetHijriDate( GetDlgItem(hDlg, IDC_ADD_HIJRI_DATE) );
    }

    if (Changes & DC_TwoDigitYearMax)
    {
        if (CalId == 0)
        {
            HWND hCtrl = GetDlgItem(hDlg, IDC_CALENDAR_TYPE);
            int index;

            if ((index = ComboBox_GetCurSel(hCtrl)) == CB_ERR)
            {
                if (GetLocaleInfo( UserLocaleID,
                                   LOCALE_ICALENDARTYPE | LOCALE_NOUSEROVERRIDE,
                                   szBuf,
                                   SIZE_128))
                {
                    CalId = Intl_StrToLong(szBuf);
                }
                else
                {
                    return (FALSE);
                }
            }
            else
            {
                CalId = (CALID)ComboBox_GetItemData(hCtrl, index);
            }
        }
        if (!Date_SetTwoDigitYearMax(hDlg, CalId))
        {
            //
            //  Make sure that the API failed due to a reason other than
            //  the upper year two digit max is <= 99. This can easily
            //  be checked by seeing if the control is enabled or not.
            //
            if (IsWindowEnabled(hwndYearHigh))
            {
                return (FALSE);
            }
        }
    }

    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    lpPropSheet->lParam = DC_EverChg;

    //
    //  Display the current sample that represents all of the locale settings.
    //
    if (bRedisplay)
    {
        Date_DisplaySample(hDlg);
    }

    //
    //  Changes made in the second level.
    //
    if (Changes)
    {
        g_dwCustChange |= Process_Date;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Date_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= DC_EverChg)
    {
        return (TRUE);
    }

    //
    //  If the date separator has changed, ensure that there are no digits
    //  and no invalid characters contained in the new separator.
    //
    if (Changes & DC_SDate &&
        Item_Has_Digits_Or_Invalid_Chars( hDlg,
                                          IDC_SEPARATOR,
                                          FALSE,
                                          szInvalidSDate ))
    {
        No_Numerals_Error(hDlg, IDC_SEPARATOR, IDS_LOCALE_DATE_SEP);
        return (FALSE);
    }

    //
    //  If the short date style has changed, ensure that there are only
    //  characters in this set " dHhMmsty,-./:;\", the separator string,
    //  and text enclosed in single quotes.
    //
    if (Changes & DC_ShortFmt)
    {
        if (NLSize_Style( hDlg,
                          IDC_SHORT_DATE_STYLE,
                          szNLS_ShortDate,
                          LOCALE_SSHORTDATE ) ||
            Item_Check_Invalid_Chars( hDlg,
                                      szNLS_ShortDate,
                                      szSDateChars,
                                      IDC_SEPARATOR,
                                      FALSE,
                                      szSDCaseSwap,
                                      IDC_SHORT_DATE_STYLE ))
        {
            Invalid_Chars_Error(hDlg, IDC_SHORT_DATE_STYLE, IDS_LOCALE_SDATE);
            return (FALSE);
        }
    }

    //
    //  If the long date style has changed, ensure that there are only
    //  characters in this set " dgHhMmsty,-./:;\", the separator string,
    //  and text enclosed in single quotes.
    //
    if (Changes & DC_LongFmt)
    {
        if (NLSize_Style( hDlg,
                          IDC_LONG_DATE_STYLE,
                          szNLS_LongDate,
                          LOCALE_SLONGDATE ) ||
            Item_Check_Invalid_Chars( hDlg,
                                      szNLS_LongDate,
                                      szLDateChars,
                                      IDC_SEPARATOR,
                                      FALSE,
                                      szLDCaseSwap,
                                      IDC_LONG_DATE_STYLE ))
        {
            Invalid_Chars_Error(hDlg, IDC_LONG_DATE_STYLE, IDS_LOCALE_LDATE);
            return (FALSE);
        }
    }

    //
    //  If the two digit year has changed, make sure the value is between
    //  99 and 9999 (if the window is still enabled).
    //
    if (Changes & DC_TwoDigitYearMax)
    {
        DWORD YearHigh;
        BOOL bSuccess;

        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH)))
        {
            YearHigh = GetDlgItemInt( hDlg,
                                      IDC_TWO_DIGIT_YEAR_HIGH,
                                      &bSuccess,
                                      FALSE );

            if ((!bSuccess) || (YearHigh < 99) || (YearHigh > 9999))
            {
                TCHAR szBuf[SIZE_128];

                LoadString(hInstance, IDS_LOCALE_YEAR_ERROR, szBuf, SIZE_128);
                MessageBox(hDlg, szBuf, NULL, MB_OK | MB_ICONINFORMATION);
                SetFocus(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH));
                return (FALSE);
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_InitializeHijriDateComboBox
//
//  Initialize the HijriDate advance combo box.
//
////////////////////////////////////////////////////////////////////////////

void Date_InitializeHijriDateComboBox(
    HWND hDlg)
{
    HWND hHijriDate = GetDlgItem(hDlg, IDC_ADD_HIJRI_DATE);
    HKEY hKey;
    TCHAR szBuf[128];
    TCHAR szCurrentValue[16];   // Max size ever needed should be 15 characters including the NULL
    INT iIndex;
    DWORD dwCtr, dwNumEntries, DataLen;


    //
    //  Clear contents.
    //
    SendMessage( hHijriDate,
                 CB_RESETCONTENT,
                 0L,
                 0L);

    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      c_szInternational,
                      0,
                      KEY_READ | KEY_WRITE,
                      &hKey ) == ERROR_SUCCESS)
    {
        //
        //  Read the default/current value.
        //

        // Use the byte count, the API expects that even for Unicode strings
        DataLen = sizeof(szCurrentValue);

        if (RegQueryValueEx( hKey,
                             c_szAddHijriDate,
                             NULL,
                             NULL,
                             (LPBYTE)szCurrentValue,
                             &DataLen ) != ERROR_SUCCESS)
        {
            szCurrentValue[0] = TEXT('\0');
        }

        dwNumEntries = (ARRAYSIZE(c_szAddHijriDateValues));
        for (dwCtr = 0; dwCtr < dwNumEntries; dwCtr++)
        {
            //
            //  Fill the combo box.
            //
            if (RegSetValueEx( hKey,
                               c_szAddHijriDateTemp,
                               0,
                               REG_SZ,
                               (LPBYTE)c_szAddHijriDateValues[dwCtr],
                               (lstrlen(c_szAddHijriDateValues[dwCtr]) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
            {
                //
                //  0x80000000 is a private flag to make GetDateFormat read
                //  the HijriDate setting from the temp reg value.
                //
                if (GetDateFormat( MAKELCID(MAKELANGID(LANG_ARABIC,
                                                       SUBLANG_DEFAULT),
                                            SORT_DEFAULT),
                                   DATE_ADDHIJRIDATETEMP | DATE_LONGDATE |
                                     DATE_RTLREADING,
                                   NULL,
                                   NULL,
                                   szBuf,
                                   ARRAYSIZE(szBuf)))
                {
                    iIndex = (INT)SendMessage(hHijriDate, CB_ADDSTRING, 0L, (LPARAM)szBuf);
                    if (iIndex != CB_ERR)
                    {
                        SendMessage(hHijriDate, CB_SETITEMDATA, iIndex, (LPARAM)dwCtr);

                        if (!lstrcmp(szCurrentValue, c_szAddHijriDateValues[dwCtr]))
                        {
                            SendMessage(hHijriDate, CB_SETCURSEL, iIndex, 0L);
                        }
                    }
                }
            }
        }

        //
        //  Delete the value after we're done.
        //
        RegDeleteValue(hKey, c_szAddHijriDateTemp);

        RegCloseKey(hKey);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Date_SetValues with the property
//  sheet handle and the value TRUE (to indicate that the Positive Value
//  button should also be initialized) to initialize all of the property
//  sheet controls.
//
////////////////////////////////////////////////////////////////////////////

void Date_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    //
    //  The lParam holds a pointer to the property sheet page, save it
    //  for later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    //
    //  Set the values.
    //
    Date_SetValues(hDlg);
    szNLS_ShortDate[0] = szNLS_LongDate[0] = 0;

    ComboBox_LimitText(GetDlgItem(hDlg, IDC_SEPARATOR),        MAX_SDATE);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_SHORT_DATE_STYLE), MAX_FORMAT);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_LONG_DATE_STYLE),  MAX_FORMAT);

    Edit_LimitText(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_LOW),   MAX_YEAR);
    Edit_LimitText(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH),  MAX_YEAR);

    //
    //  Set the Add Hijri Date combo box appropriately.
    //
    if (bShowArabic)
    {
        Date_InitializeHijriDateComboBox(hDlg);
    }

    //
    //  Make sure the Apply button is off.
    //
    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    if (lParam)
    {
        ((LPPROPSHEETPAGE)lParam)->lParam = DC_EverChg;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DateDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DateDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    DWORD dwIndex;
    HWND hCtrl;

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            Date_InitPropSheet(hDlg, lParam);
            Date_SaveValues();
            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aDateHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aDateHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (!lpPropSheet)
            {
                break;
            }

            switch ( LOWORD(wParam) )
            {
                case ( IDC_SHORT_DATE_STYLE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= DC_ShortFmt;
                    }
                    break;
                }
                case ( IDC_LONG_DATE_STYLE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= DC_LongFmt;
                    }
                    break;
                }
                case ( IDC_SEPARATOR ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= DC_SDate;
                    }
                    break;
                }
                case ( IDC_CALENDAR_TYPE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= DC_Calendar;

                        hCtrl = GetDlgItem(hDlg, IDC_CALENDAR_TYPE);
                        dwIndex = ComboBox_GetCurSel(hCtrl);
                        if (dwIndex != CB_ERR)
                        {
                            dwIndex = (DWORD)ComboBox_GetItemData(hCtrl, dwIndex);
                            Date_InitializeHijriDateComboBox(hDlg);
                            Date_EnableHijriComboBox(hDlg, (dwIndex == CAL_HIJRI) );
                            Date_GetTwoDigitYearRange(hDlg, (CALID)dwIndex);
                        }

                        Date_EnumerateDates(hDlg, CAL_SSHORTDATE);
                        Date_EnumerateDates(hDlg, CAL_SLONGDATE);
                    }
                    break;
                }
                case ( IDC_ADD_HIJRI_DATE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= DC_Arabic_Calendar;
                    }
                    break;
                }
                case ( IDC_TWO_DIGIT_YEAR_HIGH ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        Date_ChangeYear(hDlg);
                        lpPropSheet->lParam |= DC_TwoDigitYearMax;
                    }
                    break;
                }
            }

            //
            //  Turn on ApplyNow button.
            //
            if (lpPropSheet->lParam > DC_EverChg)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            break;
        }
        case ( WM_NOTIFY ) :
        {
            lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Date)
                    {
                        Verified_Regional_Chg &= ~Process_Date;
                        Date_ClearValues(hDlg);
                        Date_SetValues(hDlg);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                   DWLP_MSGRESULT,
                                   !Date_ValidatePPS( hDlg,
                                                      lpPropSheet->lParam ) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Date_ApplySettings(hDlg, TRUE))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        //
                        //  Zero out the DC_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                       DWLP_MSGRESULT,
                                       PSNRET_INVALID_NOCHANGEPAGE );
                    }

                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_VSCROLL ) :
        {
            if ((GET_WM_VSCROLL_CODE(wParam, lParam) == SB_ENDSCROLL) &&
                ((HWND)SendMessage( GET_WM_VSCROLL_HWND(wParam, lParam),
                                   UDM_GETBUDDY,
                                   0,
                                   0L ) == GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH)))
            {
                DWORD YearHigh;

                //
                //  Get the high year.
                //
                YearHigh = (DWORD)SendDlgItemMessage( hDlg,
                                                      IDC_TWO_DIGIT_YEAR_ARROW,
                                                      UDM_GETPOS,
                                                      0,
                                                      0L );

                //
                //  Set the low year based on the high year.
                //
                SetDlgItemInt( hDlg,
                               IDC_TWO_DIGIT_YEAR_LOW,
                               (UINT)(YearHigh - 99),
                               FALSE );

                //
                //  Mark it as changed.
                //
                lpPropSheet->lParam |= DC_TwoDigitYearMax;

                //
                //  Turn on ApplyNow button.
                //
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\batt\ci.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ci.c

Abstract:

    Battery Class Installer

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/



#include "proj.h"

#include <initguid.h>
#include <devguid.h>


BOOL APIENTRY LibMain(
    HANDLE hDll, 
    DWORD dwReason,  
    LPVOID lpReserved)
{
    
    switch( dwReason ) {
    case DLL_PROCESS_ATTACH:
        
        TRACE_MSG (TF_FUNC, "Battery Class Installer Loaded\n");
        DisableThreadLibraryCalls(hDll);

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }


    
    return TRUE;
} 



DWORD
APIENTRY
BatteryClassInstall(
    IN DI_FUNCTION      DiFunction,
    IN HDEVINFO         DevInfoHandle,
    IN PSP_DEVINFO_DATA DevInfoData     OPTIONAL
    )       
/*++

Routine Description:

    This function is the class installer entry-point.

Arguments:

    DiFunction      - Requested installation function

    DevInfoHandle   - Handle to a device information set

    DevInfoData     - Pointer to device information about device to install

Return Value:

    

--*/
{
    DWORD                   status;
    SP_DEVINSTALL_PARAMS    devParams;

    
    //
    // Get the DeviceInstallParams, because some of the InstallFunction
    // handlers may find some of its fields useful.  Keep in mind not
    // to set the DeviceInstallParams using this same structure at the
    // end.  The handlers may have called functions which would change the
    // DeviceInstallParams, and simply calling SetupDiSetDeviceInstallParams
    // with this blanket structure would destroy those settings.
    //

    devParams.cbSize = sizeof(devParams);
    if (!SetupDiGetDeviceInstallParams(DevInfoHandle, DevInfoData, &devParams))
    {
        status = GetLastError();

    } else {
        TRACE_MSG (TF_GENERAL, "DiFunction = %x\n", DiFunction);

        //
        // Dispatch the InstallFunction
        //

        switch (DiFunction) {
            case DIF_INSTALLDEVICE:
                status = InstallCompositeBattery (DevInfoHandle, DevInfoData, &devParams);
                if (status == ERROR_SUCCESS) {
                    // 
                    // Let the default device installer actually install the battery. 
                    //
                    
                    status = ERROR_DI_DO_DEFAULT;
                }
                break;


            default:
                status = ERROR_DI_DO_DEFAULT;
                break;
        }
    }


    return status;
}





DWORD
PRIVATE
InstallCompositeBattery (
    IN     HDEVINFO                DevInfoHandle,
    IN     PSP_DEVINFO_DATA        DevInfoData,         OPTIONAL
    IN OUT PSP_DEVINSTALL_PARAMS   DevInstallParams
    )
/*++

Routine Description:

    This function installs the composite battery if it hasn't already been
    installed.

Arguments:

    DevInfoHandle       - Handle to a device information set

    DevInfoData         - Pointer to device information about device to install

    DevInstallParams    - Device install parameters associated with device 

Return Value:

    

--*/
{
    DWORD                   status;
    PSP_DEVINFO_DATA        newDevInfoData;
    HDEVINFO                newDevInfoHandle;
    SP_DRVINFO_DATA         driverInfoData;
    UCHAR                   tmpBuffer[100];
    DWORD                   bufferLen;
    
    
    // DebugBreak();

    //
    // Allocate local memory for a new device info structure
    //

    if(!(newDevInfoData = LocalAlloc(LPTR, sizeof(SP_DEVINFO_DATA)))) {
        status = GetLastError();
        TRACE_MSG (TF_ERROR, "Couldn't allocate composite battery device info- %x\n", status);
        goto clean0;
    }

    
    //
    // Create a new device info list.  Since we are "manufacturing" a completely new 
    // device with the Composite Battery, we can't use any of the information from 
    // the battery device list.
    //

    newDevInfoHandle = SetupDiCreateDeviceInfoList ((LPGUID)&GUID_DEVCLASS_SYSTEM, DevInstallParams->hwndParent);
    if (newDevInfoHandle == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        TRACE_MSG (TF_ERROR, "Can't create DevInfoList - %x\n", status);
        goto clean1;
    }
    
    
    //
    // Attempt to manufacture a new device information element for the root enumerated
    // composite battery.
    //
    
    newDevInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
    if(!SetupDiCreateDeviceInfo(newDevInfoHandle,
                              TEXT("Root\\COMPOSITE_BATTERY\\0000"),
                              (LPGUID)&GUID_DEVCLASS_SYSTEM,
                              NULL,
                              DevInstallParams->hwndParent,  // same parent window as enumerated device
                              0,
                              newDevInfoData)) {

        status = GetLastError();

        if (status == ERROR_DEVINST_ALREADY_EXISTS) {
            //
            // The composite battery is already installed.  Our work is done.
            //

            TRACE_MSG (TF_GENERAL, "Composite Battery Already Installed\n");
            status = ERROR_SUCCESS;
            goto clean2;
        
        } else {

            TRACE_MSG (TF_ERROR, "Error creating composite battery devinfo - %x\n", status);
            goto clean2;
        }
    }


    //
    // Register the device so it is not a phantom anymore
    //

    if (!SetupDiRegisterDeviceInfo(newDevInfoHandle, newDevInfoData, 0, NULL, NULL, NULL)) {
        status = GetLastError();
        TRACE_MSG (TF_ERROR, "Couldn't register device - %x\n", status);
        goto clean3;
    }


    //
    // Set the hardware ID.  For the composite battery it will be COMPOSITE_BATTERY
    //
    
    memset (tmpBuffer, 0, sizeof(tmpBuffer));
    lstrcpy (tmpBuffer, TEXT("COMPOSITE_BATTERY"));

    bufferLen = lstrlen(tmpBuffer) + (2 * sizeof(TCHAR));
    TRACE_MSG (TF_GENERAL, "tmpBuffer - %s\n with strlen = %x\n", tmpBuffer, bufferLen);

    status = SetupDiSetDeviceRegistryProperty (
	                    newDevInfoHandle,
                        newDevInfoData,
                        SPDRP_HARDWAREID,
	                    tmpBuffer,
	                    bufferLen
	                    );

    if (!status) {
        status = GetLastError();
        TRACE_MSG(TF_ERROR, "Couldn't set the HardwareID - %x\n", status);
        goto clean3;
    }


    //
    // Build a compatible driver list for this new device...
    //
    
    if(!SetupDiBuildDriverInfoList(newDevInfoHandle, newDevInfoData, SPDIT_COMPATDRIVER)) {
        status = GetLastError();
        TRACE_MSG(TF_ERROR, "Couldn't build class driver list - %x\n", status);
        goto clean3;
    }


    //
    // Select the first driver in the list as this will be the most compatible
    //

    driverInfoData.cbSize = sizeof (SP_DRVINFO_DATA);
    if (!SetupDiEnumDriverInfo(newDevInfoHandle, newDevInfoData, SPDIT_COMPATDRIVER, 0, &driverInfoData)) {
        status = GetLastError();
        TRACE_MSG(TF_ERROR, "Couldn't get driver list - %x\n", status);
        goto clean3;

    } else {
        TRACE_MSG(TF_GENERAL, "Driver info - \n"
                              "------------- DriverType     %x\n"
                              "------------- Description    %s\n"
                              "------------- MfgName        %s\n"
                              "------------- ProviderName   %s\n\n",
                              driverInfoData.DriverType,
                              driverInfoData.Description,
                              driverInfoData.MfgName,
                              driverInfoData.ProviderName);
	    if (!SetupDiSetSelectedDriver(newDevInfoHandle, newDevInfoData, &driverInfoData)) {
            status = GetLastError();
            TRACE_MSG (TF_ERROR, "Couldn't select driver - %x\n", status);
            goto clean4;
        } 
    }

    
    //
    // Install the device
    //

    if (!SetupDiInstallDevice (newDevInfoHandle, newDevInfoData)) {
        status = GetLastError();
        TRACE_MSG (TF_ERROR, "Couldn't install device - %x\n", status);
        goto clean4;
    }

    
    //
    // If we got here we were successful
    //

    status = ERROR_SUCCESS;
    SetLastError (status);
    goto clean1;


clean4:
    SetupDiDestroyDriverInfoList (newDevInfoHandle, newDevInfoData, SPDIT_COMPATDRIVER);

clean3:
    SetupDiDeleteDeviceInfo (newDevInfoHandle, newDevInfoData);

clean2:
    SetupDiDestroyDeviceInfoList (newDevInfoHandle);

clean1:
    LocalFree (newDevInfoData);

clean0:
    return status;
}

DWORD
APIENTRY
BatteryClassCoInstaller (
    IN DI_FUNCTION  InstallFunction,
    IN HDEVINFO  DeviceInfoSet,
    IN PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA  Context
    )
{
    SYSTEM_BATTERY_STATE batteryState;
    GLOBAL_POWER_POLICY powerPolicy;
    int i;
    UINT policyId;

    if ((InstallFunction != DIF_INSTALLDEVICE) && (InstallFunction != DIF_REMOVE)) {
        //
        // Only handle DIF_INSTALLDEVICE or DIF_REMOVE request
        //

        return (NO_ERROR);
    }

    if (!Context->PostProcessing) {
        //
        // Wait until device is installed before Adjusting levels
        //

        return (ERROR_DI_POSTPROCESSING_REQUIRED); 
    }

    NtPowerInformation (SystemBatteryState, NULL, 0, &batteryState, sizeof(batteryState));
    if ((batteryState.BatteryPresent) && (batteryState.MaxCapacity != 0)) {
        //
        // Don't try to adjust levels if for some reason no battery was installed.
        //

        ReadGlobalPwrPolicy (&powerPolicy);
       
        if (powerPolicy.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel < 
            (100 * batteryState.DefaultAlert1)/batteryState.MaxCapacity) {
            //
            // If Critical level is less than DefaultAlert1, this idicates the settings 
            // are messed up.  Reset both the Critical and the Low setting.
            //

            powerPolicy.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel =
                (100 * batteryState.DefaultAlert1)/batteryState.MaxCapacity;
            powerPolicy.user.DischargePolicy[DISCHARGE_POLICY_LOW].BatteryLevel =
                (100 * batteryState.DefaultAlert2)/batteryState.MaxCapacity;

            WriteGlobalPwrPolicy (&powerPolicy);
            GetActivePwrScheme (&policyId);
            SetActivePwrScheme (policyId, &powerPolicy, NULL); 
        }
    }
    return (NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\intl.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    intl.c

Abstract:

    This module contains the main routines for the Regional Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <cpl.h>
#include <tchar.h>




//
//  Constant Declarations.
//

#define MAX_PAGES 3          // limit on the number of pages on the first level

#define LANGUAGE_PACK_KEY    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\LanguagePack")
#define LANGUAGE_PACK_VALUE  TEXT("COMPLEXSCRIPTS")
#define LANGUAGE_PACK_DLL    TEXT("lpk.dll")

static const TCHAR c_szLanguages[] =
    TEXT("System\\CurrentControlSet\\Control\\Nls\\Language");

static const TCHAR c_szControlPanelIntl[] =
    TEXT("Control Panel\\International");




//
//  Global Variables.
//

HANDLE g_hMutex = NULL;
TCHAR szMutexName[] = TEXT("RegionalSettings_InputLocaleMutex");

HANDLE g_hEvent = NULL;
TCHAR szEventName[] = TEXT("RegionalSettings_InputLocaleEvent");

TCHAR aInt_Str[cInt_Str][3] = { TEXT("0"),
                                TEXT("1"),
                                TEXT("2"),
                                TEXT("3"),
                                TEXT("4"),
                                TEXT("5"),
                                TEXT("6"),
                                TEXT("7"),
                                TEXT("8"),
                                TEXT("9")
                              };

BOOL  g_bAdmin_Privileges = FALSE;
DWORD g_dwLastSorting;
DWORD g_dwCurSorting;
BOOL  g_bCustomize = FALSE;
BOOL  g_bDefaultUser = FALSE;
DWORD g_dwCustChange = 0L;
BOOL  g_bShowSortingTab = FALSE;
BOOL  g_bInstallComplex = FALSE;
BOOL  g_bInstallCJK = FALSE;

TCHAR szSample_Number[] = TEXT("123456789.00");
TCHAR szNegSample_Number[] = TEXT("-123456789.00");
TCHAR szTimeChars[]  = TEXT(" Hhmst,-./:;\\ ");
TCHAR szTCaseSwap[]  = TEXT("   MST");
TCHAR szTLetters[]   = TEXT("Hhmst");
TCHAR szSDateChars[] = TEXT(" dgMy,-./:;\\ ");
TCHAR szSDCaseSwap[] = TEXT(" DGmY");
TCHAR szSDLetters[]  = TEXT("dgMy");
TCHAR szLDateChars[] = TEXT(" dgMy,-./:;\\");
TCHAR szLDCaseSwap[] = TEXT(" DGmY");
TCHAR szLDLetters[]  = TEXT("dgHhMmsty");
TCHAR szStyleH[3];
TCHAR szStyleh[3];
TCHAR szStyleM[3];
TCHAR szStylem[3];
TCHAR szStyles[3];
TCHAR szStylet[3];
TCHAR szStyled[3];
TCHAR szStyley[3];
TCHAR szLocaleGetError[SIZE_128];
TCHAR szIntl[] = TEXT("intl");

TCHAR szInvalidSDate[] = TEXT("Mdyg'");
TCHAR szInvalidSTime[] = TEXT("Hhmst'");

HINSTANCE hInstance;
int Verified_Regional_Chg = 0;
int RegionalChgState = 0;
BOOL Styles_Localized;
LCID UserLocaleID;
LCID SysLocaleID;
LCID RegUserLocaleID;
LCID RegSysLocaleID;
BOOL bShowArabic;
BOOL bShowRtL;
BOOL bHebrewUI;
BOOL bLPKInstalled;
TCHAR szSetupSourcePath[MAX_PATH];
TCHAR szSetupSourcePathWithArchitecture[MAX_PATH];
LPTSTR pSetupSourcePath = NULL;
LPTSTR pSetupSourcePathWithArchitecture = NULL;

BOOL g_bCDROM = FALSE;

BOOL g_bSetupCase = FALSE;
BOOL g_bLog = FALSE;
BOOL g_bProgressBarDisplay = FALSE;
BOOL g_bSettingsChanged = FALSE;
BOOL g_bUnttendMode = FALSE;
BOOL g_bMatchUIFont = FALSE;

const TCHAR c_szInstalledLocales[] = TEXT("System\\CurrentControlSet\\Control\\Nls\\Locale");
const TCHAR c_szLanguageGroups[] = TEXT("System\\CurrentControlSet\\Control\\Nls\\Language Groups");
const TCHAR c_szMUILanguages[] = TEXT("System\\CurrentControlSet\\Control\\Nls\\MUILanguages");
const TCHAR c_szLIPInstalled[] = TEXT("Software\\Microsoft\\Windows Interface Pack\\LIPInstalled");
const TCHAR c_szFontSubstitute[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes");
const TCHAR c_szSetupKey[] = TEXT("System\\Setup");
const TCHAR c_szCPanelIntl[] = TEXT("Control Panel\\International");
const TCHAR c_szCPanelIntl_DefUser[] = TEXT(".DEFAULT\\Control Panel\\International");
const TCHAR c_szCtfmon[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
const TCHAR c_szCtfmon_DefUser[] = TEXT(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Run");
const TCHAR c_szCPanelDesktop[] = TEXT("Control Panel\\Desktop");
const TCHAR c_szCPanelDesktop_DefUser[] = TEXT(".DEFAULT\\Control Panel\\Desktop");
const TCHAR c_szKbdLayouts[] = TEXT("Keyboard Layout");
const TCHAR c_szKbdLayouts_DefUser[] = TEXT(".DEFAULT\\Keyboard Layout");
const TCHAR c_szInputMethod[] = TEXT("Control Panel\\Input Method");
const TCHAR c_szInputMethod_DefUser[] = TEXT(".DEFAULT\\Control Panel\\Input Method");
const TCHAR c_szInputTips[] = TEXT("Software\\Microsoft\\CTF");
const TCHAR c_szInputTips_DefUser[] = TEXT(".DEFAULT\\Software\\Microsoft\\CTF");
const TCHAR c_szMUIPolicyKeyPath[] = TEXT("Software\\Policies\\Microsoft\\Control Panel\\Desktop");
const TCHAR c_szMUIValue[] = TEXT("MultiUILanguageId");
const TCHAR c_szIntlRun[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\IntlRun");
const TCHAR c_szSysocmgr[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\IntlRun.OC");

TCHAR szIntlInf[]          = TEXT("intl.inf");
TCHAR szHelpFile[]         = TEXT("windows.hlp");
TCHAR szFontSubstitute[]   = TEXT("FontSubstitute");
TCHAR szLocaleListPrefix[] = TEXT("LOCALE_LIST_");
TCHAR szLGBasicInstall[]   = TEXT("LANGUAGE_COLLECTION.BASIC.INSTALL");
TCHAR szLGComplexInstall[] = TEXT("LANGUAGE_COLLECTION.COMPLEX.INSTALL");
TCHAR szLGComplexRemove[]  = TEXT("LANGUAGE_COLLECTION.COMPLEX.REMOVE");
TCHAR szLGExtInstall[]     = TEXT("LANGUAGE_COLLECTION.EXTENDED.INSTALL");
TCHAR szLGExtRemove[]      = TEXT("LANGUAGE_COLLECTION.EXTENDED.REMOVE");
TCHAR szCPInstallPrefix[]  = TEXT("CODEPAGE_INSTALL_");
TCHAR szCPRemovePrefix[]   = TEXT("CODEPAGE_REMOVE_");
TCHAR szKbdLayoutIds[]     = TEXT("KbdLayoutIds");
TCHAR szInputLibrary[]     = TEXT("input.dll");

TCHAR szUIFontSubstitute[] = TEXT("UIFontSubstitute");
TCHAR szSetupInProgress[]  = TEXT("SystemSetupInProgress");
TCHAR szSetupUpgrade[]     = TEXT("UpgradeInProgress");
TCHAR szMUILangPending[]   = TEXT("MUILanguagePending");
TCHAR szCtfmonValue[]      = TEXT("ctfmon.exe");

TCHAR szRegionalSettings[] = TEXT("RegionalSettings");
TCHAR szLanguageGroup[]    = TEXT("LanguageGroup");
TCHAR szLanguage[]         = TEXT("Language");
TCHAR szSystemLocale[]     = TEXT("SystemLocale");
TCHAR szUserLocale[]       = TEXT("UserLocale");
TCHAR szInputLocale[]      = TEXT("InputLocale");
TCHAR szMUILanguage[]      = TEXT("MUILanguage");
TCHAR szUserLocale_DefUser[]  = TEXT("UserLocale_DefaultUser");
TCHAR szInputLocale_DefUser[] = TEXT("InputLocale_DefaultUser");
TCHAR szMUILanguage_DefUSer[] = TEXT("MUILanguage_DefaultUser");

HINF g_hIntlInf = NULL;

LPLANGUAGEGROUP pLanguageGroups = NULL;
LPCODEPAGE pCodePages = NULL;

int g_NumAltSorts = 0;
HANDLE hAltSorts = NULL;
LPDWORD pAltSorts = NULL;

HINSTANCE hInputDLL = NULL;
BOOL (*pfnInstallInputLayout)(LCID, DWORD, BOOL, HKL, BOOL, BOOL) = NULL;
BOOL (*pfnUninstallInputLayout)(LCID, DWORD, BOOL) = NULL;

UILANGUAGEGROUP UILangGroup;




//
//  Function Prototypes.
//

void
DoProperties(
    HWND hwnd,
    LPCTSTR pCmdLine);





////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
//  This routine is called from LibInit to perform any initialization that
//  is required.
//
////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY LibMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            hInstance = hDll;

            //
            //  Create the mutex used for the Input Locale property page.
            //
            g_hMutex = CreateMutex(NULL, FALSE, szMutexName);
            g_hEvent = CreateEvent(NULL, TRUE, TRUE, szEventName);

            DisableThreadLibraryCalls(hDll);

            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            if (g_hMutex)
            {
                CloseHandle(g_hMutex);
            }
            if (g_hEvent)
            {
                CloseHandle(g_hEvent);
            }
            break;
        }
        case ( DLL_THREAD_DETACH ) :
        {
            break;
        }
        case ( DLL_THREAD_ATTACH ) :
        default :
        {
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateGlobals
//
////////////////////////////////////////////////////////////////////////////

BOOL CreateGlobals()
{
    HKEY hKey;
    TCHAR szData[MAX_PATH];
    DWORD cbData;

    //
    //  Get the localized strings.
    //
    LoadString(hInstance, IDS_LOCALE_GET_ERROR, szLocaleGetError, SIZE_128);
    LoadString(hInstance, IDS_STYLEUH,          szStyleH,         3);
    LoadString(hInstance, IDS_STYLELH,          szStyleh,         3);
    LoadString(hInstance, IDS_STYLEUM,          szStyleM,         3);
    LoadString(hInstance, IDS_STYLELM,          szStylem,         3);
    LoadString(hInstance, IDS_STYLELS,          szStyles,         3);
    LoadString(hInstance, IDS_STYLELT,          szStylet,         3);
    LoadString(hInstance, IDS_STYLELD,          szStyled,         3);
    LoadString(hInstance, IDS_STYLELY,          szStyley,         3);

    Styles_Localized = (szStyleH[0] != TEXT('H') || szStyleh[0] != TEXT('h') ||
                        szStyleM[0] != TEXT('M') || szStylem[0] != TEXT('m') ||
                        szStyles[0] != TEXT('s') || szStylet[0] != TEXT('t') ||
                        szStyled[0] != TEXT('d') || szStyley[0] != TEXT('y'));

    //
    //  Get the user and system default locale ids.
    //
    UserLocaleID = GetUserDefaultLCID();
    SysLocaleID = GetSystemDefaultLCID();

    //
    //  Get the system locale id from the registry.  This may be
    //  different from the current system default locale id if the user
    //  changed the system locale and chose not to reboot.
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szLanguages,
                      0L,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        //
        //  Query the default locale id.
        //
        szData[0] = 0;
        cbData = sizeof(szData);
        RegQueryValueEx(hKey, TEXT("Default"), NULL, NULL, (LPBYTE)szData, &cbData);
        RegCloseKey(hKey);

        if ((RegSysLocaleID = TransNum(szData)) == 0)
        {
            RegSysLocaleID = SysLocaleID;
        }
    }
    else
    {
        RegSysLocaleID = SysLocaleID;
    }

    //
    //  Get the user locale id from the registry.
    //
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      c_szControlPanelIntl,
                      0L,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        //
        //  Query the locale id.
        //
        szData[0] = 0;
        cbData = sizeof(szData);
        RegQueryValueEx(hKey, TEXT("Locale"), NULL, NULL, (LPBYTE)szData, &cbData);
        RegCloseKey(hKey);

        if ((RegUserLocaleID = TransNum(szData)) == 0)
        {
            RegUserLocaleID = UserLocaleID;
        }
    }
    else
    {
        RegUserLocaleID = UserLocaleID;
    }

    //
    //  See if the user locale id is Arabic or/and right to left.
    //
    bShowRtL = IsRtLLocale(UserLocaleID);
    bShowArabic = (bShowRtL &&
                   (PRIMARYLANGID(LANGIDFROMLCID(UserLocaleID)) != LANG_HEBREW));
    bHebrewUI = (PRIMARYLANGID(UserLocaleID) == LANG_HEBREW);

    //
    //  See if there is an LPK installed.
    //
    if (GetModuleHandle(LANGUAGE_PACK_DLL))
    {
        bLPKInstalled = TRUE;
    }
    else
    {
        bLPKInstalled = FALSE;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyGlobals
//
////////////////////////////////////////////////////////////////////////////

void DestroyGlobals()
{
}


////////////////////////////////////////////////////////////////////////////
//
//  CPlApplet
//
////////////////////////////////////////////////////////////////////////////

LONG CALLBACK CPlApplet(
    HWND hwnd,
    UINT Msg,
    LPARAM lParam1,
    LPARAM lParam2)
{
    switch (Msg)
    {
        case ( CPL_INIT ) :
        {
            //
            //  First message to CPlApplet(), sent once only.
            //  Perform all control panel applet initialization and return
            //  true for further processing.
            //
            InitCommonControls();
            return (CreateGlobals());
        }
        case ( CPL_GETCOUNT ) :
        {
            //
            //  Second message to CPlApplet(), sent once only.
            //  Return the number of control applets to be displayed in the
            //  control panel window.  For this applet, return 1.
            //
            return (1);
        }
        case ( CPL_INQUIRE ) :
        {
            //
            //  Third message to CPlApplet().
            //  It is sent as many times as the number of applets returned by
            //  CPL_GETCOUNT message.  Each applet must register by filling
            //  in the CPLINFO structure referenced by lParam2 with the
            //  applet's icon, name, and information string.  Since there is
            //  only one applet, simply set the information for this
            //  singular case.
            //
            LPCPLINFO lpCPlInfo = (LPCPLINFO)lParam2;

            lpCPlInfo->idIcon = IDI_ICON;
            lpCPlInfo->idName = IDS_NAME;
            lpCPlInfo->idInfo = IDS_INFO;
            lpCPlInfo->lData  = 0;

            break;
        }
        case ( CPL_NEWINQUIRE ) :
        {
            //
            //  Third message to CPlApplet().
            //  It is sent as many times as the number of applets returned by
            //  CPL_GETCOUNT message.  Each applet must register by filling
            //  in the NEWCPLINFO structure referenced by lParam2 with the
            //  applet's icon, name, and information string.  Since there is
            //  only one applet, simply set the information for this
            //  singular case.
            //
            LPNEWCPLINFO lpNewCPlInfo = (LPNEWCPLINFO)lParam2;

            lpNewCPlInfo->dwSize = sizeof(NEWCPLINFO);
            lpNewCPlInfo->dwFlags = 0;
            lpNewCPlInfo->dwHelpContext = 0UL;
            lpNewCPlInfo->lData = 0;
            lpNewCPlInfo->hIcon = LoadIcon( hInstance,
                                            (LPCTSTR)MAKEINTRESOURCE(IDI_ICON) );
            LoadString(hInstance, IDS_NAME, lpNewCPlInfo->szName, 32);
            LoadString(hInstance, IDS_INFO, lpNewCPlInfo->szInfo, 64);
            lpNewCPlInfo->szHelpFile[0] = CHAR_NULL;

            break;
        }
        case ( CPL_SELECT ) :
        {
            //
            //  Applet has been selected, do nothing.
            //
            break;
        }
        case ( CPL_DBLCLK ) :
        {
            //
            //  Applet icon double clicked -- invoke property sheet with
            //  the first property sheet page on top.
            //
            DoProperties(hwnd, (LPCTSTR)NULL);
            break;
        }
        case ( CPL_STARTWPARMS ) :
        {
            //
            //  Same as CPL_DBLCLK, but lParam2 is a long pointer to
            //  a string of extra directions that are to be supplied to
            //  the property sheet that is to be initiated.
            //
            DoProperties(hwnd, (LPCTSTR)lParam2);
            break;
        }
        case ( CPL_STOP ) :
        {
            //
            //  Sent once for each applet prior to the CPL_EXIT msg.
            //  Perform applet specific cleanup.
            //
            break;
        }
        case ( CPL_EXIT ) :
        {
            //
            //  Last message, sent once only, before MMCPL.EXE calls
            //  FreeLibrary() on this DLL.  Do non-applet specific cleanup.
            //
            DestroyGlobals();
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DoProperties
//
////////////////////////////////////////////////////////////////////////////

void DoProperties(
    HWND hwnd,
    LPCTSTR pCmdLine)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    LPARAM lParam = SETUP_SWITCH_NONE;
    LPTSTR pStartPage;
    LPTSTR pSrc;
    LPTSTR pSrcDrv;
    BOOL bShortDate = FALSE;
    BOOL bNoUI = FALSE;
    BOOL bUnattended = FALSE;
    TCHAR szUnattendFile[MAX_PATH * 2];
    HKEY hKey;
    TCHAR szSetupSourceDrive[MAX_PATH];

    //
    //  Log if the command line is not null.
    //
    if (pCmdLine != NULL)
    {
        g_bLog = TRUE;
    }

    //
    //  Begin Log and log command line parameters.
    //
    Intl_LogSimpleMessage(IDS_LOG_HEAD, NULL);
    Intl_LogMessage(pCmdLine);
    Intl_LogMessage(TEXT(""));        // add a carriage return and newline

    //
    //  Load the library used for Text Services.
    //
    if (!hInputDLL)
    {
        hInputDLL = LoadLibrary(szInputLibrary);
    }

    //
    //  Initialize the Install/Remove function from the Input applet.
    //
    if (hInputDLL)
    {
        //
        //  Initialize Install function.
        //
        pfnInstallInputLayout = (BOOL (*)(LCID, DWORD, BOOL, HKL, BOOL, BOOL))
                GetProcAddress(hInputDLL, MAKEINTRESOURCEA(ORD_INPUT_INST_LAYOUT));

        //
        //  Initialize Uninstall function.
        //
        pfnUninstallInputLayout = (BOOL (*)(LCID, DWORD, BOOL))
                GetProcAddress(hInputDLL, MAKEINTRESOURCEA(ORD_INPUT_UNINST_LAYOUT));
    }

    //
    //  See if there is a command line switch from Setup.
    //
    psh.nStartPage = (UINT)-1;
    while (pCmdLine && *pCmdLine)
    {
        if (*pCmdLine == TEXT('/'))
        {
            //
            //  Legend:
            //    gG: allow progress bar to show when setup is copying files
            //    iI: bring up the Input Locale page only
            //    rR: bring up the General page on top
            //    sS: setup source string passed on command line
            //            [example: /s:"c:\winnt"]
            //
            //  NO UI IS SHOWN IF THE FOLLOWING OPTIONS ARE SPECIFIED:
            //    fF: unattend mode file - no UI is shown
            //            [example: /f:"c:\unattend.txt"]
            //    uU: update short date format to 4-digit year - no UI is shown
            //        (registry only updated if current setting is the
            //         same as the default setting except for the
            //         "yy" vs. "yyyy")
            //    tT: Match system UI font with the default UI language
            //
            switch (*++pCmdLine)
            {
                case ( TEXT('g') ) :
                case ( TEXT('G') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_G, NULL);

                    //
                    //  Do switch related processing.
                    //
                    g_bProgressBarDisplay = TRUE;
                    pCmdLine++;
                    break;
                }
                case ( TEXT('i') ) :
                case ( TEXT('I') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_I, NULL);

                    //
                    //  Do switch related processing
                    //
                    lParam |= SETUP_SWITCH_I;
                    psh.nStartPage = 0;
                    pCmdLine++;
                    break;
                }
                case ( TEXT('r') ) :
                case ( TEXT('R') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_R, NULL);

                    //
                    //  Do switch related processing
                    //
                    lParam |= SETUP_SWITCH_R;
                    psh.nStartPage = 0;
                    pCmdLine++;
                    break;
                }
                case ( TEXT('s') ) :
                case ( TEXT('S') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_S, NULL);

                    //
                    //  Get the name of the setup source path.
                    //
                    lParam |= SETUP_SWITCH_S;
                    if ((*++pCmdLine == TEXT(':')) && (*++pCmdLine == TEXT('"')))
                    {
                        pCmdLine++;
                        pSrc = szSetupSourcePath;
                        pSrcDrv = szSetupSourceDrive;
                        while (*pCmdLine && (*pCmdLine != TEXT('"')))
                        {
                            *pSrc = *pCmdLine;
                            pSrc++;
                            *pSrcDrv = *pCmdLine;
                            pSrcDrv++;
                            pCmdLine++;
                        }
                        *pSrc = 0;
                        *pSrcDrv = 0;
                        wcscpy(szSetupSourcePathWithArchitecture, szSetupSourcePath);
                        pSetupSourcePathWithArchitecture = szSetupSourcePathWithArchitecture;

                        //
                        //  Remove the architecture-specific portion of
                        //  the source path (that gui-mode setup sent us).
                        //
                        pSrc = wcsrchr(szSetupSourcePath, TEXT('\\'));
                        if (pSrc)
                        {
                            *pSrc = TEXT('\0');
                        }
                        pSetupSourcePath = szSetupSourcePath;
                    }
                    if (*pCmdLine == TEXT('"'))
                    {
                        pCmdLine++;
                    }
                    pSrcDrv = szSetupSourceDrive;
                    while (*pSrcDrv)
                    {
                        if (*pSrcDrv == TEXT('\\'))
                        {
                            pSrcDrv[1] = 0;
                        }
                        pSrcDrv++;
                    }
                    g_bCDROM = (GetDriveType(szSetupSourceDrive) == DRIVE_CDROM);
                    break;
                }
                case ( TEXT('f') ) :
                case ( TEXT('F') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_F, NULL);

                    //
                    //  Get the name of the unattend file.
                    //
                    g_bUnttendMode = TRUE;
                    bNoUI = TRUE;
                    szUnattendFile[0] = 0;
                    if ((*++pCmdLine == TEXT(':')) && (*++pCmdLine == TEXT('"')))
                    {
                        pCmdLine++;
                        pSrc = szUnattendFile;
                        while (*pCmdLine && (*pCmdLine != TEXT('"')))
                        {
                            *pSrc = *pCmdLine;
                            pSrc++;
                            pCmdLine++;
                        }
                        *pSrc = 0;
                    }
                    if (*pCmdLine == TEXT('"'))
                    {
                        pCmdLine++;
                    }
                    break;
                }
                case ( TEXT('u') ) :
                case ( TEXT('U') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_U, NULL);

                    //
                    //  Do switch related processing.
                    //
                    bShortDate = TRUE;
                    bNoUI = TRUE;
                    break;
                }

                case ( TEXT('t') ) :
                case ( TEXT('T') ) :
                {
                    g_bMatchUIFont = TRUE;
                }

                default :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_DEFAULT, pCmdLine);

                    //
                    //  Fall out, maybe it's a number...
                    //
                    break;
                }
            }
        }
        else if (*pCmdLine == TEXT(' '))
        {
            pCmdLine++;
        }
        else
        {
            break;
        }
    }

    //
    //  See if we are in setup mode.
    //
    g_bSetupCase = Intl_IsSetupMode();

    //
    //  See if the user has Administrative privileges by checking for
    //  write permission to the registry key.
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szInstalledLocales,
                      0UL,
                      KEY_WRITE,
                      &hKey ) == ERROR_SUCCESS)
    {
        //
        //  See if the user can write into the registry.  Due to a registry
        //  modification, we can open a registry key with write access and
        //  be unable to write to the key... thanks to terminal server.
        //
        if (RegSetValueEx( hKey,
                           TEXT("Test"),
                           0UL,
                           REG_SZ,
                           (LPBYTE)TEXT("Test"),
                           (DWORD)(lstrlen(TEXT("Test")) + 1) * sizeof(TCHAR) ) == ERROR_SUCCESS)
        {
            //
            //  Delete the value created
            //
            RegDeleteValue(hKey, TEXT("Test"));

            //
            //  We can write to the HKEY_LOCAL_MACHINE key, so the user
            //  has Admin privileges.
            //
            g_bAdmin_Privileges = TRUE;
        }
        else
        {
            //
            //  The user does not have admin privileges.
            //
            g_bAdmin_Privileges = FALSE;
        }
        RegCloseKey(hKey);
    }

    //
    //  See if we are in setup mode.
    //
    if (g_bSetupCase)
    {
        //
        //  We need to remove the hard coded LPK registry key.
        //
        if (RegOpenKey( HKEY_LOCAL_MACHINE,
                        LANGUAGE_PACK_KEY,
                        &hKey ) == ERROR_SUCCESS)
        {
            RegDeleteValue(hKey, LANGUAGE_PACK_VALUE);
            RegCloseKey(hKey);
        }
    }

    //
    //  See if the unattend mode file switch was used.
    //
    if (g_bUnttendMode)
    {
        //
        //  Use the unattend mode file to carry out the appropriate commands.
        //
        Region_DoUnattendModeSetup(szUnattendFile);

        if (Intl_IsWinntUpgrade())
        {
            //
            //  Remove MUI files.
            //
            Intl_RemoveMUIFile();
        }
    }

    //
    //  If the update to 4-digit year switch was used and the user's short
    //  date setting is still set to the default for the chosen locale, then
    //  update the current user's short date setting to the new 4-digit year
    //  default.
    //
    if (bShortDate)
    {
        Region_UpdateShortDate();
    }

    //
    //  If we're not to show any UI, then return.
    //
    if (bNoUI)
    {
        return;
    }

    //
    //  Make sure we have a start page.
    //
    if (psh.nStartPage == (UINT)-1)
    {
        psh.nStartPage = 0;
        if (pCmdLine && *pCmdLine)
        {
            //
            //  Get the start page from the command line.
            //
            pStartPage = (LPTSTR)pCmdLine;
            while ((*pStartPage >= TEXT('0')) && (*pStartPage <= TEXT('9')))
            {
                psh.nStartPage *= 10;
                psh.nStartPage += *pStartPage++ - CHAR_ZERO;
            }

            //
            //  Make sure that the requested starting page is less than
            //  the max page for the selected applet.
            //
            if (psh.nStartPage >= MAX_PAGES)
            {
                psh.nStartPage = 0;
            }
        }
    }

    //
    //  Set up the property sheet information.
    //
    psh.dwSize = sizeof(psh);
    psh.dwFlags = 0;
    psh.hwndParent = hwnd;
    psh.hInstance = hInstance;
    psh.nPages = 0;
    psh.phpage = rPages;

    //
    //  Add the appropriate property pages.
    //
    if (lParam &= SETUP_SWITCH_I)
    {
        psh.pszCaption = MAKEINTRESOURCE(IDS_TEXT_INPUT_METHODS);
        Intl_AddExternalPage( &psh,
                              DLG_INPUT_LOCALES,
                              hInputDLL,
                              MAKEINTRESOURCEA(ORD_INPUT_DLG_PROC),
                              MAX_PAGES );   // One page
    }
    else
    {
        psh.pszCaption = MAKEINTRESOURCE(IDS_NAME);
        Intl_AddPage(&psh, DLG_GENERAL, GeneralDlgProc, lParam, MAX_PAGES);
        Intl_AddPage(&psh, DLG_LANGUAGES, LanguageDlgProc, lParam, MAX_PAGES);
        if (g_bAdmin_Privileges == TRUE)
        {
            Intl_AddPage(&psh, DLG_ADVANCED, AdvancedDlgProc, lParam, MAX_PAGES);
        }
    }

    //
    //  Make the property sheet.
    //
    PropertySheet(&psh);

    //
    //  Free the Text Services Library.
    //
    if (hInputDLL)
    {
        FreeLibrary(hInputDLL);
        pfnInstallInputLayout = NULL;
        pfnUninstallInputLayout = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsRtLLocale
//
////////////////////////////////////////////////////////////////////////////

#define MAX_FONTSIGNATURE    16   // length of font signature string

BOOL IsRtLLocale(
    LCID iLCID)
{
    WORD wLCIDFontSignature[MAX_FONTSIGNATURE];
    BOOL bRet = FALSE;

    //
    //  Verify that this is an RTL (BiDi) locale.  Call GetLocaleInfo with
    //  LOCALE_FONTSIGNATURE which always gives back 16 WORDs.
    //
    if (GetLocaleInfo( iLCID,
                       LOCALE_FONTSIGNATURE,
                       (LPTSTR) &wLCIDFontSignature,
                       (sizeof(wLCIDFontSignature) / sizeof(TCHAR)) ))
    {
        //
        //  Verify the bits show a BiDi UI locale.
        //
        if (wLCIDFontSignature[7] & 0x0800)
        {
            bRet = TRUE;
        }
    }

    //
    //  Return the result.
    //
    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\langdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    langdlg.c

Abstract:

    This module implements the languages property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "intl.h"
#include "intlhlp.h"
#include <windowsx.h>
#include "winnlsp.h"




//
//  Context Help Ids.
//

static int aLanguagesHelpIds[] =
{
    IDC_GROUPBOX1,            IDH_INTL_LANG_CHANGE,
    IDC_LANGUAGE_LIST_TEXT,   IDH_INTL_LANG_CHANGE,
    IDC_LANGUAGE_CHANGE,      IDH_INTL_LANG_CHANGE,

    IDC_GROUPBOX2,            IDH_INTL_LANG_INSTALL,
    IDC_LANGUAGE_SUPPL_TEXT,  IDH_INTL_LANG_INSTALL,
    IDC_LANGUAGE_COMPLEX,     IDH_INTL_LANG_INSTALL,
    IDC_LANGUAGE_CJK,         IDH_INTL_LANG_INSTALL,

    IDC_UI_LANGUAGE_TEXT,     IDH_INTL_LANG_UI_LANGUAGE,
    IDC_UI_LANGUAGE,          IDH_INTL_LANG_UI_LANGUAGE,

    0, 0
};

//
//  Global Variable.
//
BOOL bComplexInitState;
BOOL bCJKInitState;


//
//  Function prototypes.
//

void
Language_SetValues(
    HWND hDlg);


////////////////////////////////////////////////////////////////////////////
//
//  Language_InstallLanguageCollectionProc
//
//  This is the dialog proc for the Copy status Dlg.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK Language_InstallLanguageCollectionProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            break;
        }
        case (WM_DESTROY) :
        {
            EndDialog(hwnd, 0);
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_GetUILanguagePolicy
//
//  Checks if a policy is installed for the current user's MUI language.
//  The function assumes this is an MUI system.
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_GetUILanguagePolicy()
{
    HKEY hKey;
    BYTE buf[MAX_PATH];
    DWORD dwType, dwResultLen = sizeof(buf);
    BOOL bRet = FALSE;
    DWORD Num;


    //
    //  Try to open the MUI Language policy key.
    //
    if (RegOpenKey(HKEY_CURRENT_USER,
                   c_szMUIPolicyKeyPath,
                   &hKey) == ERROR_SUCCESS)
    {
        if ((RegQueryValueEx(hKey,
                             c_szMUIValue,
                             NULL,
                             &dwType,
                             &buf[0],
                             &dwResultLen) == ERROR_SUCCESS) &&
            (dwType == REG_SZ) &&
            (dwResultLen > 2))
        {
            bRet = TRUE;
        }
        RegCloseKey(hKey);
    }

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_UpdateUILanguageCombo
//
////////////////////////////////////////////////////////////////////////////

void Language_UpdateUILanguageCombo(
    HWND hDlg)
{
    HWND hUILangText = GetDlgItem(hDlg, IDC_UI_LANGUAGE_TEXT);
    HWND hUILang = GetDlgItem(hDlg, IDC_UI_LANGUAGE);
    HKEY hKey;
    TCHAR szValue[MAX_PATH];
    TCHAR szData[MAX_PATH];
    DWORD dwIndex, cchValue, cbData;
    DWORD UILang;
    DWORD dwType;
    LANGID DefaultUILang;
    LONG rc;
    DWORD dwLangIdx = 0;

    //
    //  Reset the contents of the combo box.
    //
    ComboBox_ResetContent(hUILang);

    //
    //  See if this combo box should be enabled by getting the default
    //  UI language and opening the
    //  HKLM\System\CurrentControlSet\Control\Nls\MUILanguages key.
    //
    if (!(DefaultUILang = GetUserDefaultUILanguage()) ||
        (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       c_szMUILanguages,
                       0,
                       KEY_READ,
                       &hKey ) != ERROR_SUCCESS))
    {
        //
        //  No MUILanguages.  Disable and hide the UI language combo box.
        //
        EnableWindow(hUILangText, FALSE);
        EnableWindow(hUILang, FALSE);
        ShowWindow(hUILangText, SW_HIDE);
        ShowWindow(hUILang, SW_HIDE);
        return;
    }

    //
    //  Enumerate the values in the MUILanguages key.
    //
    dwIndex = 0;
    cchValue = sizeof(szValue) / sizeof(TCHAR);
    szValue[0] = TEXT('\0');
    cbData = sizeof(szData);
    szData[0] = TEXT('\0');
    rc = RegEnumValue( hKey,
                       dwIndex,
                       szValue,
                       &cchValue,
                       NULL,
                       &dwType,
                       (LPBYTE)szData,
                       &cbData );

    while (rc == ERROR_SUCCESS)
    {
        //
        //  If the UI language contains data, then it is installed.
        //
        if ((szData[0] != 0) &&
            (dwType == REG_SZ) &&
            (UILang = TransNum(szValue)) &&
            (GetLocaleInfo(UILang, LOCALE_SNATIVELANGNAME, szData, MAX_PATH)))
        {
            //
            //  Add the new UI Language option to the combo box.
            //
            dwLangIdx = ComboBox_AddString(hUILang, szData);
            ComboBox_SetItemData(hUILang, dwLangIdx, UILang);

            //
            //  Set this as the current selection if it's the default.
            //
            if (UILang == (DWORD)DefaultUILang)
            {
                ComboBox_SetCurSel(hUILang, dwLangIdx);
            }
        }

        //
        //  Get the next enum value.
        //
        dwIndex++;
        cchValue = sizeof(szValue) / sizeof(TCHAR);
        szValue[0] = TEXT('\0');
        cbData = sizeof(szData);
        szData[0] = TEXT('\0');
        rc = RegEnumValue( hKey,
                           dwIndex,
                           szValue,
                           &cchValue,
                           NULL,
                           &dwType,
                           (LPBYTE)szData,
                           &cbData );
    }

    //
    //  Close the registry key handle.
    //
    RegCloseKey(hKey);

    //
    //  Make sure there is at least one entry in the list.
    //
    if (ComboBox_GetCount(hUILang) < 1)
    {
        //
        //  No MUILanguages.  Add the default UI language option to the
        //  combo box.
        //
        if ((GetLocaleInfo(DefaultUILang, LOCALE_SNATIVELANGNAME, szData, MAX_PATH)) &&
            (ComboBox_AddString(hUILang, szData) == 0))
        {
            ComboBox_SetItemData(hUILang, 0, (DWORD)DefaultUILang);
            ComboBox_SetCurSel(hUILang, 0);
        }
    }

    //
    //  Make sure something is selected.
    //
    if (ComboBox_GetCurSel(hUILang) == CB_ERR)
    {
        ComboBox_SetCurSel(hUILang, 0);
    }

    //
    //  Enable the combo box if there is more than one entry in the list.
    //  Otherwise, disable it.
    //
    if (ComboBox_GetCount(hUILang) > 1)
    {
        if ((IsWindowEnabled(hUILang) == FALSE) ||
            (IsWindowVisible(hUILang) == FALSE))
        {
            ShowWindow(hUILangText, SW_SHOW);
            ShowWindow(hUILang, SW_SHOW);
        }

        //
        //  Check if there is a policy enforced on the user, and if
        //  so, disable the MUI controls.
        //
        if (Language_GetUILanguagePolicy())
        {
            EnableWindow(hUILangText, FALSE);
            EnableWindow(hUILang, FALSE);
        }
        else
        {
            EnableWindow(hUILangText, TRUE);
            EnableWindow(hUILang, TRUE);
        }
    }
    else
    {
        if ((IsWindowEnabled(hUILang) == TRUE) ||
            (IsWindowVisible(hUILang) == TRUE))
        {
            EnableWindow(hUILangText, FALSE);
            EnableWindow(hUILang, FALSE);
            ShowWindow(hUILangText, SW_HIDE);
            ShowWindow(hUILang, SW_HIDE);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_GetCollectionStatus
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_GetCollectionStatus(
    DWORD collection,
    WORD wStatus)
{
    LPLANGUAGEGROUP pLG = pLanguageGroups;

    while (pLG)
    {
        if (pLG->LanguageCollection == collection)
        {
            if (pLG->wStatus & wStatus)
            {
                return (TRUE);
            }
        }
        pLG = pLG->pNext;
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_SetCollectionStatus
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_SetCollectionStatus(
    DWORD collection,
    WORD wStatus,
    BOOL bOr)
{
    LPLANGUAGEGROUP pLG = pLanguageGroups;

    while (pLG)
    {
        if (pLG->LanguageCollection == collection)
        {
            if( bOr)
            {
                pLG->wStatus |= wStatus;
            }
            else
            {
                pLG->wStatus &= wStatus;
            }
        }
        pLG = pLG->pNext;
    }

    return (TRUE);
}

    
////////////////////////////////////////////////////////////////////////////
//
//  Language_InstallCollection
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_InstallCollection(
    BOOL bInstall,
    DWORD collection,
    HWND hDlg)
{
    HINF hIntlInf;
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    INFCONTEXT Context;
    HCURSOR hcurSave;
    BOOL bActionSuccess = FALSE;
    DWORD dwRet;
    LPLANGUAGEGROUP pLG = pLanguageGroups;
    LCID *pLocale;
    BOOL bStopLoop = FALSE;
    LPTSTR pszInfSection = NULL;

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  Check if we remove the Language Collection.  This may affect the
    //  UI Language, User Locale, and/or System Locale setting.
    //
    if (!bInstall)
    {
        //
        //  Check if we can remove the Language group.
        //
        if (Language_GetCollectionStatus(collection, ML_PERMANENT))
        {
            return (FALSE);
        }
        
        //
        //  Inform Text Services that we are going to remove the
        //  complex script language collection.
        //
        while (pLG)
        {
            if (pLG->LanguageCollection == collection)
            {
                //
                //  Uninstall keyboards of the current user
                //
                Intl_UninstallAllKeyboardLayout(pLG->LanguageGroup, FALSE);


                //
                //  Uninstall keyboards of the default user
                //
                Intl_UninstallAllKeyboardLayout(pLG->LanguageGroup, TRUE);
            }
            pLG = pLG->pNext;
        }
        
        //
        //  If the User Locale is one the Language group asked to be removed. Change
        //  the user locale to be the system locale.
        //
        //  Walk through all language groups.
        //
        pLG = pLanguageGroups;
        while (pLG && !bStopLoop)
        {
            if (pLG->LanguageCollection == collection)
            {
                pLocale = pLG->pLocaleList;

                //
                //  Walk through the locale list, see if the User Locale is
                //  part of one of these Language Group.
                //
                while (*pLocale)
                {
                    if(PRIMARYLANGID(UserLocaleID) == PRIMARYLANGID(*pLocale))
                    {
                        //
                        //  Save the new locale information.
                        //
                        UserLocaleID = SysLocaleID;
                        bShowRtL = IsRtLLocale(UserLocaleID);
                        bHebrewUI = (PRIMARYLANGID(UserLocaleID) == LANG_HEBREW);                        
                        bShowArabic = (bShowRtL && (PRIMARYLANGID(LANGIDFROMLCID(UserLocaleID)) != LANG_HEBREW));
            
                        //
                        //  Install the new locale by adding the appropriate information
                        //  to the registry.
                        //
                        Intl_InstallUserLocale(UserLocaleID, FALSE, TRUE);
            
                        //
                        //  Update the NLS process cache.
                        //
                        NlsResetProcessLocale();
            
                        //
                        //  Reset the registry user locale value.
                        //
                        RegUserLocaleID = UserLocaleID;
                        
                        //
                        //  Need to make sure the proper keyboard layout is installed.
                        //
                        Intl_InstallKeyboardLayout(hDlg, UserLocaleID, 0, FALSE, FALSE, FALSE);
            
                        //
                        //  Force the loop the end.
                        //
                        bStopLoop = TRUE;
                        break;
                    }
                    pLocale++;
                }
            }

            pLG = pLG->pNext;
        }
    }

    //
    //  Initialize Inf stuff.
    //
    if (!Intl_InitInf(hDlg, &hIntlInf, szIntlInf, &FileQueue, &QueueContext))
    {
        SetCursor(hcurSave);
        return (FALSE);
    }

    //
    //  Determine with language collection we are dealing with
    //
    if( bInstall)
    {
        if (collection == COMPLEX_COLLECTION)
        {
            pszInfSection = szLGComplexInstall;
        }
        else if (collection == CJK_COLLECTION)
        {
            pszInfSection = szLGExtInstall;
        }
        else
        {
            return (FALSE);
        }
    }
    else
    {
        if (collection == COMPLEX_COLLECTION)
        {
            pszInfSection = szLGComplexRemove;
        }
        else if (collection == CJK_COLLECTION)
        {
            pszInfSection = szLGExtRemove;
        }
        else
        {
            return (FALSE);
        }
    }

    //
    //  Enqueue the complex script language group files so that they may be
    //  copied.  This only handles the CopyFiles entries in the inf file.
    //
    if (!SetupInstallFilesFromInfSection( hIntlInf,
                                          NULL,
                                          FileQueue,
                                          pszInfSection,
                                          pSetupSourcePath,
                                          SP_COPY_NEWER ))
    {
        //
        //  Setup failed to find the complex script language group.
        //  This shouldn't happen - the inf file is messed up.
        //
        ShowMsg( hDlg,
                 IDS_ML_COPY_FAILED,
                 0,
                 MB_OK_OOPS,
                 TEXT("Supplemental Language Support") );
    }

    //
    //  See if we need to install/remove any files.
    //
    if (SetupScanFileQueue( FileQueue,
                            SPQ_SCAN_PRUNE_COPY_QUEUE | SPQ_SCAN_FILE_VALIDITY,
                            GetParent(hDlg),
                            NULL,
                            NULL,
                            &dwRet ))
    {
        //
        //  Copy the files in the queue.
        //
        if (!SetupCommitFileQueue( GetParent(hDlg),
                                   FileQueue,
                                   SetupDefaultQueueCallback,
                                   QueueContext ))
        {
            //
            //  This can happen if the user hits Cancel from within
            //  the setup dialog.
            //
            bInstall = FALSE;
            ShowMsg( hDlg,
                     IDS_ML_SETUP_FAILED,
                     0,
                     MB_OK_OOPS,
                     NULL );
        }
        else
        {
            //
            //  Call setup to install other inf info for this
            //  language group.
            //
            if (!SetupInstallFromInfSection( GetParent(hDlg),
                                             hIntlInf,
                                             pszInfSection,
                                             SPINST_ALL & ~SPINST_FILES,
                                             NULL,
                                             pSetupSourcePath,
                                             0,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL ))
            {
                //
                //  Setup failed.
                //
                //  Already copied the language group file, so no need to
                //  change the status of the language group info here.
                //
                //  This shouldn't happen - the inf file is messed up.
                //
                ShowMsg( hDlg,
                         IDS_ML_INSTALL_FAILED,
                         0,
                         MB_OK_OOPS,
                         TEXT("Supplemental Language Support") );
            }
            else
            {
                //
                //  Run any necessary apps (for IME installation).
                //
                if (bInstall)
                {
                    Intl_RunRegApps(c_szIntlRun);
                }
                bActionSuccess = TRUE;
            }
        }
    }

    //
    //  Update the status of all language groups included in the
    //  Supplemental Language support.
    //
    if (bActionSuccess)
    {
        if (bInstall)
        {
            //
            //  Mark as installed.
            //
            Language_SetCollectionStatus(collection,
            	                         ML_INSTALL,
            	                         TRUE);
            Language_SetCollectionStatus(collection,
            	                         ~(ML_DISABLE | ML_REMOVE),
            	                         FALSE);
        }
        else
        {
            //
            //  Mark as removed.
            //
            Language_SetCollectionStatus(collection,
            	                         (ML_DISABLE | ML_REMOVE),
            	                         TRUE);
            Language_SetCollectionStatus(collection,
            	                         ~ML_INSTALL,
            	                         FALSE);
        }
    }

    //
    //  Close Inf stuff.
    //
    Intl_CloseInf(hIntlInf, FileQueue, QueueContext);

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Return the result.
    //
    return (bActionSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_InstallLanguageCollection
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_InstallLanguageCollection(
    BOOL bInstall,
    DWORD collection,
    HWND hDlg)
{
    //
    //  Check if we are in setup. If in setup we need to show up a dialog
    //  instead of using the progress bar of setup.
    //
    if( g_bSetupCase)
    {
        HWND hDialog;
        BOOL retVal;

        //
        // Create a dialog.
        //
        hDialog = CreateDialog( hInstance,
                                MAKEINTRESOURCE(DLG_SETUP_INFORMATION),
                                hDlg,
                                Language_InstallLanguageCollectionProc);
        
        //
        //  Show dialog
        //
        ShowWindow(hDialog, SW_SHOW);

        //
        //  proceed with the installation
        //
        retVal = Language_InstallCollection(bInstall, collection, hDlg);

        //
        //  Close the dialog
        //
        DestroyWindow(hDialog);
        return (retVal);
    }
    else
    {
       return Language_InstallCollection(bInstall, collection, hDlg);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_CommandChange
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_CommandChange(
    HWND hDlg)
{
    //
    //  Call Text Services input page
    //
    Intl_CallTextServices();

    //
    //  Return the result.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_ClearValues
//
//  Reset each of the list boxes in the advanced property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Language_ClearValues(
    HWND hDlg)
{
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_SetValues
//
//  Initialize all of the controls in the advanced property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Language_SetValues(
    HWND hDlg)
{
    HWND hUILang = GetDlgItem(hDlg, IDC_UI_LANGUAGE);
    TCHAR szUILang[SIZE_128];
    DWORD dwIndex;

    //
    //  Fill in the current UI Language settings in the list.
    //
    ComboBox_GetLBText( hUILang, ComboBox_GetCurSel(hUILang), szUILang );
    Language_UpdateUILanguageCombo(hDlg);
    dwIndex = ComboBox_GetCurSel(hUILang);
    if (ComboBox_SetCurSel( hUILang,
                            ComboBox_FindStringExact( hUILang,
                                                      -1,
                                                      szUILang ) ) == CB_ERR)
    {
        ComboBox_SetCurSel(hUILang, dwIndex);
    }

    //
    //  Verify if the user has administrative privileges.  If not, then
    //  disable the controls.
    //
    if (!g_bAdmin_Privileges)
    {
        //
        //  Disable the complex scripts install/remove.
        //
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE_COMPLEX), FALSE);

        //
        //  Disable the CJK install/remove.
        //
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE_CJK), FALSE);
    }

    //
    //  Verify that the collection is not marked as permanent.
    //
    if (Language_GetCollectionStatus(COMPLEX_COLLECTION, ML_PERMANENT))
    {
        //
        //  Disable the complex scripts install/remove.
        //
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE_COMPLEX), FALSE);
    }
    if (Language_GetCollectionStatus(CJK_COLLECTION, ML_PERMANENT))
    {
        //
        //  Disable the CJK install/remove.
        //
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE_CJK), FALSE);
    }

    //
    //  Check if we can install the CJK Language Groups.  This is only
    //  the case on a Clean install over the Network.
    //
    if (g_bSetupCase)
    {
        //
        //  Check if we have at least one file in the \Lang directory.
        //
        if (!Intl_LanguageGroupFilesExist())
        {
            //
            //  Disable the CJK install/remove.
            //
            EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE_CJK), FALSE);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_ApplySettings
//
//  If anything has changed, update the settings.  Notify the parent of
//  changes and reset the change flag stored in the property sheet page
//  structure appropriately.
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_ApplySettings(
    HWND hDlg)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;
    HCURSOR hcurSave;
    BOOL bReboot = FALSE;

    //
    //  See if there are any changes.
    //
    if (Changes <= LG_EverChg)
    {
        return (TRUE);
    }

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  See if there are any changes to the Complex Srcipts Languages group
    //  installation.
    //
    if (Changes & LG_Complex)
    {
        //
        //  Install/Remove Complex Scripts Language groups.
        //
        if (Language_InstallLanguageCollection(g_bInstallComplex, COMPLEX_COLLECTION, hDlg))
        {
            if (g_bInstallComplex)
            {
                //
                //  Check the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_CHECKED);
                bComplexInitState = TRUE;
            }
            else
            {
                //
                //  Uncheck the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_UNCHECKED);
                bComplexInitState = FALSE;
            }

            //
            //  Need to reboot in order for the change to take effect.
            //
            bReboot = TRUE;
        }
        else
        {
            if (g_bInstallComplex)
            {
                //
                //  UnCheck the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_UNCHECKED);
            }
            else
            {
                //
                //  Check the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_CHECKED);
            }
        }
    }

    //
    //  See if there are any changes to the CJK Languages group
    //  installation.
    //
    if (Changes & LG_CJK)
    {
        //
        //  Install/Remove CJK Language groups.
        //
        if (Language_InstallLanguageCollection(g_bInstallCJK, CJK_COLLECTION, hDlg))
        {
            if (g_bInstallCJK)
            {
                //
                //  Check the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_CHECKED);
                bCJKInitState = TRUE;
            }
            else
            {
                //
                //  Uncheck the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_UNCHECKED);
                bCJKInitState = FALSE;
            }

            //
            //  Need to reboot to the change to take effect
            //
            bReboot = TRUE;
        }
        else
        {
            if (g_bInstallCJK)
            {
                //
                //  Uncheck the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_UNCHECKED);
            }
            else
            {
                //
                //  Check the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_CHECKED);
            }
        }
    }

    //
    //  See if there are any changes to the UI Language.
    //
    if (Changes & LG_UILanguage)
    {
        DWORD dwUILang;
        LANGID UILang;
        HWND hUILang = GetDlgItem(hDlg, IDC_UI_LANGUAGE);

        //
        //  Get the current selection.
        //
        dwUILang = ComboBox_GetCurSel(hUILang);

        //
        //  See if the current selection is different from the original
        //  selection.
        //
        if (dwUILang != CB_ERR)
        {
            //
            //  Get the UI Language id for the current selection.
            //
            UILang = (LANGID)ComboBox_GetItemData(hUILang, dwUILang);

            //
            //  Set the UI Language value in the user's registry.
            //
            if (NT_SUCCESS(NtSetDefaultUILanguage(UILang)))
            {
                //  deleting the key this way makes the key invalid for this process
                //  this way the new UI doesn't get bogus cached values
                SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\MUICache"));

            }

            //
            //  Install keyboard assciated with the UI language
            //
            Intl_InstallKeyboardLayout(hDlg, MAKELCID(UILang, SORT_DEFAULT), 0, FALSE, FALSE, FALSE);

            //
            //  Alert them that the UI change will take effect next time
            //  they log on.
            //
            ShowMsg( hDlg,
                     IDS_CHANGE_UI_LANG_NOT_ADMIN,
                     IDS_TITLE_STRING,
                     MB_OK | MB_ICONINFORMATION,
                     NULL );
        }
    }

    //
    //  Reset the property page settings.
    //
    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    Changes = LG_EverChg;

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  See if we need to display the reboot message.
    //
    if ((!g_bSetupCase) && (bReboot))
    {
        if ((RegionalChgState & AD_SystemLocale) || 
            (RegionalChgState & AD_CodePages))
        {
            RegionalChgState &= ~Process_Languages;
            RegionalChgState |= AD_SystemLocale;
        }
        else
        {
            if (ShowMsg( hDlg,
                         IDS_REBOOT_STRING,
                         IDS_TITLE_STRING,
                         MB_YESNO | MB_ICONQUESTION,
                         NULL ) == IDYES)
            {
                Intl_RebootTheSystem();
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= LG_EverChg)
    {
        return (TRUE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Language_SetValues with the property
//  sheet handle to initialize all of the property sheet controls.  Limit
//  the length of the text in some of the ComboBoxes.
//
////////////////////////////////////////////////////////////////////////////

void Language_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    DWORD dwColor;

    //
    //  The lParam holds a pointer to the property sheet page.  Save it
    //  for later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    //
    //  Set values.
    //
    if (pLanguageGroups == NULL)
    {
        Intl_LoadLanguageGroups(hDlg);
    }
    Language_SetValues(hDlg);

    //
    //  Determine if Complex Scripts language support is installed.
    //
    if (Language_GetCollectionStatus(COMPLEX_COLLECTION, ML_INSTALL))
    {
        //
        //  Check the box.
        //
        CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_CHECKED);
        bComplexInitState = TRUE;
    }
    else
    {
        //
        //  Uncheck the box.
        //
        CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_UNCHECKED);
        bComplexInitState = FALSE;
    }

    //
    //  Determine if CJK language support is installed.
    //
    if (Language_GetCollectionStatus(CJK_COLLECTION, ML_INSTALL))
    {
        //
        //  Check the box.
        //
        CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_CHECKED);
        bCJKInitState = TRUE;
    }
    else
    {
        //
        //  Uncheck the box.
        //
        CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_UNCHECKED);
        bCJKInitState = FALSE;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LanguagesDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK LanguageDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch (message)
    {
        case ( WM_NOTIFY ) :
        {
            LPNMHDR lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Languages)
                    {
                        Verified_Regional_Chg &= ~Process_Languages;
                        Language_ClearValues(hDlg);
                        Language_SetValues(hDlg);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                      DWLP_MSGRESULT,
                                      !Language_ValidatePPS(hDlg, lpPropSheet->lParam) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Language_ApplySettings(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        //
                        //  Check if we need to do something for the
                        //  default user.
                        //
                        if (g_bDefaultUser)
                        {
                            g_bSettingsChanged = TRUE;
                            Intl_SaveDefaultUserSettings();
                        }

                        //
                        //  Zero out the LG_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                          DWLP_MSGRESULT,
                                          PSNRET_INVALID_NOCHANGEPAGE );
                    }

                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            //
            //  Init property sheet.
            //
            Language_InitPropSheet(hDlg, lParam);
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aLanguagesHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aLanguagesHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_UI_LANGUAGE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        DWORD dwUILang;
                        HWND hUILang = GetDlgItem(hDlg, IDC_UI_LANGUAGE);
                        
                        //
                        //  Get the current selection.
                        //
                        dwUILang = ComboBox_GetCurSel(hUILang);
                        
                        //
                        //  Check if the user reverted the change back
                        //
                        if (dwUILang != CB_ERR)
                        {
                            if ((LANGID)ComboBox_GetItemData(hUILang, dwUILang) == Intl_GetPendingUILanguage())
                            {
                                //
                                //  Reset the LG_UILanguage change flag.
                                //
                                lpPropSheet->lParam &= ~LG_UILanguage;
                            }
                            else
                            {
                                //
                                //  Set the LG_UILanguage change flag.
                                //
                                lpPropSheet->lParam |= LG_UILanguage;
                            }
                        }
                    }
                    break;
                }
                case ( IDC_LANGUAGE_CHANGE ) :
                {
                    if (Language_CommandChange(hDlg))
                    {
                        //
                        //  Set the LG_Change change flag.
                        //
                        lpPropSheet->lParam |= LG_Change;
                    }
                    break;
                }
                case ( IDC_LANGUAGE_CJK ) :
                {
                    BOOL curState;

                    //
                    //  Verify the check box state.
                    //
                    if (IsDlgButtonChecked(hDlg, IDC_LANGUAGE_CJK))
                    {
#ifdef i386
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_CJK_INST,
                                 IDS_SUP_LANG_SUP_INST_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
#endif
#ifdef IA64
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_CJK_INST64,
                                 IDS_SUP_LANG_SUP_INST_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
#endif
                        curState = TRUE;
                    }
                    else
                    {
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_CJK_REM,
                                 IDS_SUP_LANG_SUP_REM_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
                        curState = FALSE;
                    }

                    //
                    //  Set the LG_CJK change flag.
                    //
                    if (curState != bCJKInitState)
                    {
                        lpPropSheet->lParam |= LG_CJK;
                        g_bInstallCJK = curState;
                        RegionalChgState |= Process_Languages;
                    }
                    else
                    {
                        lpPropSheet->lParam &= ~LG_CJK;
                        RegionalChgState &= ~Process_Languages;
                    }

                    //
                    //  Enable/Disable the avability of Collection dependant locale
                    //
                    if (curState)
                    {
                        Language_SetCollectionStatus(CJK_COLLECTION,
                        	                         ML_INSTALL,
                        	                         TRUE);
                        Language_SetCollectionStatus(CJK_COLLECTION,
                        	                         ~(ML_DISABLE | ML_REMOVE),
                        	                         FALSE);
                    }
                    else
                    {
                        Language_SetCollectionStatus(CJK_COLLECTION,
                        	                         (ML_DISABLE | ML_REMOVE),
                        	                         TRUE);
                        Language_SetCollectionStatus(CJK_COLLECTION,
                        	                         ~ML_INSTALL,
                        	                         FALSE);
                    }

                    //
                    //  Register that we changed the Complex Script and/or CJK
                    //  installation.  This will affect settings in other pages.  All
                    //  other changes to settings on this page do not affect other pages.
                    //
                    Verified_Regional_Chg |= (Process_Regional | Process_Advanced);
                    
                    break;
                }
                case ( IDC_LANGUAGE_COMPLEX ) :
                {
                    BOOL curState;

                    //
                    //  Verify the check box state.
                    //
                    if (IsDlgButtonChecked(hDlg, IDC_LANGUAGE_COMPLEX))
                    {
#ifdef i386
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_COMPLEX_INST,
                                 IDS_SUP_LANG_SUP_INST_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
#endif
#ifdef IA64
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_COMPLEX_INST64,
                                 IDS_SUP_LANG_SUP_INST_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
#endif
                        curState = TRUE;
                    }
                    else
                    {
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_COMPLEX_REM,
                                 IDS_SUP_LANG_SUP_REM_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
                        curState = FALSE;
                    }

                    //
                    //  Set the LG_Complex change flag.
                    //
                    if (curState != bComplexInitState)
                    {
                        lpPropSheet->lParam |= LG_Complex;
                        g_bInstallComplex = curState;
                        RegionalChgState |= Process_Languages;
                    }
                    else
                    {
                        lpPropSheet->lParam &= ~LG_Complex;
                        RegionalChgState &= ~Process_Languages;
                    }
                    
                    //
                    //  Enable/Disable the avability of Collection dependant locale
                    //
                    if (curState)
                    {
                        Language_SetCollectionStatus(COMPLEX_COLLECTION,
                        	                         ML_INSTALL,
                        	                         TRUE);
                        Language_SetCollectionStatus(COMPLEX_COLLECTION,
                        	                         ~(ML_DISABLE | ML_REMOVE),
                        	                         FALSE);
                    }
                    else
                    {
                        Language_SetCollectionStatus(COMPLEX_COLLECTION,
                        	                         (ML_DISABLE | ML_REMOVE),
                        	                         TRUE);
                        Language_SetCollectionStatus(COMPLEX_COLLECTION,
                        	                         ~ML_INSTALL,
                        	                         FALSE);
                    }
                    
                    //
                    //  Register that we changed the Complex Script and/or CJK
                    //  installation.  This will affect settings in other pages.  All
                    //  other changes to settings on this page do not affect other pages.
                    //
                    Verified_Regional_Chg |= (Process_Regional | Process_Advanced);
                    
                    break;
                }
            }

            //
            //  Turn on ApplyNow button.
            //
            if (lpPropSheet->lParam > LG_EverChg)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\maxvals.h ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    maxvals.h

Abstract:

    This module contains the maximum value string constants for the
    SetLocaleInfo api.

Revision History:

--*/



//
//  SetLocaleInfo string constants.
//

#define MAX_SLIST                 3    // max wide chars in sList
#define MAX_IMEASURE              1    // max wide chars in iMeasure
#define MAX_SDECIMAL              3    // max wide chars in sDecimal
#define MAX_STHOUSAND             3    // max wide chars in sThousand
#define MAX_SGROUPING             3    // max wide chars in sGrouping
#define MAX_IDIGITS               1    // max wide chars in iDigits
#define MAX_IDIGITSUBSTITUTION    2    // max wide chars in iDigitsSubstitution
#define MAX_ILZERO                1    // max wide chars in iLZero
#define MAX_INEGNUMBER            1    // max wide chars in iNegNumber
#define MAX_SCURRENCY             5    // max wide chars in sCurrency
#define MAX_SMONDECSEP            3    // max wide chars in sMonDecimalSep
#define MAX_SMONTHOUSEP           3    // max wide chars in sMonThousandSep
#define MAX_SMONGROUPING          3    // max wide chars in sMonGrouping
#define MAX_ICURRDIGITS           2    // max wide chars in iCurrDigits
#define MAX_ICURRENCY             1    // max wide chars in iCurrency
#define MAX_INEGCURR              2    // max wide chars in iNegCurr
#define MAX_SPOSSIGN              4    // max wide chars in sPositiveSign
#define MAX_SNEGSIGN              4    // max wide chars in sNegativeSign
#define MAX_STIMEFORMAT          79    // max wide chars in sTimeFormat
#define MAX_STIME                 3    // max wide chars in sTime
#define MAX_ITIME                 1    // max wide chars in iTime
#define MAX_S1159                12    // max wide chars in s1159
#define MAX_S2359                12    // max wide chars in s2359
#define MAX_SSHORTDATE           79    // max wide chars in sShortDate
#define MAX_SDATE                 3    // max wide chars in sDate
#define MAX_SLONGDATE            79    // max wide chars in sLongDate
#define MAX_ICALTYPE              1    // max wide chars in iCalendarType
#define MAX_IFIRSTDAY             1    // max wide chars in iFirstDayOfWeek
#define MAX_IFIRSTWEEK            1    // max wide chars in iFirstWeekOfYear
#define MAX_FORMAT               80    // max wide chars in date & time styles
#define MAX_YEAR                  4    // max wide chars in year
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\numdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    numdlg.c

Abstract:

    This module implements the number property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <windowsx.h>
#include <tchar.h>
#include "intlhlp.h"
#include "maxvals.h"



//
//  Constant Declarations.
//

#define MAX_DIGIT_SUBST           2
#define CHAR_MAX_DIGIT_SUBST      TEXT('2')

#define EUROPEAN_DIGITS           TEXT("0123456789")
#define LPK_EUROPEAN_DIGITS       TEXT("\x206f\x0030\x0031\x0032\x0033\x0034\x0035\x0036\x0037\x0038\x0039")

#define LANGUAGE_GROUPS_KEY       TEXT("System\\CurrentControlSet\\Control\\Nls\\Language Groups")



//
//  Global Variables.
//

static TCHAR sz_iNegNumber[MAX_INEGNUMBER + 1];
static TCHAR sz_iMeasure[MAX_IMEASURE + 1];
static TCHAR sz_NumShape[MAX_IDIGITSUBSTITUTION + 1];
static TCHAR sz_sDecimal[MAX_SDECIMAL + 1];
static TCHAR sz_sGrouping[MAX_SGROUPING + 1];
static TCHAR sz_sList[MAX_SLIST + 1];
static TCHAR sz_sNativeDigits[MAX_FORMAT + 1];
static TCHAR sz_sNegativeSign[MAX_SNEGSIGN + 1];
static TCHAR sz_sPositiveSign[MAX_SPOSSIGN + 1];
static TCHAR sz_sThousand[MAX_STHOUSAND + 1];
static TCHAR sz_iDigits[MAX_IDIGITS + 1];
static TCHAR sz_iLZero[MAX_ILZERO + 1];

//
//  Native Digits tables.
//
#define MAX_LANG_GROUPS    16
#define MAX_DIGITS_PER_LG   2
static const int c_szDigitsPerLangGroup[MAX_LANG_GROUPS][MAX_DIGITS_PER_LG] =
{
    0,  0,    // 0  = (invalid)
    0,  0,    // 1  = Western Europe (added by code, see Number_SetValues(..))
    0,  0,    // 2  = Central Europe
    0,  0,    // 3  = Baltic
    0,  0,    // 4  = Greek
    0,  0,    // 5  = Cyrillic
    0,  0,    // 6  = Turkish
    0,  0,    // 7  = Japanese
    0,  0,    // 8  = Korean
    0,  0,    // 9  = Traditional Chinese
    0,  0,    // 10 = Simplified Chinese
    12, 0,    // 11 = Thai
    0,  0,    // 12 = Hebrew
    1,  2,    // 13 = Arabic
    0,  0,    // 14 = Vietnamese
    3,  8     // 15 = Indian (NT5 supports only Devenagari and Tamil (i.e. fonts and kbd))
};

static const LPTSTR c_szNativeDigits[15] =
{
    TEXT("0123456789"),                                                    // European
    TEXT("\x0660\x0661\x0662\x0663\x0664\x0665\x0666\x0667\x0668\x0669"),  // Arabic-Indic
    TEXT("\x06f0\x06f1\x06f2\x06f3\x06f4\x06f5\x06f6\x06f7\x06f8\x06f9"),  // Extended Arabic-Indic
    TEXT("\x0966\x0967\x0968\x0969\x096a\x096b\x096c\x096d\x096e\x096f"),  // Devanagari
    TEXT("\x09e6\x09e7\x09e8\x09e9\x09ea\x09eb\x09ec\x09ed\x09ee\x09ef"),  // Bengali
    TEXT("\x0a66\x0a67\x0a68\x0a69\x0a6a\x0a6b\x0a6c\x0a6d\x0a6e\x0a6f"),  // Gurmukhi
    TEXT("\x0ae6\x0ae7\x0ae8\x0ae9\x0aea\x0aeb\x0aec\x0aed\x0aee\x0aef"),  // Gujarati
    TEXT("\x0b66\x0b67\x0b68\x0b69\x0b6a\x0b6b\x0b6c\x0b6d\x0b6e\x0b6f"),  // Oriya
    TEXT("\x0030\x0be7\x0be8\x0be9\x0bea\x0beb\x0bec\x0bed\x0bee\x0bef"),  // Tamil
    TEXT("\x0c66\x0c67\x0c68\x0c69\x0c6a\x0c6b\x0c6c\x0c6d\x0c6e\x0c6f"),  // Telugu
    TEXT("\x0ce6\x0ce7\x0ce8\x0ce9\x0cea\x0ceb\x0cec\x0ced\x0cee\x0cef"),  // Kannada
    TEXT("\x0d66\x0d67\x0d68\x0d69\x0d6a\x0d6b\x0d6c\x0d6d\x0d6e\x0d6f"),  // Malayalam
    TEXT("\x0e50\x0e51\x0e52\x0e53\x0e54\x0e55\x0e56\x0e57\x0e58\x0e59"),  // Thai
    TEXT("\x0ed0\x0ed1\x0ed2\x0ed3\x0ed4\x0ed5\x0ed6\x0ed7\x0ed8\x0ed9"),  // Lao
    TEXT("\x0f20\x0f21\x0f22\x0f23\x0f24\x0f25\x0f26\x0f27\x0f28\x0f29")   // Tibetan
};



//
//  Context Help Ids.
//

static int aNumberHelpIds[] =
{
    IDC_SAMPLELBL3,          IDH_COMM_GROUPBOX,
    IDC_SAMPLELBL1,          IDH_INTL_NUM_POSVALUE,
    IDC_SAMPLE1,             IDH_INTL_NUM_POSVALUE,
    IDC_SAMPLELBL2,          IDH_INTL_NUM_NEGVALUE,
    IDC_SAMPLE2,             IDH_INTL_NUM_NEGVALUE,

    IDC_SAMPLELBL1A,         IDH_INTL_NUM_POSVALUE_ARABIC,
    IDC_SAMPLE1A,            IDH_INTL_NUM_POSVALUE_ARABIC,
    IDC_SAMPLELBL2A,         IDH_INTL_NUM_NEGVALUE_ARABIC,
    IDC_SAMPLE2A,            IDH_INTL_NUM_NEGVALUE_ARABIC,

    IDC_DECIMAL_SYMBOL,      IDH_INTL_NUM_DECSYMBOL,
    IDC_NUM_DECIMAL_DIGITS,  IDH_INTL_NUM_DIGITSAFTRDEC,
    IDC_DIGIT_GROUP_SYMBOL,  IDH_INTL_NUM_DIGITGRPSYMBOL,
    IDC_NUM_DIGITS_GROUP,    IDH_INTL_NUM_DIGITSINGRP,
    IDC_NEG_SIGN,            IDH_INTL_NUM_NEGSIGNSYMBOL,
    IDC_NEG_NUM_FORMAT,      IDH_INTL_NUM_NEGNUMFORMAT,
    IDC_SEPARATOR,           IDH_INTL_NUM_LISTSEPARATOR,
    IDC_DISPLAY_LEAD_0,      IDH_INTL_NUM_DISPLEADZEROS,
    IDC_MEASURE_SYS,         IDH_INTL_NUM_MEASUREMNTSYS,
    IDC_NATIVE_DIGITS_TEXT,  IDH_INTL_NUM_NATIVE_DIGITS,
    IDC_NATIVE_DIGITS,       IDH_INTL_NUM_NATIVE_DIGITS,
    IDC_DIGIT_SUBST_TEXT,    IDH_INTL_NUM_DIGIT_SUBST,
    IDC_DIGIT_SUBST,         IDH_INTL_NUM_DIGIT_SUBST,

    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  Number_IsEuropeanDigits
//
////////////////////////////////////////////////////////////////////////////

BOOL Number_IsEuropeanDigits(
    TCHAR *pNum)
{
    int Ctr;
    int Length = lstrlen(pNum);

    for (Ctr = 0; Ctr < Length; Ctr++)
    {
        if (!((pNum[Ctr] >= TEXT('0')) && (pNum[Ctr] <= TEXT('9'))))
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_GetDigitSubstitution
//
////////////////////////////////////////////////////////////////////////////

int Number_GetDigitSubstitution()
{
    TCHAR szBuf[10];
    int cch;

    //
    //  Get the digit substitution.
    //
    if ((cch = GetLocaleInfo(UserLocaleID, LOCALE_IDIGITSUBSTITUTION, szBuf, 10)) &&
        (cch == 2) &&
        ((szBuf[0] >= CHAR_ZERO) && (szBuf[0] <= CHAR_MAX_DIGIT_SUBST)))
    {
        return (szBuf[0] - CHAR_ZERO);
    }

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_DisplaySample
//
//  Update the Number sample.  Format the number based on the user's
//  current locale settings.  Display either a positive value or a
//  negative value based on the Positive/Negative radio buttons.
//
////////////////////////////////////////////////////////////////////////////

void Number_DisplaySample(
    HWND hDlg)
{
    TCHAR szBuf[MAX_SAMPLE_SIZE];
    int nCharCount;

    //
    //  Show or hide the Arabic info based on the current user locale id.
    //
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLELBL1A), bShowArabic ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLE1A), bShowArabic ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLELBL2A), bShowArabic ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLE2A), bShowArabic ? SW_SHOW : SW_HIDE);

    //
    //  Get the string representing the number format for the positive sample
    //  number and, if the the value is valid, display it.  Perform the same
    //  operations for the negative sample.
    //
    nCharCount = GetNumberFormat( UserLocaleID,
                                  0,
                                  szSample_Number,
                                  NULL,
                                  szBuf,
                                  MAX_SAMPLE_SIZE );
    if (nCharCount)
    {
        SetDlgItemText(hDlg, IDC_SAMPLE1, szBuf);
        if (bShowArabic)
        {
            SetDlgItemText(hDlg, IDC_SAMPLE1A, szBuf);
            SetDlgItemRTL(hDlg, IDC_SAMPLE1A);
        }
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }

    nCharCount = GetNumberFormat( UserLocaleID,
                                  0,
                                  szNegSample_Number,
                                  NULL,
                                  szBuf,
                                  MAX_SAMPLE_SIZE );
    if (nCharCount)
    {
        SetDlgItemText(hDlg, IDC_SAMPLE2, szBuf);
        if (bShowArabic)
        {
            SetDlgItemText(hDlg, IDC_SAMPLE2A, szBuf);
            SetDlgItemRTL(hDlg, IDC_SAMPLE2A);
        }
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_SaveValues
//
//  Save values in the case that we need to restore them.
//
////////////////////////////////////////////////////////////////////////////

void Number_SaveValues()
{
    //
    //  Save registry values.
    //
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_INEGNUMBER,
                        sz_iNegNumber,
                        MAX_INEGNUMBER + 1 ))
    {
        _tcscpy(sz_iNegNumber, TEXT("1"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_IMEASURE,
                        sz_iMeasure,
                        MAX_IMEASURE + 1 ))
    {
        _tcscpy(sz_iMeasure, TEXT("1"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_IDIGITSUBSTITUTION,
                        sz_NumShape,
                        MAX_IDIGITSUBSTITUTION + 1 ))
    {
        _tcscpy(sz_NumShape, TEXT("1"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SDECIMAL,
                        sz_sDecimal,
                        MAX_SDECIMAL + 1 ))
    {
        _tcscpy(sz_sDecimal, TEXT("."));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SGROUPING,
                        sz_sGrouping,
                        MAX_SGROUPING + 1 ))
    {
        _tcscpy(sz_sGrouping, TEXT("3;0"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SLIST,
                        sz_sList,
                        MAX_SLIST + 1 ))
    {
        _tcscpy(sz_sList, TEXT(","));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SNATIVEDIGITS,
                        sz_sNativeDigits,
                        MAX_FORMAT + 1 ))
    {
        _tcscpy(sz_sNativeDigits, TEXT("0123456789"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SNEGATIVESIGN,
                        sz_sNegativeSign,
                        MAX_SNEGSIGN + 1 ))
    {
        _tcscpy(sz_sNegativeSign, TEXT("-"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SPOSITIVESIGN,
                        sz_sPositiveSign,
                        MAX_SPOSSIGN + 1 ))
    {
        _tcscpy(sz_sPositiveSign, TEXT(""));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_STHOUSAND,
                        sz_sThousand,
                        MAX_STHOUSAND + 1 ))
    {
        _tcscpy(sz_sThousand, TEXT(","));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_IDIGITS,
                        sz_iDigits,
                        MAX_IDIGITS + 1 ))
    {
        _tcscpy(sz_iDigits, TEXT("2"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_ILZERO,
                        sz_iLZero,
                        MAX_ILZERO + 1 ))
    {
        _tcscpy(sz_iLZero, TEXT("2"));
    }
}


////////////////////////////////////////////////////////////////////////////
//
// Number_RestoreValues
//
////////////////////////////////////////////////////////////////////////////

void Number_RestoreValues()
{
    if (g_dwCustChange & Process_Num)
    {
        SetLocaleInfo(UserLocaleID, LOCALE_INEGNUMBER,         sz_iNegNumber);
        SetLocaleInfo(UserLocaleID, LOCALE_IMEASURE,           sz_iMeasure);
        SetLocaleInfo(UserLocaleID, LOCALE_IDIGITSUBSTITUTION, sz_NumShape);
        SetLocaleInfo(UserLocaleID, LOCALE_SDECIMAL,           sz_sDecimal);
        SetLocaleInfo(UserLocaleID, LOCALE_SGROUPING,          sz_sGrouping);
        SetLocaleInfo(UserLocaleID, LOCALE_SLIST,              sz_sList);
        SetLocaleInfo(UserLocaleID, LOCALE_SNATIVEDIGITS,      sz_sNativeDigits);
        SetLocaleInfo(UserLocaleID, LOCALE_SNEGATIVESIGN,      sz_sNegativeSign);
        SetLocaleInfo(UserLocaleID, LOCALE_SPOSITIVESIGN,      sz_sPositiveSign);
        SetLocaleInfo(UserLocaleID, LOCALE_STHOUSAND,          sz_sThousand);
        SetLocaleInfo(UserLocaleID, LOCALE_IDIGITS,            sz_iDigits);
        SetLocaleInfo(UserLocaleID, LOCALE_ILZERO,             sz_iLZero);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  Number_ClearValues
//
//  Reset each of the list boxes in the number property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Number_ClearValues(
    HWND hDlg)
{
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DECIMAL_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NEG_SIGN));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SEPARATOR));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DIGIT_GROUP_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NUM_DECIMAL_DIGITS));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NUM_DIGITS_GROUP));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DISPLAY_LEAD_0));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NEG_NUM_FORMAT));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_MEASURE_SYS));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NATIVE_DIGITS));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DIGIT_SUBST));
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_SetValues
//
//  Initialize all of the controls in the number property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Number_SetValues(
    HWND hDlg)
{
    HWND hCtrl1, hCtrl2;
    HKEY hKey;
    int Index, Ctr1, Ctr2;
    DWORD cbData;
    TCHAR szBuf[SIZE_128];
    const nMax_Array_Fill = (cInt_Str >= 10 ? 10 : cInt_Str);
    NUMBERFMT nfmt;
    TCHAR szThousandSep[SIZE_128];
    TCHAR szEmpty[]  = TEXT("");
    TCHAR szSample[] = TEXT("123456789");
    BOOL bShow;

    //
    //  ----------------------------------------------------------------------
    //  Initialize the dropdown box for the current locale setting for:
    //      Decimal Symbol
    //      Positive Sign
    //      Negative Sign
    //      List Separator
    //      Grouping Symbol
    //  ----------------------------------------------------------------------
    //
    DropDown_Use_Locale_Values(hDlg, LOCALE_SDECIMAL, IDC_DECIMAL_SYMBOL);
    DropDown_Use_Locale_Values(hDlg, LOCALE_SNEGATIVESIGN, IDC_NEG_SIGN);
    DropDown_Use_Locale_Values(hDlg, LOCALE_SLIST, IDC_SEPARATOR);
    DropDown_Use_Locale_Values(hDlg, LOCALE_STHOUSAND, IDC_DIGIT_GROUP_SYMBOL);

    //
    //  ----------------------------------------------------------------------
    //  Fill in the Number of Digits after Decimal Symbol drop down list
    //  with the values of 0 through 10.  Get the user locale value and
    //  make it the current selection.  If GetLocaleInfo fails, simply
    //  select the first item in the list.
    //  ----------------------------------------------------------------------
    //
    hCtrl1 = GetDlgItem(hDlg, IDC_NUM_DECIMAL_DIGITS);
    hCtrl2 = GetDlgItem(hDlg, IDC_NUM_DIGITS_GROUP);
    for (Index = 0; Index < nMax_Array_Fill; Index++)
    {
        ComboBox_InsertString(hCtrl1, -1, aInt_Str[Index]);
    }

    if (GetLocaleInfo(UserLocaleID, LOCALE_IDIGITS, szBuf, SIZE_128))
    {
        ComboBox_SelectString(hCtrl1, -1, szBuf);
    }
    else
    {
        ComboBox_SetCurSel(hCtrl1, 0);
    }

    //
    //  ----------------------------------------------------------------------
    //  Fill in the Number of Digits in "Thousands" Grouping's drop down
    //  list with the appropriate options.  Get the user locale value and
    //  make it the current selection.  If GetLocaleInfo fails, simply
    //  select the first item in the list.
    //  ----------------------------------------------------------------------
    //
    nfmt.NumDigits = 0;                // no decimal in sample string
    nfmt.LeadingZero = 0;              // no decimal in sample string
    nfmt.lpDecimalSep = szEmpty;       // no decimal in sample string
    nfmt.NegativeOrder = 0;            // not a negative value
    nfmt.lpThousandSep = szThousandSep;
    GetLocaleInfo(UserLocaleID, LOCALE_STHOUSAND, szThousandSep, SIZE_128);

    nfmt.Grouping = 0;
    GetNumberFormat(UserLocaleID, 0, szSample, &nfmt, szBuf, SIZE_128);
    ComboBox_InsertString(hCtrl2, -1, szBuf);

    nfmt.Grouping = 3;
    GetNumberFormat(UserLocaleID, 0, szSample, &nfmt, szBuf, SIZE_128);
    ComboBox_InsertString(hCtrl2, -1, szBuf);

    nfmt.Grouping = 32;
    GetNumberFormat(UserLocaleID, 0, szSample, &nfmt, szBuf, SIZE_128);
    ComboBox_InsertString(hCtrl2, -1, szBuf);

    if (GetLocaleInfo(UserLocaleID, LOCALE_SGROUPING, szBuf, SIZE_128) &&
        (szBuf[0]))
    {
        //
        //  Since only the values 0, 3;0, and 3;2;0 are allowed, simply
        //  ignore the ";#"s for subsequent groupings.
        //
        Index = 0;
        if (szBuf[0] == TEXT('3'))
        {
            if ((szBuf[1] == CHAR_SEMICOLON) && (szBuf[2] == TEXT('2')))
            {
                Index = 2;
            }
            else
            {
                Index = 1;
            }
        }
        else
        {
            //
            //  We used to allow the user to set #;0, where # is a value from
            //  0 - 9.  If it's 0, then fall through so that Index is 0.
            //
            if ((szBuf[0] > CHAR_ZERO) && (szBuf[0] <= CHAR_NINE) &&
                ((szBuf[1] == 0) || (lstrcmp(szBuf + 1, TEXT(";0")) == 0)))
            {
                nfmt.Grouping = szBuf[0] - CHAR_ZERO;
                if (GetNumberFormat(UserLocaleID, 0, szSample, &nfmt, szBuf, SIZE_128))
                {
                    Index = ComboBox_InsertString(hCtrl2, -1, szBuf);
                    if (Index >= 0)
                    {
                        ComboBox_SetItemData( hCtrl2,
                                              Index,
                                              (LPARAM)((DWORD)nfmt.Grouping) );
                    }
                    else
                    {
                        Index = 0;
                    }
                }
            }
        }
        ComboBox_SetCurSel(hCtrl2, Index);
    }
    else
    {
        ComboBox_SetCurSel(hCtrl2, 0);
    }

    //
    //  ----------------------------------------------------------------------
    //  Initialize and Lock function.  If it succeeds, call enum function to
    //  enumerate all possible values for the list box via a call to EnumProc.
    //  EnumProc will call Set_List_Values for each of the string values it
    //  receives.  When the enumeration of values is complete, call
    //  Set_List_Values to clear the dialog item specific data and to clear
    //  the lock on the function.  Perform this set of operations for:
    //  Display Leading Zeros, Negative Number Format, and Measurement Systems.
    //  ----------------------------------------------------------------------
    //
    if (Set_List_Values(hDlg, IDC_DISPLAY_LEAD_0, 0))
    {
        EnumLeadingZeros(EnumProcEx, UserLocaleID, 0);
        Set_List_Values(0, IDC_DISPLAY_LEAD_0, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_ILZERO, szBuf, SIZE_128))
        {
            ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_DISPLAY_LEAD_0),
                                Intl_StrToLong(szBuf) );
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }
    if (Set_List_Values(hDlg, IDC_NEG_NUM_FORMAT, 0))
    {
        EnumNegNumFmt(EnumProcEx, UserLocaleID, 0);
        Set_List_Values(0, IDC_NEG_NUM_FORMAT, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_INEGNUMBER, szBuf, SIZE_128))
        {
            ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_NEG_NUM_FORMAT),
                                Intl_StrToLong(szBuf) );
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }
    if (Set_List_Values(hDlg, IDC_MEASURE_SYS, 0))
    {
        EnumMeasureSystem(EnumProc, UserLocaleID, 0);
        Set_List_Values(0, IDC_MEASURE_SYS, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_IMEASURE, szBuf, SIZE_128))
        {
            ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_MEASURE_SYS),
                                Intl_StrToLong(szBuf) );
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }

    //
    //  ----------------------------------------------------------------------
    //  Fill in the "Native Digits" dropdown and set the current selection.
    //  Only show this combo box if there is more than one entry in the list.
    //  ----------------------------------------------------------------------
    //
    hCtrl1 = GetDlgItem(hDlg, IDC_NATIVE_DIGITS);
    ComboBox_AddString( hCtrl1,
                        bLPKInstalled
                          ? LPK_EUROPEAN_DIGITS
                          : EUROPEAN_DIGITS );
    ComboBox_SetCurSel(hCtrl1, 0);

    //
    //  Go through the language groups to see which ones have extra native
    //  digits options.
    //
    //  Entry 0 in c_szNativeDigits is the European option.  If any entries
    //  in c_szDigitsPerLangGroup are 0 (European), then ignore them as the
    //  European option is always enabled.
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      LANGUAGE_GROUPS_KEY,
                      0L,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        for (Ctr1 = 1; Ctr1 < MAX_LANG_GROUPS; Ctr1++)
        {
            //
            //  This assumes that if the first entry of
            //  c_szDigitsPerLangGroup is 0, then all other entries are 0.
            //
            if (c_szDigitsPerLangGroup[Ctr1][0] != 0)
            {
                //
                //  See if the language group is installed.
                //
                cbData = 0;
                wsprintf(szBuf, TEXT("%x"), Ctr1);
                RegQueryValueEx(hKey, szBuf, NULL, NULL, NULL, &cbData);
                if (cbData > sizeof(TCHAR))
                {
                    //
                    //  Installed, so add the native digit options to
                    //  the combo box.
                    //
                    for (Ctr2 = 0; Ctr2 < MAX_DIGITS_PER_LG; Ctr2++)
                    {
                        if ((Index = c_szDigitsPerLangGroup[Ctr1][Ctr2]) != 0)
                        {
                            if (ComboBox_FindStringExact(
                                            hCtrl1,
                                            -1,
                                            c_szNativeDigits[Index] ) == CB_ERR)
                            {
                                ComboBox_AddString( hCtrl1,
                                                    c_szNativeDigits[Index] );
                            }
                        }
                    }
                }
            }
        }
        RegCloseKey(hKey);
    }

    //
    //  Add the current user's Native Digits option if it's not already
    //  in the combo box.
    //
    if (GetLocaleInfo( UserLocaleID,
                       LOCALE_SNATIVEDIGITS,
                       szBuf,
                       SIZE_128 ) &&
        (!Number_IsEuropeanDigits(szBuf)))
    {
        if ((Index = ComboBox_FindStringExact(hCtrl1, -1, szBuf)) == CB_ERR)
        {
            Index = ComboBox_AddString(hCtrl1, szBuf);
        }
        if (Index != CB_ERR)
        {
            ComboBox_SetCurSel(hCtrl1, Index);
        }
    }

    //
    //  Add the default Native Digits option for the user's chosen locale
    //  if it's not already in the combo box.
    //
    if (GetLocaleInfo( UserLocaleID,
                       LOCALE_SNATIVEDIGITS | LOCALE_NOUSEROVERRIDE,
                       szBuf,
                       SIZE_128 ) &&
        (!Number_IsEuropeanDigits(szBuf)))
    {
        if (ComboBox_FindStringExact(hCtrl1, -1, szBuf) == CB_ERR)
        {
            ComboBox_AddString(hCtrl1, szBuf);
        }
    }

    //
    //  Disable the control if there is only 1 entry in the list.
    //
    bShow = ComboBox_GetCount(hCtrl1) > 1;
    EnableWindow(GetDlgItem(hDlg, IDC_NATIVE_DIGITS_TEXT), bShow);
    EnableWindow(GetDlgItem(hDlg, IDC_NATIVE_DIGITS), bShow);
    ShowWindow(GetDlgItem(hDlg, IDC_NATIVE_DIGITS_TEXT), bShow ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_NATIVE_DIGITS), bShow ? SW_SHOW : SW_HIDE);

    //
    //  ----------------------------------------------------------------------
    //  Fill in the "Digit Substitution" dropdown and set the current
    //  selection.  Only show this combo box if a language pack is installed.
    //  ----------------------------------------------------------------------
    //
    hCtrl1 = GetDlgItem(hDlg, IDC_DIGIT_SUBST);
    for (Index = 0; Index <= MAX_DIGIT_SUBST; Index++)
    {
        LoadString(hInstance, IDS_DIGIT_SUBST_CONTEXT + Index, szBuf, SIZE_128);
        ComboBox_InsertString(hCtrl1, Index, szBuf);
    }

    ComboBox_SetCurSel( hCtrl1,
                        Number_GetDigitSubstitution() );

    EnableWindow(GetDlgItem(hDlg, IDC_DIGIT_SUBST_TEXT), bLPKInstalled);
    EnableWindow(hCtrl1, bLPKInstalled);
    ShowWindow(GetDlgItem(hDlg, IDC_DIGIT_SUBST_TEXT), bLPKInstalled ? SW_SHOW : SW_HIDE);
    ShowWindow(hCtrl1, bLPKInstalled ? SW_SHOW : SW_HIDE);

    //
    //  ----------------------------------------------------------------------
    //  Display the current sample that represents all of the locale settings.
    //  ----------------------------------------------------------------------
    //
    Number_DisplaySample(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_ApplySettings
//
//  For every control that has changed (that affects the Locale settings),
//  call Set_Locale_Values to update the user locale information.
//  Notify the parent of changes and reset the change flag stored in the
//  property sheet page structure appropriately.  Redisplay the number
//  sample if bRedisplay is TRUE.
//
////////////////////////////////////////////////////////////////////////////

BOOL Number_ApplySettings(
    HWND hDlg,
    BOOL bRedisplay)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;

    if (Changes & NC_DSymbol)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SDECIMAL,
                                IDC_DECIMAL_SYMBOL,
                                TEXT("sDecimal"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_NSign)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SNEGATIVESIGN,
                                IDC_NEG_SIGN,
                                0,
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_SList)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SLIST,
                                IDC_SEPARATOR,
                                TEXT("sList"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_SThousand)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_STHOUSAND,
                                IDC_DIGIT_GROUP_SYMBOL,
                                TEXT("sThousand"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_IDigits)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_IDIGITS,
                                IDC_NUM_DECIMAL_DIGITS,
                                TEXT("iDigits"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_DGroup)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SGROUPING,
                                IDC_NUM_DIGITS_GROUP,
                                0,
                                TRUE,
                                0,
                                TEXT(";0"),
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_LZero)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_ILZERO,
                                IDC_DISPLAY_LEAD_0,
                                TEXT("iLzero"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_NegFmt)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_INEGNUMBER,
                                IDC_NEG_NUM_FORMAT,
                                0,
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_Measure)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_IMEASURE,
                                IDC_MEASURE_SYS,
                                TEXT("iMeasure"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_NativeDigits)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SNATIVEDIGITS,
                                IDC_NATIVE_DIGITS,
                                TEXT("sNativeDigits"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_DigitSubst)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_IDIGITSUBSTITUTION,
                                IDC_DIGIT_SUBST,
                                TEXT("NumShape"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }

    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    lpPropSheet->lParam = NC_EverChg;

    //
    //  Display the current sample that represents all of the locale settings.
    //
    if (bRedisplay)
    {
        Number_ClearValues(hDlg);
        Number_SetValues(hDlg);
    }

    //
    //  Changes made in the second level.
    //
    if (Changes)
    {
        g_dwCustChange |= Process_Num;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Number_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= NC_EverChg)
    {
        return (TRUE);
    }

    //
    //  If the decimal symbol has changed, ensure that there are no digits
    //  contained in the new symbol.
    //
    if (Changes & NC_DSymbol &&
        Item_Has_Digits(hDlg, IDC_DECIMAL_SYMBOL, FALSE))
    {
        No_Numerals_Error(hDlg, IDC_DECIMAL_SYMBOL, IDS_LOCALE_DECIMAL_SYM);
        return (FALSE);
    }

    //
    //  If the negative sign symbol has changed, ensure that there are no
    //  digits contained in the new symbol.
    //
    if (Changes & NC_NSign &&
        Item_Has_Digits(hDlg, IDC_NEG_SIGN, TRUE))
    {
        No_Numerals_Error(hDlg, IDC_NEG_SIGN, IDS_LOCALE_NEG_SIGN);
        return (FALSE);
    }

    //
    //  If the thousands grouping symbol has changed, ensure that there
    //  are no digits contained in the new symbol.
    //
    if (Changes & NC_SThousand &&
        Item_Has_Digits(hDlg, IDC_DIGIT_GROUP_SYMBOL, FALSE))
    {
        No_Numerals_Error(hDlg, IDC_DIGIT_GROUP_SYMBOL, IDS_LOCALE_GROUP_SYM);
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Number_SetValues with the property
//  sheet handle to initialize all of the property sheet controls.
//  Constrain the size of certain ComboBox text sizes.
//
////////////////////////////////////////////////////////////////////////////

void Number_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    //
    //  The lParam holds a pointer to the property sheet page, save it for
    //  later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    Number_SetValues(hDlg);

    ComboBox_LimitText(GetDlgItem(hDlg, IDC_NEG_SIGN),           MAX_SNEGSIGN);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_DECIMAL_SYMBOL),     MAX_SDECIMAL);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_DIGIT_GROUP_SYMBOL), MAX_STHOUSAND);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_SEPARATOR),          MAX_SLIST);
}


////////////////////////////////////////////////////////////////////////////
//
//  NumberDlgProc
//
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK NumberDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch (message)
    {
        case ( WM_NOTIFY ) :
        {
            lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Num)
                    {
                        Verified_Regional_Chg &= ~Process_Num;
                        Number_ClearValues(hDlg);
                        Number_SetValues(hDlg);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                   DWLP_MSGRESULT,
                                   !Number_ValidatePPS( hDlg,
                                                        lpPropSheet->lParam ) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Number_ApplySettings(hDlg, TRUE))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        //
                        //  Zero out the NC_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                       DWLP_MSGRESULT,
                                       PSNRET_INVALID_NOCHANGEPAGE );
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            Number_InitPropSheet(hDlg, lParam);
            Number_SaveValues();
            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aNumberHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aNumberHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_DECIMAL_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= NC_DSymbol;
                    }
                    break;
                }
                case ( IDC_NEG_SIGN ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= NC_NSign;
                    }
                    break;
                }
                case ( IDC_SEPARATOR ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= NC_SList;
                    }
                    break;
                }
                case ( IDC_DIGIT_GROUP_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= NC_SThousand;
                    }
                    break;
                }
                case ( IDC_NUM_DECIMAL_DIGITS ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_IDigits;
                    }
                    break;
                }
                case ( IDC_NUM_DIGITS_GROUP ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_DGroup;
                    }
                    break;
                }
                case ( IDC_DISPLAY_LEAD_0 ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_LZero;
                    }
                    break;
                }
                case ( IDC_NEG_NUM_FORMAT ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_NegFmt;
                    }
                    break;
                }
                case ( IDC_MEASURE_SYS ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_Measure;
                    }
                    break;
                }
                case ( IDC_NATIVE_DIGITS ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_NativeDigits;
                    }
                    break;
                }
                case ( IDC_DIGIT_SUBST ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_DigitSubst;
                    }
                    break;
                }
            }

            //
            //  Turn on ApplyNow button.
            //
            if (lpPropSheet->lParam > NC_EverChg)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\applet.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    applet.h

Abstract:

    This module contains the main header information for this project.

Revision History:

--*/



#ifndef _APPLETS_H
#define _APPLETS_H



//
//  The prototype for an applet function is:
//    int Applet(HINSTANCE instance, HWND parent, LPCTSTR cmdline);
//
//  instance - The instance handle of the control panel containing the applet.
//
//  parent   - Contains the handle of a parent window for the applet (if any).
//
//  cmdline  - Points to the command line for the applet (if available).
//             If the applet was launched without a command line,
//             'cmdline' contains NULL.
//

typedef int (*PFNAPPLET)(HINSTANCE, HWND, LPCTSTR);


//
//  The return value specifies any further action that must be taken:
//      APPLET_RESTART -- Windows must be restarted
//      APPLET_REBOOT  -- the machine must be rebooted
//      all other values are ignored
//

#define APPLET_RESTART            0x8
#define APPLET_REBOOT             (APPLET_RESTART | 0x4)


//
//  The prototype for an applet query functions is:
//      LRESULT AppletQuery(UINT Message);
//

typedef LRESULT (*PFNAPPLETQUERY)(HWND, UINT);

#define APPLET_QUERY_EXISTS       0   //  BOOL result
#define APPLET_QUERY_GETICON      1   //  HICON result



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\intlhlp.h ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    intlhlp.h

Abstract:

    This module contains the help context ids for the Regional Options
    applet.

Revision History:

--*/



//
//  From help.h.
//
#define NO_HELP               ((DWORD) -1)  // Disables Help for a control

#define IDH_COMM_GROUPBOX              28548



//
//  Values must be in the range 3300 - 3499.
//

// General tab
#define IDH_INTL_GEN_CULTURE                3302
#define IDH_INTL_GEN_REGION                 3303
#define IDH_INTL_GEN_CUSTOMIZE              3304
#define IDH_INTL_GEN_SAMPLE                 3305

// Language tab
#define IDH_INTL_LANG_UI_LANGUAGE           3311
#define IDH_INTL_LANG_CHANGE                3312
#define IDH_INTL_LANG_INSTALL               3313

// Advanced tab
#define IDH_INTL_ADV_SYSTEM_LOCALE          3321
#define IDH_INTL_ADV_CODEPAGES              3322
#define IDH_INTL_ADV_CHANGE                 3323

// Time tab
#define IDH_INTL_TIME_SAMPLE                3331
#define IDH_INTL_TIME_AMSYMBOL              3332
#define IDH_INTL_TIME_PMSYMBOL              3333
#define IDH_INTL_TIME_SEPARATOR             3334
#define IDH_INTL_TIME_FORMAT_NOTATION       3335
#define IDH_INTL_TIME_SAMPLE_ARABIC         3336
#define IDH_INTL_TIME_FORMAT                3337

// Number tab
#define IDH_INTL_NUM_POSVALUE               3341
#define IDH_INTL_NUM_NEGVALUE               3342
#define IDH_INTL_NUM_DECSYMBOL              3343
#define IDH_INTL_NUM_DIGITSAFTRDEC          3344
#define IDH_INTL_NUM_DIGITGRPSYMBOL         3345
#define IDH_INTL_NUM_DIGITSINGRP            3346
#define IDH_INTL_NUM_NEGSIGNSYMBOL          3347
#define IDH_INTL_NUM_DISPLEADZEROS          3348
#define IDH_INTL_NUM_NEGNUMFORMAT           3349
#define IDH_INTL_NUM_MEASUREMNTSYS          3350
#define IDH_INTL_NUM_LISTSEPARATOR          3351
#define IDH_INTL_NUM_POSVALUE_ARABIC        3352
#define IDH_INTL_NUM_NEGVALUE_ARABIC        3353
#define IDH_INTL_NUM_NATIVE_DIGITS          3354
#define IDH_INTL_NUM_DIGIT_SUBST            3355

// Currency tab
#define IDH_INTL_CURR_POSVALUE              3361
#define IDH_INTL_CURR_NEGVALUE              3362
#define IDH_INTL_CURR_SYMBOL                3363
#define IDH_INTL_CURR_POSOFSYMBOL           3364
#define IDH_INTL_CURR_NEGNUMFMT             3365
#define IDH_INTL_CURR_DECSYMBOL             3366
#define IDH_INTL_CURR_DIGITSAFTRDEC         3367
#define IDH_INTL_CURR_DIGITGRPSYMBOL        3368
#define IDH_INTL_CURR_DIGITSINGRP           3369

// Date tab
#define IDH_INTL_DATE_SHORTSAMPLE           3370
#define IDH_INTL_DATE_SEPARATOR             3371
#define IDH_INTL_DATE_LONGSAMPLE            3372
#define IDH_INTL_DATE_LONGSTYLE             3373
#define IDH_INTL_DATE_SHORTSTYLE            3374
#define IDH_INTL_DATE_CALENDARTYPE          3375
#define IDH_INTL_DATE_SHORTSAMPLE_ARABIC    3376
#define IDH_INTL_DATE_LONGSAMPLE_ARABIC     3377
#define IDH_INTL_DATE_ADD_HIJRI_DATE        3378
#define IDH_INTL_DATE_TWO_DIGIT_YEAR        3379

// Sorting
#define IDH_INTL_SORT_SORTING               3381
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\drvaplet.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    drvaplet.h

Abstract:

    This module contains the header information for the driver routines
    for the project.

Revision History:

--*/



#ifndef _DRVAPLET_H
#define _DRVAPLET_H


//
//  HDAP: handle to a driver applet.
//

DECLARE_HANDLE(HDAP);


//
//  GetDriverModule: gets the module.
//
HMODULE GetDriverModule(LPCTSTR name);

//
// ReleaseDriverModule:  releases the module.
//
void ReleaseDriverModule(HMODULE module);

//
//  OpenDriverApplet: opens a handle to the named driver applet.
//
HDAP OpenDriverApplet(LPCTSTR);


//
//  CloseDriverApplet: closes a handle to a driver applet.
//
void CloseDriverApplet(HDAP);


//
//  GetDriverAppletIcon: get's a driver applet's icon (if any).
//
HICON GetDriverAppletIcon(HDAP);


//
//  CallDriverApplet: sends a message to the driver applet (CplApplet syntax).
//
LRESULT CallDriverApplet(HDAP, HWND, UINT, LPARAM, LPARAM);


//
//  RunDriverApplet: runs the driver applet.
//
#define RunDriverApplet(h, w)  CallDriverApplet(h, w, CPL_DBLCLK, 0L, 0L)


//
//  "CplApplet"
//
extern const TCHAR *c_szCplApplet;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\regdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    regdlg.c

Abstract:

    This module implements the general property sheet for the Regional
    Options applet.

Revision History:


--*/



//
//  Include Files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "intl.h"
#include "winnlsp.h"
#include <windowsx.h>
#include <regstr.h>
#include <tchar.h>
#include <stdlib.h>
#include <setupapi.h>
#include <syssetup.h>
#include <winuserp.h>
#include <userenv.h>
#include "intlhlp.h"
#include "maxvals.h"
#include "util.h"


//
//  Constant Declarations.
//

#define MAX_CUSTOM_PAGES 5          // limit on number of second level pages

//
//  TEMPO
//
static TCHAR szLayoutFile[]    = TEXT("layout file");


//
//  Global Variables.
//
DWORD g_savedLocaleId;


//
//  Context Help Ids.
//

static int aRegionHelpIds[] =
{
    IDC_GROUPBOX1,        IDH_COMM_GROUPBOX,
    IDC_USER_LOCALE_TEXT, IDH_INTL_GEN_CULTURE,
    IDC_USER_LOCALE,      IDH_INTL_GEN_CULTURE,
    IDC_USER_REGION_TEXT, IDH_INTL_GEN_REGION,
    IDC_USER_REGION,      IDH_INTL_GEN_REGION,
    IDC_CUSTOMIZE,        IDH_INTL_GEN_CUSTOMIZE,
    IDC_SAMPLE_TEXT,      IDH_INTL_GEN_SAMPLE,
    IDC_TEXT1,            IDH_INTL_GEN_SAMPLE,
    IDC_TEXT2,            IDH_INTL_GEN_SAMPLE,
    IDC_TEXT3,            IDH_INTL_GEN_SAMPLE,
    IDC_TEXT4,            IDH_INTL_GEN_SAMPLE,
    IDC_TEXT5,            IDH_INTL_GEN_SAMPLE,
    IDC_TEXT6,            IDH_INTL_GEN_SAMPLE,
    IDC_NUMBER_SAMPLE,    IDH_INTL_GEN_SAMPLE,
    IDC_CURRENCY_SAMPLE,  IDH_INTL_GEN_SAMPLE,
    IDC_TIME_SAMPLE,      IDH_INTL_GEN_SAMPLE,
    IDC_SHRTDATE_SAMPLE,  IDH_INTL_GEN_SAMPLE,
    IDC_LONGDATE_SAMPLE,  IDH_INTL_GEN_SAMPLE,

    0, 0
};




//
//  Function Prototypes.
//

void
Region_ShowSettings(
    HWND hDlg,
    LCID lcid);

int
Region_CommandCustomize(
    HWND hDlg,
    LPREGDLGDATA pDlgData);


////////////////////////////////////////////////////////////////////////////
//
//  Region_EnumAlternateSorts
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_EnumAlternateSorts()
{
    LPLANGUAGEGROUP pLG;
    UINT ctr;

    //
    //  Initialize the globals for the alternate sort locales.
    //
    if (!pAltSorts)
    {
        if (!(hAltSorts = GlobalAlloc(GHND, MAX_PATH * sizeof(DWORD))))
        {
            return (FALSE);
        }
        pAltSorts = GlobalLock(hAltSorts);
    }

    //
    //  Reset the global counter so that we don't get duplicates each time
    //  this gets called.  We need to update the list each time in case any
    //  language groups get added or removed.
    //
    g_NumAltSorts = 0;

    //
    //  Go through the language groups to see which ones are installed.
    //  Save the alternate sorts for these language groups.
    //
    pLG = pLanguageGroups;
    while (pLG)
    {
        //
        //  If the language group is originally installed and not marked for
        //  removal OR is marked to be installed, then add the locales for
        //  this language group to the System and User combo boxes.
        //
        if (pLG->wStatus & ML_INSTALL)
        {
            for (ctr = 0; ctr < pLG->NumAltSorts; ctr++)
            {
                //
                //  Save the locale id.
                //
                if (g_NumAltSorts >= MAX_PATH)
                {
                    return (TRUE);
                }
                pAltSorts[g_NumAltSorts] = (pLG->pAltSortList)[ctr];
                g_NumAltSorts++;
            }
        }
        pLG = pLG->pNext;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_EnableSortingPanel
//
////////////////////////////////////////////////////////////////////////////

void Region_EnableSortingPanel(
    HWND hDlg)
{
    LCID LocaleID;
    LANGID LangID;
    int ctr;
    int sortCount = 0;

    //
    //  Get the language id from the locale id.
    //
    LangID = LANGIDFROMLCID( UserLocaleID );

    //
    //  Special case Spanish (Spain) - list International sort first.
    //
    if ((LangID == LANG_SPANISH_TRADITIONAL) || (LangID == LANG_SPANISH_INTL))
    {
        g_bShowSortingTab = TRUE;
        return;
    }

    //
    //  Fill in the drop down if necessary.
    //
    for (ctr = 0; ctr < g_NumAltSorts; ctr++)
    {
        LocaleID = pAltSorts[ctr];
        if (LANGIDFROMLCID(LocaleID) == LangID)
        {
            sortCount++;
        }
    }

    //
    //  Enable the combo box if there is more than one entry in the list.
    //  Otherwise, disable it.
    //
    if (sortCount >= 1)
    {
        g_bShowSortingTab = TRUE;
    }
    else
    {
        g_bShowSortingTab = FALSE;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_SetRegionListValues
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_SetRegionListValues(
    GEOID GeoId,
    HWND handle)
{
    static HWND hUserRegion = NULL;
    DWORD dwIndex;
    WCHAR szBuf[SIZE_300];

    if (!GeoId)
    {
        hUserRegion = handle;
    }
    else if (hUserRegion)
    {
        if (GetGeoInfo(GeoId, GEO_FRIENDLYNAME, szBuf, SIZE_300, 0))
        {
            dwIndex = ComboBox_AddString(hUserRegion, szBuf);
            if (dwIndex != CB_ERR)
            {
                ComboBox_SetItemData(hUserRegion, dwIndex, GeoId);
            }
        }
    }
    else
    {
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_EnumProc
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_EnumProc(
    GEOID GeoId)
{
    return (Region_SetRegionListValues(GeoId, NULL));
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_EnumRegions
//
////////////////////////////////////////////////////////////////////////////

void Region_EnumRegions(
    HWND hUserRegion)
{
    //
    //  Fill in the UI.
    //
    Region_SetRegionListValues(0, hUserRegion);
    EnumSystemGeoID(GEOCLASS_NATION, 0, Region_EnumProc);
    Region_SetRegionListValues(0, NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_SaveValues
//
//  Save values in the case that we need to restore them.
//
////////////////////////////////////////////////////////////////////////////

void Region_SaveValues()
{
    //
    //  Save locale values.
    //
    g_savedLocaleId = RegUserLocaleID;
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_ApplyValues
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_ApplyValues(
    HWND hDlg,
    LPREGDLGDATA pDlgData)
{
    DWORD dwLocale;
    LCID NewLocale;
    HCURSOR hcurSave;
    HWND hUserLocale = GetDlgItem(hDlg, IDC_USER_LOCALE);

    //
    //  See if there are any changes.
    //
    if (pDlgData->Changes <= RC_EverChg)
    {
        return (TRUE);
    }

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  See if there are any changes to the user locale.
    //
    if (pDlgData->Changes & RC_UserLocale)
    {
        //
        //  Get the current selections.
        //
        dwLocale = ComboBox_GetCurSel(hUserLocale);

        //
        //  See if the current selections are different from the original
        //  selections.
        //
        if ((dwLocale != CB_ERR) && (dwLocale != pDlgData->dwCurUserLocale))
        {
            //
            //  Get the locale id for the current selection.
            //
            NewLocale = (LCID)ComboBox_GetItemData(hUserLocale, dwLocale);

            //
            //  Set the current locale values in the pDlgData structure.
            //
            pDlgData->dwCurUserLocale = dwLocale;

            //
            //  Save the new locale information.
            //
            UserLocaleID = NewLocale;
            bShowRtL = IsRtLLocale(UserLocaleID);
            bHebrewUI = (PRIMARYLANGID(UserLocaleID) == LANG_HEBREW);
            bShowArabic = (bShowRtL && (PRIMARYLANGID(LANGIDFROMLCID(UserLocaleID)) != LANG_HEBREW));

            //
            //  Install the new locale by adding the appropriate information
            //  to the registry.
            //
            Intl_InstallUserLocale( NewLocale, FALSE, TRUE);

            //
            //  Update the NLS process cache.
            //
            NlsResetProcessLocale();

            //
            //  Reset the registry user locale value.
            //
            RegUserLocaleID = UserLocaleID;
        }
    }

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_RestoreValues
//
////////////////////////////////////////////////////////////////////////////

void Region_RestoreValues()
{
    //
    //  See if the current selections are different from the original
    //  selections.
    //
    if (UserLocaleID != g_savedLocaleId)
    {
        //
        //  Install the new locale by adding the appropriate information
        //  to the registry.
        //
        Intl_InstallUserLocale(g_savedLocaleId, FALSE, TRUE);

        //
        //  Update the NLS process cache.
        //
        NlsResetProcessLocale();

        //
        //  Reset the registry user locale value.
        //
        UserLocaleID = g_savedLocaleId;
        RegUserLocaleID = g_savedLocaleId;

        //
        //  Need to make sure the proper keyboard layout is installed.
        //
        Intl_InstallKeyboardLayout(NULL, g_savedLocaleId, 0, FALSE, FALSE, FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_ClearValues
//
//  Reset each of the list boxes in the region property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Region_ClearValues(
    HWND hDlg)
{
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_USER_LOCALE));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_USER_REGION));
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_SetValues
//
//  Initialize all of the controls in the region property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Region_SetValues(
    HWND hDlg,
    LPREGDLGDATA pDlgData,
    BOOL fInit)
{
    TCHAR szUserBuf[SIZE_128];
    GEOID geoID = GEOID_NOT_AVAILABLE;
    TCHAR szDefaultUserBuf[SIZE_128];
    TCHAR szLastUserBuf[SIZE_128];
    TCHAR szBuf[SIZE_128];
    DWORD dwIndex;
    HWND hUserLocale = GetDlgItem(hDlg, IDC_USER_LOCALE);
    HWND hUserRegion = GetDlgItem(hDlg, IDC_USER_REGION );
    DWORD dwItemCount;

    //
    //  Get the strings to search for in the combo boxes in order to set
    //  the current selections.
    //
    if (fInit)
    {
        //
        //  It's init time, so get the local user's default settings.
        //
        if ((UserLocaleID == LCID_SPANISH_TRADITIONAL) ||
            (UserLocaleID == LCID_SPANISH_INTL))
        {
            LoadString(hInstance, IDS_SPANISH_NAME, szUserBuf, SIZE_128);
        }
        else
        {
            GetLocaleInfo(UserLocaleID, LOCALE_SLANGUAGE, szUserBuf, SIZE_128);
        }

        //
        //  It's init time, so get the region user default settings.
        //
        geoID = GetUserGeoID(GEOCLASS_NATION);
    }
    else
    {
        //
        //  It's not init time, so get the settings from the combo boxes.
        //
        ComboBox_GetLBText( hUserLocale,
                            ComboBox_GetCurSel(hUserLocale),
                            szUserBuf );
        geoID = (GEOID)ComboBox_GetItemData( hUserRegion,
                                             ComboBox_GetCurSel(hUserRegion));

        if (pDlgData)
        {
            ComboBox_GetLBText( hUserLocale,
                                pDlgData->dwCurUserLocale,
                                szDefaultUserBuf );
            ComboBox_GetLBText( hUserLocale,
                                pDlgData->dwLastUserLocale,
                                szLastUserBuf );
        }
    }

    //
    //  Reset the combo boxes.
    //
    Region_ClearValues(hDlg);

    //
    //  Get the list of locales and fill in the user locale combo box.
    //
    Intl_EnumLocales(hDlg, hUserLocale, FALSE);

    //
    //  Select the current user locale id in the list.
    //  Special case Spanish.
    //
    dwIndex = ComboBox_FindStringExact(hUserLocale, -1, szUserBuf);
    if (dwIndex == CB_ERR)
    {
        szBuf[0] = 0;
        GetLocaleInfo(SysLocaleID, LOCALE_SLANGUAGE, szBuf, SIZE_128);
        dwIndex = ComboBox_FindStringExact(hUserLocale, -1, szBuf);
        if (dwIndex == CB_ERR)
        {
            GetLocaleInfo(US_LOCALE, LOCALE_SLANGUAGE, szBuf, SIZE_128);
            dwIndex = ComboBox_FindStringExact(hUserLocale, -1, szBuf);
            if (dwIndex == CB_ERR)
            {
                dwIndex = 0;
            }
        }
        if (!fInit && pDlgData)
        {
            pDlgData->Changes |= RC_UserLocale;
        }
    }
    ComboBox_SetCurSel(hUserLocale, dwIndex);

    //
    //  Get the list of regions and fill in the region combo box.
    //
    Region_EnumRegions(hUserRegion);

    //
    //  Select the current user region in the list.
    //
    dwItemCount = (DWORD)ComboBox_GetCount(hUserRegion);
    dwIndex = 0;
    while(dwIndex < dwItemCount)
    {
        if (ComboBox_GetItemData(hUserRegion,dwIndex) == geoID)
        {
            ComboBox_SetCurSel(hUserRegion, dwIndex);
            break;
        }
        dwIndex++;
    }

    //
    //  If it's fail, try with User Locale.
    //
    if(dwIndex >= dwItemCount)
    {
        //
        //  Get the GEOID associated with the User Locale.
        //
        szBuf[0] = 0;
        GetLocaleInfo(UserLocaleID, LOCALE_IGEOID | LOCALE_RETURN_NUMBER, szBuf, SIZE_128);
        geoID = *((LPDWORD)szBuf);

        //
        //  Search for it...
        //
        dwIndex = 0;
        while(dwIndex < dwItemCount)
        {
            if (ComboBox_GetItemData(hUserRegion,dwIndex) == geoID)
            {
                //
                //  Note:
                //  Mark this as being changed so that the region will be set
                //  when the user hits apply.  This avoids the problem of having
                //  the region change every time the user closes and reopens the
                //  applet after changing the user locale.
                //
                if (pDlgData)
                {
                    pDlgData->Changes |= RC_UserRegion;
                }
                ComboBox_SetCurSel(hUserRegion, dwIndex);
                break;
            }
            dwIndex++;
        }
    }

    //
    //  If it's fail, try with System Locale.
    //
    if(dwIndex >= dwItemCount)
    {
        //
        //  Get the GEOID associated with the User Locale.
        //
        szBuf[0] = 0;
        GetLocaleInfo(SysLocaleID, LOCALE_IGEOID | LOCALE_RETURN_NUMBER, szBuf, SIZE_128);
        geoID = *((LPDWORD)szBuf);

        //
        //  Search for it...
        //
        dwIndex = 0;
        while(dwIndex < dwItemCount)
        {
            if (ComboBox_GetItemData(hUserRegion,dwIndex) == geoID)
            {
                //
                //  Note:
                //  Mark this as being changed so that the region will be set
                //  when the user hits apply.  This avoids the problem of having
                //  the region change every time the user closes and reopens the
                //  applet after changing the user locale.
                //
                if (pDlgData)
                {
                    pDlgData->Changes |= RC_UserRegion;
                }
                ComboBox_SetCurSel(hUserRegion, dwIndex);
                break;
            }
            dwIndex++;
        }
    }

    //
    //  If it's fail, try with US Locale.
    //
    if(dwIndex >= dwItemCount)
    {
        //
        //  Get the GEOID associated with the User Locale.
        //
        szBuf[0] = 0;
        GetLocaleInfo(US_LOCALE, LOCALE_IGEOID | LOCALE_RETURN_NUMBER, szBuf, SIZE_128);
        geoID = *((LPDWORD)szBuf);

        //
        //  Search for it...
        //
        dwIndex = 0;
        while(dwIndex >= dwItemCount)
        {
            if (ComboBox_GetItemData(hUserRegion,dwIndex) == geoID)
            {
                //
                //  Note:
                //  Mark this as being changed so that the region will be set
                //  when the user hits apply.  This avoids the problem of having
                //  the region change every time the user closes and reopens the
                //  applet after changing the user locale.
                //
                if (pDlgData)
                {
                    pDlgData->Changes |= RC_UserRegion;
                }
                ComboBox_SetCurSel(hUserRegion, dwIndex);
                break;
            }
            dwIndex++;
        }
    }

    //
    //  If it's fail, set to the first item.
    //
    if(dwIndex >= dwItemCount)
    {
        //
        //  Note:
        //  Mark this as being changed so that the region will be set
        //  when the user hits apply.  This avoids the problem of having
        //  the region change every time the user closes and reopens the
        //  applet after changing the user locale.
        //
        if (pDlgData)
        {
            pDlgData->Changes |= RC_UserRegion;
        }
        ComboBox_SetCurSel(hUserRegion, 0);
    }

    //
    //  Store the initial locale state in the pDlgData structure.
    //
    if (pDlgData)
    {
        //
        //  Set the current user locale and the last user locale.
        //
        if (fInit)
        {
            pDlgData->dwCurUserLocale = ComboBox_GetCurSel(hUserLocale);
            pDlgData->dwLastUserLocale = pDlgData->dwCurUserLocale;
        }
        else
        {
            pDlgData->dwCurUserLocale =  ComboBox_FindStringExact(hUserLocale, -1, szDefaultUserBuf);
            pDlgData->dwLastUserLocale = ComboBox_FindStringExact(hUserLocale, -1, szLastUserBuf);
        }

        //
        //  Set the current region selection.
        //
        //  Note:  The current region is only set if there is actually
        //         a region set in the registry.  Otherwise, if the
        //         selection is based off of the user locale, then we
        //         don't set this so that it will get set when the user
        //         hits Apply.  See above note.
        //
        if (pDlgData->Changes & RC_UserRegion)
        {
            pDlgData->dwCurUserRegion = CB_ERR;
        }
        else
        {
            pDlgData->dwCurUserRegion = ComboBox_GetCurSel(hUserRegion);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_RevertChanges
//
//  If the user has changed something at the second level, call
//  Set_Locale_Values to restore the user locale information.
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_RevertChanges()
{
    HCURSOR hcurSave;

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor( LoadCursor(NULL, IDC_WAIT) );

    //
    //  Revert any changes.
    //
    if (g_dwCustChange)
    {
        DWORD dwRecipients;

        //
        //  Revert changes.
        //
        Date_RestoreValues();
        Currency_RestoreValues();
        Time_RestoreValues();
        Number_RestoreValues();
        Sorting_RestoreValues();
    }

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_ApplySettings
//
//  If the Locale has changed, call Set_Locale_Values to update the
//  user locale information.   Notify the parent of changes and reset the
//  change flag stored in the property sheet page structure appropriately.
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_ApplySettings(
    HWND hDlg,
    LPREGDLGDATA pDlgData)
{
    DWORD dwLocale, dwRegion;
    LCID NewLocale;
    GEOID CurGeoID;
    HCURSOR hcurSave;
    HWND hUserLocale = GetDlgItem(hDlg, IDC_USER_LOCALE);
    HWND hUserRegion = GetDlgItem(hDlg, IDC_USER_REGION);
    DWORD dwRecipients;
    LPLANGUAGEGROUP pLG;
    BOOL bState, fUserCancel = FALSE;
    LVITEM lvItem;
    int iIndex=0, cCount=0;
    BOOL bBroadcast = FALSE;

    //
    //  See if there are any changes.
    //
    if ((pDlgData->Changes <= RC_EverChg) && (g_dwCustChange == 0L))
    {
        return (TRUE);
    }

    //
    //  Check if the second level has changed.
    //
    if (g_dwCustChange)
    {
        bBroadcast = TRUE;
    }

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  See if there are any changes to the user locale.
    //
    if (pDlgData->Changes & RC_UserLocale)
    {
        //
        //  Need to make sure the proper keyboard layout is installed.
        //
        Intl_InstallKeyboardLayout(hDlg, UserLocaleID, 0, FALSE, FALSE, FALSE);

        //
        //  We need to broadcast the change
        //
        bBroadcast = TRUE;
    }

    //
    //  See if there are any changes to the user region.
    //
    if (pDlgData->Changes & RC_UserRegion)
    {
        //
        //  Get the current selection.
        //
        dwRegion = (GEOID)ComboBox_GetCurSel(hUserRegion);

        //
        //  See if the current selection is different from the original
        //  selection.
        //
        if ((dwRegion != CB_ERR) && ((dwRegion != pDlgData->dwCurUserRegion)))
        {
            //
            //  Get the Region for the current selection.
            //
            CurGeoID = (GEOID)ComboBox_GetItemData(hUserRegion, dwRegion);

            //
            //  Set the current Region value in the pDlgData structure.
            //
            pDlgData->dwCurUserRegion = dwRegion;

            //
            //  Set the Region value in the user's registry.
            //
            SetUserGeoID(CurGeoID);
        }
    }

    //
    //  Broadcast the message that the international settings in the
    //  registry have changed.
    //
    if (bBroadcast)
    {
        dwRecipients = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
        BroadcastSystemMessage( BSF_FORCEIFHUNG | BSF_IGNORECURRENTTASK |
                                  BSF_NOHANG | BSF_NOTIMEOUTIFNOTHUNG,
                                &dwRecipients,
                                WM_WININICHANGE,
                                0,
                                (LPARAM)szIntl );
    }

    //
    //  Reset the property page settings.
    //
    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    pDlgData->Changes = RC_EverChg;

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
//  Also, if the user locale has changed, then register the change so
//  that all other property pages will be updated with the new locale
//  settings.
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_ValidatePPS(
    HWND hDlg,
    LPREGDLGDATA pDlgData)
{
    LPARAM Changes = pDlgData->Changes;

    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= RC_EverChg)
    {
        return (TRUE);
    }

    //
    //  See if the user locale has changed.
    //
    if (Changes & RC_UserLocale)
    {
        HWND hUserLocale = GetDlgItem(hDlg, IDC_USER_LOCALE);
        DWORD dwLocale = ComboBox_GetCurSel(hUserLocale);
        LCID NewLocale;

        //
        //  See if the current selections are different from the original
        //  selections.
        //
        if ((dwLocale != CB_ERR) && (dwLocale != pDlgData->dwLastUserLocale))
        {
            //
            //  Get the locale id for the current selection.
            //
            NewLocale = (LCID)ComboBox_GetItemData(hUserLocale, dwLocale);

            //
            //  Set the current locale values in the pDlgData structure.
            //
            pDlgData->dwLastUserLocale = dwLocale;

            //
            //  Set the UserLocaleID value.
            //
            UserLocaleID = NewLocale;
            bShowRtL    = IsRtLLocale(UserLocaleID);
            bHebrewUI = (PRIMARYLANGID(UserLocaleID) == LANG_HEBREW);
            bShowArabic = (bShowRtL && (PRIMARYLANGID(LANGIDFROMLCID(UserLocaleID)) != LANG_HEBREW));
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_InitPropSheet
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_InitPropSheet(
    HWND hDlg,
    LPPROPSHEETPAGE psp)
{
    LPREGDLGDATA pDlgData = (LPREGDLGDATA)LocalAlloc(LPTR, sizeof(REGDLGDATA));

    //
    //  Make sure we have a REGDLGDATA buffer.
    //
    if (pDlgData == NULL)
    {
        return (FALSE);
    }

    //
    //  See if we're in setup mode.
    //
    if (g_bSetupCase)
    {
        //
        //  Use the registry system locale value for the setup case.
        //
        SysLocaleID = RegSysLocaleID;

        //
        //  Use the registry user locale value for the setup case.
        //
        UserLocaleID = RegUserLocaleID;
        bShowRtL = IsRtLLocale(UserLocaleID);
        bHebrewUI = (PRIMARYLANGID(UserLocaleID) == LANG_HEBREW);
        bShowArabic = (bShowRtL && (PRIMARYLANGID(LANGIDFROMLCID(UserLocaleID)) != LANG_HEBREW));
    }

    //
    //  Save the data.
    //
    psp->lParam = (LPARAM)pDlgData;
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)psp);

    //
    //  Load the information into the dialog.
    //
    if (pLanguageGroups == NULL)
    {
        Intl_LoadLanguageGroups(hDlg);
    }
    Region_SetValues(hDlg, pDlgData, TRUE);
    Region_ShowSettings(hDlg, UserLocaleID);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_FreeGlobalInfo
//
//  Processing for a WM_DESTROY message.
//
////////////////////////////////////////////////////////////////////////////

void Region_FreeGlobalInfo()
{
    LPLANGUAGEGROUP pPreLG, pCurLG;
    HANDLE hAlloc;

    //
    //  Remove Language Group info.
    //
    pCurLG = pLanguageGroups;
    pLanguageGroups = NULL;

    while (pCurLG)
    {
        pPreLG = pCurLG;
        pCurLG = pPreLG->pNext;
        hAlloc = pPreLG->hLanguageGroup;
        GlobalUnlock(hAlloc);
        GlobalFree(hAlloc);
    }

    //
    //  Remove Alternate Sorts info.
    //
    g_NumAltSorts = 0;
    pAltSorts = NULL;
    GlobalUnlock(hAltSorts);
    GlobalFree(hAltSorts);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_CommandCustomize
//
////////////////////////////////////////////////////////////////////////////

int Region_CommandCustomize(
    HWND hDlg,
    LPREGDLGDATA pDlgData)
{
    int rc = 0;
    HPROPSHEETPAGE rPages[MAX_CUSTOM_PAGES];
    PROPSHEETHEADER psh;
    LPARAM lParam = 0;

    //
    //  Start at the first page.
    //
    psh.nStartPage = 0;

    //
    //  Set up the property sheet information.
    //
    psh.dwSize = sizeof(psh);
    psh.dwFlags = 0;
    psh.hwndParent = hDlg;
    psh.hInstance = hInstance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_NAME_CUSTOM);
    psh.nPages = 0;
    psh.phpage = rPages;

    //
    //  Add the appropriate property pages.
    //
    Intl_AddPage(&psh, DLG_NUMBER, NumberDlgProc, lParam, MAX_CUSTOM_PAGES);
    Intl_AddPage(&psh, DLG_CURRENCY, CurrencyDlgProc, lParam, MAX_CUSTOM_PAGES);
    Intl_AddPage(&psh, DLG_TIME, TimeDlgProc, lParam, MAX_CUSTOM_PAGES);
    Intl_AddPage(&psh, DLG_DATE, DateDlgProc, lParam, MAX_CUSTOM_PAGES);
    if (g_bShowSortingTab)
    {
        Intl_AddPage(&psh, DLG_SORTING, SortingDlgProc, lParam, MAX_CUSTOM_PAGES);
    }

    //
    //  Make the property sheet.
    //
    PropertySheet(&psh);

    //
    //  Return the result.
    //
    return (rc);
}

////////////////////////////////////////////////////////////////////////////
//
//  Region_ShowSettings
//
////////////////////////////////////////////////////////////////////////////

void Region_ShowSettings(
    HWND hDlg,
    LCID lcid)
{
    WCHAR szBuf[MAX_SAMPLE_SIZE];

    //
    //  Show Number Sample.
    //
    if (GetNumberFormat(lcid, 0, szSample_Number, NULL, szBuf, MAX_SAMPLE_SIZE))
    {
        SetDlgItemText(hDlg, IDC_NUMBER_SAMPLE, szBuf);
    }
    else
    {
        SetDlgItemText(hDlg, IDC_NUMBER_SAMPLE, L"");
    }

    //
    //  Show Currency Sample.
    //
    if (GetCurrencyFormat(lcid, 0, szSample_Number, NULL, szBuf, MAX_SAMPLE_SIZE))
    {
        SetDlgItemText(hDlg, IDC_CURRENCY_SAMPLE, szBuf);
    }
    else
    {
        SetDlgItemText(hDlg, IDC_CURRENCY_SAMPLE, L"");
    }

    //
    //  Show Time Sample.
    //
    if (GetTimeFormat(lcid, 0, NULL, NULL, szBuf, MAX_SAMPLE_SIZE))
    {
        SetDlgItemText(hDlg, IDC_TIME_SAMPLE, szBuf);
    }
    else
    {
        SetDlgItemText(hDlg, IDC_TIME_SAMPLE, L"");
    }

    //
    //  Show Short Date Sample.
    //
    if (bShowArabic)
    {
        if (GetDateFormat( lcid,
                           DATE_RTLREADING | DATE_SHORTDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_SHRTDATE_SAMPLE, szBuf);
        }
        else
        {
            SetDlgItemText(hDlg, IDC_SHRTDATE_SAMPLE, L"");
        }
    }
    else
    {
        // If user locale is not Arabic, make sure that the controls for date samples are:
        //  * LTR reading orders for non-Hebrew locales
        //  * RTL reading orders for Hebrew locales.
        SetControlReadingOrder(bHebrewUI, GetDlgItem(hDlg, IDC_SHRTDATE_SAMPLE));
        if (GetDateFormat( lcid,
                          (bShowRtL ? DATE_LTRREADING : 0) | DATE_SHORTDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_SHRTDATE_SAMPLE, szBuf);
        }
        else
        {
            SetDlgItemText(hDlg, IDC_SHRTDATE_SAMPLE, L"");
        }
    }

    //
    //  Show Long Date Sample.
    //
    if (bShowArabic)
    {
        if (GetDateFormat( lcid,
                           DATE_RTLREADING | DATE_LONGDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_LONGDATE_SAMPLE, szBuf);
        }
        else
        {
            SetDlgItemText(hDlg, IDC_LONGDATE_SAMPLE, L"");
        }
    }
    else
    {
        // If user locale is not Arabic, make sure that the control for date samples are:
        //  * LTR reading orders for non-Hebrew locales
        //  * RTL reading orders for Hebrew locales.
        SetControlReadingOrder(bHebrewUI, GetDlgItem(hDlg, IDC_LONGDATE_SAMPLE));
        if (GetDateFormat( lcid,
                           (bHebrewUI ? DATE_RTLREADING :
                             (bShowRtL ? DATE_LTRREADING : 0)) | DATE_LONGDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_LONGDATE_SAMPLE, szBuf);
        }
        else
        {
            SetDlgItemText(hDlg, IDC_LONGDATE_SAMPLE, L"");
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GeneralDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK GeneralDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPREGDLGDATA pDlgData = lpPropSheet ? (LPREGDLGDATA)lpPropSheet->lParam : NULL;

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            if (!Region_InitPropSheet( hDlg, (LPPROPSHEETPAGE)lParam))
            {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
            Region_SaveValues();
            break;
        }
        case ( WM_DESTROY ) :
        {
            Region_FreeGlobalInfo();
            if (pDlgData)
            {
                lpPropSheet->lParam = 0;
                LocalFree((HANDLE)pDlgData);
            }
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aRegionHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aRegionHelpIds );
            break;
        }
        case ( WM_NOTIFY ) :
        {
            LPNMHDR psn = (NMHDR *)lParam;
            switch (psn->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Regional)
                    {
                        Verified_Regional_Chg &= ~Process_Regional;
                        Region_SetValues(hDlg, pDlgData, FALSE);
                        Region_ShowSettings(hDlg, UserLocaleID);
                    }
                    break;
                }
                case ( PSN_RESET ) :
                {
                    //
                    // Revert any changes made
                    //
                    if (g_bCustomize)
                    {
                        Region_RevertChanges();
                        g_bCustomize = FALSE;
                    }
                    Region_RestoreValues();
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    if (pDlgData)
                    {
                        SetWindowLongPtr( hDlg,
                                          DWLP_MSGRESULT,
                                          !Region_ValidatePPS(hDlg, pDlgData) );
                    }
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    if (pDlgData)
                    {
                        //
                        //  Apply the settings.
                        //
                        if (Region_ApplySettings(hDlg, pDlgData))
                        {
                            SetWindowLongPtr( hDlg,
                                              DWLP_MSGRESULT,
                                              PSNRET_NOERROR );
                            //
                            //  Check if we need to do something for the
                            //  default user.
                            //
                            if (g_bDefaultUser)
                            {
                                g_bSettingsChanged = TRUE;
                                Intl_SaveDefaultUserSettings();
                            }

                            //
                            //  Zero out the RC_EverChg bit.
                            //
                            pDlgData->Changes = 0;

                            //
                            //  Save the new user locale.
                            //
                            Region_SaveValues();

                            //
                            //  Update settings.
                            //
                            Region_ShowSettings(hDlg, UserLocaleID);
                        }
                        else
                        {
                            SetWindowLongPtr( hDlg,
                                              DWLP_MSGRESULT,
                                              PSNRET_INVALID_NOCHANGEPAGE );
                        }
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }

            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_USER_LOCALE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        if (pDlgData)
                        {
                            //
                            //  User locale has changed.
                            //
                            pDlgData->Changes |= RC_UserLocale;

                            //
                            //  Apply second level changes.
                            //
                            Region_ApplyValues(hDlg, pDlgData);

                            //
                            //  Update settings.
                            //
                            Region_ShowSettings(hDlg, UserLocaleID);
                        }
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                    break;
                }
                case ( IDC_USER_REGION ) :
                {
                    //
                    //  See if it's a selection change.
                    //
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        if (pDlgData)
                        {
                            pDlgData->Changes |= RC_UserRegion;
                        }
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                    break;
                }
                case ( IDC_CUSTOMIZE ) :
                {
                    //
                    //  Show second level tabs.
                    //
                    g_bCustomize = TRUE;
                    Region_EnumAlternateSorts();
                    Region_EnableSortingPanel(hDlg);
                    Region_CommandCustomize(hDlg, pDlgData);

                    //
                    //  Update Settings.
                    //
                    if (g_dwCustChange)
                    {
                        Region_ShowSettings(hDlg, UserLocaleID);
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }

                    break;
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_InstallSystemLocale
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_InstallSystemLocale(
    LCID Locale)
{
    //
    //  Make sure the locale is valid and then call setup to install the
    //  requested locale.
    //
    if (IsValidLocale(Locale, LCID_INSTALLED))
    {
        if (!SetupChangeLocaleEx( HWND_DESKTOP,
                                  LOWORD(Locale),
                                  pSetupSourcePath,
                                  SP_INSTALL_FILES_QUIETLY,
                                  NULL,
                                  0 ))
        {
            //
            //  Check if we need to proceed with the Font Substitution
            //
            if (Intl_IsUIFontSubstitute() &&
                ((LANGID)LANGIDFROMLCID(Locale) == Intl_GetDotDefaultUILanguage()))
            {
                Intl_ApplyFontSubstitute(Locale);
            }

            //
            //  Log system locale change.
            //
            Intl_LogSimpleMessage(IDS_LOG_SYS_LOCALE_CHG, NULL);

            //
            //  Update current SysLocale, so we can use it later.
            //
            SysLocaleID = LOWORD(Locale);

            //
            //  Return success.
            //
            return (TRUE);
        }
        else
        {
            //
            //  This can happen if the user hits Cancel from
            //  within the setup dialog.
            //
            Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
        }
    }
    else
    {
        //
        //  Log invalid locale info.
        //
        Intl_LogSimpleMessage(IDS_LOG_INVALID_LOCALE, NULL);
    }

    //
    //  Return failure.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_UpdateShortDate
//
//  Updates the user's short date setting to contain a 4-digit year.
//  The setting is only updated if it is the same as the default setting
//  for the current locale (except for the 2-digit vs. 4-digit year).
//
////////////////////////////////////////////////////////////////////////////

void Region_UpdateShortDate()
{
    TCHAR szBufCur[SIZE_64];
    TCHAR szBufDef[SIZE_64];
    LPTSTR pCur, pDef;
    BOOL bChange = FALSE;

    //
    //  Get the current short date format setting and the default short date
    //  format setting.
    //
    if ((GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_SSHORTDATE,
                        szBufCur,
                        SIZE_64 )) &&
        (GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_SSHORTDATE | LOCALE_NOUSEROVERRIDE,
                        szBufDef,
                        SIZE_64 )))
    {
        //
        //  See if the current setting and the default setting only differ
        //  in a 2-digit year ("yy") vs. a 4-digit year ("yyyy").
        //
        //  Note: For this, we want an Exact match, so we don't need to
        //        use CompareString to compare the formats.
        //
        pCur = szBufCur;
        pDef = szBufDef;
        while ((*pCur) && (*pCur == *pDef))
        {
            //
            //  See if it's a 'y'.
            //
            if (*pCur == CHAR_SML_Y)
            {
                if (((*(pCur + 1)) == CHAR_SML_Y) &&
                    ((*(pDef + 1)) == CHAR_SML_Y) &&
                    ((*(pDef + 2)) == CHAR_SML_Y) &&
                    ((*(pDef + 3)) == CHAR_SML_Y))
                {
                    bChange = TRUE;
                    pCur += 1;
                    pDef += 3;
                }
            }
            pCur++;
            pDef++;
        }

        //
        //  Set the default short date format as the user's setting.
        //
        if (bChange && (*pCur == *pDef))
        {
            SetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, szBufDef);
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  Region_DoUnattendModeSetup
//
//  NOTE: The unattend mode file contains strings rather than integer
//        values, so we must get the string field and then convert it
//        to the appropriate integer format.  The Setup APIs won't just
//        do the right thing, so we have to roll our own.
//
////////////////////////////////////////////////////////////////////////////

void Region_DoUnattendModeSetup(
    LPCTSTR pUnattendFile)
{
    HINF hFile, hIntlInf;
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    INFCONTEXT Context;
    DWORD dwNum, dwCtr, dwLocale, dwLayout;
    UINT LanguageGroup, Language, SystemLocale, UserLocale;
    UINT UserLocale_DefUser = 0;
    LANGID MUILanguage, MUILanguage_DefUser;
    TCHAR szBuffer[MAX_PATH];
    DWORD dwLocaleACP = 0UL;
    BOOL bWinntUpgrade;
    BOOL bFound = FALSE;
    BOOL bFound_DefUser = FALSE;
    BOOL bLangGroup = FALSE;
    TCHAR szLCID[25];
    BOOL bInstallBasic = FALSE;
    BOOL bInstallComplex = FALSE;
    BOOL bInstallExt = FALSE;

    //
    //  Log the unattended file content.
    //
    if (g_bSetupCase)
    {
        TCHAR szPath[MAX_PATH * 2] = {0};

        //
        //  We are in setup mode.  No need to log the unattended mode file
        //  because the file is located in the system directory and named
        //  $winnt$.inf.
        //
        GetSystemDirectory(szPath, MAX_PATH);
        _tcscat(szPath, TEXT("\\$winnt$.inf"));
        Intl_LogSimpleMessage(IDS_LOG_UNAT_LOCATED, szPath);
    }
    else
    {
        Intl_LogUnattendFile(pUnattendFile);
    }

    //
    //  Open the unattend mode file.
    //
    hFile = SetupOpenInfFile(pUnattendFile, NULL, INF_STYLE_OLDNT, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        Intl_LogFormatMessage(IDS_LOG_FILE_ERROR);
        return;
    }

    //
    //  Check if we're doing an upgrade or fresh install.
    //
    bWinntUpgrade = Intl_IsWinntUpgrade();

    //
    //  Install the Basic Collection upfront when we are in setup.
    //
    if (g_bSetupCase)
    {
        //
        //  Open the intl.inf file.
        //
        if (!Intl_InitInf(0, &hIntlInf, szIntlInf, &FileQueue, &QueueContext))
        {
            SetupCloseInfFile(hFile);
            return;
        }

        if (!SetupInstallFilesFromInfSection( hIntlInf,
                                              NULL,
                                              FileQueue,
                                              szLGBasicInstall,
                                              pSetupSourcePath,
                                              SP_COPY_NEWER ))
        {
            Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
            goto Region_UnattendModeExit;
        }
        else
        {
            //
            //  See if we need to install any files.
            //
            if ((SetupScanFileQueue( FileQueue,
                                     SPQ_SCAN_PRUNE_COPY_QUEUE |
                                       SPQ_SCAN_FILE_VALIDITY,
                                     HWND_DESKTOP,
                                     NULL,
                                     NULL,
                                     &dwCtr )) && (dwCtr != 1))
            {
                //
                //  Copy the files in the queue.
                //
                if (!SetupCommitFileQueue( NULL,
                                           FileQueue,
                                           SetupDefaultQueueCallback,
                                           QueueContext ))
                {
                    //
                    //  This can happen if the user hits Cancel from
                    //  within the setup dialog.
                    //
                    Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                    goto Region_UnattendModeExit;
                }
            }

            //
            //  Call setup to install other inf info for the various
            //  language groups.
            //
            if (!SetupInstallFromInfSection( NULL,
                                             hIntlInf,
                                             szLGBasicInstall,
                                             SPINST_ALL & ~SPINST_FILES,
                                             NULL,
                                             pSetupSourcePath,
                                             0,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL ))
            {
                //
                //  This can happen if the user hits Cancel from
                //  within the setup dialog.
                //
                Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                goto Region_UnattendModeExit;
            }
        }

        //
        //  Close the inf file.
        //
        Intl_CloseInf(hIntlInf, FileQueue, QueueContext);
    }

    //
    //  Open the intl.inf file.
    //
    if (!Intl_InitInf(0, &hIntlInf, szIntlInf, &FileQueue, &QueueContext))
    {
        SetupCloseInfFile(hFile);
        return;
    }

    //
    //  Install all requested Language Groups.
    //
    if ((SetupFindFirstLine( hFile,
                             szRegionalSettings,
                             szLanguageGroup,
                             &Context )) &&
        (dwNum = SetupGetFieldCount(&Context)))
    {
        bLangGroup = TRUE;

        //
        //  Check for admin privilege.
        //
        if (g_bAdmin_Privileges)
        {
            for (dwCtr = 1; dwCtr <= dwNum; dwCtr++)
            {
                if (SetupGetStringField(&Context, dwCtr, szBuffer, MAX_PATH, NULL))
                {
                    //
                    //  Log language group info.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_LANG_GROUP, szBuffer);

                    //
                    //  Get the Language Group as an integer.
                    //
                    LanguageGroup = Intl_StrToLong(szBuffer);

                    //
                    //  See which language collections need to be installed.
                    //
                    if ((LanguageGroup == LGRPID_JAPANESE) ||
                        (LanguageGroup == LGRPID_KOREAN) ||
                        (LanguageGroup == LGRPID_TRADITIONAL_CHINESE) ||
                        (LanguageGroup == LGRPID_SIMPLIFIED_CHINESE))
                    {
                        bInstallExt = TRUE;
                    }
                    else if ((LanguageGroup == LGRPID_ARABIC) ||
                             (LanguageGroup == LGRPID_ARMENIAN) ||
                             (LanguageGroup == LGRPID_GEORGIAN) ||
                             (LanguageGroup == LGRPID_HEBREW) ||
                             (LanguageGroup == LGRPID_INDIC) ||
                             (LanguageGroup == LGRPID_VIETNAMESE) ||
                             (LanguageGroup == LGRPID_THAI))
                    {
                        bInstallComplex = TRUE;
                    }
                    else
                    {
                        bInstallBasic = TRUE;
                    }
                }
            }

            //
            //  Enqueue the appropriate language group files so that they
            //  may be copied.  This only handles the CopyFiles entries in
            //  the inf file.
            //

            //
            //  CJK Collection.
            //
            if (bInstallExt)
            {
                if (!SetupInstallFilesFromInfSection( hIntlInf,
                                                      NULL,
                                                      FileQueue,
                                                      szLGExtInstall,
                                                      pSetupSourcePath,
                                                      SP_COPY_NEWER ))
                {
                    bInstallExt = FALSE;
                    Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
                    goto Region_UnattendModeExit;
                }
            }

            //
            //  Complex Scripts Collection.
            //
            if (bInstallComplex)
            {
                if (!SetupInstallFilesFromInfSection( hIntlInf,
                                                      NULL,
                                                      FileQueue,
                                                      szLGComplexInstall,
                                                      pSetupSourcePath,
                                                      SP_COPY_NEWER ))
                {
                    bInstallComplex = FALSE;
                    Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
                    goto Region_UnattendModeExit;
                }
            }

            //
            //  Basic Collection.
            //
            //  Only install the Basic Collection if we're not in setup
            //  mode.  If we're in setup mode, this was already done above.
            //
            if (bInstallBasic && (!g_bSetupCase))
            {
                if (!SetupInstallFilesFromInfSection( hIntlInf,
                                                      NULL,
                                                      FileQueue,
                                                      szLGBasicInstall,
                                                      pSetupSourcePath,
                                                      SP_COPY_NEWER ))
                {
                    bInstallBasic = FALSE;
                    Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
                    goto Region_UnattendModeExit;
                }
            }

            //
            //  See if we need to install any files.
            //
            if ((SetupScanFileQueue( FileQueue,
                                     SPQ_SCAN_PRUNE_COPY_QUEUE |
                                       SPQ_SCAN_FILE_VALIDITY,
                                     HWND_DESKTOP,
                                     NULL,
                                     NULL,
                                     &dwCtr )) && (dwCtr != 1))
            {
                //
                //  Copy the files in the queue.
                //
                if (!SetupCommitFileQueue( NULL,
                                           FileQueue,
                                           SetupDefaultQueueCallback,
                                           QueueContext ))
                {
                    //
                    //  This can happen if the user hits Cancel from
                    //  within the setup dialog.
                    //
                    Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                    goto Region_UnattendModeExit;
                }
            }

            //
            //  Call setup to install other inf info for the various
            //  language groups.
            //
            if (bInstallExt)
            {
                if (!SetupInstallFromInfSection( NULL,
                                                 hIntlInf,
                                                 szLGExtInstall,
                                                 SPINST_ALL & ~SPINST_FILES,
                                                 NULL,
                                                 pSetupSourcePath,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL ))
                {
                    //
                    //  This can happen if the user hits Cancel from
                    //  within the setup dialog.
                    //
                    Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                    goto Region_UnattendModeExit;
                }
            }

            if (bInstallComplex)
            {
                if (!SetupInstallFromInfSection( NULL,
                                                 hIntlInf,
                                                 szLGComplexInstall,
                                                 SPINST_ALL & ~SPINST_FILES,
                                                 NULL,
                                                 pSetupSourcePath,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL ))
                {
                    //
                    //  This can happen if the user hits Cancel from
                    //  within the setup dialog.
                    //
                    Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                    goto Region_UnattendModeExit;
                }
            }

            if (bInstallBasic && (!g_bSetupCase))
            {
                if (!SetupInstallFromInfSection( NULL,
                                                 hIntlInf,
                                                 szLGBasicInstall,
                                                 SPINST_ALL & ~SPINST_FILES,
                                                 NULL,
                                                 pSetupSourcePath,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL ))
                {
                    //
                    //  This can happen if the user hits Cancel from
                    //  within the setup dialog.
                    //
                    Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                    goto Region_UnattendModeExit;
                }
            }
            
            //
            //  Run any necessary apps (for IME installation).
            //
            if (bInstallBasic || bInstallComplex || bInstallExt)
            {
                Intl_RunRegApps(c_szIntlRun);
            }
        }
        else
        {
            //
            //  Log that the unattend mode setup was blocked since they
            //  do not have admin privileges.
            //
            Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
        }
    }

    //
    //  Install the requested Language/Region information.  If a
    //  Language/Region was not specified, then install the requested
    //  System Locale, User Locale, and Input Locales.
    //
    if ((SetupFindFirstLine( hFile,
                             szRegionalSettings,
                             szLanguage,
                             &Context )) &&
        (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
    {
        //
        //  Log language info.
        //
        Intl_LogSimpleMessage(IDS_LOG_LANG, szBuffer);

        //
        //  Get the Language as an integer.
        //
        Language = TransNum(szBuffer);

        //
        //  Block the invariant locale.
        //
        if (Language != LANG_INVARIANT)
        {
            //
            //  Check for admin privilege.
            //
            if (g_bAdmin_Privileges)
            {
                //
                //  Install the Language as the System Locale and the User Locale,
                //  and then install all layouts associated with the Language.
                //
                if (GetLocaleInfo( MAKELCID(Language, SORT_DEFAULT),
                                   LOCALE_IDEFAULTANSICODEPAGE |
                                     LOCALE_NOUSEROVERRIDE |
                                     LOCALE_RETURN_NUMBER,
                                   (PTSTR) &dwLocaleACP,
                                   sizeof(dwLocaleACP) / sizeof(TCHAR) ))
                {
                    //
                    //  Don't set the system locale if the locale doesn't have
                    //  an ACP.
                    //
                    if (dwLocaleACP)
                    {
                        if (Region_InstallSystemLocale(MAKELCID(Language, SORT_DEFAULT)))
                        {
                            bFound = TRUE;
                        }
                    }
                    else
                    {
                        //
                        //  Unicode locale blocked.
                        //
                        Intl_LogSimpleMessage(IDS_LOG_UNI_BLOCK, NULL);
                    }
                    
                    //
                    //  If we are in setup, try to set the Current User GEOID.
                    //
                    if( g_bSetupCase)
                    {
                        TCHAR szBuffer[MAX_PATH];
                        BOOL bSetGeoId = FALSE;
                        
                        //
                        //  If it's a clean install, then always set the GEOID. If 
                        //  it's a upgrade install set the GEOID only if no value
                        //  already set.
                        //
                        if (!bWinntUpgrade)
                        {
                            bSetGeoId = TRUE;
                        }
                        else if (GetUserGeoID(GEOCLASS_NATION) != GEOID_NOT_AVAILABLE)
                        {
                            bSetGeoId = TRUE;
                        }

                        if (bSetGeoId)
                        {
                            //
                            //  Retreive the Geo Identifier from the NLS info
                            //
                            if(GetLocaleInfo(MAKELCID(Language, SORT_DEFAULT),
                            	             LOCALE_IGEOID | LOCALE_RETURN_NUMBER,
                            	             szBuffer,
                            	             MAX_PATH))
                            {
                                //
                                //  Set The GeoId
                                //
                                SetUserGeoID(*((LPDWORD)szBuffer));
                            }
                        }
                    }
                }
                else
                {
                    Intl_LogFormatMessage(IDS_LOG_LOCALE_ACP_FAIL);
                }
            }
            else
            {
                //
                //  Log that the unattend mode setup was blocked since they
                //  do not have admin privileges.
                //
                Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
            }

            //
            //  If we're doing an upgrade, then don't touch per-user settings.
            //
            if (!bWinntUpgrade)
            {
                //
                //  Install the requested User Locale.
                //
                if (Intl_InstallUserLocale(MAKELCID(Language, SORT_DEFAULT), FALSE, TRUE))
                {
                    bFound = TRUE;
                }

                //
                //  Install Keyboard layout
                //
                Intl_InstallAllKeyboardLayout((LANGID)Language);
            }
        }
        else
        {
            //
            //  Log invariant locale blocked.
            //
            Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
        }
    }

    //
    //  Make sure there was a valid Language setting.  If not, then look
    //  for the individual keywords.
    //
    if (!bFound)
    {
        //
        //  Init the locale variables.
        //
        SystemLocale = 0;
        UserLocale = 0;

        //
        //  Log : no valid language setting found.
        //
        Intl_LogSimpleMessage(IDS_LOG_NO_VALID_FOUND, NULL);

        //
        //  Install the requested System Locale.
        //
        if ((SetupFindFirstLine( hFile,
                                 szRegionalSettings,
                                 szSystemLocale,
                                 &Context )) &&
            (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
        {
            SystemLocale = TransNum(szBuffer);

            //
            //  Check for admin privilege.
            //
            if (g_bAdmin_Privileges)
            {
                //
                //  Log system locale info.
                //
                Intl_LogSimpleMessage(IDS_LOG_SYS_LOCALE, szBuffer);

                //
                //  Block the invariant locale.
                //
                if (SystemLocale != LOCALE_INVARIANT)
                {
                    dwLocaleACP = 0UL;
                    if (GetLocaleInfo( SystemLocale,
                                       LOCALE_IDEFAULTANSICODEPAGE |
                                         LOCALE_NOUSEROVERRIDE |
                                         LOCALE_RETURN_NUMBER,
                                       (PTSTR) &dwLocaleACP,
                                       sizeof(dwLocaleACP) / sizeof(TCHAR) ))
                    {
                        //
                        //  Don't set the system locale if the locale doesn't
                        //  have an ACP.
                        //
                        if (dwLocaleACP)
                        {
                            if (Region_InstallSystemLocale(SystemLocale))
                            {
                                bFound = TRUE;
                            }
                        }
                        else
                        {
                            //
                            //  Unicode locale blocked.
                            //
                            Intl_LogSimpleMessage(IDS_LOG_UNI_BLOCK, NULL);
                        }
                    }
                    else
                    {
                        Intl_LogFormatMessage(IDS_LOG_LOCALE_ACP_FAIL);
                    }
                }
                else
                {
                    //
                    //  Log invariant locale blocked.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
                }
            }
            else
            {
                //
                //  Log that the unattend mode setup was blocked since they
                //  do not have admin privileges.
                //
                Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
            }
        }

        //
        //  Install the requested User Locale.
        //
        if ((SetupFindFirstLine( hFile,
                                 szRegionalSettings,
                                 szUserLocale,
                                 &Context )) &&
            (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
        {
            UserLocale = TransNum(szBuffer);

            //
            //  Log User locale info.
            //
            Intl_LogSimpleMessage(IDS_LOG_USER_LOCALE, szBuffer);

            //
            //  Block the invariant locale.
            //
            if (UserLocale != LOCALE_INVARIANT)
            {
                if ((!bWinntUpgrade) &&
                    (Intl_InstallUserLocale(UserLocale, FALSE, TRUE)))
                {
                    bFound = TRUE;
                }
            }
            else
            {
                //
                //  Log invariant locale blocked.
                //
                Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
            }
        }

        //
        //  Install the requested Input Locales.
        //
        if (SetupFindFirstLine( hFile,
                                szRegionalSettings,
                                szInputLocale,
                                &Context ))
        {
            //
            //  Log Default User - Input Locale info.
            //
            Intl_LogSimpleMessage(IDS_LOG_INPUT, NULL);

            //
            //  Install the keyboard layout list.
            //
            if (Intl_InstallKeyboardLayoutList(&Context, 1, FALSE))
            {
                bFound = TRUE;
            }
        }
        else
        {
            //
            //  No input locales are specified, so install the default
            //  input locale for the system locale and/or user locale if
            //  they were specified.
            //
            if (SystemLocale != 0)
            {
                //
                //  Log system locale info.
                //
                Intl_LogSimpleMessage(IDS_LOG_SYS_DEF_LAYOUT, NULL);

                //
                //  Install the keyboard layout.
                //
                Intl_InstallKeyboardLayout(NULL, SystemLocale, 0, FALSE, FALSE, TRUE);
            }
            if ((UserLocale != 0) && (UserLocale != SystemLocale))
            {
                //
                //  Log user locale info.
                //
                Intl_LogSimpleMessage(IDS_LOG_USER_DEF_LAYOUT, NULL);

                //
                //  Install the keyboard layout.
                //
                Intl_InstallKeyboardLayout(NULL, UserLocale, 0, FALSE, FALSE, FALSE);
            }
        }

        //
        //  Install the requested MUI Language.
        //
        if ((SetupFindFirstLine( hFile,
                                 szRegionalSettings,
                                 szMUILanguage,
                                 &Context )) &&
            (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
        {
            MUILanguage = (LANGID)TransNum(szBuffer);

            //
            //  Log MUI Language info.
            //
            Intl_LogSimpleMessage(IDS_LOG_MUI_LANG, szBuffer);

            //
            //  Check UI language validity.
            //
            if (IsValidUILanguage(MUILanguage))
            {
                //
                //  Block the invariant locale.
                //
                if (MUILanguage != LANG_INVARIANT)
                {
                    if ((!bWinntUpgrade) &&
                        NT_SUCCESS(NtSetDefaultUILanguage(MUILanguage)))
                    {
                        //  deleting the key this way makes the key invalid for this process
                        //  this way the new UI doesn't get bogus cached values
                        SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\MUICache"));

                        //
                        //  Install the default keyboard.
                        //
                        if (Intl_InstallKeyboardLayout( NULL,
                                                        MAKELCID(MUILanguage, SORT_DEFAULT),
                                                        0,
                                                        FALSE,
                                                        FALSE,
                                                        FALSE ))
                        {
                            bFound = TRUE;
                        }
                    }
                }
                else
                {
                    //
                    //  Log invariant locale blocked.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
                }
            }
            else
            {
                //
                //  Log invalid UI language blocked.
                //
                Intl_LogSimpleMessage(IDS_LOG_UI_BLOCK, NULL);
            }
        }
    }


    //
    //  Install the requested User Locale for the Default User.
    //
    if ((SetupFindFirstLine( hFile,
                             szRegionalSettings,
                             szUserLocale_DefUser,
                             &Context )) &&
        (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
    {
        UserLocale_DefUser = TransNum(szBuffer);

        //
        //  Log default user - user locale info.
        //
        Intl_LogSimpleMessage(IDS_LOG_USER_LOCALE_DEF, szBuffer);

        //
        //  Block users that do not have administrative privilege.
        //
        if (g_bAdmin_Privileges)
        {
            //
            //  Block the invariant locale.
            //
            if (UserLocale_DefUser != LOCALE_INVARIANT)
            {
                if (Intl_InstallUserLocale(UserLocale_DefUser, TRUE, TRUE))
                {
                    if (Intl_InstallKeyboardLayout(NULL, UserLocale_DefUser, 0, FALSE, TRUE, FALSE))
                    {
                        Intl_SaveDefaultUserInputSettings();
                        bFound_DefUser = TRUE;
                    }
                }
            }
            else
            {
                //
                //  Log invariant locale blocked.
                //
                Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
            }
        }
        else
        {
            //
            //  Log that the unattend mode setup was blocked since they
            //  do not have admin privileges.
            //
            Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
        }
    }

    //
    //  Install the requested Input Locales for the Default User.
    //
    if (SetupFindFirstLine( hFile,
                            szRegionalSettings,
                            szInputLocale_DefUser,
                            &Context ))
    {
        //
        //  Log Default User - Input Locale info.
        //
        Intl_LogSimpleMessage(IDS_LOG_INPUT_DEF, NULL);

        //
        //  Block users that do not have administrative privilege.
        //
        if (g_bAdmin_Privileges)
        {
            if (Intl_InstallKeyboardLayoutList(&Context, 1, TRUE))
            {
                Intl_SaveDefaultUserInputSettings();
                bFound_DefUser = TRUE;
            }
        }
        else
        {
            //
            //  Log that the unattend mode setup was blocked since they
            //  do not have admin privileges.
            //
            Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
        }
    }

    //
    //  Install the requested MUI Language for the Default User.
    //
    if ((SetupFindFirstLine( hFile,
                             szRegionalSettings,
                             szMUILanguage_DefUSer,
                             &Context )) &&
        (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
    {
        MUILanguage_DefUser = (LANGID)TransNum(szBuffer);

        //
        //  Log Default User - MUI Language info.
        //
        Intl_LogSimpleMessage(IDS_LOG_MUI_LANG_DEF, szBuffer);

        //
        //  Check UI language validity.
        //
        if (IsValidUILanguage(MUILanguage_DefUser))
        {
            //
            //  Block users that do not have administrative privilege.
            //
            if (g_bAdmin_Privileges)
            {
                //
                //  Block the invariant locale.
                //
                if (MUILanguage_DefUser != LANG_INVARIANT)
                {
                    if (Intl_ChangeUILangForAllUsers(MUILanguage_DefUser))
                    {
                        Intl_SaveDefaultUserInputSettings();
                        bFound_DefUser = TRUE;
                    }
                }
                else
                {
                    //
                    //  Log invariant locale blocked.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
                }
            }
            else
            {
                //
                //  Log that the unattend mode setup was blocked since they
                //  do not have admin privileges.
                //
                Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
            }
        }
        else
        {
            //
            //  Log invalid UI language blocked.
            //
            Intl_LogSimpleMessage(IDS_LOG_UI_BLOCK, NULL);
        }
    }

    //
    //  If we still didn't find anything, then load the default locale for
    //  the installation.  It will be the equivalent of:
    //      LanguageGroup = "x"
    //      Language = "y"
    //  where x is the language group for the default locale and y is the
    //  default locale.
    //
    if (!bFound && !bLangGroup && !bFound_DefUser)
    {
        //
        //  Get the default locale.
        //
        if ((SetupFindFirstLine( hIntlInf,
                                 L"DefaultValues",
                                 L"Locale",
                                 &Context )) &&
            (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
        {
            //
            //  Get the Language as an integer.
            //
            Language = TransNum(szBuffer);

            //
            //  Install the Language Group needed for this Language.
            //
            if ((SetupFindFirstLine( hIntlInf,
                                     L"Locales",
                                     szBuffer,
                                     &Context )) &&
                (SetupGetStringField(&Context, 3, szBuffer, MAX_PATH, NULL)))
            {
                //
                //  Get the Language Group as an integer.
                //
                bInstallBasic = FALSE;
                bInstallExt = FALSE;
                LanguageGroup = Intl_StrToLong(szBuffer);

                //
                //  Enqueue the language group files so that they may be
                //  copied.  This only handles the CopyFiles entries in the
                //  inf file.
                //
                if ((LanguageGroup == LGRPID_JAPANESE) ||
                    (LanguageGroup == LGRPID_KOREAN) ||
                    (LanguageGroup == LGRPID_TRADITIONAL_CHINESE) ||
                    (LanguageGroup == LGRPID_SIMPLIFIED_CHINESE))
                {
                    if (SetupInstallFilesFromInfSection( hIntlInf,
                                                         NULL,
                                                         FileQueue,
                                                         szLGExtInstall,
                                                         pSetupSourcePath,
                                                         SP_COPY_NEWER ))
                    {
                        bInstallExt = TRUE;
                    }
                }
                else if ((LanguageGroup == LGRPID_ARABIC) ||
                         (LanguageGroup == LGRPID_ARMENIAN) ||
                         (LanguageGroup == LGRPID_GEORGIAN) ||
                         (LanguageGroup == LGRPID_HEBREW) ||
                         (LanguageGroup == LGRPID_INDIC) ||
                         (LanguageGroup == LGRPID_VIETNAMESE) ||
                         (LanguageGroup == LGRPID_THAI))
                {
                    if (SetupInstallFilesFromInfSection( hIntlInf,
                                                         NULL,
                                                         FileQueue,
                                                         szLGComplexInstall,
                                                         pSetupSourcePath,
                                                         SP_COPY_NEWER ))
                    {
                        bInstallComplex = TRUE;
                    }
                }
                else
                {
                    if (SetupInstallFilesFromInfSection( hIntlInf,
                                                         NULL,
                                                         FileQueue,
                                                         szLGBasicInstall,
                                                         pSetupSourcePath,
                                                         SP_COPY_NEWER ))
                    {
                        bInstallBasic = TRUE;
                    }
                }

                //
                //  See if we need to install any files.
                //
                if ((SetupScanFileQueue( FileQueue,
                                         SPQ_SCAN_PRUNE_COPY_QUEUE |
                                           SPQ_SCAN_FILE_VALIDITY,
                                         HWND_DESKTOP,
                                         NULL,
                                         NULL,
                                         &dwCtr )) && (dwCtr != 1))
                {
                    //
                    //  Copy the files in the queue.
                    //
                    if (!SetupCommitFileQueue( NULL,
                                               FileQueue,
                                               SetupDefaultQueueCallback,
                                               QueueContext ))
                    {
                        //
                        //  This can happen if the user hits Cancel from
                        //  within the setup dialog.
                        //
                        goto Region_UnattendModeExit;
                    }
                }

                //
                //  Call setup to install other inf info for the various
                //  language groups.
                //
                if (bInstallExt)
                {
                    if (!SetupInstallFromInfSection( NULL,
                                                     hIntlInf,
                                                     szLGExtInstall,
                                                     SPINST_ALL & ~SPINST_FILES,
                                                     NULL,
                                                     pSetupSourcePath,
                                                     0,
                                                     NULL,
                                                     NULL,
                                                     NULL,
                                                     NULL ))
                    {
                        //
                        //  This can happen if the user hits Cancel from
                        //  within the setup dialog.
                        //
                        Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                        goto Region_UnattendModeExit;
                    }
                }
                else if (bInstallComplex)
                {
                    if (!SetupInstallFromInfSection( NULL,
                                                     hIntlInf,
                                                     szLGComplexInstall,
                                                     SPINST_ALL & ~SPINST_FILES,
                                                     NULL,
                                                     pSetupSourcePath,
                                                     0,
                                                     NULL,
                                                     NULL,
                                                     NULL,
                                                     NULL ))
                    {
                        //
                        //  This can happen if the user hits Cancel from
                        //  within the setup dialog.
                        //
                        Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                        goto Region_UnattendModeExit;
                    }
                }
                else
                {
                    if (!SetupInstallFromInfSection( NULL,
                                                     hIntlInf,
                                                     szLGBasicInstall,
                                                     SPINST_ALL & ~SPINST_FILES,
                                                     NULL,
                                                     pSetupSourcePath,
                                                     0,
                                                     NULL,
                                                     NULL,
                                                     NULL,
                                                     NULL ))
                    {
                        //
                        //  This can happen if the user hits Cancel from
                        //  within the setup dialog.
                        //
                        Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                        goto Region_UnattendModeExit;
                    }
                }
                
                //
                //  Run any necessary apps (for IME installation).
                //
                if (bInstallBasic || bInstallComplex || bInstallExt)
                {
                    Intl_RunRegApps(c_szIntlRun);
                }            }

            //
            //  Install the Language as the System Locale and the User Locale,
            //  and then install all layouts associated with the Language.
            //
            Region_InstallSystemLocale(MAKELCID(Language, SORT_DEFAULT));

            //
            //  If we're doing an upgrade, then don't touch per-user settings.
            //
            if (!bWinntUpgrade)
            {
                Intl_InstallUserLocale(MAKELCID(Language, SORT_DEFAULT), FALSE, TRUE);
                Intl_InstallAllKeyboardLayout((LANGID)Language);
            }
        }
    }



    //
    //  Run any necessary apps (for FSVGA/FSNEC installation).
    //
    Intl_RunRegApps(c_szSysocmgr);
    
Region_UnattendModeExit:
    //
    //  Close the inf file.
    //
    Intl_CloseInf(hIntlInf, FileQueue, QueueContext);

    //
    //  Close the unattend mode file.
    //
    SetupCloseInfFile(hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\main\fake.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mouse.c

Abstract:

    This module contains the routines for the "fake" applets.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"

//
// From shell\inc\shsemip.h
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//
//  From shelldll\help.c.
//
VOID WINAPI SHHelpShortcuts_RunDLL( HWND, HINSTANCE, LPCSTR, int );
VOID WINAPI SHHelpShortcuts_RunDLLW( HWND, HINSTANCE, LPCWSTR, int );

static const TCHAR c_szPrintersFolder[]           = TEXT("PrintersFolder");
static const TCHAR c_szFontsFolder[]              = TEXT("FontsFolder");




////////////////////////////////////////////////////////////////////////////
//
//  PrintApplet
//
////////////////////////////////////////////////////////////////////////////

int PrintApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
#ifdef UNICODE
    SHHelpShortcuts_RunDLLW( NULL,
                             GetModuleHandle(NULL),
                             c_szPrintersFolder,
                             SW_SHOWNORMAL );
#else
    SHHelpShortcuts_RunDLL( NULL,
                            GetModuleHandle(NULL),
                            c_szPrintersFolder,
                            SW_SHOWNORMAL );
#endif

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  FontsApplet
//
////////////////////////////////////////////////////////////////////////////

int FontsApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
#ifdef UNICODE
    SHHelpShortcuts_RunDLLW( NULL,
                             GetModuleHandle(NULL),
                             c_szFontsFolder,
                             SW_SHOWNORMAL );
#else
    SHHelpShortcuts_RunDLL( NULL,
                            GetModuleHandle(NULL),
                            c_szFontsFolder,
                            SW_SHOWNORMAL );
#endif

    return (0);
}

////////////////////////////////////////////////////////////////////////////
//
//  AdmApplet
//
////////////////////////////////////////////////////////////////////////////

int AdmApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szAdminTools[MAX_PATH];

    if ( !SHGetSpecialFolderPath(parent, szPath, CSIDL_COMMON_PROGRAMS, 0) )
        return 1;

    // load the string for the tools folder, then path combine the two so that
    // we can open that directory.

    if ( !LoadString(instance, IDS_ADM_TITLE, szAdminTools, ARRAYSIZE(szAdminTools)) )
        return 1;
    
    //+1 for backslash and +1 for '\0'

    if ( (lstrlen(szPath)+lstrlen(szAdminTools)+1+1) > ARRAYSIZE(szPath) )
        return 1;

    PathCombine(szPath, szPath, szAdminTools);
    ShellExecute(parent, NULL, szPath, NULL, NULL, SW_SHOWDEFAULT);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\sortdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    sortdlg.c

Abstract:

    This module implements the sorting property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <windowsx.h>
#include <winnls.h>
#include "intlhlp.h"
#include "maxvals.h"
#include "winnlsp.h"



//
//  Global Variables.
//

static DWORD g_savLocaleId;



//
//  Context Help Ids.
//

static int aSortingHelpIds[] =
{
    IDC_SORTING,       IDH_INTL_SORT_SORTING,
    IDC_SORTING_TEXT1, IDH_INTL_SORT_SORTING,
    IDC_SORTING_TEXT2, IDH_INTL_SORT_SORTING,
    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  Sorting_UpdateSortingCombo
//
////////////////////////////////////////////////////////////////////////////

void Sorting_UpdateSortingCombo(
    HWND hDlg)
{
    HWND hSorting = GetDlgItem(hDlg, IDC_SORTING);
    DWORD dwIndex;
    TCHAR szBuf[SIZE_128];
    LCID LocaleID;
    LANGID LangID;
    int ctr;

    //
    //  Reset the contents of the combo box.
    //
    ComboBox_ResetContent(hSorting);

    //
    //  Get the language id from the locale id.
    //
    LocaleID = UserLocaleID;
    LangID = LANGIDFROMLCID(UserLocaleID);

    //
    //  Special case Spanish (Spain) - list International sort first.
    //
    if (LangID == LANG_SPANISH_TRADITIONAL)
    {
        LangID = LANG_SPANISH_INTL;
        LocaleID = LCID_SPANISH_INTL;
    }

    //
    //  Store the sort name for the locale.
    //
    if (GetLocaleInfo((LCID)LangID, LOCALE_SSORTNAME, szBuf, SIZE_128))
    {
        //
        //  Add the new sorting option to the sorting combo box.
        //
        dwIndex = ComboBox_AddString(hSorting, szBuf);
        ComboBox_SetItemData(hSorting, dwIndex, (LCID)LangID);

        //
        //  Set this as the current selection.
        //
        ComboBox_SetCurSel(hSorting, dwIndex);
    }

    //
    //  Special case Spanish (Spain) - list Traditional sort second.
    //
    if (LangID == LANG_SPANISH_INTL)
    {
        LangID = LANG_SPANISH_TRADITIONAL;
        if (GetLocaleInfo((LCID)LangID, LOCALE_SSORTNAME, szBuf, SIZE_128))
        {
            //
            //  Add the new sorting option to the sorting combo box.
            //
            dwIndex = ComboBox_AddString(hSorting, szBuf);
            ComboBox_SetItemData(hSorting, dwIndex, LCID_SPANISH_TRADITIONAL);

            //
            //  Set this as the current selection if it's the current
            //  locale id.
            //
            if (UserLocaleID == LCID_SPANISH_TRADITIONAL)
            {
                ComboBox_SetCurSel(hSorting, dwIndex);
            }
        }
        LangID = LANGIDFROMLCID(UserLocaleID);
    }

    //
    //  Fill in the drop down if necessary.
    //
    for (ctr = 0; ctr < g_NumAltSorts; ctr++)
    {
        LocaleID = pAltSorts[ctr];
        if ((LANGIDFROMLCID(LocaleID) == LangID) &&
            (GetLocaleInfo(LocaleID, LOCALE_SSORTNAME, szBuf, SIZE_128)))
        {
            //
            //  Add the new sorting option to the sorting combo box.
            //
            dwIndex = ComboBox_AddString(hSorting, szBuf);
            ComboBox_SetItemData(hSorting, dwIndex, LocaleID);

            //
            //  Set this as the current selection if it's the current
            //  locale id.
            //
            if (LocaleID == UserLocaleID)
            {
                ComboBox_SetCurSel(hSorting, dwIndex);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Sorting_SaveValues
//
//  Save values in case we need to restore them.
//
////////////////////////////////////////////////////////////////////////////

void Sorting_SaveValues()
{
    //
    //  Save locale values.
    //
    g_savLocaleId = RegUserLocaleID;
}


////////////////////////////////////////////////////////////////////////////
//
//  Sorting_RestoreValues
//
////////////////////////////////////////////////////////////////////////////

void Sorting_RestoreValues()
{
    if (!(g_dwCustChange & Process_Sorting))
    {
        return;
    }

    //
    //  See if the current selections are different from the original
    //  selections.
    //
    if (UserLocaleID != g_savLocaleId)
    {
        //
        //  Install the new locale by adding the appropriate information
        //  to the registry.
        //
        Intl_InstallUserLocale(g_savLocaleId, FALSE, FALSE);

        //
        //  Update the NLS process cache.
        //
        NlsResetProcessLocale();

        //
        //  Reset the registry user locale value.
        //
        UserLocaleID = g_savLocaleId;
        RegUserLocaleID = g_savLocaleId;

        //
        //  Need to make sure the proper keyboard layout is installed.
        //
        Intl_InstallKeyboardLayout(NULL, g_savLocaleId, 0, FALSE, FALSE, FALSE);

        //
        //  Register the regional change every time so that all other property
        //  pages will be updated due to the locale settings change.
        //
        Verified_Regional_Chg = INTL_CHG;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Sorting_ClearValues
//
//  Reset each of the list boxes in the sorting property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Sorting_ClearValues(
    HWND hDlg)
{
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SORTING));
}


////////////////////////////////////////////////////////////////////////////
//
//  Sorting_SetValues
//
//  Initialize all of the controls in the sorting property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Sorting_SetValues(
    HWND hDlg,
    BOOL fInit)
{
    DWORD dwIndex;
    TCHAR szSorting[SIZE_128];
    HWND hSorting = GetDlgItem(hDlg, IDC_SORTING);

    //
    //  Reset the combo box.
    //
    Sorting_ClearValues(hDlg);

    //
    //  Fill in the appropriate Sorting name for the selected locale.
    //
    Sorting_UpdateSortingCombo(hDlg);
    dwIndex = ComboBox_GetCurSel(hSorting);
    if (ComboBox_SetCurSel( hSorting,
                            ComboBox_FindStringExact( hSorting,
                                                      -1,
                                                      szSorting ) ) == CB_ERR)
    {
        ComboBox_SetCurSel(hSorting, dwIndex);
    }

    //
    //  Store the sorting state.
    //
    if (fInit)
    {
        g_dwCurSorting  = ComboBox_GetCurSel(hSorting);
        g_dwLastSorting = g_dwCurSorting;
    }
    else
    {
        g_dwCurSorting = ComboBox_GetCurSel(hSorting);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Sorting_ApplySettings
//
//  For every control that has changed (that affects the Locale settings),
//  call Set_Locale_Values to update the user locale information.  Notify
//  the parent of changes and reset the change flag stored in the property
//  sheet page structure appropriately.  Redisplay the time sample if
//  bRedisplay is TRUE.
//
////////////////////////////////////////////////////////////////////////////

BOOL Sorting_ApplySettings(
    HWND hDlg)
{
    TCHAR szLCID[25];
    DWORD dwSorting;
    LCID NewLocale, SortLocale;
    HCURSOR hcurSave;
    HWND hSorting = GetDlgItem(hDlg, IDC_SORTING);
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;

    //
    //  See if there are any changes.
    //
    if (Changes <= SC_EverChg)
    {
        return (TRUE);
    }

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  See if there are any changes to the user locale.
    //
    if (Changes & SC_Sorting)
    {
        //
        //  Get the current selections.
        //
        dwSorting = ComboBox_GetCurSel(hSorting);

        //
        //  See if the current selections are different from the original
        //  selections.
        //
        if (dwSorting != g_dwCurSorting)
        {
            //
            //  Get the locale id with the sort id.
            //
            NewLocale = UserLocaleID;
            SortLocale = (LCID)ComboBox_GetItemData(hSorting, dwSorting);

            //
            //  See if we've got Spanish.
            //
            if (SortLocale == LCID_SPANISH_TRADITIONAL)
            {
                NewLocale = LCID_SPANISH_TRADITIONAL;
            }
            else if (SortLocale == LCID_SPANISH_INTL)
            {
                NewLocale = LCID_SPANISH_INTL;
            }

            //
            //  Make sure the sort locale is okay.
            //
            if (LANGIDFROMLCID(SortLocale) != LANGIDFROMLCID(NewLocale))
            {
                SortLocale = NewLocale;
            }

            //
            //  Set the current locale values in the pDlgData structure.
            //
            g_dwCurSorting = dwSorting;

            //
            //  Install the new locale by adding the appropriate information
            //  to the registry.
            //
            Intl_InstallUserLocale(SortLocale, FALSE, FALSE);

            //
            //  Update the NLS process cache.
            //
            NlsResetProcessLocale();

            //
            //  Reset the registry user locale value.
            //
            UserLocaleID = SortLocale;
            RegUserLocaleID = SortLocale;

            //
            //  Need to make sure the proper keyboard layout is installed.
            //
            Intl_InstallKeyboardLayout(hDlg, SortLocale, 0, FALSE, FALSE, FALSE);
            
            //
            //  Register the regional change every time so that all other property
            //  pages will be updated due to the locale settings change.
            //
            Verified_Regional_Chg = INTL_CHG;
        }
    }

    //
    //  Reset the property page settings.
    //
    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    Changes = SC_EverChg;

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Changes made in the second level.
    //
    if (Changes)
    {
        g_dwCustChange |= Process_Sorting;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Sorting_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Sorting_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Sorting_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Sorting_SetValues with the property
//  sheet handle to initialize all of the property sheet controls.  Limit
//  the length of the text in some of the ComboBoxes.
//
////////////////////////////////////////////////////////////////////////////

void Sorting_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    //
    //  The lParam holds a pointer to the property sheet page.  Save it
    //  for later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    //
    //  Load the information into the dialog.
    //
    Sorting_SetValues(hDlg, TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SortingDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK SortingDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch (message)
    {
        case ( WM_NOTIFY ) :
        {
            lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Sorting)
                    {
                        Verified_Regional_Chg &= ~Process_Sorting;
                        Sorting_ClearValues(hDlg);
                        Sorting_SetValues(hDlg, FALSE);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                      DWLP_MSGRESULT,
                                      !Sorting_ValidatePPS( hDlg, lpPropSheet->lParam ) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Sorting_ApplySettings(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        //
                        //  Zero out the TC_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                          DWLP_MSGRESULT,
                                          PSNRET_INVALID_NOCHANGEPAGE );
                    }

                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            Sorting_InitPropSheet(hDlg, lParam);
            Sorting_SaveValues();
            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aSortingHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aSortingHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_SORTING ) :
                {
                    //
                    //  See if it's a selection change.
                    //
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= SC_Sorting;
                    }
                    break;
                }
            }

            //
            //  Turn on ApplyNow button.
            //
            if (lpPropSheet->lParam > SC_EverChg)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\timedlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    timedlg.c

Abstract:

    This module implements the time property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <windowsx.h>
#include <tchar.h>
#include "intlhlp.h"
#include "maxvals.h"



//
//  Global Variables.
//

static TCHAR sz_s1159[MAX_S1159 + 1];
static TCHAR sz_s2359[MAX_S2359 + 1];
static TCHAR sz_sTime[MAX_STIME + 1];
static TCHAR sz_sTimeFormat[MAX_FORMAT + 1];

TCHAR szNLS_TimeStyle[SIZE_128];



//
//  Context Help Ids.
//

static int aTimeHelpIds[] =
{
    IDC_GROUPBOX1,  IDH_COMM_GROUPBOX,
    IDC_SAMPLELBL1, IDH_INTL_TIME_SAMPLE,
    IDC_SAMPLE1,    IDH_INTL_TIME_SAMPLE,
    IDC_SAMPLE1A,   IDH_INTL_TIME_SAMPLE_ARABIC,
    IDC_TIME_STYLE, IDH_INTL_TIME_FORMAT,
    IDC_SEPARATOR,  IDH_INTL_TIME_SEPARATOR,
    IDC_AM_SYMBOL,  IDH_INTL_TIME_AMSYMBOL,
    IDC_PM_SYMBOL,  IDH_INTL_TIME_PMSYMBOL,
    IDC_GROUPBOX2,  IDH_INTL_TIME_FORMAT_NOTATION,
    IDC_SAMPLE2,    IDH_INTL_TIME_FORMAT_NOTATION,

    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  Time_DisplaySample
//
//  Update the Time sample.  Format the time based on the user's
//  current locale settings.
//
////////////////////////////////////////////////////////////////////////////

void Time_DisplaySample(
    HWND hDlg)
{
    TCHAR szBuf[MAX_SAMPLE_SIZE];

    //
    //  Show or hide the Arabic info based on the current user locale id.
    //
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLE1A), bShowArabic ? SW_SHOW : SW_HIDE);

    //
    //  Get the string representing the time format for the current system
    //  time and display it.  If the sample in the buffer is valid, display
    //  it.  Otherwise, display a message box indicating that there is a
    //  problem retrieving the locale information.
    //
    if (GetTimeFormat(UserLocaleID, 0, NULL, NULL, szBuf, MAX_SAMPLE_SIZE))
    {
        SetDlgItemText(hDlg, IDC_SAMPLE1, szBuf);
        if (bShowArabic)
        {
            SetDlgItemText(hDlg, IDC_SAMPLE1A, szBuf);
            SetDlgItemRTL(hDlg, IDC_SAMPLE1A);
        }
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Time_SaveValues
//
//  Save values in the case that we need to restore them.
//
////////////////////////////////////////////////////////////////////////////

void Time_SaveValues()
{
    //
    //  Save registry values.
    //
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_S1159,
                        sz_s1159,
                        MAX_S1159 + 1 ))
    {
        _tcscpy(sz_s1159, TEXT("AM"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_S2359,
                        sz_s2359,
                        MAX_S2359 + 1 ))
    {
        _tcscpy(sz_s2359, TEXT("PM"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_STIME,
                        sz_sTime,
                        MAX_STIME + 1 ))
    {
        _tcscpy(sz_sTime, TEXT(":"));
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_STIMEFORMAT,
                        sz_sTimeFormat,
                        MAX_FORMAT + 1 ))
    {
        _tcscpy(sz_sTimeFormat, TEXT("h:mm:ss tt"));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Time_RestoreValues
//
////////////////////////////////////////////////////////////////////////////

void Time_RestoreValues()
{
    if (g_dwCustChange & Process_Time)
    {
        SetLocaleInfo(UserLocaleID, LOCALE_S1159,       sz_s1159);
        SetLocaleInfo(UserLocaleID, LOCALE_S2359,       sz_s2359);
        SetLocaleInfo(UserLocaleID, LOCALE_STIME,       sz_sTime);
        SetLocaleInfo(UserLocaleID, LOCALE_STIMEFORMAT, sz_sTimeFormat);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Time_ClearValues
//
//  Reset each of the list boxes in the time property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Time_ClearValues(
    HWND hDlg)
{
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_AM_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_PM_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SEPARATOR));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_TIME_STYLE));
}


////////////////////////////////////////////////////////////////////////////
//
//  Time_SetValues
//
//  Initialize all of the controls in the time property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Time_SetValues(
    HWND hDlg)
{
    TCHAR szBuf[SIZE_128];
    DWORD dwIndex;
    HWND hCtrl = GetDlgItem(hDlg, IDC_TIME_STYLE);

    //
    //  Initialize the dropdown box for the current locale setting for:
    //  AM Symbol, PM Symbol, and Time Separator.
    //
    DropDown_Use_Locale_Values(hDlg, LOCALE_S1159, IDC_AM_SYMBOL);
    DropDown_Use_Locale_Values(hDlg, LOCALE_S2359, IDC_PM_SYMBOL);
    DropDown_Use_Locale_Values(hDlg, LOCALE_STIME, IDC_SEPARATOR);

    //
    //  Initialize and Lock function.  If it succeeds, call enum function to
    //  enumerate all possible values for the list box via a call to EnumProc.
    //  EnumProc will call Set_List_Values for each of the string values it
    //  receives.  When the enumeration of values is complete, call
    //  Set_List_Values to clear the dialog item specific data and to clear
    //  the lock on the function.  Perform this set of operations for all of
    //  the Time Styles.
    //
    if (Set_List_Values(hDlg, IDC_TIME_STYLE, 0))
    {
        EnumTimeFormats(EnumProc, UserLocaleID, 0);
        Set_List_Values(0, IDC_TIME_STYLE, 0);
        dwIndex = 0;
        if (GetLocaleInfo(UserLocaleID, LOCALE_STIMEFORMAT, szBuf, SIZE_128))
        {
            dwIndex = ComboBox_FindString(hCtrl, -1, szBuf);
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }

        Localize_Combobox_Styles(hDlg, IDC_TIME_STYLE, LOCALE_STIMEFORMAT);
        ComboBox_SetCurSel(hCtrl, dwIndex);
    }

    //
    //  Display the current sample that represents all of the locale settings.
    //
    Time_DisplaySample(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  Time_ApplySettings
//
//  For every control that has changed (that affects the Locale settings),
//  call Set_Locale_Values to update the user locale information.  Notify
//  the parent of changes and reset the change flag stored in the property
//  sheet page structure appropriately.  Redisplay the time sample if
//  bRedisplay is TRUE.
//
////////////////////////////////////////////////////////////////////////////

BOOL Time_ApplySettings(
    HWND hDlg,
    BOOL bRedisplay)
{
    TCHAR szBuf[SIZE_128];
    DWORD dwIndex;
    HWND hCtrl;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;

    if (Changes & TC_1159)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_S1159,
                                IDC_AM_SYMBOL,
                                TEXT("s1159"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & TC_2359)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_S2359,
                                IDC_PM_SYMBOL,
                                TEXT("s2359"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & TC_TimeFmt)
    {
        //
        //  szNLS_TimeStyle is set in Time_ValidatePPS.
        //
        if (!Set_Locale_Values( hDlg,
                                LOCALE_STIMEFORMAT,
                                IDC_TIME_STYLE,
                                0,
                                FALSE,
                                0,
                                0,
                                szNLS_TimeStyle ))
        {
            return (FALSE);
        }

#ifndef WINNT
        //
        //  The time marker gets:
        //    set to Null for 24 hour format and
        //    doesn't change for 12 hour format.
        //
        GetProfileString(szIntl, TEXT("iTime"), TEXT("0"), pTestBuf, 10);
        if (*pTestBuf == TC_FullTime)
        {
            SetLocaleInfo(UserLocaleID, LOCALE_S1159, TEXT(""));
            SetLocaleInfo(UserLocaleID, LOCALE_S2359, TEXT(""));
        }
        else
        {
            //
            //  Set time marker in the registry.
            //
            if (!Set_Locale_Values( 0,
                                    LOCALE_S1159,
                                    0,
                                    TEXT("s1159"),
                                    TRUE,
                                    0,
                                    0,
                                    NULL ))
            {
                return (FALSE);
            }
            if (!Set_Locale_Values( 0,
                                    LOCALE_S2359,
                                    0,
                                    TEXT("s2359"),
                                    TRUE,
                                    0,
                                    0,
                                    NULL ))
            {
                return (FALSE);
            }
        }
#endif

        //
        //  If the time separator has areadly been changed, then don't update
        //  it now as it will be updated down below.
        //
        if (!(Changes & TC_STime))
        {
            //
            //  Since the time style changed, reset time separator list box.
            //
            ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SEPARATOR));
            DropDown_Use_Locale_Values(hDlg, LOCALE_STIME, IDC_SEPARATOR);
            if (!Set_Locale_Values( hDlg,
                                    LOCALE_STIME,
                                    IDC_SEPARATOR,
                                    TEXT("sTime"),
                                    FALSE,
                                    0,
                                    0,
                                    NULL ))
            {
                return (FALSE);
            }
        }

        //
        //  Also need to reset the AM and PM list boxes.
        //
        ComboBox_ResetContent(GetDlgItem(hDlg, IDC_AM_SYMBOL));
        ComboBox_ResetContent(GetDlgItem(hDlg, IDC_PM_SYMBOL));
        DropDown_Use_Locale_Values(hDlg, LOCALE_S1159, IDC_AM_SYMBOL);
        DropDown_Use_Locale_Values(hDlg, LOCALE_S2359, IDC_PM_SYMBOL);
    }
    if (Changes & TC_STime)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_STIME,
                                IDC_SEPARATOR,
                                TEXT("sTime"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }

        //
        //  Since the time separator changed, update the time style
        //  list box.
        //
        hCtrl = GetDlgItem(hDlg, IDC_TIME_STYLE);
        ComboBox_ResetContent(hCtrl);
        if (Set_List_Values(hDlg, IDC_TIME_STYLE, 0))
        {
            EnumTimeFormats(EnumProc, UserLocaleID, 0);
            Set_List_Values(0, IDC_TIME_STYLE, 0);
            dwIndex = 0;
            if (GetLocaleInfo(UserLocaleID, LOCALE_STIMEFORMAT, szBuf, SIZE_128))
            {
                dwIndex = ComboBox_FindString(hCtrl, -1, szBuf);
            }
            else
            {
                MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
            }

            Localize_Combobox_Styles( hDlg,
                                      IDC_TIME_STYLE,
                                      LOCALE_STIMEFORMAT );
            ComboBox_SetCurSel(hCtrl, dwIndex);
        }
    }

    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    lpPropSheet->lParam = TC_EverChg;

    //
    //  Display the current sample that represents all of the locale settings.
    //
    if (bRedisplay)
    {
        Time_DisplaySample(hDlg);
    }

    //
    //  Changes made in the second level.
    //
    if (Changes)
    {
        g_dwCustChange |= Process_Time;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Time_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Time_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= TC_EverChg)
    {
        return (TRUE);
    }

    //
    //  If the AM symbol has changed, ensure that there are no digits
    //  contained in the new symbol.
    //
    if (Changes & TC_1159 &&
        Item_Has_Digits(hDlg, IDC_AM_SYMBOL, TRUE))
    {
        No_Numerals_Error(hDlg, IDC_AM_SYMBOL, IDS_LOCALE_AM_SYM);
        return (FALSE);
    }

    //
    //  If the PM symbol has changed, ensure that there are no digits
    //  contained in the new symbol.
    //
    if (Changes & TC_2359 &&
        Item_Has_Digits(hDlg, IDC_PM_SYMBOL, TRUE))
    {
        No_Numerals_Error(hDlg, IDC_PM_SYMBOL, IDS_LOCALE_PM_SYM);
        return (FALSE);
    }

    //
    //  If the time separator has changed, ensure that there are no digits
    //  and no invalid characters contained in the new separator.
    //
    if (Changes & TC_STime &&
        Item_Has_Digits_Or_Invalid_Chars( hDlg,
                                          IDC_SEPARATOR,
                                          FALSE,
                                          szInvalidSTime ))
    {
        No_Numerals_Error(hDlg, IDC_SEPARATOR, IDS_LOCALE_TIME_SEP);
        return (FALSE);
    }

    //
    //  If the time style has changed, ensure that there are only characters
    //  in this set " Hhmst,-./:;\" or localized equivalent, the separator
    //  string, and text enclosed in single quotes.
    //
    if (Changes & TC_TimeFmt)
    {
        if (NLSize_Style( hDlg,
                          IDC_TIME_STYLE,
                          szNLS_TimeStyle,
                          LOCALE_STIMEFORMAT ) ||
            Item_Check_Invalid_Chars( hDlg,
                                      szNLS_TimeStyle,
                                      szTimeChars,
                                      IDC_SEPARATOR,
                                      FALSE,
                                      szTCaseSwap,
                                      IDC_TIME_STYLE ))
        {
            Invalid_Chars_Error(hDlg, IDC_TIME_STYLE, IDS_LOCALE_TIME);
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Time_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Time_SetValues with the property
//  sheet handle to initialize all of the property sheet controls.  Limit
//  the length of the text in some of the ComboBoxes.
//
////////////////////////////////////////////////////////////////////////////

void Time_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    //
    //  The lParam holds a pointer to the property sheet page.  Save it
    //  for later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    Time_SetValues(hDlg);
    szNLS_TimeStyle[0] = 0;

    ComboBox_LimitText(GetDlgItem(hDlg, IDC_AM_SYMBOL),  MAX_S1159);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_PM_SYMBOL),  MAX_S2359);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_SEPARATOR),  MAX_STIME);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_TIME_STYLE), MAX_FORMAT);
}


////////////////////////////////////////////////////////////////////////////
//
//  TimeDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK TimeDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch (message)
    {
        case ( WM_NOTIFY ) :
        {
            lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Time)
                    {
                        Verified_Regional_Chg &= ~Process_Time;
                        Time_ClearValues(hDlg);
                        Time_SetValues(hDlg);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                   DWLP_MSGRESULT,
                                   !Time_ValidatePPS( hDlg,
                                                      lpPropSheet->lParam ) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Time_ApplySettings(hDlg, TRUE))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        //
                        //  Zero out the TC_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                       DWLP_MSGRESULT,
                                       PSNRET_INVALID_NOCHANGEPAGE );
                    }


                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            Time_InitPropSheet(hDlg, lParam);
            Time_SaveValues();
            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aTimeHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aTimeHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_AM_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= TC_1159;
                    }
                    break;
                }
                case ( IDC_PM_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= TC_2359;
                    }
                    break;
                }
                case ( IDC_SEPARATOR ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= TC_STime;
                    }
                    break;
                }
                case ( IDC_TIME_STYLE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= TC_TimeFmt;
                    }
                    break;
                }
            }

            //
            //  Turn on ApplyNow button.
            //
            if (lpPropSheet->lParam > TC_EverChg)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\cpls\intl\util.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    util.c

Abstract:

    This module implements the utility functions used by the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <shlwapi.h>
#include "intl.h"
#include <tchar.h>
#include <windowsx.h>
#include <userenv.h>
#include <regstr.h>
#include "intlhlp.h"
#include "maxvals.h"
#include "winnlsp.h"

//
//  Global Variables.
//

#ifdef UNICODE
#define NUM_CURRENCY_SYMBOLS      2
LPWSTR pCurrencySymbols[] =
{
    L"$",
    L"\x20ac"
};
#endif

#define NUM_DATE_SEPARATORS       3
LPTSTR pDateSeparators[] =
{
    TEXT("/"),
    TEXT("-"),
    TEXT(".")
};

#define NUM_NEG_NUMBER_FORMATS    5
LPTSTR pNegNumberFormats[] =
{
    TEXT("(1.1)"),
    TEXT("-1.1"),
    TEXT("- 1.1"),
    TEXT("1.1-"),
    TEXT("1.1 -")
};

#define NUM_POS_CURRENCY_FORMATS  4
LPTSTR pPosCurrencyFormats[] =
{
    TEXT("1.1"),
    TEXT("1.1"),
    TEXT(" 1.1"),
    TEXT("1.1 ")
};

#define NUM_NEG_CURRENCY_FORMATS  16
LPTSTR pNegCurrencyFormats[] =
{
    TEXT("(1.1)"),
    TEXT("-1.1"),
    TEXT("-1.1"),
    TEXT("1.1-"),
    TEXT("(1.1)"),
    TEXT("-1.1"),
    TEXT("1.1-"),
    TEXT("1.1-"),
    TEXT("-1.1 "),
    TEXT("- 1.1"),
    TEXT("1.1 -"),
    TEXT(" 1.1-"),
    TEXT(" -1.1"),
    TEXT("1.1- "),
    TEXT("( 1.1)"),
    TEXT("(1.1 )")
};

#define NUM_AM_SYMBOLS            1
LPTSTR pAMSymbols[] =
{
    TEXT("AM")
};

#define NUM_PM_SYMBOLS            1
LPTSTR pPMSymbols[] =
{
    TEXT("PM")
};





////////////////////////////////////////////////////////////////////////////
//
//  Intl_StrToLong
//
//  Returns the long integer value stored in the string.  Since these
//  values are coming back form the NLS API as ordinal values, do not
//  worry about double byte characters.
//
////////////////////////////////////////////////////////////////////////////

LONG Intl_StrToLong(
    LPTSTR szNum)
{
    LONG Rtn_Val = 0;

    while (*szNum)
    {
        Rtn_Val = (Rtn_Val * 10) + (*szNum - CHAR_ZERO);
        szNum++;
    }
    return (Rtn_Val);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_FileExists
//
//  Determines if the file exists and is accessible.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_FileExists(
    LPTSTR pFileName)
{
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    BOOL bRet;
    UINT OldMode;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(pFileName, &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        bRet = FALSE;
    }
    else
    {
        FindClose(FindHandle);
        bRet = TRUE;
    }

    SetErrorMode(OldMode);

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  TransNum
//
//  Converts a number string to a dword value (in hex).
//
////////////////////////////////////////////////////////////////////////////

DWORD TransNum(
    LPTSTR lpsz)
{
    DWORD dw = 0L;
    TCHAR c;

    while (*lpsz)
    {
        c = *lpsz++;

        if (c >= TEXT('A') && c <= TEXT('F'))
        {
            c -= TEXT('A') - 0xa;
        }
        else if (c >= TEXT('0') && c <= TEXT('9'))
        {
            c -= TEXT('0');
        }
        else if (c >= TEXT('a') && c <= TEXT('f'))
        {
            c -= TEXT('a') - 0xa;
        }
        else
        {
            break;
        }
        dw *= 0x10;
        dw += c;
    }
    return (dw);
}


////////////////////////////////////////////////////////////////////////////
//
//  Item_Has_Digits
//
//  Return true if the combo box specified by item in the property sheet
//  specified by the dialog handle contains any digits.
//
////////////////////////////////////////////////////////////////////////////

BOOL Item_Has_Digits(
    HWND hDlg,
    int nItemId,
    BOOL Allow_Empty)
{
    TCHAR szBuf[SIZE_128];
    LPTSTR lpszBuf = szBuf;
    HWND hCtrl = GetDlgItem(hDlg, nItemId);
    int dwIndex = ComboBox_GetCurSel(hCtrl);

    //
    //  If there is no selection, get whatever is in the edit box.
    //
    if (dwIndex == CB_ERR)
    {
        dwIndex = GetDlgItemText(hDlg, nItemId, szBuf, SIZE_128);
        if (dwIndex)
        {
            //
            //  Get text succeeded.
            //
            szBuf[dwIndex] = 0;
        }
        else
        {
            //
            //  Get text failed.
            //
            dwIndex = CB_ERR;
        }
    }
    else
    {
        ComboBox_GetLBText(hCtrl, dwIndex, szBuf);
    }

    if (dwIndex != CB_ERR)
    {
        while (*lpszBuf)
        {
#ifndef UNICODE
            if (IsDBCSLeadByte(*lpszBuf))
            {
                //
                //  Skip 2 bytes in the array.
                //
                lpszBuf += 2;
            }
            else
#endif
            {
                if ((*lpszBuf >= CHAR_ZERO) && (*lpszBuf <= CHAR_NINE))
                {
                    return (TRUE);
                }
                lpszBuf++;
            }
        }
        return (FALSE);
    }

    //
    //  The data retrieval failed.
    //  If !Allow_Empty, just return TRUE.
    //
    return (!Allow_Empty);
}


////////////////////////////////////////////////////////////////////////////
//
//  Item_Has_Digits_Or_Invalid_Chars
//
//  Return true if the combo box specified by item in the property sheet
//  specified by the dialog handle contains any digits or any of the
//  given invalid characters.
//
////////////////////////////////////////////////////////////////////////////

BOOL Item_Has_Digits_Or_Invalid_Chars(
    HWND hDlg,
    int nItemId,
    BOOL Allow_Empty,
    LPTSTR pInvalid)
{
    TCHAR szBuf[SIZE_128];
    LPTSTR lpszBuf = szBuf;
    HWND hCtrl = GetDlgItem(hDlg, nItemId);
    int dwIndex = ComboBox_GetCurSel(hCtrl);

    //
    //  If there is no selection, get whatever is in the edit box.
    //
    if (dwIndex == CB_ERR)
    {
        dwIndex = GetDlgItemText(hDlg, nItemId, szBuf, SIZE_128);
        if (dwIndex)
        {
            //
            //  Get text succeeded.
            //
            szBuf[dwIndex] = 0;
        }
        else
        {
            //
            //  Get text failed.
            //
            dwIndex = CB_ERR;
        }
    }
    else
    {
        dwIndex = ComboBox_GetLBText(hCtrl, dwIndex, szBuf);
    }

    if (dwIndex != CB_ERR)
    {
        while (*lpszBuf)
        {
#ifndef UNICODE
            if (IsDBCSLeadByte(*lpszBuf))
            {
                //
                //  Skip 2 bytes in the array.
                //
                lpszBuf += 2;
            }
            else
#endif
            {
                if ( ((*lpszBuf >= CHAR_ZERO) && (*lpszBuf <= CHAR_NINE)) ||
                     (_tcschr(pInvalid, *lpszBuf)) )
                {
                    return (TRUE);
                }
                lpszBuf++;
            }
        }
        return (FALSE);
    }

    //
    //  The data retrieval failed.
    //  If !Allow_Empty, just return TRUE.
    //
    return (!Allow_Empty);
}


////////////////////////////////////////////////////////////////////////////
//
//  Item_Check_Invalid_Chars
//
//  Return true if the input string contains any characters that are not in
//  lpCkChars or in the string contained in the check id control combo box.
//  If there is an invalid character and the character is contained in
//  lpChgCase, change the invalid character's case so that it will be a
//  vaild character.
//
////////////////////////////////////////////////////////////////////////////

BOOL Item_Check_Invalid_Chars(
    HWND hDlg,
    LPTSTR lpszBuf,
    LPTSTR lpCkChars,
    int nCkIdStr,
    BOOL Allow_Empty,
    LPTSTR lpChgCase,
    int nItemId)
{
    TCHAR szCkBuf[SIZE_128];
    LPTSTR lpCCaseChar;
    LPTSTR lpszSaveBuf = lpszBuf;
    int nCkBufLen;
    BOOL bInQuote = FALSE;
    BOOL UpdateEditTest = FALSE;
    HWND hCtrl = GetDlgItem(hDlg, nCkIdStr);
    DWORD dwIndex = ComboBox_GetCurSel(hCtrl);
    BOOL TextFromEditBox = (ComboBox_GetCurSel(GetDlgItem(hDlg, nItemId)) == CB_ERR);

    if (!lpszBuf)
    {
        return (!Allow_Empty);
    }

    if (dwIndex != CB_ERR)
    {
        nCkBufLen = ComboBox_GetLBText(hCtrl, dwIndex, szCkBuf);
        if (nCkBufLen == CB_ERR)
        {
            nCkBufLen = 0;
        }
    }
    else
    {
        //
        //  No selection, so pull the string from the edit portion.
        //
        nCkBufLen = GetDlgItemText(hDlg, nCkIdStr, szCkBuf, SIZE_128);
        szCkBuf[nCkBufLen] = 0;
    }

    while (*lpszBuf)
    {
#ifndef UNICODE
        if (IsDBCSLeadByte(*lpszBuf))
        {
            //
            //  If the the text is in the midst of a quote, skip it.
            //  Otherwise, if there is a string from the check ID to
            //  compare, determine if the current string is equal to the
            //  string in the combo box.  If it is not equal, return true
            //  (there are invalid characters).  Otherwise, skip the entire
            //  length of the "check" combo box's string in lpszBuf.
            //
            if (bInQuote)
            {
                lpszBuf += 2;
            }
            else if (nCkBufLen &&
                     lstrlen(lpszBuf) >= nCkBufLen)
            {
                if (CompareString( UserLocaleID,
                                   0,
                                   szCkBuf,
                                   nCkBufLen,
                                   lpszBuf,
                                   nCkBufLen ) != CSTR_EQUAL)
                {
                    //
                    //  Invalid DB character.
                    //
                    return (TRUE);
                }
                lpszBuf += nCkBufLen;
            }
        }
        else
#endif
        {
            if (bInQuote)
            {
                bInQuote = (*lpszBuf != CHAR_QUOTE);
                lpszBuf++;
            }
            else if (_tcschr(lpCkChars, *lpszBuf))
            {
                lpszBuf++;
            }
            else if (TextFromEditBox &&
                     (lpCCaseChar = _tcschr(lpChgCase, *lpszBuf), lpCCaseChar))
            {
                *lpszBuf = lpCkChars[lpCCaseChar - lpChgCase];
                UpdateEditTest = TRUE;
                lpszBuf++;
            }
            else if (*lpszBuf == CHAR_QUOTE)
            {
                lpszBuf++;
                bInQuote = TRUE;
            }
            else if ( (nCkBufLen) &&
                      (lstrlen(lpszBuf) >= nCkBufLen) &&
                      (CompareString( UserLocaleID,
                                      0,
                                      szCkBuf,
                                      nCkBufLen,
                                      lpszBuf,
                                      nCkBufLen ) == CSTR_EQUAL) )
            {
                lpszBuf += nCkBufLen;
            }
            else
            {
                //
                //  Invalid character.
                //
                return (TRUE);
            }
        }
    }

    //
    //  Parsing passed.
    //  If the edit text changed, update edit box only if returning true.
    //
    if (!bInQuote && UpdateEditTest)
    {
        return (!SetDlgItemText(hDlg, nItemId, lpszSaveBuf));
    }

    //
    //  If there are unmatched quotes return TRUE.  Otherwise, return FALSE.
    //
    if (bInQuote)
    {
        return (TRUE);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  No_Numerals_Error
//
//  Display the no numerals allowed in "some control" error.
//
////////////////////////////////////////////////////////////////////////////

void No_Numerals_Error(
    HWND hDlg,
    int nItemId,
    int iStrId)
{
    TCHAR szBuf[SIZE_300];
    TCHAR szBuf2[SIZE_128];
    TCHAR szErrorMessage[SIZE_300+SIZE_128];

    LoadString(hInstance, IDS_LOCALE_NO_NUMS_IN, szBuf, SIZE_300);
    LoadString(hInstance, iStrId, szBuf2, SIZE_128);
    wsprintf(szErrorMessage, szBuf, szBuf2);
    MessageBox(hDlg, szErrorMessage, NULL, MB_OK | MB_ICONINFORMATION);
    SetFocus(GetDlgItem(hDlg, nItemId));
}


////////////////////////////////////////////////////////////////////////////
//
//  Invalid_Chars_Error
//
//  Display the invalid chars in "some style" error.
//
////////////////////////////////////////////////////////////////////////////

void Invalid_Chars_Error(
    HWND hDlg,
    int nItemId,
    int iStrId)
{
    TCHAR szBuf[SIZE_300];
    TCHAR szBuf2[SIZE_128];
    TCHAR szErrorMessage[SIZE_300+SIZE_128];

    LoadString(hInstance, IDS_LOCALE_STYLE_ERR, szBuf, SIZE_300);
    LoadString(hInstance, iStrId, szBuf2, SIZE_128);
    wsprintf(szErrorMessage, szBuf, szBuf2);
    MessageBox(hDlg, szErrorMessage, NULL, MB_OK | MB_ICONINFORMATION);
    SetFocus(GetDlgItem(hDlg, nItemId));
}


////////////////////////////////////////////////////////////////////////////
//
//  Localize_Combobox_Styles
//
//  Transform either all date or time style, as indicated by LCType, in
//  the indicated combobox from a value that the NLS will provide to a
//  localized value.
//
////////////////////////////////////////////////////////////////////////////

void Localize_Combobox_Styles(
    HWND hDlg,
    int nItemId,
    LCTYPE LCType)
{
    BOOL bInQuote = FALSE;
    BOOL Map_Char = TRUE;
    TCHAR szBuf1[SIZE_128];
    TCHAR szBuf2[SIZE_128];
    LPTSTR lpszInBuf = szBuf1;
    LPTSTR lpszOutBuf = szBuf2;
    HWND hCtrl = GetDlgItem(hDlg, nItemId);
    DWORD ItemCnt = ComboBox_GetCount(hCtrl);
    DWORD Position = 0;
    DWORD dwIndex;

    if (!Styles_Localized)
    {
        return;
    }

    while (Position < ItemCnt)
    {
        //
        //  Could check character count with CB_GETLBTEXTLEN to make sure
        //  that the item text will fit in 128, but max values for these
        //  items is 79 chars.
        //
        dwIndex = ComboBox_GetLBText(hCtrl, Position, szBuf1);
        if (dwIndex != CB_ERR)
        {
            lpszInBuf = szBuf1;
            lpszOutBuf = szBuf2;
            while (*lpszInBuf)
            {
                Map_Char = TRUE;
#ifndef UNICODE
                if (IsDBCSLeadByte(*lpszInBuf))
                {
                    //
                    //  Copy any double byte character straight through.
                    //
                    *lpszOutBuf++ = *lpszInBuf++;
                    *lpszOutBuf++ = *lpszInBuf++;
                }
                else
#endif
                {
                    if (*lpszInBuf == CHAR_QUOTE)
                    {
                        bInQuote = !bInQuote;
                        *lpszOutBuf++ = *lpszInBuf++;
                    }
                    else
                    {
                        if (!bInQuote)
                        {
                            if (LCType == LOCALE_STIMEFORMAT ||
                                LCType == LOCALE_SLONGDATE)
                            {
                                Map_Char = FALSE;
                                if (CompareString( UserLocaleID,
                                                   0,
                                                   lpszInBuf,
                                                   1,
                                                   TEXT("H"),
                                                   1 ) == CSTR_EQUAL)
                                {
                                    *lpszOutBuf++ = szStyleH[0];
#ifndef UNICODE
                                    if (IsDBCSLeadByte(*szStyleH))
                                    {
                                        *lpszOutBuf++ = szStyleH[1];
                                    }
#endif
                                }
                                else if (CompareString( UserLocaleID,
                                                        0,
                                                        lpszInBuf,
                                                        1,
                                                        TEXT("h"),
                                                        1 ) == CSTR_EQUAL)
                                {
                                    *lpszOutBuf++ = szStyleh[0];
#ifndef UNICODE
                                    if (IsDBCSLeadByte(*szStyleh))
                                    {
                                        *lpszOutBuf++ = szStyleh[1];
                                    }
#endif
                                }
                                else if (CompareString( UserLocaleID,
                                                        0,
                                                        lpszInBuf,
                                                        1,
                                                        TEXT("m"),
                                                        1 ) == CSTR_EQUAL)
                                {
                                    *lpszOutBuf++ = szStylem[0];
#ifndef UNICODE
                                    if (IsDBCSLeadByte(*szStylem))
                                    {
                                        *lpszOutBuf++ = szStylem[1];
                                    }
#endif
                                }
                                else if (CompareString( UserLocaleID,
                                                        0,
                                                        lpszInBuf,
                                                        1,
                                                        TEXT("s"),
                                                        1 ) == CSTR_EQUAL)
                                {
                                    *lpszOutBuf++ = szStyles[0];
#ifndef UNICODE
                                    if (IsDBCSLeadByte(*szStyles))
                                    {
                                        *lpszOutBuf++ = szStyles[1];
                                    }
#endif
                                }
                                else if (CompareString( UserLocaleID,
                                                        0,
                                                        lpszInBuf,
                                                        1,
                                                        TEXT("t"),
                                                        1 ) == CSTR_EQUAL)
                                {
                                    *lpszOutBuf++ = szStylet[0];
#ifndef UNICODE
                                    if (IsDBCSLeadByte(*szStylet))
                                    {
                                        *lpszOutBuf++ = szStylet[1];
                                    }
#endif
                                }
                                else
                                {
                                    Map_Char = TRUE;
                                }
                            }
                            if (LCType == LOCALE_SSHORTDATE ||
                                (LCType == LOCALE_SLONGDATE && Map_Char))
                            {
                                Map_Char = FALSE;
                                if (CompareString( UserLocaleID,
                                                   0,
                                                   lpszInBuf,
                                                   1,
                                                   TEXT("d"),
                                                   1 ) == CSTR_EQUAL)
                                {
                                    *lpszOutBuf++ = szStyled[0];
#ifndef UNICODE
                                    if (IsDBCSLeadByte(*szStyled))
                                    {
                                        *lpszOutBuf++ = szStyled[1];
                                    }
#endif
                                }
                                else if (CompareString( UserLocaleID,
                                                        0,
                                                        lpszInBuf,
                                                        1,
                                                        TEXT("M"),
                                                        1 ) == CSTR_EQUAL)
                                {
                                    *lpszOutBuf++ = szStyleM[0];
#ifndef UNICODE
                                    if (IsDBCSLeadByte(*szStyleM))
                                    {
                                        *lpszOutBuf++ = szStyleM[1];
                                    }
#endif
                                }
                                else if (CompareString( UserLocaleID,
                                                        0,
                                                        lpszInBuf,
                                                        1,
                                                        TEXT("y"),
                                                        1 ) == CSTR_EQUAL)
                                {
                                    *lpszOutBuf++ = szStyley[0];
#ifndef UNICODE
                                    if (IsDBCSLeadByte(*szStyley))
                                    {
                                        *lpszOutBuf++ = szStyley[1];
                                    }
#endif
                                }
                                else
                                {
                                    Map_Char = TRUE;
                                }
                            }
                        }

                        if (Map_Char)
                        {
                            *lpszOutBuf++ = *lpszInBuf++;
                        }
                        else
                        {
                            lpszInBuf++;
                        }
                    }
                }
            }

            //
            //  Append null to localized string.
            //
            *lpszOutBuf = 0;

            ComboBox_DeleteString(hCtrl, Position);
            ComboBox_InsertString(hCtrl, Position, szBuf2);
        }
        Position++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  NLSize_Style
//
//  Transform either date or time style, as indicated by LCType, from a
//  localized value to one that the NLS API will recognize.
//
////////////////////////////////////////////////////////////////////////////

BOOL NLSize_Style(
    HWND hDlg,
    int nItemId,
    LPTSTR lpszOutBuf,
    LCTYPE LCType)
{
    BOOL bInQuote = FALSE;
    BOOL Map_Char = TRUE;
    TCHAR szBuf[SIZE_128];
    LPTSTR lpszInBuf = szBuf;
    LPTSTR lpNLSChars1;
    LPTSTR lpNLSChars2;
    HWND hCtrl = GetDlgItem(hDlg, nItemId);
    DWORD dwIndex = ComboBox_GetCurSel(hCtrl);
    BOOL TextFromEditBox = dwIndex == CB_ERR;
    int Cmp_Size;
#ifndef UNICODE
    BOOL Is_Dbl = FALSE;
#endif

    //
    //  If there is no selection, get whatever is in the edit box.
    //
    if (TextFromEditBox)
    {
        dwIndex = GetDlgItemText(hDlg, nItemId, szBuf, SIZE_128);
        if (dwIndex)
        {
            //
            //  Get text succeeded.
            //
            szBuf[dwIndex] = 0;
        }
        else
        {
            //
            //  Get text failed.
            //
            dwIndex = (DWORD)CB_ERR;
        }
    }
    else
    {
        dwIndex = ComboBox_GetLBText(hCtrl, dwIndex, szBuf);
    }

    if (!Styles_Localized)
    {
        lstrcpy(lpszOutBuf, lpszInBuf);
        return (FALSE);
    }

    switch (LCType)
    {
        case ( LOCALE_STIMEFORMAT ) :
        {
            lpNLSChars1 = szTLetters;
            lpNLSChars2 = szTCaseSwap;
            break;
        }
        case ( LOCALE_SLONGDATE ) :
        {
            lpNLSChars1 = szLDLetters;
            lpNLSChars2 = szLDCaseSwap;
            break;
        }
        case ( LOCALE_SSHORTDATE ) :
        {
            lpNLSChars1 = szSDLetters;
            lpNLSChars2 = szSDCaseSwap;
            break;
        }
    }

    while (*lpszInBuf)
    {
        Map_Char = TRUE;
#ifdef UNICODE
        Cmp_Size = 1;
#else
        Is_Dbl = IsDBCSLeadByte(*lpszInBuf);
        Cmp_Size = Is_Dbl ? 2 : 1;
#endif

        if (*lpszInBuf == CHAR_QUOTE)
        {
            bInQuote = !bInQuote;
            *lpszOutBuf++ = *lpszInBuf++;
        }
        else
        {
            if (!bInQuote)
            {
                if (LCType == LOCALE_STIMEFORMAT || LCType == LOCALE_SLONGDATE)
                {
                    Map_Char = FALSE;
                    if (CompareString( UserLocaleID,
                                       0,
                                       lpszInBuf,
                                       Cmp_Size,
                                       szStyleH,
                                       -1 ) == CSTR_EQUAL)
                    {
                        *lpszOutBuf++ = CHAR_CAP_H;
                    }
                    else if (CompareString( UserLocaleID,
                                            0,
                                            lpszInBuf,
                                            Cmp_Size,
                                            szStyleh,
                                            -1 ) == CSTR_EQUAL)
                    {
                        *lpszOutBuf++ = CHAR_SML_H;
                    }
                    else if (CompareString( UserLocaleID,
                                            0,
                                            lpszInBuf,
                                            Cmp_Size,
                                            szStylem,
                                            -1 ) == CSTR_EQUAL)
                    {
                        *lpszOutBuf++ = CHAR_SML_M;
                    }
                    else if (CompareString( UserLocaleID,
                                            0,
                                            lpszInBuf,
                                            Cmp_Size,
                                            szStyles,
                                            -1 ) == CSTR_EQUAL)
                    {
                        *lpszOutBuf++ = CHAR_SML_S;
                    }
                    else if (CompareString( UserLocaleID,
                                            0,
                                            lpszInBuf,
                                            Cmp_Size,
                                            szStylet,
                                            -1 ) == CSTR_EQUAL)
                    {
                        *lpszOutBuf++ = CHAR_SML_T;
                    }
                    else
                    {
                        Map_Char = TRUE;
                    }
                }
                if (LCType == LOCALE_SSHORTDATE ||
                    (LCType == LOCALE_SLONGDATE && Map_Char))
                {
                    Map_Char = FALSE;
                    if (CompareString( UserLocaleID,
                                       0,
                                       lpszInBuf,
                                       Cmp_Size,
                                       szStyled,
                                       -1 ) == CSTR_EQUAL)
                    {
                        *lpszOutBuf++ = CHAR_SML_D;
                    }
                    else if (CompareString( UserLocaleID,
                                            0,
                                            lpszInBuf,
                                            Cmp_Size,
                                            szStyleM,
                                            -1) == CSTR_EQUAL)
                    {
                        *lpszOutBuf++ = CHAR_CAP_M;
                    }
                    else if (CompareString( UserLocaleID,
                                            0,
                                            lpszInBuf,
                                            Cmp_Size,
                                            szStyley,
                                            -1 ) == CSTR_EQUAL)
                    {
                        *lpszOutBuf++ = CHAR_SML_Y;
                    }
                    else if (CompareString( UserLocaleID,
                                            0,
                                            lpszInBuf,
                                            Cmp_Size,
                                            TEXT("g"),
                                            -1) == CSTR_EQUAL)
                    {
                        //
                        //  g is not localized, but it's legal.
                        //
                        *lpszOutBuf++ = CHAR_SML_G;
                    }
                    else
                    {
                        Map_Char = TRUE;
                    }
                }
            }

            if (Map_Char)
            {
                //
                //  Just copy chars in quotes or chars that are not
                //  recognized. Leave the char checking to the other
                //  function.  However, do check for NLS standard chars
                //  that were not supposed to be here due to localization.
                //
                if ( !bInQuote &&
#ifndef UNICODE
                     !Is_Dbl &&
#endif
                     (CompareString( UserLocaleID,
                                     0,
                                     lpszInBuf,
                                     Cmp_Size,
                                     TEXT(" "),
                                     -1 ) != CSTR_EQUAL) &&
                     ( _tcschr(lpNLSChars1, *lpszInBuf) ||
                       _tcschr(lpNLSChars2, *lpszInBuf) ) )
                {
                    return (TRUE);
                }
                *lpszOutBuf++ = *lpszInBuf++;
#ifndef UNICODE
                if (Is_Dbl)
                {
                    //
                    //  Copy 2nd byte.
                    //
                    *lpszOutBuf++ = *lpszInBuf++;
                }
#endif
            }
#ifndef UNICODE
            else if (Is_Dbl)
            {
                lpszInBuf += 2;
            }
#endif
            else
            {
                lpszInBuf++;
            }
        }
    }

    //
    //  Append null to localized string.
    //
    *lpszOutBuf = 0;

    return (FALSE);
}


#ifndef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  SDate3_1_Compatibility
//
//  There is a requirement to keep windows 3.1 compatibility in the
//  registry (win.ini).  Only allow 1 or 2 'M's, 1 or 2 'd's, and
//  2 or 4 'y's.  The remainder of the date style is compatible.
//
////////////////////////////////////////////////////////////////////////////

void SDate3_1_Compatibility(
    LPTSTR lpszBuf,
    int Buf_Size)
{
    BOOL bInQuote = FALSE;
    int Index, Del_Cnt;
    int Len = lstrlen(lpszBuf);
    int MCnt = 0;                 // running total of Ms
    int dCnt = 0;                 // running total of ds
    int yCnt = 0;                 // running total of ys

    while (*lpszBuf)
    {
#ifndef UNICODE
        if (IsDBCSLeadByte(*lpszBuf))
        {
            lpszBuf += 2;
        }
        else
#endif
        {
            if (bInQuote)
            {
                bInQuote = (*lpszBuf != CHAR_QUOTE);
                lpszBuf++;
            }
            else if (*lpszBuf == CHAR_CAP_M)
            {
                if (MCnt++ < 2)
                {
                    lpszBuf++;
                }
                else
                {
                    //
                    //  At least 1 extra M.  Move all of the chars, including
                    //  null, up by Del_Cnt.
                    //
                    Del_Cnt = 1;
                    Index = 1;
                    while (lpszBuf[Index++] == CHAR_CAP_M)
                    {
                        Del_Cnt++;
                    }
                    for (Index = 0; Index <= Len - Del_Cnt + 1; Index++)
                    {
                        lpszBuf[Index] = lpszBuf[Index + Del_Cnt];
                    }
                    Len -= Del_Cnt;
                }
            }
            else if (*lpszBuf == CHAR_SML_D)
            {
                if (dCnt++ < 2)
                {
                    lpszBuf++;
                }
                else
                {
                    //
                    //  At least 1 extra d.  Move all of the chars, including
                    //  null, up by Del_Cnt.
                    //
                    Del_Cnt = 1;
                    Index = 1;
                    while (lpszBuf[Index++] == CHAR_SML_D)
                    {
                        Del_Cnt++;
                    }
                    for (Index = 0; Index <= Len - Del_Cnt + 1; Index++)
                    {
                        lpszBuf[Index] = lpszBuf[Index + Del_Cnt];
                    }
                    Len -= Del_Cnt;
                }
            }
            else if (*lpszBuf == CHAR_SML_Y)
            {
                if (yCnt == 0 || yCnt == 2)
                {
                    if (lpszBuf[1] == CHAR_SML_Y)
                    {
                        lpszBuf += 2;
                        yCnt += 2;
                    }
                    else if (Len < Buf_Size - 1)
                    {
                        //
                        //  Odd # of ys & room for one more.
                        //  Move the remaining text down by 1 (the y will
                        //  be copied).
                        //
                        //  Use Del_Cnt for unparsed string length.
                        //
                        Del_Cnt = lstrlen(lpszBuf);
                        for (Index = Del_Cnt + 1; Index > 0; Index--)
                        {
                            lpszBuf[Index] = lpszBuf[Index - 1];
                        }
                    }
                    else
                    {
                        //
                        //  No room, move all of the chars, including null,
                        //  up by 1.
                        //
                        for (Index = 0; Index <= Len; Index++)
                        {
                            lpszBuf[Index] = lpszBuf[Index + 1];
                        }
                        Len--;
                    }
                }
                else
                {
                    //
                    //  At least 1 extra y.  Move all of the chars, including
                    //  null, up by Del_Cnt.
                    //
                    Del_Cnt = 1;
                    Index = 1;
                    while (lpszBuf[Index++] == CHAR_SML_Y)
                    {
                        Del_Cnt++;
                    }
                    for (Index = 0; Index <= Len - Del_Cnt + 1; Index++)
                    {
                        lpszBuf[Index] = lpszBuf[Index + Del_Cnt];
                    }
                    Len -= Del_Cnt;
                }
            }
            else if (*lpszBuf == CHAR_QUOTE)
            {
                lpszBuf++;
                bInQuote = TRUE;
            }
            else
            {
                lpszBuf++;
            }
        }
    }
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  Set_Locale_Values
//
//  Set_Locale_Values is called for each LCType that has either been
//  directly modified via a user change, or indirectly modified by the user
//  changing the regional locale setting.  When a dialog handle is available,
//  Set_Locale_Values will pull the new value of the LCType from the
//  appropriate list box (this is a direct change), register it in the
//  locale database, and then update the registry string.  If no dialog
//  handle is available, it will simply update the registry string based on
//  the locale registry.  If the registration succeeds, return true.
//  Otherwise, return false.
//
////////////////////////////////////////////////////////////////////////////

BOOL Set_Locale_Values(
    HWND hDlg,
    LCTYPE LCType,
    int nItemId,
    LPTSTR lpIniStr,
    BOOL bValue,
    int Ordinal_Offset,
    LPTSTR Append_Str,
    LPTSTR NLS_Str)
{
    DWORD dwIndex;
    BOOL bSuccess = TRUE;
    TCHAR szBuf[SIZE_128 + 1];
    LPTSTR pBuf = szBuf;
    HWND hCtrl;

    if (NLS_Str)
    {
        //
        //  Use a non-localized string.
        //
        lstrcpy(pBuf, NLS_Str);
        bSuccess = SetLocaleInfo(UserLocaleID, LCType, pBuf);
    }
    else if (hDlg)
    {
        //
        //  Get the new value from the list box.
        //
        hCtrl = GetDlgItem(hDlg, nItemId);
        dwIndex = ComboBox_GetCurSel(hCtrl);

        //
        //  If there is no selection, get whatever is in the edit box.
        //
        if (dwIndex == CB_ERR)
        {
            dwIndex = GetDlgItemText(hDlg, nItemId, pBuf, SIZE_128);
            if (dwIndex)
            {
                //
                //  Get text succeeded.
                //
                pBuf[dwIndex] = 0;
            }
            else
            {
                //
                //  Get text failed.
                //  Allow the AM/PM symbols to be set as empty strings.
                //  Otherwise, fail.
                //
                if ((LCType == LOCALE_S1159) || (LCType == LOCALE_S2359))
                {
                    pBuf[0] = 0;
                }
                else
                {
                    bSuccess = FALSE;
                }
            }
        }
        else if (bValue)
        {
            //
            //  Need string representation of ordinal locale value.
            //
            if (nItemId == IDC_CALENDAR_TYPE)
            {
                dwIndex = (DWORD)ComboBox_GetItemData(hCtrl, dwIndex);
            }
            else
            {
                //
                //  Ordinal_Offset is required since calendar is 1 based,
                //  not 0 based.
                //
                dwIndex += Ordinal_Offset;
            }

            //
            //  Special case the grouping string.
            //
            if (nItemId == IDC_NUM_DIGITS_GROUP)
            {
                switch (dwIndex)
                {
                    case ( 0 ) :
                    {
                        lstrcpy(pBuf, TEXT("0"));
                        break;
                    }
                    case ( 1 ) :
                    {
                        lstrcpy(pBuf, TEXT("3"));
                        break;
                    }
                    case ( 2 ) :
                    {
                        lstrcpy(pBuf, TEXT("3;2"));
                        break;
                    }
                    case ( 3 ) :
                    {
                        wsprintf( pBuf,
                                  TEXT("%d"),
                                  ComboBox_GetItemData(hCtrl, dwIndex) );
                        break;
                    }
                }
            }
            else if (dwIndex < cInt_Str)
            {
                lstrcpy(pBuf, aInt_Str[dwIndex]);
            }
            else
            {
                wsprintf(pBuf, TEXT("%d"), dwIndex);
            }
        }
        else
        {
            //
            //  Get actual value of locale data.
            //
            bSuccess = (ComboBox_GetLBText(hCtrl, dwIndex, pBuf) != CB_ERR);
        }

        if (bSuccess)
        {
            //
            //  If edit text, index value or selection text succeeds...
            //
            if (Append_Str)
            {
                lstrcat(pBuf, Append_Str);
            }

            //
            //  If this is sNativeDigits, the LPK is installed, and the
            //  first char is 0x206f (nominal digit shapes), then do not
            //  store the first char in the registry.
            //
            if ((LCType == LOCALE_SNATIVEDIGITS) &&
                (bLPKInstalled) &&
                (pBuf[0] == TEXT('\x206f')))
            {
                pBuf++;
            }
            bSuccess = SetLocaleInfo( UserLocaleID, LCType, pBuf );
        }
    }

    if (lpIniStr && bSuccess)
    {
        //
        //  Set the registry string to the string that is stored in the list
        //  box.  If there is no dialog handle, get the required string
        //  locale value from the NLS function.  Write the associated string
        //  into the registry.
        //
        if (!hDlg && !NLS_Str)
        {
            GetLocaleInfo( UserLocaleID,
                           LCType | LOCALE_NOUSEROVERRIDE,
                           pBuf,
                           SIZE_128 );
        }

#ifndef WINNT
        //
        //  There is a requirement to keep windows 3.1 compatibility in the
        //  win.ini.  There are some win32 short date formats that are
        //  incompatible with exisiting win 3.1 apps... modify these styles.
        //
        if (LCType == LOCALE_SSHORTDATE)
        {
            SDate3_1_Compatibility(pBuf, SIZE_128);
        }
#endif

        //
        //  Check the value whether it is empty or not.
        //
        switch (LCType)
        {
            case ( LOCALE_STHOUSAND ) :
            case ( LOCALE_SDECIMAL ) :
            case ( LOCALE_SDATE ) :
            case ( LOCALE_STIME ) :
            case ( LOCALE_SLIST ) :
            {
                CheckEmptyString(pBuf);
                break;
            }
        }

        //
        //  Set the locale information in the registry.
        //
        //  NOTE: We want to use SetLocaleInfo if possible so that the
        //        NLS cache is updated right away.  Otherwise, we'll
        //        simply use WriteProfileString.
        //
        if (!SetLocaleInfo(UserLocaleID, LCType, pBuf))
        {
            WriteProfileString(szIntl, lpIniStr, pBuf);
        }
    }
    else if (!bSuccess)
    {
        LoadString(hInstance, IDS_LOCALE_SET_ERROR, szBuf, SIZE_128);
        MessageBox(hDlg, szBuf, NULL, MB_OK | MB_ICONINFORMATION);
        SetFocus(GetDlgItem(hDlg, nItemId));
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Set_List_Values
//
//  Set_List_Values is called several times for each drop down list which is
//  populated via an enum function.  The first call to this function should
//  be with a valid dialog handle, valid dialog item ID, and null string
//  value.  If the function is not already in use, it will clear the list box
//  and store the handle and id information for the subsequent calls to this
//  function that will be made by the enumeration function.  The calls from
//  the enumeration function will add the specified string values to the
//  list box.  When the enumeration function is complete, this function
//  should be called with a null dialog handle, the valid dialog item id,
//  and a null string value.  This will clear all of the state information,
//  including the lock flag.
//
////////////////////////////////////////////////////////////////////////////

BOOL Set_List_Values(
    HWND hDlg,
    int nItemId,
    LPTSTR lpValueString)
{
    static BOOL bLock, bString;
    static HWND hDialog;
    static int nDItemId, nID;

    if (!lpValueString)
    {
        //
        //  Clear the lock if there is no dialog handle and the item IDs
        //  match.
        //
        if (bLock && !hDlg && (nItemId == nDItemId))
        {
            if (nItemId != IDC_CALENDAR_TYPE)
            {
                hDialog = 0;
                nDItemId = 0;
                bLock = FALSE;
            }
            else
            {
                if (bString)
                {
                    hDialog = 0;
                    nDItemId = 0;
                    bLock = FALSE;
                    bString = FALSE;
                }
                else
                {
                    nID = 0;
                    bString = TRUE;
                }
            }
            return (TRUE);
        }

        //
        //  Return false, for failure, if the function is locked or if the
        //  handle or ID parameters are null.
        //
        if (bLock || !hDlg || !nItemId)
        {
            return (FALSE);
        }

        //
        //  Prepare for subsequent calls to populate the list box.
        //
        bLock = TRUE;
        hDialog = hDlg;
        nDItemId = nItemId;
    }
    else if (bLock && hDialog && nDItemId)
    {
        //
        //  Add the string to the list box.
        //
        if (!bString)
        {
            ComboBox_InsertString( GetDlgItem(hDialog, nDItemId),
                                   -1,
                                   lpValueString );
        }
        else
        {
            ComboBox_SetItemData( GetDlgItem(hDialog, nDItemId),
                                  nID++,
                                  Intl_StrToLong(lpValueString) );
        }
    }
    else
    {
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DropDown_Use_Locale_Values
//
//  Get the user locale value for the locale type specifier.  Add it to
//  the list box and make this value the current selection.  If the user
//  locale value for the locale type is different than the system value,
//  add the system value to the list box.  If the user default is different
//  than the user override, add the user default.
//
////////////////////////////////////////////////////////////////////////////

void DropDown_Use_Locale_Values(
    HWND hDlg,
    LCTYPE LCType,
    int nItemId)
{
    TCHAR szBuf[SIZE_128];
    TCHAR szCmpBuf1[SIZE_128];
    TCHAR szCmpBuf2[SIZE_128];
    HWND hCtrl = GetDlgItem(hDlg, nItemId);
    int ctr;

    if (GetLocaleInfo(UserLocaleID, LCType, szBuf, SIZE_128))
    {
        ComboBox_SetCurSel(hCtrl, ComboBox_InsertString(hCtrl, -1, szBuf));

        //
        //  If the system setting is different, add it to the list box.
        //
        if (GetLocaleInfo( SysLocaleID,
                           LCType | LOCALE_NOUSEROVERRIDE,
                           szCmpBuf1,
                           SIZE_128 ))
        {
            if (CompareString( UserLocaleID,
                               0,
                               szCmpBuf1,
                               -1,
                               szBuf,
                               -1 ) != CSTR_EQUAL)
            {
                ComboBox_InsertString(hCtrl, -1, szCmpBuf1);
            }
        }

        //
        //  If the default user locale setting is different than the user
        //  overridden setting and different than the system setting, add
        //  it to the list box.
        //
        if (GetLocaleInfo( UserLocaleID,
                           LCType | LOCALE_NOUSEROVERRIDE,
                           szCmpBuf2,
                           SIZE_128 ))
        {
            if (CompareString(UserLocaleID, 0, szCmpBuf2, -1, szBuf, -1) != CSTR_EQUAL &&
                CompareString(UserLocaleID, 0, szCmpBuf2, -1, szCmpBuf1, -1) != CSTR_EQUAL)
            {
                ComboBox_InsertString(hCtrl, -1, szCmpBuf2);
            }
        }
    }
    else
    {
        //
        //  Failed to get user value, try for system value.  If system value
        //  fails, display a message box indicating that there was a locale
        //  problem.
        //
        if (GetLocaleInfo( SysLocaleID,
                           LCType | LOCALE_NOUSEROVERRIDE,
                           szBuf,
                           SIZE_128 ))
        {
            ComboBox_SetCurSel(hCtrl, ComboBox_InsertString(hCtrl, -1, szBuf));
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }

    //
    //  If it's the date separator, then we want slash, dot, and dash in
    //  the list in addition to the user and system settings (if different).
    //
    if (LCType == LOCALE_SDATE)
    {
        for (ctr = 0; ctr < NUM_DATE_SEPARATORS; ctr++)
        {
            if (ComboBox_FindStringExact( hCtrl,
                                          -1,
                                          pDateSeparators[ctr] ) == CB_ERR)
            {
                ComboBox_InsertString(hCtrl, -1, pDateSeparators[ctr]);
            }
        }
    }

    //
    //  If it's the AM symbol, then we want AM in the list in addition
    //  to the user and system settings (if different).
    //
    if (LCType == LOCALE_S1159)
    {
        for (ctr = 0; ctr < NUM_AM_SYMBOLS; ctr++)
        {
            if (ComboBox_FindStringExact( hCtrl,
                                          -1,
                                          pAMSymbols[ctr] ) == CB_ERR)
            {
                ComboBox_InsertString(hCtrl, -1, pAMSymbols[ctr]);
            }
        }
    }

    //
    //  If it's the PM symbol, then we want PM in the list in addition
    //  to the user and system settings (if different).
    //
    if (LCType == LOCALE_S2359)
    {
        for (ctr = 0; ctr < NUM_PM_SYMBOLS; ctr++)
        {
            if (ComboBox_FindStringExact( hCtrl,
                                          -1,
                                          pPMSymbols[ctr] ) == CB_ERR)
            {
                ComboBox_InsertString(hCtrl, -1, pPMSymbols[ctr]);
            }
        }
    }

#ifdef UNICODE
    //
    //  If it's the currency symbol, then we want the Euro symbol and dollar
    //  sign in the list in addition to the user and system settings (if
    //  different).
    //
    if (LCType == LOCALE_SCURRENCY)
    {
        for (ctr = 0; ctr < NUM_CURRENCY_SYMBOLS; ctr++)
        {
            if (ComboBox_FindStringExact( hCtrl,
                                          -1,
                                          pCurrencySymbols[ctr] ) == CB_ERR)
            {
                ComboBox_InsertString(hCtrl, -1, pCurrencySymbols[ctr]);
            }
        }
    }
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumProc
//
//  This call back function calls Set_List_Values assuming that whatever
//  code called the NLS enumeration function (or dummied enumeration
//  function) has properly set up Set_List_Values for the list box
//  population.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK EnumProc(
    LPTSTR lpValueString)
{
    return (Set_List_Values(0, 0, lpValueString));
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumProcEx
//
//  This call back function calls Set_List_Values assuming that whatever
//  code called the enumeration function has properly set up
//  Set_List_Values for the list box population.
//  Also, this function fixes the string passed in to contain the correct
//  decimal separator and negative sign, if appropriate.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK EnumProcEx(
    LPTSTR lpValueString,
    LPTSTR lpDecimalString,
    LPTSTR lpNegativeString,
    LPTSTR lpSymbolString)
{
    TCHAR szString[SIZE_128];
    LPTSTR pStr, pValStr, pTemp;


    //
    //  Simplify things if we have a NULL string.
    //
    if (lpDecimalString && (*lpDecimalString == CHAR_NULL))
    {
        lpDecimalString = NULL;
    }
    if (lpNegativeString && (*lpNegativeString == CHAR_NULL))
    {
        lpNegativeString = NULL;
    }
    if (lpSymbolString && (*lpSymbolString == CHAR_NULL))
    {
        lpSymbolString = NULL;
    }

    //
    //  See if we need to do any substitutions.
    //
    if (lpDecimalString || lpNegativeString || lpSymbolString)
    {
        pValStr = lpValueString;
        pStr = szString;

        while (*pValStr)
        {
            if (lpDecimalString && (*pValStr == CHAR_DECIMAL))
            {
                //
                //  Substitute the current user decimal separator.
                //
                pTemp = lpDecimalString;
                while (*pTemp)
                {
                    *pStr = *pTemp;
                    pStr++;
                    pTemp++;
                }
            }
            else if (lpNegativeString && (*pValStr == CHAR_HYPHEN))
            {
                //
                //  Substitute the current user negative sign.
                //
                pTemp = lpNegativeString;
                while (*pTemp)
                {
                    *pStr = *pTemp;
                    pStr++;
                    pTemp++;
                }
            }
            else if (lpSymbolString && (*pValStr == CHAR_INTL_CURRENCY))
            {
                //
                //  Substitute the current user currency symbol.
                //
                pTemp = lpSymbolString;
                while (*pTemp)
                {
                    *pStr = *pTemp;
                    pStr++;
                    pTemp++;
                }
            }
            else
            {
                //
                //  Simply copy the character.
                //
                *pStr = *pValStr;
                pStr++;
            }
            pValStr++;
        }
        *pStr = CHAR_NULL;

        return (Set_List_Values(0, 0, szString));
    }
    else
    {
        return (Set_List_Values(0, 0, lpValueString));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumLeadingZeros
//
////////////////////////////////////////////////////////////////////////////

BOOL EnumLeadingZeros(
    LEADINGZEROS_ENUMPROC lpLeadingZerosEnumProc,
    LCID LCId,
    DWORD dwFlags)
{
    TCHAR szBuf[SIZE_128];
    TCHAR szDecimal[SIZE_128];

    //
    //  If there is no enum proc, return false to indicate a failure.
    //
    if (!lpLeadingZerosEnumProc)
    {
        return (FALSE);
    }

    //
    //  Get the Decimal Separator for the current user locale so that
    //  it may be displayed correctly.
    //
    if (!GetLocaleInfo(UserLocaleID, LOCALE_SDECIMAL, szDecimal, SIZE_128) ||
        ((szDecimal[0] == CHAR_DECIMAL) && (szDecimal[1] == CHAR_NULL)))
    {
        szDecimal[0] = CHAR_NULL;
    }

    //
    //  Call enum proc with the NO string.  Check to make sure the
    //  enum proc requests continuation.
    //
    LoadString(hInstance, IDS_NO_LZERO, szBuf, SIZE_128);
    if (!lpLeadingZerosEnumProc(szBuf, szDecimal, NULL, NULL))
    {
        return (TRUE);
    }

    //
    //  Call enum proc with the YES string.
    //
    LoadString(hInstance, IDS_LZERO, szBuf, SIZE_128);
    lpLeadingZerosEnumProc(szBuf, szDecimal, NULL, NULL);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumNegNumFmt
//
////////////////////////////////////////////////////////////////////////////

BOOL EnumNegNumFmt(
    NEGNUMFMT_ENUMPROC lpNegNumFmtEnumProc,
    LCID LCId,
    DWORD dwFlags)
{
    TCHAR szDecimal[SIZE_128];
    TCHAR szNeg[SIZE_128];
    int ctr;

    //
    //  If there is no enum proc, return false to indicate a failure.
    //
    if (!lpNegNumFmtEnumProc)
    {
        return (FALSE);
    }

    //
    //  Get the Decimal Separator for the current user locale so that
    //  it may be displayed correctly.
    //
    if (!GetLocaleInfo(UserLocaleID, LOCALE_SDECIMAL, szDecimal, SIZE_128) ||
        ((szDecimal[0] == CHAR_DECIMAL) && (szDecimal[1] == CHAR_NULL)))
    {
        szDecimal[0] = CHAR_NULL;
    }

    //
    //  Get the Negative Sign for the current user locale so that
    //  it may be displayed correctly.
    //
    if (!GetLocaleInfo(UserLocaleID, LOCALE_SNEGATIVESIGN, szNeg, SIZE_128) ||
        ((szNeg[0] == CHAR_HYPHEN) && (szNeg[1] == CHAR_NULL)))
    {
        szNeg[0] = CHAR_NULL;
    }

    //
    //  Call enum proc with each format string.  Check to make sure
    //  the enum proc requests continuation.
    //
    for (ctr = 0; ctr < NUM_NEG_NUMBER_FORMATS; ctr++)
    {
        if (!lpNegNumFmtEnumProc( pNegNumberFormats[ctr],
                                  szDecimal,
                                  szNeg,
                                  NULL ))
        {
            return (TRUE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumMeasureSystem
//
////////////////////////////////////////////////////////////////////////////

BOOL EnumMeasureSystem(
    MEASURESYSTEM_ENUMPROC lpMeasureSystemEnumProc,
    LCID LCId,
    DWORD dwFlags)
{
    TCHAR szBuf[SIZE_128];

    //
    //  If there is no enum proc, return false to indicate a failure.
    //
    if (!lpMeasureSystemEnumProc)
    {
        return (FALSE);
    }

    //
    //  Call enum proc with the metric string.  Check to make sure the
    //  enum proc requests continuation.
    //
    LoadString(hInstance, IDS_METRIC, szBuf, SIZE_128);
    if (!lpMeasureSystemEnumProc(szBuf))
    {
        return (TRUE);
    }

    //
    //  Call enum proc with the U.S. string.
    //
    LoadString(hInstance, IDS_US, szBuf, SIZE_128);
    lpMeasureSystemEnumProc(szBuf);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumPosCurrency
//
////////////////////////////////////////////////////////////////////////////

BOOL EnumPosCurrency(
    POSCURRENCY_ENUMPROC lpPosCurrencyEnumProc,
    LCID LCId,
    DWORD dwFlags)
{
    TCHAR szDecimal[SIZE_128];
    TCHAR szSymbol[SIZE_128];
    int ctr;

    //
    //  If there is no enum proc, return false to indicate a failure.
    //
    if (!lpPosCurrencyEnumProc)
    {
        return (FALSE);
    }

    //
    //  Get the Decimal Separator for the current user locale so that
    //  it may be displayed correctly.
    //
    if (!GetLocaleInfo(UserLocaleID, LOCALE_SMONDECIMALSEP, szDecimal, SIZE_128) ||
        ((szDecimal[0] == CHAR_DECIMAL) && (szDecimal[1] == CHAR_NULL)))
    {
        szDecimal[0] = CHAR_NULL;
    }

    //
    //  Get the Currency Symbol for the current user locale so that
    //  it may be displayed correctly.
    //
    if (!GetLocaleInfo(UserLocaleID, LOCALE_SCURRENCY, szSymbol, SIZE_128) ||
        ((szSymbol[0] == CHAR_INTL_CURRENCY) && (szSymbol[1] == CHAR_NULL)))
    {
        szSymbol[0] = CHAR_NULL;
    }

    //
    //  Call enum proc with each format string.  Check to make sure the
    //  enum proc requests continuation.
    //
    for (ctr = 0; ctr < NUM_POS_CURRENCY_FORMATS; ctr++)
    {
        if (!lpPosCurrencyEnumProc( pPosCurrencyFormats[ctr],
                                    szDecimal,
                                    NULL,
                                    szSymbol ))
        {
            return (TRUE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumNegCurrency
//
////////////////////////////////////////////////////////////////////////////

BOOL EnumNegCurrency(
    NEGCURRENCY_ENUMPROC lpNegCurrencyEnumProc,
    LCID LCId,
    DWORD dwFlags)
{
    TCHAR szDecimal[SIZE_128];
    TCHAR szNeg[SIZE_128];
    TCHAR szSymbol[SIZE_128];
    int ctr;

    //
    //  If there is no enum proc, return false to indicate a failure.
    //
    if (!lpNegCurrencyEnumProc)
    {
        return (FALSE);
    }

    //
    //  Get the Decimal Separator for the current user locale so that
    //  it may be displayed correctly.
    //
    if (!GetLocaleInfo(UserLocaleID, LOCALE_SMONDECIMALSEP, szDecimal, SIZE_128) ||
        ((szDecimal[0] == CHAR_DECIMAL) && (szDecimal[1] == CHAR_NULL)))
    {
        szDecimal[0] = CHAR_NULL;
    }

    //
    //  Get the Negative Sign for the current user locale so that
    //  it may be displayed correctly.
    //
    if (!GetLocaleInfo(UserLocaleID, LOCALE_SNEGATIVESIGN, szNeg, SIZE_128) ||
        ((szNeg[0] == CHAR_HYPHEN) && (szNeg[1] == CHAR_NULL)))
    {
        szNeg[0] = CHAR_NULL;
    }

    //
    //  Get the Currency Symbol for the current user locale so that
    //  it may be displayed correctly.
    //
    if (!GetLocaleInfo(UserLocaleID, LOCALE_SCURRENCY, szSymbol, SIZE_128) ||
        ((szSymbol[0] == CHAR_INTL_CURRENCY) && (szSymbol[1] == CHAR_NULL)))
    {
        szSymbol[0] = CHAR_NULL;
    }

    //
    //  Call enum proc with each format string.  Check to make sure the
    //  enum proc requests continuation.
    //
    for (ctr = 0; ctr < NUM_NEG_CURRENCY_FORMATS; ctr++)
    {
        if (!lpNegCurrencyEnumProc( pNegCurrencyFormats[ctr],
                                    szDecimal,
                                    szNeg,
                                    szSymbol ))
        {
            return (TRUE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckEmptyString
//
//  If lpStr is empty, then it fills it with a null ("") string.
//  If lpStr is filled only by space, fills with a blank (" ") string.
//
////////////////////////////////////////////////////////////////////////////

void CheckEmptyString(
    LPTSTR lpStr)
{
    LPTSTR lpString;
    WORD wStrCType[64];

    if (!(*lpStr))
    {
        //
        //  Put "" string in buffer.
        //
        lstrcpy(lpStr, TEXT("\"\""));
    }
    else
    {
        for (lpString = lpStr; *lpString; lpString = CharNext(lpString))
        {
            GetStringTypeEx( LOCALE_USER_DEFAULT,
                             CT_CTYPE1,
                             lpString,
                             1,
                             wStrCType);

            if (wStrCType[0] != CHAR_SPACE)
            {
                return;
            }
        }

        //
        //  Put " " string in buffer.
        //
        lstrcpy(lpStr, TEXT("\" \""));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SetDlgItemRTL
//
////////////////////////////////////////////////////////////////////////////

void SetDlgItemRTL(
    HWND hDlg,
    UINT uItem)
{
    HWND hItem = GetDlgItem(hDlg, uItem);
    DWORD dwExStyle = GetWindowLong(hItem, GWL_EXSTYLE);

    SetWindowLong(hItem, GWL_EXSTYLE, dwExStyle | WS_EX_RTLREADING);
}


////////////////////////////////////////////////////////////////////////////
//
//  ShowMsg
//
////////////////////////////////////////////////////////////////////////////

int ShowMsg(
    HWND hDlg,
    UINT iMsg,
    UINT iTitle,
    UINT iType,
    LPTSTR pString)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szMsg[MAX_PATH*2];
    TCHAR szErrMsg[MAX_PATH*2];
    LPTSTR pTitle = NULL;

    if (iTitle)
    {
        if (LoadString(hInstance, iTitle, szTitle, ARRAYSIZE(szTitle)))
        {
            pTitle = szTitle;
        }
    }

    if (pString)
    {
        if (LoadString(hInstance, iMsg, szMsg, ARRAYSIZE(szMsg)))
        {
            wsprintf(szErrMsg, szMsg, pString);
            return (MessageBox(hDlg, szErrMsg, pTitle, iType));
        }
    }
    else
    {
        if (LoadString(hInstance, iMsg, szErrMsg, ARRAYSIZE(szErrMsg)))
        {
            return (MessageBox(hDlg, szErrMsg, pTitle, iType));
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_EnumLocales
//
////////////////////////////////////////////////////////////////////////////

void Intl_EnumLocales(
    HWND hDlg,
    HWND hLocale,
    BOOL EnumSystemLocales)
{
    LPLANGUAGEGROUP pLG;
    DWORD Locale, dwIndex;
    BOOL fSpanish = FALSE;
    UINT ctr;
    TCHAR szBuf[SIZE_300];
    DWORD dwLocaleACP;
    INT iRet = TRUE;

    //
    //  Go through the language groups to see which ones are installed.
    //  Display only the locales for the groups that are either already
    //  installed or the groups the user wants to be installed.
    //
    pLG = pLanguageGroups;
    while (pLG)
    {
        //
        //  If the language group is originally installed and not marked for
        //  removal OR is marked to be installed, then add the locales for
        //  this language group to the System and User combo boxes.
        //
        if (pLG->wStatus & ML_INSTALL)
        {
            for (ctr = 0; ctr < pLG->NumLocales; ctr++)
            {
                //
                //  Save the locale id.
                //
                Locale = (pLG->pLocaleList)[ctr];

                //
                //  See if we need to special case Spanish.
                //
                if ((LANGIDFROMLCID(Locale) == LANG_SPANISH_TRADITIONAL) ||
                    (LANGIDFROMLCID(Locale) == LANG_SPANISH_INTL))
                {
                    //
                    //  If we've already displayed Spanish (Spain), then
                    //  don't display it again.
                    //
                    if (!fSpanish)
                    {
                        //
                        //  Add the Spanish locale to the list box.
                        //
                        if (LoadString(hInstance, IDS_SPANISH_NAME, szBuf, SIZE_300))
                        {
                            dwIndex = ComboBox_AddString(hLocale, szBuf);
                            ComboBox_SetItemData( hLocale,
                                                  dwIndex,
                                                  LCID_SPANISH_INTL );

                            fSpanish = TRUE;
                        }
                    }
                }
                else
                {
                    //
                    //  Don't enum system locales that don't have an ACP.
                    //
                    if (EnumSystemLocales)
                    {
                        iRet = GetLocaleInfo( Locale,
                                              LOCALE_IDEFAULTANSICODEPAGE |
                                                LOCALE_NOUSEROVERRIDE |
                                                LOCALE_RETURN_NUMBER,
                                              (PTSTR) &dwLocaleACP,
                                              sizeof(dwLocaleACP) / sizeof(TCHAR) );
                        if (iRet)
                        {
                            iRet = dwLocaleACP;
                        }
                    }

                    if (iRet)
                    {
                        //
                        //  Get the name of the locale.
                        //
                        GetLocaleInfo(Locale, LOCALE_SLANGUAGE, szBuf, SIZE_300);

                        //
                        //  Add the new locale to the list box.
                        //
                        dwIndex = ComboBox_AddString(hLocale, szBuf);
                        ComboBox_SetItemData(hLocale, dwIndex, Locale);
                    }
                }
            }
        }
        pLG = pLG->pNext;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_EnumInstalledCPProc
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK Intl_EnumInstalledCPProc(
    LPTSTR pString)
{
    UINT CodePage;
    LPCODEPAGE pCP;

    //
    //  Convert the code page string to an integer.
    //
    CodePage = Intl_StrToLong(pString);

    //
    //  Find the code page in the linked list and mark it as
    //  originally installed.
    //
    pCP = pCodePages;
    while (pCP)
    {
        if (pCP->CodePage == CodePage)
        {
            pCP->wStatus |= ML_ORIG_INSTALLED;
            break;
        }

        pCP = pCP->pNext;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_InstallKeyboardLayout
//
//  Install the Keyboard Layout requested.  If the Layout parameter is 0,
//  the function will proceed with the installation of the default layout
//  for the Locale specified.  No need to validate the Layout because it's
//  done by the Text Services call.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_InstallKeyboardLayout(
    HWND  hDlg,
    LCID  Locale,
    DWORD Layout,
    BOOL  bDefaultLayout,
    BOOL  bDefaultUser,
    BOOL  bSystemLocale)
{
    TCHAR szData[MAX_PATH];
    DWORD dwLayout = Layout;
    DWORD dwLocale = (DWORD)Locale;
    TCHAR szLayout[50];
    HKL hklValue = (HKL)NULL;
    BOOL bOverrideDefaultLayout = FALSE;

    //
    //  Check if input.dll is loaded.
    //
    if (hInputDLL && pfnInstallInputLayout)
    {
        //
        //  See if we need to look for the default layout.
        //
        if (!Layout)
        {
            //
            //  Look in the INF file for the default layout.
            //
            if (!Intl_GetDefaultLayoutFromInf(&dwLocale, &dwLayout))
            {
                //
                //  Try just the language id.
                //
                if (HIWORD(Locale) != 0)
                {
                    dwLocale = LANGIDFROMLCID(Locale);
                    if (!Intl_GetDefaultLayoutFromInf(&dwLocale, &dwLayout))
                    {
                        if (g_bLog)
                        {
                            wsprintf(szLayout, TEXT("%08x:%08x"), dwLocale, dwLayout);
                            Intl_LogSimpleMessage(IDS_LOG_LOCALE_KBD_FAIL, szLayout);
                        }
                        return (FALSE);
                    }
                }
                else
                {
                    if (g_bLog)
                    {
                        wsprintf(szLayout,TEXT("%08x:%08x"), dwLocale, dwLayout);
                        Intl_LogSimpleMessage(IDS_LOG_LOCALE_KBD_FAIL, szLayout);
                    }
                    return (FALSE);
                }
            }
        }

        //
        //  See if we need to provide the HKL.  This case only occurs when
        //  we need to set the Layout as the default.  Otherwise, the value
        //  can be NULL.
        //
        if (bDefaultLayout)
        {
            hklValue = Intl_GetHKL(dwLocale, dwLayout);
        }

        //
        //  Check if need to override the default layout.
        //
        if (g_bSetupCase && ((HIWORD(dwLayout) & 0xf000) == 0xe000))
        {
            bOverrideDefaultLayout = TRUE;
        }

        //
        //  Install the input Layout.
        //
        if (!(*pfnInstallInputLayout)( dwLocale,
                                       dwLayout,
                                       bOverrideDefaultLayout ? FALSE : bDefaultLayout,
                                       hklValue,
                                       bDefaultUser,
                                       g_bSetupCase ? TRUE : bSystemLocale ))
        {
            if (hDlg != NULL)
            {
                GetLocaleInfo(Locale, LOCALE_SLANGUAGE, szData, MAX_PATH);
                ShowMsg( hDlg,
                         IDS_KBD_LOAD_KBD_FAILED,
                         0,
                         MB_OK_OOPS,
                         szData );
            }
            else
            {
                if (g_bLog)
                {
                    wsprintf(szLayout, TEXT("%08x:%08x"), dwLocale, dwLayout);
                    Intl_LogSimpleMessage(IDS_LOG_LOCALE_KBD_FAIL, szLayout);
                }
            }
            return (FALSE);
        }

        //
        //  If the language has a default layout that has a different locale
        //  than the language (e.g. Thai), we want the default locale to be
        //  English (so that logon can occur with a US keyboard), but the
        //  first Thai keyboard layout should be installed when the Thai
        //  locale is chosen.  This is why we have two locales and layouts
        //  passed back to the caller.
        //
        if (PRIMARYLANGID(LANGIDFROMLCID(dwLocale)) !=
            PRIMARYLANGID(LANGIDFROMLCID(Locale)))
        {
            dwLocale = Locale;
            dwLayout = 0;
            if (!Intl_GetSecondValidLayoutFromInf(&dwLocale, &dwLayout))
            {
                //
                //  Try just the language id.
                //
                if (HIWORD(Locale) != 0)
                {
                    dwLocale = LANGIDFROMLCID(Locale);
                    if (!Intl_GetSecondValidLayoutFromInf(&dwLocale, &dwLayout))
                    {
                        if (g_bLog)
                        {
                            wsprintf(szLayout, TEXT("%08x:%08x"), dwLocale, dwLayout);
                            Intl_LogSimpleMessage(IDS_LOG_LOCALE_KBD_FAIL, szLayout);
                        }
                        return (FALSE);
                    }
                }
                else
                {
                    if (g_bLog)
                    {
                        wsprintf(szLayout,TEXT("%08x:%08x"), dwLocale, dwLayout);
                        Intl_LogSimpleMessage(IDS_LOG_LOCALE_KBD_FAIL, szLayout);
                    }
                    return (FALSE);
                }
            }
        }

        //
        //  See if we need to provide the HKL.  This case only occurs when
        //  we need to set the Layout as the default.  Otherwise, the value
        //  can be NULL.
        //
        if (bDefaultLayout)
        {
            hklValue = Intl_GetHKL(dwLocale, dwLayout);
        }

        //
        //  Install the input Layout.
        //
        if (!(*pfnInstallInputLayout)( dwLocale,
                                       dwLayout,
                                       FALSE,
                                       hklValue,
                                       bDefaultUser,
                                       g_bSetupCase ? TRUE : bSystemLocale))
        {
            if (hDlg != NULL)
            {
                GetLocaleInfo(Locale, LOCALE_SLANGUAGE, szData, MAX_PATH);
                ShowMsg( hDlg,
                         IDS_KBD_LOAD_KBD_FAILED,
                         0,
                         MB_OK_OOPS,
                         szData );
            }
            else
            {
                if (g_bLog)
                {
                    wsprintf(szLayout, TEXT("%08x:%08x"), dwLocale, dwLayout);
                    Intl_LogSimpleMessage(IDS_LOG_LOCALE_KBD_FAIL, szLayout);
                }
            }
            return (FALSE);
        }
    }
    else
    {
        if (g_bLog)
        {
            wsprintf(szLayout, TEXT("%08x:%08x"), dwLocale, dwLayout);
            Intl_LogSimpleMessage(IDS_LOG_LAYOUT_INSTALLED, szLayout);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_InstallKeyboardLayoutList
//
//  Install all keyboard requested. Pass through the layout list and ask the
//  Text Services to process with the installation.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_InstallKeyboardLayoutList(
    PINFCONTEXT pContext,
    DWORD dwStartField,
    BOOL bDefaultUserCase)
{
    DWORD dwNumFields, dwNumList, dwCtr;
    DWORD Locale;
    DWORD Layout;
    BOOL bDefaultLayout = FALSE;
    TCHAR szBuffer[MAX_PATH];
    LPTSTR pPos;

    //
    //  Get the number of items in the list.
    //
    dwNumFields = SetupGetFieldCount(pContext);
    if (dwNumFields < dwStartField)
    {
        return (FALSE);
    }
    dwNumList = dwNumFields - dwStartField + 1;

    //
    //  Install all Keyboard layouts from the list.
    //
    for (dwCtr = dwStartField; dwCtr <= dwNumFields; dwCtr++)
    {
        if (SetupGetStringField( pContext,
                                 dwCtr,
                                 szBuffer,
                                 MAX_PATH,
                                 NULL ))
        {
            //
            //  Find the colon in order to save the input locale
            //  and layout values separately.
            //
            pPos = szBuffer;
            while (*pPos)
            {
                if ((*pPos == CHAR_COLON) && (pPos != szBuffer))
                {
                    *pPos = 0;
                    pPos++;

                    //
                    //  Check if related to the invariant locale.
                    //
                    Locale = TransNum(szBuffer);
                    Layout = TransNum(pPos);
                    if (Locale != LOCALE_INVARIANT)
                    {
                        //
                        //  Only the first one in list would be installed as
                        //  the default in the Preload section.
                        //
                        if (dwCtr == dwStartField)
                        {
                            bDefaultLayout = TRUE;
                        }
                        else
                        {
                            bDefaultLayout = FALSE;
                        }

                        //
                        //  Install the keyboard layout requested
                        //
                        if (Intl_InstallKeyboardLayout( NULL,
                                                        Locale,
                                                        Layout,
                                                        bDefaultLayout,
                                                        bDefaultUserCase,
                                                        FALSE ))
                        {
                            //
                            //  Log Layout installation info.
                            //
                            if (g_bLog)
                            {
                                Intl_LogSimpleMessage(IDS_LOG_LAYOUT, szBuffer);
                            }
                        }
                    }
                    else
                    {
                        //
                        //  Log invariant locale blocked.
                        //
                        if (g_bLog)
                        {
                            Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
                        }
                    }
                    break;
                }
                pPos++;
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_InstallAllKeyboardLayout
//
//  Install all keyboard layouts associated with a Language groups.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_InstallAllKeyboardLayout(
    LANGID Language)
{
    BOOL bRet = TRUE;
    HINF hIntlInf;
    LCID Locale = MAKELCID(Language, SORT_DEFAULT);
    TCHAR szLCID[25];
    INFCONTEXT Context;

    //
    //  Open the INF file
    //
    if (Intl_OpenIntlInfFile(&hIntlInf))
    {
        //
        //  Get the locale.
        //
        wsprintf(szLCID, TEXT("%08x"), Locale);

        //
        //  Look for the keyboard section.
        //
        if (SetupFindFirstLine( hIntlInf,
                                TEXT("Locales"),
                                szLCID,
                                &Context ))
        {
            bRet = Intl_InstallKeyboardLayoutList(&Context, 5, FALSE);
        }

        Intl_CloseInfFile(&hIntlInf);
    }

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_UninstallAllKeyboardLayout
//
//  Remove all keyboard layouts associated with a Language groups.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_UninstallAllKeyboardLayout(
    UINT uiLangGroup,
    BOOL DefaultUserCase)
{
    LPLANGUAGEGROUP pLG = pLanguageGroups;
    LANGID lidCurrent, lidPrev = 0;
    LCID *pLocale;
    BOOL bRet = TRUE;

    //
    //  Bail out if we can't get this API from input.dll.
    //

    if (pfnUninstallInputLayout)
    {
        //
        //  Walk through all language groups.
        //
        while (pLG)
        {
            if (pLG->LanguageGroup == uiLangGroup)
            {
                TCHAR szLang[MAX_PATH];

                pLocale = pLG->pLocaleList;

                //
                //  Walk through the locale list, remove relevant keyboard
                //  layouts by the locale's primary language.
                //
                while (*pLocale)
                {
                    lidCurrent = PRIMARYLANGID(*pLocale);

                    //
                    //  Don't uninstall any US keyboard layouts.
                    //
    	            if (lidCurrent == 0x09)
    	            {
                        pLocale++;
    	                continue;
    	            }    	

                    //
                    //  The locale list is sorted, so we can avoid redundant
                    //  UninstallInputLayout calls.
                    //
                    if (lidCurrent != lidPrev)
                    {
                        //
                        //  Uninstall the input layouts associated with
                        //  this current locale in the list.
                        //
                        BOOL bSuccess =
                            (*pfnUninstallInputLayout)( (LCID) lidCurrent,
                                                        0L,
                                                        DefaultUserCase );
                        if (g_bLog)
                        {
                            wsprintf(szLang, TEXT("%04x"), lidCurrent);
                            Intl_LogSimpleMessage( bSuccess
                                                     ? IDS_LOG_LOCALE_LG_REM
                                                     : IDS_LOG_LOCALE_LG_FAIL,
                                                   szLang );
                        }

                        if (!bSuccess && bRet)
                        {
                            bRet = bSuccess;
                        }

                        lidPrev = lidCurrent;
                    }
                    pLocale++;
                }
                break;
            }

            pLG = pLG->pNext;
        }
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_GetHKL
//
////////////////////////////////////////////////////////////////////////////

HKL Intl_GetHKL(
    DWORD dwLocale,
    DWORD dwLayout)
{
    TCHAR szData[MAX_PATH];
    INFCONTEXT Context;
    HINF hIntlInf;
    TCHAR szLayout[25];

    //
    //  Get the HKL based on the input locale value and the layout value.
    //
    if (dwLayout == 0)
    {
        //
        //  See if it's the default layout for the input locale or an IME.
        //
        if (HIWORD(dwLocale) == 0)
        {
            return ((HKL)MAKELPARAM(dwLocale, dwLocale));
        }
        else if ((HIWORD(dwLocale) & 0xf000) == 0xe000)
        {
            return ((HKL)IntToPtr(dwLocale));
        }
    }
    else
    {
        //
        //  Open the INF file.
        //
        if (Intl_OpenIntlInfFile(&hIntlInf))
        {
            //
            //  Create the Layout string.
            //
            wsprintf(szLayout, TEXT("%08x"), dwLayout);

            //
            //  Use the layout to make the hkl.
            //
            if (HIWORD(dwLayout) != 0)
            {
                //
                //  We have a special id.  Need to find out what the layout id
                //  should be.
                //
                if ((SetupFindFirstLine(hIntlInf, szKbdLayoutIds, szLayout, &Context)) &&
                    (SetupGetStringField(&Context, 1, szData, MAX_PATH, NULL)))
                {
                    dwLayout = (DWORD)(LOWORD(TransNum(szData)) | 0xf000);
                }
            }

            //
            //  Close the handle
            //
            Intl_CloseInfFile(&hIntlInf);

            //
            //  Return the hkl:
            //      loword = input locale id
            //      hiword = layout id
            //
            return ((HKL)MAKELPARAM(dwLocale, dwLayout));
        }
    }

    //
    //  Return failure.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_GetDefaultLayoutFromInf
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_GetDefaultLayoutFromInf(
    LPDWORD pdwLocale,
    LPDWORD pdwLayout)
{
    BOOL bRet = TRUE;
    HINF hIntlInf;

    if (Intl_OpenIntlInfFile(&hIntlInf))
    {
        bRet = Intl_ReadDefaultLayoutFromInf(pdwLocale, pdwLayout, hIntlInf);
        Intl_CloseInfFile(&hIntlInf);
    }

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_GetSecondValidLayoutFromInf
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_GetSecondValidLayoutFromInf(
    LPDWORD pdwLocale,
    LPDWORD pdwLayout)
{
    BOOL bRet = TRUE;
    HINF hIntlInf;

    if (Intl_OpenIntlInfFile(&hIntlInf))
    {
        bRet = Intl_ReadSecondValidLayoutFromInf(pdwLocale, pdwLayout, hIntlInf);
        Intl_CloseInfFile(&hIntlInf);
    }

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_InitInf
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_InitInf(
    HWND hDlg,
    HINF *phIntlInf,
    LPTSTR pszInf,
    HSPFILEQ *pFileQueue,
    PVOID *pQueueContext)
{
    BOOL bSpecialCase = TRUE;

    //
    //  Open the Inf file.
    //
    *phIntlInf = SetupOpenInfFile(pszInf, NULL, INF_STYLE_WIN4, NULL);
    if (*phIntlInf == INVALID_HANDLE_VALUE)
    {
        if (g_bLog)
        {
            Intl_LogFormatMessage(IDS_LOG_INTL_ERROR);
        }

        return (FALSE);
    }

    if (!SetupOpenAppendInfFile(NULL, *phIntlInf, NULL))
    {
        if (g_bLog)
        {
            Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
        }

        SetupCloseInfFile(*phIntlInf);
        return (FALSE);
    }

    //
    //  Create a setup file queue and initialize default setup
    //  copy queue callback context.
    //
    *pFileQueue = SetupOpenFileQueue();
    if ((!*pFileQueue) || (*pFileQueue == INVALID_HANDLE_VALUE))
    {
        if (g_bLog)
        {
            Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
        }

        SetupCloseInfFile(*phIntlInf);
        return (FALSE);
    }

    //
    //  Determine if we are dealing with a special case.
    //
    if ((g_bUnttendMode || g_bSetupCase) && !g_bProgressBarDisplay)
    {
        bSpecialCase = FALSE;
    }

    //
    //  Don't display FileCopy progress operation during GUI mode setup or Unattend mode.
    //
    *pQueueContext = SetupInitDefaultQueueCallbackEx( GetParent(hDlg),
                                                      (bSpecialCase ? NULL : INVALID_HANDLE_VALUE),
                                                      0L,
                                                      0L,
                                                      NULL );
    if (!*pQueueContext)
    {
        if (g_bLog)
        {
            Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
        }

        SetupCloseFileQueue(*pFileQueue);
        SetupCloseInfFile(*phIntlInf);
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_OpenIntlInfFile
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_OpenIntlInfFile(
    HINF *phInf)
{
    HINF hIntlInf;

    //
    //  Open the intl.inf file.
    //
    hIntlInf = SetupOpenInfFile(szIntlInf, NULL, INF_STYLE_WIN4, NULL);
    if (hIntlInf == INVALID_HANDLE_VALUE)
    {
        return (FALSE);
    }

    if (!SetupOpenAppendInfFile(NULL, hIntlInf, NULL))
    {
        SetupCloseInfFile(hIntlInf);
        return (FALSE); 
    }

    *phInf = hIntlInf;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_CloseInf
//
////////////////////////////////////////////////////////////////////////////

void Intl_CloseInf(
    HINF hIntlInf,
    HSPFILEQ FileQueue,
    PVOID QueueContext)
{
    //
    //  Terminate the Queue.
    //
    SetupTermDefaultQueueCallback(QueueContext);

    //
    //  Close the file queue.
    //
    SetupCloseFileQueue(FileQueue);

    //
    //  Close the Inf file.
    //
    SetupCloseInfFile(hIntlInf);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_ReadDefaultLayoutFromInf
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_ReadDefaultLayoutFromInf(
    LPDWORD pdwLocale,
    LPDWORD pdwLayout,
    HINF hIntlInf)
{
    INFCONTEXT Context;
    TCHAR szPair[MAX_PATH * 2];
    LPTSTR pPos;
    TCHAR szLCID[25];

    //
    //  Get the locale.
    //
    wsprintf(szLCID, TEXT("%08x"), *pdwLocale);

    //
    //  Get the first (default) LANGID:HKL pair for the given locale.
    //    Example String: "0409:00000409"
    //
    szPair[0] = 0;
    if (SetupFindFirstLine( hIntlInf,
                            TEXT("Locales"),
                            szLCID,
                            &Context ))
    {
        SetupGetStringField(&Context, 5, szPair, MAX_PATH, NULL);
    }

    //
    //  Make sure we have a string.
    //
    if (szPair[0] == 0)
    {
        return (FALSE);
    }

    //
    //  Find the colon in the string and then set the position
    //  pointer to the next character.
    //
    pPos = szPair;
    while (*pPos)
    {
        if ((*pPos == CHAR_COLON) && (pPos != szPair))
        {
            *pPos = 0;
            pPos++;
            break;
        }
        pPos++;
    }

    //
    //  If there is a layout, then return the input locale and the layout.
    //
    if ((*pPos) &&
        (*pdwLocale = TransNum(szPair)) &&
        (*pdwLayout = TransNum(pPos)))
    {
        return (TRUE);
    }

    //
    //  Return failure.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_ReadSecondValidLayoutFromInf
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_ReadSecondValidLayoutFromInf(
    LPDWORD pdwLocale,
    LPDWORD pdwLayout,
    HINF hIntlInf)
{
    INFCONTEXT Context;
    int iField = 6;
    TCHAR szPair[MAX_PATH * 2];
    LPTSTR pPos;
    DWORD dwLoc, dwlay, savedLocale = *pdwLocale;
    TCHAR szLCID[25];

    //
    //  Get the locale.
    //
    wsprintf(szLCID, TEXT("%08x"), *pdwLocale);

    //
    //  Get the first (default) LANGID:HKL pair for the given locale.
    //    Example String: "0409:00000409"
    //
    szPair[0] = 0;
    if (SetupFindFirstLine(hIntlInf, TEXT("Locales"), szLCID, &Context))
    {
        while (SetupGetStringField(&Context, iField, szPair, MAX_PATH, NULL))
        {
            //
            //  Make sure we have a string.
            //
            if (szPair[0] == 0)
            {
                iField++;
                continue;
            }

            //
            //  Find the colon in the string and then set the position
            //  pointer to the next character.
            //
            pPos = szPair;
            while (*pPos)
            {
                if ((*pPos == CHAR_COLON) && (pPos != szPair))
                {
                    *pPos = 0;
                    pPos++;
                    break;
                }
                pPos++;
            }

            if (*pPos == 0)
            {
                iField++;
                continue;
            }

            //
            //  If there is a layout, then return the input locale and the
            //  layout.
            //
            if (((dwLoc = TransNum(szPair)) == 0) ||
                ((dwlay = TransNum(pPos)) == 0))
            {
                iField++;
                continue;
            }

            if (PRIMARYLANGID(LANGIDFROMLCID(dwLoc)) ==
                PRIMARYLANGID(LANGIDFROMLCID(savedLocale)))
            {
                *pdwLayout = dwlay;
                *pdwLocale = dwLoc;
                return (TRUE);
            }
            iField++;
        }
    }

    //
    //  Return failure.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_CloseInfFile
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_CloseInfFile(
    HINF *phInf)
{
    SetupCloseInfFile(*phInf);
    *phInf = INVALID_HANDLE_VALUE;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_IsValidLayout
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_IsValidLayout(
    DWORD dwLayout)
{
    HKEY hKey1, hKey2;
    TCHAR szLayout[MAX_PATH];

    //
    //  Get the layout id as a string.
    //
    wsprintf(szLayout, TEXT("%08x"), dwLayout);

    //
    //  Open the Keyboard Layouts key.
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, szLayoutPath, &hKey1) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Try to open the layout id key under the Keyboard Layouts key.
    //
    if (RegOpenKey(hKey1, szLayout, &hKey2) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey1);
        return (FALSE);
    }

    //
    //  Close the keys.
    //
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_RunRegApps
//
////////////////////////////////////////////////////////////////////////////

void Intl_RunRegApps(
    LPCTSTR pszRegKey)
{
    HKEY hkey;
    DWORD cbData, cbValue, dwType, ctr;
    TCHAR szValueName[32], szCmdLine[MAX_PATH];
    STARTUPINFO startup;
    PROCESS_INFORMATION pi;

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    pszRegKey,
                    &hkey ) == ERROR_SUCCESS)
    {
        startup.cb = sizeof(STARTUPINFO);
        startup.lpReserved = NULL;
        startup.lpDesktop = NULL;
        startup.lpTitle = NULL;
        startup.dwFlags = 0L;
        startup.cbReserved2 = 0;
        startup.lpReserved2 = NULL;
    //  startup.wShowWindow = wShowWindow;

        for (ctr = 0; ; ctr++)
        {
            LONG lEnum;

            cbValue = sizeof(szValueName) / sizeof(TCHAR);
            cbData = sizeof(szCmdLine);

            if ((lEnum = RegEnumValue( hkey,
                                       ctr,
                                       szValueName,
                                       &cbValue,
                                       NULL,
                                       &dwType,
                                       (LPBYTE)szCmdLine,
                                       &cbData )) == ERROR_MORE_DATA)
            {
                //
                //  ERROR_MORE_DATA means the value name or data was too
                //  large, so skip to the next item.
                //
                continue;
            }
            else if (lEnum != ERROR_SUCCESS)
            {
                //
                //  This could be ERROR_NO_MORE_ENTRIES, or some kind of
                //  failure.  We can't recover from any other registry
                //  problem anyway.
                //
                break;
            }

            //
            //  Found a value.
            //
            if (dwType == REG_SZ)
            {
                //
                //  Adjust for shift in value index.
                //
                ctr--;

                //
                //  Delete the value.
                //
                RegDeleteValue(hkey, szValueName);

                //
                //  Only run things marked with a "*" in clean boot.
                //
                if (CreateProcess( NULL,
                                   szCmdLine,
                                   NULL,
                                   NULL,
                                   FALSE,
                                   CREATE_NEW_PROCESS_GROUP,
                                   NULL,
                                   NULL,
                                   &startup,
                                   &pi ))
                {
                    WaitForSingleObjectEx(pi.hProcess, INFINITE, TRUE);

                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                }
            }
        }
        RegCloseKey(hkey);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_RebootTheSystem
//
//  This routine enables all privileges in the token, calls ExitWindowsEx
//  to reboot the system, and then resets all of the privileges to their
//  old state.
//
////////////////////////////////////////////////////////////////////////////

VOID Intl_RebootTheSystem()
{
    HANDLE Token = NULL;
    ULONG ReturnLength, Index;
    PTOKEN_PRIVILEGES NewState = NULL;
    PTOKEN_PRIVILEGES OldState = NULL;
    BOOL Result;

    Result = OpenProcessToken( GetCurrentProcess(),
                               TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               &Token );
    if (Result)
    {
        ReturnLength = 4096;
        NewState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        OldState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        Result = (BOOL)((NewState != NULL) && (OldState != NULL));
        if (Result)
        {
            Result = GetTokenInformation( Token,            // TokenHandle
                                          TokenPrivileges,  // TokenInformationClass
                                          NewState,         // TokenInformation
                                          ReturnLength,     // TokenInformationLength
                                          &ReturnLength );  // ReturnLength
            if (Result)
            {
                //
                //  Set the state settings so that all privileges are
                //  enabled...
                //
                if (NewState->PrivilegeCount > 0)
                {
                    for (Index = 0; Index < NewState->PrivilegeCount; Index++)
                    {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }

                Result = AdjustTokenPrivileges( Token,           // TokenHandle
                                                FALSE,           // DisableAllPrivileges
                                                NewState,        // NewState
                                                ReturnLength,    // BufferLength
                                                OldState,        // PreviousState
                                                &ReturnLength ); // ReturnLength
                if (Result)
                {
                    ExitWindowsEx(EWX_REBOOT, 0);


                    AdjustTokenPrivileges( Token,
                                           FALSE,
                                           OldState,
                                           0,
                                           NULL,
                                           NULL );
                }
            }
        }
    }

    if (NewState != NULL)
    {
        LocalFree(NewState);
    }
    if (OldState != NULL)
    {
        LocalFree(OldState);
    }
    if (Token != NULL)
    {
        CloseHandle(Token);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_InstallUserLocale
//
//  When the DefaultUserCase flag is FALSE, this function write information
//  related to the locale for the current user. Otherwise, this function
//  write information for the .DEFAULT user. In the Default user case, the
//  the information are stored in the registry and the NTSUSER.DAT.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_InstallUserLocale(
    LCID Locale,
    BOOL DefaultUserCase,
    BOOL bChangeLocaleInfo )
{
    HKEY hKey = NULL;
    HKEY hHive = NULL;
    BOOLEAN wasEnabled;
    TCHAR szLCID[25];
    DWORD dwRet;

    //
    //  Save the locale id as a string.
    //
    wsprintf(szLCID, TEXT("%08x"), Locale);

    //
    //  Make sure the locale is valid.
    //
    if (!IsValidLocale(Locale, LCID_INSTALLED))
    {
        if (g_bLog)
        {
            Intl_LogSimpleMessage(IDS_LOG_INVALID_LOCALE, szLCID);
        }

        return (FALSE);
    }

    //
    //  Log user locale info change.
    //
    if (g_bLog)
    {
        Intl_LogSimpleMessage(IDS_LOG_USER_LOCALE_CHG, szLCID);
    }

    //
    //  Open the right registry section.
    //
    if (!DefaultUserCase)
    {
        dwRet = RegOpenKeyEx( HKEY_CURRENT_USER,
                              c_szCPanelIntl,
                              0L,
                              KEY_READ | KEY_WRITE,
                              &hKey );
    }
    else
    {
        dwRet = RegOpenKeyEx( HKEY_USERS,
                              c_szCPanelIntl_DefUser,
                              0L,
                              KEY_READ | KEY_WRITE,
                              &hKey );

        if (dwRet == ERROR_SUCCESS)
        {
            //
            //  Load the default hive.
            //
            if ((hHive = Intl_LoadNtUserHive( TEXT("tempKey"),
                                              c_szCPanelIntl,
                                              &wasEnabled )) == NULL )
            {
                RegCloseKey(hKey);
                return (FALSE);
            }

            //
            //  Save the Locale value in NTUSER.DAT.
            //
            RegSetValueEx( hHive,
                           TEXT("Locale"),
                           0L,
                           REG_SZ,
                           (LPBYTE)szLCID,
                           (lstrlen(szLCID) + 1) * sizeof(TCHAR));

            //
            //  Clean up.
            //
            RegCloseKey(hHive);
            Intl_UnloadNtUserHive(TEXT("tempKey"), &wasEnabled);
        }
    }

    //
    //  Set the locale value in the user's control panel international
    //  section of the registry.
    //
    if ((dwRet != ERROR_SUCCESS) ||
        (RegSetValueEx( hKey,
                        TEXT("Locale"),
                        0L,
                        REG_SZ,
                        (LPBYTE)szLCID,
                        (lstrlen(szLCID) + 1) * sizeof(TCHAR) ) != ERROR_SUCCESS))
    {
        if (hKey != NULL)
        {
            RegCloseKey(hKey);
        }
        return (FALSE);
    }

    //
    //  When the locale changes, update ALL registry information when asked.
    //
    if (bChangeLocaleInfo)
    {
       Intl_SetLocaleInfo(Locale, LOCALE_SABBREVLANGNAME,    TEXT("sLanguage"),        DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SCOUNTRY,           TEXT("sCountry"),         DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_ICOUNTRY,           TEXT("iCountry"),         DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_S1159,              TEXT("s1159"),            DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_S2359,              TEXT("s2359"),            DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_STIMEFORMAT,        TEXT("sTimeFormat"),      DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_STIME,              TEXT("sTime"),            DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_ITIME,              TEXT("iTime"),            DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_ITLZERO,            TEXT("iTLZero"),          DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_ITIMEMARKPOSN,      TEXT("iTimePrefix"),      DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SSHORTDATE,         TEXT("sShortDate"),       DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_IDATE,              TEXT("iDate"),            DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SDATE,              TEXT("sDate"),            DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SLONGDATE,          TEXT("sLongDate"),        DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SCURRENCY,          TEXT("sCurrency"),        DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_ICURRENCY,          TEXT("iCurrency"),        DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_INEGCURR,           TEXT("iNegCurr"),         DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_ICURRDIGITS,        TEXT("iCurrDigits"),      DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SDECIMAL,           TEXT("sDecimal"),         DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SMONDECIMALSEP,     TEXT("sMonDecimalSep"),   DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_STHOUSAND,          TEXT("sThousand"),        DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SMONTHOUSANDSEP,    TEXT("sMonThousandSep"),  DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SLIST,              TEXT("sList"),            DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_IDIGITS,            TEXT("iDigits"),          DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_ILZERO,             TEXT("iLzero"),           DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_INEGNUMBER,         TEXT("iNegNumber"),       DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SNATIVEDIGITS,      TEXT("sNativeDigits"),    DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_IDIGITSUBSTITUTION, TEXT("NumShape"),         DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_IMEASURE,           TEXT("iMeasure"),         DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_ICALENDARTYPE,      TEXT("iCalendarType"),    DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_IFIRSTDAYOFWEEK,    TEXT("iFirstDayOfWeek"),  DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_IFIRSTWEEKOFYEAR,   TEXT("iFirstWeekOfYear"), DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SGROUPING,          TEXT("sGrouping"),        DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SMONGROUPING,       TEXT("sMonGrouping"),     DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SPOSITIVESIGN,      TEXT("sPositiveSign"),    DefaultUserCase);
       Intl_SetLocaleInfo(Locale, LOCALE_SNEGATIVESIGN,      TEXT("sNegativeSign"),    DefaultUserCase);
    }

    //
    //  Set the user's default locale in the system so that any new
    //  process will use the new locale.
    //
    if (!DefaultUserCase)
    {
        NtSetDefaultLocale(TRUE, Locale);
    }

    //
    //  Flush the International key.
    //
    if (hKey != NULL)
    {
        RegFlushKey(hKey);
        RegCloseKey(hKey);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_SetLocaleInfo
//
////////////////////////////////////////////////////////////////////////////

void Intl_SetLocaleInfo(
    LCID Locale,
    LCTYPE LCType,
    LPTSTR lpIniStr,
    BOOL bDefaultUserCase)
{
    TCHAR pBuf[SIZE_128];

    //
    //  Get the default information for the given locale.
    //
    if (GetLocaleInfo( Locale,
                       LCType | LOCALE_NOUSEROVERRIDE,
                       pBuf,
                       SIZE_128 ))
    {
        if (!bDefaultUserCase)
        {
            //
            //  Set the default information in the registry.
            //
            //  NOTE: We want to use SetLocaleInfo if possible so that the
            //        NLS cache is updated right away.  Otherwise, we'll
            //        simply use WriteProfileString.
            //
            if (!SetLocaleInfo(Locale, LCType, pBuf))
            {
                //
                //  If SetLocaleInfo failed, try WriteProfileString since
                //  some of the LCTypes are not supported in SetLocaleInfo.
                //
                WriteProfileString(szIntl, lpIniStr, pBuf);
            }
        }
        else
        {
            //
            //  Set the default information in the registry and NTUSER.DAT.
            //
            Intl_SetDefaultUserLocaleInfo(lpIniStr, pBuf);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_AddPage
//
////////////////////////////////////////////////////////////////////////////

void Intl_AddPage(
    LPPROPSHEETHEADER ppsh,
    UINT id,
    DLGPROC pfn,
    LPARAM lParam,
    UINT iMaxPages)
{
    if (ppsh->nPages < iMaxPages)
    {
        PROPSHEETPAGE psp;

        psp.dwSize = sizeof(psp);
        psp.dwFlags = PSP_DEFAULT;
        psp.hInstance = hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(id);
        psp.pfnDlgProc = pfn;
        psp.lParam = lParam;

        ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);
        if (ppsh->phpage[ppsh->nPages])
        {
            ppsh->nPages++;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_AddExternalPage
//
//  Adds a property sheet page from the given dll.
//
////////////////////////////////////////////////////////////////////////////

void Intl_AddExternalPage(
    LPPROPSHEETHEADER ppsh,
    UINT id,
    HINSTANCE hInst,
    LPSTR ProcName,
    UINT iMaxPages)
{
    DLGPROC pfn;

    if (ppsh->nPages < iMaxPages)
    {
        PROPSHEETPAGE psp;

        if (hInst)
        {
            pfn = (DLGPROC)GetProcAddress(hInst, ProcName);
            if (!pfn)
            {
                return;
            }

            psp.dwSize = sizeof(psp);
            psp.dwFlags = PSP_DEFAULT;
            psp.hInstance = hInst;
            psp.pszTemplate = MAKEINTRESOURCE(id);
            psp.pfnDlgProc = pfn;
            psp.lParam = 0;

            ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);
            if (ppsh->phpage[ppsh->nPages])
            {
                ppsh->nPages++;
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_SetDefaultUserLocaleInfo
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_SetDefaultUserLocaleInfo(
    LPCTSTR lpKeyName,
    LPCTSTR lpString)
{
    HKEY hKey = NULL;
    LONG rc = 0L;
    TCHAR szProfile[REGSTR_MAX_VALUE_LENGTH];
    BOOLEAN wasEnabled;

    //
    //  Open the .DEFAULT control panel international section.
    //
    if ((rc = RegOpenKeyEx( HKEY_USERS,
                            c_szCPanelIntl_DefUser,
                            0L,
                            KEY_READ | KEY_WRITE,
                            &hKey )) == ERROR_SUCCESS)
    {
        //
        //  Set the value
        //
        rc = RegSetValueEx( hKey,
                            lpKeyName,
                            0L,
                            REG_SZ,
                            (LPBYTE)lpString,
                            (lstrlen(lpString) + 1) * sizeof(TCHAR) );

        //
        //  Flush the International key.
        //
        RegFlushKey(hKey);
        RegCloseKey(hKey);
    }

    if (rc == ERROR_SUCCESS)
    {
        //
        //  Load the hive.
        //
        if ((hKey = Intl_LoadNtUserHive( TEXT("RegionalSettingsTempKey"),
                                         c_szCPanelIntl,
                                         &wasEnabled)) == NULL)
        {
            return (FALSE);
        }

        //
        //  Set the value.
        //
        rc = RegSetValueEx( hKey,
                            lpKeyName,
                            0L,
                            REG_SZ,
                            (LPBYTE)lpString,
                            (lstrlen(lpString) + 1) * sizeof(TCHAR) );

        //
        //  Clean up.
        //
        RegCloseKey(hKey);
        Intl_UnloadNtUserHive(TEXT("RegionalSettingsTempKey"), &wasEnabled);
    }
    else
    {
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_DeleteRegKeyValues
//
//  This deletes all values under a specific key.
//
////////////////////////////////////////////////////////////////////////////

void Intl_DeleteRegKeyValues(
    HKEY hKey)
{
    TCHAR szValueName[REGSTR_MAX_VALUE_LENGTH];
    DWORD cbValue = REGSTR_MAX_VALUE_LENGTH;

    //
    //  Sanity check.
    //
    if (hKey == NULL)
    {
        return;
    }

    //
    //  Enumerate values.
    //
    while (RegEnumValue( hKey,
                        0,
                        szValueName,
                        &cbValue,
                        NULL,
                        NULL,
                        NULL,
                        NULL ) ==  ERROR_SUCCESS)
    {
        //
        //  Delete the value.
        //
        RegDeleteValue(hKey, szValueName);
        cbValue = REGSTR_MAX_VALUE_LENGTH;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_DeleteRegTree
//
//  This deletes all subkeys under a specific key.
//
//  Note: The code makes no attempt to check or recover from partial
//  deletions.
//
//  A registry key that is opened by an application can be deleted
//  without error by another application.  This is by design.
//
////////////////////////////////////////////////////////////////////////////

DWORD Intl_DeleteRegTree(
    HKEY hStartKey,
    LPTSTR pKeyName)
{
    DWORD dwRtn, dwSubKeyLength;
    LPTSTR pSubKey = NULL;
    TCHAR szSubKey[REGSTR_MAX_VALUE_LENGTH];   // (256) this should be dynamic.
    HKEY hKey;

    //
    //  Do not allow NULL or empty key name.
    //
    if (pKeyName && lstrlen(pKeyName))
    {
        if ((dwRtn = RegOpenKeyEx( hStartKey,
                                   pKeyName,
                                   0,
                                   KEY_ENUMERATE_SUB_KEYS | DELETE,
                                   &hKey )) == ERROR_SUCCESS)
        {
            while (dwRtn == ERROR_SUCCESS)
            {
                dwSubKeyLength = REGSTR_MAX_VALUE_LENGTH;
                dwRtn = RegEnumKeyEx( hKey,
                                      0,       // always index zero
                                      szSubKey,
                                      &dwSubKeyLength,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL );

                if (dwRtn == ERROR_NO_MORE_ITEMS)
                {
                    dwRtn = RegDeleteKey(hStartKey, pKeyName);
                    break;
                }
                else if (dwRtn == ERROR_SUCCESS)
                {
                    dwRtn = Intl_DeleteRegTree(hKey, szSubKey);
                }
            }

            RegCloseKey(hKey);

            //
            //  Do not save return code because error has already occurred.
            //
        }
    }
    else
    {
        dwRtn = ERROR_BADKEY;
    }

    return (dwRtn);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_DeleteRegSubKeys
//
//  This deletes all subkeys under a specific key.
//
////////////////////////////////////////////////////////////////////////////

void Intl_DeleteRegSubKeys(
    HKEY hKey)
{
    TCHAR szKeyName[REGSTR_MAX_VALUE_LENGTH];
    DWORD cbKey = REGSTR_MAX_VALUE_LENGTH;

    //
    //  Sanity check.
    //
    if (hKey == NULL)
    {
        return;
    }

    //
    //  Enumerate values.
    //
    while (RegEnumKeyEx( hKey,
                         0,
                         szKeyName,
                         &cbKey,
                         NULL,
                         NULL,
                         NULL,
                         NULL ) == ERROR_SUCCESS)
    {
        //
        //  Delete the value.
        //
        Intl_DeleteRegTree(hKey, szKeyName);
        cbKey = REGSTR_MAX_VALUE_LENGTH;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_CopyRegKeyValues
//
//  This copies all values under the source key to the destination key.
//
////////////////////////////////////////////////////////////////////////////

DWORD Intl_CopyRegKeyValues(
    HKEY hSrc,
    HKEY hDest)
{
    DWORD cbValue, dwSubKeyIndex=0, dwType, cdwBuf;
    DWORD dwValues, cbMaxValueData, i;
    TCHAR szValue[REGSTR_MAX_VALUE_LENGTH];   // this should be dynamic.
    DWORD lRet = ERROR_SUCCESS;
    LPBYTE pBuf;

    if ((lRet = RegQueryInfoKey( hSrc,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwValues,
                                 NULL,
                                 &cbMaxValueData,
                                 NULL,
                                 NULL )) == ERROR_SUCCESS)
    {
        if (dwValues)
        {
            if ((pBuf = HeapAlloc( GetProcessHeap(),
                                   HEAP_ZERO_MEMORY,
                                   cbMaxValueData )))
            {
                for (i = 0; i < dwValues; i++)
                {
                    //
                    //  Get values to create.
                    //
                    cbValue = REGSTR_MAX_VALUE_LENGTH;
                    cdwBuf = cbMaxValueData;
                    lRet = RegEnumValue( hSrc,      // handle of key to query
                                         i,         // index of value to query
                                         szValue,   // buffer for value string
                                         &cbValue,  // address for size of buffer
                                         NULL,      // reserved
                                         &dwType,   // buffer address for type code
                                         pBuf,      // address of buffer for value data
                                         &cdwBuf ); // address for size of buffer

                    if (lRet == ERROR_SUCCESS)
                    {
                        if ((lRet = RegSetValueEx( hDest,
                                                   szValue,
                                                   0,
                                                   dwType,
                                                   (CONST BYTE *)pBuf,
                                                   cdwBuf )) != ERROR_SUCCESS)
                        {
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                HeapFree(GetProcessHeap(), 0, pBuf);
            }
        }
    }

    return (lRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_CreateRegTree
//
//  This copies all values and subkeys under the source key to the
//  destination key.
//
////////////////////////////////////////////////////////////////////////////

DWORD Intl_CreateRegTree(
    HKEY hSrc,
    HKEY hDest)
{
    DWORD cdwClass, dwSubKeyLength, dwDisposition, dwKeyIndex = 0;
    LPTSTR pSubKey = NULL;
    TCHAR szSubKey[REGSTR_MAX_VALUE_LENGTH];     // this should be dynamic.
    TCHAR szClass[REGSTR_MAX_VALUE_LENGTH];      // this should be dynamic.
    HKEY hNewKey, hKey;
    DWORD lRet;

    //
    //  Copy values
    //
    if ((lRet = Intl_CopyRegKeyValues( hSrc,
                                       hDest )) != ERROR_SUCCESS)
    {
        return (lRet);
    }

    //
    //  Copy the subkeys and the subkey values.
    //
    for (;;)
    {
        dwSubKeyLength = REGSTR_MAX_VALUE_LENGTH;
        cdwClass = REGSTR_MAX_VALUE_LENGTH;
        lRet = RegEnumKeyEx( hSrc,
                             dwKeyIndex,
                             szSubKey,
                             &dwSubKeyLength,
                             NULL,
                             szClass,
                             &cdwClass,
                             NULL );

        if (lRet == ERROR_NO_MORE_ITEMS)
        {
            lRet = ERROR_SUCCESS;
            break;
        }
        else if (lRet == ERROR_SUCCESS)
        {
            if ((lRet = RegCreateKeyEx( hDest,
                                        szSubKey,
                                        0,
                                        szClass,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hNewKey,
                                        &dwDisposition )) == ERROR_SUCCESS)
            {
                //
                //  Copy all subkeys.
                //
                if ((lRet = RegOpenKeyEx( hSrc,
                                          szSubKey,
                                          0,
                                          KEY_ALL_ACCESS,
                                          &hKey )) == ERROR_SUCCESS)
                {
                    //
                    //  Recursively copy the remainder of the tree.
                    //
                    lRet = Intl_CreateRegTree(hKey, hNewKey);

                    CloseHandle(hKey);
                    CloseHandle(hNewKey);
                    if (lRet != ERROR_SUCCESS)
                    {
                        break;
                    }
                }
                else
                {
                    CloseHandle(hNewKey);
                    break;
                }
            }
        }
        else
        {
            break;
        }

        ++dwKeyIndex;
    }

    return (lRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_LoadNtUserHive
//
//  The caller of this function needs to call Intl_UnloadNtUserHive() when
//  the function succeeds in order to properly release the handle on the
//  NTUSER.DAT file.
//
////////////////////////////////////////////////////////////////////////////

HKEY Intl_LoadNtUserHive(
    LPCTSTR lpRoot,
    LPCTSTR lpKeyName,
    BOOLEAN *lpWasEnabled)
{
    HKEY hKey = NULL;
    LONG rc = 0L;
    BOOL bRet = TRUE;
    TCHAR szProfile[REGSTR_MAX_VALUE_LENGTH] = {0};
    TCHAR szKeyName[REGSTR_MAX_VALUE_LENGTH] = {0};
    DWORD cchSize;

    //
    //  Get the file name for the Default User profile.
    //
    cchSize = MAX_PATH;
    if (!GetDefaultUserProfileDirectory(szProfile, &cchSize))
    {
        return (NULL);
    }
    lstrcat(szProfile, TEXT("\\NTUSER.DAT"));

    //
    //  Set the value in the Default User hive.
    //
    rc = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, lpWasEnabled);
    if (NT_SUCCESS(rc))
    {
        //
        //  Load the hive and restore the privilege to its previous state.
        //
        rc = RegLoadKey(HKEY_USERS, lpRoot, szProfile);
        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, *lpWasEnabled, FALSE, lpWasEnabled);

        //
        //  If the hive loaded properly, set the value.
        //
        if (rc == ERROR_SUCCESS)
        {
            //
            //  Get the temporary key name.
            //
            swprintf(szKeyName, TEXT("%s\\%s"), lpRoot, lpKeyName);
            if ((rc = RegOpenKeyEx( HKEY_USERS,
                                    szKeyName,
                                    0L,
                                    KEY_READ | KEY_WRITE,
                                    &hKey )) == ERROR_SUCCESS)
            {
                return (hKey);
            }
            else
            {
                Intl_UnloadNtUserHive(lpRoot, lpWasEnabled);
                return (NULL);
            }
        }
    }

    return (NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_UnloadNtUserHive
//
////////////////////////////////////////////////////////////////////////////

void Intl_UnloadNtUserHive(
    LPCTSTR lpRoot,
    BOOLEAN *lpWasEnabled)
{
    if (NT_SUCCESS(RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                       TRUE,
                                       FALSE,
                                       lpWasEnabled )))
    {
        RegUnLoadKey(HKEY_USERS, lpRoot);
        RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                            *lpWasEnabled,
                            FALSE,
                            lpWasEnabled );
    }
}



////////////////////////////////////////////////////////////////////////////
//
//  Intl_ChangeUILangForAllUsers
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_ChangeUILangForAllUsers(
    LANGID UILanguageId)
{
    HKEY hKey;
    HKEY hHive;
    TCHAR szData[MAX_PATH];
    LONG rc = 0L;
    BOOLEAN wasEnabled;
    int i;
    //
    //  Array of user accounts that we care
    //  S-1-5-19, local services, S-1-5-20, network services
    //

    LPTSTR ppDefaultUser[] = { TEXT(".DEFAULT"), TEXT("S-1-5-19"), TEXT("S-1-5-20")};	
    TCHAR szRegPath[MAX_PATH];

    //
    //  Save the UILanguageId as a string.
    //
    wsprintf(szData, TEXT("%08x"), UILanguageId);	

    for (i=0; i< ARRAYSIZE(ppDefaultUser); i++)
    {
        if (!PathCombine(szRegPath, ppDefaultUser[i], TEXT("Control Panel\\Desktop")))
        {
            return (FALSE);
        }
    
        //
        //  Set the value in .DEFAULT registry.
        //
        if ((rc = RegOpenKeyEx( HKEY_USERS,
                                szRegPath,
                                0L,
                                KEY_READ | KEY_WRITE,
                                &hKey )) == ERROR_SUCCESS)
        {
            rc = RegSetValueEx( hKey,
                                c_szMUIValue,
                                0L,
                                REG_SZ,
                                (LPBYTE)szData,
                                (lstrlen(szData) + 1) * sizeof(TCHAR) );
            //
            //  Sync up UI language pending key
            //
            if (rc == ERROR_SUCCESS)
            {
                rc = RegSetValueEx( hKey,
                                    szMUILangPending,
                                    0L,
                                    REG_SZ,
                                    (LPBYTE)szData,
                                    (lstrlen(szData) + 1) * sizeof(TCHAR) );
            }
            RegCloseKey(hKey);
        }
    }

    //
    //  Save the value into the .DEFAULT user hive
    //
    if (rc == ERROR_SUCCESS)
    {
        //
        //  Load the default hive
        //
        if ((hHive = Intl_LoadNtUserHive( TEXT("tempKey"),
                                          c_szCPanelDesktop,
                                          &wasEnabled )) == NULL )
        {
            return (FALSE);
        }

        //
        //  Save the MUI language value in the NTUSER.dat
        //
        RegSetValueEx( hHive,
                       c_szMUIValue,
                       0L,
                       REG_SZ,
                       (LPBYTE)szData,
                       (lstrlen(szData) + 1) * sizeof(TCHAR));

        //
        //  Sync up UI language pending key
        //
        if (rc == ERROR_SUCCESS)
        {
            rc = RegSetValueEx( hHive,
                                szMUILangPending,
                                0L,
                                REG_SZ,
                                (LPBYTE)szData,
                                (lstrlen(szData) + 1) * sizeof(TCHAR) );
        }
        
        //
        //  Clean up
        //
        RegCloseKey(hHive);
        Intl_UnloadNtUserHive(TEXT("tempKey"), &wasEnabled);
    }
    else
    {
        return (FALSE);
    }

    //
    //  Install Language Input locales.
    //
    return Intl_InstallKeyboardLayout(NULL,
                                      MAKELCID(UILanguageId, SORT_DEFAULT),
                                      0,
                                      FALSE,
                                      TRUE,
                                      FALSE);
}



////////////////////////////////////////////////////////////////////////////
//
//  Intl_LoadLanguageGroups
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_LoadLanguageGroups(
    HWND hDlg)
{
    LPLANGUAGEGROUP pLG;
    DWORD dwExStyle;
    RECT Rect;
    LV_COLUMN Column;
    LV_ITEM Item;
    int iIndex;

    //
    //  Open the Inf file.
    //
    g_hIntlInf = SetupOpenInfFile(szIntlInf, NULL, INF_STYLE_WIN4, NULL);
    if (g_hIntlInf == INVALID_HANDLE_VALUE)
    {
        return (FALSE);
    }

    if (!SetupOpenAppendInfFile(NULL, g_hIntlInf, NULL))
    {
        SetupCloseInfFile(g_hIntlInf);
        g_hIntlInf = NULL;
        return (FALSE);
    }

    //
    //  Get all supported language groups from the inf file.
    //
    if (Intl_GetSupportedLanguageGroups() == FALSE)
    {
        return (FALSE);
    }

    //
    //  Close the inf file.
    //
    SetupCloseInfFile(g_hIntlInf);
    g_hIntlInf = NULL;

    //
    //  Enumerate all installed language groups.
    //
    if (Intl_EnumInstalledLanguageGroups() == FALSE)
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_GetSupportedLanguageGroups
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_GetSupportedLanguageGroups()
{
    UINT LanguageGroup;
    HANDLE hLanguageGroup;
    LPLANGUAGEGROUP pLG;
    INFCONTEXT Context;
    TCHAR szSection[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    int LineCount, LineNum;
    DWORD ItemCount;
    WORD wItemStatus;

    //
    //  Get the number of supported language groups from the inf file.
    //
    LineCount = (UINT)SetupGetLineCount(g_hIntlInf, TEXT("LanguageGroups"));
    if (LineCount <= 0)
    {
        return (FALSE);
    }

    //
    //  Go through all supported language groups in the inf file.
    //
    for (LineNum = 0; LineNum < LineCount; LineNum++)
    {
        if (SetupGetLineByIndex(g_hIntlInf, TEXT("LanguageGroups"), LineNum, &Context) &&
            SetupGetIntField(&Context, 0, &LanguageGroup))
        {
            //
            //  Create the new node.
            //
            if (!(hLanguageGroup = GlobalAlloc(GHND, sizeof(LANGUAGEGROUP))))
            {
                return (FALSE);
            }
            pLG = GlobalLock(hLanguageGroup);

            //
            //  Fill in the new node with the appropriate info.
            //
            pLG->wStatus = 0;
            pLG->LanguageGroup = LanguageGroup;
            pLG->hLanguageGroup = hLanguageGroup;
            (pLG->pszName)[0] = 0;
            pLG->NumLocales = 0;
            pLG->NumAltSorts = 0;

            //
            //  Set the collection 
            //
            if ((pLG->LanguageGroup == LGRPID_JAPANESE) ||
                (pLG->LanguageGroup == LGRPID_KOREAN) ||
                (pLG->LanguageGroup == LGRPID_TRADITIONAL_CHINESE) ||
                (pLG->LanguageGroup == LGRPID_SIMPLIFIED_CHINESE) )
            {
                pLG->LanguageCollection = CJK_COLLECTION;
            }
            else if ((pLG->LanguageGroup == LGRPID_ARABIC) ||
                     (pLG->LanguageGroup == LGRPID_ARMENIAN) ||
                     (pLG->LanguageGroup == LGRPID_GEORGIAN) ||
                     (pLG->LanguageGroup == LGRPID_HEBREW) ||
                     (pLG->LanguageGroup == LGRPID_INDIC) ||
                     (pLG->LanguageGroup == LGRPID_VIETNAMESE) ||
                     (pLG->LanguageGroup == LGRPID_THAI))
            {
                pLG->LanguageCollection = COMPLEX_COLLECTION;
            }
            else
            {
                pLG->LanguageCollection = BASIC_COLLECTION;
            }

            //
            //  Get the appropriate display string.
            //
            if (!SetupGetStringField(&Context, 1, pLG->pszName, MAX_PATH, NULL))
            {
                GlobalUnlock(hLanguageGroup);
                GlobalFree(hLanguageGroup);
                continue;
            }

            //
            //  Get the list of locales for this language group.
            //
            if (Intl_GetLocaleList(pLG) == FALSE)
            {
                return (FALSE);
            }

            //
            //  Add the language group to the front of the linked list.
            //
            pLG->pNext = pLanguageGroups;
            pLanguageGroups = pLG;
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_EnumInstalledLanguageGroups
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_EnumInstalledLanguageGroups()
{
    HKEY hKey;
    TCHAR szValue[MAX_PATH];
    TCHAR szData[MAX_PATH];
    TCHAR szDefault[SIZE_64];
    DWORD dwIndex, cchValue, cbData;
    LONG rc;
    UINT LanguageGroup, OriginalGroup, DefaultGroup, UILanguageGroup;
    LPLANGUAGEGROUP pLG;
    LCID Locale;
    LANGID Language;
    int Ctr;

    //
    //  Get the original install language so that we can mark that
    //  language group as permanent.
    //
    Language = GetSystemDefaultUILanguage();
    if (SUBLANGID(Language) == SUBLANG_NEUTRAL)
    {
        Language = MAKELANGID(PRIMARYLANGID(Language), SUBLANG_DEFAULT);
    }

    if ((OriginalGroup = Intl_GetLanguageGroup(Language)) == 0)
    {
        OriginalGroup = 1;
    }

    //
    //  Get the default system locale so that we can mark that language
    //  group as permanent. During gui mode setup, read the system locale from
    //  the registry to make the info on the setup page consistent with intl.cpl.
    //  SysLocaleID will be the registry value in case of setup.
    //
    Locale = SysLocaleID;
    if (Locale == (LCID)Language)
    {
        DefaultGroup = OriginalGroup;
    }
    else
    {
        if ((DefaultGroup = Intl_GetLanguageGroup(Locale)) == 0)
        {
            DefaultGroup = 1;
        }
    }

    //
    //  Get the UI language's language groups to disable the user from
    //  un-installing them.  MUISETUP makes sure that each installed UI
    //  language has its language group installed.
    //
    Intl_GetUILanguageGroups(&UILangGroup);

    //
    //  Open the HKLM\SYSTEM\CurrentControlSet\Control\Nls\Language Groups
    //  key.
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szLanguageGroups,
                      0,
                      KEY_READ,
                      &hKey ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Enumerate the values in the Language Groups key.
    //
    dwIndex = 0;
    cchValue = sizeof(szValue) / sizeof(TCHAR);
    szValue[0] = TEXT('\0');
    cbData = sizeof(szData);
    szData[0] = TEXT('\0');
    rc = RegEnumValue( hKey,
                       dwIndex,
                       szValue,
                       &cchValue,
                       NULL,
                       NULL,
                       (LPBYTE)szData,
                       &cbData );

    while (rc == ERROR_SUCCESS)
    {
        //
        //  If the language group contains data, then it is installed.
        //
        if ((szData[0] != 0) &&
            (LanguageGroup = TransNum(szValue)))
        {
            //
            //  Find the language group in the linked list and mark it as
            //  originally installed.
            //
            pLG = pLanguageGroups;
            while (pLG)
            {
                if (pLG->LanguageGroup == LanguageGroup)
                {
                    pLG->wStatus |= ML_INSTALL;

                    //
                    //  If this is a language group for a UI language that's
                    //  installed, then disable the un-installation of this
                    //  language group.
                    //
                    Ctr = 0;
                    while (Ctr < UILangGroup.iCount)
                    {
                        if (UILangGroup.lgrp[Ctr] == LanguageGroup)
                        {
                            pLG->wStatus |= ML_PERMANENT;
                            break;
                        }
                        Ctr++;
                    }

                    if (pLG->LanguageGroup == OriginalGroup)
                    {
                        pLG->wStatus |= ML_PERMANENT;
                    }
                    if (pLG->LanguageGroup == DefaultGroup)
                    {
                        pLG->wStatus |= (ML_PERMANENT | ML_DEFAULT);

                        if (LoadString(hInstance, IDS_DEFAULT, szDefault, SIZE_64))
                        {
                            lstrcat(pLG->pszName, szDefault);
                        }
                    }
                    break;
                }

                pLG = pLG->pNext;
            }
        }

        //
        //  Get the next enum value.
        //
        dwIndex++;
        cchValue = sizeof(szValue) / sizeof(TCHAR);
        szValue[0] = TEXT('\0');
        cbData = sizeof(szData);
        szData[0] = TEXT('\0');
        rc = RegEnumValue( hKey,
                           dwIndex,
                           szValue,
                           &cchValue,
                           NULL,
                           NULL,
                           (LPBYTE)szData,
                           &cbData );
    }

    //
    //  Close the registry key handle.
    //
    RegCloseKey(hKey);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_LanguageGroupDirExist
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_LanguageGroupDirExist(
    PTSTR pszLangDir)
{
    TCHAR szLanguageGroupDir[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    TCHAR SavedChar;

    //
    //  If it doesn't start with lang, then this is a core language.
    //
    SavedChar = pszLangDir[4];
    pszLangDir[4] = TEXT('\0');
    if (lstrcmp(pszLangDir, TEXT("lang")))
    {
        return (TRUE);
    }
    pszLangDir[4] = SavedChar;

    //
    //  Format the path to the language group directory.
    //
    lstrcpy(szLanguageGroupDir, pSetupSourcePathWithArchitecture);
    lstrcat(szLanguageGroupDir, TEXT("\\"));
    lstrcat(szLanguageGroupDir, pszLangDir);

    //
    //  See if the language group directory exists.
    //
    FindHandle = FindFirstFile(szLanguageGroupDir, &FindData);
    if (FindHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(FindHandle);
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            //
            //  Return success.
            //
            return (TRUE);
        }
    }

    //
    //  Return failure.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_LanguageGroupFilesExist
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_LanguageGroupFilesExist()
{
    TCHAR szLanguageGroupDir[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    //  Format the path to the language group directory. Add the wildcard
    //  to search for any files located in the lang directory.
    //
    lstrcpy(szLanguageGroupDir, pSetupSourcePathWithArchitecture);
    lstrcat(szLanguageGroupDir, TEXT("\\Lang\\*"));

    //
    //  See if at least one file exists.
    //
    FindHandle = FindFirstFile(szLanguageGroupDir, &FindData);
    if (FindHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(FindHandle);
        //
        //  Return success.
        //
        return (TRUE);
    }

    //
    //  Return failure.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_GetLocaleList
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_GetLocaleList(
    LPLANGUAGEGROUP pLG)
{
    TCHAR szSection[MAX_PATH];
    INFCONTEXT Context;
    int LineCount, LineNum;
    LCID Locale;

    //
    //  Get the inf section name.
    //
    wsprintf(szSection, TEXT("%ws%d"), szLocaleListPrefix, pLG->LanguageGroup);

    //
    //  Get the number of locales for the language group.
    //
    LineCount = (UINT)SetupGetLineCount(g_hIntlInf, szSection);
    if (LineCount <= 0)
    {
        return (FALSE);
    }

    //
    //  Add each locale in the list to the language group node.
    //
    for (LineNum = 0; LineNum < LineCount; LineNum++)
    {
        if (SetupGetLineByIndex(g_hIntlInf, szSection, LineNum, &Context) &&
            SetupGetIntField(&Context, 0, &Locale))
        {
            if (SORTIDFROMLCID(Locale))
            {
                //
                //  Add the locale to the alternate sort list for this
                //  language group.
                //
                if (pLG->NumAltSorts >= MAX_PATH)
                {
                    return (FALSE);
                }
                pLG->pAltSortList[pLG->NumAltSorts] = Locale;
                (pLG->NumAltSorts)++;
            }
            else
            {
                //
                //  Add the locale to the locale list for this
                //  language group.
                //
                if (pLG->NumLocales >= MAX_PATH)
                {
                    return (FALSE);
                }
                pLG->pLocaleList[pLG->NumLocales] = Locale;
                (pLG->NumLocales)++;
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_GetLocaleLanguageGroup
//
//  Reads the Language Group Id of the given language.
//
////////////////////////////////////////////////////////////////////////////

DWORD Intl_GetLanguageGroup(
    LCID lcid)
{
    TCHAR szValue[MAX_PATH];
    TCHAR szData[MAX_PATH];
    HKEY hKey;
    DWORD cbData;


    wsprintf(szValue, TEXT("%8.8x"), lcid);
    szData[0] = 0;
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szInstalledLocales,
                      0,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        cbData = sizeof(szData);
        RegQueryValueEx(hKey, szValue, NULL, NULL, (LPBYTE)szData, &cbData);
        RegCloseKey(hKey);
    }

    return (TransNum(szData));
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_GetUILanguageGroups
//
//  Reads the language groups of all the UI languages installed on this
//  machine.
//
////////////////////////////////////////////////////////////////////////////

BOOL Intl_GetUILanguageGroups(
    PUILANGUAGEGROUP pUILanguageGroup)
{
    //
    //  Enumerate the installed UI languages.
    //
    pUILanguageGroup->iCount = 0L;

    EnumUILanguages(Intl_EnumUILanguagesProc, 0, (LONG_PTR)pUILanguageGroup);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_EnumUILanguagesProc
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK Intl_EnumUILanguagesProc(
    LPWSTR pwszUILanguage,
    LONG_PTR lParam)
{
    int Ctr = 0;
    LGRPID lgrp;
    PUILANGUAGEGROUP pUILangGroup = (PUILANGUAGEGROUP)lParam;
    LCID UILanguage = TransNum(pwszUILanguage);

    if (UILanguage)
    {
        if ((lgrp = Intl_GetLanguageGroup(UILanguage)) == 0)
        {
            lgrp = 1;   // default;
        }

        while (Ctr < pUILangGroup->iCount)
        {
            if (pUILangGroup->lgrp[Ctr] == lgrp)
            {
                break;
            }
            Ctr++;
        }

        //
        //  Theoritically, we won't go over 64 language groups!
        //
        if ((Ctr == pUILangGroup->iCount) && (Ctr < MAX_UI_LANG_GROUPS))
        {
            pUILangGroup->lgrp[Ctr] = lgrp;
            pUILangGroup->iCount++;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_SaveValuesToDefault
//
//  This function copies the current user settings under the srcKey to
//  the Default user under the destKey.
//
////////////////////////////////////////////////////////////////////////////

void Intl_SaveValuesToDefault(
    LPCTSTR srcKey,
    LPCTSTR destKey)
{
    HKEY hkeyLayouts;
    HKEY hkeyLayouts_DefUser;

    //
    //  1. Open the Current user key.
    //
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      srcKey,
                      0,
                      KEY_ALL_ACCESS,
                      &hkeyLayouts ) != ERROR_SUCCESS)
    {
        return;
    }

    //
    //  2. Open the .Default hive key.
    //
    if (RegOpenKeyEx( HKEY_USERS,
                      destKey,
                      0,
                      KEY_ALL_ACCESS,
                      &hkeyLayouts_DefUser ) != ERROR_SUCCESS)
    {
        RegCloseKey(hkeyLayouts);
        return;
    }

    //
    //  3. Delete .Default key values.
    //
    Intl_DeleteRegKeyValues(hkeyLayouts_DefUser);

    //
    //  4. Delete .Default subkeys.
    //
    Intl_DeleteRegSubKeys(hkeyLayouts_DefUser);

    //
    //  5. Copy tree.
    //
    Intl_CreateRegTree(hkeyLayouts, hkeyLayouts_DefUser);

    //
    //  6. Clean up
    //
    RegCloseKey(hkeyLayouts_DefUser);
    RegCloseKey(hkeyLayouts);
}


////////////////////////////////////////////////////////////////////////////
//
//  Intl_SaveValuesToNtUserFile
//
//  This function copy current user setting under the srcKey to the Default
//  user hive under the destKey.
//
////////////////////////////////////////////////////////////////////////////

void Intl_SaveValuesToNtUserFile(
    HKEY hSourceRegKey,
    LPCTSTR srcKey,
    LPCTSTR destKey)
{
    HKEY hRegKey;
    HKEY hHi