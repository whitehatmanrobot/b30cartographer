le));
                PSPage.pszTitle = szABPaneTitle;
                PSPage.pfnDlgProc = ViewPageAddressBook;
                PSPage.lParam = (LPARAM)&ABDialogPaneParams;       // (DWORD) &viewhelp;
                PSPage.pfnCallback = 0;
                PSPage.pcRefParent = NULL;

                {
                    CERT_VIEWPROPERTIES_STRUCT_A cvps = {0};

                    // Fill in the cert view struct
                    cvps.dwSize = sizeof(CERT_VIEWPROPERTIES_STRUCT);
                    cvps.hwndParent = hwnd;
                    cvps.hInstance = hInst;
                    cvps.dwFlags = CM_ADD_CERT_STORES;      // Look in rghstoreCAs
                    LoadString(hInst, idsCertificateViewTitle, szTitle, sizeof(szTitle));
                    cvps.szTitle = szTitle;
                    cvps.pCertContext = rgCertContext[i];
                    cvps.nStartPage = iAddToWAB;    // show add to WAB page first
                    cvps.arrayPurposes = rgPurposes;
                    cvps.cArrayPurposes = 1;
                    cvps.cStores = 1;                       // Count of other stores to search
                    cvps.rghstoreCAs = &hCertStoreMsg;      // Array of other stores to search
                    cvps.hprov = hCryptProvider;          // Provider to use for verification

                    cvps.cArrayPropSheetPages = 1;
                    cvps.arrayPropSheetPages = &PSPage;

                    if (! CertViewPropertiesA(&cvps)) {
                        hr = GetLastError();
                    }
                }


                fFound = TRUE;
                break;  // done with loop
            }
        }

        // Free the table of certs
        for (i = 0; i < cCert; i++) {
            if (rgCertContext[i]) {
                CertFreeCertificateContext(rgCertContext[i]);
            }
        }
        LocalFree((LPVOID)rgCertContext);

        if (! fFound) {
            // Didn't find a cert that isn't an issuer.  Fail.
            hr = ResultFromScode(MAPI_E_NOT_FOUND);
            goto exit;
        }
    }


exit:
    if (hCryptProvider) {
        CryptReleaseContext(hCryptProvider, 0);
    }

    return(hr);
}



/* DebugTrapFn -------------------------------------------------------------- */
#ifdef DEBUG
#if defined(WIN32) && !defined(_MAC)

typedef struct {
	char *		sz1;
	char *		sz2;
	UINT		rgf;
	int			iResult;
} MBContext;

DWORD WINAPI MessageBoxFnThreadMain(MBContext *pmbc)
{
   pmbc->iResult = MessageBoxA(NULL, pmbc->sz1, pmbc->sz2,
       pmbc->rgf | MB_SETFOREGROUND);

	return(0);
}

int MessageBoxFn(char *sz1, char *sz2, UINT rgf)
{
	HANDLE		hThread;
	DWORD		dwThreadId;
	MBContext	mbc;

	mbc.sz1		= sz1;
	mbc.sz2		= sz2;
	mbc.rgf		= rgf;
	mbc.iResult = IDRETRY;

   MessageBoxFnThreadMain(&mbc);
	return(mbc.iResult);
}
#else
#define MessageBoxFn(sz1, sz2, rgf)		MessageBoxA(NULL, sz1, sz2, rgf)
#endif

void FAR CDECL DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...) {
	char	sz[512];
	va_list	vl;

	#if defined(WIN16) || defined(WIN32)
	int		id;
	#endif

	lstrcpyA(sz, "++++ WAB Debug Trap (");
//	_strdate(sz + lstrlenA(sz));
//	lstrcatA(sz, " ");
//	_strtime(sz + lstrlenA(sz));
	lstrcatA(sz, ")\n");
	DebugTrace(sz);

	va_start(vl, pszFormat);
	wvsprintfA(sz, pszFormat, vl);
	va_end(vl);

	wsprintfA(sz + lstrlenA(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

	DebugTrace(sz);

	#if defined(DOS)
	_asm { int 3 }
	#endif

#if defined(WIN16) || defined(WIN32)
	/* Hold down control key to prevent MessageBox */
	if ( GetAsyncKeyState(VK_CONTROL) >= 0 )
	{
		UINT uiFlags = MB_ABORTRETRYIGNORE;

		if (fFatal)
			uiFlags |= MB_DEFBUTTON1;
		else
			uiFlags |= MB_DEFBUTTON3;

		#ifdef WIN16
		uiFlags |= MB_ICONEXCLAMATION | MB_SYSTEMMODAL;
		#else
		uiFlags |= MB_ICONSTOP | MB_TASKMODAL;
		#endif

#ifndef MAC
		id = MessageBoxFn(sz, "WAB Debug Trap", uiFlags);

		if (id == IDABORT)
			*((LPBYTE)NULL) = 0;
		else if (id == IDRETRY)
			DebugBreak();
#endif // MAC			
	}
#endif
}
#endif

/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
#ifdef DEBUG
VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];


    va_start(marker, lpszFmt);
    wvsprintf(String, lpszFmt, marker);
    OutputDebugString(String);
}
#endif

#ifdef DEBUG
//*******************************************************************
void DebugTraceCertContextName(PCCERT_CONTEXT pcCertContext, LPTSTR lpDescription) {
    LPTSTR lpName = NULL;
    PCERT_INFO pCertInfo = pcCertContext->pCertInfo;
#ifdef OLD_STUFF
    GetAttributeString(
      &lpName,
      pCertInfo->Subject.pbData,
      pCertInfo->Subject.cbData,
      szOID_COMMON_NAME);
    if (! lpName) {
        GetAttributeString(
          &lpName,
          pCertInfo->Subject.pbData,
          pCertInfo->Subject.cbData,
          szOID_ORGANIZATION_NAME);
    }

    DebugTrace("%s %s\n", lpDescription, lpName ? lpName : "<unknown>");
    if (lpName) {
        LocalFree(lpName);
    }
#endif // OLD_STUFF
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabapi\dead\image.c ===
//
// image.cpp
//
// utilities for images and imagelists
//


//#include "pch.hxx"
//#include "resource.h"
//#include "globals.h"
//#include "util.h"
#include "_apipch.h"

//extern HINSTANCE hinstMapiX;

//
// TileImage
//
// This function tiles a bitmap in lprcDest, using lpptOrigin as the origin
//
#define ILT_PARTIALBLT_LEFT     0
#define ILT_PARTIALBLT_TOP      1
#define ILT_PARTIALBLT_RIGHT    2
#define ILT_PARTIALBLT_BOTTOM   3

void TileImage(HBITMAP hbmp, HDC hdc, LPPOINT lpptOrigin, LPRECT lprcDest)
    {
    BOOL    fFirstRow, fFirstCol;
    int     nRows, nCols, nSaveCols, offset;
    int     rgOffsetPartialBlt[4];
    POINT   ptTileOrigin, ptDraw, ptDest, ptSrc;
    SIZE    sizeImage, sizeRect, sizeBlt;
    HDC     hdcBmp=0;
    HBITMAP hbmpOrig=0;
    BITMAP  bm;

    if(!hdc)
        return;

    if(!(hdcBmp = CreateCompatibleDC(hdc)))
        goto fail;

    if(!(hbmpOrig = SelectObject(hdcBmp, hbmp)))
        goto fail;
    
    GetObject(hbmp, sizeof(BITMAP), &bm);
    sizeImage.cx = bm.bmWidth;
    sizeImage.cy = bm.bmHeight;

    // Generate the true origin with the tile
    lpptOrigin->x %= sizeImage.cx;
    lpptOrigin->y %= sizeImage.cy;

    // We will start the tile so that the origin lines up
    ptTileOrigin.x = lprcDest->left - lpptOrigin->x;
    ptTileOrigin.y = lprcDest->top - lpptOrigin->y;

    // Figure out how many rows and columns wo need
    sizeRect.cx = lprcDest->right - ptTileOrigin.x;
    sizeRect.cy = lprcDest->bottom - ptTileOrigin.y;

    nRows = sizeRect.cy / sizeImage.cy;
    nRows += (sizeRect.cy % sizeImage.cy) ? 1 : 0;
    nSaveCols = sizeRect.cx / sizeImage.cx;
    nSaveCols += (sizeRect.cx % sizeImage.cx) ? 1 : 0;

    // Generate the partial blt offsets
    rgOffsetPartialBlt[ILT_PARTIALBLT_TOP] = lprcDest->top - ptTileOrigin.y;
     rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT] = lprcDest->left - ptTileOrigin.x;
    if (sizeImage.cy >= sizeRect.cy)
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = sizeImage.cy - sizeRect.cy;
    else if(sizeRect.cy % sizeImage.cy)
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = sizeImage.cy -
                (sizeRect.cy % sizeImage.cy);
    else
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = 0;
    if (sizeImage.cx >= sizeRect.cx)
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = sizeImage.cx - sizeRect.cx;
    else if(sizeRect.cx % sizeImage.cx)
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = sizeImage.cx -
                (sizeRect.cx % sizeImage.cx);
    else
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = 0;

    // Draw the tiles
    ptDraw.y = ptTileOrigin.y;
    fFirstRow = TRUE;
    while (nRows--)
        {
        ptDraw.x = ptTileOrigin.x;
        nCols = nSaveCols;
        fFirstCol = TRUE;
        while (nCols--)
            {
            ptDest = ptDraw;
            sizeBlt = sizeImage;
            ptSrc.x = ptSrc.y = 0; 
            // Handle partial boundary Blts
            if (fFirstRow && rgOffsetPartialBlt[ILT_PARTIALBLT_TOP] != 0)
                {
                offset = rgOffsetPartialBlt[ILT_PARTIALBLT_TOP];
                ptDest.y += offset;
                sizeBlt.cy -= offset;
                ptSrc.y += offset;
                }
            if (nRows == 0 && rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] != 0)
                sizeBlt.cy -= rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM];
            if (fFirstCol && rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT] != 0)
                {
                offset = rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT];
                ptDest.x += offset;
                sizeBlt.cx -= offset;
                ptSrc.x += offset;
                }
            if (nCols == 0 && rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] != 0)
                sizeBlt.cx -= rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT];
            // Just do it
            BitBlt(hdc, ptDest.x, ptDest.y,    sizeBlt.cx, sizeBlt.cy,
                    hdcBmp, ptSrc.x, ptSrc.y, SRCCOPY);
            ptDraw.x += sizeImage.cx;
            fFirstCol = FALSE;
            }
        ptDraw.y += sizeImage.cy;
        fFirstRow = FALSE;
        }

fail:
    if(hdcBmp) 
        {
        if(hbmpOrig)
            SelectObject(hdcBmp, hbmpOrig);
        DeleteDC(hdcBmp);
        }
    }

//
// shared image list..
//

static HIMAGELIST g_himlAthSm = NULL;
static HIMAGELIST g_himlAthLg = NULL;
static HIMAGELIST g_himlAthSt = NULL;

HIMAGELIST InitImageList(int cx, int cy, LPSTR szbm, int cicon)
{
    HBITMAP hbm;
    HIMAGELIST himl;

    himl = ImageList_Create(cx, cy, ILC_MASK, cicon, 0);

    if (himl != NULL)
        {
        hbm = LoadBitmap(hinstMapiX, szbm);

        ImageList_AddMasked(himl, hbm, RGB_TRANSPARENT);

        DeleteObject((HGDIOBJ)hbm);
        }

    return(himl);
}


void FreeImageLists(void)
{
    if (g_himlAthSm != NULL)
        {
        ImageList_Destroy(g_himlAthSm);
        g_himlAthSm = NULL;
        }

    if (g_himlAthLg != NULL)
        {
        ImageList_Destroy(g_himlAthLg);
        g_himlAthLg = NULL;
        }

    if (g_himlAthSt != NULL)
        {
        ImageList_Destroy(g_himlAthSt);
        g_himlAthSt = NULL;
        }
}

BOOL LoadBitmapAndPalette(int idbmp, HBITMAP *phbmp, HPALETTE *phpal)
    {
    int i, n;
    HBITMAP hbmp;
    HPALETTE hpal;
    HDC hdcBitmap;
    DWORD adw[257];
    BOOL fret = FALSE;

    hdcBitmap = NULL;
    *phbmp = NULL;
    *phpal = NULL;

    hbmp = (HBITMAP)LoadImage(hinstMapiX, MAKEINTRESOURCE(idbmp),
                    IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    if (hbmp == NULL)
        goto DoneLoadBitmap;

    hdcBitmap = CreateCompatibleDC(NULL);
    if (hdcBitmap == NULL)
        goto DoneLoadBitmap;
    SelectObject(hdcBitmap, (HGDIOBJ)hbmp);
    n = GetDIBColorTable(hdcBitmap, 0, 256, (LPRGBQUAD)&adw[1]);
    for (i = 1; i <= n; i++)
        adw[i] = RGB(GetBValue(adw[i]), GetGValue(adw[i]), GetRValue(adw[i]));
    adw[0] = MAKELONG(0x300, n);
    hpal = CreatePalette((LPLOGPALETTE)&adw[0]);
    if (hpal == NULL)
        goto DoneLoadBitmap;

    *phbmp = hbmp;
    *phpal = hpal;

    fret = TRUE;

DoneLoadBitmap:
    if (hdcBitmap != NULL)
        DeleteDC(hdcBitmap);

    return(fret);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabexe\makefile.inc ===
$O\wabexe.res : selfreg.inf

selfreg.inf : selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabfind\common.c ===
/*****************************************************************************
 *
 *	common.c - Shared stuff that operates on all classes
 *
 *	WARNING!  The Common services work only if you pass in the
 *	"primary object".  This is vacuous if you don't use multiple
 *	inheritance, since there's only one object in the first place.
 *
 *	If you use multiple inheritance, make sure you pass the pointer
 *	to the object that you use as IUnknown.
 *
 *	The exceptions are the Forward_* functions, which work on
 *	pointers to non-primary interfaces.  They forward the call to the
 *	primary interface.
 *
 *****************************************************************************/

#include "fnd.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflCommon

/*****************************************************************************
 *
 *  USAGE FOR OLE OBJECTS
 *
 *	Suppose you want to implement an object called CObj that supports
 *	the interfaces Foo, Bar, and Baz.  Suppose that you opt for
 *	Foo as the primary interface.
 *
 *	>> NAMING CONVENTION <<
 *
 *	    COM objects begin with the letter "C".
 *
 *	(1) Declare the primary and secondary vtbls.
 *
 *		Primary_Interface(CObj, IFoo);
 *		Secondary_Interface(CObj, IBar);
 *		Secondary_Interface(CObj, IBaz);
 *
 *	(3) Declare the object itself.
 *
 *		typedef struct CObj {
 *		    IFoo 	foo;	    // Primary must come first
 *		    IBar	bar;
 *		    IBaz	baz;
 *		    ... other fields ...
 *		} CObj;
 *
 *	(4) Implement the methods.
 *
 *	    You may *not* reimplement the AddRef and Release methods!
 *	    although you can subclass them.
 *
 *	(5) To allocate an object of the appropriate type, write
 *
 *		hres = Common_New(CObj, ppvOut);
 *
 *	    or, if the object is variable-sized,
 *
 *		hres = Common_NewCb(cb, CObj, ppvOut);
 *
 *	    If the object supports multiple interfaces, you also need to
 *	    initialize all the secondary interfaces.
 *
 *		CObj *pco = *ppvOut;
 *		pco->bar = Secondary_Vtbl(CObj, IBar);
 *		pco->baz = Secondary_Vtbl(CObj, IBaz);
 *
 *	(6) Define the vtbls.
 *
 *		#pragma BEGIN_CONST_DATA
 *
 *		// The macros will declare QueryInterface, AddRef and Release
 *		// so don't list them again
 *
 *		Primary_Interface_Begin(CObj, IFoo)
 *		    CObj_FooMethod1,
 *		    CObj_FooMethod2,
 *		    CObj_FooMethod3,
 *		    CObj_FooMethod4,
 *		Primary_Interface_End(Obj, IFoo)
 *
 *		Secondary_Interface_Begin(CObj, IBar, bar)
 *		    CObj_Bar_BarMethod1,
 *		    CObj_Bar_BarMethod2,
 *		Secondary_Interface_Begin(CObj, IBar, bar)
 *
 *		Secondary_Interface_Begin(CObj, IBaz, baz)
 *		    CObj_Baz_BazMethod1,
 *		    CObj_Baz_BazMethod2,
 *		    CObj_Baz_BazMethod3,
 *		Secondary_Interface_Begin(CObj, IBaz, baz)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  USAGE FOR NON-OLE OBJECTS
 *
 *	All objects are COM objects, even if they are never given out.
 *	In the simplest case, it just derives from IUnknown.
 *
 *	Suppose you want to implement an object called Obj which is
 *	used only internally.
 *
 *	(1) Declare the vtbl.
 *
 *		Simple_Interface(Obj);
 *
 *	(3) Declare the object itself.
 *
 *		typedef struct Obj {
 *		    IUnknown unk;
 *		    ... other fields ...
 *		} Obj;
 *
 *	(4) Implement the methods.
 *
 *	    You may *not* override the QueryInterface, AddRef or
 *	    Release methods!
 *
 *	(5) Allocating an object of the appropriate type is the same
 *	    as with OLE objects.
 *
 *	(6) Define the "vtbl".
 *
 *		#pragma BEGIN_CONST_DATA
 *
 *		Simple_Interface_Begin(Obj)
 *		Simple_Interface_End(Obj)
 *
 *	    That's right, nothing goes between the Begin and the End.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	CommonInfo
 *
 *	Information tracked for all common objects.
 *
 *	A common object looks like this:
 *
 *			  riid
 *              cRef	  FinalizeProc
 *	pFoo -> lpVtbl -> QueryInterface
 *		data	  Common_AddRef
 *		data	  Common_Release
 *		...	  ...
 *
 *	Essentially, we use the otherwise-unused space above the
 *	pointers to record our bookkeeping information.
 *
 *	cRef	     = object reference count
 *	riid	     = object iid
 *	FinalizeProc = Finalization procedure
 *
 *	For secondary interfaces, it looks like this:
 *
 *              	  offset to primary interface
 *	pFoo -> lpVtbl -> Forward_QueryInterface
 *			  Forward_AddRef
 *			  Forward_Release
 *			  ...
 *
 *****************************************************************************/

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

typedef struct CommonInfoN {
  D(ULONG cin_dwSig;)
    ULONG cin_cRef;
} CommonInfoN, CIN, *PCIN;

typedef struct CommonInfoP {
    PREVTBL *cip_prevtbl;
} CommonInfoP, CIP, *PCIP;

typedef struct CommonInfoP2 {
    PREVTBL2 *cip2_prevtbl2;
} CommonInfoP2, CIP2, *PCIP2;

typedef union CommonInfo {
    CIN cin[1];
    CIP cip[1];
    CIP2 cip2[1];
} CommonInfo, CI, *PCI;


#define ci_dwSig	cin[-1].cin_dwSig
#define ci_cRef		cin[-1].cin_cRef
#define ci_rgfp		cip[0].cip_prevtbl
#define ci_riid		cip[0].cip_prevtbl[-1].riid
#define ci_Finalize	cip[0].cip_prevtbl[-1].FinalizeProc
#define ci_lib		cip2[0].cip2_prevtbl2[-1].lib

#define ci_Start	ci_cRef

#define ci_dwSignature	0x38162378		/* typed by my cat */

/*****************************************************************************
 *
 *	Common_QueryInterface (from IUnknown)
 *
 *	Use this for objects that support only one interface.
 *
 *****************************************************************************/

STDMETHODIMP
Common_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    PCI pci = pv;
    HRESULT hres;
    EnterProc(Common_QueryInterface, (_ "pG", pv, riid));
    AssertF(pci->ci_dwSig == ci_dwSignature);

#ifdef _WIN64
    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IShellExtInit) || IsEqualIID(riid, &IID_IContextMenu))
#else
    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, pci->ci_riid))
#endif 
    {
    	*ppvObj = pv;
	    Common_AddRef(pv);
	    hres = NOERROR;
    } 
    else
    {
	    *ppvObj = NULL;
	    hres = ResultFromScode(E_NOINTERFACE);
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	Common_AddRef (from IUnknown)
 *
 *	Increment the object refcount and the dll refcount.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
_Common_AddRef(PV pv)
{
    PCI pci = pv;
    AssertF(pci->ci_dwSig == ci_dwSignature);
    InterlockedIncrement((LPLONG)&g_cRef);
    return ++pci->ci_cRef;
}

/*****************************************************************************
 *
 *	Common_Finalize (from Common_Release)
 *
 *	By default, no finalization is necessary.
 *
 *****************************************************************************/

void EXTERNAL
Common_Finalize(PV pv)
{
}

/*****************************************************************************
 *
 *	Common_Release (from IUnknown)
 *
 *	Decrement the object refcount and the dll refcount.
 *
 *	If the object refcount drops to zero, finalize the object
 *	and free it.
 *
 *	The finalization handler lives ahead of the object vtbl.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
_Common_Release(PV pv)
{
    PCI pci = pv;
    ULONG ulRc;
    AssertF(pci->ci_dwSig == ci_dwSignature);
    InterlockedDecrement((LPLONG)&g_cRef);
    ulRc = --pci->ci_cRef;
    if (ulRc == 0) 
    {
#ifndef _WIN64
	    pci->ci_Finalize(pv);
#endif // WIN64
	    FreePv(&pci->ci_Start);
    }
    return ulRc;
}

/*****************************************************************************
 *
 *	Forward_QueryInterface (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP
Forward_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_QueryInterface(punk, riid, ppvObj);
}

/*****************************************************************************
 *
 *	Forward_AddRef (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Forward_AddRef(PV pv)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_AddRef(punk);
}

/*****************************************************************************
 *
 *	Forward_Release (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Forward_Release(PV pv)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_Release(punk);
}

/*****************************************************************************
 *
 *	_Common_New
 *
 *	Create a new object with refcount 1 and the specific vtbl.
 *	All other fields are zero-initialized.
 *
 *****************************************************************************/

STDMETHODIMP
_Common_New(ULONG cb, PV vtbl, PPV ppvObj)
{
    HRESULT hres;
    UNALIGNED PVOID * ppv;

    EnterProc(Common_New, (_ "u", cb));
    hres = AllocCbPpv(cb + sizeof(CIN), ppvObj);
    if (SUCCEEDED(hres)) 
    {
	    PCI pci = pvAddPvCb(*ppvObj, sizeof(CIN));
        D(pci->ci_dwSig = ci_dwSignature);
        ppv = &(pci->cip[0].cip_prevtbl);
	    *ppv = vtbl;

	    *ppvObj = pci;
	    Common_AddRef(pci);
	    hres = NOERROR;
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	Invoke_Release
 *
 *	Release the object (if there is one) and wipe out the back-pointer.
 *	Note that we wipe out the value before calling the release, in order
 *	to ameliorate various weird callback conditions.
 *
 *****************************************************************************/

void EXTERNAL
Invoke_Release(PV pv)
{
    LPUNKNOWN punk = pvExchangePpvPv(pv, 0);
    if (punk) {
	punk->lpVtbl->Release(punk);
    }
}

#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabexe\resource.h ===
#define IDI_ICON1                       101
#define IDI_ICON_VCARD                  102

#define idsWABTitle         2001
#define idsWABFileNotFound  2002
#define idsWABOpenError     2003
#define idsWABOpenFileTitle 2004
#define idsWABOpenFileFilter 2005
#define idsWABNewFileTitle  2006
#define idsWABUsage         2007
#define idsWABPathNotFound  2008
#define idsWABInvalidCmdLine 2009
#define idsWABTitleWithFileName 2010
#define idsWABAddressError  2011
#define idsWABOpenErrorMemory   2012
#define idsWABOpenErrorLocked   2013
#define idsWABOpenErrorCorrupt  2014
#define idsWABOpenErrorDisk     2015
#define idsWABAddressErrorMissing  2016
#define idsWABOpenErrorNotWAB      2017
#define idsWABOpenErrorNotWABName  2018
#define idsWABOpenVCardError        2019
#define idsWABOpenLDAPUrlError      2020
#ifdef WIN16
#define idsWABUsage1        2100
#endif

#define idsAddToABPaneTitle         2030
#define idsCertificateViewTitle     2031

#define IDD_DIALOG_DEFAULT_VCARD_VIEWER 3000
#define IDC_CHECK_ALWAYS                3001
#define IDC_STATIC_ASK                  3002
#define IDC_STATIC_ICON                 3003

#define IDC_ADD_TO_ADDRESS_BOOK     4000
#define IDD_CERTPROP_ADDRESS_BOOK   4001
#define IDC_ADD_TO_ADDRESS_BOOK_FRAME   4002
#define IDC_ADD_TO_ADDRESS_BOOK_TEXT    4003

#define MAX_RESOURCE_STRING         260
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabexe\wabexe.h ===
/*-----------------------------------------
//
//   WABExe.h -- externs
//
//
//-----------------------------------------*/
extern HINSTANCE hInst;         // this module's resources instance handle
extern HINSTANCE hInstApp;         // this module's instance handle

HRESULT CertFileDisplay(HWND hwnd,
  LPWABOBJECT lpWABObject,
  LPADRBOOK lpAdrBook,
  LPTSTR lpFileName);

extern const UCHAR szEmpty[];


#ifdef DEBUG
#define DebugTrace          DebugTraceFn
#define IFTRAP(x)           x
#define Assert(t) IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#else
#define DebugTrace          1?0:DebugTraceFn
#define IFTRAP(x)           0
#define Assert(t)
#endif

/* Debugging Functions ---------------------------------------------------- */
VOID FAR CDECL DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
VOID FAR CDECL DebugTraceFn(char *pszFormat, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabfind\fnd.h ===
/*****************************************************************************
 *
 *	fnd.h - Main private header file
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	Coding conventions:
 *
 *	+ Follow standard shell coding conventions.
 *
 *	+ Standard K&R brace placement and indentation style.
 *
 *	+ Indent by 4 spaces.
 *
 *	+ Fully-brace all dependent clauses.  Never write "if (c) foo();"
 *
 *	+ Do not return in the middle of a function.  If forced,
 *	  use a "goto exit".  This way, you can stick entry/exit stuff
 *	  later without getting caught out.  (I learned this rule the
 *	  hard way.)
 *
 *	+ Declare variables with narrowest possible scope.
 *
 *	+ Always test for success, not failure!  The compiler will
 *	  thank you.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	NOTE!  This code was written for readability, not efficiency.
 *
 *	I'm trusting the compiler to do optimizations like these:
 *
 *	"Parameter alias":
 *
 *	    Function(LPFOO pfoo)
 *	    {
 *		LPBAR pbar = (LPBAR)pfoo;
 *		... use pbar and never mention pfoo again ...
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(LPFOO pfoo)
 *	    {
 *		#define pbar ((LPBAR)pfoo)
 *		... use pbar and never mention pfoo again ...
 *		#undef pbar
 *	    }
 *
 *	"Speculative Execution":
 *
 *	    Function(PFOO pfoo)
 *	    {
 *		BOOL fRc;
 *		if (... condition 1 ...) {
 *		    ... complicated stuff ...
 *		    *pfoo = result;
 *		    fRc = 1;
 *		} else {		// condition 1 failed
 *		    *pfoo = 0;
 *		    fRc = 0;
 *		}
 *		return fRc;
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(PFOO pfoo)
 *	    {
 *		BOOL fRc = 0;
 *		*pfoo = 0;
 *		if (... condition 1 ...) {
 *		    ... complicated stuff ...
 *		    *pfoo = result;
 *		    fRc = 1;
 *		}
 *		return fRc;
 *	    }
 *
 *	"Single Exit":
 *
 *	    Function(...)
 *	    {
 *		BOOL fRc;
 *		if (... condition 1 ...) {
 *		    ...
 *		    if (... condition 2 ...) {
 *			...
 *			fRc = 1;
 *		    } else {		// condition 2 failed
 *			... clean up ...
 *			fRc = 0;
 *		    }
 *		} else {		// condition 1 failed
 *		    ... clean up ...
 *		    fRc = 0;
 *		}
 *		return fRc;
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(...)
 *	    {
 *		if (... condition 1 ...) {
 *		    ...
 *		    if (... condition 2 ...) {
 *			...
 *			return 1;
 *		    } else {		// condition 2 failed
 *			... clean up ...
 *			return 0;
 *		    }
 *		} else {		// condition 1 failed
 *		    ... clean up ...
 *		    return 0;
 *		}
 *		NOTREACHED;
 *	    }
 *
 *
 *
 *****************************************************************************/

#define WIN32_LEAN_AND_MEAN
#define NOIME
#define NOSERVICE
#define _WIN32_WINDOWS 0x0400
#include <windows.h>

#ifdef	RC_INVOKED		/* Define some tags to speed up rc.exe */
#define __RPCNDR_H__		/* Don't need RPC network data representation */
#define __RPC_H__		/* Don't need RPC */
#include <oleidl.h>		/* Get the DROPEFFECT stuff */
#define _OLE2_H_		/* But none of the rest */
#define _WINDEF_
#define _WINBASE_
#define _WINGDI_
#define NONLS
#define _WINCON_
#define _WINREG_
#define _WINNETWK_
#define _INC_COMMCTRL
#define _INC_SHELLAPI
#else
#include <windowsx.h>
#endif


#include <shlobj.h>
#include <shellapi.h>
#include <objbase.h>
#include "resrc2.h"

#define _IOffset(class, itf)         ((UINT_PTR)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf)))

#ifndef	RC_INVOKED

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

/*****************************************************************************
 *
 *	Stuff I'm tired of typing over and over.
 *
 *****************************************************************************/

typedef LPITEMIDLIST PIDL, *PPIDL;
typedef LPCITEMIDLIST PCIDL;
typedef LPSHELLFOLDER PSF;
typedef LPVOID PV;
typedef LPVOID *PPV;
typedef LPCVOID PCV;
typedef REFIID RIID;
typedef LPUNKNOWN PUNK;

/*****************************************************************************
 *
 *	Baggage - Stuff I carry everywhere
 *
 *****************************************************************************/

#define INTERNAL NTAPI	/* Called only within a translation unit */
#define EXTERNAL NTAPI	/* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

#define OBJAT(T, v) (*(T *)(v))		/* Pointer punning */
#define PUN(T, v) OBJAT(T, &(v))	/* General-purpose type-punning */

/*
 * Convert a count of TCHAR's to a count of bytes.
 */
#define cbCtch(ctch) ((ctch) * sizeof(TCHAR))

/*
 * Convert an object (X) to a count of bytes (cb).
 */

/*
 * Convert an array name (A) to a generic count (c).
 */
#define cA(a) (cbX(a)/cbX(a[0]))

/*
 * Convert an array name (A) to a pointer to its Max.
 * (I.e., one past the last element.)
 */
#define pvMaxA(a) (&a[cA(a)])

#ifdef _WIN64
#define ALIGNTYPE                       LARGE_INTEGER
#define ALIGN                           ((ULONG) (sizeof(ALIGNTYPE) - 1))
#define LcbAlignLcb(lcb)        (((lcb) + ALIGN) & ~ALIGN)
#endif

#ifdef _WIN64
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - LcbAlignLcb((cb))))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + LcbAlignLcb((cb))))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))
#else
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))
#endif //WIN64
/*
 * Round cb up to the nearest multiple of cbAlign.  cbAlign must be
 * a power of 2 whose evaluation entails no side-effects.
 */
#define ROUNDUP(cb, cbAlign) ((((cb) + (cbAlign) - 1) / (cbAlign)) * (cbAlign))

#define cbX(X) sizeof(X)

/*
 * lfNeVV
 *
 * Given two values, return zero if they are equal and nonzero if they
 * are different.  This is the same as (v1) != (v2), except that the
 * return value on unequal is a random nonzero value instead of 1.
 * (lf = logical flag)
 *
 * lfNePvPv
 *
 * The same as lfNeVV, but for pointers.
 *
 * lfPv
 *
 * Nonzero if pv is not null.
 *
 */
#define lfNeVV(v1, v2) ((v1) - (v2))
#define lfNePvPv(v1, v2) lfNeVV((DWORD)(PV)(v1), (DWORD)(PV)(v2))
#define lfPv(pv) ((BOOL)(PV)(pv))

/*
 * land -- Logical and.  Evaluate the first.  If the first is zero,
 * then return zero.  Otherwise, return the second.
 */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

/*
 * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
 * return it.  Otherwise, return the second.
 *
 * Unfortunately, due to the C language, this can't
 * be implemented, so we just return 1 if the first is nonzero.
 * GNU has an extension that supports this, which we use. //;Internal
 */

#if defined(__GNUC__) //;Internal
#define fLorFF(f1, f2) ((f1) ?: (f2)) //;Internal
#else //;Internal
#define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif //;Internal

/*
 * limp - logical implication.  True unless the first is nonzero and
 * the second is zero.
 */
#define fLimpFF(f1, f2) (!(f1) || (f2))

/*
 * leqv - logical equivalence.  True if both are zero or both are nonzero.
 */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))

/*
 * InOrder - checks that i1 <= i2 < i3.
 */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

/*
 * CopyPvPvCb - Copy some memory around
 * MovePvPvCb - Move some memory around
 */
#define CopyPvPvCb RtlCopyMemory
#define MovePvPvCb RtlMoveMemory

/*
 * memeq - Reverse of memcmp
 */
#define memeq !memcmp

/*
 * fPvPfnCmpPv - Compare two objects for equality using the comparison
 *		 function and the desired outcome.  E.g.,
 *
 *			fPvPfnCmpPv(psz1, lstrcmpi, >, psz2)
 *
 *		 returns nonzero if psz1 is greater than psz2 according
 *		 to lstrcmpi.
 */

#define fPvPfnCmpPv(p1, pfn, cmp, p2) (pfn(p1, p2) cmp 0)

/*
 * lstreq   - nonzero if two strings (according to lstrcmp) are equal
 * lstrne   - nonzero if two strings (according to lstrcmp) are different
 *
 * lstrieq   - nonzero if two strings (according to lstrcmpi) are equal
 * lstrine   - nonzero if two strings (according to lstrcmpi) are different
 *
 * lstrieqA  - nonzero if two strings (according to lstrcmpiA) are equal
 * lstrineA  - nonzero if two strings (according to lstrcmpiA) are different
 */

#define lstreq   !lstrcmp
#define lstrne   lstrcmp

#define lstrieq  !lstrcmpi
#define lstrine  lstrcmpi

#define lstrieqA !lstrcmpiA
#define lstrineA lstrcmpiA

/*****************************************************************************
 *
 *	Wrappers and other quickies
 *
 *****************************************************************************/

#define pvExchangePpvPv(ppv, pv) \
	(PV)InterlockedExchangePointer((ppv), (pv))

#define hresUs(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))

/*****************************************************************************
 *
 *	Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *****************************************************************************/

HINSTANCE g_hinst;		/* My resource instance handle */
HINSTANCE g_hinstApp;   /* My instance handle */
HINSTANCE g_hinstWABDLL; /* My WAB32.DLL instance handle */

//DEFINE_GUID(CLSID_Fnd, 0x37865980, 0x75d1, 0x11cf,
//		       0xbf,0xc7,0x44,0x45,0x53,0x54,0,0);
// {32714800-2E5F-11d0-8B85-00AA0044F941}
DEFINE_GUID(CLSID_Fnd, 
0x32714800, 0x2e5f, 0x11d0, 0x8b, 0x85, 0x0, 0xaa, 0x0, 0x44, 0xf9, 0x41);

/*****************************************************************************
 *
 *	Dynamic Globals.  There should be as few of these as possible.
 *
 *	All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef;			/* Global reference count */

/*****************************************************************************
 *
 *	fndcf.c - Class Factory
 *
 *****************************************************************************/

STDMETHODIMP CFndFactory_New(RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *	fndcm.c - IContextMenu, IShellExtInit
 *
 *****************************************************************************/

STDMETHODIMP CFndCm_New(RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *	Common object managers.
 *
 *****************************************************************************/


typedef struct PREVTBL0 {		/* Simple (non-OLE) object */
    void (NTAPI *FinalizeProc)(PV pv);	/* Finalization procedure */
} PREVTBL0, *PPREVTBL0;

typedef struct PREVTBL {		/* Primary interface */
    REFIID riid;			/* Type of this object */
    void (NTAPI *FinalizeProc)(PV pv);	/* Finalization procedure */
} PREVTBL, *PPREVTBL;

typedef struct PREVTBL2 {		/* Secondary interface */
    ULONG lib;				/* offset from start of object */
} PREVTBL2, *PPREVTBL2;

#define Simple_Interface(C) 		Primary_Interface(C, IUnknown)
#define Simple_Vtbl(C)	    		Primary_Vtbl(C)
#define Simple_Interface_Begin(C)	\
	struct S_##C##Vtbl c_####C##VI = { {		\
	    &IID_##IUnknown,				\
	    C##_Finalize,				\
	}, {						\
	    Common##_QueryInterface,			\
	    Common##_AddRef,				\
	    Common##_Release,				\

#define Simple_Interface_End(C)	    	Primary_Interface_End(C, IUnknown)

#define Primary_Interface(C, I)				\
	extern struct S_##C##Vtbl {			\
	    PREVTBL prevtbl;				\
	    I##Vtbl vtbl;				\
	} c_##C##VI					\

#define Primary_Vtbl(C) &c_##C##VI.vtbl

#define Primary_Interface_Begin(C, I)			\
	struct S_##C##Vtbl c_####C##VI = { {		\
	    &IID_##I,					\
	    C##_Finalize,				\
	}, {						\
	    C##_QueryInterface,				\
	    C##_AddRef,					\
	    C##_Release,				\

#define Primary_Interface_End(C, I)			\
	} };						\

#define Secondary_Interface(C, I)			\
	extern struct S_##I##_##C##Vtbl {		\
	    PREVTBL2 prevtbl;	 			\
	    I##Vtbl vtbl;	 			\
	} c_##I##_##C##VI				\

#define Secondary_Vtbl(C, I) &c_##I##_##C##VI.vtbl

#define Secondary_Interface_Begin(C, I, nm)		\
	struct S_##I##_##C##Vtbl c_##I##_##C##VI = { {	\
	    _IOffset(C, nm),				\
	}, {						\
	    Forward_QueryInterface,			\
	    Forward_AddRef,				\
	    Forward_Release,				\

#define Secondary_Interface_End(C, I, nm)		\
	} };						\

#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64

STDMETHODIMP Common_QueryInterface(PV, REFIID, PPV);
STDMETHODIMP_(ULONG) _Common_AddRef(PV pv);
STDMETHODIMP_(ULONG) _Common_Release(PV pv);

#define Common_AddRef _Common_AddRef
#define Common_Release _Common_Release

void EXTERNAL Common_Finalize(PV);

STDMETHODIMP _Common_New(ULONG cb, PV vtbl, PPV ppvObj);
#define Common_NewCb(cb, C, ppvObj) _Common_New(cb, Primary_Vtbl(C), ppvObj)
#define Common_New(C, ppvObj) Common_NewCb(cbX(C), C, ppvObj)

STDMETHODIMP Forward_QueryInterface(PV pv, REFIID riid, PPV ppvObj);
STDMETHODIMP_(ULONG) Forward_AddRef(PV pv);
STDMETHODIMP_(ULONG) Forward_Release(PV pv);

/*****************************************************************************
 *
 *	Common_CopyAddRef
 *
 *	Copy a pointer and increment its reference count.
 *
 *	Cannot be a macro because Common_AddRef evaluates its argument
 *	twice.
 *
 *****************************************************************************/

INLINE void Common_CopyAddRef(PV pvDst, PV pvSrc)
{
    PPV ppvDst = pvDst;
    *ppvDst = pvSrc;
    Common_AddRef(pvSrc);
}

/*****************************************************************************
 *
 *	Invoking OLE methods.
 *
 *	Invoke_Release is called with a pointer to the object, not with
 *	the object itself.  It zeros out the variable on the release.
 *
 *****************************************************************************/

void EXTERNAL Invoke_AddRef(PV pv);
void EXTERNAL Invoke_Release(PV pv);

/*****************************************************************************
 *
 *	assert.c - Assertion stuff
 *
 *****************************************************************************/

typedef enum {
    sqflAlways		= 0x00000000,		/* Unconditional */
    sqflDll		= 0x00000001,		/* Dll bookkeeping */
    sqflFactory		= 0x00000002,		/* IClassFactory */
    sqflCm		= 0x00000004,		/* IContextMenu */
    sqflCommon		= 0x00000000,		/* common.c */
    sqflError		= 0x80000000,		/* Errors */
} SQFL;						/* squiffle */

void EXTERNAL SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...);
int EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);


/*****************************************************************************
 *
 *	Procedure enter/exit tracking.
 *
 *	Start a procedure with
 *
 *	EnterProc(ProcedureName, (_ "format", arg, arg, arg, ...));
 *
 *	The format string is documented in EmitPal.
 *
 *	End a procedure with one of the following:
 *
 *	    ExitProc();
 *
 *		Procedure returns no value.
 *
 *	    ExitProcX();
 *
 *		Procedure returns an arbitrary DWORD.
 *
 *	    ExitOleProc();
 *
 *		Procedure returns an HRESULT (named "hres").
 *
 *	    ExitOleProcPpv(ppvOut);
 *
 *		Procedure returns an HRESULT (named "hres") and, on success,
 *		puts a new object in ppvOut.
 *
 *****************************************************************************/

#define cpvArgMax	10	/* Max of 10 args per procedure */

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

typedef struct ARGLIST {
    LPCSTR pszProc;
    LPCSTR pszFormat;
    PV rgpv[cpvArgMax];
} ARGLIST, *PARGLIST;

void EXTERNAL ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...);
void EXTERNAL EnterSqflPszPal(SQFL sqfl, LPCTSTR psz, PARGLIST pal);
void EXTERNAL ExitSqflPalHresPpv(SQFL, PARGLIST, HRESULT, PPV);

#define AssertFPtsz(c, ptsz)
#define ValidateF(c)	(c)
#define D(x)

#define SetupEnterProc(nm)
#define DoEnterProc(v)
#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()


#define AssertF(c)	AssertFPtsz(c, TEXT(#c))

/*****************************************************************************
 *
 *	Macros that forward to the common handlers after squirting.
 *	Use these only in DEBUG.
 *
 *	It is assumed that sqfl has been #define'd to the appropriate sqfl.
 *
 *****************************************************************************/


/*****************************************************************************
 *
 *	mem.c
 *
 *	Be extremely careful with FreePv, because it doesn't work if
 *	the pointer is null.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#define FreePpv(ppv) ReallocCbPpv(0, ppv)
#define FreePv(pv) LocalFree((HLOCAL)(pv))

#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64

#endif /* !RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabfind\fndcm.c ===
/*****************************************************************************
 *
 *	fndcm.c - IContextMenu interface
 *
 *****************************************************************************/

#include "fnd.h"
#include <wab.h>

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflCm

/*****************************************************************************
 *
 *	PICI
 *
 *	I'm getting lazy.
 *
 *****************************************************************************/

typedef LPCMINVOKECOMMANDINFO PICI;

/*****************************************************************************
 *
 *	Declare the interfaces we will be providing.
 *
 *	We must implement an IShellExtInit so the shell
 *	will know that we are ready for action.
 *
 *****************************************************************************/

Primary_Interface(CFndCm, IContextMenu);
Secondary_Interface(CFndCm, IShellExtInit);

/*****************************************************************************
 *
 *	CFndCm
 *
 *	The context menu extension for "Find... &People".
 *
 *****************************************************************************/

typedef struct CFndCm {

    /* Supported interfaces */
    IContextMenu 	cm;
    IShellExtInit	sxi;

} CFndCm, FCM, *PFCM;

typedef IContextMenu CM, *PCM;
typedef IShellExtInit SXI, *PSXI;
typedef IDataObject DTO, *PDTO;

/*****************************************************************************
 *
 *	CFndCm_QueryInterface (from IUnknown)
 *
 *	We need to check for our additional interfaces before falling
 *	through to Common_QueryInterface.
 *
 *****************************************************************************/

STDMETHODIMP
CFndCm_QueryInterface(PCM pcm, RIID riid, PPV ppvObj)
{
    PFCM this = IToClass(CFndCm, cm, pcm);
    HRESULT hres;
    if (IsEqualIID(riid, &IID_IShellExtInit)) {
	*ppvObj = &this->sxi;
	Common_AddRef(this);
	hres = NOERROR;
    } else {
	hres = Common_QueryInterface(this, riid, ppvObj);
    }
    AssertF(fLimpFF(FAILED(hres), *ppvObj == 0));
    return hres;
}

/*****************************************************************************
 *
 *	CFndCm_AddRef (from IUnknown)
 *	CFndCm_Release (from IUnknown)
 *
 *****************************************************************************/

#define CFndCm_AddRef Common_AddRef
#define CFndCm_Release Common_Release

/*****************************************************************************
 *
 *	CFndCm_Finalize (from Common)
 *
 *	Release the resources of an CFndCm.
 *
 *****************************************************************************/

void EXTERNAL
CFndCm_Finalize(PV pv)
{
    PFCM this = pv;

    EnterProc(CFndCm_Finalize, (_ "p", pv));

    ExitProc();
}


/*****************************************************************************
 *
 *	CFndCm_QueryContextMenu (From IContextMenu)
 *
 *	Given an existing context menu hmenu, insert new context menu
 *	items at location imi (imi = index to menu imi), returning the
 *	number of menu items added.
 *
 *	Our job is to add the "Find... People" menu option.
 *
 *	hmenu     - destination menu
 *	imi	  - location at which menu items should be inserted
 *	idcMin	  - first available menu identifier
 *	idcMax    - first unavailable menu identifier
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszMyself[] = TEXT(".{32714800-2E5F-11d0-8B85-00AA0044F941}");

#pragma END_CONST_DATA

STDMETHODIMP
CFndCm_QueryContextMenu(PCM pcm, HMENU hmenu, UINT imi,
			UINT idcMin, UINT idcMax, UINT uFlags)
{
    PFCM this = IToClass(CFndCm, cm, pcm);
    HRESULT hres;
    MENUITEMINFO mii;
    TCHAR tsz[256];
    SHFILEINFO sfi;
    EnterProc(CFndCm_QueryContextMenu, (_ "pu", pcm, idcMin));

    LoadString(g_hinst, IDS_ONTHEINTERNET, tsz, cA(tsz));

    SHGetFileInfo(c_tszMyself, FILE_ATTRIBUTE_DIRECTORY, &sfi, cbX(sfi),
		  SHGFI_SMALLICON |
		  SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES);

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_DATA | MIIM_ID | MIIM_TYPE;
    mii.fType = MFT_STRING;
    mii.fState = MFS_UNCHECKED;
    mii.wID = idcMin;
    mii.dwItemData = sfi.iIcon;
    mii.dwTypeData = tsz;

    InsertMenuItem(hmenu, imi, TRUE, &mii);

    hres = hresUs(1);

    ExitOleProc();
    return hres;
}

const static TCHAR lpszWABRegPathKey[] = TEXT("Software\\Microsoft\\WAB\\DLLPath");
const static TCHAR lpszWABDll[] = TEXT("Wab32.dll");

// GetWABDllPath - loads the WAB DLL path from the registry
// szPath	- ptr to buffer
// cb		- sizeof buffer
//
void GetWABDllPath(LPTSTR szPath, ULONG cb)
{
    DWORD  dwType = 0;
    ULONG  cbData = cb;
    HKEY hKey = NULL;
    if(szPath)
    {
        *szPath = '\0';
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszWABRegPathKey, 0, KEY_READ, &hKey))
            RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szPath, &cbData);
    }
    if(hKey) RegCloseKey(hKey);
	return;
}

// LoadLibrary_WABDll() - Load the WAB library based on the WAB DLL path
//
HINSTANCE LoadLibrary_WABDll()
{
    TCHAR       szWABDllPath[MAX_PATH];

    // [PaulHi]  We only need one reference count on the wab32.dll.  The wabfind.dll
    // will unload the wab32.dll when it unloads.  The wabfind.dll won't unload
    // until all CMFind threads are finished through the global g_cRef variable.
    if (g_hinstWABDLL)
        return g_hinstWABDLL;

    GetWABDllPath(szWABDllPath, sizeof(szWABDllPath));

    // if you want an IE4.0x WAB or later then you should fail here if the WAB
    // DLL path could not be retreived from the registry
    // Otherwise, if you don't care, you can just do a LoadLibrary("wab32.dll")
    return(g_hinstWABDLL = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : lpszWABDll ));
}


//
// Initialize the WAB and get an instance of IWABObject and IAddrBook
//
HRESULT InitWAB(LPWABOBJECT * lppWABObject,
				LPADRBOOK * lppAdrBook)
{
    HRESULT hr = E_FAIL;
    LPWABOPEN lpfnWABOpen = NULL; // defined in WABAPI.H
    HINSTANCE hinstWAB = NULL;
    WAB_PARAM WP = {0};

    WP.ulFlags = WAB_ENABLE_PROFILES;

    hinstWAB = LoadLibrary_WABDll();

    if(hinstWAB)
    {
        lpfnWABOpen = (LPWABOPEN) GetProcAddress(hinstWAB, "WABOpen");
        if(lpfnWABOpen)
            hr = lpfnWABOpen(lppAdrBook, lppWABObject, &WP, 0);
    }

    // Remember to release the IAddrBook and IWABObject objects retrieved above

    return hr;
}


/*
-
-   WABThreadProc
*
*   Since the WAB Find thing is a dialog, it is blocking Explorer's thread
*   and user's can't access the Start menu anymore .. so we put the dialog
*   on a seperate thread
*
*/
DWORD WINAPI WABThreadProc( LPVOID lpParam )
{
    HRESULT hres;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;

    if(!HR_FAILED(hres = InitWAB(&lpWABObject,&lpAdrBook)))
    {
        hres = lpWABObject->lpVtbl->Find(lpWABObject,lpAdrBook,NULL);

        // Release the WAB and AB objects
        lpAdrBook->lpVtbl->Release(lpAdrBook);
        lpWABObject->lpVtbl->Release(lpWABObject);
    }

    // Our work is done, wabfind.dll can safely go away
    InterlockedDecrement((LPLONG)&g_cRef);

    return 0;
}
				
/*****************************************************************************
 *
 *	_CFndCm_InvokeFind
 *
 *****************************************************************************/

STDMETHODIMP
_CFndCm_InvokeFind(void)
{

    HANDLE hThread = NULL;
    DWORD dwThreadID = 0;

    // Increment the refcount so that when the Shell continues (the Invoke returns)
    // wabfind.dll doesn't unload when the Shell releases the FindCM
    InterlockedIncrement((LPLONG)&g_cRef);

    hThread = CreateThread( NULL,           // no security attributes
                            0,              // use default stack size
                            WABThreadProc,  // thread function
                            (LPVOID) NULL,  // argument to thread function
                            0,              // use default creation flags
                            &dwThreadID);   // returns the thread identifier

    CloseHandle(hThread);
    return S_OK;
}

/*****************************************************************************
 *
 *	CFndCm_InvokeCommand (from IContextMenu)
 *
 *	We have only one command, called "find".
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszFind[] = TEXT("find");

#pragma END_CONST_DATA

STDMETHODIMP
CFndCm_InvokeCommand(PCM pcm, PICI pici)
{
    PFCM this = IToClass(CFndCm, cm, pcm);
    HRESULT hres;
    EnterProc(CFndCm_InvokeCommand,
	    (_ HIWORD(pici->lpVerb) ? "pA" : "pu", pcm, pici->lpVerb));

    if (pici->cbSize >= sizeof(*pici)) {
	if (
#ifdef	SHELL32_IS_BUG_FREE //;Internal
	(HIWORD(pici->lpVerb) && lstrcmpi(c_tszFind, pici->lpVerb) == 0) || //;Internal
	     pici->lpVerb == 0 //;Internal
#else //;Internal
	fLimpFF(HIWORD(pici->lpVerb), lstrcmpi(c_tszFind, pici->lpVerb) == 0)
#endif //;Internal
	    ) {
	    hres = _CFndCm_InvokeFind();
	} else {
	    hres = E_INVALIDARG;
	}
    } else {
	hres = E_INVALIDARG;
    }
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CFndCm_GetCommandString (from IContextMenu)
 *
 *	Somebody wants to convert a command id into a string of some sort.
 *
 *****************************************************************************/

STDMETHODIMP
CFndCm_GetCommandString(PCM pcm, UINT_PTR idCmd, UINT uFlags, UINT *pwRsv,
			LPSTR pszName, UINT cchMax)
{
    PFCM this = IToClass(CFndCm, cm, pcm);
    HRESULT hres;
    EnterProc(CFndCm_GetCommandString, (_ "uu", idCmd, uFlags));

    if (idCmd == 0) {
	switch (uFlags) {
	case GCS_HELPTEXT:
	    if (cchMax) {
		pszName[0] = '\0';
		if (LoadString(g_hinst, IDS_FINDHELP, pszName, cchMax)) {
		    hres = NOERROR;
		} else {
		    hres = E_INVALIDARG;
		}
	    } else {
		hres = E_INVALIDARG;
	    }
	    break;

	case GCS_VALIDATE:
	    hres = NOERROR;
	    break;

	case GCS_VERB:
	    lstrcpyn(pszName, c_tszFind, cchMax);
	    hres = NOERROR;
	    break;

	default:
	    hres = E_NOTIMPL;
	    break;
	}
    } else {
	hres = E_INVALIDARG;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CFndCm_SXI_Initialize (from IShellExtension)
 *
 *****************************************************************************/

STDMETHODIMP
CFndCm_SXI_Initialize(PSXI psxi, PCIDL pidlFolder, PDTO pdto, HKEY hk)
{
    PFCM this = IToClass(CFndCm, sxi, psxi);
    HRESULT hres;
    EnterProc(CFndCm_SXI_Initialize, (_ ""));

    hres = S_OK;
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CFndCm_New (from IClassFactory)
 *
 *	Note that we release the pfcm that Common_New created, because we
 *	are done with it.  The real refcount is handled by the
 *	CFndCm_QueryInterface.
 *
 *****************************************************************************/

STDMETHODIMP
CFndCm_New(RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(CFndCm_New, (_ "G", riid));

    *ppvObj = 0;
    hres = Common_New(CFndCm, ppvObj);
    if (SUCCEEDED(hres)) {
	PFCM pfcm = *ppvObj;
	pfcm->sxi.lpVtbl = Secondary_Vtbl(CFndCm, IShellExtInit);
	hres = CFndCm_QueryInterface(&pfcm->cm, riid, ppvObj);
	Common_Release(pfcm);
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	The long-awaited vtbls
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

Primary_Interface_Begin(CFndCm, IContextMenu)
	CFndCm_QueryContextMenu,
	CFndCm_InvokeCommand,
	CFndCm_GetCommandString,
Primary_Interface_End(CFndCm, IContextMenu)

Secondary_Interface_Begin(CFndCm, IShellExtInit, sxi)
 	CFndCm_SXI_Initialize,
Secondary_Interface_End(CFndCm, IShellExtInit, sxi)

#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabfind\fnd.c ===
/*****************************************************************************
 *
 *	fnd.c - Find ... On the Internet
 *
 *****************************************************************************/

#include "fnd.h"
#include <advpub.h>
#include <shlwapi.h>

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDll

/*****************************************************************************
 *
 *	DllGetClassObject
 *
 *	OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *****************************************************************************/

STDAPI
DllGetClassObject(REFCLSID rclsid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(DllGetClassObject, (_ "G", rclsid));
    if (IsEqualIID(rclsid, &CLSID_Fnd)) {
	hres = CFndFactory_New(riid, ppvObj);
    } else {
	*ppvObj = 0;
	hres = CLASS_E_CLASSNOTAVAILABLE;
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	DllCanUnloadNow
 *
 *	OLE entry point.  Fail iff there are outstanding refs.
 *
;begin_internal
 *	There is an unavoidable race condition between DllCanUnloadNow
 *	and the creation of a new reference:  Between the time we
 *	return from DllCanUnloadNow() and the caller inspects the value,
 *	another thread in the same process may decide to call
 *	DllGetClassObject, thus suddenly creating an object in this DLL
 *	when there previously was none.
 *
 *	It is the caller's responsibility to prepare for this possibility;
 *	there is nothing we can do about it.
;end_internal
 *
 *****************************************************************************/

STDMETHODIMP
DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

extern void GetWABDllPath(LPTSTR szPath, ULONG cb);

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCTSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);

static const TCHAR c_szShlwapiDll[] = TEXT("shlwapi.dll");
static const char c_szDllGetVersion[] = "DllGetVersion";
static const TCHAR c_szWABResourceDLL[] = TEXT("wab32res.dll");
static const TCHAR c_szWABDLL[] = TEXT("wab32.dll");

HINSTANCE LoadWABResourceDLL(HINSTANCE hInstWAB32)
{
    TCHAR szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
#ifdef UNICODE
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)378);
#else
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)377);
#endif // UNICODE
                    if (pfn != NULL)
                        hInst = pfn(c_szWABResourceDLL, hInstWAB32, 0);
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if (NULL == hInst)
    {
        GetWABDllPath(szPath, sizeof(szPath));
        iEnd = lstrlen(szPath);
        if (iEnd > 0)
        {
            iEnd = iEnd - lstrlen(c_szWABDLL);
            lstrcpyn(&szPath[iEnd], c_szWABResourceDLL, sizeof(szPath)/sizeof(TCHAR)-iEnd);
            hInst = LoadLibrary(szPath);
        }
    }

    return(hInst);
}

/*****************************************************************************
 *
 *	Entry32
 *
 *	DLL entry point.
 *
 *****************************************************************************/

BOOL APIENTRY
Entry32(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) 
    {
    case DLL_PROCESS_ATTACH:
        g_hinstApp = hinst;
    	g_hinst = LoadWABResourceDLL(hinst);
	    DisableThreadLibraryCalls(hinst);
        break;

    case DLL_PROCESS_DETACH:
        if (g_hinst)
        {
            FreeLibrary(g_hinst);
            g_hinst = 0;
        }
        if (g_hinstWABDLL)
        {
            FreeLibrary(g_hinstWABDLL);
            g_hinstWABDLL = 0;
        }
        break;
    }
    return 1;
}

/*****************************************************************************
 *
 *	The long-awaited CLSID
 *
 *****************************************************************************/

#include <initguid.h>

// {37865980-75d1-11cf-bfc7-444553540000}
//DEFINE_GUID(CLSID_Fnd, 0x37865980, 0x75d1, 0x11cf,
//		       0xbf,0xc7,0x44,0x45,0x53,0x54,0,0);
// {32714800-2E5F-11d0-8B85-00AA0044F941}
DEFINE_GUID(CLSID_Fnd, 
0x32714800, 0x2e5f, 0x11d0, 0x8b, 0x85, 0x0, 0xaa, 0x0, 0x44, 0xf9, 0x41);

const static char c_szReg[]         = "Reg";
const static char c_szUnReg[]       = "UnReg";
const static char c_szAdvPackDll[]  = "ADVPACK.DLL";

// Selfreg.inx strings
const static char c_szWABPEOPLE[]   = "WAB_PEOPLE";
const static char c_szWABFIND[]     = "WABFIND";

#define CCHMAX_RES 255

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT     hr;
    HINSTANCE   hAdvPack;
    REGINSTALL  pfnri;
    char        szWabfindDll[MAX_PATH];
    char        szMenuText[CCHMAX_RES];
    char        szLocMenuText[CCHMAX_RES];
    STRENTRY    seReg[3];
    STRTABLE    stReg;

    hr = E_FAIL;

    hAdvPack = LoadLibraryA(c_szAdvPackDll);
    if (hAdvPack != NULL)
        {
        // Get Proc Address for registration util
        pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
        if (pfnri != NULL)
            {
            UINT ids;

            // Figure out the OS we are running on for correct menu text (&People or For &People)
            OSVERSIONINFO verinfo;
            verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            if (GetVersionEx(&verinfo) && 
                (VER_PLATFORM_WIN32_NT == verinfo.dwPlatformId) && (5 <= verinfo.dwMajorVersion))
                // NT5+
                ids = IDS_FORPEOPLE;
            else
                // Something else
                ids = IDS_PEOPLE;
        
            LoadString(g_hinst, ids, szMenuText, CCHMAX_RES);


            seReg[0].pszName  = (LPSTR)c_szWABPEOPLE;
            seReg[0].pszValue = (LPSTR)szMenuText;
            
            // Borrow szWabfindDll to hold the resource DLL name
            GetModuleFileName(g_hinst, szWabfindDll, ARRAYSIZE(szWabfindDll));
            seReg[1].pszName = "LOC_WAB_PEOPLE";
            wnsprintf(szLocMenuText, ARRAYSIZE(szLocMenuText), "@%s,-%d", szWabfindDll, ids);
            seReg[1].pszValue = szLocMenuText;

            GetModuleFileName(g_hinstApp, szWabfindDll, ARRAYSIZE(szWabfindDll));
            seReg[2].pszName  = (LPSTR)c_szWABFIND;
            seReg[2].pszValue = szWabfindDll;
            
            stReg.cEntries = 3;
            stReg.pse = seReg;

            // Call the self-reg routine
            hr = pfnri(g_hinstApp, szSection, &stReg);
            }

        FreeLibrary(hAdvPack);
        }

    return(hr);
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(c_szReg);

    return(hr);
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(c_szUnReg);

    return(hr);
}

#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabexe\wabexe.c ===
/*-----------------------------------------
//
//   WABExe.C -- Enables viewing the WAB modeless UI
//
//
-------------------------------------------*/

#include <windows.h>
#include <wab.h>
#include <wabguid.h>
#include "..\wab32res\resrc2.h"
#include <advpub.h>
#include <shlwapi.h>
#include "wabexe.h"


#define WinMainT WinMain
LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;
LRESULT CALLBACK WndProcW (HWND, UINT, WPARAM, LPARAM) ;

#define MAX_INPUT_STRING    200

// #define LDAP_AUTH_SICILY    (0x86L | 0x0200)

char szAppName [] = "Address Book Viewer" ;
const LPTSTR szWABFilter = TEXT("*.wab");
const UCHAR szEmpty[] = "";

// Command Line Parameters
static const TCHAR szParamOpen[]  =           "/Open";
static const TCHAR szParamNew[]   =           "/New";
static const TCHAR szParamShowExisting[] =    "/ShowExisting";
static const TCHAR szParamFind[]  =           "/Find";
static const TCHAR szParamVCard[] =           "/VCard";
static const TCHAR szParamLDAPUrl[] =         "/LDAP:";
static const TCHAR szParamCert[] =            "/Certificate";
static const TCHAR szParamFirstRun[] =        "/FirstRun";
static const TCHAR szAllProfiles[] =          "/All";

static const TCHAR szWabKey[]="Software\\Microsoft\\Wab";
static const TCHAR szVCardNoCheckKey[]="NoVCardCheck";

static const TCHAR lpszSharedKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SharedDlls");

HINSTANCE hInstWABDll = NULL;
HINSTANCE hInst = NULL;         // this module's resource instance handle
HINSTANCE hInstApp = NULL;         // this module's instance handle

HINSTANCE LoadLibrary_WABDll();

LPWABOPEN lpfnWABOpen = NULL;
const static TCHAR szWABOpen[] = TEXT("WABOpen");

static const GUID MPSWab_GUID = // keep this in sync with the one in wabapi\mpswab.h
{ 0xc1843281, 0x585, 0x11d0, { 0xb2, 0x90, 0x0, 0xaa, 0x0, 0x3c, 0xf6, 0x76 } };

BOOL bGetFileNameFromDlg(HWND hwnd,
                  HINSTANCE hInstance,
                  LPTSTR lpszDirectory,
                  int szTitleID,
                  DWORD dwFlags,
                  LPTSTR szFileName);

#define WAB_VCARDFILE   0x00000001
#define WAB_FINDSESSION 0x00000010
#define WAB_LDAPURL     0x00000100
#define WAB_CERTFILE    0x00001000
#define WAB_ALLPROFILES 0x00010000

BOOL bGetFileNameFromCmdLine(HWND hwnd,
                             HINSTANCE hInstance,
                             LPTSTR lpszCmdLine,
                             LPTSTR szWABTitle,
                             ULONG * ulFlag,
                             LPTSTR szFileName);

void GetWABDefaultAddressBookName(LPTSTR szDefaultFile);

static const char c_szReg[] = "Reg";
static const char c_szUnReg[] = "UnReg";
static const char c_szAdvPackDll[] = "ADVPACK.DLL";


//$$//////////////////////////////////////////////////////////////////////
//
//  LoadAllocString - Loads a string resource and allocates enough
//                    memory to hold it.
//
//  StringID - String identifier to load
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR LoadAllocString(int StringID, HINSTANCE hInstance) {
    ULONG ulSize = 0;
    LPTSTR lpBuffer = NULL;
    TCHAR szBuffer[261];    // Big enough?  Strings better be smaller than 260!

    ulSize = LoadString(hInstance, StringID, szBuffer, sizeof(szBuffer));

    if (ulSize && (lpBuffer = LocalAlloc(LPTR, ulSize + 1))) {
        lstrcpy(lpBuffer, szBuffer);
    }

    return(lpBuffer);
}

//$$//////////////////////////////////////////////////////////////////////
//
//  FormatAllocFilter - Loads a file filter name string resource and
//                      formats it with the file extension filter
//
//  StringID - String identifier to load
//  szFilter - file name filter, ie, "*.vcf"
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR FormatAllocFilter(int StringID, const LPTSTR lpFilter, HINSTANCE hInstance) {
    LPTSTR lpFileType;
    LPTSTR lpTemp;
    LPTSTR lpBuffer = NULL;
    ULONG cbFileType, cbFilter;

    cbFilter = lstrlen(lpFilter);
    if (lpFileType = LoadAllocString(StringID,hInstance)) {
        if (lpBuffer = LocalAlloc(LPTR, (cbFileType = lstrlen(lpFileType)) + 1 + lstrlen(lpFilter) + 2)) {
            lpTemp = lpBuffer;
            lstrcpy(lpTemp, lpFileType);
            lpTemp += cbFileType;
            lpTemp++;   // leave null there
            lstrcpy(lpTemp, lpFilter);
            lpTemp += cbFilter;
            lpTemp++;   // leave null there
            *lpTemp = '\0';
        }

        LocalFree(lpFileType);
    }

    return(lpBuffer);
}


//$$//////////////////////////////////////////////////////////////////////
//
// GetWABExePath - queries the reg for the full path of the wab exe
//
// sz is a preallocated buffer
//
//////////////////////////////////////////////////////////////////////////
TCHAR lpszWABExeRegPath[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\Wab.exe");

void GetWABExePath(LPTSTR sz, ULONG cbsz)
{
    DWORD dwType = 0;
    DWORD dwSize = cbsz;
    *sz = '\0';
    RegQueryValue(  HKEY_LOCAL_MACHINE,
                    lpszWABExeRegPath,
                    sz, &dwSize);

    if(!lstrlen(sz))
        lstrcpy(sz, TEXT("WAB.Exe"));
}

static const TCHAR szWabAutoFileKey[]=".wab";
static const TCHAR szWabAutoFile[]="wab_auto_file";

static const TCHAR szWabAutoFileNameKey[]="wab_auto_file";
static const TCHAR szWabAutoFileName[]="WAB File";

static const TCHAR szWabCommandOpenKey[]="wab_auto_file\\shell\\open\\command";
static const TCHAR szWabCommandOpen[]="\"%s\" %%1";

//$$//////////////////////////////////////////////////////////////////////
//
// CheckWABDefaultHandler
//
// Checks if WAB.exe is the default handler for the WAB in the registry.
// If not, sets wab.exe as the default handler
//
//////////////////////////////////////////////////////////////////////////
void CheckWABDefaultHandler()
{
    HKEY hKey = NULL;

    TCHAR sz[MAX_PATH];
    TCHAR szWABExe[MAX_PATH];


    DWORD dwDisposition = 0;

    // Check to see if something is registered or not ...

    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                        szWabAutoFileKey,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        goto out;
    }

    if (dwDisposition == REG_CREATED_NEW_KEY)
    {
        // New key ... need to give it a value .. this will be the
        // default value
        //
        DWORD dwLenName = lstrlen(szWabAutoFile);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szWabAutoFile,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        // Create the other keys also

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szWabAutoFileNameKey,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        dwLenName = lstrlen(szWabAutoFileName);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szWabAutoFileName,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szWabCommandOpenKey,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        GetWABExePath(szWABExe, sizeof(szWABExe));
        wsprintf(sz, szWabCommandOpen, szWABExe);


        dwLenName = lstrlen(sz);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) sz,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

    }

out:

    if(hKey)
        RegCloseKey(hKey);

    return;
}


enum _RetVal
{
    MAKE_DEFAULT=0,
    DONT_MAKE_DEFAULT
};

enum _DoVCardCheck
{
    NO_VCARD_CHECK=1,
    DO_VCARD_CHECK
};


//$$//////////////////////////////////////////////////////////////////////
//
// fnAskVCardProc
//
//
//////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK fnAskVCardProc(HWND    hDlg, UINT    message, WPARAM    wParam, LPARAM    lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        break;

   case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CHECK_ALWAYS:
			{
				// Set a registry setting depending on the check mark value
				
				UINT nIsChecked = IsDlgButtonChecked(hDlg, IDC_CHECK_ALWAYS);
				DWORD dwCheck = (nIsChecked == BST_CHECKED) ? NO_VCARD_CHECK : DO_VCARD_CHECK;

				{
					// Set this value in the registry
					
					HKEY hKey = NULL;
					DWORD dwDisposition;

					// Open the WAB Key
					if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
														szWabKey,
														0,      //reserved
														NULL,
														REG_OPTION_NON_VOLATILE,
														KEY_ALL_ACCESS,
														NULL,
														&hKey,
														&dwDisposition))
					{
						//if this key exists, get the WAB DoVCardCheck value
						DWORD dwLenName = sizeof(dwCheck);
						DWORD dwType = REG_DWORD;
						RegSetValueEx(	hKey,
										szVCardNoCheckKey,
										0,
										dwType,      //reserved
										(LPBYTE) &dwCheck,
										dwLenName);
					}

					if(hKey)
						RegCloseKey(hKey);

				}
			}
			break;

        case IDOK:
            EndDialog(hDlg, MAKE_DEFAULT);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DONT_MAKE_DEFAULT);
            break;

        }
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;

}

static const TCHAR szVCardAutoFileKey[]=".vcf";
static const TCHAR szVCardAutoFile[]="vcard_wab_auto_file";

static const TCHAR szVCardContentTypeValue[]="Content Type";
static const TCHAR szVCardContentType[]="text/x-vcard";

static const TCHAR szVCardMimeDatabase[]="MIME\\Database\\Content Type\\text/x-vcard";
static const TCHAR szVCardExtension[]="Extension";

static const TCHAR szVCardAutoFileNameKey[]="vcard_wab_auto_file";
static const TCHAR szVCardAutoFileName[]="vCard File";

static const TCHAR szVCardCommandOpenKey[]="vcard_wab_auto_file\\shell\\open\\command";
static const TCHAR szVCardCommandOpen[]="\"%s\" /vcard %%1";

static const TCHAR szVCardDefaultIconKey[]="vcard_wab_auto_file\\DefaultIcon";
static const TCHAR szVCardDefaultIcon[]="\"%s\",1";

//$$//////////////////////////////////////////////////////////////////////
//
// CheckVCardDefaultHandler
//
// Checks if WAB.exe is the default handler for the VCard in the registry.
// If not, sets wab.exe as the default handler
//
//////////////////////////////////////////////////////////////////////////
void CheckVCardDefaultHandler(HWND hWnd,
                              HINSTANCE hInstance)
{

    TCHAR sz[MAX_PATH];
    TCHAR szWABExe[MAX_PATH];

    HKEY hKey = NULL;
    HKEY hVCardKey = NULL;

    DWORD dwDisposition = 0;
    DWORD dwType = 0;
    DWORD dwLenName = 0;


    //First check if they want us to check at all ..
    // Open key
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                        szWabKey,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        // Found the key
        if (dwDisposition == REG_OPENED_EXISTING_KEY)
        {
            //if this key exists, get the WAB DoVCardCheck value
            DWORD dwCheck = 0;
            dwLenName = sizeof(dwCheck);
            if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                szVCardNoCheckKey,
                                                NULL,
                                                &dwType,      //reserved
                                                (LPBYTE) &dwCheck,
                                                &dwLenName))
            {
                // success .. what did we get back
                if (dwCheck == NO_VCARD_CHECK) // Dont Check
                    goto out;
            }
            // else no success - so should do the check
        }
        // else no success, do the check
    }
    // else no success, do the check


    if(hKey)
        RegCloseKey(hKey);


    // Check to see if something is registered as a vCard handler or not ...

    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                        szVCardAutoFileKey,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        goto out;
    }

    if (dwDisposition == REG_OPENED_EXISTING_KEY)
    {
        // This key exists .. check who is registered to handle vCards ..
        TCHAR szHandlerNameKey[MAX_PATH];
        lstrcpy(szHandlerNameKey, szEmpty);
        dwLenName = sizeof(szHandlerNameKey);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                            NULL,
                                            NULL,
                                            &dwType,      //reserved
                                            szHandlerNameKey,
                                            &dwLenName))
        {
            // We got the value for this .. is it us ?

            if(!lstrcmpi(szVCardAutoFile, szHandlerNameKey))
            {
                //its us, dont do anything
                goto out;
            }
            else if (szHandlerNameKey && lstrlen(szHandlerNameKey) != 0)
            {
                // Its not us, pop up a dialog asking if they want us
                int nRetVal = (int) DialogBox(
                                hInstance,
                                MAKEINTRESOURCE(IDD_DIALOG_DEFAULT_VCARD_VIEWER),
                                hWnd,
                                fnAskVCardProc);

                if (nRetVal == DONT_MAKE_DEFAULT)
                    goto out;

            } // else couldnt open.. go ahead and make us default
        }  // else couldnt open.. go ahead and make us default
    }


    // If we are here then either dwDisposition == REG_CREATED_NEW_KEY or
    // there is some problem that couldnt let us read the above so set us as
    // the default ...

    {
        // New key ... need to give it a value .. this will be the
        // default value
        //
        DWORD dwLenName = lstrlen(szVCardAutoFile);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szVCardAutoFile,
                                            dwLenName))
        {
            goto out;
        }

        dwLenName = lstrlen(szVCardContentType);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            szVCardContentTypeValue,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szVCardContentType,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        // Create the other keys also

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szVCardAutoFileNameKey,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        dwLenName = lstrlen(szVCardAutoFileName);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szVCardAutoFileName,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szVCardCommandOpenKey,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        GetWABExePath(szWABExe, sizeof(szWABExe));
        wsprintf(sz, szVCardCommandOpen, szWABExe);

        dwLenName = lstrlen(sz);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) sz,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szVCardDefaultIconKey,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        wsprintf(sz, szVCardDefaultIcon, szWABExe);

        dwLenName = lstrlen(sz);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) sz,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;


        // Set HKCR\MIME\Database\Content Type\text/x-vCard: Extension=.vcf

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szVCardMimeDatabase,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        dwLenName = lstrlen(szVCardAutoFileKey);
        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            szVCardExtension,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szVCardAutoFileKey,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

    }

out:

    if(hVCardKey)
        RegCloseKey(hVCardKey);
    if(hKey)
        RegCloseKey(hKey);

    return;
}


//$$//////////////////////////////////////////////////////////////////////
//
// Callback dismiss function for IADRBOOK->Address
//
//////////////////////////////////////////////////////////////////////////
void STDMETHODCALLTYPE WABDismissFunction(ULONG_PTR ulUIParam, LPVOID lpvContext)
{
    LPDWORD lpdw = (LPDWORD) lpvContext;
    PostQuitMessage(0);
    return;
}


void GetWABDllPath(LPTSTR szPath, ULONG cb);
static const LPTSTR szWABResourceDLL = TEXT("wab32res.dll");
static const LPTSTR szWABDLL = TEXT("wab32.dll");
static const LPTSTR c_szShlwapiDll = TEXT("shlwapi.dll");
static const LPTSTR c_szDllGetVersion = TEXT("DllGetVersion");
typedef HRESULT (CALLBACK * SHDLLGETVERSIONPROC)(DLLVERSIONINFO *);
typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCTSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
/*
-   LoadWABResourceDLL
-
*   WAB resources are split up into a seperate dll so we want to load them from there
*   The Resource DLL location should be the same as the wab32.dll location
*   So we will try to make sure we don't fail here - 
*   1. Get current WAB32.dll path and look in that directory
*   2. Just loadlibrary(wab32.dll)
*
*   The MLLoadLibrary function should be used if available (IE5 only thing)  since
*   it will load the correct language pack
*
*/
HINSTANCE LoadWABResourceDLL(HINSTANCE hInstWAB32)
{
    HINSTANCE hinst = NULL; 
    PFNMLLOADLIBARY pfnLoadLibrary = NULL;
    HINSTANCE hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    SHDLLGETVERSIONPROC pfnVersion = NULL;
    DLLVERSIONINFO info = {0};

    // [PaulHi] 1/26/99  Raid 67380
    // Make sure we have the correct version of SHLWAPI.DLL before we use it
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (SHDLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
//                    pfnLoadLibrary = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)378); // UNICODE version
                    pfnLoadLibrary = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)377); //ANSI version
                }
            }
        }
    }

    hinst = pfnLoadLibrary ? 
             pfnLoadLibrary(szWABResourceDLL, hInstWAB32, 0) :
             LoadLibrary(szWABResourceDLL);
 
    if(!hinst)
    {
        // maybe not on the path so look in the wab32.dll directory
        TCHAR szResDLL[MAX_PATH];
        *szResDLL = '\0';
        GetWABDllPath(szResDLL, sizeof(szResDLL));
        if(lstrlen(szResDLL))
        {
            // the returned filename will always end in wab32.dll so we can nix that many characters off
            // and replace with wab32res.dll
            szResDLL[lstrlen(szResDLL) - lstrlen(szWABDLL)] = '\0';
            lstrcat(szResDLL, szWABResourceDLL);

            hinst = pfnLoadLibrary ?
                     pfnLoadLibrary(szResDLL, hInstWAB32, 0) :
                     LoadLibrary(szResDLL);
        }
    }
    
    if(hinstShlwapi)
        FreeLibrary(hinstShlwapi);

    return hinst;
}


/*
-   Strip quotes from File Names
-
*   szFileName needs to be a buffer
*/
void StripQuotes(LPTSTR szFileName)
{
    // now let's get rid of " and ' in the filename string
    if( szFileName && lstrlen(szFileName))
    {
        TCHAR szCopy[MAX_PATH];
        LPTSTR lpTemp, lpTempBegin;
        int len = lstrlen(szFileName);
        lpTempBegin = szFileName;
        lstrcpy(szCopy, szFileName);
        for( lpTemp = szCopy; lpTemp < szCopy+len; lpTemp++)
        {
            if( *lpTemp != '"' )//&& *lpTemp != '\'' )
                *(lpTempBegin++) = *lpTemp;
        }
        *(lpTempBegin) = '\0';
    }
}

/*
-
-   CheckifRunningOnWinNT
*
*   Checks the OS we are running on and returns TRUE for WinNT
*   False for Win9x
*/
BOOL bCheckifRunningOnWinNT()
{
    OSVERSIONINFO osvi = {0};
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    return (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);
}


///////////////////////////////////////////////////////////////////////////////
//  ConvertAtoW
//
//  Helper function
///////////////////////////////////////////////////////////////////////////////
LPWSTR ConvertAtoW(LPCSTR lpszA)
{
    int cch;
    LPWSTR lpW = NULL;
    ULONG   ulSize;

    if ( !lpszA)
        goto ret;
    
    cch = (lstrlenA( lpszA ) + 1);
    ulSize = cch*sizeof(WCHAR);
    
    if(lpW = LocalAlloc(LMEM_ZEROINIT, ulSize))
    {
        MultiByteToWideChar( GetACP(), 0, lpszA, -1, lpW, cch );
    }
ret:
    return lpW;
}


//$$//////////////////////////////////////////////////////////////////////
//
// WinMain
//
//////////////////////////////////////////////////////////////////////////
int WINAPI WinMain( HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR lpszCmdLine,
                    int nCmdShow)
{
    HWND     hwnd = NULL;
    MSG      msg ;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    HRESULT hResult = hrSuccess;
    ADRPARM AdrParms = {0};
    WAB_PARAM WP = {0};
    LPTSTR szFileName = NULL;
    int nLen = MAX_PATH+1;
    //TCHAR szFileName[MAX_PATH+1];
    //TCHAR szDefaultFile[MAX_PATH+1];
    LPTSTR lpszTitle = NULL;
    ULONG ulFlag = 0;
    LPTSTR lpszVCardFileName = NULL;
    LPTSTR lpszCertFileName = NULL;
    LPTSTR lpszLDAPUrl = NULL;

    // "Windows Address Book" - used for msgboxes when we dont have
    // a file name
    TCHAR szWABTitle[MAX_PATH];

    // Contains the opened file name in the title
    // This makes it easier to search for a default address book
    // even if mutiple other ones are open
    TCHAR szWABTitleWithFileName[MAX_PATH];


    // Check which platform we are running on.
    BOOL bRunningOnNT = bCheckifRunningOnWinNT();

    hInstApp = hInstance;
    hInst = LoadWABResourceDLL(hInstance);

    if(lpszCmdLine && lstrlen(lpszCmdLine) > nLen)
        nLen = lstrlen(lpszCmdLine)+1;

    szFileName = LocalAlloc(LMEM_ZEROINIT, nLen);
    if(!szFileName)
        goto out;


    // if this is the firstrun flag, all we need to do is call WABOpen and then exit
    //
    if(!lstrcmpi(lpszCmdLine,szParamFirstRun))
    {
        const LPTSTR lpszNewWABKey = TEXT("Software\\Microsoft\\WAB\\WAB4");
        const LPTSTR lpszFirstRunValue = TEXT("FirstRun");
        HKEY hKey = NULL;
        DWORD dwType = 0, dwValue = 0, dwSize = sizeof(DWORD);
        // First check if this is a first run - if its not a first run then we can just skip out
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpszNewWABKey, 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS == RegQueryValueEx( hKey, lpszFirstRunValue, NULL, &dwType, (LPBYTE) &dwValue, &dwSize))
            {
                if(hKey)
                    RegCloseKey(hKey);
                goto out;
            }
            else
                if(hKey)
                    RegCloseKey(hKey);
        }
        // Either the WAB4 key did not exist, or the first run value was not found.
        // In either case, fix this
        hInstWABDll = LoadLibrary_WABDll();
        if(hInstWABDll)
            lpfnWABOpen = (LPWABOPEN) GetProcAddress(hInstWABDll, szWABOpen);
        if(lpfnWABOpen)
            lpfnWABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        goto out;
    }

    CheckWABDefaultHandler();
    CheckVCardDefaultHandler(NULL, hInst);

    szFileName[0]='\0';

    // We will show a file name in the title only if a file name is 
    // explicitly specified .. if the file name is not explicitly specified,
    // we will revert to a generic "Address Book" title

    LoadString(hInst, idsWABTitle, szWABTitle, sizeof(szWABTitle));
    LoadString(hInst, idsWABTitleWithFileName, szWABTitleWithFileName, sizeof(szWABTitleWithFileName));


    // Get the default windows address book from the registry
    //szDefaultFile[0]='\0';
    //GetWABDefaultAddressBookName(szDefaultFile);


    if(!lstrcmpi(lpszCmdLine,szParamShowExisting))
    {
        //perhaps this already exists - find the window and set focus to it

        // /ShowExisting flag always opens the default wab file
        // The title of this wab.exe window will have the default file
        // name in the title.
/*
        LPTSTR lpsz = szDefaultFile;

        FormatMessage(  FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szWABTitleWithFileName,
                        0,
                        0,
                        (LPTSTR) &lpszTitle,
                        0,
                        (va_list *)&lpsz);
*/
        // Create the Expected Title from the default
        hwnd = FindWindow("WABBrowseView", NULL);//szWABTitle); //lpszTitle);
        if(hwnd)
        {
            ULONG ulFlags = SW_SHOWNORMAL;
            ulFlags |= IsZoomed(hwnd) ? SW_SHOWMAXIMIZED : SW_RESTORE;

            //SetForegroundWindow(hwnd);
            ShowWindow(hwnd, ulFlags);
            SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
            SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
            SetActiveWindow(hwnd);
            SetFocus(hwnd);

            goto out;
        }
    }

    if (bRunningOnNT)
    {
        LPWSTR      lpwszAppName = ConvertAtoW(szAppName);
        WNDCLASSW   wndclassW;

        // [PaulHi] 4/29/99  Raid 75578
        // On NT we need to create a Unicode main window so the child windows
        // can display Unicode characters.
        wndclassW.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclassW.lpfnWndProc   = WndProcW ;
        wndclassW.cbClsExtra    = 0 ;
        wndclassW.cbWndExtra    = 0 ;
        wndclassW.hInstance     = hInstApp;
        wndclassW.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICON1)) ;
        wndclassW.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wndclassW.hbrBackground = GetStockObject(WHITE_BRUSH) ;
        wndclassW.lpszMenuName  = lpwszAppName ;
        wndclassW.lpszClassName = lpwszAppName ;

        RegisterClassW(&wndclassW);

        hwnd = CreateWindowW (lpwszAppName, lpwszAppName,
                              WS_OVERLAPPEDWINDOW,
                              0,        // CW_USEDEFAULT,
                              0,        // CW_USEDEFAULT,
                              300,      // CW_USEDEFAULT,
                              200,      // CW_USEDEFAULT,
                              NULL,
                              NULL,
                              hInstApp,
                              NULL);

        LocalFree(lpwszAppName);
    }
    else
    {
        WNDCLASS    wndclass;

        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.lpfnWndProc   = WndProc ;
        wndclass.cbClsExtra    = 0 ;
        wndclass.cbWndExtra    = 0 ;
        wndclass.hInstance     = hInstApp;
        wndclass.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICON1)) ;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wndclass.hbrBackground = GetStockObject(WHITE_BRUSH) ;
        wndclass.lpszMenuName  = szAppName ;
        wndclass.lpszClassName = szAppName ;

        RegisterClass(&wndclass);

        hwnd = CreateWindow (szAppName, szAppName,
                              WS_OVERLAPPEDWINDOW,
                              0,        // CW_USEDEFAULT,
                              0,        // CW_USEDEFAULT,
                              300,      // CW_USEDEFAULT,
                              200,      // CW_USEDEFAULT,
                              NULL,
                              NULL,
                              hInstApp,
                              NULL);
    }

    if(!hwnd)
        goto out;
    else
        WP.hwnd = hwnd;

    if(lstrlen(lpszCmdLine))
    {
        if(!bGetFileNameFromCmdLine( hwnd,
                                     hInst,
                                     lpszCmdLine,
                                     szWABTitle,
                                     &ulFlag,
                                     szFileName))
        {
            goto out;
        }
    }

    if(ulFlag & WAB_VCARDFILE)
    {
        StripQuotes(szFileName);
        lpszVCardFileName = szFileName;
        // [PaulHi] 12/2/98  Raid #55033
        WP.ulFlags = WAB_ENABLE_PROFILES;
    }
    else if(ulFlag & WAB_LDAPURL)
    {
        lpszLDAPUrl = szFileName;
    }
    else if(ulFlag & WAB_CERTFILE)
    {
        StripQuotes(szFileName);
        lpszCertFileName = szFileName;
    }
    else if(ulFlag & WAB_ALLPROFILES)
    {
        WP.ulFlags &= ~WAB_ENABLE_PROFILES;
        ulFlag &= ~WAB_ALLPROFILES;
    }
    else if(szFileName && lstrlen(szFileName))
    {
        WP.szFileName = szFileName;
        // [PaulHi] 3/2/99  Raid 73492
        // [PaulHi] 4/22/99 Modified
        // Can't do this because identity mode will only show folders for that
        // identity, which may not be the folder in this general WAB file.
        // WP.ulFlags = WAB_ENABLE_PROFILES;   // Start with profiles on
    }
    else if(!(ulFlag & WAB_ALLPROFILES))
    {
        WP.ulFlags = WAB_ENABLE_PROFILES;
    }

    hInstWABDll = LoadLibrary_WABDll();
    if(hInstWABDll)
        lpfnWABOpen = (LPWABOPEN) GetProcAddress(hInstWABDll, szWABOpen);

    if(!lpfnWABOpen)
        goto out;

    WP.cbSize = sizeof(WAB_PARAM);
    WP.guidPSExt = MPSWab_GUID;

    hResult = lpfnWABOpen(&lpAdrBook, &lpWABObject, &WP, 0);

    if(HR_FAILED(hResult))
    {
        TCHAR szBuf[MAX_PATH];
        int id;
        switch(hResult)
        {
        case MAPI_E_NOT_ENOUGH_MEMORY:
            id = idsWABOpenErrorMemory;
            break;
        case MAPI_E_NO_ACCESS:
            id = idsWABOpenErrorLocked;
            break;
        case MAPI_E_CORRUPT_DATA:
            id = idsWABOpenErrorCorrupt;
            break;
        case MAPI_E_DISK_ERROR:
            id = idsWABOpenErrorDisk;
            break;
        case MAPI_E_INVALID_OBJECT:
            id = idsWABOpenErrorNotWAB;
            break;
        case E_FAIL:
        default:
            id = idsWABOpenError;
            break;
        }
        LoadString(hInst, id, szBuf, sizeof(szBuf));
        MessageBox(hwnd, szBuf, szWABTitle, MB_OK | MB_ICONERROR);
        goto out;
    }

    if (lpAdrBook)
    {
        if(!ulFlag)
        {
            // We are in the business of showing the address book
            LPTSTR lpsz = NULL;

            lpszTitle = NULL;
/*
            if(!lstrlen(szFileName))
                lstrcpy(szFileName, szDefaultFile);
*/
            if(lstrlen(szFileName))
            {
                lpsz = szFileName;

                FormatMessage(  FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                szWABTitleWithFileName,
                                0,
                                0,
                                (LPTSTR) &lpszTitle,
                                0,
                                (va_list *)&lpsz);
            }

            AdrParms.cDestFields = 0;
            AdrParms.ulFlags = DIALOG_SDI;
            AdrParms.lpvDismissContext = NULL;
            AdrParms.lpfnDismiss = &WABDismissFunction;
            AdrParms.lpfnABSDI = NULL;

            //if(lpszTitle)
                AdrParms.lpszCaption = lpszTitle; //szWABTitle;
            //else // its possible to not have a file name the first time we run this ..
            //    AdrParms.lpszCaption = szWABTitle;

            AdrParms.nDestFieldFocus = AdrParms.cDestFields-1;

            hResult = lpAdrBook->lpVtbl->Address(  lpAdrBook,
                                                    (ULONG_PTR *) &hwnd,
                                                    &AdrParms,
                                                    NULL);
            if(HR_FAILED(hResult))
            {
                TCHAR szBuf[MAX_PATH];
                int id;
                switch(hResult)
                {
                case MAPI_E_UNCONFIGURED: // no commctrl
                    id = idsWABAddressErrorMissing;
                    break;
                default:
                    id = idsWABAddressErrorMissing;
                    break;
                }
                LoadString(hInst, id, szBuf, sizeof(szBuf));
                MessageBox(hwnd, szBuf, szWABTitle, MB_OK | MB_ICONERROR);
                goto out;
            }

            // [PaulHi] 4/29/99  Raid 75578  Must use Unicode versions of
            // message pump APIs for NT so Unicode data can be displayed.
            if (bRunningOnNT)
            {
                while (GetMessageW(&msg, NULL, 0, 0))
                {
                    if (AdrParms.lpfnABSDI)
                    {
                        if ((*(AdrParms.lpfnABSDI))((ULONG_PTR) hwnd, (LPVOID) &msg))
                            continue;
                    }

                    TranslateMessage(&msg);
                    DispatchMessageW(&msg);
                }
            }
            else
            {
                while (GetMessage(&msg, NULL, 0, 0))
                {
                    if (AdrParms.lpfnABSDI)
                    {
                        if ((*(AdrParms.lpfnABSDI))((ULONG_PTR) hwnd, (LPVOID) &msg))
                            continue;
                    }

                    TranslateMessage (&msg) ;
                    DispatchMessage (&msg) ;
                }
            }
        }
        else if(ulFlag & WAB_FINDSESSION)
        {
            lpWABObject->lpVtbl->Find(  lpWABObject,
                                        (LPADRBOOK) lpAdrBook,
                                        NULL);//hwnd);
        }
        else if(ulFlag & WAB_LDAPURL)
        {
            BOOL bUnicode = FALSE;
            BOOL bIsNT = bCheckifRunningOnWinNT();
            LPWSTR lpUrlW = NULL;
            LPWSTR lpCmdLineW = GetCommandLineW();

            //When working with LDAP URLs on NT, we want to err on the side of safety and
            // get the LDAP URL in UNICODE format if possible ..
            if(bIsNT)
            {
                LPWSTR lp = lpCmdLineW;
                WCHAR szLDAPW[] = L"/ldap:";
                WCHAR szTemp[16];
                int nLenW = lstrlenW(szLDAPW);
                // parse the command line till we find "/ldap:" and then use the
                // remainder as the LDAP URL
                while(lp && *lp)
                {
                    CopyMemory(szTemp, lp, nLenW * sizeof(WCHAR));
                    szTemp[nLenW] = '\0';
                    if(!lstrcmpiW(szTemp, szLDAPW))
                    {
                        lp+=nLenW;
                        lpUrlW = lp;
                        break;
                    }
                    else
                        lp++;
                }
            }

            hResult = lpWABObject->lpVtbl->LDAPUrl(lpWABObject,
                                        (LPADRBOOK) lpAdrBook,
                                        hwnd,
                                        MAPI_DIALOG | (lpUrlW ? MAPI_UNICODE : 0 ),
                                        lpUrlW ? (LPSTR)lpUrlW : lpszLDAPUrl,
                                        NULL);

        }
        else if(ulFlag & WAB_VCARDFILE)
        {
            hResult = lpWABObject->lpVtbl->VCardDisplay(
                                        lpWABObject,
                                        (LPADRBOOK) lpAdrBook,
                                        NULL, //hwnd,
                                        lpszVCardFileName);
            if(HR_FAILED(hResult) && (hResult != MAPI_E_USER_CANCEL))
            {
                TCHAR szBuf[MAX_PATH];
                int id;
                switch(hResult)
                {
                default:
                    id = idsWABOpenVCardError;
                    break;
                }
                LoadString(hInst, id, szBuf, sizeof(szBuf));
                MessageBox(hwnd, szBuf, szWABTitle, MB_OK | MB_ICONERROR);
                goto out;
            }
        }
        else if(ulFlag & WAB_CERTFILE)
        {
            CertFileDisplay(NULL,   // hwnd
              lpWABObject,
              lpAdrBook,
              lpszCertFileName);
        }

    }
out:
    if(lpAdrBook)
        lpAdrBook->lpVtbl->Release(lpAdrBook);

    if (lpWABObject)
        lpWABObject->lpVtbl->Release(lpWABObject);

    if (lpszTitle)
        LocalFree(lpszTitle);

    if(hInstWABDll)
        FreeLibrary(hInstWABDll);

    if(szFileName)
        LocalFree(szFileName);

    if(hInst)
        FreeLibrary(hInst);

    return (int) msg.wParam;
}



//$$//////////////////////////////////////////////////////////////////
//
// WndProc for the hidden parent window that launches the UI
//
////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
        case WM_CREATE:
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            return(0);
        }
    return(DefWindowProc (hwnd, message, wParam, lParam));
}

//$$//////////////////////////////////////////////////////////////////
//
// WndProc for the hidden parent window that launches the UI.  Unicode version
//
////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK WndProcW (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
        case WM_CREATE:
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            return(0);
        }
    return(DefWindowProcW (hwnd, message, wParam, lParam));
}

//$$//////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////
int _stdcall WinMainCRTStartup (void)
{
    int i;
    STARTUPINFOA si;
    PTSTR pszCmdLine = GetCommandLine();

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if (*pszCmdLine == TEXT ('\"')) {
        // Scan, and skip over, subsequent characters until
        // another double-quote or a null is encountered.
        while (*++pszCmdLine && (*pszCmdLine != TEXT ('\"')));

        // If we stopped on a double-quote (usual case), skip over it.
        if (*pszCmdLine == TEXT ('\"')) {
            pszCmdLine++;
        }
    } else {
        while (*pszCmdLine > TEXT (' ')) {
            pszCmdLine++;
        }
    }

    // Skip past any white space preceeding the second token.
    while (*pszCmdLine && (*pszCmdLine <= TEXT (' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo (&si);

    i = WinMainT(GetModuleHandle (NULL), NULL, pszCmdLine,
    si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);

    return(i);
}

//$$//////////////////////////////////////////////////////////////////
//
// bGetFileNameFromDlg - opens the FIleOpen common dialog
//
////////////////////////////////////////////////////////////////////////
BOOL bGetFileNameFromDlg(HWND hwnd,
                  HINSTANCE hInstance,
                  LPTSTR lpszDirectory,
                  int szTitleID,
                  DWORD dwFlags,
                  LPTSTR szFileName)
{
    OPENFILENAME ofn;
    TCHAR szBuf[MAX_PATH];
    BOOL bRet = FALSE;
    TCHAR szFile[MAX_PATH];

    LPTSTR lpFilter = FormatAllocFilter(idsWABOpenFileFilter, szWABFilter, hInstance);

    szFile[0]='\0';
    LoadString(hInstance, szTitleID, szBuf, sizeof(szBuf));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = hInstance;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = lpszDirectory;
    ofn.lpstrTitle = szBuf;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = "wab";
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    ofn.Flags = dwFlags;

    if(GetOpenFileName(&ofn))
    {
        bRet = TRUE;
        lstrcpy(szFileName, szFile);
    }

    if(lpFilter)
        LocalFree(lpFilter);

    return bRet;
}

/***************************************************************************

    Name      : StrICmpN

    Purpose   : Compare strings, ignore case, stop at N characters

    Parameters: szString1 = first string
                szString2 = second string
                N = number of characters to compare

    Returns   : 0 if first N characters of strings are equivalent.

    Comment   :

***************************************************************************/
int StrICmpN(LPTSTR lpsz1, LPTSTR lpsz2, ULONG N) {
    int Result = 0;
    LPTSTR szString1 = NULL, lp1 = NULL;
    LPTSTR szString2 = NULL, lp2 = NULL;

    szString1 = LocalAlloc(LMEM_ZEROINIT, lstrlen(lpsz1)+1);
    if(!szString1)
        return 1;
    lp1 = szString1;

    szString2 = LocalAlloc(LMEM_ZEROINIT, lstrlen(lpsz2)+1);
    if(!szString2)
        return 1;
    lp2 = szString2;

    lstrcpy(szString1, lpsz1);
    lstrcpy(szString2, lpsz2);

    if (szString1 && szString2) {

        szString1 = CharUpper(szString1);
        szString2 = CharUpper(szString2);

        while (*szString1 && *szString2 && N)
        {
            N--;

            if (*szString1 != *szString2)
            {
                Result = 1;
                break;
            }

            szString1=CharNext(szString1);
            szString2=CharNext(szString2);
        }
    } else {
        Result = -1;    // arbitrarily non-equal result
    }

    if(lp1)
        LocalFree(lp1);
    if(lp2)
        LocalFree(lp2);

    return(Result);
}


//$$//////////////////////////////////////////////////////////////////
//
// bGetFileNameFromCmdLine - Parses command line and acts appropriately till
//      we have a valid filename, cancel or failure.
//
// Input parameters -
//          hWnd
//          hInstance
//          lpszCmdLine
//          szWabTitle (for message boxes)
//          szFileName - file name returned from command line
//
//  Command line Parameters we understand so far
//
//      (none)  -   opens default wab file
//      /find   -   launches wab with find window
//      filename-   opens the file
//      /open   -   open file dialog to pick a wab file
//      /new    -   new file dialog to create a wab file
//      /showexisting - brings any already open default-wab file browse
//                      view to the forefront
//      /? -?   -   pops up a parameter dialog
//
////////////////////////////////////////////////////////////////////////
BOOL bGetFileNameFromCmdLine(HWND hwnd,
                             HINSTANCE hInstance,
                             LPTSTR lpszCmdLine,
                             LPTSTR szWABTitle,
                             ULONG * lpulFlag,
                             LPTSTR szFileName)
{
    BOOL bRet = FALSE;
    TCHAR szBuf[2*MAX_PATH];
    LPTSTR lpTemp = lpszCmdLine;

//    if(lpbIsVCardFile)
//        *lpbIsVCardFile = FALSE;

    if(lpulFlag)
        *lpulFlag = 0;
    else
        goto out;

    if (!lstrcmpi(lpszCmdLine,szParamShowExisting))
    {
        // do nothing
        szFileName[0] = '\0';
        bRet = TRUE;
        goto out;
    }
    else if (!lstrcmpi(lpszCmdLine,szParamFind))
    {
        // do nothing
        szFileName[0] = '\0';
        bRet = TRUE;
        *lpulFlag = WAB_FINDSESSION;
        goto out;
    }
    else if( (!lstrcmpi(lpszCmdLine,TEXT("/?"))) ||
             (!lstrcmpi(lpszCmdLine,TEXT("-?"))) )
    {
        LoadString(hInstance, idsWABUsage, szBuf, sizeof(szBuf));
        MessageBox(hwnd, szBuf, szWABTitle, MB_OK | MB_ICONINFORMATION);
        goto out;
    }
    else if(!lstrcmpi(lpszCmdLine,szParamOpen))
    {
        if(bGetFileNameFromDlg(hwnd,
                        hInstance,
                        NULL,
                        idsWABOpenFileTitle,
                        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
                        szFileName))
        {
            bRet = TRUE;
        }
        goto out;
    }
    else if(!lstrcmpi(lpszCmdLine,szParamNew))
    {
        if(bGetFileNameFromDlg(hwnd,
                        hInstance,
                        NULL,
                        idsWABNewFileTitle,
                        OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                        szFileName))
        {
            bRet = TRUE;
        }
        goto out;
    }
    else if (!StrICmpN(lpTemp, (LPTSTR)szParamVCard, sizeof(szParamVCard)))
    {
               lpTemp += sizeof(szParamVCard);     // move past the switch

               while(lpTemp && *lpTemp && (*lpTemp==' '))
                   lpTemp=CharNext(lpTemp);

               if(lpTemp && lstrlen(lpTemp))
               {
                   lstrcpy(szFileName, lpTemp);
                   *lpulFlag = WAB_VCARDFILE;
                   bRet = TRUE;
               }
               goto out;
    }
    else if (!StrICmpN(lpTemp, (LPTSTR)szParamCert, sizeof(szParamCert)))
    {
       lpTemp += sizeof(szParamCert);     // move past the switch

       while(lpTemp && *lpTemp && (*lpTemp==' '))
           lpTemp=CharNext(lpTemp);

       if(lpTemp && lstrlen(lpTemp))
       {
           lstrcpy(szFileName, lpTemp);
           *lpulFlag = WAB_CERTFILE;
           bRet = TRUE;
       }
       goto out;
    }
    else if (!StrICmpN(lpTemp, (LPTSTR)szParamLDAPUrl, sizeof(szParamLDAPUrl)))
    {
        // We are expecting a url of the form
        //  /ldap:ldap-url
        lpTemp += sizeof(szParamLDAPUrl)-1;     // move past the switch

        if(lpTemp && lstrlen(lpTemp))
        {
           lstrcpy(szFileName, lpTemp);
           *lpulFlag = WAB_LDAPURL;
           bRet = TRUE;
        }
        goto out;
    }
    else if (!StrICmpN(lpTemp, (LPTSTR)szAllProfiles, sizeof(szAllProfiles)))
    {
        *lpulFlag = WAB_ALLPROFILES;
        bRet = TRUE;
        goto out;
    }
    else
    {
        //perhaps this is a file name
        //See if we can find this file in this computer
        DWORD dwAttr = GetFileAttributes(lpszCmdLine);
        if(dwAttr != 0xFFFFFFFF)
        {
            //Found the file
            if(!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
            {
                //Not a directory, must be a file
                lstrcpy(szFileName,lpszCmdLine);
            }
            else
            {
                //This is a directory - open a dialog in this directory
                if(bGetFileNameFromDlg(hwnd,
                                hInstance,
                                lpszCmdLine,
                                idsWABOpenFileTitle,
                                OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
                                szFileName))
                {
                    bRet = TRUE;
                }
                goto out;
            }
        }
        else
        {
            // we couldnt find any such file
            LPTSTR lpszMsg = NULL;
            int nRet;
            DWORD dwLastError = GetLastError();

            if(dwLastError == 3)
            {
                // Path not found
                LoadString(hInstance, idsWABPathNotFound, szBuf, sizeof(szBuf));
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                szBuf,
                                0,
                                0,
                                (LPTSTR) &lpszMsg,
                                0,
                                (va_list *)&lpszCmdLine);
                MessageBox( NULL, lpszMsg, szWABTitle, MB_OK|MB_ICONEXCLAMATION );
                LocalFree( lpszMsg );
                goto out;
            }
            else if(dwLastError == 2)
            {
                // File not found
                LoadString(hInstance, idsWABFileNotFound, szBuf, sizeof(szBuf));
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                szBuf,
                                0,
                                0,
                                (LPTSTR) &lpszMsg,
                                0,
                                (va_list *)&lpszCmdLine);
                nRet = MessageBox(hwnd, lpszMsg, szWABTitle, MB_YESNO | MB_ICONEXCLAMATION);
                LocalFree( lpszMsg );
                switch(nRet)
                {
                case IDYES:
                    // use this as the file name (TBD - waht if path doesnt match ?)
                    lstrcpy(szFileName,lpszCmdLine);
                    bRet = TRUE;
                    break;
                case IDNO:
                    goto out;
                    break;
                }
            }
            else
            {
                LoadString(hInstance, idsWABInvalidCmdLine, szBuf, sizeof(szBuf));
                MessageBox( NULL, szBuf, szWABTitle, MB_OK|MB_ICONEXCLAMATION );
                goto out;
            }
        }
    }

    bRet = TRUE;

out:
    return bRet;
}

//$$////////////////////////////////////////////////////////////////////
//
// Gets the default wab file name from the registry setting
// gets nothing if there is no name
//
////////////////////////////////////////////////////////////////////////
void GetWABDefaultAddressBookName(LPTSTR szDefaultFile)
{
    TCHAR   szFileName[MAX_PATH];
    const LPTSTR  lpszKeyName = TEXT("Software\\Microsoft\\WAB\\WAB4\\Wab File Name");
    HKEY    hKey = NULL;
    DWORD   dwLenName = sizeof(szFileName);
    DWORD   dwDisposition = 0;
    DWORD   dwType = 0;

    szFileName[0]='\0';

    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER,
                                        lpszKeyName,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        goto out;
    }

    if (dwDisposition != REG_OPENED_EXISTING_KEY)
    {
        goto out;
    }

    // Didn't create a new key, so get the key value
    if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                        NULL,
                                        NULL,
                                        &dwType,      //reserved
                                        szFileName,
                                        &dwLenName))
    {
        goto out;
    }

    // Check if the path for this file exists or not
    {
        if(0xFFFFFFFF == GetFileAttributes(szFileName))
        {
            // error
            if(GetLastError() == ERROR_PATH_NOT_FOUND)
                goto out;
        }
    }
    lstrcpy(szDefaultFile, szFileName);

out:

    return;
}
//$$//////////////////////////////////////////////////////////////////////
//
// GetWABDllPath
//
//
//////////////////////////////////////////////////////////////////////////
void GetWABDllPath(LPTSTR szPath, ULONG cb)
{
    DWORD  dwType = 0;
    ULONG  cbData;
    HKEY hKey = NULL;
    TCHAR szPathT[MAX_PATH];

    if(szPath)
    {

        *szPath = '\0';

        // open the szWABDllPath key under
        if (ERROR_SUCCESS == RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                                            WAB_DLL_PATH_KEY,
                                            0,      //reserved
                                            KEY_READ,
                                            &hKey))
        {
            cbData = sizeof(szPathT);
            if (ERROR_SUCCESS == RegQueryValueEx(    hKey,
                                "",
                                NULL,
                                &dwType,
                                (LPBYTE) szPathT,
                                &cbData))
            {
                if (dwType == REG_EXPAND_SZ)
                    cbData = ExpandEnvironmentStrings(szPathT, szPath, cb / sizeof(TCHAR));
                else
                {
                    if(GetFileAttributes(szPathT) != 0xFFFFFFFF)
                        lstrcpy(szPath, szPathT);
                }
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);
}

//$$//////////////////////////////////////////////////////////////////////
//
// LoadLibrary_WABDll()
//
//  Since we are moving the WAB directory out of Windows\SYstem, we cant be
//  sure it will be on the path. Hence we need to make sure that WABOpen will
//  work - by loading the wab32.dll upfront
//
///////////////////////////////////////////////////////////////////////////
HINSTANCE LoadLibrary_WABDll()
{
    LPTSTR lpszWABDll = TEXT("Wab32.dll");
    TCHAR  szWABDllPath[MAX_PATH];
    HINSTANCE hinst = NULL;

    GetWABDllPath(szWABDllPath, sizeof(szWABDllPath));

    hinst = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : lpszWABDll );

    return hinst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabfind\fndcf.c ===
/*****************************************************************************
 *
 * fndcf.c - IClassFactory interface
 *
 *****************************************************************************/

#include "fnd.h"

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflFactory

/*****************************************************************************
 *
 *	Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CFndFactory, IClassFactory);

/*****************************************************************************
 *
 *	CFndFactory
 *
 *	Really nothing doing.
 *
 *****************************************************************************/

typedef struct CFndFactory {

    /* Supported interfaces */
    IClassFactory 	cf;

} CFndFactory, FCF, *PFCF;

typedef IClassFactory CF, *PCF;

/*****************************************************************************
 *
 *	CFndFactory_QueryInterface (from IUnknown)
 *	CFndFactory_AddRef (from IUnknown)
 *	CFndFactory_Finalize (from Common)
 *	CFndFactory_Release (from IUnknown)
 *
 *****************************************************************************/

#define CFndFactory_QueryInterface Common_QueryInterface
#define CFndFactory_AddRef	Common_AddRef
#define CFndFactory_Release	Common_Release
#define CFndFactory_Finalize	Common_Finalize

/*****************************************************************************
 *
 *	CFndFactory_CreateInstance (from IClassFactory)
 *
 *****************************************************************************/

STDMETHODIMP
CFndFactory_CreateInstance(PCF pcf, LPUNKNOWN punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    if (!punkOuter) {
	/* The only object we know how to create is a context menu */
	hres = CFndCm_New(riid, ppvObj);
    } else {		/* Does anybody support aggregation any more? */
	hres = ResultFromScode(CLASS_E_NOAGGREGATION);
    }
    return hres;
}

/*****************************************************************************
 *
 *	CFndFactory_LockServer (from IClassFactory)
 *
 *	Locking the server is identical to
 *	creating an object and not releasing it until you want to unlock
 *	the server.
 *
 *****************************************************************************/

STDMETHODIMP
CFndFactory_LockServer(PCF pcf, BOOL fLock)
{
    PFCF this = IToClass(CFndFactory, cf, pcf);
    if (fLock) {
	InterlockedIncrement((LPLONG)&g_cRef);
    } else {
	InterlockedDecrement((LPLONG)&g_cRef);
    }
    return NOERROR;
}

/*****************************************************************************
 *
 *	CFndFactory_New
 *
 *****************************************************************************/

STDMETHODIMP
CFndFactory_New(RIID riid, PPV ppvObj)
{
    HRESULT hres;
    if (IsEqualIID(riid, &IID_IClassFactory)) {
	hres = Common_New(CFndFactory, ppvObj);
    } else {
	hres = ResultFromScode(E_NOINTERFACE);
    }
    return hres;
}

/*****************************************************************************
 *
 *	The long-awaited vtbl
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

Primary_Interface_Begin(CFndFactory, IClassFactory)
	CFndFactory_CreateInstance,
	CFndFactory_LockServer,
Primary_Interface_End(CFndFactory, IClassFactory)


#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabhelp\adcs_ids.h ===
#define IDH_WAB_COMM_GROUPBOX	            96969600
#define IDH_WAB_PICK_RECIP_TYPE_NAME	    96969601
#define IDH_WAB_PICK_RECIP_NAME_LIST	    96969602
#define IDH_WAB_PICK_RECIP_NAME_NEW	    96969603
#define IDH_WAB_PICK_RECIP_NAME_NEW_GROUP   96969604
#define IDH_WAB_PICK_RECIP_NAME_PROPERTIES  96969605
#define IDH_WAB_PICK_RECIP_NAME_FIND        96969606
#define IDH_WAB_PICK_RECIP_NAME_TO_BUTTON   96969607
#define IDH_WAB_PICK_RECIP_NAME_TO_LIST     96969608  

//Select Group Members dialog
#define IDH_WAB_PICK_RECIP_NAME_CC_BUTTON   96969609
#define IDH_WAB_PICK_RECIP_NAME_CC_LIST     96969610
#define IDH_WAB_GROUPS_CONTACTS_FOLDER      96969670

#define IDH_WAB_FIND_FIRST                  96969611
#define IDH_WAB_FIND_LAST                   96969612	
#define IDH_WAB_FIND_E_MAIL                 96969613
#define IDH_WAB_CONTACT_PROPS_TITLE         96969614
#define IDH_WAB_CONTACT_PROPS_FIRST         96969615
#define IDH_WAB_CONTACT_PROPS_LAST          96969616
#define IDH_WAB_CONTACT_PROPS_SUFFIX        96969617
#define IDH_WAB_HOME_ADDRESS                96969618
#define IDH_WAB_HOME_CITY                   96969619
#define IDH_WAB_HOME_STATE                  96969620
#define IDH_WAB_HOME_ZIP                    96969621
#define IDH_WAB_HOME_COUNTRY                96969622
#define IDH_WAB_BUS_COMPANY                 96969623
#define IDH_WAB_BUS_TITLE                   96969624
#define IDH_WAB_BUS_DEPT                    96969625
#define IDH_WAB_BUS_OFFICE                  96969626
#define IDH_WAB_BUS_ADDRESS                 96969627
#define IDH_WAB_BUS_CITY                    96969628
#define IDH_WAB_BUS_STATE                   96969629
#define IDH_WAB_BUS_ZIP                     96969630
#define IDH_WAB_BUS_COUNTRY                 96969631
#define IDH_WAB_BUS_PHONE                   96969632
#define IDH_WAB_BUS_PHONE_BUTTON            96969633
#define IDH_WAB_BUS_FAX                     96969634
#define IDH_WAB_BUS_FAX_BUTTON              96969635
#define IDH_WAB_BUS_CELLULAR                96969636
#define IDH_WAB_BUS_CELLULAR_BUTTON         96969637
#define IDH_WAB_ANYTAB_OTHER_DROP_DOWN      96969638
#define IDH_WAB_BUS_PAGER                   96969639
#define IDH_WAB_BUS_PAGER_BUTTON            96969640
#define IDH_WAB_CONF_MODEM                  96969641
#define IDH_WAB_CONF_MODEM_BUTTON           96969642
#define IDH_WAB_NICKNAME                    96969643
#define IDH_WAB_MIDDLE_NAME                 96969644

#define IDH_WAB_APPLY                       96969646
#define IDH_WAB_ADD_EMAIL_NAME              96969647
#define IDH_WAB_EMAIL_NAME_LIST             96969648
#define IDH_WAB_DELETE_EMAIL_NAME           96969649
#define IDH_WAB_DEFAULT_EMAIL_NAME          96969650
#define IDH_WAB_HOMEPAGE                    96969651
#define IDH_WAB_HOMEPAGE_BUTTON             96969652

//Group Properties
#define IDH_WAB_GROUPNAME                   96969653
#define IDH_WAB_ADD_GROUP_MEMBERS           96969654
#define IDH_WAB_GROUP_NAME_LIST             96969655
#define IDH_WAB_DELETE_GROUP_MEMBERS        96969656
#define IDH_WAB_ADD_NEW_GROUP_CONTACTS      96969660 

#define IDH_WAB_CHK_NAME_LIST               96969657
#define IDH_WAB_PICK_USER                   96969658
#define IDH_WAB_EDIT_EMAIL_NAME             96969665
#define IDH_WAB_PICK_RECIP_NAME_BCC_BUTTON  96969666
#define IDH_WAB_PICK_RECIP_NAME_BCC_LIST    96969667
#define IDH_WAB_PICK_RECIP_NAME_DELETE      96969668
#define IDH_WABLDAP_DIR_SER_LIST            5
#define IDH_WABLDAP_GEN_ADD                 15
#define IDH_WABLDAP_GEN_REMOVE              25
#define IDH_WABLDAP_GEN_PROPERTIES          35
#define IDH_WABLDAP_OPT_SELECT              45
#define IDH_WABLDAP_OPT_REMOVE              55
#define IDH_WABLDAP_OPT_UP                  65
#define IDH_WABLDAP_OPT_DOWN                75
#define IDH_WABLDAP_OPT_DIRSERV_CHECK_AGAINST	  85
#define IDH_WABLDAP_DIRSERV_LIST            95
#define IDH_WABLDAP_OPT_COUNTRY             100
#define IDH_SHOW_NAMES_FROM                 125
#define IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS_CONF  195
#define IDH_WABLDAP_CONNECT_TIMEOUT         205
//#define IDH_LDAP_SEARCH_SEARCH_IN         230
#define IDH_LDAP_SEARCH_FIRST_NAME          235
#define IDH_LDAP_SEARCH_LAST_NAME           240
#define IDH_LDAP_SEARCH_EMAIL_ADDRESS       245
#define IDH_LDAP_SEARCH_ORGANIZATION        250
#define IDH_LDAP_SEARCH_COUNTRY             255
#define IDH_WAB_DIR_SER_LIST                275
#define IDH_WAB_FIND_ADDRESS                280
#define IDH_WAB_FIND_PHONE                  285
#define IDH_WAB_FIND_OTHER                  290
#define IDH_WAB_FIND_FINDNOW                295
#define IDH_WAB_FIND_STOP                   297
#define IDH_WAB_FIND_CLEARALL               300
#define IDH_WAB_FIND_CLOSE                  305
#define IDH_WAB_FIND_RESULTS                310
#define IDH_WAB_FIND_DELETE                 315
#define IDH_WAB_FIND_ADD2WAB                320
#define IDH_WAB_PRINT_MEMO                  325
#define IDH_WAB_PRINT_BIZCARD               330
#define IDH_WAB_PRINT_PHONELIST             335
#define IDH_WAB_PERSONAL_NAME_DISPLAY       340
#define IDH_WAB_PROPERTIES_CERTIFICATES     4000
#define IDH_WAB_PROPERTIES_PROPERTIES       4005
#define IDH_WAB_PROPERTIES_REMOVE           4010
#define IDH_WAB_PROPERTIES_SETASDEFAULT     4015
#define IDH_WAB_PROPERTIES_IMPORT           4020
#define IDH_WAB_PROPERTIES_EXPORT           4025
#define IDH_WABLDAP_DIRSSERV_AUTH_ANON      145
#define IDH_WAB_VISITDS_BUTTON              4030
#define IDH_WAB_DIRSERV_ADDADDRESS          4035

//Conferencing tab for Properties
#define IDH_WAB_CONFERENCE_SELECT_ADDRESS   4050
#define IDH_WAB_CONFERENCE_CALL_NOW         4055
#define IDH_WAB_CONFERENCE_SERVER_NAME      4060
#define IDH_WAB_CONFERENCE_SERVER_LIST      4063
#define IDH_WAB_CONFERENCE_ADD_SERVER       4065
#define IDH_WAB_CONFERENCE_EDIT_SERVER      4070
#define IDH_WAB_CONFERENCE_REMOVE_SERVER    4075
#define IDH_WAB_CONFERENCE_SET_DEFAULT      4080
#define IDH_WAB_CONFERENCE_SET_BACKUP       4085

//Other tab for contact properties
#define IDH_WAB_NOTES                       96969645
#define IDH_WAB_OTHER_GROUP_MEMBERSHIP      4090

//Name tab for contact properties
#define IDH_WAB_PROPERTIES_SEND_USING_PLAIN_TEXT  4095

//Certificates tab for contact properties
#define IDH_WAB_CERTIFICATES_SELECT_EMAIL_ADDRESS 4100

//Advanced tab in Find People
#define IDH_WAB_FIND_ADV_CRITERIA           96969680
#define IDH_WAB_FIND_ADV_CRITERIA_DISPLAY   96969681
#define IDH_WAB_FIND_ADV_CRITERIA_ADD       96969682
#define IDH_WAB_FIND_ADV_CRITERIA_REMOVE    96969683

//Properties dialog, Home tab
#define IDH_WAB_HOME_GENDER                 96969684

//Properties dialog, Other tab
#define IDH_WAB_OTHER_FOLDER                96969685

//Properties dialog, Summary tab
#define IDH_WAB_SUMMARY                     96969686

//New Call dialog (the dialer)
#define IDH_WAB_DIALER_CONTACT              96969687
#define IDH_WAB_DIALER_PHONE                96969688
#define IDH_WAB_DIALER_PROPERTIES           96969689
#define IDH_WAB_DIALER_CALL                 96969690
#define IDH_WAB_DIALING_PROPERTIES          96969691

//Properties dialog, Business tab
#define IDH_WAB_BUSINESS_VIEWMAP            96969692
#define IDH_WAB_BUSINESS_DEFAULTBOX         96969693
#define IDH_WAB_BUSINESS_IPPHONE            96969694

//Properties dialog, Organization tab
#define IDH_WAB_ORGANIZATION_MANAGER        96969695
#define IDH_WAB_ORGANIZATION_REPORTS        96969696

//Properties dialog, Personal (new) tab
#define IDH_WAB_PERSONAL_SPOUSE             96969697
#define IDH_WAB_PERSONAL_CHILDREN           96969698
#define IDH_WAB_PERSONAL_BIRTHDAY           96969699
#define IDH_WAB_PERSONAL_ANNIVERSARY        96969700
#define IDH_WAB_PERSONAL_ADD                96969701
#define IDH_WAB_PERSONAL_EDIT               96969702
#define IDH_WAB_PERSONAL_REMOVE             96969703

//Money tab
#define IDH_WAB_FINANCIAL			400
#define IDH_WAB_PAYMENT_TERMS			405
#define IDH_WAB_BALANCE_DUE			410
#define IDH_WAB_BALANCE_OVERDUE			415
#define IDH_WAB_RECENT_INVOICES			420

//Group and Group Details tabs
#define IDH_WAB_GROUP_NAME                  96969710
#define IDH_WAB_GROUP_EMAIL                 96969712
#define IDH_WAB_GROUP_PROPERTIES            96969714
#define IDH_WAB_GROUP_ADD                   96969716
#define IDH_WAB_GROUP_UPDATE                96969718
#define IDH_WAB_GROUP_CANCEL_EDIT           96969720
#define IDH_WAB_DETAILS_ADDRESS             96969722
#define IDH_WAB_DETAILS_CITY                96969724
#define IDH_WAB_DETAILS_STATE               96969726
#define IDH_WAB_DETAILS_ZIP                 96969728
#define IDH_WAB_DETAILS_COUNTRY             96969730
#define IDH_WAB_DETAILS_PHONE               96969732
#define IDH_WAB_DETAILS_FAX                 96969734
#define IDH_WAB_DETAILS_WEBPAGE             96969736
#define IDH_WAB_DETAILS_GO                  96969738

//Choose Profile dialog box
#define IDH_WAB_CHOOSE_PROFILE_CREATE_NEW   96969740
#define IDH_WAB_CHOOSE_PROFILE_SELECTFROM   96969742
#define IDH_WAB_CHOOSE_PROFILE_LIST         96969744
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabfind\makefile.inc ===
$O\wabfind.res : $(O)\selfreg.inf

selfreg.src : reg.src reg2.src

$(O)\selfreg.inx : selfreg.src
	cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabfind\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inetfind.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\wabw\wabfind\mem.c ===
/*****************************************************************************
 *
 *	mem.c - Memory management
 *
 *	WARNING!  These do not go through OLE allocation.  Use these
 *	only for private allocation.
 *
 *****************************************************************************/

#include "fnd.h"

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64


/*****************************************************************************
 *
 *	AllocCbPpv
 *
 *	Allocate memory into the ppv.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
#ifdef _WIN64
    UINT cb1 = LcbAlignLcb(cb);
    *ppv = LocalAlloc(LPTR, cb1);
#else
    *ppv = LocalAlloc(LPTR, cb);
#endif // _WIN64

    hres = *ppv ? NOERROR : E_OUTOFMEMORY;
    return hres;
}


#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\passport\inetsess.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    InetSess.cpp

Abstract:

    Implements the Passport Session that uses WinInet as the underlying transport.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"

#ifdef HINTERNET
#undef HINTERNET
#endif

#ifdef INTERNET_PORT
#undef INTERNET_PORT
#endif

#include <WinInet.h>
#include "session.h"
#include <wchar.h>
#include "passport.h"
#include <sensapi.h>

// #include "inetsess.tmh"

//
// func pointer decl for WinInet
//

typedef HINTERNET
(WINAPI * PFN_INTERNET_OPEN)(
    IN LPCWSTR lpwszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpwszProxy OPTIONAL,
    IN LPCWSTR lpwszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_INTERNET_CONNECT)(
    IN HINTERNET hInternet,
    IN LPCWSTR lpwszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpwszUserName OPTIONAL,
    IN LPCWSTR lpwszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

typedef HINTERNET
(WINAPI * PFN_OPEN_REQUEST)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpwszVerb,
    IN LPCWSTR lpwszObjectName,
    IN LPCWSTR lpwszVersion,
    IN LPCWSTR lpwszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpwszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

typedef BOOL
(WINAPI * PFN_SEND_REQUEST)(
    IN HINTERNET hRequest,
    IN LPCWSTR lpwszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );

typedef BOOL 
(WINAPI * PFN_QUERY_INFO)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPVOID lpvBuffer,
    IN LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
);

typedef BOOL 
(WINAPI* PFN_CLOSE_HANDLE)(
    IN HINTERNET hInternet
);

typedef BOOL 
(WINAPI* PFN_SET_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
);

typedef BOOL 
(WINAPI* PFN_QUERY_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
);

typedef HINTERNET 
(WINAPI* PFN_OPEN_URL)(
    IN HINTERNET hInternet, 
    IN LPCWSTR lpwszUrl,
    IN LPCWSTR lpwszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
);

typedef BOOL 
(WINAPI* PFN_CRACK_URL)(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents
);

typedef BOOL 
(WINAPI* PFN_READ_FILE)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
);

typedef INTERNET_STATUS_CALLBACK 
(WINAPI* PFN_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
);

typedef BOOL 
(WINAPI* PFN_ADD_HEADERS)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
);

typedef BOOL
(WINAPI* PFN_IS_HOST_BYPASS_PROXY)(
    IN INTERNET_SCHEME tScheme, 
    IN LPCSTR pszHost, 
    IN DWORD cchHost);

class WININET_SESSION : public SESSION
{
protected:
    WININET_SESSION(void);
    virtual ~WININET_SESSION(void);

    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET);
    virtual void Close(void);

protected:    
    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT
        );

    virtual HINTERNET OpenRequest(
            HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0);

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0);

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL);

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet);

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength);    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength);

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags);

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead);

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents);

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        );

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        );

    virtual BOOL IsHostBypassProxy(
        INTERNET_SCHEME tScheme, 
        LPCSTR pszHost, 
        DWORD cchHost);


#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR pwszData,
                                PDWORD pdwDataLength
                                );
#endif // PP_DEMO

    BOOL InitHttpApi(PFN_INTERNET_OPEN*);

protected:
    HINTERNET m_hInternet;

    PFN_INTERNET_CONNECT    m_pfnConnect;
    PFN_OPEN_REQUEST        m_pfnOpenRequest;
    PFN_SEND_REQUEST        m_pfnSendRequest;
    PFN_QUERY_INFO          m_pfnQueryInfo;
    PFN_CLOSE_HANDLE        m_pfnCloseHandle;
    PFN_SET_OPTION          m_pfnSetOption;
    PFN_OPEN_URL            m_pfnOpenUrl;
    PFN_QUERY_OPTION        m_pfnQueryOption;
    PFN_CRACK_URL           m_pfnCrack;
    PFN_READ_FILE           m_pfnReadFile;
    PFN_STATUS_CALLBACK     m_pfnStatusCallback;
    PFN_ADD_HEADERS         m_pfnAddHeaders;
    PFN_IS_HOST_BYPASS_PROXY m_pfnIsHostBypassProxy;

friend class SESSION;
};

//
// Implementation for SESSION
//

SESSION* CreateWinHttpSession(void);

// -----------------------------------------------------------------------------
BOOL SESSION::CreateObject(PCWSTR pwszHttpStack, HINTERNET hSession, SESSION*& pSess)
{
    PP_ASSERT(pwszHttpStack != NULL);
    
    pSess = NULL;

    if (!::_wcsicmp(pwszHttpStack, L"WinInet.dll") || 
        !::_wcsicmp(pwszHttpStack, L"WinInet"))
    {
        pSess = new WININET_SESSION();
    }
    else
    {
        pSess = ::CreateWinHttpSession();
    }

    if (pSess)
    {
        return pSess->Open(pwszHttpStack, hSession);
    }
    else
    {
        DoTraceMessage(PP_LOG_ERROR, "CreateObject() failed; not enough memory");
        return FALSE;
    }
}

// -----------------------------------------------------------------------------
SESSION::SESSION(void)
{
    m_hHttpStack = 0;
    m_hCredUI = 0;
    m_RefCount = 0;

    m_pfnReadDomainCred = NULL;
    m_pfnCredFree = NULL;

    m_hKeyLM = NULL;
    m_hKeyCU = NULL;
    m_hKeyDAMap = NULL;

    m_wCurrentDAUrl[0] = 0;

    m_LastNexusDownloadTime = 0xFFFFFFFF;
}

// -----------------------------------------------------------------------------
SESSION::~SESSION(void)
{
}

BOOL SESSION::GetDAInfoFromPPNexus(
    IN BOOL             fForce,         // ignored for now, always assumes TRUE regardless of actual value
    IN PWSTR            pwszRegUrl,    // user supplied buffer ...
    IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
    IN PWSTR            pwszRealm,    // user supplied buffer ...
    IN OUT PDWORD       pdwRealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    )
{
    BOOL fRetVal = FALSE;
    HINTERNET hRequest = NULL;
    HINTERNET hConnect = NULL;
    DWORD dwError;
    
    WCHAR wNexusHost[128] = L"nexus.passport.com";
    DWORD dwHostLen = sizeof(wNexusHost); // note: size of the buffer, not # of UNICODE characters
    WCHAR wNexusObj[128] = L"rdr/pprdr.asp";
    DWORD dwObjLen = sizeof(wNexusObj);
    
    PWSTR pwszPassportUrls = NULL;
    DWORD dwUrlsLen = 0;
    DWORD dwValueType;

    WCHAR Delimiters[] = L",";
    PWSTR Token = NULL;
    // we allow only one Nexus contact per session to avoid infinite loop due to Nexus misconfiguration

    DWORD dwCurrentTime = ::GetTickCount();

    if ((dwCurrentTime >= m_LastNexusDownloadTime) && 
        (dwCurrentTime - m_LastNexusDownloadTime < 5*60*1000)) // 5 minutes
    {
        DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() failed: Nexus info already downloaded");
        goto exit;
    }

    // biaow-todo: when the Passport Team gives us THE final Nexus name, we'll then hard-code it here. And
    //             there will be no need to query registry here by then.
    
    if (m_hKeyLM)
    {
        dwError = ::RegQueryValueExW(m_hKeyLM,
                                     L"NexusHost",
                                     0,
                                     &dwValueType,
                                     reinterpret_cast<LPBYTE>(wNexusHost),
                                     &dwHostLen);

        PP_ASSERT(!(dwError == ERROR_MORE_DATA));
        // PP_ASSERT(dwValueType == REG_SZ); BVT Break!!!

        dwError = ::RegQueryValueExW(m_hKeyLM,
                                     L"NexusObj",
                                     0,
                                     &dwValueType,
                                     reinterpret_cast<LPBYTE>(wNexusObj),
                                     &dwObjLen);

        PP_ASSERT(!(dwError == ERROR_MORE_DATA));
        // PP_ASSERT(dwValueType == REG_SZ); BVT Break!!!
    }

    CHAR NexusHost[128];
    ::WideCharToMultiByte (CP_ACP, 0, wNexusHost, -1, NexusHost, 128, NULL, NULL);

   
    hConnect = Connect(wNexusHost,
#ifdef DISABLE_SSL
                    INTERNET_DEFAULT_HTTP_PORT
#else
                    INTERNET_DEFAULT_HTTPS_PORT
#endif
                       );
    if (hConnect == NULL)
    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::GetDAInfoFromPPNexus(): failed to connect to %ws; Error = %d", 
                       wNexusHost, dwErrorCode);
        goto exit;
    }

    hRequest = OpenRequest(hConnect,
                           NULL,
                           wNexusObj,
#ifdef DISABLE_SSL
                           0
#else                                                 
                           INTERNET_FLAG_SECURE
#endif
                           );

    if (hRequest == NULL)

    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; OpenRequest() to %ws failed, Error Code = %d",
                       wNexusObj, dwErrorCode);
        goto exit;
    }


    if (!SendRequest(hRequest, NULL, 0))
    {
        DWORD dwErrorCode = ::GetLastError();

#ifdef BAD_CERT_OK
        if (dwErrorCode == ERROR_INTERNET_INVALID_CA)
        {
            DWORD dwSecFlags;
            DWORD dwSecurityFlagsSize = sizeof(dwSecFlags);

            if (!QueryOption(hRequest, 
                                    INTERNET_OPTION_SECURITY_FLAGS,
                                    &dwSecFlags,
                                    &dwSecurityFlagsSize))
            {
                dwSecFlags = 0;
            }
            else
            {
                dwSecFlags |= SECURITY_SET_MASK;
            }

            if (!SetOption(hRequest, 
                                      INTERNET_OPTION_SECURITY_FLAGS, 
                                      &dwSecFlags, 
                                      dwSecurityFlagsSize))
            {
                PP_ASSERT(TRUE); // shouldn't reach here
                goto exit;
            }
            else
            {
                if (!SendRequest(hRequest, NULL, 0))
                {
                    DWORD dwErrorCode = ::GetLastError();
                    DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus(): SendRequest() failed");
                    goto exit;
                }
            }
        }
#else
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus(): failed");
        goto exit;
#endif // BAD_CERT_OK
    }

    if (QueryHeaders(hRequest,
                     HTTP_QUERY_PASSPORT_URLS,
                     0,
                     &dwUrlsLen) == FALSE)
    {
        if ((::GetLastError() != ERROR_INSUFFICIENT_BUFFER) || (dwUrlsLen == 0))
        {
            DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; PassportUrls header not found");
            goto exit;
        }
    }
    else
    {
        PP_ASSERT(TRUE); // should not reach here
    }
    
    pwszPassportUrls = new WCHAR[dwUrlsLen];
    if (pwszPassportUrls == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; insufficient memory");
        goto exit;
    }
    
    if (QueryHeaders(hRequest,
                     HTTP_QUERY_PASSPORT_URLS,
                     pwszPassportUrls,
                     &dwUrlsLen) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; PassportUrls header not found");
        goto exit;
    }

    Token = ::wcstok(pwszPassportUrls, Delimiters);
    while (Token != NULL)
    {
        // skip leading white spaces
        while (*Token == (L" ")[0]) { ++Token; }
        if (Token == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no text in between commas");
            goto next_token;
        }

        // find DALocation
        if (!::_wcsnicmp(Token, L"DALogin", ::wcslen(L"DALogin")))
        {
            PWSTR pwszDAUrl = ::wcsstr(Token, L"=");
            if (pwszDAUrl == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DALocation");
                goto exit;
            }
            
            pwszDAUrl++; // skip "="

            while (*pwszDAUrl == (L" ")[0]) { ++pwszDAUrl; } // skip leading white spaces

            ::wcscpy(m_wDefaultDAUrl, L"https://");
            ::wcscat(m_wDefaultDAUrl, pwszDAUrl);

            if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                             L"LoginServerUrl",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(m_wDefaultDAUrl),
                             ::wcslen(m_wDefaultDAUrl) * sizeof(WCHAR)) != ERROR_SUCCESS)
            {
                if (m_hKeyCU)
                {
                    ::RegSetValueExW(m_hKeyCU,
                             L"LoginServerUrl",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(m_wDefaultDAUrl),
                             ::wcslen(m_wDefaultDAUrl) * sizeof(WCHAR));
                }
            }

            m_LastNexusDownloadTime = ::GetTickCount();
            fRetVal = TRUE;

            DoTraceMessage(PP_LOG_INFO, "DALocation URL %ws found", m_wDefaultDAUrl);
        }
        else if (!::_wcsnicmp(Token, L"DARealm", ::wcslen(L"DARealm")))
        {
            PWSTR pwszDARealm = ::wcsstr(Token, L"=");
            if (pwszDARealm == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DARealm");
                goto exit;
            }

            pwszDARealm++; // skip "="

            while (*pwszDARealm == (L" ")[0]) { ++pwszDARealm; } // skip leading white spaces

            if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                             L"LoginServerRealm",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(pwszDARealm),
                             ::wcslen(pwszDARealm) * sizeof(WCHAR)) != ERROR_SUCCESS)
            {
                if (m_hKeyCU)
                {
                ::RegSetValueExW(m_hKeyCU,
                             L"LoginServerRealm",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(pwszDARealm),
                             ::wcslen(pwszDARealm) * sizeof(WCHAR));
                }
            }

            if (pwszRealm)
            {
                if (*pdwRealmLen < ::wcslen(pwszDARealm) + 1)
                {
                    *pdwRealmLen = ::wcslen(pwszDARealm) + 1;
                    fRetVal = FALSE;
                    goto exit;
                }
                else
                {
                    ::wcscpy(pwszRealm, pwszDARealm);
                    *pdwRealmLen = ::wcslen(pwszDARealm) + 1;
                }
            }
            
            DoTraceMessage(PP_LOG_INFO, "DARealm URL %ws found", m_wDefaultDAUrl);
        }
        else if (!::_wcsnicmp(Token, L"DAReg", ::wcslen(L"DAReg")))
            {
                PWSTR pwszDAReg = ::wcsstr(Token, L"=");
                if (pwszDAReg == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DAReg");
                    goto exit;
                }

                pwszDAReg++; // skip "="

                while (*pwszDAReg == (L" ")[0]) { ++pwszDAReg; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"RegistrationUrl",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszDAReg),
                                 ::wcslen(pwszDAReg) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"RegistrationUrl",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszDAReg),
                                 ::wcslen(pwszDAReg) * sizeof(WCHAR));
                    }
                }

                if (pwszRegUrl)
                {
                    if (*pdwRegUrlLen < ::wcslen(pwszDAReg) + 1)
                    {
                        *pdwRegUrlLen = ::wcslen(pwszDAReg) + 1;
                        fRetVal = FALSE;
                        goto exit;
                    }
                    else
                    {
                        ::wcscpy(pwszRegUrl, pwszDAReg);
                        *pdwRegUrlLen = ::wcslen(pwszDAReg) + 1;
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "DAReg URL %ws found", m_wDefaultDAUrl);
            }
        else if (!::_wcsnicmp(Token, L"ConfigVersion", ::wcslen(L"ConfigVersion")))
            {
                PWSTR pwszConfigVersion = ::wcsstr(Token, L"=");
                if (pwszConfigVersion == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after ConfigVersion");
                    goto exit;
                }

                pwszConfigVersion++; // skip "="

                while (*pwszConfigVersion == (L" ")[0]) { ++pwszConfigVersion; } // skip leading white spaces

                DWORD dwVersion = _wtoi(pwszConfigVersion);

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"ConfigVersion",
                                 0,
                                 REG_DWORD,
                                 reinterpret_cast<const LPBYTE>(&dwVersion),
                                 sizeof(DWORD)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"ConfigVersion",
                                 0,
                                 REG_DWORD,
                                 reinterpret_cast<const LPBYTE>(&dwVersion),
                                 sizeof(DWORD));
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "ConfigVersion URL %ws found", m_wDefaultDAUrl);
            }
        else if (!::_wcsnicmp(Token, L"Help", ::wcslen(L"Help")))
            {
                PWSTR pwszHelp = ::wcsstr(Token, L"=");
                if (pwszHelp == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after Help");
                    goto exit;
                }

                pwszHelp++; // skip "="

                while (*pwszHelp == (L" ")[0]) { ++pwszHelp; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"Help",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszHelp),
                                 ::wcslen(pwszHelp) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"Help",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszHelp),
                                 ::wcslen(pwszHelp) * sizeof(WCHAR));
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "Help URL %ws found", m_wDefaultDAUrl);
            }
        else if (!::_wcsnicmp(Token, L"Privacy", ::wcslen(L"Privacy")))
            {
                PWSTR pwszPrivacy = ::wcsstr(Token, L"=");
                if (pwszPrivacy == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after Privacy");
                    goto exit;
                }

                pwszPrivacy++; // skip "="

                while (*pwszPrivacy == (L" ")[0]) { ++pwszPrivacy; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"Privacy",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszPrivacy),
                                 ::wcslen(pwszPrivacy) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"Privacy",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszPrivacy),
                                 ::wcslen(pwszPrivacy) * sizeof(WCHAR));
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "Privacy URL %ws found", m_wDefaultDAUrl);
            }
        else if (!::_wcsnicmp(Token, L"Properties", ::wcslen(L"Properties")))
            {
                PWSTR pwszProperties = ::wcsstr(Token, L"=");
                if (pwszProperties == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after Properties");
                    goto exit;
                }

                pwszProperties++; // skip "="

                while (*pwszProperties == (L" ")[0]) { ++pwszProperties; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"Properties",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszProperties),
                                 ::wcslen(pwszProperties) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"Properties",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszProperties),
                                 ::wcslen(pwszProperties) * sizeof(WCHAR));
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "Properties URL %ws found", m_wDefaultDAUrl);
            }
        else if (!::_wcsnicmp(Token, L"GeneralRedir", ::wcslen(L"GeneralRedir")))
            {
                PWSTR pwszGeneralRedir = ::wcsstr(Token, L"=");
                if (pwszGeneralRedir == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after GeneralRedir");
                    goto exit;
                }

                pwszGeneralRedir++; // skip "="

                while (*pwszGeneralRedir == (L" ")[0]) { ++pwszGeneralRedir; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"GeneralRedir",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszGeneralRedir),
                                 ::wcslen(pwszGeneralRedir) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"GeneralRedir",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszGeneralRedir),
                                 ::wcslen(pwszGeneralRedir) * sizeof(WCHAR));
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "GeneralRedir URL %ws found", m_wDefaultDAUrl);
            }

    next_token:

        Token = ::wcstok(NULL, Delimiters);
    }

exit:
    if (pwszPassportUrls)
    {
        delete [] pwszPassportUrls;
    }
    if (hRequest)
    {
        CloseHandle(hRequest);
    }
    if (hConnect)
    {
        CloseHandle(hConnect);
    }

    return fRetVal;
}

BOOL SESSION::GetRealm(
    PWSTR      pwszRealm,    // user supplied buffer ...
    PDWORD     pdwRealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    ) const
{
    WCHAR wRealm[64];
    DWORD RealmLen = sizeof(wRealm);
    DWORD dwValueType;
    BOOL fRealmFound = FALSE;

    if (m_hKeyCU == NULL || ::RegQueryValueExW(m_hKeyCU, 
                           L"LoginServerRealm",
                           0,
                           &dwValueType,
                           reinterpret_cast<LPBYTE>(&wRealm),
                           &RealmLen) != ERROR_SUCCESS)
    {
        if (m_hKeyLM && ::RegQueryValueExW(m_hKeyLM, 
                               L"LoginServerRealm",
                               0,
                               &dwValueType,
                               reinterpret_cast<LPBYTE>(&wRealm),
                               &RealmLen) == ERROR_SUCCESS)
        {
            fRealmFound = TRUE;
        }
    }
    else
    {
        fRealmFound = TRUE;
    }

    if (!fRealmFound)
    {
        *pdwRealmLen = 0;
        return FALSE;
    }
    
    if (!pwszRealm)
    {
        *pdwRealmLen = ::wcslen(wRealm) + 1;
        return FALSE;
    }
    
    if (*pdwRealmLen < ::wcslen(wRealm) + 1)
    {
        *pdwRealmLen = ::wcslen(wRealm) + 1;
        return FALSE;
    }
    
    ::wcscpy(pwszRealm, wRealm);
    *pdwRealmLen = ::wcslen(wRealm) + 1;

    return TRUE;
}


DWORD SESSION::GetNexusVersion(void)
{
    DWORD dwVersion = 0;
    DWORD dwValueType;
    DWORD dwVerLen = sizeof(dwVersion);
    BOOL fVersionFound = FALSE;

    if (m_hKeyCU == NULL || ::RegQueryValueExW(m_hKeyCU, 
                           L"ConfigVersion",
                           0,
                           &dwValueType,
                           reinterpret_cast<LPBYTE>(&dwVersion),
                           &dwVerLen) != ERROR_SUCCESS)
    {
        if (m_hKeyLM && ::RegQueryValueExW(m_hKeyLM, 
                               L"ConfigVersion",
                               0,
                               &dwValueType,
                               reinterpret_cast<LPBYTE>(&dwVersion),
                               &dwVerLen) == ERROR_SUCCESS)
        {
            fVersionFound = TRUE;
        }
    }
    else
    {
        fVersionFound = TRUE;
    }

    if (fVersionFound)
    {
        return dwVersion;
    }
    else
    {
        return 0;
    }
}

BOOL SESSION::UpdateDAInfo(
    PCWSTR pwszSignIn,
    PCWSTR pwszDAUrl
    )
{
    if (pwszSignIn)
    {
        LPCWSTR pwszDomain = ::wcsstr(pwszSignIn, L"@");
        if (pwszDomain && m_hKeyDAMap)
        {
            DWORD dwError = ::RegSetValueExW(m_hKeyDAMap,
                                             pwszDomain,
                                             0,
                                             REG_SZ,
                                             reinterpret_cast<const LPBYTE>(const_cast<PWSTR>(pwszDAUrl)),
                                             ::wcslen(pwszDAUrl) * sizeof(WCHAR));
            if (dwError == ERROR_SUCCESS)
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL SESSION::PurgeDAInfo(PCWSTR pwszSignIn)
{
    if (pwszSignIn == NULL)
    {
        return TRUE;
    }

    LPCWSTR pwszDomain = ::wcsstr(pwszSignIn, L"@");
    if (pwszDomain && m_hKeyDAMap)
    {
        ::RegDeleteValueW(m_hKeyDAMap, pwszDomain);
        
        return TRUE;
    }

    return FALSE;
}

BOOL SESSION::GetDAInfo(PCWSTR pwszSignIn,
                        LPWSTR pwszDAHostName,
                        DWORD HostNameLen,
                        LPWSTR pwszDAHostObj,
                        DWORD HostObjLen)
{
    LPCWSTR pwszDAUrl = m_wDefaultDAUrl;

    PWSTR pwszDomainDAUrl = NULL;

    if (pwszSignIn)
    {
        LPCWSTR pwszDomain = ::wcsstr(pwszSignIn, L"@");
        if (pwszDomain && m_hKeyDAMap)
        {
            pwszDomainDAUrl = new WCHAR[512];
            if (pwszDomainDAUrl == NULL)
            {
                return FALSE;
            }

            DWORD dwDomainUrlLen = 512 * sizeof(sizeof(WCHAR));
            
            DWORD dwValueType;
            DWORD dwError = ::RegQueryValueExW(m_hKeyDAMap, 
                                               pwszDomain,
                                               0,
                                               &dwValueType,
                                               reinterpret_cast<LPBYTE>(pwszDomainDAUrl),
                                               &dwDomainUrlLen);
            
            PP_ASSERT(!(dwError == ERROR_MORE_DATA));
            // PP_ASSERT(dwValueType == REG_SZ);

            if (dwError == ERROR_SUCCESS)
            {
                pwszDAUrl = pwszDomainDAUrl;
            }
        }
    }

    ::wcscpy(m_wCurrentDAUrl, pwszDAUrl);

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));

    UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);

    UrlComps.lpszHostName = pwszDAHostName;
    UrlComps.dwHostNameLength = HostNameLen;

    UrlComps.lpszUrlPath = pwszDAHostObj;
    UrlComps.dwUrlPathLength = HostObjLen;

    if (CrackUrl(pwszDAUrl, 
                 0, 
                 0, 
                 &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::GetDAInfo() failed; can not crack the URL %ws",
                       pwszDAUrl);
        delete [] pwszDomainDAUrl;
        return FALSE;
    }

    delete [] pwszDomainDAUrl;
    return TRUE;
}


BOOL SESSION::GetCachedCreds(
    PCWSTR	pwszRealm,
    PCWSTR  pwszTarget,
    PCREDENTIALW** pppCreds,
    DWORD* pdwCreds
    )
{
    *pppCreds = NULL;
    *pdwCreds = 0;

    if (m_pfnReadDomainCred == NULL)
    {
        return FALSE;
    }

    ULONG CredTypes = CRED_TYPE_DOMAIN_VISIBLE_PASSWORD;
    DWORD dwFlags = CRED_CACHE_TARGET_INFORMATION;
    CREDENTIAL_TARGET_INFORMATIONW TargetInfo;


    memset ( (void*)&TargetInfo, 0, sizeof(CREDENTIAL_TARGET_INFORMATIONW));

    TargetInfo.TargetName = const_cast<PWSTR>(pwszTarget);
    TargetInfo.DnsDomainName = const_cast<PWSTR>(pwszRealm);
    TargetInfo.PackageName = L"Passport1.4";    

    TargetInfo.Flags = 0;
    TargetInfo.CredTypeCount = 1;
    TargetInfo.CredTypes = &CredTypes;

    if ((*m_pfnReadDomainCred)(&TargetInfo, 
                                dwFlags,
                                pdwCreds,
                                pppCreds ) != TRUE)
    {
        *pppCreds = NULL;
        *pdwCreds = 0;
    }

    // check to see if we've been told to ignore cached creds
    if ( g_fIgnoreCachedCredsForPassport )
    {
        if ( *pppCreds != NULL )
        {
            if (m_pfnCredFree)
            {
                m_pfnCredFree(*pppCreds);
            }
        }

        *pppCreds = NULL;
        *pdwCreds = 0;
    }

    return (*pppCreds != NULL );
}



BOOL SESSION::Open(PCWSTR /*pwszHttpStack*/, HINTERNET)
{
    BOOL fRetVal = FALSE;
    DWORD dwError;
    DWORD dwValueType;
    DWORD dwUrlLen = sizeof(m_wDefaultDAUrl); // note: size of the buffer, not # of UNICODE characters
    BOOL fDAInfoCached = FALSE; // assume NO DA info's cached locally

    dwError = ::RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &m_hKeyLM,
                          NULL);

    if (dwError != ERROR_SUCCESS)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);
        
        // we can't open the Passport key for read & write, let's try open it for read only
        ::RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ,
                          NULL,
                          &m_hKeyLM,
                          NULL);

        // if we still can't open it for read, we are still fine since we can download the info from the
        // Nexus server. *NOTE* m_hKeyLM could be NULL from this point on.
    }

    dwError = ::RegCreateKeyExW(HKEY_CURRENT_USER,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &m_hKeyCU,
                          NULL);

    if (dwError != ERROR_SUCCESS)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);

        ::RegCreateKeyExW(HKEY_CURRENT_USER,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ,
                          NULL,
                          &m_hKeyCU,
                          NULL);
    }

    if (m_hKeyCU)
    {
        dwError = ::RegCreateKeyExW(m_hKeyCU,
                              L"DAMap",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              &m_hKeyDAMap,
                              NULL);

        if (dwError != ERROR_SUCCESS)
        {
            DoTraceMessage(PP_LOG_ERROR, 
                           "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);
        
            ::RegCreateKeyExW(m_hKeyCU,
                              L"DAMap",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ,
                              NULL,
                              &m_hKeyDAMap,
                              NULL);        
        }
    }
    
    if (m_hKeyCU == NULL || ::RegQueryValueExW(m_hKeyCU, 
                           L"LoginServerUrl",
                           0,
                           &dwValueType,
                           reinterpret_cast<LPBYTE>(m_wDefaultDAUrl),
                           &dwUrlLen) != ERROR_SUCCESS)
    {
        if (m_hKeyLM && ::RegQueryValueExW(m_hKeyLM, 
                               L"LoginServerUrl",
                               0,
                               &dwValueType,
                               reinterpret_cast<LPBYTE>(m_wDefaultDAUrl),
                               &dwUrlLen) == ERROR_SUCCESS)
        {
            fDAInfoCached = TRUE;
        }
    }
    else
    {
        fDAInfoCached = TRUE;
    }

    PP_ASSERT(!(dwError == ERROR_MORE_DATA));
    // PP_ASSERT(dwValueType == REG_SZ); BVT break!!!

    if (!fDAInfoCached || (::wcslen(m_wDefaultDAUrl) == ::wcslen(L"")))
    {
        if (GetDAInfoFromPPNexus(FALSE, // don't force connection establishment if nexus not reachable
                                 NULL, 
                                 0, 
                                 NULL, 
                                 0) == FALSE)
        {
            goto exit;
        }
    }
    else
    {
        /*
        URL_COMPONENTSW UrlComps;
        ::memset(&UrlComps, 0, sizeof(UrlComps));

        UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);

        UrlComps.lpszHostName = m_wDAHostName;
        UrlComps.dwHostNameLength = ARRAYSIZE(m_wDAHostName);

        UrlComps.lpszUrlPath = m_wDATargetObj;
        UrlComps.dwUrlPathLength = ARRAYSIZE(m_wDATargetObj);

        if (CrackUrl(m_wDefaultDAUrl, 
                          0, 
                          0, 
                          &UrlComps) == FALSE)
        {
            DoTraceMessage(PP_LOG_ERROR, 
                           "WININET_SESSION::Open() failed; can not crack the URL %ws",
                           m_wDefaultDAUrl);
            goto exit;
        }
        */
    }

    /*
    DWORD dwRegUrlLen = sizeof(m_wRegistrationUrl);
    dwError = ::RegQueryValueExW(m_hKeyLM, 
                       L"RegistrationUrl",
                       0,
                       &dwValueType,
                       reinterpret_cast<LPBYTE>(m_wRegistrationUrl),
                       &dwRegUrlLen);

    PP_ASSERT(!(dwError == ERROR_MORE_DATA));
    */

    m_hCredUI = ::LoadLibraryW(L"advapi32.dll");
    if (m_hCredUI)
    {
        m_pfnReadDomainCred = 
                    reinterpret_cast<PFN_READ_DOMAIN_CRED_W>(::GetProcAddress(m_hCredUI, "CredReadDomainCredentialsW"));
        if (m_pfnReadDomainCred == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "failed to bind to CredReadDomainCredentialsW()"); 
        }

        m_pfnCredFree = 
            reinterpret_cast<PFN_CRED_FREE>(::GetProcAddress(m_hCredUI, "CredFree"));
        if (m_pfnCredFree == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "failed to bind to CredFree()"); 
        }
    }

    fRetVal = TRUE;

exit:

    return fRetVal;
}

void SESSION::Close(void)
{
    if (m_hCredUI)
    {
       ::FreeLibrary(m_hCredUI);
        m_hCredUI = NULL;
    }

    if (m_hKeyDAMap)
    {
        ::RegCloseKey(m_hKeyDAMap);
    }

    if (m_hKeyCU)
    {
        ::RegCloseKey(m_hKeyCU);
    }
    
    if (m_hKeyLM)
    {
        ::RegCloseKey(m_hKeyLM);
    }
}


//
// Implementation for WININET_SESSION
//

// -----------------------------------------------------------------------------
WININET_SESSION::WININET_SESSION(void)
{
    m_hInternet = NULL;

    m_pfnConnect = NULL;
    m_pfnOpenRequest = NULL;
    m_pfnSendRequest = NULL;
    m_pfnQueryInfo = NULL;
    m_pfnCloseHandle = NULL;
    m_pfnSetOption = NULL;
    m_pfnOpenUrl = NULL;
    m_pfnQueryOption = NULL;
    m_pfnCrack = NULL;
    m_pfnReadFile = NULL;
    m_pfnStatusCallback = NULL;
    m_pfnAddHeaders = NULL;
    m_pfnIsHostBypassProxy = NULL;
}

// -----------------------------------------------------------------------------
WININET_SESSION::~WININET_SESSION(void)
{
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::Connect(
    LPCWSTR lpwszServerName,
    INTERNET_PORT nPort)
{
    PP_ASSERT(m_pfnConnect != NULL);

    return (*m_pfnConnect)(m_hInternet, 
                    lpwszServerName, 
                    nPort,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::OpenRequest(
    HINTERNET hConnect,
    LPCWSTR lpwszVerb,
    LPCWSTR lpwszObjectName,
    DWORD dwFlags,
    DWORD_PTR dwContext)
{
    PP_ASSERT(m_pfnOpenRequest != NULL);

    return (*m_pfnOpenRequest)(hConnect,
                               lpwszVerb,
                               lpwszObjectName,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               dwFlags,
							   dwContext);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::SendRequest(
    HINTERNET hRequest,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD_PTR dwContext)
{                                                                 

    PP_ASSERT(m_pfnSendRequest != NULL);

    return (*m_pfnSendRequest)(hRequest,
                        lpwszHeaders,
                        dwHeadersLength,
                        NULL,
                        0);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::QueryHeaders(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex)
{
    PP_ASSERT(m_pfnQueryInfo != NULL);

    return (*m_pfnQueryInfo)(hRequest,
                             dwInfoLevel,
                             lpvBuffer,
                             lpdwBufferLength,
                             lpdwIndex);
}

// -----------------------------------------------------------------------------
BOOL  WININET_SESSION::CloseHandle(
    IN HINTERNET hInternet)
{
    PP_ASSERT(m_pfnCloseHandle != NULL);

    return (*m_pfnCloseHandle)(hInternet);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::QueryOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    LPDWORD lpdwBufferLength)
{
    PP_ASSERT(m_pfnQueryOption != NULL);

    return (*m_pfnQueryOption)(hInternet,
                               dwOption,
                               lpBuffer,
                               lpdwBufferLength
                               );
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::SetOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    DWORD dwBufferLength)
{
    PP_ASSERT(m_pfnSetOption != NULL);

    return (*m_pfnSetOption)(hInternet,
                             dwOption,
                             lpBuffer,
                             dwBufferLength);
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::OpenUrl(
    LPCWSTR lpwszUrl,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD dwFlags)
{
    PP_ASSERT(m_pfnOpenUrl != NULL);

    return (*m_pfnOpenUrl)(m_hInternet,
                           lpwszUrl,
                           lpwszHeaders,
                           dwHeadersLength,
                           dwFlags,
                           0);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::ReadFile(
    HINTERNET hFile,
    LPVOID lpBuffer,
    DWORD dwNumberOfBytesToRead,
    LPDWORD lpdwNumberOfBytesRead)
{
    PP_ASSERT(m_pfnReadFile != NULL);

    return (*m_pfnReadFile)(
                            hFile,
                            lpBuffer,
                            dwNumberOfBytesToRead,
                            lpdwNumberOfBytesRead);
}

BOOL WININET_SESSION::CrackUrl(
    LPCWSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents)
{
    PP_ASSERT (m_pfnCrack != NULL);

    return (*m_pfnCrack)(lpszUrl,
                         dwUrlLength,
                         dwFlags,
                         lpUrlComponents);
}


PVOID WININET_SESSION::SetStatusCallback(
    HINTERNET hInternet,
    PVOID lpfnCallback
    )
{
    PP_ASSERT (m_pfnStatusCallback != NULL);

    return (*m_pfnStatusCallback)(hInternet,
                                  (INTERNET_STATUS_CALLBACK)lpfnCallback);

}

BOOL WININET_SESSION::AddHeaders(
    HINTERNET hConnect,
    LPCWSTR lpszHeaders,
    DWORD dwHeadersLength,
    DWORD dwModifiers
    )
{
    PP_ASSERT(m_pfnAddHeaders != NULL);

    return (*m_pfnAddHeaders)(hConnect,
                              lpszHeaders,
                              dwHeadersLength,
                              dwModifiers
                              );
}


BOOL WININET_SESSION::IsHostBypassProxy(
    INTERNET_SCHEME tScheme, 
    LPCSTR pszHost, 
    DWORD cchHost)
{
    PP_ASSERT(m_pfnIsHostBypassProxy != NULL);

    return (*m_pfnIsHostBypassProxy)(tScheme,
                                     pszHost,
                                     cchHost);
}




BOOL WININET_SESSION::InitHttpApi(PFN_INTERNET_OPEN* ppfnInternetOpen)
{
    BOOL  fRet = FALSE;

    m_pfnCloseHandle =
        reinterpret_cast<PFN_CLOSE_HANDLE>(::GetProcAddress(m_hHttpStack, "InternetCloseHandle"));
    if (m_pfnCloseHandle == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetCloseHandle not found");
        goto exit;
    }

    *ppfnInternetOpen = 
        reinterpret_cast<PFN_INTERNET_OPEN>(::GetProcAddress(m_hHttpStack, "InternetOpenW"));
    if (*ppfnInternetOpen == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetOpenW not found");
        goto exit;
    }

    m_pfnConnect = 
        reinterpret_cast<PFN_INTERNET_CONNECT>(::GetProcAddress(m_hHttpStack, "InternetConnectW"));
    if (m_pfnConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetConnectW not found");
        goto exit;
    }

    m_pfnOpenRequest = 
        reinterpret_cast<PFN_OPEN_REQUEST>(::GetProcAddress(m_hHttpStack, "HttpOpenRequestW"));
    if (m_pfnOpenRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpOpenRequestW not found");
        goto exit;
    }

    m_pfnSendRequest =
        reinterpret_cast<PFN_SEND_REQUEST>(::GetProcAddress(m_hHttpStack, "HttpSendRequestW"));
    if (m_pfnSendRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpSendRequestW not found");
        goto exit;
    }

    m_pfnQueryInfo =
        reinterpret_cast<PFN_QUERY_INFO>(::GetProcAddress(m_hHttpStack, "HttpQueryInfoW"));
    if (m_pfnQueryInfo == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpQueryInfoW not found");
        goto exit;
    }
    
    m_pfnSetOption =
        reinterpret_cast<PFN_SET_OPTION>(::GetProcAddress(m_hHttpStack, "InternetSetOptionW"));
    if (m_pfnSetOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetSetOptionW not found");
        goto exit;
    }

    m_pfnOpenUrl =
        reinterpret_cast<PFN_OPEN_URL>(::GetProcAddress(m_hHttpStack, "InternetOpenUrlW"));
    if (m_pfnOpenUrl == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetOpenUrlW not found");
        goto exit;
    }

    m_pfnQueryOption =
            reinterpret_cast<PFN_QUERY_OPTION>(::GetProcAddress(m_hHttpStack, "InternetQueryOptionW"));
    if (m_pfnQueryOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetQueryOptionW not found");
        goto exit;
    }

    m_pfnCrack =
            reinterpret_cast<PFN_CRACK_URL>(::GetProcAddress(m_hHttpStack, "InternetCrackUrlW"));
        if (m_pfnCrack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetCrackUrlW not found");
        goto exit;
    }

    m_pfnReadFile =
            reinterpret_cast<PFN_READ_FILE>(::GetProcAddress(m_hHttpStack, "InternetReadFile"));
    if (m_pfnReadFile == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetReadFile not found");
        goto exit;
    }

    m_pfnStatusCallback =
        reinterpret_cast<PFN_STATUS_CALLBACK>(::GetProcAddress(m_hHttpStack, "InternetSetStatusCallbackW"));
    if (m_pfnStatusCallback == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetSetStatusCallback not found");
        goto exit;
    }

    m_pfnAddHeaders =
        reinterpret_cast<PFN_ADD_HEADERS>(::GetProcAddress(m_hHttpStack, "HttpAddRequestHeadersW"));
    if (m_pfnAddHeaders == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpAddRequestHeaders not found");
        goto exit;
    }

    m_pfnIsHostBypassProxy =
        reinterpret_cast<PFN_IS_HOST_BYPASS_PROXY>(::GetProcAddress(m_hHttpStack, "IsHostInProxyBypassList"));
    if (m_pfnIsHostBypassProxy == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point IsHostInProxyBypassList not found");
        goto exit;
    }


    fRet = TRUE;

exit:
    return fRet;
}

BOOL WININET_SESSION::Open(
    PCWSTR pwszHttpStack,
    HINTERNET hInternet
    )
{
    PP_ASSERT(pwszHttpStack != NULL);

    DWORD dwErrorCode;
    BOOL  fRet = FALSE;
    PFN_INTERNET_OPEN pfnInternetOpen = NULL;

    PP_ASSERT(m_hHttpStack == 0);
    m_hHttpStack = ::LoadLibraryW(pwszHttpStack);
    if (m_hHttpStack == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to load library %ws; error = %d", pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (InitHttpApi(&pfnInternetOpen) == FALSE)
    {
        goto exit;
    }

    if (hInternet)
    {
        m_hInternet = hInternet;
        m_fOwnedSession = FALSE;
    }
    else
    {
        m_hInternet = (*pfnInternetOpen)(
                                         L"Microsoft.NET-Passport-Authentication-Service/1.4",
                                         INTERNET_OPEN_TYPE_PRECONFIG,
                                         NULL,
                                         NULL,
                                         0 /*INTERNET_FLAG_ASYNC*/ // biaow-todo: use async
                                         );
        (*m_pfnSetOption)(m_hInternet, INTERNET_OPTION_EXEMPT_CONNECTION_LIMIT, NULL, 0);

        m_fOwnedSession = TRUE;
    }
    if (m_hInternet == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to open an HTTP session through %ws; error = %d", 
                       pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (SESSION::Open(pwszHttpStack, hInternet) == FALSE)
    {
        goto exit;
    }
    
    fRet = TRUE;

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session opened");

exit:
    if (!fRet)
    {
        if (m_hInternet && m_fOwnedSession)
        {
            (*m_pfnCloseHandle)(m_hInternet);
            m_hInternet = NULL;
        }
        if (m_hHttpStack)
        {
           ::FreeLibrary(m_hHttpStack);
            m_hHttpStack = NULL;
        }
        
        DoTraceMessage(PP_LOG_ERROR, "WinInet Http Session failed");
    }

    return fRet;
}

void WININET_SESSION::Close(void)
{
    PP_ASSERT(m_pfnCloseHandle);
    if (m_hInternet && m_fOwnedSession)
    {
        (*m_pfnCloseHandle)(m_hInternet);
        m_pfnCloseHandle = NULL;
    }

    if (m_hHttpStack)
    {
       ::FreeLibrary(m_hHttpStack);
        m_hHttpStack = NULL;
    }

    SESSION::Close();

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session closed");
}

#ifdef PP_DEMO
BOOL WININET_SESSION::ContactPartner(PCWSTR pwszPartnerUrl,
                                     PCWSTR pwszVerb,
                                     PCWSTR pwszHeaders,
                                     PWSTR  pwszData,
                                     PDWORD pdwDataLength
                                     )
{
    BOOL fRet = FALSE;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    WCHAR ServerName[128];
    WCHAR ObjectPath[1024];

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));
    
    UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);
    
    UrlComps.lpszHostName = ServerName;
    UrlComps.dwHostNameLength = ARRAYSIZE(ServerName);

    UrlComps.lpszUrlPath = ObjectPath;
    UrlComps.dwUrlPathLength = ARRAYSIZE(ObjectPath);

    PP_ASSERT(m_pfnCrack != NULL);

    if ((*m_pfnCrack)(pwszPartnerUrl, 
                      0, 
                      0, 
                      &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not crack the URL %ws",
                       pwszPartnerUrl);
        goto exit;
    }

    PP_ASSERT(m_pfnConnect != NULL);

    hConnect = (*m_pfnConnect)(m_hInternet, 
                    UrlComps.lpszHostName, 
                    UrlComps.nPort,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);
    if (hConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not open an HTTP sesstion to %ws:%d",
                       UrlComps.lpszHostName, UrlComps.nPort);
        goto exit;
    }

    PP_ASSERT(m_pfnOpenRequest != NULL);

    hRequest = (*m_pfnOpenRequest)(hConnect,
                               pwszVerb,
                               UrlComps.lpszUrlPath,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               INTERNET_FLAG_NO_AUTO_REDIRECT | INTERNET_FLAG_NO_AUTH,
                               0);
    if (hRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not open an HTTP request to %ws:(%ws)",
                       UrlComps.lpszUrlPath, pwszVerb);
        goto exit;
    }

    PP_ASSERT(m_pfnSendRequest != NULL);

    if ((*m_pfnSendRequest)(hRequest,
                        pwszHeaders,
                        0,
                        NULL,
                        0) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not send an HTTP request");

        goto exit;
    }

    if (pwszData == NULL)
    {
        fRet = TRUE;
        goto exit;
    }
    
    DWORD dwStatus, dwStatusLen;
    dwStatusLen = sizeof(dwStatus);
    if (!QueryHeaders(hRequest, 
                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                      &dwStatus,
                      &dwStatusLen))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not query status code");
        goto exit;
    }

    if (dwStatus != HTTP_STATUS_REDIRECT)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; expecting %d but get %d",
                       HTTP_STATUS_REDIRECT, dwStatus);
        goto exit;
    }

    ::wcscpy(pwszData, L"WWW-Authenticate: ");
    if(!QueryHeaders(hRequest,
                     HTTP_QUERY_WWW_AUTHENTICATE, 
                     (LPVOID)(pwszData + ::wcslen(L"WWW-Authenticate: ")),
                     pdwDataLength))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; no auth headers found");
        goto exit;
    }

    (*m_pfnCloseHandle)(hRequest);
    hRequest = NULL;
    (*m_pfnCloseHandle)(hConnect);
    hConnect = NULL;
    
    fRet = TRUE;

exit:
    if (hRequest)
    {
        (*m_pfnCloseHandle)(hRequest);
        hRequest = NULL;
    }

    if (hConnect)
    {
        (*m_pfnCloseHandle)(hConnect);
        hConnect = NULL;
    }

    return fRet;
}
#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\passport\logon.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Logon.cpp

Abstract:


Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"
#include "passport.h"
typedef int INTERNET_SCHEME;
#include "session.h"
#include "ole2.h"
#include "logon.h"
#include "wincrypt.h"

#define SIZE_OF_SALT  37
#define SALT_SHIFT     2

WCHAR g_szSalt[] = L"82BD0E67-9FEA-4748-8672-D5EFE5B779B0";

// #include "wininet.h"
#define INTERNET_MAX_USER_NAME_LENGTH   128

#include "shlwapi.h"
#include <stdio.h>

// #include "logon.tmh"

#define HTTP_STATUS_DENIED              401 // access denied
#define HTTP_STATUS_OK                  200 // request completed

#define HTTP_QUERY_FLAG_NUMBER          0x20000000
#define HTTP_QUERY_STATUS_CODE          19  // special: part of status line
#define HTTP_QUERY_AUTHENTICATION_INFO  76
#define HTTP_QUERY_WWW_AUTHENTICATE     40
#define HTTP_QUERY_RAW_HEADERS_CRLF             22  // special: all headers
#define HTTP_QUERY_PASSPORT_CONFIG              78


// NOTE*** below we assume(!) the WinInet & WinHttp shared the same error VALUE

#define ERROR_HTTP_HEADER_NOT_FOUND     12150L
#define ERROR_INTERNET_INVALID_CA       12045L
#define INTERNET_OPTION_SECURITY_FLAGS  31

#define SECURITY_FLAG_IGNORE_REVOCATION         0x00000080
#define SECURITY_FLAG_IGNORE_UNKNOWN_CA         0x00000100
#define SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200

#define INTERNET_FLAG_IGNORE_CERT_CN_INVALID    0x00001000 // bad common name in X509 Cert.
#define INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  0x00002000 // expired X509 Cert.

#define SECURITY_FLAG_IGNORE_CERT_CN_INVALID    INTERNET_FLAG_IGNORE_CERT_CN_INVALID
#define SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  INTERNET_FLAG_IGNORE_CERT_DATE_INVALID

#define SECURITY_SET_MASK       (SECURITY_FLAG_IGNORE_REVOCATION |\
                                 SECURITY_FLAG_IGNORE_UNKNOWN_CA |\
                                 SECURITY_FLAG_IGNORE_CERT_CN_INVALID |\
                                 SECURITY_FLAG_IGNORE_CERT_DATE_INVALID |\
                                 SECURITY_FLAG_IGNORE_WRONG_USAGE)

#define INTERNET_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "
#define INTERNET_DEFAULT_HTTPS_PORT     443         //    "     "  HTTPS  "
#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  0x00004000 // ex: http:// to https://
#define INTERNET_STATUS_REDIRECT                110

#define HTTP_ADDREQ_FLAG_ADD        0x20000000
#define HTTP_ADDREQ_FLAG_REPLACE    0x80000000

#define INTERNET_FLAG_SECURE            0x00800000  // use PCT/SSL if applicable (HTTP)

#define INTERNET_STATUS_COOKIE_SENT             320
#define INTERNET_STATUS_COOKIE_RECEIVED         321

typedef struct {

    int         cSession;           // Session cookies received
    int         cPersistent;        // Persistent cookies received

    int         cAccepted;          // Number of cookies accepted
    int         cLeashed;           //               ... leashed
    int         cDowngraded;        //               ... converted to session-cookies
    int         cBlocked;           //               ... rejected

    const char *pszLocation;        // Optional: URL associated with reported cookie events
                                    // This can be used to override request URL
}
IncomingCookieState;

typedef struct {

    int     cSent;           
    int     cSuppressed;

    const char *pszLocation;        // Optional: URL associated with reported cookie events
                                    // This can be used to override request URL
}
OutgoingCookieState;

LOGON::LOGON(SESSION* pSession, DWORD dwParentFlags)
    : m_pSession(pSession)
{
    m_pSession->AddRef();

    m_hConnect = NULL;
    
    m_fCredsPresent = FALSE;
    m_pwszSignIn = NULL;
    m_pwszPassword = NULL;

    m_pwszTicketRequest = NULL;
    m_pwszAuthInfo = NULL;
    m_pwszReturnUrl = NULL;

    m_hBitmap = NULL;
    m_fPrompt = FALSE;

    m_wTimeSkew[0] = L'\0';
    m_wNewDAUrl[0] = 0;
    m_dwParentFlags = dwParentFlags;

    m_p401Content = NULL;

    m_pwszCbtxt = NULL;

    InitializeListHead(&m_PrivacyEventList);
}

LOGON::~LOGON(void)
{
    while (!IsListEmpty(&m_PrivacyEventList)) 
    {
        PLIST_ENTRY pEntry = RemoveHeadList(&m_PrivacyEventList);
        
        PRIVACY_EVENT* pEvent = (PRIVACY_EVENT*)pEntry;

        if (pEvent->dwStatus == INTERNET_STATUS_COOKIE_SENT)
        {
            delete [] ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation;
            ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation = NULL;
        }
        else
        {
            delete [] ((IncomingCookieState*)(pEvent->lpvInfo))->pszLocation;
            ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation = NULL;
        }

        delete [] pEvent->lpvInfo;
        
        delete pEvent;
    }

    if (m_pwszAuthInfo)
    {
        delete [] m_pwszAuthInfo;
    }
    if (m_pwszSignIn)
    {
        delete [] m_pwszSignIn;
    }
    if (m_pwszPassword)
    {
        delete [] m_pwszPassword;
    }
    if (m_pwszTicketRequest)
    {
        delete [] m_pwszTicketRequest;
    }
    if (m_pwszAuthHeader)
    {
        delete [] m_pwszAuthHeader;
    }
    m_pSession->RemoveRef();
    if (m_p401Content)
    {
        m_p401Content->Release();
    }

    if (m_pwszCbtxt)
    {
        delete [] m_pwszCbtxt;
    }

    if (m_hBitmap)
        DeleteObject(m_hBitmap);
}

// -----------------------------------------------------------------------------
BOOL LOGON::Open(
    PCWSTR	pwszPartnerInfo // in the form of "WWW-Authenticate: Passport1.4 ..."
    )
{
    PP_ASSERT(pwszPartnerInfo != NULL);

    // locate the auth scheme name, i.e. Passport1.4
    
    PCWSTR pwszTicketRequest = ::wcsstr(pwszPartnerInfo, L"Passport1.4");
    if (pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; Passport1.4 scheme not found");
        return FALSE;
    }
    
    pwszTicketRequest += ::wcslen(L"Passport1.4");
    
    // skip white spaces between the scheme name and the Ticket Request (TR)

    while (*pwszTicketRequest == (L" ")[0]) { ++pwszTicketRequest; }
    
    if (pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; Ticket Request missing");
        return FALSE;
    }
    
    // save the TR
    
    DWORD dwTrLen = ::wcslen(pwszTicketRequest);
    m_pwszTicketRequest = new WCHAR[dwTrLen + 1];
    if (m_pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; not enough memory");
        return FALSE;
    }
    ::wcscpy(m_pwszTicketRequest, pwszTicketRequest);

    m_pwszAuthHeader = new WCHAR[dwTrLen + 
                                 2048 + // Prepared for long creds
                                 512 + // some more head room
                                 1]; 
    if (m_pwszAuthHeader == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; not enough memory");
        return FALSE;
    }


    DoTraceMessage(PP_LOG_INFO, "LOGON::Open() succeed");

    return TRUE;
}

void LOGON::Close(void)
{
    PP_ASSERT(m_hConnect != NULL);
    PP_ASSERT(m_pSession != NULL);

    m_pSession->CloseHandle(m_hConnect);
    m_hConnect = NULL;
}



// pClearPassword is assumed to be at least 256 chars

void DecryptPassword ( WCHAR* pClearPassword, PVOID pPassword, DWORD cbSize )
{
    BOOL bOrigEncrypted = FALSE;

    DATA_BLOB InBlob;
    DATA_BLOB OutBlob;
    LPWSTR pszDesc;

    if ( pClearPassword == NULL )
        return;

    if ( cbSize == 0 )
    {
        // CryptUnprotectData doesn't like to be sent a zero-length buffer
        pClearPassword[0] = L'\0';
        return;		
    }

    InBlob.pbData = (BYTE*)pPassword;
    InBlob.cbData = cbSize;

    DATA_BLOB EntropyBlob;
    WCHAR szSalt[SIZE_OF_SALT];
    wcscpy ( szSalt, g_szSalt);
    for ( int i = 0; i < SIZE_OF_SALT; i++ )
        szSalt[i] <<= SALT_SHIFT;
    EntropyBlob.pbData = (BYTE*)szSalt;
    EntropyBlob.cbData = sizeof(WCHAR)*(wcslen(szSalt)+1);

    // Should be assumed that client won't get this far without
    // having initialized for SSL via LoadSecurity().

    if ( CryptUnprotectData ( &InBlob,
                            &pszDesc,
                            &EntropyBlob,
//                            NULL,
                            NULL,
                            NULL,
                            CRYPTPROTECT_UI_FORBIDDEN,
                            &OutBlob ) )
    {

        if ( wcscmp (L"SSOCred", pszDesc) == 0 )
        {
            DWORD dwOutChars = OutBlob.cbData/sizeof(WCHAR);
            if ( dwOutChars < 256 )
            {
                wcsncpy ( pClearPassword, (WCHAR*)OutBlob.pbData, dwOutChars );
                pClearPassword[dwOutChars] = L'\0';
            }
            bOrigEncrypted = TRUE;
        }
        LocalFree ( pszDesc );
        LocalFree ( OutBlob.pbData );
    }

    memset ( szSalt, 0, SIZE_OF_SALT);

    if ( !bOrigEncrypted )
    {
        // copy the plain text
        wcsncpy ( pClearPassword, (WCHAR*)pPassword, 256 );
        pClearPassword[cbSize/sizeof(WCHAR)] = L'\0';
    }

    return;
}



void LOGON::GetCachedCreds(
	PCWSTR	pwszRealm,
    PCWSTR  pwszTarget,
    PCREDENTIALW** pppCreds,
    DWORD* pdwCreds
    )
{
    if (m_pSession->GetCachedCreds(pwszRealm,pwszTarget,pppCreds,pdwCreds) != FALSE)
    {
        PCREDENTIALW pCredToUse = *pppCreds[0];
        ::FileTimeToSystemTime(&(pCredToUse->LastWritten), &m_TimeCredsEntered);
    }
}

// -----------------------------------------------------------------------------
BOOL LOGON::SetCredentials(
    PCWSTR      pwszRealm,
    PCWSTR      pwszTarget,
    PCWSTR      pwszSignIn,
    PCWSTR      pwszPassword,
    PSYSTEMTIME pTimeCredsEntered
    )
{
    WCHAR wPass[256];
    PCREDENTIALW* ppCred = NULL;
    DWORD dwCreds = 0;
    PCREDENTIALW pCredToUse = NULL;

    if ((!pwszSignIn) && (!pwszPassword))
    {
        pTimeCredsEntered = NULL; // invalidate this parameter if cached creds are to be used

        GetCachedCreds(pwszRealm, pwszTarget, &ppCred, &dwCreds);

        if (dwCreds > 0 && ppCred[0] != NULL )
        {
            for ( DWORD idx = 0; idx < dwCreds; idx++ )
            {
                if ( ppCred[idx]->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD )
                {
                    // check to see if prompt bit is set.   If set, keep looking, only use if
                    // the prompt bit isn't set.
                    if ( !(ppCred[idx]->Flags & CRED_FLAGS_PROMPT_NOW) )
                    {
                        pCredToUse = ppCred[idx];
                        break;
                    }
                }
            }
        }

        if (pCredToUse == NULL)
        {
            return FALSE;
        }

        DecryptPassword(wPass, 
                  PVOID(pCredToUse->CredentialBlob), 
                  pCredToUse->CredentialBlobSize);

        pwszSignIn = pCredToUse->UserName;
        pwszPassword = wPass;
    }
    else
    {
        if (pTimeCredsEntered == NULL)
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::SetCredentials() failed; Timestamp not specified");
            return FALSE;
        }
    }

    if (m_pwszSignIn)
    {
        delete [] m_pwszSignIn;
    }

    DWORD dwSignInLen = ::wcslen(pwszSignIn);
    m_pwszSignIn = new WCHAR[dwSignInLen + 1];
    if (m_pwszSignIn == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::SetCredentials() failed; not enough memory");
        return FALSE;
    }

    ::wcscpy(m_pwszSignIn, pwszSignIn);

    if (m_pwszPassword)
    {
        delete [] m_pwszPassword;
    }

    DWORD dwPasswordLen = ::wcslen(pwszPassword);
    m_pwszPassword = new WCHAR[dwPasswordLen + 1];
    if (m_pwszPassword == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::SetCredentials() failed; not enough memory");
        delete [] m_pwszSignIn;
        m_pwszSignIn = NULL;
        return FALSE;
    }

    ::wcscpy(m_pwszPassword, pwszPassword);

    if (pTimeCredsEntered)
    {
        m_TimeCredsEntered = *pTimeCredsEntered;
    }
    
    m_fCredsPresent = TRUE;

    if (ppCred)
    {
        if (m_pSession->m_pfnCredFree)
        {
            m_pSession->m_pfnCredFree(ppCred);
        }
    }

    return TRUE;
}

BOOL Gif2Bmp(LPSTREAM pStream, HBITMAP* phBmp);
// -----------------------------------------------------------------------------
BOOL LOGON::DownLoadCoBrandBitmap(
    PWSTR pwszChallenge
    )
{
    PP_ASSERT(pwszChallenge != NULL);

    PWSTR pwszCbUrl = NULL;
    BOOL fRet = FALSE;

    WCHAR Delimiters[] = L",";
    PWSTR Token = ::wcstok(pwszChallenge, Delimiters);
    while (Token != NULL)
    {
        // skip leading white spaces
        while (*Token == (L" ")[0]) { ++Token; }
        if (Token == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no text in between commas");
            goto next_token;
        }

        // find cburl
        if (!::_wcsnicmp(Token, L"cburl", ::wcslen(L"cburl")))
        {
            PWSTR CbUrl = ::wcsstr(Token, L"=");
            if (CbUrl == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no = after cburl");
                goto next_token;
            }
            
            CbUrl++; // skip "="

            while (*CbUrl == (L" ")[0]) { ++CbUrl; } // skip leading white spaces

            pwszCbUrl = new WCHAR[::wcslen(CbUrl)+1];
            if (pwszCbUrl == NULL)
            {
                DoTraceMessage(PP_LOG_ERROR, "LOGON::DownLoadCoBrandBitmap() failed; not enough memory");
                goto exit;
            }
            ::wcscpy(pwszCbUrl, CbUrl);

            DoTraceMessage(PP_LOG_INFO, "CoBrand URL %ws found", pwszCbUrl);
        }
        else if (!::_wcsnicmp(Token, L"ts", ::wcslen(L"ts")))
        {
            ::wcscpy(m_wTimeSkew, Token);
        }
        else if (!::_wcsnicmp(Token, L"srealm", ::wcslen(L"srealm")))
        {
            PWSTR pwszRealm = ::wcsstr(Token, L"=");
            if (pwszRealm == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no = after cburl");
                goto next_token;
            }
            
            pwszRealm++; // skip "="

            while (*pwszRealm == (L" ")[0]) { ++pwszRealm; } // skip leading white spaces

            ::wcscpy( m_wRealm, pwszRealm);
		
            DoTraceMessage(PP_LOG_INFO, "sRealm URL %ws found", pwszCbUrl);
        }
        else if (!::_wcsnicmp(Token, L"cbtxt", ::wcslen(L"cbtxt")))
        {
            PWSTR pwszCbTxt = ::wcsstr(Token, L"=");
            if (pwszCbTxt == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no = after cbtxt");
                goto next_token;
            }
            
            pwszCbTxt++; // skip "="

            while (*pwszCbTxt == (L" ")[0]) { ++pwszCbTxt; } // skip leading white spaces

            if (m_pwszCbtxt)
            {
                delete [] m_pwszCbtxt;
            }

            m_pwszCbtxt = new WCHAR[wcslen(pwszCbTxt)+1];
            if (m_pwszCbtxt)
            {
                ::wcscpy( m_pwszCbtxt, pwszCbTxt);

                DoTraceMessage(PP_LOG_INFO, "cbtxt %ws found", m_pwszCbtxt);
            }
        }


    next_token:

        Token = ::wcstok(NULL, Delimiters);
    }

    if (pwszCbUrl)
    {
        HINTERNET hCbUrl = m_pSession->OpenUrl(pwszCbUrl, NULL, 0, 0);
        if (hCbUrl == NULL)
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "LOGON::DownLoadCoBrandBitmap() failed; can not open URL %ws",
                           pwszCbUrl);
            goto exit;
        }

        {
            LPSTREAM pStream;

            if (CreateStreamOnHGlobal(NULL, TRUE, &pStream) != S_OK)
            {
                DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed");
                m_pSession->CloseHandle(hCbUrl);

                goto exit;
            }

            {
                DWORD cbRead = 0;
                PBYTE bBuf = new BYTE[1024];
                if (bBuf == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed; out of memory");
                    m_pSession->CloseHandle(hCbUrl);

                    goto exit;
                }

                DWORD cbBuf = 1024;
                
                while (m_pSession->ReadFile(hCbUrl, bBuf, cbBuf, &cbRead) && cbRead)
                    pStream->Write(bBuf, cbRead, NULL);

                delete [] bBuf;
            }

            LARGE_INTEGER Zero = {0};
            pStream->Seek(Zero, STREAM_SEEK_SET, NULL); // seek to the beginning of the stream

            DoTraceMessage(PP_LOG_INFO, "CoBrand Graphic %ws downloaded", pwszCbUrl);
            
            if (m_hBitmap)
            {
                DeleteObject(m_hBitmap);
                m_hBitmap = NULL;
            }

            if (Gif2Bmp(pStream, &m_hBitmap) == FALSE)
            {
                DoTraceMessage(PP_LOG_ERROR, "Gif2Bmp() failed");
                m_pSession->CloseHandle(hCbUrl);

                goto exit;
            }

            pStream->Release();
            m_pSession->CloseHandle(hCbUrl);

            fRet = TRUE;

            DoTraceMessage(PP_LOG_INFO, "CoBrand Bitmap created");
        }
    }

exit:
    if (pwszCbUrl)
    {
        delete [] pwszCbUrl;
    }

    return fRet;
}

// -----------------------------------------------------------------------------
DWORD LOGON::Handle401FromDA(
    HINTERNET   hRequest, 
    BOOL        fTicketRequest
    )
{
    PP_ASSERT(hRequest != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    PWSTR pwszRawHeaders = NULL;
    PSTR  pszRawHeaders = NULL;
    PWSTR  pwszChallenge = NULL;
    PWSTR  pwszChallengeEnd = NULL;
    DWORD ChallengeLength = 0;

    if(m_pSession->QueryHeaders(hRequest,
                                HTTP_QUERY_RAW_HEADERS_CRLF, 
                                0,
                                &ChallengeLength) == FALSE)
    {
        if ((::GetLastError() != ERROR_INSUFFICIENT_BUFFER) || (ChallengeLength == 0))
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; QueryHeaders() failed; Error Code = %d",
                           dwErrorCode);
            goto exit;
        }
    }
    else
    {
        PP_ASSERT(TRUE); // control should not reach here
    }

    pwszRawHeaders = new WCHAR[ChallengeLength];
    if (pwszRawHeaders == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; out of memory");
        goto exit;
    }

    if(m_pSession->QueryHeaders(hRequest,
                                HTTP_QUERY_RAW_HEADERS_CRLF, 
                                pwszRawHeaders,
                                &ChallengeLength) == FALSE)
    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; QueryHeaders() failed; Error Code = %d",
                       dwErrorCode);
        goto exit;
    }

    if ((pwszChallenge = ::wcsstr(pwszRawHeaders, L"Passport1.4")) == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; Passport1.4 auth header not found");
        goto exit;
    }

    if (pwszChallengeEnd = ::wcsstr(pwszChallenge, L"\r\n"))
    {
        *pwszChallengeEnd = 0;
    }
    
    if (::wcsstr(pwszChallenge, L"noretry"))
    {
        dwRetVal = PP_LOGON_FAILED; // Login Request Failed; bad news!
        DoTraceMessage(PP_LOG_WARNING, "Handle401FromDA() : Logon failed");
    }
    else if (::wcsstr(pwszChallenge, L"retry"))
    {
        // biaow-todo: not yet implemented
        PP_ASSERT(TRUE); // shouldn't reach here
        dwRetVal = PP_LOGON_REQUIRED;
    }
    else if (::wcsstr(pwszChallenge, L"failed"))
    {
        // if (fTicketRequest)
        // {
        dwRetVal = PP_LOGON_REQUIRED;
        DoTraceMessage(PP_LOG_INFO, "Handle401FromDA() : Logon required by DA");
        // }
        // else
        // {
        //     dwRetVal = PP_LOGON_FAILED; // Login Request Failed; bad news!
        //     DoTraceMessage(PP_LOG_WARNING, "Handle401FromDA() : Logon failed");
        // }
    }
    else
    {
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; no valid DA status");
        goto exit;
    }

    if (dwRetVal == PP_LOGON_REQUIRED || dwRetVal == PP_LOGON_FAILED)
    {
        if (::wcsstr(pwszChallenge, L"prompt"))
        {
            m_fPrompt = TRUE;
        }
        else
        {
            m_fPrompt = FALSE;
        }

        if (CreateStreamOnHGlobal(NULL, TRUE, &m_p401Content) != S_OK)
        {
            DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed");
            goto exit;
        }

        if (pwszChallengeEnd)
        {
            PP_ASSERT(*pwszChallengeEnd == 0);
            *pwszChallengeEnd = L'\r';
        }

        pszRawHeaders = new CHAR[2048];
        if (pszRawHeaders == NULL)
        {
            DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed, out of memory");
            goto exit;
        }

        ::WideCharToMultiByte(CP_ACP, 0, pwszRawHeaders, -1, pszRawHeaders, 2048, NULL, NULL);

        m_p401Content->Write(pszRawHeaders, strlen(pszRawHeaders), NULL);

        {
            DWORD cbRead = 0;
            PBYTE bBuf = new BYTE [1024];
            if (bBuf == NULL)
            {
                DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed, out of memory");
                goto exit;
            }
            DWORD cbBuf = 1024;
            
            while (m_pSession->ReadFile(hRequest, bBuf, cbBuf, &cbRead) && cbRead)
                m_p401Content->Write(bBuf, cbRead, NULL);

            delete [] bBuf;
        }

        LARGE_INTEGER Zero = {0};
        m_p401Content->Seek(Zero, STREAM_SEEK_SET, NULL); // seek to the beginning of the stream
    
        if (pwszChallengeEnd)
        {
            *pwszChallengeEnd = 0;
        }


        DownLoadCoBrandBitmap(pwszChallenge);
    }

exit:

    if (pwszRawHeaders)
    {
        delete [] pwszRawHeaders;
    }

    if (pszRawHeaders)
    {
        delete [] pszRawHeaders;
    }
    
    return dwRetVal;
}

// -----------------------------------------------------------------------------
DWORD LOGON::Handle200FromDA(
    HINTERNET hRequest
    )
{
    PP_ASSERT(hRequest != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    
    PWSTR pwszBuffer = NULL;
    DWORD dwBuffer = 0;
    if((!m_pSession->QueryHeaders(hRequest,
                                  HTTP_QUERY_AUTHENTICATION_INFO, 
                                  pwszBuffer,
                                  &dwBuffer))
       && (::GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        pwszBuffer = new WCHAR[dwBuffer];
        if (pwszBuffer == NULL)
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
            goto exit;
        }

        if (!m_pSession->QueryHeaders(hRequest,
                                      HTTP_QUERY_AUTHENTICATION_INFO, 
                                      pwszBuffer,
                                      &dwBuffer))
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; no Authenticate-Info header found");
            goto exit;
        }

        WCHAR Delimiters[] = L",";
        PWSTR Token = ::wcstok(pwszBuffer, Delimiters);
        while (Token != NULL)
        {
            while (*Token == (L" ")[0]) { ++Token; }
            if (Token == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::Handle200FromDA() : no text in between commas");
                goto next_token;
            }

            if (!::_wcsnicmp(Token, L"ru", ::wcslen(L"ru")))
            {
                PWSTR ReturnUrl = ::wcsstr(Token, L"=");
                if (ReturnUrl == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() : no = after cburl");
                    goto exit;
                }
                ReturnUrl++; // skip =
                
                while (*ReturnUrl == (L" ")[0]) { ++ReturnUrl; }  // skip leading white spaces
                
                m_pwszReturnUrl = new WCHAR[::wcslen(ReturnUrl)+1];
                if (m_pwszReturnUrl == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
                    goto exit;
                }

                ::wcscpy(m_pwszReturnUrl, ReturnUrl);
            }
            else if (!::_wcsnicmp(Token, L"from-pp", ::wcslen(L"from-pp")))
            {
                m_pwszAuthInfo = new WCHAR[::wcslen(Token)+1];
                if (m_pwszAuthInfo == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
                    goto exit;
                }

                ::wcscpy(m_pwszAuthInfo, Token);
            }

        next_token:

            Token = ::wcstok(NULL, Delimiters);
        }

        dwRetVal = PP_LOGON_SUCCESS;
        g_fCurrentProcessLoggedOn = TRUE;

    }
    else
    {
        PP_ASSERT(TRUE); // shouldn't reach here
        goto exit;
    }

exit:

    if (pwszBuffer)
    {
        delete [] pwszBuffer;
    }

    return dwRetVal;
}

void LOGON::CheckForVersionChange(
    HINTERNET hRequest
    )
{
    WCHAR wszBuffer[256];
    DWORD dwBufferLen = sizeof(wszBuffer) / sizeof(WCHAR);
    BOOL fDownloadNewNexusConfig = FALSE;
    
    if (!m_pSession->QueryHeaders(hRequest,
                                  HTTP_QUERY_PASSPORT_CONFIG, 
                                  wszBuffer,
                                  &dwBufferLen))
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::CheckForVersionChange() failed; no PassportConfig header found");
        goto exit;
    }

    WCHAR Delimiters[] = L",";
    PWSTR Token = ::wcstok(wszBuffer, Delimiters);
    while (Token != NULL)
    {
        // skip leading white spaces
        while (*Token == (L" ")[0]) { ++Token; }
        if (Token == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "LOGON::CheckForVersionChange() : no text in between commas");
            goto next_token;
        }

        if (!::_wcsnicmp(Token, L"ConfigVersion", ::wcslen(L"ConfigVersion")))
        {
            PWSTR pwszConfigVersion = ::wcsstr(Token, L"=");
            if (pwszConfigVersion == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::CheckForVersionChange() : no = after ConfigVersion");
                goto next_token;
            }
            
            pwszConfigVersion++; // skip "="

            while (*pwszConfigVersion == (L" ")[0]) { ++pwszConfigVersion; } // skip leading white spaces

            if ((DWORD)_wtoi(pwszConfigVersion) > m_pSession->GetNexusVersion())
            {
                fDownloadNewNexusConfig = TRUE;
            }
		
            DoTraceMessage(PP_LOG_INFO, "ConfigVersion URL %ws found", pwszConfigVersion);
        }

    next_token:

        Token = ::wcstok(NULL, Delimiters);
    }

    if (fDownloadNewNexusConfig)
    {
        m_pSession->GetDAInfoFromPPNexus(FALSE, // don't force connection establishment if nexus not reachable
                                         NULL, 
                                         0, 
                                         NULL, 
                                         0);
    }

exit:
    return;
}


VOID PrvLogonStatusCallback(    
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation,
    IN DWORD dwStatusInformationLength
)
{
    LOGON* pLogon = reinterpret_cast<LOGON*>(dwContext);

    pLogon->StatusCallback(hInternet,
                           dwInternetStatus,
                           lpvStatusInformation,
                           dwStatusInformationLength);


}

VOID LOGON::StatusCallback(
    IN HINTERNET hInternet,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation,
    IN DWORD dwStatusInformationLength)
{
    if (dwInternetStatus == INTERNET_STATUS_REDIRECT)
    {
        ::wcscpy(m_wNewDAUrl, (LPCWSTR)lpvStatusInformation);
        BOOL fRet = m_pSession->AddHeaders(hInternet, 
                               m_pwszAuthHeader, 
                               ::wcslen(m_pwszAuthHeader),
                               HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE
                               );

        PP_ASSERT(fRet == TRUE);
    }
    else if ((dwInternetStatus == INTERNET_STATUS_COOKIE_SENT) || 
             (dwInternetStatus == INTERNET_STATUS_COOKIE_RECEIVED))
    {
        PVOID lpvInfo = new BYTE [dwStatusInformationLength];
        if (lpvInfo == 0)
        {
            return;
        }
        memcpy(lpvInfo, lpvStatusInformation, dwStatusInformationLength); 
        
        LPCWSTR pwszLocation = m_wNewDAUrl[0] ? m_wNewDAUrl : m_pSession->GetCurrentDAUrl();
        LPSTR   pszLocation = NULL;
        DWORD dwLocationLen = 0;
        if (dwLocationLen = wcslen(pwszLocation))
        {
            pszLocation = new CHAR[dwLocationLen + 1];
            if (pszLocation == 0)
            {
                return;
            }
            ::WideCharToMultiByte(CP_ACP, 0, pwszLocation, -1, pszLocation, dwLocationLen + 1, NULL, NULL);

            if (dwInternetStatus == INTERNET_STATUS_COOKIE_SENT)
            {
                ((OutgoingCookieState*)lpvInfo)->pszLocation = pszLocation;
            }
            else
            {
                ((IncomingCookieState*)lpvInfo)->pszLocation = pszLocation;
            }
        }

        PRIVACY_EVENT* pEvent = new PRIVACY_EVENT;
        if (pEvent != NULL)
        {
            pEvent->dwStatus = dwInternetStatus;
            pEvent->lpvInfo = lpvInfo;
            pEvent->dwInfoLength = dwStatusInformationLength;

            InsertTailList(&m_PrivacyEventList, &(pEvent->List));
        }
    }
}

BOOL LOGON::GetLogonHost(
    PWSTR       pwszHostName,
    OUT PDWORD  pdwHostNameLen
    ) const
{
    if (*pdwHostNameLen < DWORD(::wcslen(m_wDAHostName) + 1))
    {
        *pdwHostNameLen = ::wcslen(m_wDAHostName) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszHostName != NULL);

    ::wcscpy(pwszHostName, m_wDAHostName);

    *pdwHostNameLen = ::wcslen(m_wDAHostName) + 1;

    return TRUE;
}

BOOL PPEscapeUrl(LPCSTR lpszStringIn,
                 LPSTR lpszStringOut,
                 DWORD* pdwStrLen,
                 DWORD dwMaxLength,
                 DWORD dwFlags);

// -----------------------------------------------------------------------------
DWORD LOGON::Logon(
    BOOL fAnonymous
    )
{
    PP_ASSERT(m_pSession != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    BOOL fTicketRequest;
    HINTERNET hRequest = 0;
    DWORD dwFlags = 0;

    ::wcscpy(m_pwszAuthHeader, L"Authorization: Passport1.4 ");

    if (m_fCredsPresent && !fAnonymous)
    {
        if (m_pSession->GetNexusVersion() >= 10)
        {
            DWORD dwUTF8CredLen = max(::wcslen(m_pwszSignIn), ::wcslen(m_pwszPassword)) * 3;
            DWORD dwEscCredLen  = dwUTF8CredLen * 3;
            DWORD dwActualEscCredLen;

            PSTR pszUTF8Cred = new CHAR[dwUTF8CredLen];
            if (pszUTF8Cred == NULL)
            {
                goto exit;
            }
            PSTR pszEscCred  = new CHAR[dwEscCredLen];
            if (pszEscCred == NULL)
            {
                delete [] pszUTF8Cred;
                goto exit;
            }
            PWSTR pwszEscCred = new WCHAR[dwEscCredLen];
            if (pwszEscCred == NULL)
            {
                delete [] pszEscCred;
                delete [] pszUTF8Cred;
                goto exit;
            }

            ::WideCharToMultiByte(CP_UTF8, 0, m_pwszSignIn, -1, pszUTF8Cred, dwUTF8CredLen, NULL, NULL);
            ::PPEscapeUrl(pszUTF8Cred, pszEscCred, &dwActualEscCredLen, dwEscCredLen, 0);
            int cchEscCred = ::MultiByteToWideChar(CP_ACP, 0, pszEscCred, -1, pwszEscCred, dwEscCredLen);

            if ((cchEscCred - 1) > 1024)
            {
                pwszEscCred[1024] = L'\0';
            }

            ::wcscat(m_pwszAuthHeader, L"sign-in=");
            ::wcscat(m_pwszAuthHeader, pwszEscCred);
            ::wcscat(m_pwszAuthHeader, L",");

            ::WideCharToMultiByte(CP_UTF8, 0, m_pwszPassword, -1, pszUTF8Cred, dwUTF8CredLen, NULL, NULL);
            ::PPEscapeUrl(pszUTF8Cred, pszEscCred, &dwActualEscCredLen, dwEscCredLen, 0);
            cchEscCred = ::MultiByteToWideChar(CP_ACP, 0, pszEscCred, -1, pwszEscCred, dwEscCredLen); 

            if ((cchEscCred - 1) > 1024)
            {
                pwszEscCred[1024] = L'\0';
            }

            ::wcscat(m_pwszAuthHeader, L"pwd=");
            ::wcscat(m_pwszAuthHeader, pwszEscCred);
            ::wcscat(m_pwszAuthHeader, L",");

            delete [] pwszEscCred;
            delete [] pszEscCred;
            delete [] pszUTF8Cred;
        }
        else
        {
            if (::wcslen(m_pwszSignIn) > 1024)
            {
                m_pwszSignIn[1024] = L'\0';
            }

            ::wcscat(m_pwszAuthHeader, L"sign-in=");
            ::wcscat(m_pwszAuthHeader, m_pwszSignIn);
            ::wcscat(m_pwszAuthHeader, L",");

            if (::wcslen(m_pwszPassword) > 1024)
            {
                m_pwszPassword[1024] = L'\0';
            }
        
            ::wcscat(m_pwszAuthHeader, L"pwd=");
            ::wcscat(m_pwszAuthHeader, m_pwszPassword);
            ::wcscat(m_pwszAuthHeader, L",");
        }

        FILETIME ftCredsEntered;
        ::SystemTimeToFileTime(&m_TimeCredsEntered, &ftCredsEntered);

        SYSTEMTIME stCurrent;
        ::GetSystemTime(&stCurrent);
        FILETIME ftCurrent;
        ::SystemTimeToFileTime(&stCurrent, &ftCurrent);
        
        LONGLONG llElapsedTime;
        llElapsedTime = (*(LONGLONG *)&ftCurrent) - (*(LONGLONG *)&ftCredsEntered);
        llElapsedTime /= (LONGLONG)10000000;
        DWORD dwElapsedTime = (DWORD)llElapsedTime;
        WCHAR wElapsedTime[16];
        ::wsprintfW(wElapsedTime, L"%d", dwElapsedTime);

        ::wcscat(m_pwszAuthHeader, L"elapsed-time=");
        ::wcscat(m_pwszAuthHeader, wElapsedTime);
        ::wcscat(m_pwszAuthHeader, L",");
        
        if (m_wTimeSkew[0])
        {
            ::wcscat(m_pwszAuthHeader, m_wTimeSkew);
            ::wcscat(m_pwszAuthHeader, L",");
        }

        fTicketRequest = FALSE; // this is a login request, since we've gather credentials

        // save off the sign-in name
        if ( ::wcslen ( m_pwszSignIn ) < INTERNET_MAX_USER_NAME_LENGTH )  
            ::wcscpy ( g_szUserNameLoggedOn, m_pwszSignIn );

    }
    else
    {
        ::wcscat(m_pwszAuthHeader, L"tname = , ");
        
        fTicketRequest = TRUE;
    }
    
    ::wcscat(m_pwszAuthHeader, m_pwszTicketRequest);

retry:

    // attempt connecting to the Passport DA

    if (m_hConnect)
    {
        m_pSession->CloseHandle(m_hConnect);
    }

    WCHAR       wDATargetObj[256];
    
    DWORD fStstus = m_pSession->GetDAInfo(m_pwszSignIn,
                                          m_wDAHostName, 256,
                                          wDATargetObj, 256);

    if (fStstus == FALSE)
    {
        goto exit;
    }
    
    m_hConnect = m_pSession->Connect(m_wDAHostName/*m_pSession->GetLoginHost()*/,
#ifdef DISABLE_SSL
                    INTERNET_DEFAULT_HTTP_PORT
#else
                    INTERNET_DEFAULT_HTTPS_PORT
#endif
                                     );
    if (m_hConnect == NULL)
    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; can not connect to %ws, Error = %d",
                       m_wDAHostName, dwErrorCode);
        goto exit;
    }
    if (hRequest)
    {
        m_pSession->CloseHandle(hRequest);
    }

    dwFlags = m_dwParentFlags;

    hRequest = m_pSession->OpenRequest(m_hConnect,
                                       NULL, // "GET"
                                       wDATargetObj/*m_pSession->GetLoginTarget()*/,
#ifdef DISABLE_SSL
                                       dwFlags | INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS,
#else                                                 
                                                 dwFlags | INTERNET_FLAG_SECURE,
#endif
                                       (DWORD_PTR)this
                                       );
    if (hRequest == NULL)

    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; OpenRequest() to %ws failed, Error Code = %d",
                       wDATargetObj, dwErrorCode);
        goto exit;
    }
    
    m_wNewDAUrl[0] = 0;
    m_pSession->SetStatusCallback(hRequest, PrvLogonStatusCallback);
    
    if (!m_pSession->SendRequest(hRequest, 
                                 m_pwszAuthHeader, 
                                 ::wcslen(m_pwszAuthHeader),
                                 (DWORD_PTR)this))
    {
        DWORD dwErrorCode = ::GetLastError();

#ifdef BAD_CERT_OK
        if (dwErrorCode == ERROR_INTERNET_INVALID_CA)
        {
            DWORD dwSecFlags;
            DWORD dwSecurityFlagsSize = sizeof(dwSecFlags);

            if (!m_pSession->QueryOption(hRequest, 
                                    INTERNET_OPTION_SECURITY_FLAGS,
                                    &dwSecFlags,
                                    &dwSecurityFlagsSize))
            {
                dwSecFlags = 0;
            }
            else
            {
                dwSecFlags |= SECURITY_SET_MASK;
            }

            if (!m_pSession->SetOption(hRequest, 
                                      INTERNET_OPTION_SECURITY_FLAGS, 
                                      &dwSecFlags, 
                                      dwSecurityFlagsSize))
            {
                PP_ASSERT(TRUE); // shouldn't reach here
                goto exit;
            }
            else
            {
                if (!m_pSession->SendRequest(hRequest, NULL, 0))
                {
                    dwErrorCode = ::GetLastError();
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; SendRequest() failed, Error Code = %d",
                                   dwErrorCode);
                    goto exit;
                }
                else
                {
                    dwErrorCode = ERROR_SUCCESS;
                }
            }
        }
#endif // BAD_CERT_OK
        
        if (dwErrorCode != ERROR_SUCCESS)
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; SendRequest() failed, Error Code = %d",
                           dwErrorCode);

            m_pSession->PurgeDAInfo(m_pwszSignIn);

            if (m_pSession->GetDAInfoFromPPNexus(FALSE, // don't force connection establishment if nexus not reachable
                                                 NULL, 
                                                 0, 
                                                 NULL, 
                                                 0) == TRUE)
            {
                goto retry;
            }

            goto exit;
        }
    }

    {
        DWORD dwStatus, dwStatusLen;
        dwStatusLen = sizeof(dwStatus);
        if (!m_pSession->QueryHeaders(hRequest,
                                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                                      &dwStatus,
                                      &dwStatusLen))
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; can not retrieve Status Code, Error Code = %d",
                           dwErrorCode);
            goto exit;
        }
    
        if (dwStatus == HTTP_STATUS_DENIED)
        {
            dwRetVal = Handle401FromDA(hRequest, fTicketRequest);
        }
        else if (dwStatus == HTTP_STATUS_OK)
        {
            dwRetVal = Handle200FromDA(hRequest);
        }
        else
        {
            //PP_ASSERT(TRUE); // shouldn't reach here
            //goto exit;
        }

        CheckForVersionChange(hRequest);

        if (dwRetVal == PP_GENERIC_ERROR)
        {
            m_pSession->PurgeDAInfo(m_pwszSignIn);
            
            if (m_pSession->GetDAInfoFromPPNexus(FALSE, // don't force connection establishment if nexus not reachable
                                                 NULL, 
                                                 0, 
                                                 NULL, 
                                                 0) == TRUE)
            {
                goto retry;
            }
        }
        else
        {
            if (m_wNewDAUrl[0])
            {
                m_pSession->UpdateDAInfo(m_pwszSignIn,
                                         m_wNewDAUrl);
                m_wNewDAUrl[0] = 0;
            }
        }
    }

exit:

    if (hRequest)
    {
        m_pSession->CloseHandle(hRequest);
    }
    
    return dwRetVal;
}

// -----------------------------------------------------------------------------
BOOL LOGON::GetChallengeInfo(
	HBITMAP*		 phBitmap,
	PBOOL			 pfPrompt,
	PWSTR			 pwszCbText,
    PDWORD           pdwTextLen,
    PWSTR            pwszRealm,
    DWORD            dwMaxRealmLen,
    PWSTR            pwszReqUserName,
    PDWORD           pdwReqUserNameLen

    ) const
{
    if (phBitmap)
    {
        *phBitmap = m_hBitmap;
    }
    if (pfPrompt)
    {
        *pfPrompt = m_fPrompt;
    }

	// *pdwTextLen = 0; // biaow-todo:
    
    if (pwszRealm)
    {
        ::wcsncpy(pwszRealm, m_wRealm, dwMaxRealmLen-1);
    }

    if (m_pwszCbtxt == NULL)
    {
        if (pdwTextLen)
        {
            // tell them how much is needed
            *pdwTextLen = 0;
        }

        goto CheckReqUserName;
    }

    if (pwszCbText && pdwTextLen )
    {
        // only copy if they gave us enough bytes.
        if ( *pdwTextLen >= ::wcslen(m_pwszCbtxt) ) 
            ::wcsncpy(pwszCbText, m_pwszCbtxt, *pdwTextLen);
    }

    if (pdwTextLen)
    {
        // tell them how much is needed
        *pdwTextLen = ::wcslen(m_pwszCbtxt);
	}


CheckReqUserName:

    // username
    if (pdwReqUserNameLen)
    {
        if (m_fPrompt && g_fCurrentProcessLoggedOn)
        {
            if ( *pdwReqUserNameLen >= ::wcslen (g_szUserNameLoggedOn) )
            {
                if ( pwszReqUserName != NULL )
                {
                    wcsncpy ( pwszReqUserName, g_szUserNameLoggedOn, *pdwReqUserNameLen );
                }

            }

            // tell them how much is needed
            *pdwReqUserNameLen = ::wcslen (g_szUserNameLoggedOn) + 1;
        }
        else
        {
            // nothing is needed
            *pdwReqUserNameLen = 0;
        }

    }
    
    return TRUE;
}

BOOL LOGON::GetChallengeContent(
    PBYTE    	     pContent,
    OUT PDWORD       pdwContentLen
    ) const
{
    if (m_p401Content == NULL)
    {
        *pdwContentLen = 0;
        return FALSE;
    }

    HGLOBAL hContent;
    if (GetHGlobalFromStream(m_p401Content, &hContent) != S_OK)
    {
        *pdwContentLen = 0;
        return FALSE;
    }

    DWORD dwContentLen = (DWORD)GlobalSize(hContent);
    if (*pdwContentLen < dwContentLen)
    {
        *pdwContentLen = dwContentLen;
        return FALSE;
    }

    LPVOID pvContent = GlobalLock(hContent);
    memcpy(pContent, pvContent, dwContentLen);
    GlobalUnlock(hContent);

    *pdwContentLen = dwContentLen;
    
    return TRUE;
}

// -----------------------------------------------------------------------------
BOOL LOGON::GetAuthorizationInfo(
    PWSTR   pwszTicket,
    PDWORD  pdwTicketLen,
    PBOOL   pfKeepVerb,
    PWSTR   pwszUrl,
    PDWORD  pdwUrlLen 
    ) const
{
    if (*pdwTicketLen < DWORD(::wcslen(m_pwszAuthInfo) + 1))
    {
        *pdwTicketLen = ::wcslen(m_pwszAuthInfo) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszTicket != NULL);

    ::wcscpy(pwszTicket, m_pwszAuthInfo);
    *pdwTicketLen = ::wcslen(m_pwszAuthInfo) + 1;
    
    if (m_pwszReturnUrl == NULL)
    {
        if (pfKeepVerb)
        {
            *pfKeepVerb = TRUE;
        }
        *pdwUrlLen = 0;
        return TRUE;
    }

    if (*pdwUrlLen < DWORD(::wcslen(m_pwszReturnUrl) + 1))
    {
        *pdwUrlLen = ::wcslen(m_pwszReturnUrl) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszUrl != NULL);

    ::wcscpy(pwszUrl, m_pwszReturnUrl);

    if (pfKeepVerb)
    {
        *pfKeepVerb = FALSE;
    }

    *pdwUrlLen = ::wcslen(m_pwszReturnUrl) + 1;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\passport\loadgif.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\loadgif.cpp
//
//  Contents: gif decoder, copied from direct animation source: danim\src\appel\util\loadgif.cpp
//
//------------------------------------------------------------------------------------
//#include <wininetp.h>

//bw #include "headers.h"

// #define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ole2.h>
#include <math.h>


#include <windowsx.h>

/*lint ++flb*/

//bw DeclareTag(tagImageDecode, "Image Decode", "Image Decode Filters");

const long COLORKEY_NOT_SET = -1;

/*-- 
Structs from IE img.hxx 
--*/

void * __cdecl
_calloc(size_t num, size_t size)
{
    void * pv = malloc(num * size);
    if (NULL == pv)
    {
        return NULL;
    }
    ZeroMemory(pv, num * size);
    return pv;
}

enum
{
    gifNoneSpecified =  0, // no disposal method specified
    gifNoDispose =      1, // do not dispose, leave the bits there
    gifRestoreBkgnd =   2, // replace the image with the background color
    gifRestorePrev =    3  // replace the image with the previous pixels
};

typedef struct _GCEDATA // data from GIF Graphic control extension
{
    unsigned int uiDelayTime;           // frame duration, initialy 1/100ths seconds
                                    // converted to milliseconds
    unsigned int uiDisposalMethod;      // 0 - none specified.
                                    // 1 - do not dispose - leave bits in place.
                                    // 2 - replace with background color.
                                    // 3 - restore previous bits
                                    // >3 - not yet defined
    BOOL                  fTransparent;         // TRUE is ucTransIndex describes transparent color
    unsigned char ucTransIndex;         // transparent index

} GCEDATA; 

typedef struct _GIFFRAME
{
    struct _GIFFRAME    *pgfNext;
    GCEDATA                             gced;           // animation parameters for frame.
    int                                 top;            // bounds relative to the GIF logical screen 
    int                                 left;
    int                                 width;
    int                                 height;
    unsigned char               *ppixels;       // pointer to image pixel data
    int                                 cColors;        // number of entries in pcolors
    PALETTEENTRY                *pcolors;
    PBITMAPINFO                 pbmi;
    HRGN                                hrgnVis;                // region describing currently visible portion of the frame
    int                                 iRgnKind;               // region type for hrgnVis
} GIFFRAME, *PGIFFRAME;

typedef struct {
    BOOL        fAnimating;                 // TRUE if animation is (still) running
    DWORD       dwLoopIter;                 // current iteration of looped animation, not actually used for Netscape compliance reasons
    _GIFFRAME * pgfDraw;                    // last frame we need to draw
    DWORD       dwNextTimeMS;               // Time to display pgfDraw->pgfNext, or next iteration
} GIFANIMATIONSTATE, *PGIFANIMATIONSTATE;

#define dwGIFVerUnknown     ((DWORD)0)   // unknown version of GIF file
#define dwGIFVer87a         ((DWORD)87)  // GIF87a file format
#define dwGIFVer89a        ((DWORD)89)  // GIF89a file format.

typedef struct _GIFANIMDATA
{
    BOOL                        fAnimated;                      // TRUE if cFrames and pgf define a GIF animation
    BOOL                        fLooped;                        // TRUE if we've seen a Netscape loop block
    BOOL                        fHasTransparency;       // TRUE if a frame is transparent, or if a frame does
                                        // not cover the entire logical screen.
    BOOL            fNoBWMapping;       // TRUE if we saw more than two colors in anywhere in the file.
    DWORD           dwGIFVer;           // GIF Version <see defines above> we need to special case 87a backgrounds
    unsigned short      cLoops;                         // A la Netscape, we will treat this as 
                                        // "loop forever" if it is zero.
    PGIFFRAME           pgf;                            // animation frame entries
    PALETTEENTRY        *pcolorsGlobal;         // GIF global colors - NULL after GIF prepared for screen
    PGIFFRAME       pgfLastProg;        // remember the last frame to be drawn during decoding
    DWORD           dwLastProgTimeMS;   // time at which pgfLastProg was displayed.

} GIFANIMDATA, *PGIFANIMDATA;

/** End Structs **/
 
#define MAXCOLORMAPSIZE     256

#define TRUE    1
#define FALSE   0

#define CM_RED      0
#define CM_GREEN    1
#define CM_BLUE     2

#define MAX_LWZ_BITS        12

#define INTERLACE       0x40
#define LOCALCOLORMAP   0x80
#define BitSet(byte, bit)   (((byte) & (bit)) == (bit))

#define LM_to_uint(a,b)         ((((unsigned int) b)<<8)|((unsigned int)a))

#define dwIndefiniteGIFThreshold 300    // 300 seconds == 5 minutes
                                        // If the GIF runs longer than
                                        // this, we will assume the author
                                        // intended an indefinite run.
#define dwMaxGIFBits 13107200           // keep corrupted GIFs from causing
                                        // us to allocate _too_ big a buffer.
                                        // This one is 1280 X 1024 X 10.

typedef struct _GIFSCREEN
{
        unsigned long Width;
        unsigned long Height;
        unsigned char ColorMap[3][MAXCOLORMAPSIZE];
        unsigned long BitPixel;
        unsigned long ColorResolution;
        unsigned long Background;
        unsigned long AspectRatio;
}
GIFSCREEN;

typedef struct _GIF89
{
        long transparent;
        long delayTime;
        long inputFlag;
        long disposal;
}
GIF89;

#define MAX_STACK_SIZE  ((1 << (MAX_LWZ_BITS)) * 2)
#define MAX_TABLE_SIZE  (1 << MAX_LWZ_BITS)
typedef struct _GIFINFO
{
    IStream *stream;
    GIF89 Gif89;
    long lGifLoc;
    long ZeroDataBlock;

/*
 **  Pulled out of nextCode
 */
    long curbit, lastbit, get_done;
    long last_byte;
    long return_clear;
/*
 **  Out of nextLWZ
 */
    unsigned short *pstack, *sp;
    long stacksize;
    long code_size, set_code_size;
    long max_code, max_code_size;
    long clear_code, end_code;

/*
 *   Were statics in procedures
 */
    unsigned char buf[280];
    unsigned short *table[2];
    long tablesize;
    long firstcode, oldcode;

} GIFINFO,*PGIFINFO;

/*
 DirectAnimation wrapper class for GIF info
*/
class CImgGif
{
   // Class methods
   public:
      CImgGif();
      ~CImgGif();

      unsigned char * ReadGIFMaster();
      BOOL Read(unsigned char *buffer, long len);
      long ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE]);
      long DoExtension(long label);
      long GetDataBlock(unsigned char *buf);
      unsigned char * ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame);
      long readLWZ();
      long nextLWZ();
      long nextCode(long code_size);
      BOOL initLWZ(long input_code_size);
      unsigned short *  growStack();
      BOOL growTables();
      BITMAPINFO * FinishDithering();

   // Data members
   public:
      LPCSTR              _szFileName;
      BOOL                _fInterleaved;
      BOOL                _fInvalidateAll;
      int                 _yLogRow;
      GIFINFO             _gifinfo;
      GIFANIMATIONSTATE   _gas;
      GIFANIMDATA         _gad;
      PALETTEENTRY        _ape[256];
      int                 _xWidth;
      int                 _yHeight;
      LONG                _lTrans;
      BYTE *              _pbBits;

} GIFIMAGE;


CImgGif::CImgGif() {
   _gifinfo.pstack = NULL;
   _gifinfo.table[0] = NULL;
   _gifinfo.table[1] = NULL;
}

CImgGif::~CImgGif() {
   free(_gifinfo.pstack);
   free(_gifinfo.table[0]);
   free(_gifinfo.table[1]);
   PGIFFRAME nextPgf, curPgf;
   curPgf = _gad.pgf;
   while(curPgf != NULL) {
      nextPgf = curPgf->pgfNext;
      free(curPgf->ppixels);
      free(curPgf->pcolors);
      free(curPgf->pbmi);
      free(curPgf);
      curPgf = nextPgf;
   }
}

static int GetColorMode() { return 0; };

#ifndef DEBUG
#pragma optimize("t",on)
#endif

BOOL CImgGif::Read(unsigned char *buffer, long len)
{
   DWORD lenout = 0;
   /* read len characters into buffer */
   _gifinfo.stream->Read(buffer,len,&lenout);

   return ((long)lenout == len);
}

long CImgGif::ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE])
{
        long i;
        unsigned char rgb[3];

        for (i = 0; i < number; ++i)
        {
                if (!Read(rgb, sizeof(rgb)))
                {
                        //bw //bw TraceTag((tagImageDecode, "bad gif colormap."));
                        return (TRUE);
                }
                buffer[CM_RED][i] = rgb[0];
                buffer[CM_GREEN][i] = rgb[1];
                buffer[CM_BLUE][i] = rgb[2];
        }
        return FALSE;
}

long
CImgGif::GetDataBlock(unsigned char *buf)
{
   unsigned char count;

   count = 0;
   if (!Read(&count, 1))
   {
          return -1;
   }
   _gifinfo.ZeroDataBlock = count == 0;

   if ((count != 0) && (!Read(buf, count)))
   {
          return -1;
   }

   return ((long) count);
}

#define MIN_CODE_BITS 5
#define MIN_STACK_SIZE 64
#define MINIMUM_CODE_SIZE 2

BOOL CImgGif::initLWZ(long input_code_size)
{
   if(input_code_size < MINIMUM_CODE_SIZE)
     return FALSE;

   _gifinfo.set_code_size = input_code_size;
   _gifinfo.code_size = _gifinfo.set_code_size + 1;
   _gifinfo.clear_code = 1 << _gifinfo.set_code_size;
   _gifinfo.end_code = _gifinfo.clear_code + 1;
   _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
   _gifinfo.max_code = _gifinfo.clear_code + 2;

   _gifinfo.curbit = _gifinfo.lastbit = 0;
   _gifinfo.last_byte = 2;
   _gifinfo.get_done = FALSE;

   _gifinfo.return_clear = TRUE;
    
    if(input_code_size >= MIN_CODE_BITS)
        _gifinfo.stacksize = ((1 << (input_code_size)) * 2);
    else
        _gifinfo.stacksize = MIN_STACK_SIZE;

        if ( _gifinfo.pstack != NULL )
                free( _gifinfo.pstack );
        if ( _gifinfo.table[0] != NULL  )
                free( _gifinfo.table[0] );
        if ( _gifinfo.table[1] != NULL  )
                free( _gifinfo.table[1] );

 
    _gifinfo.table[0] = 0;
    _gifinfo.table[1] = 0;
    _gifinfo.pstack = 0;

    _gifinfo.pstack = (unsigned short *) malloc((_gifinfo.stacksize)*sizeof(unsigned short));
    if(_gifinfo.pstack == 0){
        goto ErrorExit;
    }    
    _gifinfo.sp = _gifinfo.pstack;

    // Initialize the two tables.
    _gifinfo.tablesize = (_gifinfo.max_code_size);

    _gifinfo.table[0] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    _gifinfo.table[1] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    if((_gifinfo.table[0] == 0) || (_gifinfo.table[1] == 0)){
        goto ErrorExit;
    }

    return TRUE;

   ErrorExit:
    if(_gifinfo.pstack){
        free(_gifinfo.pstack);
        _gifinfo.pstack = 0;
    }

    if(_gifinfo.table[0]){
        free(_gifinfo.table[0]);
        _gifinfo.table[0] = 0;
    }

    if(_gifinfo.table[1]){
        free(_gifinfo.table[1]);
        _gifinfo.table[1] = 0;
    }

    return FALSE;
}

long CImgGif::nextCode(long code_size)
{
   static const long maskTbl[16] =
   {
          0x0000, 0x0001, 0x0003, 0x0007,
          0x000f, 0x001f, 0x003f, 0x007f,
          0x00ff, 0x01ff, 0x03ff, 0x07ff,
          0x0fff, 0x1fff, 0x3fff, 0x7fff,
   };
   long i, j, ret, end;
   unsigned char *buf = &_gifinfo.buf[0];

   if (_gifinfo.return_clear)
   {
          _gifinfo.return_clear = FALSE;
          return _gifinfo.clear_code;
   }

   end = _gifinfo.curbit + code_size;

   if (end >= _gifinfo.lastbit)
   {
          long count;

          if (_gifinfo.get_done)
          {
                  return -1;
          }
          buf[0] = buf[_gifinfo.last_byte - 2];
          buf[1] = buf[_gifinfo.last_byte - 1];

          if ((count = GetDataBlock(&buf[2])) == 0)
                  _gifinfo.get_done = TRUE;
          if (count < 0)
          {
                  return -1;
          }
          _gifinfo.last_byte = 2 + count;
          _gifinfo.curbit = (_gifinfo.curbit - _gifinfo.lastbit) + 16;
          _gifinfo.lastbit = (2 + count) * 8;

          end = _gifinfo.curbit + code_size;

   // Okay, bug 30784 time. It's possible that we only got 1
   // measly byte in the last data block. Rare, but it does happen.
   // In that case, the additional byte may still not supply us with
   // enough bits for the next code, so, as Mars Needs Women, IE
   // Needs Data.
   if ( end >= _gifinfo.lastbit && !_gifinfo.get_done )
   {
      // protect ourselve from the ( theoretically impossible )
      // case where between the last data block, the 2 bytes from
      // the block preceding that, and the potential 0xFF bytes in
      // the next block, we overflow the buffer.
      // Since count should always be 1,
      //bw Assert ( count == 1 );
      // there should be enough room in the buffer, so long as someone
      // doesn't shrink it.
      if ( count + 0x101 >= sizeof( _gifinfo.buf ) )
      {
          //bw Assert ( FALSE ); // 
          return -1;
      }

              if ((count = GetDataBlock(&buf[2 + count])) == 0)
                      _gifinfo.get_done = TRUE;
              if (count < 0)
              {
                      return -1;
              }
              _gifinfo.last_byte += count;
              _gifinfo.lastbit = _gifinfo.last_byte * 8;

              end = _gifinfo.curbit + code_size;
   }
   }

   j = end / 8;
   i = _gifinfo.curbit / 8;

   if (i == j)
          ret = buf[i];
   else if (i + 1 == j)
          ret = buf[i] | (((long) buf[i + 1]) << 8);
   else
          ret = buf[i] | (((long) buf[i + 1]) << 8) | (((long) buf[i + 2]) << 16);

   ret = (ret >> (_gifinfo.curbit % 8)) & maskTbl[code_size];

   _gifinfo.curbit += code_size;

        return ret;
}

// Grows the stack and returns the top of the stack.
unsigned short *
CImgGif::growStack()
{
    long index;
    unsigned short *lp;
    
        if (_gifinfo.stacksize >= MAX_STACK_SIZE) return 0;

	index = long(_gifinfo.sp - _gifinfo.pstack);
    lp = (unsigned short *)realloc(_gifinfo.pstack, (_gifinfo.stacksize)*2*sizeof(unsigned short));
    if(lp == 0)
        return 0;
        
    _gifinfo.pstack = lp;
    _gifinfo.sp = &(_gifinfo.pstack[index]);
    _gifinfo.stacksize = (_gifinfo.stacksize)*2;
    lp = &(_gifinfo.pstack[_gifinfo.stacksize]);
    return lp;
}

BOOL
CImgGif::growTables()
{
    unsigned short *lp;

    lp = (unsigned short *) realloc(_gifinfo.table[0], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[0] = lp;
    
    lp = (unsigned short *) realloc(_gifinfo.table[1], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[1] = lp;

    return TRUE;

}

inline
long CImgGif::readLWZ()
{
   return((_gifinfo.sp > _gifinfo.pstack) ? *--(_gifinfo.sp) : nextLWZ());
}

#define CODE_MASK 0xffff
long CImgGif::nextLWZ()
{
        long code, incode;
        unsigned short usi;
        unsigned short *table0 = _gifinfo.table[0];
        unsigned short *table1 = _gifinfo.table[1];
        unsigned short *pstacktop = &(_gifinfo.pstack[_gifinfo.stacksize]);

        while ((code = nextCode(_gifinfo.code_size)) >= 0)
        {
                if (code == _gifinfo.clear_code)
                {
                        /* corrupt GIFs can make this happen */
                        if (_gifinfo.clear_code >= (1 << MAX_LWZ_BITS))
                        {
                                return -2;
                        }

                
                        _gifinfo.code_size = _gifinfo.set_code_size + 1;
                        _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
                        _gifinfo.max_code = _gifinfo.clear_code + 2;

            if(!growTables())
                return -2;
                        
            table0 = _gifinfo.table[0];
            table1 = _gifinfo.table[1];

                        _gifinfo.tablesize = _gifinfo.max_code_size;


                        for (usi = 0; usi < _gifinfo.clear_code; ++usi)
                        {
                                table1[usi] = usi;
                        }
                        memset(table0,0,sizeof(unsigned short )*(_gifinfo.tablesize));
                        memset(&table1[_gifinfo.clear_code],0,sizeof(unsigned short)*((_gifinfo.tablesize)-_gifinfo.clear_code));
                        _gifinfo.sp = _gifinfo.pstack;
                        do
                        {
                                _gifinfo.firstcode = _gifinfo.oldcode = nextCode(_gifinfo.code_size);
                        }
                        while (_gifinfo.firstcode == _gifinfo.clear_code);

                        return _gifinfo.firstcode;
                }
                if (code == _gifinfo.end_code)
                {
                        long count;
                        unsigned char buf[260];

                        if (_gifinfo.ZeroDataBlock)
                        {
                                return -2;
                        }

                        while ((count = GetDataBlock(buf)) > 0)
                                ;

                        if (count != 0)
                        return -2;
                }

                incode = code;

                if (code >= _gifinfo.max_code)
                {
            if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = (unsigned short)((CODE_MASK ) & (_gifinfo.firstcode));
                        code = _gifinfo.oldcode;
                }

#if FEATURE_FAST
                // (andyp) easy speedup here for ie3.1 (too late for ie3.0):
                //
                // 1. move growStack code out of loop (use max 12-bit/4k slop).
                // 2. do "sp = _gifinfo.sp" so it will get enreg'ed.
                // 3. un-inline growStack (and growTables).
                // 4. change short's to int's (benefits win32) (esp. table1 & table2)
                // (n.b. int not long, so we'll keep win3.1 perf)
                // 5. change long's to int's (benefits win16) (esp. code).
                //
                // together these will make the loop very tight w/ everything kept
                // enregistered and no 66 overrides.
                //
                // one caveat is that on average this loop iterates 4x so it's
                // not clear how much the speedup will really gain us until we
                // look at the outer loop as well.
#endif
                while (code >= _gifinfo.clear_code)
                {
                        if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = table1[code];
                        if (code == (long)(table0[code]))
                        {
                                return (code);
                        }
                        code = (long)(table0[code]);
                }

        if (_gifinfo.sp >= pstacktop){
            pstacktop = growStack();
            if(pstacktop == 0)
                return -2;
        }
                _gifinfo.firstcode = (long)table1[code];
        *(_gifinfo.sp)++ = table1[code];

                if ((code = _gifinfo.max_code) < (1 << MAX_LWZ_BITS))
                {
                        table0[code] = (USHORT)(_gifinfo.oldcode) & CODE_MASK;
                        table1[code] = (USHORT)(_gifinfo.firstcode) & CODE_MASK;
                        ++_gifinfo.max_code;
                        if ((_gifinfo.max_code >= _gifinfo.max_code_size) && (_gifinfo.max_code_size < ((1 << MAX_LWZ_BITS))))
                        {
                                _gifinfo.max_code_size *= 2;
                                ++_gifinfo.code_size;
                                if(!growTables())
                                    return -2;
       
                table0 = _gifinfo.table[0];
                table1 = _gifinfo.table[1];

                // Tables have been reallocated to the correct size but initialization
                // still remains to be done. This initialization is different from
                // the first time initialization of these tables.
                memset(&(table0[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                memset(&(table1[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                _gifinfo.tablesize = (_gifinfo.max_code_size);


                        }
                }

                _gifinfo.oldcode = incode;

                if (_gifinfo.sp > _gifinfo.pstack)
                        return ((long)(*--(_gifinfo.sp)));
        }
        return code;
}

#ifndef DEBUG
// Return to default optimization flags
#pragma optimize("",on)
#endif

unsigned char *
CImgGif::ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame)
{
    unsigned char *dp, c;
    long v;
    long xpos = 0, ypos = 0, pass = 0;
    unsigned char *image;
    long padlen = ((len + 3) / 4) * 4;
    DWORD cbImage = 0;
    char buf[256]; // need a buffer to read trailing blocks ( up to terminator ) into
    //ULONG ulCoversImg = IMGBITS_PARTIAL;

    /*
       **  Initialize the Compression routines
     */
    if (!Read(&c, 1))
    {
        return (NULL);
    }

    /*
       **  If this is an "uninteresting picture" ignore it.
     */

     cbImage = padlen * height * sizeof(char);

     if (   cbImage > dwMaxGIFBits
        ||  (image = (unsigned char *) _calloc(1, cbImage)) == NULL)
    {
         //bw TraceTag((tagImageDecode, "Cannot allocate space for gif image data\n"));
         return (NULL);
    }

        if (c == 1)
        {
                // Netscape seems to field these bogus GIFs by filling treating them
                // as transparent. While not the optimal way to simulate this effect,
                // we'll fake it by pushing the initial code size up to a safe value,
                // consuming the input, and returning a buffer full of the transparent
                // color or zero, if no transparency is indicated.
                if (initLWZ(MINIMUM_CODE_SIZE))
                        while (readLWZ() >= 0);
                else {
          //bw TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
          free(image);
          return (NULL);
        }

                if (_gifinfo.Gif89.transparent != -1)
						FillMemory(image, cbImage, (BYTE)_gifinfo.Gif89.transparent);
                else // fall back on the background color 
                        FillMemory(image, cbImage, 0);
                
                return image;
        }
        else if (initLWZ(c) == FALSE)
        {
                free(image);
        //bw TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
        return NULL;
        }

    if (!fGIFFrame)
        _pbBits = image;

    if (fInterlace)
    {
        long i;
        long pass = 0, step = 8;

        if (!fGIFFrame && (height > 4))
            _fInterleaved = TRUE;

        for (i = 0; i < height; i++)
        {
//              message("readimage, logical=%d, offset=%d\n", i, padlen * ((height-1) - ypos));
            dp = &image[padlen * ((height-1) - ypos)];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            ypos += step;
            while (ypos >= height)
            {
                if (pass++ > 0)
                    step /= 2;
                ypos = step / 2;
                /*if (!fGIFFrame && pass == 1)
                {
                    ulCoversImg = IMGBITS_TOTAL;
                }*/
            }
            if (!fGIFFrame)
            {
                _yLogRow = i;

                /*if ((i & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/

        if (!fGIFFrame && height <= 4)
        {
            _yLogRow = height-1;
        }
    }
    else
    {

        if (!fGIFFrame) 
            _yLogRow = -1;

        for (ypos = height-1; ypos >= 0; ypos--)
        {
            dp = &image[padlen * ypos];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            if (!fGIFFrame)
            {
                _yLogRow++;
//                  message("readimage, logical=%d, offset=%d\n", _yLogRow, padlen * ypos);
                /*if ((_yLogRow & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/
    }

    // consume blocks up to image block terminator so we can proceed to the next image
    while (GetDataBlock((unsigned char *) buf) > 0)
                                ;
    return (image);

abort:
    /*if (!fGIFFrame)
        OnProg(TRUE, ulCoversImg);*/
    return NULL;
}

long CImgGif::DoExtension(long label)
{
    unsigned char buf[256];
    int count;

    switch (label)
    {
        case 0x01:              /* Plain Text Extension */
            break;
        case 0xff:              /* Application Extension */
            // Is it the Netscape looping extension
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 11)
            {
                char *szNSExt = "NETSCAPE2.0";

                if ( memcmp( buf, szNSExt, strlen( szNSExt ) ) == 0 )
                { // if it has their signature, get the data subblock with the iter count
                    count = GetDataBlock((unsigned char *) buf);
                    if ( count >= 3 )
                    {
                        _gad.fLooped = TRUE;
                        _gad.cLoops = (buf[2] << 8) | buf[1];
                    }
                }
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
            break;
        case 0xfe:              /* Comment Extension */
            while (GetDataBlock((unsigned char *) buf) > 0)
            {
                //bw TraceTag((tagImageDecode, "GIF comment: %s\n", buf));                
            }
            return FALSE;
        case 0xf9:              /* Graphic Control Extension */
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 3)
            {
                _gifinfo.Gif89.disposal = (buf[0] >> 2) & 0x7;
                _gifinfo.Gif89.inputFlag = (buf[0] >> 1) & 0x1;
                _gifinfo.Gif89.delayTime = LM_to_uint(buf[1], buf[2]);
                if ((buf[0] & 0x1) != 0)
                    _gifinfo.Gif89.transparent = buf[3];
                else
                    _gifinfo.Gif89.transparent = -1;
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
        default:
            break;
    }

    while (GetDataBlock((unsigned char *) buf) > 0)
        ;

    return FALSE;
}

BOOL IsGifHdr(BYTE * pb)
{
    return(pb[0] == 'G' && pb[1] == 'I' && pb[2] == 'F'
        && pb[3] == '8' && (pb[4] == '7' || pb[4] == '9') && pb[5] == 'a');
}


PBITMAPINFO x_8BPIBitmap(int xsize, int ysize)
{
        PBITMAPINFO pbmi;

        if (GetColorMode() == 8)
        {
                pbmi = (PBITMAPINFO) _calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(WORD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        else
        {
                pbmi = (PBITMAPINFO) _calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        return pbmi;
}

/*
    For color images.
        This routine should only be used when drawing to an 8 bit palette screen.
        It always creates a DIB in DIB_PAL_COLORS format.
*/
PBITMAPINFO BIT_Make_DIB_PAL_Header(int xsize, int ysize)
{
        int i;
        PBITMAPINFO pbmi;
        WORD *pw;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        pw = (WORD *) pbmi->bmiColors;

        for (i = 0; i < 256; i++)
        {
                pw[i] = (WORD)i;
        }

        return pbmi;
}

/*
    For color images.
        This routine is used when drawing to the nonpalette screens.  It always creates
        DIBs in DIB_RGB_COLORS format.
        If there is a transparent color, it is modified in the palette to be the
        background color for the window.
*/
PBITMAPINFO BIT_Make_DIB_RGB_Header_Screen(int xsize, int ysize,
                                           int cEntries, PALETTEENTRY * rgpe, int transparent)
{
        int i;
        PBITMAPINFO pbmi;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        for (i = 0; i < cEntries; i++)
        {
                pbmi->bmiColors[i].rgbRed = rgpe[i].peRed;
                pbmi->bmiColors[i].rgbGreen = rgpe[i].peGreen;
                pbmi->bmiColors[i].rgbBlue = rgpe[i].peBlue;
                pbmi->bmiColors[i].rgbReserved = 0;
        }

/*
        if (transparent != -1)
        {
                COLORREF color;

                color = PREF_GetBackgroundColor();
                pbmi->bmiColors[transparent].rgbRed     = GetRValue(color);
                pbmi->bmiColors[transparent].rgbGreen   = GetGValue(color);
                pbmi->bmiColors[transparent].rgbBlue    = GetBValue(color);
        }
*/
        return pbmi;
}

unsigned char *
CImgGif::ReadGIFMaster()
{
    HRESULT hr = S_OK;
    unsigned char buf[16];
    unsigned char c;
    unsigned char localColorMap[3][MAXCOLORMAPSIZE];
    long useGlobalColormap;
    long imageCount = 0;
    long imageNumber = 1;
    unsigned char *image = NULL;
    unsigned long i;
    long bitPixel;
    PGIFFRAME pgfLast = NULL;
    PGIFFRAME pgfNew;
    GIFSCREEN* GifScreen = new GIFSCREEN;
    if (GifScreen == NULL)
    {
        hr = E_FAIL;
        goto done;  
    }
    
    _gifinfo.ZeroDataBlock = 0;
    
    /*
    * Initialize GIF89 extensions
    */
    _gifinfo.Gif89.transparent = -1;
    _gifinfo.Gif89.delayTime = 5;
    _gifinfo.Gif89.inputFlag = -1;
    _gifinfo.Gif89.disposal = 0;
    _gifinfo.lGifLoc = 0;
    
    // initialize our animation fields
    _gad.fAnimated = FALSE;          // set to TRUE if we see more than one image
    _gad.fLooped = FALSE;                    // TRUE if we've seen a Netscape loop block
    _gad.fHasTransparency = FALSE; // until proven otherwise
    _gad.fNoBWMapping = FALSE;
    _gad.dwGIFVer = dwGIFVerUnknown;
    _gad.cLoops = 0;                
    _gad.pgf = NULL;
    _gad.pcolorsGlobal = NULL;
    
    if (!Read(buf, 6))
    {
        //bw TraceTag((tagImageDecode, "GIF: error reading magic number\n"));
        hr = E_FAIL;
        goto done;  
    }
    
    if (!IsGifHdr(buf)) {
        //bw TraceTag((tagImageDecode, "GIF: Malformed header\n"));
        hr = E_FAIL;
        goto done;
    }
    
    _gad.dwGIFVer = (buf[4] == '7') ? dwGIFVer87a : dwGIFVer89a;
    
    if (!Read(buf, 7))
    {
        //bw TraceTag((tagImageDecode, "GIF: failed to read screen descriptor\n"));
        hr = E_FAIL;
        goto done;
    }
    
    GifScreen->Width = LM_to_uint(buf[0], buf[1]);
    GifScreen->Height = LM_to_uint(buf[2], buf[3]);
    GifScreen->BitPixel = 2 << (buf[4] & 0x07);
    GifScreen->ColorResolution = (((buf[4] & 0x70) >> 3) + 1);
    GifScreen->Background = buf[5];
    GifScreen->AspectRatio = buf[6];
    
    if (BitSet(buf[4], LOCALCOLORMAP))
    {                                                       /* Global Colormap */
        int scale = 65536 / MAXCOLORMAPSIZE;
        
        if (ReadColorMap(GifScreen->BitPixel, GifScreen->ColorMap))
        {
            //bw TraceTag((tagImageDecode, "error reading global colormap\n"));
            hr = E_FAIL;
            goto done;
        }
        for (i = 0; i < GifScreen->BitPixel; i++)
        {
            int tmp;
            
            tmp = (BYTE) (GifScreen->ColorMap[0][i]);
            _ape[i].peRed = (BYTE) (GifScreen->ColorMap[0][i]);
            _ape[i].peGreen = (BYTE) (GifScreen->ColorMap[1][i]);
            _ape[i].peBlue = (BYTE) (GifScreen->ColorMap[2][i]);
            _ape[i].peFlags = (BYTE) 0;
        }
        for (i = GifScreen->BitPixel; i < MAXCOLORMAPSIZE; i++)
        {
            _ape[i].peRed = (BYTE) 0;
            _ape[i].peGreen = (BYTE) 0;
            _ape[i].peBlue = (BYTE) 0;
            _ape[i].peFlags = (BYTE) 0;
        }
    }
    
    if (GifScreen->AspectRatio != 0 && GifScreen->AspectRatio != 49)
    {
        float r;
        r = ((float) (GifScreen->AspectRatio) + (float) 15.0) / (float) 64.0;
        //bw TraceTag((tagImageDecode, "Warning: non-square pixels!\n"));
    }
    
    for (;; ) // our appetite now knows no bounds save termination or error
    {
        if (!Read(&c, 1))
        {
            //bw TraceTag((tagImageDecode, "EOF / read error on image data\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if (c == ';')
        {                                               /* GIF terminator */
            if (imageCount < imageNumber)
            {
                //bw TraceTag((tagImageDecode, "No images found in file\n"));
                hr = E_FAIL;
                goto done;
            }
            break;
        }
        
        if (c == '!')
        {                                               /* Extension */
            if (!Read(&c, 1))
            {
                //bw TraceTag((tagImageDecode, "EOF / read error on extension function code\n"));
                hr = E_FAIL;
                goto done;
            }
            DoExtension(c);
            continue;
        }
        
        if (c != ',')
        {                                               /* Not a valid start character */
            break;
        }
        
        ++imageCount;
        
        if (!Read(buf, 9))
        {
            //bw TraceTag((tagImageDecode, "couldn't read left/top/width/height\n"));
            hr = E_FAIL;
            goto done;
        }
        
        useGlobalColormap = !BitSet(buf[8], LOCALCOLORMAP);
        
        bitPixel = 1 << ((buf[8] & 0x07) + 1);
        
        /*
        * We only want to set width and height for the imageNumber
        * we are requesting.
        */
        if (imageCount == imageNumber)
        {
            // Replicate some of Netscape's special cases:
            // Don't use the logical screen if it's a GIF87a and the topLeft of the first image is at the origin.
            // Don't use the logical screen if the first image spills out of the logical screen.
            // These are artifacts of primitive authoring tools falling into the hands of hapless users.
            RECT    rectImage;  // rect defining bounds of GIF
            RECT    rectLS;     // rect defining bounds of GIF logical screen.
            RECT    rectSect;   // intersection of image an logical screen
            BOOL    fNoSpill;   // True if the image doesn't spill out of the logical screen
            BOOL    fGoofy87a;  // TRUE if its one of the 87a pathologies that Netscape special cases
            
            rectImage.left = LM_to_uint(buf[0], buf[1]);
            rectImage.top = LM_to_uint(buf[2], buf[3]);
            rectImage.right = rectImage.left + LM_to_uint(buf[4], buf[5]);
            rectImage.bottom = rectImage.top + LM_to_uint(buf[6], buf[7]);
            rectLS.left = rectLS.top = 0;
            rectLS.right = GifScreen->Width;
            rectLS.bottom = GifScreen->Height;
            IntersectRect( &rectSect, &rectImage, &rectLS );
            fNoSpill = EqualRect( &rectImage, &rectSect );
            fGoofy87a = FALSE;
            if (_gad.dwGIFVer == dwGIFVer87a)
            {
                // netscape ignores the logical screen if the image is flush against
                // either the upper left or lower right corner
                fGoofy87a = (rectImage.top == 0 && rectImage.left == 0) ||
                    (rectImage.bottom == rectLS.bottom &&
                    rectImage.right == rectLS.right);
            }   
            
            if (!fGoofy87a && fNoSpill)
            {
                _xWidth = GifScreen->Width;  
                _yHeight = GifScreen->Height;
            }
            else
            {
                // Something is amiss. Fall back to the image's dimensions.
                
                // If the sizes match, but the image is offset, or we're ignoring
                // the logical screen cuz it's a goofy 87a, then pull it back to 
                // to the origin
                if ((LM_to_uint(buf[4], buf[5]) == GifScreen->Width &&
                    LM_to_uint(buf[6], buf[7]) == GifScreen->Height) ||
                    fGoofy87a)
                {
                    buf[0] = buf[1] = 0; // left corner to zero
                    buf[2] = buf[3] = 0; // top to zero.
                }
                
                _xWidth = LM_to_uint(buf[4], buf[5]);
                _yHeight = LM_to_uint(buf[6], buf[7]);
            }
            
            _lTrans = _gifinfo.Gif89.transparent;
            
            // Post WHKNOWN
            //OnSize(_xWidth, _yHeight, _lTrans);
        }
        
        if (!useGlobalColormap)
        {
            if (ReadColorMap(bitPixel, localColorMap))
            {
                //bw TraceTag((tagImageDecode, "error reading local colormap\n"));
                hr = E_FAIL;
                goto done;
            }
        }
        
        // We allocate a frame record for each imag in the GIF stream, including
        // the first/primary image.
        pgfNew = (PGIFFRAME) _calloc(1, sizeof(GIFFRAME));
        
        if ( pgfNew == NULL )
        {
            //bw TraceTag((tagImageDecode, "not enough memory for GIF frame\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if ( _gifinfo.Gif89.delayTime != -1 )
        {
            // we have a fresh control extension for this block
            
            // convert to milliseconds
            pgfNew->gced.uiDelayTime = _gifinfo.Gif89.delayTime * 10;
            
            
            //REVIEW(seanf): crude hack to cope with 'degenerate animations' whose timing is set to some
            //                               small value becaue of the delays imposed by Netscape's animation process
            if ( pgfNew->gced.uiDelayTime <= 50 ) // assume these small values imply Netscape encoding delay
                pgfNew->gced.uiDelayTime = 100;   // pick a larger value s.t. the frame will be visible
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
            
        }
        else
        {   // fake one up s.t. GIFs that rely solely on Netscape's delay to time their animations will play
            // The spec says that the scope of one of these blocks is the image after the block.
            // Netscape says 'until further notice'. So we play it their way up to a point. We
            // propagate the disposal method and transparency. Since Netscape doesn't honor the timing
            // we use our default timing for these images.
            pgfNew->gced.uiDelayTime = 100;
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
        }
        
        pgfNew->top = LM_to_uint(buf[2], buf[3]);               // bounds relative to the GIF logical screen 
        pgfNew->left = LM_to_uint(buf[0], buf[1]);
        pgfNew->width = LM_to_uint(buf[4], buf[5]);
        pgfNew->height = LM_to_uint(buf[6], buf[7]);
        
        // Images that are offset, or do not cover the full logical screen are 'transparent' in the
        // sense that they require us to matte the frame onto the background.
        
        if (!_gad.fHasTransparency && (pgfNew->gced.fTransparent ||
            pgfNew->top != 0 ||
            pgfNew->left != 0 ||
            (UINT)pgfNew->width != (UINT)GifScreen->Width ||
            (UINT)pgfNew->height != (UINT)GifScreen->Height))
        {
            _gad.fHasTransparency = TRUE;
            //if (_lTrans == -1)
            //    OnTrans(0);
        }
        
        // We don't need to allocate a handle for the simple region case.
        // FrancisH says Windows is too much of a cheapskate to allow us the simplicity
        // of allocating the region once and modifying as needed. Well, okay, he didn't
        // put it that way...
        pgfNew->hrgnVis = NULL;
        pgfNew->iRgnKind = NULLREGION;
        
        if (!useGlobalColormap)
        {
            // remember that we saw a local color table and only map two-color images
            // if we have a homogenous color environment
            _gad.fNoBWMapping = _gad.fNoBWMapping || bitPixel > 2;
            
            // CALLOC will set unused colors to <0,0,0,0>
            pgfNew->pcolors = (PALETTEENTRY *) _calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
            if ( pgfNew->pcolors == NULL )
            {
                DeleteRgn( pgfNew->hrgnVis );
                free( pgfNew );
                
                //bw TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                hr = E_FAIL;
                goto done;
            }
            else
            {
                for (i = 0; i < (ULONG)bitPixel; ++i)
                {
                    pgfNew->pcolors[i].peRed = localColorMap[CM_RED][i];
                    pgfNew->pcolors[i].peGreen = localColorMap[CM_GREEN][i];
                    pgfNew->pcolors[i].peBlue = localColorMap[CM_BLUE][i];
                }
                pgfNew->cColors = bitPixel;
            }
        }
        else
        {
            if ( _gad.pcolorsGlobal == NULL )
            { // Whoa! Somebody's interested in the global color table
                // CALLOC will set unused colors to <0,0,0,0>
                _gad.pcolorsGlobal = (PALETTEENTRY *) _calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
                _gad.fNoBWMapping = _gad.fNoBWMapping || GifScreen->BitPixel > 2;
                if ( _gad.pcolorsGlobal != NULL )
                {
                    CopyMemory(_gad.pcolorsGlobal, _ape,
                        GifScreen->BitPixel * sizeof(PALETTEENTRY) );
                }
                else
                {
                    DeleteRgn( pgfNew->hrgnVis );
                    free( pgfNew );
                    //bw TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                    hr = E_FAIL;
                    goto done;  
                }
            }
            pgfNew->cColors = GifScreen->BitPixel;
            pgfNew->pcolors = _gad.pcolorsGlobal;
        }
        
        // Get this in here so that GifStrectchDIBits can use it during progressive
        // rendering.
        if ( _gad.pgf == NULL )
            _gad.pgf = pgfNew;
        
        pgfNew->ppixels = ReadImage(LM_to_uint(buf[4], buf[5]), // width
            LM_to_uint(buf[6], buf[7]), // height
            BitSet(buf[8], INTERLACE),
            imageCount != imageNumber);
        
        if ( pgfNew->ppixels != NULL )
        {
            // Oh JOY of JOYS! We got the pixels!
            if (pgfLast != NULL)
            {
                int transparent = (pgfNew->gced.fTransparent) ? (int) pgfNew->gced.ucTransIndex : -1;
                
                _gad.fAnimated = TRUE; // say multi-image == animated
                
                if (GetColorMode() == 8) // palettized, use DIB_PAL_COLORS
                {   // This will also dither the bits to the screen palette
                    
                    pgfNew->pbmi = BIT_Make_DIB_PAL_Header(pgfNew->width, pgfNew->height);
                    //if (x_Dither(pgfNew->ppixels, pgfNew->pcolors, pgfNew->width, pgfNew->height, transparent))
                    //    goto exitPoint;
                }
                else // give it an RGB header
                {
                    pgfNew->pbmi = BIT_Make_DIB_RGB_Header_Screen(
                        pgfNew->width,
                        pgfNew->height,
                        pgfNew->cColors, pgfNew->pcolors,
                        transparent);
                }
                
                // Okay, so we've done any mapping on the GIFFRAME, so there's
                // no need to keep the pcolors around.  Let's go can clear out
                // the pcolors.
                // REVIEW(seanf): This assumes a common palette is used by all
                // clients of the image
                if ( pgfNew->pcolors != NULL && pgfNew->pcolors != _gad.pcolorsGlobal )
                    free( pgfNew->pcolors );
                pgfNew->pcolors = NULL;
                
                pgfLast->pgfNext = pgfNew;
                
                // Do something to here to get the new frame on the screen.
                
                _fInvalidateAll = TRUE;
                //super::OnProg(FALSE, IMGBITS_TOTAL);
            }
            else
            { // first frame
                _gad.pgf = pgfNew;
                
                _gad.pgfLastProg = pgfNew;
                _gad.dwLastProgTimeMS = 0;
                // set up a temporary animation state for use in progressive draw
                _gas.fAnimating = TRUE; 
                _gas.dwLoopIter = 0;
                _gas.pgfDraw = pgfNew;
                
                if ( imageCount == imageNumber )
                    image = pgfNew->ppixels;
            }
            pgfLast = pgfNew;
        }
        
        // make the _gifinfo.Gif89.delayTime stale, so we know if we got a new
        // GCE for the next image
        _gifinfo.Gif89.delayTime = -1;
        
        }
        
        if ( imageCount > imageNumber )
            _gad.fAnimated = TRUE; // say multi-image == animated
        
#ifdef FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        // RAID #23709 - If an animation is sufficiently long, we treat it as indefinite...
        // Indefinite stays indefinite.
        // 5/29/96 - JCordell sez we shouldn't introduce this gratuitous NS incompatibility.
        //           We'll keep it around inside this ifdef in case we decide we want it.
        if ( _gad.fLooped &&
            (_gad.dwLoopDurMS * _gad.cLoops) / 1000 > dwIndefiniteGIFThreshold ) // if longer than five minutes
            _gad.cLoops = 0; // set to indefinite looping.
#endif // FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        
done:
         if (GifScreen)
         {
             delete GifScreen;
         }
         return image;
}

BITMAPINFO *
CImgGif::FinishDithering()
{
    BITMAPINFO * pbmi;
    
    if (GetColorMode() == 8)
    {
        pbmi = BIT_Make_DIB_PAL_Header(_gad.pgf->width, _gad.pgf->height);
    }
    else
    {
        pbmi = BIT_Make_DIB_RGB_Header_Screen(_gad.pgf->width, _gad.pgf->height,
            _gad.pgf->cColors, _gad.pgf->pcolors, _lTrans);
    }
    
    return pbmi;
}

//#include <vector>
//#define vector std::vector

//+-----------------------------------------------------------------------
//
//  Member:    LoadGifImage
//
//  Overview:  Given an IStream, decode an image into an array of bitmaps
//
//  Arguments: pStream      data source
//             colorKeys    pointer to where to store colorKey data
//             numBitmaps   where to store number of bitmaps
//             delays       where to store delay array
//             loop         where to store number of times to loop
//             ppBitMaps    where to store bitmaps
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
LoadGifImage(IStream *stream,                       
             COLORREF **colorKeys,
             int *numBitmaps,
             int **delays,
             double *loop,
             HBITMAP *phBitmap)
{
    HRESULT hr = S_OK;
   /* 
      The odd approach here lets us keep the original IE GIF code unchanged while removing
      DA specific inserts (except error reporting). The progressive rendering and palette 
      dithering found in the IE code is also not supported yet.
   */
   CImgGif* gifimage = new CImgGif;
   if (gifimage == NULL)
   {
       hr = E_FAIL;
       goto done;
   }
   gifimage->_szFileName = NULL;
   gifimage->_gifinfo.stream = stream;
   BYTE *pbBits = gifimage->ReadGIFMaster();

   if (pbBits) {
      gifimage->_pbBits = pbBits;
      gifimage->_gad.pgf->pbmi = gifimage->FinishDithering(); 
   }

   /*
      Extract information from GIF decoder, and format it into an array of bitmaps.
   */
   *delays = NULL;
   /*vector<>*/HBITMAP vhbmp;
   /*vector<>*/COLORREF vcolorKey;
   /*vector<>*/int vdelay;
   LPVOID  image = NULL;
   LPVOID  lastBits = pbBits;
   LPVOID  bitsBeforeLastBits = NULL;
   PBITMAPINFO pbmi = NULL;
   HBITMAP hbm;
   PGIFFRAME pgf = gifimage->_gad.pgf;
   PGIFFRAME pgfOld = NULL;
   bool fUseOffset = false; 
   bool fFirstFrame = true;
   long pgfWidth,pgfHeight,     // animation frame dims
        fullWidth,fullHeight,   // main frame dims
        fullPad, pgfPad,        // row padding vals
        fullSize, pgfSize;
   unsigned int disp = 0;
    int i = 0;

   // TODO: Dither global palette to display palette

   fullWidth = gifimage->_xWidth;
   fullHeight = gifimage->_yHeight;
   fullPad = (((fullWidth + 3) / 4) * 4) - fullWidth;  
   fullSize = (fullPad+fullWidth)*fullHeight; 
    
   if (NULL == pgf)
   {
       hr = E_FAIL;
       goto done;
   }

   while(1) 
   {     
//      Assert(pgf);      
      pbmi = pgf->pbmi;
      if (pbmi == NULL)
      {
          hr = E_FAIL;
          goto done;
      }

      // TODO: It would be nice to pass local palettes up so they could
      // be mapped to system palettes.       

      // Check to see if frame is offset from logical frame      
      if(pgf->top != 0 ||
         pgf->left != 0 || 
         pgf->width != fullWidth ||
         pgf->height != fullHeight) 
      {
         fUseOffset = true;    
         pgfWidth = pbmi->bmiHeader.biWidth;    
         pgfHeight = pbmi->bmiHeader.biHeight;  
         pbmi->bmiHeader.biWidth = fullWidth;      
         pbmi->bmiHeader.biHeight = fullHeight; 
         pgfPad = (((pgfWidth + 3) / 4) * 4) - pgfWidth; 
         pgfSize = (pgfPad+pgfWidth)*pgfHeight;
      }

      hbm = CreateDIBSection(NULL, pbmi, DIB_RGB_COLORS, (LPVOID *) &image, NULL, 0);        
      if(!hbm) 
      {
          hr = E_OUTOFMEMORY;
          goto done;
      }

      // Correctly composite bitmaps based on disposal method specified        
      disp = pgf->gced.uiDisposalMethod;
      // If the frame is offset, fill it with          
      if( (disp == gifRestorePrev) && (bitsBeforeLastBits != NULL) )
         memcpy(image, bitsBeforeLastBits, fullSize);
      else if( (disp == gifRestoreBkgnd) || (disp == gifRestorePrev) || fFirstFrame ) // fill with bgColor      
         memset(image, pgf->gced.ucTransIndex, fullSize);           
      else // fill with last frames data                                              
         memcpy(image, lastBits, fullSize);      
         
      
      // For offset gifs allocate an image the size of the first frame 
      // and then fill in the bits at the offset location.        
      if(fUseOffset) {         
         for(i=0; i<pgfHeight; i++) {               
            BYTE *dst, *src;                     
            // the destination is the address of the image data plus the frame and row offset. 
            int topOffset = fullHeight - pgfHeight - pgf->top;
            dst = (BYTE*)image +                                  
                  ( ((topOffset + i) *(fullPad+fullWidth)) + pgf->left );
            // copy from the frame's nth row
            src = pgf->ppixels + i*(pgfPad+pgfWidth);                
            for(int j=0; j<pgfWidth; j++) {     
                // copy the frame row data, excluding transparent bytes    
                if(src[j] != pgf->gced.ucTransIndex)
                    dst[j] = src[j];
            }
         }
      }     
      else {
         // Overwritten accumulated bits with current bits. If the 
         // new image contains transparency we need to take it into 
         // account. Since this is slower, special case it.
         if(pgf->gced.fTransparent) {            
            for(i=0; i<((fullPad+fullWidth)*fullHeight); i++) {        
                if(pgf->ppixels[i] != pgf->gced.ucTransIndex)
                    ((BYTE*)image)[i] = ((BYTE*)pgf->ppixels)[i];
            }
         }
         else // Otherwise, just copy over the offset window's bytes
            memcpy(image, pgf->ppixels, (fullPad+fullWidth)*fullHeight);  
      }

      /* 
          If we got a transparent color extension, convert it to a COLORREF
      */
      COLORREF colorKey = COLORKEY_NOT_SET;
      if (pgf->gced.fTransparent) {      
          int transparent = pgf->gced.ucTransIndex;
          colorKey = RGB(pgf->pbmi->bmiColors[transparent].rgbRed,
                         pgf->pbmi->bmiColors[transparent].rgbGreen,
                         pgf->pbmi->bmiColors[transparent].rgbBlue);
      }

      // vcolorKey.push_back(colorKey);
      vcolorKey = colorKey;

      // biao change : vhbmp.push_back(hbm);
      vhbmp = hbm;
      
      /* 
         The delay times are frame specific and can be different, these
         should be propagated as an array to the sampling code.  
      */      
      // vdelay.push_back(pgf->gced.uiDelayTime);      
      vdelay = pgf->gced.uiDelayTime;

      bitsBeforeLastBits = lastBits;        
      lastBits = image;
      fUseOffset = false;
      if(pgf->pgfNext == NULL) 
          break;
      pgfOld = pgf;
      pgf = pgf->pgfNext;
      fFirstFrame = FALSE;      
   } 
 
   
   // The number of times to loop are also propagated.  Note we add one because 
   // all other GIF decoders appear to treat the loop as the number of times to 
   // loop AFTER the first run through the frames.
   if (gifimage->_gad.cLoops == 0 && gifimage->_gad.fLooped != 0)
   {
		*loop = 0; // HUGE_VAL;
   }
   else
   {
        *loop = gifimage->_gad.cLoops;
   }
   
   *numBitmaps = 1;

   // Since the vector will go out of scope, move contents over to heap
   *delays = (int*)malloc(1 * sizeof(int)); 
   if (NULL == *delays)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *colorKeys = (COLORREF*)malloc( sizeof(COLORREF) * 1 ); 
   if (NULL == *colorKeys)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *phBitmap = vhbmp; // biao fix [i];
   (*colorKeys)[0] = vcolorKey; // [i];
   (*delays)[0] = vdelay; //[i];

   hr = S_OK;
done:
   if (FAILED(hr))
   {
       free(*delays);
       free(*colorKeys);
       if (gifimage)
       {
           delete gifimage;
       }
   }
   return hr;
}

/*lint --flb*/

BOOL Gif2Bmp(LPSTREAM pStream, HBITMAP* phBmp)
{
    HRESULT hr;
    int numGifs = 0;
    double loop = 0;
    int * pDelays = NULL;
    COLORREF * pColorKeys = NULL;

    hr = LoadGifImage(pStream,
                      &pColorKeys,
                      &numGifs,
                      &pDelays,
                      &loop,
                      phBmp);

    if (FAILED(hr))
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\passport\ppdefs.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ppdefs.h

Abstract:

    Basic Passport definitions.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef PP_DEFS_H
#define PP_DEFS_H

#include <Windows.h>

#define HINTERNET PVOID
#define INTERNET_PORT WORD

#define PP_LOG_INFO	 /*Noise*/ 0x00000001
#define PP_LOG_WARNING	/*Unusual*/ 0x00000002
#define PP_LOG_ERROR	 /*Error*/ 0x00000004

#ifdef DBG
#define PP_ASSERT(fVal) if (!fVal) DebugBreak();
#else
#define PP_ASSERT(fVal)
#endif

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

 #define WPP_CONTROL_GUIDS \
     WPP_DEFINE_CONTROL_GUID(Regular,(81b20fea,73a8,4b62,95bc,354477c97a6f), \
         WPP_DEFINE_BIT(Error)      \
         WPP_DEFINE_BIT(Unusual)    \
         WPP_DEFINE_BIT(Noise)      \
    ) 
    
//
// func pointer decl for CredUI
//

//#include <credui.h>
#include <wincred.h>

typedef BOOL
(WINAPI * PFN_READ_DOMAIN_CRED_W) (
	IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
	IN DWORD Flags,
	OUT DWORD *Count,
	OUT PCREDENTIALW **Credential
	);

typedef VOID
(WINAPI * PFN_CRED_FREE)(
    IN PVOID Buffer
    );

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


#define DoTraceMessage

#endif // PP_DEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\passport\httpsess.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    InetSess.cpp

Abstract:

    Implements the Passport Session that uses WinInet as the underlying transport.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"

/*
#ifdef HINTERNET
#undef HINTERNET
#endif

#ifdef INTERNET_PORT
#undef INTERNET_PORT
#endif

#include <WinHTTP.h>
*/

#define INTERNET_DEFAULT_HTTP_PORT      80
#define INTERNET_DEFAULT_HTTPS_PORT     443
#define WINHTTP_HEADER_NAME_BY_INDEX    NULL
#define INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY  0
#define INTERNET_OPEN_TYPE_PRECONFIG  INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
#define INTERNET_FLAG_NO_AUTO_REDIRECT  0x00200000
#define INTERNET_FLAG_NO_AUTH           0x00040000
#define HTTP_QUERY_FLAG_NUMBER          0x20000000
#define HTTP_QUERY_STATUS_CODE          19  // special: part of status line
#define HTTP_STATUS_REDIRECT            302 // object temporarily moved
#define HTTP_QUERY_WWW_AUTHENTICATE     40

typedef
VOID
(CALLBACK * WINHTTP_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

typedef enum
{
    INTERNET_SCHEME_PARTIAL = -2,
    INTERNET_SCHEME_UNKNOWN = -1,
    INTERNET_SCHEME_DEFAULT = 0,
    INTERNET_SCHEME_HTTP,
    INTERNET_SCHEME_HTTPS,
    INTERNET_SCHEME_FILE,
    INTERNET_SCHEME_SOCKS,
    INTERNET_SCHEME_RES,
    INTERNET_SCHEME_FIRST = INTERNET_SCHEME_HTTP,
    INTERNET_SCHEME_LAST = INTERNET_SCHEME_RES
} INTERNET_SCHEME, * LPINTERNET_SCHEME;

#include "session.h"

// #include "inetsess.tmh"

//
// func pointer decl for WinInet
//

typedef HINTERNET
(WINAPI * PFN_INTERNET_OPEN)(
    IN LPCWSTR lpwszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpwszProxy OPTIONAL,
    IN LPCWSTR lpwszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_INTERNET_CONNECT)(
    IN HINTERNET hInternet,
    IN LPCWSTR lpwszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_OPEN_REQUEST)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpwszVerb,
    IN LPCWSTR lpwszObjectName,
    IN LPCWSTR lpwszVersion,
    IN LPCWSTR lpwszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpwszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    );

typedef BOOL
(WINAPI * PFN_SEND_REQUEST)(
    IN HINTERNET hRequest,
    IN LPCWSTR lpwszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    );

typedef BOOL 
(WINAPI * PFN_QUERY_INFO)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPCWSTR lpszName OPTIONAL,
    IN LPVOID lpvBuffer,
    IN LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
);

typedef BOOL 
(WINAPI* PFN_CLOSE_HANDLE)(
    IN HINTERNET hInternet
);

typedef BOOL 
(WINAPI* PFN_SET_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
);

typedef BOOL 
(WINAPI* PFN_QUERY_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
);

typedef HINTERNET 
(WINAPI* PFN_OPEN_URL)(
    IN HINTERNET hInternet, 
    IN LPCWSTR lpwszUrl,
    IN LPCWSTR lpwszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
);

typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPWSTR  lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPWSTR  lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPWSTR  lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPWSTR  lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPWSTR  lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPWSTR  lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSW, * LPURL_COMPONENTSW;

typedef BOOL 
(WINAPI* PFN_CRACK_URL)(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents
);

typedef BOOL 
(WINAPI* PFN_READ_FILE)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
);

typedef WINHTTP_STATUS_CALLBACK
(WINAPI* PFN_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
    );

typedef BOOL 
(WINAPI* PFN_ADD_HEADERS)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
);


class WINHTTP_SESSION : public SESSION
{
protected:
    WINHTTP_SESSION(void);
    virtual ~WINHTTP_SESSION(void);

    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET);
    virtual void Close(void);

protected:    
    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT);

    virtual HINTERNET OpenRequest(
            HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0);

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0);

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL);

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet);

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength);    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength);

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags);

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead);

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents);

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        );

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        );

    virtual BOOL IsHostBypassProxy(
        INTERNET_SCHEME tScheme, 
        LPCSTR pszHost, 
        DWORD cchHost) 
    {
        return TRUE; // biaow: todo
    }


#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR pwszData,
                                PDWORD pdwDataLength
                                );
#endif // PP_DEMO

    BOOL InitHttpApi(PFN_INTERNET_OPEN*);

protected:
    HINTERNET m_hInternet;

    PFN_INTERNET_CONNECT    m_pfnConnect;
    PFN_OPEN_REQUEST        m_pfnOpenRequest;
    PFN_SEND_REQUEST        m_pfnSendRequest;
    PFN_QUERY_INFO          m_pfnQueryInfo;
    PFN_CLOSE_HANDLE        m_pfnCloseHandle;
    PFN_SET_OPTION          m_pfnSetOption;
    PFN_OPEN_URL            m_pfnOpenUrl;
    PFN_QUERY_OPTION        m_pfnQueryOption;
    PFN_CRACK_URL           m_pfnCrack;
    PFN_READ_FILE           m_pfnReadFile;
    PFN_STATUS_CALLBACK     m_pfnStatusCallback;
    PFN_ADD_HEADERS         m_pfnAddHeaders;

friend class SESSION;
friend SESSION* CreateWinHttpSession(void);
};

SESSION* CreateWinHttpSession(void)
{
    return new WINHTTP_SESSION();
}

//
// Implementation for WINHTTP_SESSION
//

// -----------------------------------------------------------------------------
WINHTTP_SESSION::WINHTTP_SESSION(void)
{
    m_hInternet = NULL;

    m_pfnConnect = NULL;
    m_pfnOpenRequest = NULL;
    m_pfnSendRequest = NULL;
    m_pfnQueryInfo = NULL;
    m_pfnCloseHandle = NULL;
    m_pfnSetOption = NULL;
    m_pfnOpenUrl = NULL;
    m_pfnQueryOption = NULL;
    m_pfnCrack = NULL;
    m_pfnReadFile = NULL;
}

// -----------------------------------------------------------------------------
WINHTTP_SESSION::~WINHTTP_SESSION(void)
{
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::Connect(
    LPCWSTR lpwszServerName,
    INTERNET_PORT nPort)
{
    PP_ASSERT(m_pfnConnect != NULL);

    return (*m_pfnConnect)(m_hInternet, 
                    lpwszServerName, 
                    nPort,
                    0);
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::OpenRequest(
    HINTERNET hConnect,
    LPCWSTR lpwszVerb,
    LPCWSTR lpwszObjectName,
    DWORD dwFlags,
    DWORD_PTR dwContext)
{
    PP_ASSERT(m_pfnOpenRequest != NULL);

    return (*m_pfnOpenRequest)(hConnect,
                               lpwszVerb,
                               lpwszObjectName,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               dwFlags);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::SendRequest(
    HINTERNET hRequest,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD_PTR dwContext)
{                                                                 

    PP_ASSERT(m_pfnSendRequest != NULL);

    return (*m_pfnSendRequest)(hRequest,
                        lpwszHeaders,
                        dwHeadersLength,
                        NULL,
                        0,
						0, // optional total length
                        dwContext);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::QueryHeaders(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex)
{
    PP_ASSERT(m_pfnQueryInfo != NULL);

    return (*m_pfnQueryInfo)(hRequest,
                             dwInfoLevel,
                             WINHTTP_HEADER_NAME_BY_INDEX,
                             lpvBuffer,
                             lpdwBufferLength,
                             lpdwIndex);
}

// -----------------------------------------------------------------------------
BOOL  WINHTTP_SESSION::CloseHandle(
    IN HINTERNET hInternet)
{
    PP_ASSERT(m_pfnCloseHandle != NULL);

    return (*m_pfnCloseHandle)(hInternet);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::QueryOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    LPDWORD lpdwBufferLength)
{
    PP_ASSERT(m_pfnQueryOption != NULL);

    return (*m_pfnQueryOption)(hInternet,
                               dwOption,
                               lpBuffer,
                               lpdwBufferLength
                               );
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::SetOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    DWORD dwBufferLength)
{
    PP_ASSERT(m_pfnSetOption != NULL);

    return (*m_pfnSetOption)(hInternet,
                             dwOption,
                             lpBuffer,
                             dwBufferLength);
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::OpenUrl(
    LPCWSTR lpwszUrl,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD dwFlags)
{
    PP_ASSERT(m_pfnOpenUrl != NULL);

    return (*m_pfnOpenUrl)(m_hInternet,
                           lpwszUrl,
                           lpwszHeaders,
                           dwHeadersLength,
                           dwFlags,
                           0);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::ReadFile(
    HINTERNET hFile,
    LPVOID lpBuffer,
    DWORD dwNumberOfBytesToRead,
    LPDWORD lpdwNumberOfBytesRead)
{
    PP_ASSERT(m_pfnReadFile != NULL);

    return (*m_pfnReadFile)(
                            hFile,
                            lpBuffer,
                            dwNumberOfBytesToRead,
                            lpdwNumberOfBytesRead);
}

BOOL WINHTTP_SESSION::CrackUrl(
    LPCWSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents)
{
    PP_ASSERT (m_pfnCrack != NULL);

    return (*m_pfnCrack)(lpszUrl,
                         dwUrlLength,
                         dwFlags,
                         lpUrlComponents);
}

PVOID WINHTTP_SESSION::SetStatusCallback(
    HINTERNET hInternet,
    PVOID lpfnCallback
    )
{
    return (*m_pfnStatusCallback)(hInternet,
                                  (WINHTTP_STATUS_CALLBACK)lpfnCallback,
                                  0,
                                  0);

}

BOOL WINHTTP_SESSION::AddHeaders(
    HINTERNET hConnect,
    LPCWSTR lpszHeaders,
    DWORD dwHeadersLength,
    DWORD dwModifiers
    )
{
    PP_ASSERT(m_pfnAddHeaders != NULL);

    return (*m_pfnAddHeaders)(hConnect,
                              lpszHeaders,
                              dwHeadersLength,
                              dwModifiers
                              );
}

BOOL WINHTTP_SESSION::InitHttpApi(PFN_INTERNET_OPEN* ppfnInternetOpen)
{
    BOOL  fRet = FALSE;

    m_pfnCloseHandle =
        reinterpret_cast<PFN_CLOSE_HANDLE>(::GetProcAddress(m_hHttpStack, "WinHttpCloseHandle"));
    if (m_pfnCloseHandle == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpCloseHandle not found");
        goto exit;
    }

    *ppfnInternetOpen = 
        reinterpret_cast<PFN_INTERNET_OPEN>(::GetProcAddress(m_hHttpStack, "WinHttpOpen"));
    if (*ppfnInternetOpen == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpen not found");
        goto exit;
    }

    m_pfnConnect = 
        reinterpret_cast<PFN_INTERNET_CONNECT>(::GetProcAddress(m_hHttpStack, "WinHttpConnect"));
    if (m_pfnConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpConnect not found");
        goto exit;
    }

    m_pfnOpenRequest = 
        reinterpret_cast<PFN_OPEN_REQUEST>(::GetProcAddress(m_hHttpStack, "WinHttpOpenRequest"));
    if (m_pfnOpenRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpenRequest not found");
        goto exit;
    }

    m_pfnSendRequest =
        reinterpret_cast<PFN_SEND_REQUEST>(::GetProcAddress(m_hHttpStack, "WinHttpSendRequest"));
    if (m_pfnSendRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSendRequest not found");
        goto exit;
    }

    m_pfnQueryInfo =
        reinterpret_cast<PFN_QUERY_INFO>(::GetProcAddress(m_hHttpStack, "WinHttpQueryHeaders"));
    if (m_pfnQueryInfo == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpQueryHeaders not found");
        goto exit;
    }
    
    m_pfnSetOption =
        reinterpret_cast<PFN_SET_OPTION>(::GetProcAddress(m_hHttpStack, "WinHttpSetOption"));
    if (m_pfnSetOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSetOption not found");
        goto exit;
    }

    m_pfnOpenUrl =
        reinterpret_cast<PFN_OPEN_URL>(::GetProcAddress(m_hHttpStack, "WinHttpOpenUrl"));
    if (m_pfnOpenUrl == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpenUrl not found");
        goto exit;
    }

    m_pfnQueryOption =
            reinterpret_cast<PFN_QUERY_OPTION>(::GetProcAddress(m_hHttpStack, "WinHttpQueryOption"));
    if (m_pfnQueryOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpQueryOption not found");
        goto exit;
    }

    m_pfnCrack =
            reinterpret_cast<PFN_CRACK_URL>(::GetProcAddress(m_hHttpStack, "WinHttpCrackUrl"));
        if (m_pfnCrack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpCrackUrl not found");
        goto exit;
    }

    m_pfnReadFile =
            reinterpret_cast<PFN_READ_FILE>(::GetProcAddress(m_hHttpStack, "WinHttpReadData"));
    if (m_pfnReadFile == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpReadData not found");
        goto exit;
    }

    m_pfnStatusCallback =
        reinterpret_cast<PFN_STATUS_CALLBACK>(::GetProcAddress(m_hHttpStack, "WinHttpSetStatusCallback"));
    if (m_pfnStatusCallback == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSetStatusCallback not found");
        goto exit;
    }

    m_pfnAddHeaders =
        reinterpret_cast<PFN_ADD_HEADERS>(::GetProcAddress(m_hHttpStack, "WinHttpAddRequestHeaders"));
    if (m_pfnAddHeaders == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpAddRequestHeaders not found");
        goto exit;
    }
    
    fRet = TRUE;

exit:
    return fRet;
}

BOOL WINHTTP_SESSION::Open(
    PCWSTR pwszHttpStack,
    HINTERNET hInternet
    )
{
    PP_ASSERT(pwszHttpStack != NULL);

    DWORD dwErrorCode;
    BOOL  fRet = FALSE;
    PFN_INTERNET_OPEN pfnInternetOpen = NULL;

    PP_ASSERT(m_hHttpStack == 0);
    m_hHttpStack = ::LoadLibraryW(pwszHttpStack);
    if (m_hHttpStack == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to load library %ws; error = %d", pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (InitHttpApi(&pfnInternetOpen) == FALSE)
    {
        goto exit;
    }

    if (hInternet)
    {
        m_hInternet = hInternet;
        m_fOwnedSession = FALSE;
    }
    else
    {
        m_hInternet = (*pfnInternetOpen)(
                                         L"Microsoft WinHttp Passport Authentication Service 1.4",
                                         INTERNET_OPEN_TYPE_PRECONFIG,  // ? name didn't get changed yet
                                         NULL,
                                         NULL,
                                         0 /*WINHTTP_FLAG_ASYNC*/ // biaow-todo: use async
                                         );
        m_fOwnedSession = TRUE;
    }
    if (m_hInternet == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to open an HTTP session through %ws; error = %d", 
                       pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (SESSION::Open(pwszHttpStack, hInternet) == FALSE)
    {
        goto exit;
    }
    
    fRet = TRUE;

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session opened");

exit:
    if (!fRet)
    {
        if (m_hInternet && m_fOwnedSession)
        {
            (*m_pfnCloseHandle)(m_hInternet);
            m_hInternet = NULL;
        }
        if (m_hHttpStack)
        {
           ::FreeLibrary(m_hHttpStack);
            m_hHttpStack = NULL;
        }
        
        DoTraceMessage(PP_LOG_ERROR, "WinInet Http Session failed");
    }

    return fRet;
}

void WINHTTP_SESSION::Close(void)
{
    PP_ASSERT(m_pfnCloseHandle);
    if (m_hInternet && m_fOwnedSession)
    {
        (*m_pfnCloseHandle)(m_hInternet);
        m_pfnCloseHandle = NULL;
    }

    if (m_hHttpStack)
    {
       ::FreeLibrary(m_hHttpStack);
        m_hHttpStack = NULL;
    }

    SESSION::Close();

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session closed");
}

#ifdef PP_DEMO
BOOL WINHTTP_SESSION::ContactPartner(PCWSTR pwszPartnerUrl,
                                     PCWSTR pwszVerb,
                                     PCWSTR pwszHeaders,
                                     PWSTR  pwszData,
                                     PDWORD pdwDataLength
                                     )
{
    BOOL fRet = FALSE;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    WCHAR ServerName[128];
    WCHAR ObjectPath[1024];

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));
    
    UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);
    
    UrlComps.lpszHostName = ServerName;
    UrlComps.dwHostNameLength = ARRAYSIZE(ServerName);

    UrlComps.lpszUrlPath = ObjectPath;
    UrlComps.dwUrlPathLength = ARRAYSIZE(ObjectPath);

    PP_ASSERT(m_pfnCrack != NULL);

    if ((*m_pfnCrack)(pwszPartnerUrl, 
                      0, 
                      0, 
                      &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not crack the URL %ws",
                       pwszPartnerUrl);
        goto exit;
    }

    PP_ASSERT(m_pfnConnect != NULL);

    hConnect = (*m_pfnConnect)(m_hInternet, 
                    UrlComps.lpszHostName, 
                    UrlComps.nPort,
                    0);
    if (hConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not open an HTTP sesstion to %ws:%d",
                       UrlComps.lpszHostName, UrlComps.nPort);
        goto exit;
    }

    PP_ASSERT(m_pfnOpenRequest != NULL);

    hRequest = (*m_pfnOpenRequest)(hConnect,
                               pwszVerb,
                               UrlComps.lpszUrlPath,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               INTERNET_FLAG_NO_AUTO_REDIRECT | INTERNET_FLAG_NO_AUTH);
    if (hRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not open an HTTP request to %ws:(%ws)",
                       UrlComps.lpszUrlPath, pwszVerb);
        goto exit;
    }

    PP_ASSERT(m_pfnSendRequest != NULL);

    if ((*m_pfnSendRequest)(hRequest,
                        pwszHeaders,
                        0,
                        NULL,
                        0,
                        0,
                        0) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not send an HTTP request");

        goto exit;
    }

    if (pwszData == NULL)
    {
        fRet = TRUE;
        goto exit;
    }
    
    DWORD dwStatus, dwStatusLen;
    dwStatusLen = sizeof(dwStatus);
    if (!QueryHeaders(hRequest, 
                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                      &dwStatus,
                      &dwStatusLen))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not query status code");
        goto exit;
    }

    if (dwStatus != HTTP_STATUS_REDIRECT)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; expecting %d but get %d",
                       HTTP_STATUS_REDIRECT, dwStatus);
        goto exit;
    }

    ::wcscpy(pwszData, L"WWW-Authenticate: ");
    if(!QueryHeaders(hRequest,
                     HTTP_QUERY_WWW_AUTHENTICATE, 
                     (LPVOID)(pwszData + ::wcslen(L"WWW-Authenticate: ")),
                     pdwDataLength))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; no auth headers found");
        goto exit;
    }

    (*m_pfnCloseHandle)(hRequest);
    hRequest = NULL;
    (*m_pfnCloseHandle)(hConnect);
    hConnect = NULL;
    
    fRet = TRUE;

exit:
    if (hRequest)
    {
        (*m_pfnCloseHandle)(hRequest);
        hRequest = NULL;
    }

    if (hConnect)
    {
        (*m_pfnCloseHandle)(hConnect);
        hConnect = NULL;
    }

    return fRet;
}
#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\passport\logon.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    logon.h

Abstract:

    This interface abstracts a Passport Logon Session.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef LOGON_H
#define LOGON_H

void DecryptPassword ( WCHAR* pClearPassword, PVOID pPassword, DWORD cbSize );


class SESSION;

class LOGON
{
public:
    LOGON(SESSION*, DWORD dwParentFlags);
    virtual ~LOGON(void);

    BOOL Open(PCWSTR pwszPartnerInfo);
    void Close(void);

    BOOL SetCredentials(
        PCWSTR      pwszRealm,
        PCWSTR      pwszTarget,
        PCWSTR      pwszSignIn,
        PCWSTR      pwszPassword,
        PSYSTEMTIME pTimeCredsEntered
        );

    BOOL GetLogonHost(
    	PWSTR       pwszHostName,
    	OUT PDWORD  pdwHostNameLen
        ) const;

    DWORD Logon(BOOL fAnonymous);

    PLIST_ENTRY GetPrivacyEvents(void) const { return (PLIST_ENTRY)&m_PrivacyEventList; }

    BOOL GetChallengeInfo(
		HBITMAP*		 phBitmap,
        PBOOL            pfPrompt,
    	PWSTR			 pwszCbText,
        PDWORD           pdwTextLen,
        PWSTR            pwszRealm,
        DWORD            dwMaxRealmLen,
        PWSTR            pwszReqUserName,
        PDWORD           pdwReqUserNameLen
        ) const;

    BOOL GetChallengeContent(
      	PBYTE    	     pContent,
        OUT PDWORD       pdwContentLen
        ) const;


    BOOL GetAuthorizationInfo(
        PWSTR   pwszTicket,       // e.g. "from-PP = ..."
        PDWORD  pdwTicketLen,
        PBOOL   pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
        PWSTR   pwszUrl,    // user supplied buffer ...
        PDWORD  pdwUrlLen  // ... and length (will be updated to actual length 
                                        // on successful return)
        ) const;

    VOID StatusCallback(
        IN HINTERNET hInternet,
        IN DWORD dwInternetStatus,
        IN LPVOID lpvStatusInformation,
        IN DWORD dwStatusInformationLength);

protected:
    void GetCachedCreds(
        PCWSTR	pwszRealm,
        PCWSTR  pwszTarget,
        PCREDENTIALW** pppCreds,
        DWORD* pdwCreds
        );

    BOOL DownLoadCoBrandBitmap(
        PWSTR pwszChallenge
        );

    DWORD Handle401FromDA(
        HINTERNET   hRequest, 
        BOOL        fTicketRequest
        );

    DWORD Handle200FromDA(
        HINTERNET hRequest
        );

    void CheckForVersionChange(
        HINTERNET hRequest
        );

protected:

    SESSION*    m_pSession;

    HINTERNET   m_hConnect;
    BOOL        m_fCredsPresent;
    PWSTR       m_pwszSignIn;
    PWSTR       m_pwszPassword;
    WCHAR       m_wNewDAUrl[1024];
    PWSTR       m_pwszTicketRequest;
    PWSTR       m_pwszAuthInfo;
    PWSTR		m_pwszReturnUrl;
    // PWSTR       m_pwszCbUrl;
	BOOL		m_fWhistler;
    HBITMAP     m_hBitmap;
    BOOL        m_fPrompt;
    WCHAR       m_wRealm[128];
    WCHAR       m_wTimeSkew[16];
    PWSTR       m_pwszAuthHeader;
    DWORD       m_dwParentFlags;
    PWSTR       m_pwszCbtxt;

    WCHAR       m_wDAHostName[256];
    LPSTREAM    m_p401Content;
    SYSTEMTIME  m_TimeCredsEntered;

    LIST_ENTRY  m_PrivacyEventList;
};

#endif // LOGON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\dload\inetcorepch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\passport\passport.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passport.h

Abstract:

    WinInet/WinHttp- Passport Auenthtication Package Interface.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef PASSPORT_H
#define PASSPORT_H


extern BOOL g_fIgnoreCachedCredsForPassport;
extern BOOL g_fCurrentProcessLoggedOn;
extern WCHAR g_szUserNameLoggedOn[128];         // 128 = INTERNET_MAX_USER_NAME_LENGTH, defined in wininet.h


typedef void* PP_CONTEXT;
typedef void* PP_LOGON_CONTEXT;

//
// Passport related error codes
//

// generic internal error
#define PP_GENERIC_ERROR   -1   // biaow-todo: GetLastError() to return more specific error codes

// generic async error
#define PP_REQUEST_PENDING -9

//
// return codes from PP_Logon
//
#define PP_LOGON_SUCCESS    0
#define PP_LOGON_FAILED     1
#define PP_LOGON_REQUIRED   2

//
// return codes from PP_GetReturnVerbAndUrl
//
#define PP_RETURN_KEEP_VERB 1
#define PP_RETURN_USE_GET   0

#define PFN_LOGON_CALLBACK PVOID    // biaow-todo: define the async callback prototype

struct PRIVACY_EVENT
{
    LIST_ENTRY List;
    DWORD dwStatus;
    PVOID lpvInfo;
    DWORD dwInfoLength;
};


//
// Passport Context routines
//

PP_CONTEXT 
PP_InitContext(
    IN PCWSTR    pwszHttpStack, // "WinInet.dll" or "WinHttp5.dll"

    IN HINTERNET hSession       // An existing session (i.e. hInternet) returned by InternetOpen() 
                                // or WinHttpOpen(); hSession must compatible with pwszHttpStack. 
                                // (e.g.WinInet.Dll<->InternetOpen() or WinHttp5.Dll<->WinHttpOpen() )
    );

VOID 
PP_FreeContext(
	IN PP_CONTEXT hPP
    );

BOOL
PP_GetRealm(
	IN PP_CONTEXT hPP,
    IN PWSTR      pwszDARealm,    // user supplied buffer ...
    IN OUT PDWORD pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    );

//
// Passport Logon Context routines
//

PP_LOGON_CONTEXT
PP_InitLogonContext(
	IN PP_CONTEXT  hPP,
	IN PCWSTR      pwszPartnerInfo,   // i.e. "WWW-Authenticate: Passport1.4 ..." from partner 
                                      // site's 302 re-direct
    IN DWORD       dwParentFlags
    );

DWORD
PP_Logon(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN BOOL                fAnonymous,
	IN HANDLE	           hEvent,          // biaow-todo: async
    IN PFN_LOGON_CALLBACK  pfnLogonCallback,// biaow-todo: async
    IN DWORD               dwContext        // biaow-todo: async
    );

PLIST_ENTRY
PP_GetPrivacyEvents(
    IN PP_LOGON_CONTEXT hPPLogon
    );

// -- This method should be called when PP_Logon() returns PP_LOGON_REQUIRED 
// -- (i.e. 401 from a Passport DA)
BOOL
PP_GetChallengeInfo(
    IN PP_LOGON_CONTEXT hPPLogon,
    OUT HBITMAP*        phBitmap,   // can be NULL; if not NULL, ownership of the bitmap 
                                    // is not transferred to the user
    OUT PBOOL           pfPrompt,
  	IN PWSTR    	    pwszCbText,
    IN OUT PDWORD       pdwTextLen,
    IN PWSTR            pwszRealm,
    IN DWORD            dwMaxRealmLen,
    PWSTR               pwszReqUserName,
    PDWORD              pdwReqUserNameLen
    );

BOOL
PP_GetChallengeContent(
    IN PP_LOGON_CONTEXT hPPLogon,
  	IN PBYTE    	    pContent,
    IN OUT PDWORD       pdwContentLen
    );

// -- if the credentials are NULL/NULL, the means the default creds will be used
// -- if default creds can not be retrieved, this method will return FALSE
BOOL 
PP_SetCredentials(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN PCWSTR              pwszRealm,
    IN PCWSTR              pwszTarget,  // optional if user/pass are known (not null)
    IN PCWSTR              pwszSignIn,  // can be NULL
    IN PCWSTR              pwszPassword, // can be NULL
    IN PSYSTEMTIME         pTimeCredsEntered // ignore if both SignIn and Pass are NULL (should be set to NULL in that case)
    );

BOOL
PP_GetLogonHost(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszHostName,    // user supplied buffer ...
	IN OUT PDWORD       pdwHostNameLen  // ... and length (will be updated to actual length 
    );

BOOL 
PP_GetAuthorizationInfo(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszTicket,       // e.g. "from-PP = ..."
	IN OUT PDWORD       pdwTicketLen,
	OUT PBOOL           pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
	IN PWSTR            pwszUrl,    // user supplied buffer ...
	IN OUT PDWORD       pdwUrlLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	);

// -- biaow-todo: async
VOID 
PP_AbortLogon(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN DWORD               dwFlags
    );

// -- biaow-todo: 
VOID 
PP_Logout(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN DWORD               dwFlags
    );

VOID 
PP_FreeLogonContext(
    IN PP_LOGON_CONTEXT    hPPLogon
	);

BOOL
PP_ForceNexusLookup(
    IN PP_LOGON_CONTEXT hPPLogon,
    IN BOOL             fForce,
    IN PWSTR            pwszRegUrl,    // user supplied buffer ...
    IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
    IN PWSTR            pwszDARealm,    // user supplied buffer ...
    IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	);

// if either pwszUsername or pwszPassword is not NULL, it must represent a string at least 
// INTERNET_MAX_USER_NAME_LENGTH or INTERNET_MAX_PASSWORD_LENGTH chars long, respectively

BOOL
PP_GetCachedCredential(
    PP_LOGON_CONTEXT    hPP,
    IN PWSTR            pwszRealm,
    IN PWSTR            pwszTarget,
    OUT PWSTR           pwszUsername,
    OUT PWSTR           pwszPassword
	);


#ifdef PP_DEMO

BOOL PP_ContactPartner(
	IN PP_CONTEXT   hPP,
    IN PCWSTR       pwszPartnerUrl,
    IN PCWSTR       pwszVerb,
    IN PCWSTR       pwszHeaders,
    IN PWSTR        pwszData,
    IN OUT PDWORD   pdwDataLength
    );

#endif // PP_DEMO

#endif // PASSPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\passport\session.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    session.h

Abstract:

    This interface abstracts a Passport Session.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef SESSION_H
#define SESSION_H

class SESSION
{
public:
    static
    BOOL CreateObject(PCWSTR pwszHttpStack,  HINTERNET hSession, SESSION*& pSess);

public:
    SESSION(void);
    virtual ~SESSION(void);

    UINT GetSessionId(void) const { return m_SessionId; }
    BOOL Match(UINT SessionId) const { return SessionId == m_SessionId; }

    void AddRef(void) { ++m_RefCount; }
    
    void RemoveRef(void) 
    {
        if (m_RefCount > 0)
        {
            --m_RefCount;
        }
    }

    UINT RefCount(void) const { return m_RefCount; }

    // methods to retrieve the registry-configured value

    // PCWSTR GetLoginHost(void) const { return m_wDAHostName; }
    // PCWSTR GetLoginTarget(void) const { return m_wDATargetObj; }
    PCWSTR GetRegistrationUrl(void) const { return m_wRegistrationUrl; }
    
    BOOL GetDAInfoFromPPNexus(
        IN BOOL             fForce,
        IN PWSTR            pwszRegUrl,    // user supplied buffer ...
        IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                        // on successful return)
        IN PWSTR            pwszDARealm,    // user supplied buffer ...
        IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                        // on successful return)
        );

    BOOL GetDAInfo(PCWSTR pwszSignIn,
                   LPWSTR pwszDAHostName,
                   DWORD HostNameLen,
                   LPWSTR pwszDAHostObj,
                   DWORD HostObjLen);

    BOOL UpdateDAInfo(
        PCWSTR pwszSignIn,
        PCWSTR pwszDAUrl
        );

    BOOL PurgeDAInfo(PCWSTR pwszSignIn);

    DWORD GetNexusVersion(void);

    BOOL GetCachedCreds(
        PCWSTR	pwszRealm,
        PCWSTR  pwszTarget,
        PCREDENTIALW** pppCreds,
        DWORD* pdwCreds
        );

    BOOL GetRealm(
        PWSTR      pwszDARealm,    // user supplied buffer ...
        PDWORD     pdwDARealmLen  // ... and length (will be updated to actual length 
                                        // on successful return)
        ) const;

    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET) = 0;
    virtual void Close(void) = 0;

    // methods below abstracts a subset of WinInet/WinHttp functionalities.

    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT) = 0;

    virtual HINTERNET OpenRequest(
        HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0) = 0;

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0) = 0;

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL) = 0;

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet) = 0;

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength) = 0;    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength) = 0;

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags) = 0;

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead) = 0;

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents) = 0;

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        ) = 0;

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        ) = 0;

    virtual BOOL IsHostBypassProxy(
        INTERNET_SCHEME tScheme, 
        LPCSTR pszHost, 
        DWORD cchHost) = 0;


#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR  pwszData,
                                PDWORD pdwDataLength
                                ) = 0;
#endif // PP_DEMO

    LPCWSTR GetCurrentDAUrl(void) const { return m_wCurrentDAUrl; }

protected:
    static UINT m_SessionIdSeed;

    HMODULE     m_hHttpStack;
    HMODULE     m_hCredUI;
    UINT        m_SessionId;
    BOOL        m_fOwnedSession;
    UINT        m_RefCount;

    // WCHAR       m_wDAHostName[256];
    // WCHAR       m_wDATargetObj[64];
    WCHAR       m_wRegistrationUrl[256];
    
    PFN_READ_DOMAIN_CRED_W
                m_pfnReadDomainCred;
    PFN_CRED_FREE m_pfnCredFree;

    HKEY m_hKeyLM;
    HKEY m_hKeyCU;
    HKEY m_hKeyDAMap;
    WCHAR m_wDefaultDAUrl[1024];
    WCHAR m_wCurrentDAUrl[1024];

    DWORD m_LastNexusDownloadTime;

    friend class LOGON;
};

#endif // SESSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\dload\advpack.c ===
#include "inetcorepch.h"
#pragma hdrstop

#include <advpub.h>

static
HRESULT
WINAPI
RunSetupCommand(
    HWND hWnd,
    LPCSTR szCmdName,
    LPCSTR szInfSection,
    LPCSTR szDir,
    LPCSTR lpszTitle,
    HANDLE *phEXE,
    DWORD dwFlags,
    LPVOID pvReserved
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT 
WINAPI
RegInstall(
    HMODULE hm, 
    LPCSTR pszSection, 
    LPCSTRTABLE pstTable)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(advpack)
{
    DLPENTRY(RegInstall)
    DLPENTRY(RunSetupCommand)
};

DEFINE_PROCNAME_MAP(advpack)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\passport\passport.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passport.cpp

Abstract:

    WinInet/WinHttp- Passport Auenthtication Package Interface implementation.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "ppdefs.h"
#include "wininet.h"
#include "Session.h"
#include "ole2.h"
#include "logon.h"
#include "passport.h"

// #include "passport.tmh"

BOOL g_fIgnoreCachedCredsForPassport = FALSE;
BOOL g_fCurrentProcessLoggedOn = FALSE;
WCHAR g_szUserNameLoggedOn[INTERNET_MAX_USER_NAME_LENGTH];

// -----------------------------------------------------------------------------
PP_CONTEXT 
PP_InitContext(
    PCWSTR	pwszHttpStack,
    HINTERNET hSession
    )
{
//	WPP_INIT_TRACING(L"Microsoft\\Passport1.4");
    
    if (pwszHttpStack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitConect() : pwszHttpStack is null");
        return 0;
    }

    SESSION* pSession;
    if (SESSION::CreateObject(pwszHttpStack, hSession, pSession) == FALSE)
    {
        return 0;
    }


    DoTraceMessage(PP_LOG_INFO, "Passport Context Initialized");
    
    return reinterpret_cast<PP_CONTEXT>(pSession);
}

// -----------------------------------------------------------------------------
VOID 
PP_FreeContext(
	PP_CONTEXT hPP
    )
{
    if (hPP == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_FreeContext() : hPP is null");
        return;
    }
    
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);
    
    if (pSession->RefCount() > 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "Passport Context ref count not zero before freed");
    }

    delete pSession;

    DoTraceMessage(PP_LOG_INFO, "Passport Context Freed");

//	WPP_CLEANUP();
}

BOOL
PP_GetRealm(
	PP_CONTEXT hPP,
    PWSTR      pwszDARealm,    // user supplied buffer ...
    PDWORD     pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    )
{
    if (hPP == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_FreeContext() : hPP is null");
        return FALSE;
    }
    
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

    return pSession->GetRealm(pwszDARealm, pdwDARealmLen);
}

// -----------------------------------------------------------------------------
PP_LOGON_CONTEXT
PP_InitLogonContext(
	PP_CONTEXT hPP,
    PCWSTR	pwszPartnerInfo,
    DWORD dwParentFlags
    )
{
    if (hPP == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitLogonContext() : hPP is null");
        return 0;
    }

    LOGON* pLogon = new LOGON(reinterpret_cast<SESSION*>(hPP), dwParentFlags);
    if (pLogon == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitLogonContext() failed; not enough memory");
        return 0;
    }

    if (pLogon->Open(pwszPartnerInfo) == FALSE)
    {
        delete pLogon;
        return 0;
    }

    DoTraceMessage(PP_LOG_INFO, "Passport Logon Context Initialized");
    
    return reinterpret_cast<PP_LOGON_CONTEXT>(pLogon);
}

// -----------------------------------------------------------------------------
VOID 
PP_FreeLogonContext(
    PP_LOGON_CONTEXT    hPPLogon
	)
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_FreeLogonContext() : hPPLogon is null");
        return;
    }

    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);
    
    delete  pLogon;

    DoTraceMessage(PP_LOG_INFO, "Passport Logon Context Freed");
}

// -----------------------------------------------------------------------------
DWORD
PP_Logon(
    PP_LOGON_CONTEXT    hPPLogon,
    BOOL                fAnonymous,
	HANDLE	            hEvent,
    PFN_LOGON_CALLBACK  pfnLogonCallback,
    DWORD               dwContext	
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_Logon() : hPPLogon is null");
        return 0;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->Logon(fAnonymous);
}

PLIST_ENTRY
PP_GetPrivacyEvents(
    IN PP_LOGON_CONTEXT hPPLogon
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetPrivacyEvents() : hPPLogon is null");
        return 0;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->GetPrivacyEvents();
}


// -----------------------------------------------------------------------------
BOOL
PP_GetChallengeInfo(
    PP_LOGON_CONTEXT hPPLogon,
	HBITMAP*		 phBitmap,
    PBOOL            pfPrompt,
  	PWSTR			 pwszCbText,
    PDWORD           pdwTextLen,
    PWSTR            pwszRealm,
    DWORD            dwMaxRealmLen,
    PWSTR            pwszReqUserName,
    PDWORD           pdwReqUserNameLen
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetInfoFromChallenge() : hPPLogon is null");
        return FALSE;
    }

	//PP_ASSERT(ppBitmap != NULL);
	//PP_ASSERT(pfPrompt != NULL);
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

	return pLogon->GetChallengeInfo(phBitmap,
									pfPrompt,
                                    pwszCbText,
                                    pdwTextLen,
                                    pwszRealm,
                                    dwMaxRealmLen,
                                    pwszReqUserName,
                                    pdwReqUserNameLen);
}

// -----------------------------------------------------------------------------
BOOL 
PP_SetCredentials(
    PP_LOGON_CONTEXT    hPPLogon,
    PCWSTR              pwszRealm,
    PCWSTR              pwszTarget,
    PCWSTR              pwszSignIn,
    PCWSTR              pwszPassword,
    PSYSTEMTIME         pTimeCredsEntered
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_SetCredentials() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->SetCredentials(pwszRealm, 
                                  pwszTarget, 
                                  pwszSignIn, 
                                  pwszPassword, 
                                  pTimeCredsEntered);
}

BOOL
PP_GetLogonHost(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszHostName,    // user supplied buffer ...
	IN OUT PDWORD       pdwHostNameLen  // ... and length (will be updated to actual length 
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetLogonHost() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);
    
    return pLogon->GetLogonHost(pwszHostName, pdwHostNameLen);
}


// -----------------------------------------------------------------------------
BOOL 
PP_GetAuthorizationInfo(
    PP_LOGON_CONTEXT hPPLogon,
	PWSTR            pwszTicket,       // e.g. "from-PP = ..."
	OUT PDWORD       pdwTicketLen,
	PBOOL            pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
	PWSTR            pwszUrl,    // user supplied buffer ...
	OUT PDWORD       pdwUrlLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	)
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetReturnVerbAndUrl() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->GetAuthorizationInfo(pwszTicket, 
                                        pdwTicketLen, 
                                        pfKeepVerb, 
                                        pwszUrl, 
                                        pdwUrlLen);
}

BOOL
PP_GetChallengeContent(
    IN PP_LOGON_CONTEXT hPPLogon,
  	IN PBYTE    	    pContent,
    IN OUT PDWORD       pdwContentLen
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetChallengeContent() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->GetChallengeContent(pContent,
                                       pdwContentLen);
}

// -----------------------------------------------------------------------------
VOID 
PP_Logout(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN DWORD               dwFlags
    )
{

    // todo - flush passport cookies


    // set flag to ignore credmgr so we don't just auto-logon again
    g_fIgnoreCachedCredsForPassport = TRUE;    

    // unset our login flag and username
    g_fCurrentProcessLoggedOn = FALSE;
    memset ( g_szUserNameLoggedOn, 0, INTERNET_MAX_USER_NAME_LENGTH*sizeof(WCHAR) );

}

BOOL
PP_ForceNexusLookup(
    PP_LOGON_CONTEXT    hPP,
    IN BOOL             fForce,
    IN PWSTR            pwszRegUrl,    // user supplied buffer ...
    IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
    IN PWSTR            pwszDARealm,    // user supplied buffer ...
    IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	)
{

    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

	if ( pSession != NULL )
	{
	    return pSession->GetDAInfoFromPPNexus(fForce,
                                              pwszRegUrl,
                                              pdwRegUrlLen,
                                              pwszDARealm,
                                              pdwDARealmLen);
	}
	else
	{
		return FALSE;
	}

	
}

#define PASSPORT_MAX_REALM_LENGTH   256

// returns TRUE if it was found, with the value copied to pszRealm. 
// pszRealm is expected to be at least PASSPORT_MAX_REALM_LENGTH in length
// returns FALSE if not found
BOOL ReadPassportRealmFromRegistry ( 
    WCHAR* pszRealm 
    )
{
    BOOL retval = FALSE;
    HKEY key;

    if ( pszRealm == NULL )
        return FALSE;

    if ( RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
            0,
            KEY_READ,
            &key) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwSize;

        dwSize = PASSPORT_MAX_REALM_LENGTH * sizeof(WCHAR);

        if ( RegQueryValueExW(
                key,
                L"LoginServerRealm",
                NULL,
                &dwType,
                (LPBYTE)(pszRealm),
                &dwSize) == ERROR_SUCCESS )
        {
            if ( wcslen(pszRealm) > 0 )
                retval = TRUE;
            else
                retval = FALSE;
        }
        else
        {
            retval = FALSE;
            pszRealm[0] = L'\0';
        }

        RegCloseKey(key);

    }

    return retval;

}


// if either pwszUsername or pwszPassword is not NULL, it must represent a string at least 
// INTERNET_MAX_USER_NAME_LENGTH or INTERNET_MAX_PASSWORD_LENGTH chars long, respectively

BOOL
PP_GetCachedCredential(
    PP_LOGON_CONTEXT    hPP,
    IN PWSTR            pwszRealm,
    IN PWSTR            pwszTarget,
    OUT PWSTR           pwszUsername,
    OUT PWSTR           pwszPassword
	)
{

    BOOL bRetVal = FALSE;
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

    if ( pSession != NULL )
    {
        PCREDENTIALW* ppCreds;
        DWORD dwNumCreds;
        WCHAR szRealm[PASSPORT_MAX_REALM_LENGTH];
        WCHAR* pszRealm;

        if ( pwszRealm == NULL )
        {
            ReadPassportRealmFromRegistry ( szRealm );
            pszRealm = szRealm;
        }
        else
        {
            pszRealm = pwszRealm;
        }

        if (pSession->GetCachedCreds(pszRealm,
                                     pwszTarget,
                                     &ppCreds,
                                     &dwNumCreds) )
	    {
		    // look for the right cred
		    WCHAR wPass[256];
		    PCREDENTIALW pCredToUse = NULL;

		    if (dwNumCreds > 0 && ppCreds[0] != NULL )
		    {
			    for ( DWORD idx = 0; idx < dwNumCreds; idx++ )
			    {
				    if ( ppCreds[idx]->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD )
				    {
					    // check to see if prompt bit is set.   If set, keep looking, only use if
					    // the prompt bit isn't set.
					    if ( !(ppCreds[idx]->Flags & CRED_FLAGS_PROMPT_NOW) )
					    {
						    pCredToUse = ppCreds[idx];
						    break;
					    }
				    }
			    }
		    }



		    if (pCredToUse )
		    {
			    bRetVal = TRUE;

			    DecryptPassword(wPass, 
					      PVOID(pCredToUse->CredentialBlob), 
					      pCredToUse->CredentialBlobSize);

			    if ( pwszUsername != NULL )
			    {
				    wcsncpy ( pwszUsername, pCredToUse->UserName, INTERNET_MAX_USER_NAME_LENGTH-1 );
			    }

			    if ( pwszPassword != NULL )
			    {
				    wcsncpy ( pwszPassword, wPass, INTERNET_MAX_PASSWORD_LENGTH-1 );
			    }
		    }

	    }


    }

    return bRetVal;
	
}



#ifdef PP_DEMO

// -----------------------------------------------------------------------------
BOOL PP_ContactPartner(
	PP_CONTEXT hPP,
    PCWSTR pwszPartnerUrl,
    PCWSTR pwszVerb,
    PCWSTR pwszHeaders,
    PWSTR pwszData,
    PDWORD pdwDataLength
    )
{
    if (hPP == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_ContactPartner() : hPPLogon is null");
        return FALSE;
    }
    
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

    return pSession->ContactPartner(pwszPartnerUrl,
                                    pwszVerb,
                                    pwszHeaders,
                                    pwszData,
                                    pdwDataLength
                                    );
}

#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\dload\imgutil.c ===
#include "inetcorepch.h"
#pragma hdrstop

#include <ddraw.h>
#include <imgutil.h>

static
HRESULT
WINAPI
DecodeImage(
    IStream* pStream,
    IMapMIMEToCLSID* pMap,
    IUnknown* pEventSink
    )
{
    return E_FAIL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(imgutil)
{
    DLPENTRY(DecodeImage)
};

DEFINE_PROCNAME_MAP(imgutil)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\dload\inetcomm.c ===
#include "inetcorepch.h"
#pragma hdrstop

#define _MIMEOLE_
#include <mimeole.h>

#undef MIMEOLEAPI
#define MIMEOLEAPI       HRESULT STDAPICALLTYPE


static
MIMEOLEAPI
MimeOleCreateVirtualStream(
    IStream **ppStream
    )
{
    if (ppStream)
    {
        *ppStream = NULL;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
MIMEOLEAPI
MimeOleCreateMessage(
    IUnknown *pUnkOuter,
    IMimeMessage **ppMessage
    )
{
    if (ppMessage)
    {
        *ppMessage = NULL;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
MIMEOLEAPI
MimeOleSetCompatMode(
    DWORD dwMode
    )
{
    return S_OK;
}

static
MIMEOLEAPI
MimeOleParseMhtmlUrl(
    LPSTR pszUrl,
    LPSTR *ppszRootUrl,
    LPSTR *ppszBodyUrl
    )
{
    if (pszUrl)
    {
        if (ppszRootUrl)
        {
            *ppszRootUrl = NULL;
        }

        if (ppszBodyUrl)
        {
            *ppszBodyUrl = NULL;
        }
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}        


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(inetcomm)
{
    DLPENTRY(MimeOleCreateMessage)
    DLPENTRY(MimeOleCreateVirtualStream)
    DLPENTRY(MimeOleParseMhtmlUrl)
    DLPENTRY(MimeOleSetCompatMode)
};

DEFINE_PROCNAME_MAP(inetcomm)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\dload\mshtml.c ===
#include "inetcorepch.h"
#pragma hdrstop

#include <mshtmhst.h>

#undef STDAPI
#define STDAPI  HRESULT WINAPI


static
STDAPI
ShowHTMLDialog(                   
    HWND        hwndParent,              
    IMoniker *  pMk,                     
    VARIANT *   pvarArgIn,               
    WCHAR *     pchOptions,              
    VARIANT *   pvarArgOut               
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
ShowHTMLDialogEx(
    HWND        hwndParent,
    IMoniker *  pMk,
    DWORD       dwDialogFlags,
    VARIANT *   pvarArgIn,
    WCHAR *     pchOptions,
    VARIANT *   pvarArgOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
ShowModelessHTMLDialog(
    HWND        hwndParent,
    IMoniker *  pMk,
    VARIANT *   pvarArgIn,
    VARIANT *   pvarOptions,
    IHTMLWindow2 ** ppWindow)
{
    if (ppWindow)
    {
        *ppWindow = NULL;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mshtml)
{
    DLPENTRY(ShowHTMLDialog)
    DLPENTRY(ShowHTMLDialogEx)
    DLPENTRY(ShowModelessHTMLDialog)
};

DEFINE_PROCNAME_MAP(mshtml)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\advpub.h ===
//*     Copyright (c) Microsoft Corporation 1995-1998. All rights reserved. *
//***************************************************************************
//*                                                                         *
//* ADVPUB.H - Specify the Interface for ADVPACK.DLL                        *
//*                                                                         *
//***************************************************************************


#ifndef _ADVPUB_H_
#define _ADVPUB_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RunSetupCommand
//
// SYNOPSIS:    Execute an install section in an INF file, or execute a
//              program.  Advanced INF files are supported.
//
// RETURN CODES:
//
//      S_OK                                 Everything OK, no reboot needed.
//                                           No EXE to wait for.
//      S_ASYNCHRONOUS                       Please wait on phEXE.
//      ERROR_SUCCESS_REBOOT_REQUIRED        Reboot required.
//      E_INVALIDARG                         NULL specified in szCmdName or szDir
//      HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION) INF's not supported on this OS version
//      E_UNEXPECTED                         Catastrophic failure(should never happen).
//      HRESULT_FROM_WIN32(GetLastError())   Anything else
/////////////////////////////////////////////////////////////////////////////

#ifndef S_ASYNCHRONOUS
#define S_ASYNCHRONOUS  _HRESULT_TYPEDEF_(0x401e8L)
#endif

#define achRUNSETUPCOMMANDFUNCTION   "RunSetupCommand"

HRESULT WINAPI RunSetupCommand( HWND hWnd, LPCSTR szCmdName,
                                LPCSTR szInfSection, LPCSTR szDir,
                                LPCSTR lpszTitle, HANDLE *phEXE,
                                DWORD dwFlags, LPVOID pvReserved );

typedef HRESULT (WINAPI *RUNSETUPCOMMAND)(
    HWND    hWnd,                       // Handle to parent window  NULL=Quiet mode
    LPCSTR  szCmdName,                  // Inf or EXE filename to "run"
    LPCSTR  szInfSection,               // Inf section to install.  NULL="DefaultInstall"
    LPCSTR  szDir,                      // Path to extracted files
    LPCSTR  szTitle,                    // Title for all dialogs
    HANDLE *phEXE,                      // Handle to EXE to wait for
    DWORD   dwFlags,                    // Flags to specify functionality (see above)
    LPVOID  pvReserved                  // Reserved for future use
);

// FLAGS:

#define RSC_FLAG_INF                1   // exxcute INF install
#define RSC_FLAG_SKIPDISKSPACECHECK 2   // Currently does nothing
#define RSC_FLAG_QUIET              4   // quiet mode, no UI
#define RSC_FLAG_NGCONV             8   // don't run groupConv
#define RSC_FLAG_UPDHLPDLLS         16  // force to self-updating on user's system
#define RSC_FLAG_DELAYREGISTEROCX  512  // force delay of ocx registration
#define RSC_FLAG_SETUPAPI	  1024  // use setupapi.dll

// please not adding flag after this.  See LaunchINFSectionEx() flags.

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: NeedRebootInit
//
// SYNOPSIS:    Initializes state for reboot checking.  Call this function
//              before calling RunSetupCommand.
// RETURNS:     value required to be passed to NeedReboot()
/////////////////////////////////////////////////////////////////////////////

#define achNEEDREBOOTINITFUNCTION   "NeedRebootInit"

DWORD WINAPI NeedRebootInit( VOID );

typedef DWORD (WINAPI *NEEDREBOOTINIT)(VOID);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: NeedReboot
//
// SYNOPSIS:    Compares stored state with current state to determine if a
//              reboot is required.
//      dwRebootCheck   the return value from NeedRebootInit
//
// RETURNS:
//      TRUE            if a reboot is required;
//      FALSE           otherwise.
/////////////////////////////////////////////////////////////////////////////

#define achNEEDREBOOTFUNCTION   "NeedReboot"

BOOL WINAPI NeedReboot( DWORD dwRebootCheck );

typedef BOOL (WINAPI *NEEDREBOOT)(
	DWORD dwRebootCheck                                     // Value returned from NeedRebootInit
);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DoReboot
//
// SYNOPSIS:    Ask advpack to do reboot.
//      hwnd        if it is INVALID_HANDLE_VALUE, no user prompt.  Otherwise promp.
//      pszTitle    User prompt UI title string.
//      dwReserved  Not used.
// RETURNS:
//      FALSE       User choose NO to reboot prompt.
/////////////////////////////////////////////////////////////////////////////

// #define achDOREBOOT "DoReboot"

// BOOL WINAPI DoReboot( HWND hwnd, BOOL bDoUI );
// typedef BOOL (WINAPI* DOREBOOT)( HWND hwnd, BOOL bDoUI );

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RebootCheckOnInstall
//
// SYNOPSIS:    Check reboot condition if the given INF section is installed.
//      hwnd    windows handle
//      pszINF  INF filename with fully qualified path
//      pszSec  INF section.  NULL is translated as DefaultInstall or DefaultInstall.NT.
//      dwReserved Not used.
// RETURN:
//      S_OK    Reboot needed if INF section is installed.
//      S_FALSE Reboot is not needed if INF section is installed.
//      HRESULT of Win 32 errors
//
/////////////////////////////////////////////////////////////////////////////

#define achPRECHECKREBOOT   "RebootCheckOnInstall"

HRESULT WINAPI RebootCheckOnInstall( HWND hwnd, PCSTR pszINF, PCSTR pszSec, DWORD dwReserved );

typedef HRESULT (WINAPI *REBOOTCHECKONINSTALL)( HWND, PCSTR, PCSTR, DWORD );

//////////////////////////////////////////////////////////////////////////
// ENTRY POINT: TranslateInfString
//
// SYNOPSIS:    Translates a key value in an INF file, using advanced INF
//              syntax.
// RETURN CODES:
//      S_OK                                 Everything OK.
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//                                      The buffer size is too small to hold the
//                                      translated string.  Required size is in *pdwRequiredSize.
//      E_INVALIDARG                         NULL specified in pszInfFilename, pszTranslateSection,
//                                      pszTranslateKey, pdwRequiredSize.
//      HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION)
//                                      OS not supported.
//      E_UNEXPECTED                         Catastrophic failure -- should never happen.
//      HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)
//                                      The section or key specified does not exist.
//      HRESULT_FROM_WIN32(GetLastError())   Anything else
//
/////////////////////////////////////////////////////////////////////////////

#define c_szTRANSLATEINFSTRING "TranslateInfString"

HRESULT WINAPI TranslateInfString( PCSTR pszInfFilename, PCSTR pszInstallSection,
                                   PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                                   PSTR pszBuffer, DWORD dwBufferSize,
                                   PDWORD pdwRequiredSize, PVOID pvReserved );

typedef HRESULT (WINAPI *TRANSLATEINFSTRING)(
    PCSTR  pszInfFilename,              // Name of INF file to process
    PCSTR  pszInstallSection,           // Install section name (NULL=DefaultInstall)
    PCSTR  pszTranslateSection,         // Section that contains key to translate
    PCSTR  pszTranslateKey,             // Key to translate
    PSTR   pszBuffer,                   // Buffer to store translated key.  (NULL=return required size only)
    DWORD  dwBufferSize,                // Size of this buffer.  If pszBuffer==NULL, this is ignored.
    PDWORD pdwRequiredSize,             // Required size of buffer
    PVOID  pvReserved                   // Reserved for future use
);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RegInstall
//
// SYNOPSIS:    Loads an INF from a string resource, adds some entries to the
//              INF string substitution table, and executes the INF.
// RETURNS:
//      S_OK    success.
//      E_FAIL  failure,
/////////////////////////////////////////////////////////////////////////////

#define achREGINSTALL   "RegInstall"

typedef struct _StrEntry {
    LPSTR   pszName;            // String to substitute
    LPSTR   pszValue;           // Replacement string or string resource
} STRENTRY, *LPSTRENTRY;

typedef const STRENTRY CSTRENTRY;
typedef CSTRENTRY *LPCSTRENTRY;

typedef struct _StrTable {
    DWORD       cEntries;       // Number of entries in the table
    LPSTRENTRY  pse;            // Array of entries
} STRTABLE, *LPSTRTABLE;

typedef const STRTABLE CSTRTABLE;
typedef CSTRTABLE *LPCSTRTABLE;

HRESULT WINAPI RegInstall( HMODULE hm, LPCSTR pszSection, LPCSTRTABLE pstTable );

typedef HRESULT (WINAPI *REGINSTALL)(
    HMODULE hm,                         // Module that contains REGINST resource
    LPCSTR pszSection,                  // Section of INF to execute
    LPCSTRTABLE pstTable                // Additional string substitutions
);


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: LaunchINFSectionEx
//
// SYNOPSIS:    Install INF section with BACKUP/ROLLBACK capabilities.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#define achLAUNCHINFSECTIONEX   "LaunchINFSectionEx"

HRESULT WINAPI LaunchINFSectionEx( HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow );

typedef HRESULT (WINAPI *LAUNCHINFSECTIONEX)(
    HWND     hwnd,                      // pass in window handle
    HINSTANCE hInst,                    // instance handle
    PSTR     pszParams,                 // String contains params: INF,section,CAB,flags
    INT      nShow
);

// FLAGS:
// FLAGS value this way is for compatibility. Don't change them.
//
#define ALINF_QUIET              4      // quiet mode, no UI
#define ALINF_NGCONV             8      // don't run groupConv
#define ALINF_UPDHLPDLLS         16     // force to self-updating on user's system
#define ALINF_BKINSTALL          32     // backup data before install
#define ALINF_ROLLBACK           64     // rollback to previous state
#define ALINF_CHECKBKDATA        128    // validate the backup data
#define ALINF_ROLLBKDOALL        256    // bypass building file list
#define ALINF_DELAYREGISTEROCX   512    // force delay of ocx registration


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: ExecuteCab
//
// SYNOPSIS:    Extract the an INF from the CAB file, and do INF install on it.
/////////////////////////////////////////////////////////////////////////////

// RETURNS: E_FAIL on failure, S_OK on success.

#define achEXECUTECAB   "ExecuteCab"

typedef struct _CabInfo {
    PSTR  pszCab;
    PSTR  pszInf;
    PSTR  pszSection;
    char  szSrcPath[MAX_PATH];
    DWORD dwFlags;
} CABINFO, *PCABINFO;

HRESULT WINAPI ExecuteCab( HWND hwnd, PCABINFO pCab, LPVOID pReserved );

typedef HRESULT (WINAPI *EXECUTECAB)(
    HWND     hwnd,
    PCABINFO pCab,
    LPVOID   pReserved
);

// flag as LaunchINFSectionEx's flag defines

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: AdvInstallFile
//
// SYNOPSIS:    To copy a file from the source to a destination
//              Basicly a wrapper around the setupapi file copy engine
/////////////////////////////////////////////////////////////////////////////

// Flags which can be passed to AdvInstallFile
// Here is a copy of the flags defined in setupapi.h for reference below.
//#define COPYFLG_WARN_IF_SKIP            0x00000001   // warn if user tries to skip file
//#define COPYFLG_NOSKIP                  0x00000002   // disallow skipping this file
//#define COPYFLG_NOVERSIONCHECK          0x00000004   // ignore versions and overwrite target
//#define COPYFLG_FORCE_FILE_IN_USE       0x00000008   // force file-in-use behavior
//#define COPYFLG_NO_OVERWRITE            0x00000010   // do not copy if file exists on target
//#define COPYFLG_NO_VERSION_DIALOG       0x00000020   // do not copy if target is newer
//#define COPYFLG_REPLACEONLY             0x00000400   // copy only if file exists on target

#define AIF_WARNIFSKIP          0x00000001              // system critical file: warn if user tries to skip
#define AIF_NOSKIP              0x00000002              // Skip is disallowed for this file
#define AIF_NOVERSIONCHECK      0x00000004              // don't check the version number of the file overwrite
#define AIF_FORCE_FILE_IN_USE   0x00000008              // force file-in-use behavior
#define AIF_NOOVERWRITE         0x00000010              // copy only if target doesn't exist
                                                        // if AIF_QUIET, the file is not copied and
                                                        // the user is not notified
#define AIF_NO_VERSION_DIALOG   0x00000020              // do not copy if target is newer
#define AIF_REPLACEONLY         0x00000400              // copy only if target file already present

// Flags only known to AdvInstallFile
#define AIF_NOLANGUAGECHECK     0x10000000              // don't check the language of the file
                                                        // if the flags is NOT specified and AIF_QUIET
                                                        // the file is not copied and the user is not notified
#define AIF_QUIET               0x20000000              // No UI to the user


#define achADVINSTALLFILE   "AdvInstallFile"

HRESULT WINAPI AdvInstallFile(HWND hwnd, LPCSTR lpszSourceDir, LPCSTR lpszSourceFile,
                              LPCSTR lpszDestDir, LPCSTR lpszDestFile, DWORD dwFlags, DWORD dwReserved);

typedef HRESULT (WINAPI *ADVINSTALLFILE)(
                                            HWND hwnd,                  // Parent Window for messages
                                            LPCSTR lpszSourceDir,       // Source directory (does not contain filename)
                                            LPCSTR lpszSourceFile,      // Filename only
                                            LPCSTR lpszDestDir,         // Destination directory (does not contain filename)
                                            LPCSTR lpszDestFile,        // optional filename. if NULL lpszSourceFile is used
                                            DWORD dwFlags,              // AIF_* FLAGS
                                            DWORD dwReserved);

//////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////
// the following flags are for backwards compatiable.  No API user
// should reference them directly now.
//
#define  IE4_RESTORE        0x00000001      // if this bit is off, save the registries.
#define  IE4_BACKNEW        0x00000002      // backup all files which are not backed up before
#define  IE4_NODELETENEW    0x00000004      // don't delete files we don't backed up before
#define  IE4_NOMESSAGES     0x00000008      // No message display in any events.
#define  IE4_NOPROGRESS     0x00000010      // this bit on: No file backup progressbar
#define  IE4_NOENUMKEY      0x00000020      // this bit on: Don't Enum sub key even there is no given valuename
#define  IE4_NO_CRC_MAPPING 0x00000040      // Normally you should not turn on this bit, advpack creates
                                            // internal mapping for all the entries backed up.
#define  IE4_REGSECTION     0x00000080      // INF AddReg/DelReg section
#define  IE4_FRDOALL        0x00000100      // FileRestore DoAll
#define  IE4_UPDREFCNT	    0x00000200      // Update the ref count in .ini backup file list
#define  IE4_USEREFCNT	    0x00000400      // use ref count to determin if the backup file should be put back
#define  IE4_EXTRAINCREFCNT 0x00000800	    // if increase the ref cnt if it has been updated before

#define  IE4_REMOVREGBKDATA 0x00001000      // This bit should be used with restore bit

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RegSaveRestore
//
// SYNOPSIS:    Save or Restore the given register value or given INF reg section.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

// Save or Restore the given register value
HRESULT WINAPI RegSaveRestore(HWND hWnd, PCSTR pszTitleString, HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, DWORD dwFlags);

typedef HRESULT (WINAPI *REGSAVERESTORE)( HWND hWnd,
                                          PCSTR pszTitleString,  // user specified UI title
                                          HKEY hkBckupKey,       // opened Key handle to store the backup data
                                          PCSTR pcszRootKey,     // RootKey string
                                          PCSTR pcszSubKey,      // SubKey string
                                          PCSTR pcszValueName,   // Value name string
                                          DWORD dwFlags);        // Flags

// Save or Restore the given INF Reg Section. At restore, if INF and Section pointers are NULL,
// Restore all from the given backup key handle.
HRESULT WINAPI RegSaveRestoreOnINF( HWND hWnd, PCSTR pszTitle, PCSTR pszINF,
                                    PCSTR pszSection, HKEY hHKLMBackKey, HKEY hHKCUBackKey, DWORD dwFlags );

typedef HRESULT (WINAPI *REGSAVERESTOREONINF)( HWND hWnd,
                                              PCSTR pszTitle,        // user specified UI title
                                              PCSTR pszINF,          // INF filename with fully qualified path
                                              PCSTR pszSection,       // INF section name.  NULL == default
                                              HKEY hHKLMBackKey,       // openned key handle to store the data
                                              HKEY hHKCUBackKey,       // openned key handle to store the data
                                              DWORD dwFlags );       // Flags

// FLAG:
#define ARSR_RESTORE    IE4_RESTORE       // if this bit is off, means Save. Otherwise, restore.
#define ARSR_NOMESSAGES IE4_NOMESSAGES    // Quiet no messages in any event.
#define ARSR_REGSECTION IE4_REGSECTION    // if this bit is off, the given section is GenInstall Section
#define ARSR_REMOVREGBKDATA IE4_REMOVREGBKDATA // if both this bit and restore bit on, remove the backup reg data without restore it

// Turn on the logging by add these RegVale in HKLM\software\microsoft\IE4
#define  REG_SAVE_LOG_KEY    "RegSaveLogFile"
#define  REG_RESTORE_LOG_KEY "RegRestoreLogFile"

// for backwards compatible add this one back
HRESULT WINAPI RegRestoreAll(HWND hWnd, PSTR pszTitleString, HKEY hkBckupKey);
typedef HRESULT (WINAPI *REGRESTOREALL)(HWND hWnd, PSTR pszTitleString, HKEY hkBckupKey);
/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: FileSaveRestore
//
// SYNOPSIS:    Save or Restore the files on the list lpFileList.
//              If lpFileList is NULL at restore time, the function will restore
//              all based on INI index file.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI FileSaveRestore( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags);

typedef HRESULT (WINAPI *FILESAVERESTORE)( HWND hDlg,
                                           LPSTR lpFileList,    // File list file1\0file2\0filen\0\0
                                           LPSTR lpDir,         // pathname of the backup directory
                                           LPSTR lpBaseName,    // backup file basename
                                           DWORD dwFlags);      // Flags

HRESULT WINAPI FileSaveRestoreOnINF( HWND hWnd, PCSTR pszTitle, PCSTR pszINF,
                                     PCSTR pszSection, PCSTR pszBackupDir, PCSTR pszBaseBackupFile,
                                     DWORD dwFlags );

typedef HRESULT (WINAPI *FILESAVERESTOREONINF)( HWND hDlg,
                                                  PCSTR pszTitle,        // user specified UI title
                                                  PCSTR pszINF,          // INF filename with fully qualified path
                                                  PCSTR pszSection,      // GenInstall INF section name.  NULL == default
                                                  PCSTR pszBackupDir,    // directory to store the backup file
                                                  PCSTR pszBaseBackFile, // Basename of the backup data files
                                                  DWORD dwFlags );       // Flags


// FLAGS:
#define  AFSR_RESTORE        IE4_RESTORE      // if this bit is off, save the file.
#define  AFSR_BACKNEW        IE4_BACKNEW      // backup all files which are not backed up before
#define  AFSR_NODELETENEW    IE4_NODELETENEW  // don't delete files we don't backed up before
#define  AFSR_NOMESSAGES     IE4_NOMESSAGES   // No message display in any events.
#define  AFSR_NOPROGRESS     IE4_NOPROGRESS   // this bit on: No file backup progressbar
#define  AFSR_UPDREFCNT      IE4_UPDREFCNT    // update the reference count for the files
#define  AFSR_USEREFCNT	     IE4_USEREFCNT    // use the ref count to guide the restore file
#define  AFSR_EXTRAINCREFCNT IE4_EXTRAINCREFCNT

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: AddDelBackupEntry
//
// SYNOPSIS:    If AADBE_ADD_ENTRY is specified, mark the file in the File list as not existing
//              during file save in the INI file.  This can be used to mark additional files that
//              they did not exist during backup to avoid having them backup the next time the
//              FileSaveRestore is called to save files.
//              If AADBE_DEL_ENTRY is specified, delete the entry from the INI.  This mechanism can
//              be used to leave files permanently on the system.
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI AddDelBackupEntry(LPCSTR lpcszFileList, LPCSTR lpcszBackupDir, LPCSTR lpcszBaseName, DWORD dwFlags);

typedef HRESULT (WINAPI *ADDDELBACKUPENTRY)(LPCSTR lpcszFileList,   // File list file1\0file2\0filen\0\0
                                           LPCSTR lpcszBackupDir,   // pathname of the backup directory
                                           LPCSTR lpcszBaseName,    // backup file basename
                                           DWORD  dwFlags);

#define  AADBE_ADD_ENTRY    0x01            // add entries to the INI file
#define  AADBE_DEL_ENTRY    0x02            // delete entries from the INI file

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: FileSaveMarkNotExist
//
// SYNOPSIS:    Mark the file in the File list as not existing during file save in the INI file
//              This can be used to mark additional files that they did not exist during backup
//              to avoid having them backup the next time the FileSaveRestore is called to save
//              files
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI FileSaveMarkNotExist( LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName);

typedef HRESULT (WINAPI *FILESAVEMARKNOTEXIST)( LPSTR lpFileList,    // File list file1\0file2\0filen\0\0
                                           LPSTR lpDir,         // pathname of the backup directory
                                           LPSTR lpBaseName);    // backup file basename

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: GetVersionFromFile
//
// SYNOPSIS:    Get the given file's version and lang information.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI GetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);

typedef HRESULT (WINAPI *GETVERSIONFROMFILE)(
                                                LPSTR lpszFilename,         // filename to get info from
                                                LPDWORD pdwMSVer,           // Receive Major version
                                                LPDWORD pdwLSVer,           // Receive Minor version
                                                BOOL bVersion);             // if FALSE, pdwMSVer receive lang ID
                                                                            // pdwLSVer receive Codepage ID

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: GetVersionFromFileEx
//
// SYNOPSIS:    Get the given disk file's version and lang information.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI GetVersionFromFileEx(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);

typedef HRESULT (WINAPI *GETVERSIONFROMFILE)(
                                                LPSTR lpszFilename,         // filename to get info from
                                                LPDWORD pdwMSVer,           // Receive Major version
                                                LPDWORD pdwLSVer,           // Receive Minor version
                                                BOOL bVersion);             // if FALSE, pdwMSVer receive lang ID
                                                                            // pdwLSVer receive Codepage ID

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: IsNTAdmin
//
// SYNOPSIS:    On NT, check if user has admin right.
//
// RETURNS:     TURE  has admin right; FLSE  no admin right.
/////////////////////////////////////////////////////////////////////////////

#define achISNTADMIN "IsNTAdmin"

BOOL WINAPI IsNTAdmin( DWORD dwReserved, DWORD *lpdwReserved );

typedef BOOL (WINAPI *ISNTADMIN)( DWORD,        // not used
                                  DWORD * );    // not used

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DelNode
//
// SYNOPSIS:    Deletes a file or directory
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

// FLAGS:
#define ADN_DEL_IF_EMPTY        0x00000001  // delete the directory only if it's empty
#define ADN_DONT_DEL_SUBDIRS    0x00000002  // don't delete any sub-dirs; delete only the files
#define ADN_DONT_DEL_DIR        0x00000004  // don't delete the dir itself
#define ADN_DEL_UNC_PATHS       0x00000008  // delete UNC paths

#define achDELNODE              "DelNode"

HRESULT WINAPI DelNode(LPCSTR pszFileOrDirName, DWORD dwFlags);

typedef HRESULT (WINAPI *DELNODE)(
    LPCSTR pszFileOrDirName,                // Name of file or directory to delete
    DWORD dwFlags                           // 0, ADN_DEL_IF_EMPTY, etc. can be specified
);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DelNodeRunDLL32
//
// SYNOPSIS:    Deletes a file or directory; the parameters to this API are of
//              WinMain type
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#define achDELNODERUNDLL32      "DelNodeRunDLL32"

HRESULT WINAPI DelNodeRunDLL32(HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow);

typedef HRESULT (WINAPI *DELNODERUNDLL32)(
    HWND     hwnd,                          // pass in window handle
    HINSTANCE hInst,                        // instance handle
    PSTR     pszParams,                     // String contains params: FileOrDirName,Flags
    INT      nShow
);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: OpenINFEngine, TranslateINFStringEx, CloseINFEngine
//
// SYNOPSIS:    Three APIs give the caller the option to be more efficient when need
//              Advpack to translate INF file in a continue fashion.
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#if !defined(UNIX) || !defined(_INC_SETUPAPI) // IEUNIX: Prevent re-def.
//
// Define type for reference to loaded inf file
// (from setupapi.h)
//
typedef PVOID HINF;
#endif

HRESULT WINAPI OpenINFEngine( PCSTR pszInfFilename, PCSTR pszInstallSection,
                              DWORD dwFlags, HINF *phInf, PVOID pvReserved );

HRESULT WINAPI TranslateInfStringEx( HINF hInf, PCSTR pszInfFilename,
                                     PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                                     PSTR pszBuffer, DWORD dwBufferSize,
                                     PDWORD pdwRequiredSize, PVOID pvReserved );

HRESULT WINAPI CloseINFEngine( HINF hInf );



HRESULT WINAPI ExtractFiles( LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
                             LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: LaunchINFSection
//
// SYNOPSIS:    Install INF section WITHOUT BACKUP/ROLLBACK capabilities.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

INT     WINAPI LaunchINFSection( HWND, HINSTANCE, PSTR, INT );

// LaunchINFSection flags
#define LIS_QUIET               0x0001      // Bit 0
#define LIS_NOGRPCONV           0x0002      // Bit 1

// Flags in Advanced INF RunPreSetupCommands and RunPostSetupCommands of the Install section
// Those flags can tell advpack how to run those commands, quiet or not quiet, wait or not wait.
// The Default for runing those commands are:  Not Quiet and Wait for finish before return the caller.
// I.E>  RunPostSetupCommands = MyCmdsSecA:1, MyCmdsSecB:2, MyCmdsSecC
//
#define RUNCMDS_QUIET		0x00000001
#define RUNCMDS_NOWAIT		0x00000002
#define RUNCMDS_DELAYPOSTCMD	0x00000004

// Active Setup Installed Components GUID for IE4
#define awchMSIE4GUID L"{89820200-ECBD-11cf-8B85-00AA005B4383}"

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: UserStubWrapper
//
// SYNOPSIS:    The function wrapper around the real per-user restore stub to 
//              do some generic/intelligent function on behalf of every component.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI UserInstStubWrapper( HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow ); 

#define achUserInstStubWrapper      "UserInstStubWrapper"

typedef HRESULT (WINAPI *USERINSTSTUBWRAPPER)(
                                           HWND     hwnd,                          // pass in window handle
                                           HINSTANCE hInst,                        // instance handle
                                           PSTR     pszParams,                     // String contains params: {GUID}
                                           INT      nShow
                                          );

HRESULT WINAPI UserUnInstStubWrapper( HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow ); 

#define achUserUnInstStubWrapper      "UserUnInstStubWrapper"

typedef HRESULT (WINAPI *USERUNINSTSTUBWRAPPER)(
                                           HWND     hwnd,                          // pass in window handle
                                           HINSTANCE hInst,                        // instance handle
                                           PSTR     pszParams,                     // String contains params: {GUID}
                                           INT      nShow
                                          );

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: SetPerUserInstValues
//
// SYNOPSIS:    The function set the per-user stub reg values under IsInstalled\{GUID} 
//              related key to ensure the later per-user process correctly.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

// Args passed to the following API
// MAX_GUID_STRING_LEN is 39 defined in cfgmgr32.h, here we just use it.
//
typedef struct _PERUSERSECTION { char szGUID[39+20];
                                 char szDispName[128];
       		                 char szLocale[10];
                                 char szStub[MAX_PATH*4];
                                 char szVersion[32];
                				 char szCompID[128]; 
                                 DWORD dwIsInstalled;
                                 BOOL  bRollback;
} PERUSERSECTION, *PPERUSERSECTION;


HRESULT WINAPI SetPerUserSecValues( PPERUSERSECTION pPerUser );

#define achSetPerUserSecValues      "SetPerUserSecValues"

typedef HRESULT (WINAPI *SETPERUSERSECVALUES)( PPERUSERSECTION pPerUser );


/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif // _ADVPUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\dload\wininet.c ===
#include "inetcorepch.h"
#pragma hdrstop

#define _WINX32_
#include <wininet.h>
#include <winineti.h>

#undef  INTERNETAPI
#define INTERNETAPI         HRESULT STDAPICALLTYPE
#undef  INTERNETAPI_
#define INTERNETAPI_(type)  type STDAPICALLTYPE
#undef  BOOLAPI
#define BOOLAPI             BOOL STDAPICALLTYPE
#undef  STDAPI
#define STDAPI              HRESULT STDAPICALLTYPE
#undef  STDAPI_
#define STDAPI_(type)       type STDAPICALLTYPE
#undef  URLCACHEAPI_
#define URLCACHEAPI_(type)  type STDAPICALLTYPE    

static
BOOLAPI
CreateUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCWSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(DWORD) 
InternetAttemptConnect(
    IN DWORD dwReserved
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID
InternetAutodialCallback(
    IN DWORD dwOpCode,
    IN LPCVOID lpParam
    )
{
    return;
}

static
INTERNETAPI_(BOOL) 
InternetAutodial(
    IN DWORD    dwFlags,
    IN HWND     hwndParent
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
	return FALSE;
}

static
INTERNETAPI_(BOOL) 
InternetCheckConnectionW(
    IN      LPCWSTR   pszUrlW,
    IN      DWORD   dwFlags,
    IN      DWORD   dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
InternetCombineUrlW(
    IN LPCWSTR pszBaseUrl,
    IN LPCWSTR pszRelativeUrl,
    OUT LPWSTR pszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
InternetEnumPerSiteCookieDecisionA(
    OUT LPSTR pszSiteName, 
    IN OUT unsigned long *pcSiteNameSize, 
    OUT unsigned long *pdwDecision, 
    IN unsigned long dwIndex
    ) 
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
InternetOpenUrlW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
BOOLAPI
CommitUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPWSTR lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCWSTR lpszFileExtension,
    IN LPCWSTR lpszOriginalUrl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    *lpdwNumberOfBytesRead = 0;
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )
{
    return NULL;
}

static
BOOLAPI
InternetCloseHandle(
    IN HINTERNET hInternet
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetCrackUrlW(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW lpUrlComponents
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
InternetConnectW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
INTERNETAPI_(HINTERNET)
HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
INTERNETAPI_(BOOL) 
HttpEndRequestA(
    IN HINTERNET hRequest,
    OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
	SetLastError(ERROR_PROC_NOT_FOUND);
	return FALSE;
}

static
INTERNETAPI_(BOOL) 
HttpEndRequestW(
    IN HINTERNET hRequest,
    OUT LPINTERNET_BUFFERSW lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
	SetLastError(ERROR_PROC_NOT_FOUND);
	return FALSE;
}

static
INTERNETAPI_(BOOL)
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )
{
	SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
HttpSendRequestExA(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
	SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
HttpSendRequestExW(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERSW lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERSW lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
	 SetLastError(ERROR_PROC_NOT_FOUND);
	 return FALSE;
}


static
INTERNETAPI_(DWORD)
InternetErrorDlg(
    IN HWND hWnd,
    IN OUT HINTERNET hRequest,
    IN DWORD dwError,
    IN DWORD dwFlags,
    IN OUT LPVOID * lppvData
    )
{
    return ERROR_CANCELLED;
}

static
INTERNETAPI_(BOOL)
InternetFortezzaCommand(
    DWORD dwCommand,
    HWND hwnd,
    DWORD_PTR dwReserved
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOLAPI
GetUrlCacheEntryInfoExW(
    IN LPCWSTR lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
    OUT LPWSTR      lpszReserved,
    IN OUT LPDWORD lpdwReserved,
    LPVOID         lpReserved,
    DWORD          dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetGoOnlineW(
    IN LPWSTR   lpszURL,
    IN HWND     hwndParent,
    IN DWORD    dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetQueryFortezzaStatus(
    DWORD *pdwStatus,
    DWORD_PTR dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(DWORD)
InternetConfirmZoneCrossingW(
    IN HWND hWnd,
    IN LPWSTR szUrlPrev,
    IN LPWSTR szUrlNew,
    IN BOOL bPost
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOLAPI
GetUrlCacheEntryInfoExA(
    IN LPCSTR lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
    OUT LPSTR      lpszReserved, 
    IN OUT LPDWORD lpdwReserved,
    LPVOID         lpReserved,
    DWORD          dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
ReadUrlCacheEntryStream(
    IN HANDLE hUrlCacheStream,
    IN DWORD dwLocation,
    IN OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwLen,
    IN DWORD Reserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
STDAPI_(BOOL)
IsProfilesEnabled()
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
CreateUrlCacheContainerA(
    IN LPCSTR Name, 
    IN LPCSTR CachePrefix, 
    IN LPCSTR CachePath, 
    IN DWORD KBCacheLimit,
    IN DWORD dwContainerType,
    IN DWORD dwOptions,
    IN OUT LPVOID pvBuffer,
    IN OUT LPDWORD cbBuffer
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(HANDLE)
FindFirstUrlCacheContainerA(
    IN OUT LPDWORD pdwModified,
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize,
    IN DWORD dwOptions
    )
{
    return NULL;
}

static
URLCACHEAPI_(BOOL)
DeleteUrlCacheContainerA(
    IN LPCSTR Name,
    IN DWORD dwOptions
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
FindNextUrlCacheContainerA(
    IN HANDLE hFind, 
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(HANDLE)
RetrieveUrlCacheEntryStreamW(
    IN LPCWSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    )
{
    return NULL;
}

static
URLCACHEAPI_(BOOL)
UnlockUrlCacheEntryStream(
    HANDLE hStream,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetClearAllPerSiteCookieDecisions()
{
    return TRUE;
}

static
INTERNETAPI_(DWORD)
PrivacySetZonePreferenceW(
    DWORD       dwZone, 
    DWORD       dwType,
    DWORD       dwTemplate,
    LPCWSTR     pszPreference
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
URLCACHEAPI_(BOOL)
DeleteUrlCacheEntryA(
    IN LPCSTR lpszUrlName
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(int)
GetP3PPolicy(
    P3PCURL pszPolicyURL,
    HANDLE hDestination,
    P3PCXSL pszXSLtransform,
    struct P3PSignal *pSignal
    )
{
    return P3P_Error;
}

static
INTERNETAPI_(int)
MapResourceToPolicy(
    struct P3PResource *pResource,
    P3PURL pszPolicy,
    unsigned long dwSize,
    struct P3PSignal *pSignal
    )
{
    return P3P_Error;
}

static
INTERNETAPI_(BOOL)
InternetGetPerSiteCookieDecisionW(
    IN LPCWSTR pwchHostName,
    unsigned long* pResult
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static 
INTERNETAPI_(BOOL) 
InternetEnumPerSiteCookieDecisionW(
    OUT LPWSTR pwszSiteName, 
    IN OUT unsigned long *pcSiteNameSize, 
    OUT unsigned long *pdwDecision, 
    IN unsigned long dwIndex)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetSetPerSiteCookieDecisionW(
    IN LPCWSTR pwchHostName,
    DWORD dwDecision
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(int)
FreeP3PObject(
    P3PHANDLE hObject
    )
{
    return P3P_Done;
}

static
BOOLAPI
ImportCookieFileW(
    IN LPCWSTR szFilename
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
ExportCookieFileW(
    IN LPCWSTR szFilename,
    IN BOOL fAppend
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(HANDLE)
FindFirstUrlCacheContainerW(
    IN OUT DWORD *pdwModified,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
    IN OUT LPDWORD lpcbContainerInfo,
    IN DWORD dwOptions
    )
{
    return NULL;
}

static
URLCACHEAPI_(BOOL)
FindNextUrlCacheContainerW(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
    IN OUT LPDWORD lpcbContainerInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
FindCloseUrlCache(
    IN HANDLE hFind
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetCanonicalizeUrlA(
    IN LPCSTR pszUrl,
    OUT LPSTR pszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetCanonicalizeUrlW(
    IN LPCWSTR pszUrl,
    OUT LPWSTR pszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetGetConnectedStateExA(
    OUT LPDWORD lpdwFlags,
    OUT LPSTR lpszConnectionName,
    IN DWORD dwBufLen,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetGetConnectedState(
    OUT LPDWORD lpdwFlags,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
FindNextUrlCacheEntryA(
    IN HANDLE hFind,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(HANDLE)
FindFirstUrlCacheEntryA(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    )
{
    return NULL;
}

static
URLCACHEAPI_(BOOL)
FreeUrlCacheSpaceW(
    IN LPCWSTR lpszCachePath,
    IN DWORD dwSize,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
FindNextUrlCacheEntryW(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD pcbEntryInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(HANDLE)
FindFirstUrlCacheEntryW(
    IN LPCWSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    return NULL;
}

static
URLCACHEAPI_(BOOL)
DeleteUrlCacheEntryW(
    IN LPCWSTR lpszUrlName
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetShowSecurityInfoByURLW(
    IN LPWSTR    pszUrlW,
    IN HWND      hwndRootWindow
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
SetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
GetUrlCacheConfigInfoW(
    OUT LPINTERNET_CACHE_CONFIG_INFOW pCacheConfigInfo,
    IN OUT LPDWORD pcbCacheConfigInfo,
    IN DWORD dwFieldControl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetCreateUrlW(
    IN LPURL_COMPONENTSW pUCW,
    IN DWORD dwFlags,
    OUT LPWSTR pszUrlW,
    IN OUT LPDWORD pdwUrlLengthW
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
GetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb OPTIONAL,
    IN LPCSTR lpszObjectName OPTIONAL,
    IN LPCSTR lpszVersion OPTIONAL,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
INTERNETAPI_(HINTERNET)
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
INTERNETAPI_(INTERNET_STATUS_CALLBACK)
InternetSetStatusCallbackA(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    )
{
    return INTERNET_INVALID_STATUS_CALLBACK;
}

static
INTERNETAPI_(HINTERNET)
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )
{
    return NULL;
}

static
INTERNETAPI_(BOOL)
InternetCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN LPURL_COMPONENTSA lpUrlComponents
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
HttpAddRequestHeadersW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
RegisterUrlCacheNotification(
    HWND        hWnd, 
    UINT        uMsg, 
    GROUPID     gid, 
    DWORD       dwFilter, 
    DWORD       dwReserve
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
SetUrlCacheEntryGroupW(
    IN LPCWSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes,
    IN DWORD    cbGroupAttributes,
    IN LPVOID   lpReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetTimeToSystemTimeW(
    IN  LPCWSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
GetUrlCacheConfigInfoA(
    LPINTERNET_CACHE_CONFIG_INFOA lpCacheConfigInfo,
    IN OUT LPDWORD lpdwCacheConfigInfoBufferSize,
    DWORD dwFieldControl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetInitializeAutoProxyDll(
    DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(int)
FindP3PPolicySymbol(
    const char *pszSymbol
    )
{
    return -1;
}

static
BOOLAPI
IsDomainLegalCookieDomainW(
    IN LPCWSTR pchDomain,
    IN LPCWSTR pchFullDomain
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(int)
GetP3PRequestStatus(
    P3PHANDLE hObject
    )
{
    return P3P_Error;
}

static
BOOLAPI
HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpPutFileEx(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszLocalFile,
    IN LPCSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpDeleteFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszFileName
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpDeleteFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszFileName
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOLAPI
FtpRenameFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
FtpOpenFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
INTERNETAPI_(HINTERNET)
FtpOpenFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOLAPI
FtpCreateDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpCreateDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
FtpGetCurrentDirectoryW(
    IN HINTERNET hFtpSession,
    OUT LPWSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpRemoveDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
FtpFindFirstFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATAA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    if (lpFindFileData)
    {
        lpFindFileData->cFileName[0] = 0;
    }
    return NULL;
}

static
INTERNETAPI_(HINTERNET)
FtpFindFirstFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATAW lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    if (lpFindFileData)
    {
        lpFindFileData->cFileName[0] = 0;
    }
    return NULL;
}


static
BOOLAPI
FtpCommandA(
    IN HINTERNET hConnect,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCSTR lpszCommand,
    IN DWORD_PTR dwContext,
    OUT HINTERNET *phFtpCommand OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpGetFileEx(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszRemoteFile,
    IN LPCWSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetWriteFile(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwError,
    OUT LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(INTERNET_STATUS_CALLBACK)
InternetSetStatusCallbackW(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetFindNextFileA(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetFindNextFileW(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpGetCurrentDirectoryA(
    IN HINTERNET hConnect,
    OUT LPSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpSetCurrentDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpSetCurrentDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(DWORD)
FtpGetFileSize(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwFileSizeHigh OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET) 
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
CreateUrlCacheEntryA(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwExpectedFileSize,
    IN LPCSTR   lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetTimeToSystemTimeA(
    IN  LPCSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
InternetTimeFromSystemTimeA(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    ) 
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
InternetTimeFromSystemTimeW(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPWSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    ) 
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static 
INTERNETAPI_(BOOL)
InternetQueryOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static 
URLCACHEAPI_(BOOL) 
SetUrlCacheConfigInfoA(
    LPINTERNET_CACHE_CONFIG_INFOA pConfig,
    DWORD dwFieldControl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL) 
CreateUrlCacheContainerW(
        IN LPCWSTR Name,
        IN LPCWSTR CachePrefix,
        IN LPCWSTR CachePath,
        IN DWORD KBCacheLimit,
        IN DWORD dwContainerType,
        IN DWORD dwOptions,
        IN OUT LPVOID pvBuffer,
        IN OUT LPDWORD cbBuffer)
{   
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI InternetAutodialHangup(
    IN DWORD dwReserved
    )
{   
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
LoadUrlCacheContent(VOID)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(GROUPID) CreateUrlCacheGroup(
    IN DWORD  dwFlags,
    IN LPVOID lpReserved  // must pass NULL
    )
{
    GROUPID gid = 0;
    SetLastError(ERROR_PROC_NOT_FOUND);
    return gid;
}

static
BOOLAPI DeleteUrlCacheGroup(
    IN  GROUPID GroupId,
    IN  DWORD   dwFlags,       // must pass 0
    IN  LPVOID  lpReserved    // must pass NULL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) InternetGetConnectedStateExW(
    OUT LPDWORD lpdwFlags,
    OUT LPWSTR  lpszConnectionName,
    IN DWORD    dwNameLen,
    IN DWORD    dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static 
BOOLAPI FindNextUrlCacheEntryExA(
    IN     HANDLE    hEnumHandle,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpReserved,     // must pass NULL
    IN OUT LPDWORD   pcbReserved2,   // must pass NULL
    IN     LPVOID    lpReserved3     // must pass NULL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI FindNextUrlCacheEntryExW(
    IN     HANDLE    hEnumHandle,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpReserved,     // must pass NULL
    IN OUT LPDWORD   pcbReserved2,   // must pass NULL
    IN     LPVOID    lpReserved3     // must pass NULL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HANDLE) FindFirstUrlCacheEntryExA(
    IN     LPCSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpReserved,     // must pass NULL
    IN OUT LPDWORD   pcbReserved2,   // must pass NULL
    IN     LPVOID    lpReserved3     // must pass NULL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
INTERNETAPI_(HANDLE) FindFirstUrlCacheEntryExW(
    IN     LPCWSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpReserved,     // must pass NULL
    IN OUT LPDWORD   pcbReserved2,   // must pass NULL
    IN     LPVOID    lpReserved3     // must pass NULL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOLAPI IsHostInProxyBypassList (INTERNET_SCHEME tScheme, LPCSTR pszHost, DWORD cchHost)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI InternetCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) InternetReadFileExA(
    IN HINTERNET hFile,
    OUT LPINTERNET_BUFFERSA lpBuffersOut,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(DWORD) InternetSetFilePointer(
    IN HINTERNET hFile,
    IN LONG  lDistanceToMove,
    IN PVOID pReserved,
    IN DWORD dwMoveMethod,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) ResumeSuspendedDownload(
    IN HINTERNET hRequest,
    IN DWORD dwResultCode
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI UnlockUrlCacheEntryFileA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI InternetUnlockRequestFile(
    IN HANDLE hLockRequestInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static 
BOOLAPI InternetQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI InternetLockRequestFile(
    IN  HINTERNET hInternet,
    OUT HANDLE * lphLockRequestInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI RetrieveUrlCacheEntryFileA(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(wininet)
{
    DLOENTRY(110, ImportCookieFileW)
    DLOENTRY(111, ExportCookieFileW)
    DLOENTRY(112, IsProfilesEnabled)
    DLOENTRY(117, IsDomainLegalCookieDomainW)
    DLOENTRY(118, FindP3PPolicySymbol)
    DLOENTRY(120, MapResourceToPolicy)
    DLOENTRY(121, GetP3PPolicy)
    DLOENTRY(122, FreeP3PObject)
    DLOENTRY(123, GetP3PRequestStatus)
};

DEFINE_ORDINAL_MAP(wininet)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wininet)
{
    DLPENTRY(CommitUrlCacheEntryA)
    DLPENTRY(CommitUrlCacheEntryW)
    DLPENTRY(CreateUrlCacheContainerA)
    DLPENTRY(CreateUrlCacheContainerW)
    DLPENTRY(CreateUrlCacheEntryA)
    DLPENTRY(CreateUrlCacheEntryW)
    DLPENTRY(CreateUrlCacheGroup)
    DLPENTRY(DeleteUrlCacheContainerA)
    DLPENTRY(DeleteUrlCacheEntryA)
    DLPENTRY(DeleteUrlCacheEntryW)
    DLPENTRY(DeleteUrlCacheGroup)
    DLPENTRY(FindCloseUrlCache)
    DLPENTRY(FindFirstUrlCacheContainerA)
    DLPENTRY(FindFirstUrlCacheContainerW)
    DLPENTRY(FindFirstUrlCacheEntryA)
    DLPENTRY(FindFirstUrlCacheEntryExA)
    DLPENTRY(FindFirstUrlCacheEntryExW)
    DLPENTRY(FindFirstUrlCacheEntryW)
    DLPENTRY(FindNextUrlCacheContainerA)
    DLPENTRY(FindNextUrlCacheContainerW)
    DLPENTRY(FindNextUrlCacheEntryA)
    DLPENTRY(FindNextUrlCacheEntryExA)
    DLPENTRY(FindNextUrlCacheEntryExW)
    DLPENTRY(FindNextUrlCacheEntryW)
    DLPENTRY(FreeUrlCacheSpaceW)
    DLPENTRY(FtpCommandA)
    DLPENTRY(FtpCreateDirectoryA)
    DLPENTRY(FtpCreateDirectoryW)
    DLPENTRY(FtpDeleteFileA)
    DLPENTRY(FtpDeleteFileW)
    DLPENTRY(FtpFindFirstFileA)
    DLPENTRY(FtpFindFirstFileW)
    DLPENTRY(FtpGetCurrentDirectoryA)
    DLPENTRY(FtpGetCurrentDirectoryW)
    DLPENTRY(FtpGetFileEx)
    DLPENTRY(FtpGetFileSize)
    DLPENTRY(FtpOpenFileA)
    DLPENTRY(FtpOpenFileW)
    DLPENTRY(FtpPutFileEx)
    DLPENTRY(FtpRemoveDirectoryA)
    DLPENTRY(FtpRenameFileA)
    DLPENTRY(FtpSetCurrentDirectoryA)
    DLPENTRY(FtpSetCurrentDirectoryW)
    DLPENTRY(GetUrlCacheConfigInfoA)
    DLPENTRY(GetUrlCacheConfigInfoW)
    DLPENTRY(GetUrlCacheEntryInfoA)
    DLPENTRY(GetUrlCacheEntryInfoExA)
    DLPENTRY(GetUrlCacheEntryInfoExW)
    DLPENTRY(GetUrlCacheEntryInfoW)
    DLPENTRY(HttpAddRequestHeadersA)
    DLPENTRY(HttpAddRequestHeadersW)
    DLPENTRY(HttpEndRequestA)
    DLPENTRY(HttpEndRequestW)
    DLPENTRY(HttpOpenRequestA)
    DLPENTRY(HttpOpenRequestW)
    DLPENTRY(HttpQueryInfoA)
    DLPENTRY(HttpQueryInfoW)
    DLPENTRY(HttpSendRequestA)
    DLPENTRY(HttpSendRequestExA)
    DLPENTRY(HttpSendRequestExW)
    DLPENTRY(HttpSendRequestW)
    DLPENTRY(InternetAttemptConnect)
    DLPENTRY(InternetAutodial)
    DLPENTRY(InternetAutodialCallback)
    DLPENTRY(InternetAutodialHangup)
    DLPENTRY(InternetCanonicalizeUrlA)
    DLPENTRY(InternetCanonicalizeUrlW)
    DLPENTRY(InternetCheckConnectionW)
    DLPENTRY(InternetClearAllPerSiteCookieDecisions)
    DLPENTRY(InternetCloseHandle)
    DLPENTRY(InternetCombineUrlW)
    DLPENTRY(InternetConfirmZoneCrossingW)
    DLPENTRY(InternetConnectA)
    DLPENTRY(InternetConnectW)
    DLPENTRY(InternetCrackUrlA)
    DLPENTRY(InternetCrackUrlW)
    DLPENTRY(InternetCreateUrlA)
    DLPENTRY(InternetCreateUrlW)
    DLPENTRY(InternetEnumPerSiteCookieDecisionA)
    DLPENTRY(InternetEnumPerSiteCookieDecisionW)
    DLPENTRY(InternetErrorDlg)
    DLPENTRY(InternetFindNextFileA)
    DLPENTRY(InternetFindNextFileW)
    DLPENTRY(InternetFortezzaCommand)
    DLPENTRY(InternetGetConnectedState)
    DLPENTRY(InternetGetConnectedStateExA)
    DLPENTRY(InternetGetConnectedStateExW)
    DLPENTRY(InternetGetLastResponseInfoA)
    DLPENTRY(InternetGetLastResponseInfoW)
    DLPENTRY(InternetGetPerSiteCookieDecisionW)
    DLPENTRY(InternetGoOnlineW)
    DLPENTRY(InternetInitializeAutoProxyDll)
    DLPENTRY(InternetLockRequestFile)
    DLPENTRY(InternetOpenA)
    DLPENTRY(InternetOpenUrlA)    
    DLPENTRY(InternetOpenUrlW)
    DLPENTRY(InternetOpenW)
    DLPENTRY(InternetQueryDataAvailable)
    DLPENTRY(InternetQueryFortezzaStatus)
    DLPENTRY(InternetQueryOptionA)
    DLPENTRY(InternetQueryOptionW)
    DLPENTRY(InternetReadFile)
    DLPENTRY(InternetReadFileExA)
    DLPENTRY(InternetSetFilePointer)
    DLPENTRY(InternetSetOptionA)
    DLPENTRY(InternetSetOptionW)
    DLPENTRY(InternetSetPerSiteCookieDecisionW)
    DLPENTRY(InternetSetStatusCallbackA)
    DLPENTRY(InternetSetStatusCallbackW)
    DLPENTRY(InternetShowSecurityInfoByURLW)
    DLPENTRY(InternetTimeFromSystemTimeA)   
    DLPENTRY(InternetTimeFromSystemTimeW)   
    DLPENTRY(InternetTimeToSystemTimeA)   
    DLPENTRY(InternetTimeToSystemTimeW)
    DLPENTRY(InternetUnlockRequestFile)
    DLPENTRY(InternetWriteFile)
    DLPENTRY(IsHostInProxyBypassList)
    DLPENTRY(LoadUrlCacheContent)
    DLPENTRY(PrivacySetZonePreferenceW)
    DLPENTRY(ReadUrlCacheEntryStream)
    DLPENTRY(RegisterUrlCacheNotification)
    DLPENTRY(ResumeSuspendedDownload)
    DLPENTRY(RetrieveUrlCacheEntryFileA)
    DLPENTRY(RetrieveUrlCacheEntryStreamW)
    DLPENTRY(SetUrlCacheConfigInfoA)
    DLPENTRY(SetUrlCacheEntryGroupW)
    DLPENTRY(SetUrlCacheEntryInfoW)
    DLPENTRY(UnlockUrlCacheEntryFileA)
    DLPENTRY(UnlockUrlCacheEntryStream)
};

DEFINE_PROCNAME_MAP(wininet)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\autodiscoveryid.h ===
/**************************************************************************\
    FILE: AutoDiscoveryIDs.h
    DATE: BryanSt (1/19/2000)

    DESCRIPTION:
        AutoDiscovery API (Object Model).

    Copyright 1999-2000 Microsoft Corporation. All Rights Reserved.
\**************************************************************************/

#ifndef _AUTODISCOVERYID_H_

// define the ...
#define DISPID_NXOBJ_MIN                 0x00000000
#define DISPID_NXOBJ_MAX                 0x0000FFFF
#define DISPID_NXOBJ_BASE                DISPID_NXOBJ_MIN


//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These are events that are fired for all sites
//----------------------------------------------------------------------------


// IAccountDiscovery Properties
// IAccountDiscovery Methods
#define DISPIDAD_DISCOVERNOW            (DISPID_NXOBJ_BASE + 51)
#define DISPIDAD_WORKASYNC              (DISPID_NXOBJ_BASE + 52)

// IMailAutoDiscovery Properties
#define DISPIDAD_DISPLAYNAME            (DISPID_NXOBJ_BASE + 100)
#define DISPIDAD_INFOURL                (DISPID_NXOBJ_BASE + 101)
#define DISPIDAD_XML                    (DISPID_NXOBJ_BASE + 102)
#define DISPIDAD_PREFEREDPROTOCOL       (DISPID_NXOBJ_BASE + 103)
#define DISPIDAD_LENGTH                 (DISPID_NXOBJ_BASE + 104)
#define DISPIDAD_ITEM                   (DISPID_NXOBJ_BASE + 105)
// IMailAutoDiscovery Methods
#define DISPIDAD_PURGE                  (DISPID_NXOBJ_BASE + 150)
#define DISPIDAD_DISCOVERMAIL           (DISPID_NXOBJ_BASE + 151)
#define DISPIDMAD_WORKASYNC             (DISPID_NXOBJ_BASE + 152)
#define DISPIDADMP_PRIMARYPROVIDERS     (DISPID_NXOBJ_BASE + 153)
#define DISPIDADMP_SECONDARYPROVIDERS   (DISPID_NXOBJ_BASE + 154)


// IMailProtocolADEntry Properties
#define DISPIDADMP_PROTOCOL             (DISPID_NXOBJ_BASE + 201)
#define DISPIDADMP_SERVERNAME           (DISPID_NXOBJ_BASE + 202)
#define DISPIDADMP_SERVERPORTNUM        (DISPID_NXOBJ_BASE + 203)
#define DISPIDADMP_LOGIN_NAME           (DISPID_NXOBJ_BASE + 204)
#define DISPIDADMP_POST_HTML            (DISPID_NXOBJ_BASE + 205)
#define DISPIDADMP_USE_SSL              (DISPID_NXOBJ_BASE + 206)
#define DISPIDADMP_ISAUTHREQ            (DISPID_NXOBJ_BASE + 207)
#define DISPIDADMP_USESPA               (DISPID_NXOBJ_BASE + 208)
#define DISPIDADMP_SMTPUSESPOP3AUTH     (DISPID_NXOBJ_BASE + 209)
// IMailProtocolADEntry Methods




#define SZ_DISPIDAD_DISCOVERNOW                     helpstring("Set the xml of this message")
#define SZ_DISPIDAD_WORKASYNC                       helpstring("Make DiscoverNow return right way before finished.  The specified message will be sent to the hwnd when it finishes.  The LPARAM will have the IXMLDOMDocument result.")

#define SZ_DISPIDAD_DISPLAYNAME                     helpstring("Get the display name for the account")
#define SZ_DISPIDAD_INFOURL                         helpstring("Get the URL that the server or service may provide that describes how to configure your e-mail or other information about getting email.")
#define SZ_DISPIDAD_GETXML                          helpstring("Get XML")
#define SZ_DISPIDAD_PUTXML                          helpstring("Put XML")
#define SZ_DISPIDAD_PREFEREDPROTOCOL                helpstring("Get the prefered protocol")
#define SZ_DISPIDAD_GETLENGTH                       helpstring("Put the number of supported protocols")
#define SZ_DISPIDAD_GETITEM                         helpstring("Get the protocol by index")
#define SZ_DISPIDAD_DISCOVERMAIL                    helpstring("Get the information for this email address.")
#define SZ_DISPIDAD_PURGE                           helpstring("Delete this from the cache so we hit the net the next time")

#define SZ_DISPIDAD_PROTOCOL                        helpstring("Get the protocol name")
#define SZ_DISPIDAD_SERVERNAME                      helpstring("Get the Server Name (pop.mail.yahoo.com)")
#define SZ_DISPIDAD_SERVERPORTNUM                   helpstring("Get the Server Port Number (default or 123)")
#define SZ_DISPIDAD_LOGIN_NAME                      helpstring("Get the login name for this account")
#define SZ_DISPIDAD_POST_HTML                       helpstring("Get the HTTP Post HTML")
#define SZ_DISPIDAD_USE_SSL                         helpstring("Does the Server support SSL?")
#define SZ_DISPIDAD_ISAUTHREQ                       helpstring("Is Authentication required when logging into the server?")
#define SZ_DISPIDAD_USESPA                          helpstring("Should SPA be used during authentication")
#define SZ_DISPIDAD_SMTPUSESPOP3AUTH                helpstring("If SMTP, does it use the auth settings from POP3?")
#define SZ_DISPIDAD_PRIMARYPROVIDERS                helpstring("What servers will be contacted that will have the full email address uploaded?")
#define SZ_DISPIDAD_SECONDARYPROVIDERS              helpstring("What servers will be contacted that will have the hostname of the email address uploaded?")

#define _AUTODISCOVERYID_H_
#endif // _AUTODISCOVERYID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\capi.h ===
#include <wincrypt.h>
#include <sipbase.h>
#include <mscat.h>
#include <mssip.h>
#include <wintrust.h>

#ifndef _JTRUST_H
#define _JTRUST_H

#if !defined(JAVA_TRUST_PROVIDER)

#ifdef __cplusplus
extern "C" {
#endif


// New guids for Java Policy Provider
// {E6F795B1-F738-11d0-A72F-00A0C903B83D}
#define JAVA_POLICY_PROVIDER_DOWNLOAD \
{ 0xe6f795b1, 0xf738, 0x11d0, {0xa7, 0x2f, 0x0, 0xa0, 0xc9, 0x3, 0xb8, 0x3d } }

// {E6F795B2-F738-11d0-A72F-00A0C903B83D}
#define JAVA_POLICY_PROVIDER_CHECK \
{ 0xe6f795b2, 0xf738, 0x11d0, {0xa7, 0x2f, 0x0, 0xa0, 0xc9, 0x3, 0xb8, 0x3d } }

typedef struct _JAVA_TRUST {
    DWORD       cbSize;                   // Size of structure
    DWORD       flag;                     // Reserved
    BOOL        fAllActiveXPermissions;   // ActiveX explicitly asked for all (must have been signed)
    BOOL        fAllPermissions;          // Java permissions, explicit ask for all
    DWORD       dwEncodingType;           // Encoding type
    PBYTE       pbJavaPermissions;        // Encoded java permission blob
    DWORD       cbJavaPermissions;
    PBYTE       pbSigner;                 // Encoded signer.
    DWORD       cbSigner;
    LPCWSTR     pwszZone;                 // Zone index (copied from action data)
    GUID        guidZone;                 // Not used currently
    HRESULT     hVerify;                  // Authenticode policy return
} JAVA_TRUST, *PJAVA_TRUST;

typedef struct _JAVA_POLICY_PROVIDER {
    DWORD                 cbSize;                   // Size of policy provider
    LPVOID                pZoneManager;             // Zone interface manager
    LPCWSTR               pwszZone;                 // Zone index
    BOOL                  fNoBadUI;                 // Optional bad ui
    PJAVA_TRUST           pbJavaTrust;              // Returned java information (CoTaskMemAlloc)
    DWORD                 cbJavaTrust;              // Total allocated size of pJavaTrust
    DWORD                 dwActionID;               // Optional ActionID ID
    DWORD                 dwUnsignedActionID;       // Optional ActionID ID
    BOOL                  VMBased;                  // Called from VM (FALSE by DEFAULT)
} JAVA_POLICY_PROVIDER, *PJAVA_POLICY_PROVIDER;

#ifdef __cplusplus
}
#endif

#endif // !defined(JAVA_TRUST_PROVIDER)
#endif // _JTRUST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\dload\urlmon.c ===
#include "inetcorepch.h"
#pragma hdrstop

#include <urlmon.h>

#undef STDAPI
#define STDAPI          HRESULT STDAPICALLTYPE
#undef STDAPI_
#define STDAPI_(type)   type    STDAPICALLTYPE

static
STDAPI CoInternetGetSession(DWORD dwSessionMode,
                                    IInternetSession **ppIInternetSession,
                                    DWORD dwReserved)
{
    *ppIInternetSession = NULL;
    return E_OUTOFMEMORY;
}

static
STDAPI RevokeBindStatusCallback(LPBC pBC,
                                        IBindStatusCallback *pBSCb)
{
    return E_FAIL;
}

static
STDAPI CreateURLMoniker(LPMONIKER pMkCtx,
                                LPCWSTR szURL,
                                LPMONIKER FAR * ppmk)
{
    *ppmk = NULL;
    return E_OUTOFMEMORY;
}

static
STDAPI HlinkNavigateString(IUnknown *pUnk,
                                   LPCWSTR szTarget)
{
    return E_FAIL;
}

static
STDAPI RegisterBindStatusCallback(LPBC pBC,
                                          IBindStatusCallback *pBSCb,
                                          IBindStatusCallback** ppBSCBPrev,
                                          DWORD dwReserved)
{
    return E_OUTOFMEMORY;
}

static
HRESULT WINAPI
UrlMkGetSessionOption(DWORD dwOption,
                      LPVOID pBuffer,
                      DWORD dwBufferLength,
                      DWORD *pdwBufferLength,
                      DWORD dwReserved)
{
    return E_FAIL;
}

STDAPI
UrlMkSetSessionOption(DWORD dwOption,
                      LPVOID pBuffer,
                      DWORD dwBufferLength,
                      DWORD dwReserved)
{
    return E_FAIL;
}

static
STDAPI
CoInternetQueryInfo(LPCWSTR     pwzUrl,
                    QUERYOPTION QueryOptions,
                    DWORD       dwQueryFlags,
                    LPVOID      pvBuffer,
                    DWORD       cbBuffer,
                    DWORD      *pcbBuffer,
                    DWORD       dwReserved)
{
    return E_FAIL;
}

static
HRESULT WINAPI
CreateFormatEnumerator(UINT cfmtetc,
                       FORMATETC* rgfmtetc,
                       IEnumFORMATETC** ppenumfmtetc)
{
    return E_FAIL;
}

static
STDAPI
URLDownloadToFileW(LPUNKNOWN           caller,
                   LPCWSTR             szURL,
                   LPCWSTR             szFileName,
                   DWORD               dwReserved,
                   LPBINDSTATUSCALLBACK callback)
{
    return E_OUTOFMEMORY;
}

static
STDAPI
FaultInIEFeature(HWND hWnd,
                 uCLSSPEC *pClassSpec,
                 QUERYCONTEXT *pQuery,
                 DWORD dwFlags)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CoInternetParseUrl(LPCWSTR     pwzUrl,
                   PARSEACTION ParseAction,
                   DWORD       dwFlags,
                   LPWSTR      pszResult,
                   DWORD       cchResult,
                   DWORD      *pcchResult,
                   DWORD       dwReserved)
{
    return E_FAIL;
}

static
STDAPI
GetSoftwareUpdateInfo(LPCWSTR szDistUnit,
                      LPSOFTDISTINFO psdi)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI SetSoftwareUpdateAdvertisementState(LPCWSTR szDistUnit,
                                           DWORD dwAdState,
                                           DWORD dwAdvertisedVersionMS,
                                           DWORD dwAdvertisedVersionLS)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CoInternetCreateSecurityManager(IServiceProvider* pSP,
                                IInternetSecurityManager** ppSM,
                                DWORD dwReserved)
{
    *ppSM = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
GetMarkOfTheWeb(LPCSTR pszURL,
                LPCSTR pszFile,
                DWORD dwFlags,
                LPSTR *ppszMark)
{
    *ppszMark = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
URLOpenBlockingStreamW(LPUNKNOWN caller,
                       LPCWSTR szURL,
                       LPSTREAM* ppStream,
                       DWORD dwReserved,
                       LPBINDSTATUSCALLBACK callback)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI FindMimeFromData(LPBC pBC,
                        LPCWSTR pwzUrl,
                        LPVOID pBuffer,
                        DWORD cbSize,
                        LPCWSTR pwzMimeProposed,
                        DWORD dwMimeFlags,
                        LPWSTR *ppwzMimeOut,
                        DWORD dwReserved)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
URLDownloadToCacheFileW(LPUNKNOWN caller,
                        LPCWSTR szURL,
                        LPWSTR szFileName,
                        DWORD dwBufLength,
                        DWORD dwReserved,
                        LPBINDSTATUSCALLBACK callback)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
ObtainUserAgentString(DWORD dwOption,
                      LPSTR pszUAOut,
                      DWORD *cbSize)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CoInternetGetSecurityUrl(
    LPCWSTR pwszUrl,
    LPWSTR *ppwszSecUrl,
    PSUACTION   psuAction,
    DWORD dwReserved
    )
{
    if (ppwszSecUrl)
    {
        *ppwszSecUrl = NULL;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CreateAsyncBindCtxEx(IBindCtx *pbc,
                     DWORD dwOptions,
                     IBindStatusCallback *pBSCb,
                     IEnumFORMATETC *pEnum,
                     IBindCtx **ppBC,
                     DWORD reserved)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RegisterMediaTypeClass(LPBC pBC,
                       UINT ctypes,
                       const LPCSTR* rgszTypes,
                       CLSID *rgclsID,
                       DWORD reserved)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI_(void)
ReleaseBindInfo(BINDINFO * pbindinfo)
{
}

static
HRESULT WINAPI
RevokeFormatEnumerator(LPBC pBC,
                       IEnumFORMATETC *pEFetc)
{
    return E_FAIL;
}

static
HRESULT WINAPI
RegisterFormatEnumerator(LPBC pBC,
                         IEnumFORMATETC *pEFetc,
                         DWORD reserved)
{
    return E_FAIL;
}

static
HRESULT WINAPI
CoInternetCombineUrl(LPCWSTR pwzBaseUrl,
                     LPCWSTR pwzRelativeUrl,
                     DWORD dwCombineFlags,
                     LPWSTR pszResult,
                     DWORD cchResult,
                     DWORD * pcchResult,
                     DWORD dwReserved)
{
    return E_FAIL;
}

static
HRESULT WINAPI
IsValidURL(LPBC pBC,
           LPCWSTR szURL,
           DWORD dwReserved)
{
    return E_FAIL;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(urlmon)
{
    DLPENTRY(CoInternetCombineUrl)
    DLPENTRY(CoInternetCreateSecurityManager)
    DLPENTRY(CoInternetGetSecurityUrl)
    DLPENTRY(CoInternetGetSession)
    DLPENTRY(CoInternetParseUrl)
    DLPENTRY(CoInternetQueryInfo)
    DLPENTRY(CreateAsyncBindCtxEx)
    DLPENTRY(CreateFormatEnumerator)
    DLPENTRY(CreateURLMoniker)
    DLPENTRY(FaultInIEFeature)
    DLPENTRY(FindMimeFromData)
    DLPENTRY(GetMarkOfTheWeb)
    DLPENTRY(GetSoftwareUpdateInfo)
    DLPENTRY(HlinkNavigateString)
    DLPENTRY(IsValidURL)
    DLPENTRY(ObtainUserAgentString)
    DLPENTRY(RegisterBindStatusCallback)
    DLPENTRY(RegisterFormatEnumerator)
    DLPENTRY(RegisterMediaTypeClass)
    DLPENTRY(ReleaseBindInfo)
    DLPENTRY(RevokeBindStatusCallback)
    DLPENTRY(RevokeFormatEnumerator)
    DLPENTRY(SetSoftwareUpdateAdvertisementState)
    DLPENTRY(URLDownloadToCacheFileW)
    DLPENTRY(URLDownloadToFileW)
    DLPENTRY(URLOpenBlockingStreamW)
    DLPENTRY(UrlMkGetSessionOption)
    DLPENTRY(UrlMkSetSessionOption)
};

DEFINE_PROCNAME_MAP(urlmon)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dtbase.cpp ===
/*******************************************************************************
* DTBase.cpp *
*------------*
*   Description:
*    This module contains the CDXBaseNTo1 transform
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/28/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
//--- Additional includes
#include <DXTrans.h>
#include "DTBase.h"
#include "new.h"

//--- Initialize static member of debug scope class
#ifdef _DEBUG
CDXTDbgFlags CDXTDbgScope::m_DebugFlags;
#endif

//--- This should only be used locally in this file. We duplicated this GUID
//    value to avoid having to include DDraw.
static const IID IID_IDXDupDirectDraw =
    { 0x6C14DB80,0xA733,0x11CE, { 0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 } };

static const IID IID_IDXDupDDrawSurface =
    { 0x6C14DB81,0xA733,0x11CE, { 0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 } };

static const IID IID_IDXDupDirect3DRM =
    {0x2bc49361, 0x8327, 0x11cf, {0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1 } };

static const IID IID_IDXDupDirect3DRM3 =
    {0x4516ec83, 0x8f20, 0x11d0, {0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3 } };

static const IID IID_IDXDupDirect3DRMMeshBuilder3 =
    { 0x4516ec82, 0x8f20, 0x11d0, { 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3} };

HRESULT CDXDataPtr::Assign(BOOL bMesh, IUnknown * pObject, IDXSurfaceFactory *pSurfaceFactory)
{
    HRESULT hr = S_OK;
    if (pObject)
    {
        IUnknown *pNative = NULL;
        if (!bMesh)
        {
            //--- Try to get a DX surface
            hr = pObject->QueryInterface( IID_IDXSurface, (void **)&pNative );
            if( FAILED( hr ) )
            {
                IDirectDrawSurface *pSurf;
                //--- Try to get a DDraw surface
                hr = pObject->QueryInterface( IID_IDXDupDDrawSurface, (void **)&pSurf );
                if( SUCCEEDED( hr ) )
                {
                    //--- Create a DXSurface from the DDraw surface
                    hr = pSurfaceFactory->CreateFromDDSurface(
                                pSurf, NULL, 0, NULL, IID_IDXSurface,
                                (void **)&pNative );
                    pSurf->Release();
                }
            }
        }
        else // Must be a mesh builder
        {
            hr = pObject->QueryInterface(IID_IDXDupDirect3DRMMeshBuilder3, (void **)&pNative);
        }
        if (SUCCEEDED(hr))
        {
            Release();
            m_pNativeInterface = pNative;
            pObject->AddRef();
            m_pUnkOriginalObject = pObject;
            if (SUCCEEDED(pNative->QueryInterface(IID_IDXBaseObject, (void **)&m_pBaseObj)))
            {
                m_pBaseObj->GetGenerationId(&m_dwLastDirtyGenId);
                m_dwLastDirtyGenId--;
            }
            if (!bMesh)
            {   
                ((IDXSurface *)pNative)->GetPixelFormat(NULL, &m_SampleFormat);
            }
        }
        else
        {
            if (hr == E_NOINTERFACE)
            {
                hr = E_INVALIDARG;
            }
        }
    }
    else 
    {
        Release();
    }
    return hr;
} /* CDXDataPtr::Assign */

bool CDXDataPtr::IsDirty(void)
{
    if (m_pBaseObj)
    {
        DWORD dwOldId = m_dwLastDirtyGenId;
        m_pBaseObj->GetGenerationId(&m_dwLastDirtyGenId);
        return dwOldId != m_dwLastDirtyGenId;
    }
    else
    {
        return false;
    }

}

DWORD CDXDataPtr::GenerationId(void)
{
    if (m_pBaseObj)
    {
        DWORD dwGenId;
        m_pBaseObj->GetGenerationId(&dwGenId);
        return dwGenId;
    }
    else
    {
        return 0;
    }
}


bool CDXDataPtr::UpdateGenerationId(void)
{
    if (m_pBaseObj)
    {
        DWORD dwOldId = m_dwLastUpdGenId;
        m_pBaseObj->GetGenerationId(&m_dwLastUpdGenId);
        return dwOldId != m_dwLastUpdGenId;
    }
    else
    {
        return false;
    }
} /* CDXDataPtr::UpdateGenerationId */

ULONG CDXDataPtr::ObjectSize(void)
{
    ULONG ulSize = 0;
    if (m_pBaseObj)
    {
        m_pBaseObj->GetObjectSize(&ulSize);
    }
    return ulSize;    
}

/*****************************************************************************
* CDXBaseNTo1::CDXBaseNTo1 *
*--------------------------*
*   Description:
*       Constructor
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
CDXBaseNTo1::CDXBaseNTo1() :
    m_aInputs(NULL),
    m_ulNumInputs(0),
    m_ulNumProcessors(1),   // Default to one until task manager is set
    m_dwGenerationId(1),
    m_dwCleanGenId(0),
    m_Duration(1.0f),
    m_StepResolution(0.0f),
    m_Progress(0.0f),
    m_dwBltFlags(0),
    m_bPickDoneByBase(false),
    m_bInMultiThreadWorkProc(FALSE),
    m_fQuality(0.5f),   // Default to normal quality.
    //  Wait forever before timing out on a lock by default
    m_ulLockTimeOut(INFINITE),
    //
    //  Override these flags if your object does not support one or more of these options.
    //  Typically, 3-D effects should set this member to 0.
    //
    m_dwMiscFlags(DXTMF_BLEND_WITH_OUTPUT | DXTMF_DITHER_OUTPUT |
                  DXTMF_BLEND_SUPPORTED | DXTMF_DITHER_SUPPORTED | DXTMF_BOUNDS_SUPPORTED | DXTMF_PLACEMENT_SUPPORTED),
    //
    //  If your object has a different number of objects or a different number of
    //  required objects than 1, simply set these members in the body of your
    //  constructor or in FinalConstruct().  For every input that is > the number
    //  required, that input will be reported as optional.
    //
    //  If your transform takes 2 required inputs, set both to 2.
    //  If your transform takes 2 optional inputs, set MaxInputs = 2, NumInRequired = 0
    //  If your transform takes 1 required and 2 optional inputs,
    //      set MaxInputs = 2, NumInRequired = 1
    //
    //  For more complex combinations of optinal/required, you will need to override
    //  the OnSetup method of this base class, and override the methods
    //      GetInOutInfo
    //
    m_ulMaxInputs(1),
    m_ulNumInRequired(1),
    //
    //  If the intputs or output types are not surfaces then set appropriate object type
    //
    m_dwOptionFlags(0),     // Inputs and output are surfaces, don't have to be the same size
    m_ulMaxImageBands(DXB_MAX_IMAGE_BANDS),
    m_fIsSetup(false)
{
    DXTDBG_FUNC( "CDXBaseNTo1::CDXBaseNTo1" );
    //
    //  Set event handles to NULL.
    //
    memset(m_aEvent, 0, sizeof(m_aEvent));
} /* CDXBaseNTo1::CDXBaseNTo1 */

/*****************************************************************************
* CDXBaseNTo1::~CDXBaseNTo1 *
*---------------------------*
*   Description:
*       Constructor
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
CDXBaseNTo1::~CDXBaseNTo1()
{
    DXTDBG_FUNC( "CDXBaseNTo1::~CDXBaseNTo1" );
    _ReleaseReferences();
    delete[] m_aInputs;

    //--- Release event objects
    for(ULONG i = 0; i < DXB_MAX_IMAGE_BANDS; ++i )
    {
        if( m_aEvent[i] ) ::CloseHandle( m_aEvent[i] );
    }
} /* CDXBaseNTo1::~CDXBaseNTo1 */


/*****************************************************************************
* CDXBaseNTo1::_ReleaseRefernces *
*--------------------------------*
*   Description:
*       Releases all references to input and output objects
*-----------------------------------------------------------------------------
*   Created By: RAL
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
void CDXBaseNTo1::_ReleaseReferences()
{
    //--- Release data objects
    if( m_aInputs )
    {
        for( ULONG i = 0; i < m_ulNumInputs; ++i )
        {
            m_aInputs[i].Release();
        }
    }

    m_Output.Release();

    m_fIsSetup = false;
} /* CDXBaseNTo1::_ReleaseRefernces */



STDMETHODIMP CDXBaseNTo1::GetGenerationId(ULONG *pGenerationId)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetGenerationId" );
    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
    {
        return E_POINTER;
    }
    Lock();
    OnUpdateGenerationId();
    *pGenerationId = m_dwGenerationId;
    Unlock();
    return S_OK;
}

STDMETHODIMP CDXBaseNTo1::IncrementGenerationId(BOOL bRefresh)
{
    DXTDBG_FUNC( "CDXBaseNTo1::IncrementGenerationId" );
    HRESULT hr = S_OK;
    Lock();
    m_dwGenerationId++;
    if (bRefresh)
    {
        //
        //  If we have any inputs or outputs, call Setup again to refresh all internal
        //  knowledge about the surfaces (formats, height or width could change, etc.)
        //
        //  Note that we need to AddRef the objects prior to calling Setup becuase the
        //  DXTransform may be the only object holding a referec
        //
        ULONG cInputs = m_ulNumInputs;
        ULONG cOutputs = 0;
        IUnknown *pOutput = m_Output.m_pUnkOriginalObject;
        if (pOutput)
        {
            cOutputs = 1;
            pOutput->AddRef();
        }
        IUnknown ** ppInputs = NULL;
        if (cInputs)
        {
            ppInputs = (IUnknown **)_alloca(m_ulNumInputs * sizeof(IUnknown *));
            for (ULONG i = 0; i < cInputs; i++)
            {
                ppInputs[i] = m_aInputs[i].m_pUnkOriginalObject;
                if (ppInputs[i]) ppInputs[i]->AddRef();
            }
        }
        if (cInputs || cOutputs)    // If we're not setup, skip this step.
        {
            hr = Setup(ppInputs, cInputs, &pOutput, cOutputs, 0);
            if (pOutput) pOutput->Release();
            for (ULONG i = 0; i < cInputs; i++)
            {
                if (ppInputs[i]) ppInputs[i]->Release();
            }
        }
    }
    Unlock();
    return hr;
}


STDMETHODIMP CDXBaseNTo1::GetObjectSize(ULONG *pcbSize)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetObjectSize" );
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pcbSize, sizeof(*pcbSize)))
    {
        hr = E_POINTER;
    }
    else
    {
	Lock();
        *pcbSize = OnGetObjectSize();
        Unlock();
    }
    return hr;
}


void CDXBaseNTo1::_ReleaseServices(void)
{
    m_cpTransFact.Release();
    m_cpSurfFact.Release();
    m_cpTaskMgr.Release();
    m_cpDirectDraw.Release();
    m_cpDirect3DRM.Release();
}

//
//  The documentation for SetSite indicates that it is invaid to return
//  an error from this function, even if the site does not support the
//  functionality we want.  So, even if there is no service provider, or
//  the required services are not available, we will return S_OK.
//
STDMETHODIMP CDXBaseNTo1::SetSite(IUnknown * pUnkSite)
{
    DXTDBG_FUNC( "CDXBaseNTo1::SetSite" );
    HRESULT hr = S_OK;
    Lock();
    m_cpUnkSite = pUnkSite;
    _ReleaseServices();
    if (pUnkSite)
    {
        if (DXIsBadInterfacePtr(pUnkSite))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            HRESULT hr2;
            hr2 = pUnkSite->QueryInterface(IID_IDXTransformFactory, (void **)&m_cpTransFact);
	    if (SUCCEEDED(hr2))
	    {
                //
                //  Allocate memory for inputs if necessary
                //
                if (m_aInputs == NULL && m_ulMaxInputs)
                {
                    m_aInputs  = new CDXDataPtr[m_ulMaxInputs];
                    if (!m_aInputs)
                    {
                        _ASSERT(TRUE);
                        hr2 = E_OUTOFMEMORY;
                    }
                }
                hr2 = m_cpTransFact->QueryService( SID_SDXSurfaceFactory, IID_IDXSurfaceFactory, (void **)&m_cpSurfFact);
                if (SUCCEEDED(hr2))
                {
                    hr2 = m_cpTransFact->QueryService( SID_SDXTaskManager, IID_IDXTaskManager, (void **)&m_cpTaskMgr);
                }
                if (SUCCEEDED(hr2))
                {
                    m_cpTaskMgr->QueryNumProcessors(&m_ulNumProcessors);
                    if (m_ulMaxImageBands && (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)) == 0)
                    {
                        for (ULONG i = 0; SUCCEEDED(hr2) && i < m_ulMaxImageBands; i++)
                        {
                            //
                            // In theory we could get back here after failing to create an event, or
                            // by getting a new site, so make sure it's non-null before creating one.
                            //
                            if (m_aEvent[i] == NULL)
                            {
                                m_aEvent[i] = ::CreateEvent(NULL, true, false, NULL);
                                if (m_aEvent[i] == NULL)
                                {
                                    hr2 = E_OUTOFMEMORY;
                                }
                            }

                        }
                    }
                }
                if (SUCCEEDED(hr2))
                {
                    hr2 = m_cpTransFact->QueryService(SID_SDirectDraw, IID_IDXDupDirectDraw, (void**)&m_cpDirectDraw);
                }
                if (SUCCEEDED(hr2) && 
                    (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)))
                {
                    hr2 = m_cpTransFact->QueryService(SID_SDirect3DRM, IID_IDXDupDirect3DRM3, (void **)&m_cpDirect3DRM);
                }
                if (FAILED(hr2))
                {
                    _ASSERT(TRUE);
                    _ReleaseServices();
                }
            }
        }
    }
    Unlock();
    return hr;
}


STDMETHODIMP CDXBaseNTo1::GetSite(REFIID riid, void **ppv)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetSite" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(ppv, sizeof(*ppv)) )
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        if (m_cpUnkSite)
        {
            hr = m_cpUnkSite->QueryInterface(riid, ppv);
        }
        else
        {
            *ppv = NULL;
            hr = E_FAIL;    // This is the proper documented return code
                            // for this interface if no service provider.
        }
        Unlock();
    }
    return hr;
} 


void CDXBaseNTo1::_UpdateBltFlags(void)
{
    m_dwBltFlags = 0;
    if ((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0)
    {
        if (m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT) 
        {
            if ((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) || m_ulNumInputs == 0)
            {
                m_dwBltFlags |= DXBOF_DO_OVER;
            }
            else
            {
                for(ULONG i = 0; i < m_ulNumInputs; ++i )
                {
                    if (InputSampleFormat(i) & DXPF_TRANSPARENCY)
                    {
                        m_dwBltFlags |= DXBOF_DO_OVER;
                        break;
                    }
                }
            }
        }
        //
        //  Set the dither flag to true only if output error is > at least one input
        //
        if (m_dwMiscFlags & DXTMF_DITHER_OUTPUT)
        {
            ULONG OutputErr = (OutputSampleFormat() & DXPF_ERRORMASK);
            if (OutputErr)
            {
                if (m_ulNumInputs)
                {
                    for(ULONG i = 0; i < m_ulNumInputs; ++i )
                    {
                        if (InputSurface(i) && (ULONG)(InputSampleFormat(i) & DXPF_ERRORMASK) < OutputErr)
                        {
                            m_dwBltFlags |= DXBOF_DITHER;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    // If output has no error then don't set dither in blt flags
                    //  
                    if (OutputErr)
                    {
                        m_dwBltFlags |= DXBOF_DITHER; 
                    }
                }
            }
        }
    }
}



/*****************************************************************************
* CDXBaseNTo1::Setup *
*--------------------*
*   Description:
*       The Setup method is used to perform any required one-time setup
*   before the Execute method is called. Single surfaces or SurfaceSets may
*   be used as arguments in any combination. 
*   If punkOutputs is NULL, Execute will allocate an output result of the
*   appropriate size and return it.
*   if punkInputs and punkOutputs are NULL and it is a quick setup, the current
*   input and output objects are released.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::Setup( IUnknown * const * punkInputs, ULONG ulNumInputs,
                                 IUnknown * const * punkOutputs, ULONG ulNumOutputs, DWORD dwFlags )
{
    DXTDBG_FUNC( "CDXBaseNTo1::Setup" );
    //--- Lock object so state cannot change during setup
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;
    ULONG i;

    //
    //  Early out for null setup.  Forget about all other param validation, just do it.
    //  
    if (ulNumInputs == 0 && ulNumOutputs == 0)
    {
        _ReleaseReferences();
        OnReleaseObjects();
        return hr;
    }

    //--- Validate Params
    //--- Make sure we have a reference to the transform factory
    if( !m_cpTransFact )
    {
        hr = DXTERR_UNINITIALIZED;
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform has not been initialized" );
    }
    else
    {
        //
        //  We know that if we have a transform factory that we must also have
        //  allocated m_aInputs since this is done on SetSite to avoid work during
        //  each setup.
        //
        _ASSERT(m_aInputs || m_ulMaxInputs == 0);
        if( dwFlags ||              // No flags are valid
            ulNumOutputs != 1 ||
            ulNumInputs < m_ulNumInRequired ||
            ulNumInputs > m_ulMaxInputs ||
            (ulNumInputs && DXIsBadReadPtr( punkInputs , sizeof( *punkInputs ) * ulNumInputs )) ||
            DXIsBadReadPtr(punkOutputs, sizeof(*punkOutputs)) ||
            DXIsBadInterfacePtr(punkOutputs[0]))
        {
            hr = E_INVALIDARG;
            DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
        }
        else
        {
            for( i = 0; i < ulNumInputs; ++i )
            {
                if((punkInputs[i] && DXIsBadInterfacePtr(punkInputs[i])) ||
                    (punkInputs[i] == NULL && i < m_ulNumInRequired))
                {
                    hr = E_INVALIDARG;
                    DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
                    break;
                }
            }        
        }
    }

    //--- Allocate slots for input data object pointers
    if( SUCCEEDED( hr ) )
    {
        //--- Release data objects
        _ReleaseReferences();
        m_ulNumInputs = ulNumInputs;
    }

    //
    //  Assign 
    //
    for( i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
    {
        hr = m_aInputs[i].Assign((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER), punkInputs[i], m_cpSurfFact);
    }

    if( SUCCEEDED(hr) )
    {
        hr = m_Output.Assign((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER), punkOutputs[0], m_cpSurfFact);
    }   

    if (SUCCEEDED(hr) && (m_dwOptionFlags & DXBOF_SAME_SIZE_INPUTS))
    {
        hr = _MakeInputsSameSize();
    }

    if (SUCCEEDED(hr))
    {
        _UpdateBltFlags();      // Do this before calling OnSetup...
        hr = OnSetup(dwFlags);
    }
    
    if (FAILED(hr))
    {
        _ReleaseReferences();
        OnReleaseObjects();
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup failed" );
    }
    else
    {
        m_fIsSetup = true;
    }

    return hr;
} /* CDXBaseNTo1::Setup */


/*****************************************************************************
* CDXBaseNTo1::_MakeInputsSameSize *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 03/31/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/

HRESULT CDXBaseNTo1::_MakeInputsSameSize(void)
{
    _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);

    HRESULT hr = S_OK;
    if (m_ulNumInputs > 1)      // No need to do this for just one input!
    {
        CDXDBnds SurfBnds(false);
        CDXDBnds Union(true);
        ULONG i;
        for (i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; i++)
        {
            if (InputSurface(i))
            {
                hr = SurfBnds.SetToSurfaceBounds(InputSurface(i));
                Union |= SurfBnds;
            }
        }
        for (i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; i++)
        {
            if (InputSurface(i))
            {
                hr = SurfBnds.SetToSurfaceBounds(InputSurface(i));
                if (SUCCEEDED(hr) && SurfBnds != Union)
                {
                    IDXSurfaceModifier *pSurfMod;
                    hr = ::CoCreateInstance(CLSID_DXSurfaceModifier, NULL, CLSCTX_INPROC,
                                            IID_IDXSurfaceModifier, (void **)&pSurfMod);
                    if (SUCCEEDED(hr))
                    {
                        POINT p;
                        p.x = p.y = 0;
                        if (m_dwOptionFlags & DXBOF_CENTER_INPUTS)
                        {
                            p.x = (Union.Width() - SurfBnds.Width()) / 2;
                            p.y = (Union.Height() - SurfBnds.Height()) / 2;
                        }
                        pSurfMod->SetForeground(InputSurface(i), FALSE, &p);
                        pSurfMod->SetBounds(&Union);
                        InputSurface(i)->Release();
                        pSurfMod->QueryInterface(IID_IDXSurface, (void **)&(m_aInputs[i].m_pNativeInterface));
                        ((IDXSurface *)m_aInputs[i].m_pNativeInterface)->GetPixelFormat(NULL, &m_aInputs[i].m_SampleFormat);
                        pSurfMod->Release();
                    }
                }
            }
        }
    }
    return hr;
}


/*****************************************************************************
* CDXBaseNTo1::Execute *
*----------------------*
*   Description:
*       The Execute method is used to walk the inputs/outputs and break up the
*   work into suitably sized pieces to spread symetrically accross the available
*   processors in the system.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::
    Execute( const GUID* pRequestID, const DXBNDS *pClipBnds, const DXVEC *pPlacement )
{
    DXTDBG_FUNC( "CDXBaseNTo1::Execute" );
    //--- Lock object so state cannot change during execution
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;

    //--- Check args
    if( !HaveOutput() )
    {
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform has not been initialized" );
        return DXTERR_UNINITIALIZED;
    }

    if (m_ulMaxImageBands == 0 ||
        (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)))
    {
        if ((pClipBnds && (m_dwMiscFlags & DXTMF_BOUNDS_SUPPORTED) == 0) ||
            (pPlacement && (m_dwMiscFlags & DXTMF_PLACEMENT_SUPPORTED) == 0) )
        {
            DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
            return E_INVALIDARG;
        }
        return OnExecute( pRequestID, pClipBnds, pPlacement );
    }

    //--- Banded image working variables
    CDXTWorkInfoNTo1 WI;

    if ((pClipBnds && pClipBnds->eType != DXBT_DISCRETE) ||
        (pPlacement && pPlacement->eType != DXBT_DISCRETE))
    {
        hr = E_INVALIDARG;
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
    }
    else
    {
        hr = MapBoundsIn2Out( NULL, 0, 0, &WI.DoBnds );
        if( hr == S_OK )
        {
            hr = WI.OutputBnds.SetToSurfaceBounds(OutputSurface());
            if (hr == S_OK)
            {
                hr = DXClipToOutputWithPlacement(WI.DoBnds, (CDXDBnds *)pClipBnds, WI.OutputBnds, (CDXDVec *)pPlacement);
            }
        }
    }

    //--- Check for clipping early exit
    if( hr != S_OK )
    {
        return hr;
    }

    //=== Process ====================================================
    _ASSERT(m_ulMaxImageBands <= DXB_MAX_IMAGE_BANDS);
    ULONG ulNumBandsToDo = m_ulNumProcessors;
    if( ulNumBandsToDo > 1 )
    {
        ulNumBandsToDo = 1 + ((WI.OutputBnds.Width() * WI.OutputBnds.Height()) / 0x1000);
        if (ulNumBandsToDo > m_ulMaxImageBands)
        {
            ulNumBandsToDo = m_ulMaxImageBands;
        }
        if (ulNumBandsToDo > m_ulNumProcessors)
        {
            ulNumBandsToDo = m_ulNumProcessors;
        }
    }
    hr = OnInitInstData(WI, ulNumBandsToDo);
    if( SUCCEEDED( hr ) )
    {
        if (ulNumBandsToDo == 1 && pRequestID == NULL)
        {
            static BOOL bContinue = TRUE;
            hr = WorkProc(WI, &bContinue);
        }
        else
        {
            _ASSERT( ulNumBandsToDo <= DXB_MAX_IMAGE_BANDS );
            _ASSERT( m_aEvent[ulNumBandsToDo-1] );

            long lStartAtRow = WI.DoBnds[DXB_Y].Min;
            ULONG ulRowCount = WI.DoBnds[DXB_Y].Max - lStartAtRow;
            _ASSERT( ( ulRowCount / ulNumBandsToDo ) != 0 );

            //--- Init the work info structures
            ULONG ulBand, RowsPerBand = ulRowCount / ulNumBandsToDo;
            CDXTWorkInfoNTo1 *WIArray = (CDXTWorkInfoNTo1*)alloca( sizeof(CDXTWorkInfoNTo1) *
                                                         ulNumBandsToDo );
            DWORD *TaskIDs = (DWORD*)alloca( sizeof(DWORD) * ulNumBandsToDo );
            DXTMTASKINFO* TaskInfo = (DXTMTASKINFO*)alloca( sizeof( DXTMTASKINFO ) *
                                                            ulNumBandsToDo );

            //--- Build task info list
            WI.hr       = S_OK;
            WI.pvThis   =  this;
            long Start  = lStartAtRow;
            ULONG Count = RowsPerBand;
            long OutputYDelta = WI.OutputBnds[DXB_Y].Min - WI.DoBnds[DXB_Y].Min;

            for (ulBand = 0; ulBand < ulNumBandsToDo; ++ulBand)
            {
                memcpy(&WIArray[ulBand], &WI, sizeof(WI));

                WIArray[ulBand].DoBnds[DXB_Y].Min       = Start;
                WIArray[ulBand].OutputBnds[DXB_Y].Min   = Start + OutputYDelta;

                // If this is the last band, make sure it includes the last row.

                if (ulBand == ulNumBandsToDo - 1)
                {
                    WIArray[ulBand].DoBnds[DXB_Y].Max       = WI.DoBnds[DXB_Y].Max;
                    WIArray[ulBand].OutputBnds[DXB_Y].Max   = WI.OutputBnds[DXB_Y].Max;
                }
                else // Not the last band.
                {
                    WIArray[ulBand].DoBnds[DXB_Y].Max       = Start + Count;
                    WIArray[ulBand].OutputBnds[DXB_Y].Max   = Start + Count 
                                                              + OutputYDelta;
                }

                TaskInfo[ulBand].pfnTaskProc      = _TaskProc;
                TaskInfo[ulBand].pTaskData        = &WIArray[ulBand];
                TaskInfo[ulBand].pfnCompletionAPC = NULL;
                TaskInfo[ulBand].dwCompletionData = 0;
                TaskInfo[ulBand].pRequestID       = pRequestID;

                // Advance.

                Start += Count;
            }

            //
            //  Procedural surfaces (and perhaps some transforms) need to "know" that
            //  they are in a multi-threaded work procedure to avoid deadlocks.  Procedural
            //  surfaces need to allow LockSurface to work WITHOUT taking the object
            //  critical section.  Other transforms may also want to know this information
            //  to avoid deadlocks.
            //
            m_bInMultiThreadWorkProc = TRUE;

            //--- Schedule the work and wait for it to complete
            hr = m_cpTaskMgr->ScheduleTasks( TaskInfo, m_aEvent,
                                             TaskIDs, ulNumBandsToDo, m_ulLockTimeOut );

            m_bInMultiThreadWorkProc = FALSE;

            //--- Check return codes from work info structures
            //    return the first bad hr if any
            for( ulBand = 0; SUCCEEDED( hr ) && ( ulBand < ulNumBandsToDo ); ++ulBand )
            {
                hr = WIArray[ulBand].hr;
                if( hr != S_OK ) break;
            }
        }
        OnFreeInstData( WI );
    }

#ifdef _DEBUG
    if( FAILED( hr ) ) DXTDBG_MSG1( _CRT_ERROR, "\nExecute failed. HR = %X", hr );
#endif

    return hr;
} /* CDXBaseNTo1::Execute */

/*****************************************************************************
* CDXBaseNTo1::_ImageMapIn2Out *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 07/28/97
*****************************************************************************/
HRESULT CDXBaseNTo1::_ImageMapIn2Out( CDXDBnds & bnds, ULONG ulNumInBnds,
                                      const CDXDBnds * pInBounds )
{
    HRESULT hr = S_OK;
    if(ulNumInBnds)
    {
        for(ULONG i = 0; i < ulNumInBnds; ++i )
        {
            bnds |= pInBounds[i];
        }
    }
    else
    {
        for( ULONG i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
        {
            if (InputSurface(i))
            {
                CDXDBnds SurfBnds(InputSurface(i), hr);
                bnds |= SurfBnds;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = DetermineBnds(bnds);
    }
    return hr;
} /* CDXBaseNTo1::_ImageMapIn2Out */

/*****************************************************************************
* CDXBaseNTo1::_MeshMapIn2Out *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 07/28/97
*****************************************************************************/
HRESULT CDXBaseNTo1::_MeshMapIn2Out(CDXCBnds & bnds, ULONG ulNumInBnds, CDXCBnds * pInBounds)
{
    HRESULT hr = S_OK;
    if (m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER)
    {
        if(ulNumInBnds)
        {
            for(ULONG i = 0; i < ulNumInBnds; ++i )
            {
                bnds |= pInBounds[i];
            }
        }
        else
        {
            for(ULONG i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
            {
                if (InputMeshBuilder(i))
                {
                    CDXCBnds MeshBnds(InputMeshBuilder(i), hr);
                    bnds |= MeshBnds;
                }
            }

        }
    }
    else
    {
        //  Already done -> bnds[DXB_T].Min = 0.0f;
        bnds[DXB_X].Min = bnds[DXB_Y].Min = bnds[DXB_Z].Min = -1.0f;
        bnds[DXB_X].Max = bnds[DXB_Y].Max = bnds[DXB_Z].Max = bnds[DXB_T].Max = 1.0f;
    }

    //
    //  Call the derived class to get the scale values.
    //
    if (SUCCEEDED(hr))
    {
	// Increase the size just a bit so we won't have rounding errors
	// result in bounds that don't actually contain the result.
	const float fBndsIncrease = 0.0001F;
	float fTemp = bnds.Width() * fBndsIncrease;

	bnds[DXB_X].Min -= fTemp;
	bnds[DXB_X].Max += fTemp;

	fTemp = fBndsIncrease * bnds.Height();
	bnds[DXB_Y].Min -= fTemp;
	bnds[DXB_Y].Max += fTemp;

	fTemp = fBndsIncrease * bnds.Depth();
	bnds[DXB_Z].Min -= fTemp;
	bnds[DXB_Z].Max += fTemp;

        hr = DetermineBnds(bnds);
    }
    return hr;
} /* CDXBaseNTo1::_MeshMapIn2Out */

/*****************************************************************************
* CDXBaseNTo1::MapBoundsIn2Out *
*------------------------------*
*   Description:
*       The MapBoundsIn2Out method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::MapBoundsIn2Out( const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                           ULONG ulOutIndex, DXBNDS *pOutBounds )
{
    DXTDBG_FUNC( "CDXBaseNTo1::MapBoundsIn2Out" );
    if((ulNumInBnds && DXIsBadReadPtr( pInBounds, ulNumInBnds * sizeof( *pInBounds ) )) ||
        ulOutIndex)
    {
        return E_INVALIDARG;
    }

    if( DXIsBadWritePtr( pOutBounds, sizeof( *pOutBounds ) ) )
    {
        return E_POINTER;
    }
    //
    //  Set the bounds to empty and the appropriate type.
    //
    memset(pOutBounds, 0, sizeof(*pOutBounds));
    _ASSERT(DXBT_DISCRETE == 0);
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        pOutBounds->eType = DXBT_CONTINUOUS;
    }

    //
    //  Make sure all input bounds are of the correct type.
    //
    if( ulNumInBnds )
    {
        DXBNDTYPE eType = (m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) ? DXBT_CONTINUOUS : DXBT_DISCRETE;
        for (ULONG i = 0; i < ulNumInBnds; i++)
        {
            if (pInBounds[i].eType != eType)
            {
                return E_INVALIDARG;
            }
        }
    }

    //
    //  Now do the appropriate mapping
    //
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        //
        //  NOTE:  In the case of non-mesh inputs, the inputs are discrete, but they will
        //         be completely ignored by the function so it's OK to cast them to CDXCBnds
        //
        return _MeshMapIn2Out(*((CDXCBnds *)pOutBounds), ulNumInBnds, (CDXCBnds *)pInBounds);
    }
    else 
    {
        return _ImageMapIn2Out(*(CDXDBnds *)pOutBounds, ulNumInBnds, (CDXDBnds *)pInBounds);
    }
} /* CDXBaseNTo1::MapBoundsIn2Out */

/*****************************************************************************
* CDXBaseNTo1::MapBoundsOut2In *
*------------------------------*
*   Description:
*       The MapBoundsOut2In method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::
    MapBoundsOut2In( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds )
{
    DXTDBG_FUNC( "CDXBaseNTo1::MapBoundsOut2In" );
    HRESULT hr = S_OK;
    
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        hr = E_NOTIMPL;     // This is pointless for meshes.
    }
    else if(ulInIndex >= m_ulMaxInputs || ulOutIndex || DXIsBadReadPtr( pOutBounds, sizeof( *pOutBounds ) ) )
    {
        hr = E_INVALIDARG;
    }
    else if( DXIsBadWritePtr( pInBounds, sizeof( *pInBounds ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pInBounds = *pOutBounds;
    }
    return hr;
} /* CDXBaseNTo1::MapBoundsOut2In */

/*****************************************************************************
* CDXBaseNTo1::SetMiscFlags *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30.97
*-----------------------------------------------------------------------------
*   Parameters:
*       bMiscFlags - New value to set 
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::SetMiscFlags( DWORD dwMiscFlags )
{ 
    DXTDBG_FUNC( "CDXBaseNTo1::SetMiscFlags" );
    HRESULT hr = S_OK;
    Lock();
    WORD wOpts = (WORD)dwMiscFlags;     // Ignore high word.  Only set low word.
    if (((WORD)m_dwMiscFlags) != wOpts)
    {
        if ((wOpts & (~DXTMF_VALID_OPTIONS)) ||
            ((wOpts & DXTMF_BLEND_WITH_OUTPUT) && (m_dwMiscFlags & DXTMF_BLEND_SUPPORTED) == 0) ||
            ((wOpts & DXTMF_DITHER_OUTPUT) && (m_dwMiscFlags & DXTMF_DITHER_SUPPORTED) == 0))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            m_dwMiscFlags &= 0xFFFF0000;
            m_dwMiscFlags |= wOpts;
            _UpdateBltFlags();
            m_dwGenerationId++;
        }
    }
    Unlock();  
    return hr;
} /* CDXBaseNTo1::SetMiscFlags */

/*****************************************************************************
* CDXBaseNTo1::GetMiscFlags *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::GetMiscFlags( DWORD* pdwMiscFlags )
{
    if( DXIsBadWritePtr( pdwMiscFlags, sizeof( *pdwMiscFlags ) ) )
    {
        return E_POINTER;
    }
    *pdwMiscFlags = m_dwMiscFlags;
    return S_OK;
} /* CDXBaseNTo1::GetMiscFlags */


/*****************************************************************************
* CDXBaseNTo1::SetQuality *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::SetQuality(float fQuality)
{
    if ((m_dwMiscFlags & DXTMF_QUALITY_SUPPORTED) == 0)
    {
        return E_NOTIMPL;
    }

    if (fQuality < 0.0f || fQuality > 1.0f)
    {
        return E_INVALIDARG;
    }

    Lock();
    if (m_fQuality != fQuality)
    {
        m_fQuality = fQuality;
        m_dwGenerationId++;
    }
    Unlock();

    return S_OK;
}

/*****************************************************************************
* CDXBaseNTo1::GetQuality *
*-------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/

STDMETHODIMP CDXBaseNTo1::GetQuality(float *pfQuality)
{
    HRESULT hr = S_OK;

    if ((m_dwMiscFlags & DXTMF_QUALITY_SUPPORTED) == 0)
    {
        hr = E_NOTIMPL;
    }
    else 
    {
        if( DXIsBadWritePtr( pfQuality, sizeof( *pfQuality ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            *pfQuality = m_fQuality;
        }
    }
    return hr;
}



/*****************************************************************************
* GetInOutInfo
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::GetInOutInfo( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags,
                                        GUID * pIDs, ULONG *pcIDs, IUnknown **ppUnkCurObj )
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetInOutInfo" );
    HRESULT hr = S_FALSE;
    DWORD dwFlags = 0;
    BOOL bImage;
    if( bOutput )
    {
        bImage = !(m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER);
        if (ulIndex == 0)
        {
            hr = S_OK;
        }
    }
    else
    {
        bImage = !(m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER);
        if (ulIndex < m_ulMaxInputs)
        {
            hr = S_OK;
            if (ulIndex >= m_ulNumInRequired)
            {
                dwFlags = DXINOUTF_OPTIONAL;
            }
        }
    }
    if( hr == S_OK )
    {
        if( pdwFlags && !DXIsBadWritePtr( pdwFlags, sizeof( *pdwFlags ) ) )
        {
            *pdwFlags = dwFlags;
        }

        if( pIDs )
        {
            if( DXIsBadWritePtr( pcIDs, sizeof( *pcIDs ) ) ||
                DXIsBadWritePtr( pIDs, *pcIDs * sizeof( *pIDs ) ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if (bImage)
                {
                    if (*pcIDs > 0)
                    {
                        pIDs[0] = IID_IDXSurface;
                    }
                    if (*pcIDs > 1)
                    {
                        pIDs[1] = IID_IDXDupDDrawSurface;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
                    }
                    *pcIDs = 2;
                }
                else
                {
                    if (*pcIDs > 0)
                    {
                        pIDs[0] = IID_IDXDupDirect3DRMMeshBuilder3;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
                    }
                    *pcIDs = 1;
                }
            }
        }
        else if( pcIDs )
        {
            if( DXIsBadWritePtr( pcIDs, sizeof( *pcIDs ) ) )
            {
                hr = E_POINTER;
            }
            else
            {
                *pcIDs = bImage ? 2 : 1;
            }
        }
        if (hr == S_OK && ppUnkCurObj)
        {
            if (DXIsBadWritePtr(ppUnkCurObj, sizeof(*ppUnkCurObj)))
            {
                hr = E_POINTER;
            }
            else
            {
                if (bOutput)
                {
                    *ppUnkCurObj = m_Output.m_pNativeInterface;
                }
                else
                {
                    *ppUnkCurObj = NULL;
                    if (ulIndex < GetNumInputs())
                    {
                        *ppUnkCurObj = m_aInputs[ulIndex].m_pUnkOriginalObject;
                    }
                }
                if (*ppUnkCurObj)
                {
                    (*ppUnkCurObj)->AddRef();
                }
            }
        }
    }
    return hr;
} /* CDXBaseNTo1::GetInOutInfo */

/*****************************************************************************
* CDXBaseNTo1::OnUpdateGenerationId *
*-----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
void CDXBaseNTo1::OnUpdateGenerationId(void)
{
    DXTDBG_FUNC( "CDXBaseNTo1::OnUpdateGenerationId" );
    if( (m_dwMiscFlags & DXTMF_INPLACE_OPERATION) &&
        m_Output.UpdateGenerationId())
    {
        m_dwGenerationId++;
    }
    for (ULONG i = 0; i < m_ulNumInputs; i++)
    {
        if (m_aInputs[i].UpdateGenerationId())
        {
            m_dwGenerationId++;
        }
    }
} /* CDXBaseNTo1::OnUpdateGenerationId */

/*****************************************************************************
* CDXBaseNTo1::OnGetObjectSize *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
ULONG CDXBaseNTo1::OnGetObjectSize(void)
{
    return sizeof(*this);
}

//
//  Effect interface
//

/*****************************************************************************
* CDXBaseNTo1::get_Progress *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_Progress(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_Progress" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_Progress;
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::put_Progress *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::put_Progress(float newVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::put_Progress" );
    HRESULT hr = S_OK;
    if (newVal < 0.0 || newVal > 1.0f)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        Lock();
        m_Progress = newVal;
        m_dwCleanGenId++;       // This should not make the transform "dirty" internally
        m_dwGenerationId++;     
        Unlock();
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::get_StepResolution *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_StepResolution(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_StepResolution" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_StepResolution;
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::get_Duration *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_Duration(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_Duration" );
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        return E_POINTER;
    }
    else
    {
        *pVal = m_Duration;
    }
    return S_OK;
}

/*****************************************************************************
* CDXBaseNTo1::put_Duration *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::put_Duration(float newVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::put_Duration" );
    if (newVal <= 0.)
    {
        return E_INVALIDARG;
    }
    if(newVal != m_Duration)
    {
	Lock();
	m_dwGenerationId++;
        m_dwCleanGenId++;       // This should not make the transform "dirty" internally
        m_Duration = newVal;
    	Unlock();
    }
    return S_OK;
}


/*****************************************************************************
* CDXBaseNTo1::PointPick *
*------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 5/5/98
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::PointPick(const DXVEC *pPoint,
                                    ULONG * pulInputSurfaceIndex,
                                    DXVEC *pInputPoint)
{
    HRESULT hr          = S_OK;
    BOOL    bFoundIt    = FALSE;

    // If we haven't been set up yet, we will just act as if we're transparent.

    if (!m_fIsSetup)
    {
        hr = S_FALSE;

        goto done;
    }

    if (DXIsBadReadPtr(pPoint, sizeof(*pPoint)) || pPoint->eType != DXBT_DISCRETE)
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        if (DXIsBadWritePtr(pulInputSurfaceIndex, sizeof(*pulInputSurfaceIndex)) ||
            DXIsBadWritePtr(pInputPoint, sizeof(*pInputPoint)))
        {
            hr = E_POINTER;
        }
        else 
        {
            HRESULT     hr2         = S_OK;
            CDXDBnds    bndsOutput;
            CDXDBnds    OutBndsPoint(*((CDXDVec *)pPoint));
            CDXDVec &   InVec       = *(new(pInputPoint) CDXDVec(*((CDXDVec *)pPoint)));

            // Get the output size of the DXTransform.  If this point is not on
            // the output at all, we can return S_FALSE right now.

            hr = MapBoundsIn2Out(NULL, 0, 0, &bndsOutput);

            if (FAILED(hr))
            {
                goto done;
            }

            if (!bndsOutput.TestIntersect(OutBndsPoint))
            {
                hr = S_FALSE;

                goto done;
            }

            hr2 = OnSurfacePick(OutBndsPoint, *pulInputSurfaceIndex, InVec);

            if (hr2 != E_NOTIMPL)
            {
                hr = hr2;
            }
            else
            {
                //--- The derived class does not implement so we will do
                //    the hit test against the input for them.
                ULONG * aulInIndex = (ULONG *)_alloca(sizeof(ULONG) * m_ulMaxInputs);
                BYTE * aWeights = (BYTE *)_alloca(sizeof(BYTE) * m_ulMaxInputs);
                ULONG ulNumToTest;
                OnGetSurfacePickOrder(OutBndsPoint, ulNumToTest, aulInIndex, aWeights);

                if( m_bPickDoneByBase && ( m_ulNumInputs > 1 ) )
                {
                    //--- We don't know how to do multi-input picking from the base.
                    hr = E_NOTIMPL;
                }

                for (ULONG i = 0; SUCCEEDED(hr) && i < ulNumToTest; i++)
                {
                    ULONG ulInput = aulInIndex[i];
                    if (HaveInput(ulInput) && aWeights[i])
                    {
                        CDXDBnds Out2InBnds(false);
                        hr = MapBoundsOut2In(0, &OutBndsPoint, ulInput, &Out2InBnds);
                        if (SUCCEEDED(hr))
                        {
                            CDXDBnds InSurfBnds(InputSurface(ulInput), hr);
                            if (SUCCEEDED(hr) && InSurfBnds.IntersectBounds(Out2InBnds))
                            {
                                IDXARGBReadPtr * pPtr;
                                hr = InputSurface(ulInput)->LockSurface(&InSurfBnds, m_ulLockTimeOut, DXLOCKF_READ, 
                                                                        IID_IDXARGBReadPtr, (void **)&pPtr, NULL);
                                if( SUCCEEDED(hr) )
                                {
                                    DXPMSAMPLE val;
                                    pPtr->UnpackPremult(&val, 1, FALSE);
                                    pPtr->Release();
                                    if (val.Alpha * aWeights[i] / 255)
                                    {
                                        InSurfBnds.GetMinVector(InVec);
                                        bFoundIt = TRUE;
                                        *pulInputSurfaceIndex = ulInput;
                                        break;
                                    }
                                }
                            }   
                        }
                    }
                }
                if (SUCCEEDED(hr) & (!bFoundIt))
                {
                    hr = S_FALSE;
                }
            }
        }
    }

done:

    return hr;
} /* CDXBaseNTo1::PointPick */

/*****************************************************************************
* RegisterTansform (STATIC member function)
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXBaseNTo1::
RegisterTransform(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                  ULONG cCatReq, const CATID * pCatReq, BOOL bRegister)
{
    DXTDBG_FUNC( "CDXBaseNTo1::RegisterTransform" );
    HRESULT hr = bRegister ? _Module.UpdateRegistryFromResource(ResourceId, bRegister) : S_OK;
    if (SUCCEEDED(hr))
    {
        CComPtr<ICatRegister> pCatRegister;
        HRESULT hr = ::CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC, IID_ICatRegister, (void **)&pCatRegister);
        if (SUCCEEDED(hr))
        {
            if (bRegister)
            {
                hr = pCatRegister->RegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (SUCCEEDED(hr) && cCatReq && pCatReq) {
                    hr = pCatRegister->RegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            } 
            else
            {
                pCatRegister->UnRegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (cCatReq && pCatReq)
                {
                    pCatRegister->UnRegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            }
        }
    }
    if ((!bRegister) && SUCCEEDED(hr)) 
    { 
        _Module.UpdateRegistryFromResource(ResourceId, bRegister);
    }
    return hr;
}


void CDXBaseNTo1::_TaskProc(void* pTaskInfo, BOOL* pbContinue )
{ 
    _ASSERT( pTaskInfo );
    CDXTWorkInfoNTo1& WI = *((CDXTWorkInfoNTo1 *)pTaskInfo);
    CDXBaseNTo1& This = *((CDXBaseNTo1 *)WI.pvThis);
    WI.hr = This.WorkProc(WI, pbContinue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\cryptdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptdlg.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTDLG_H__
#define __CRYPTDLG_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef _CRYPTDLG_
#define CRYPTDLGAPI
#else
#define CRYPTDLGAPI DECLSPEC_IMPORT
#endif

#if (_WIN32_WINNT >= 0x0400) || defined(_MAC) || defined(WIN16)

#include <prsht.h>

#ifdef __cplusplus
extern "C" {
#endif

// Master flags to control how revocation is managed

#define CRYTPDLG_FLAGS_MASK                 0xff000000
#define CRYPTDLG_REVOCATION_DEFAULT         0x00000000
#define CRYPTDLG_REVOCATION_ONLINE          0x80000000
#define CRYPTDLG_REVOCATION_CACHE           0x40000000
#define CRYPTDLG_REVOCATION_NONE            0x20000000


// Policy flags which control how we deal with user's certificates

#define CRYPTDLG_POLICY_MASK                0x0000FFFF
#define POLICY_IGNORE_NON_CRITICAL_BC       0x00000001

#define CRYPTDLG_ACTION_MASK                0xFFFF0000
#define ACTION_REVOCATION_DEFAULT_ONLINE    0x00010000
#define ACTION_REVOCATION_DEFAULT_CACHE     0x00020000

//
//  Many of the common dialogs can be passed a filter proc to reduce
//      the set of certificates displayed.  A generic filter proc has been
//      provided to cover many of the generic cases.
//  Return TRUE to display and FALSE to hide

typedef BOOL (WINAPI * PFNCMFILTERPROC)(
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD,   // lCustData, a cookie
        IN DWORD,   // dwFlags
        IN DWORD);  // dwDisplayWell

//  Display Well Values
#define CERT_DISPWELL_SELECT                    1
#define CERT_DISPWELL_TRUST_CA_CERT             2
#define CERT_DISPWELL_TRUST_LEAF_CERT           3
#define CERT_DISPWELL_TRUST_ADD_CA_CERT         4
#define CERT_DISPWELL_TRUST_ADD_LEAF_CERT       5
#define CERT_DISPWELL_DISTRUST_CA_CERT          6
#define CERT_DISPWELL_DISTRUST_LEAF_CERT        7
#define CERT_DISPWELL_DISTRUST_ADD_CA_CERT      8
#define CERT_DISPWELL_DISTRUST_ADD_LEAF_CERT    9

//
typedef UINT (WINAPI * PFNCMHOOKPROC)(
        IN HWND hwndDialog,
        IN UINT message,
        IN WPARAM wParam,
        IN LPARAM lParam);

//
#define CSS_SELECTCERT_MASK             0x00ffffff
#define CSS_HIDE_PROPERTIES             0x00000001
#define CSS_ENABLEHOOK                  0x00000002
#define CSS_ALLOWMULTISELECT            0x00000004
#define CSS_SHOW_HELP                   0x00000010
#define CSS_ENABLETEMPLATE              0x00000020
#define CSS_ENABLETEMPLATEHANDLE        0x00000040

#define SELCERT_OK                      IDOK
#define SELCERT_CANCEL                  IDCANCEL
#define SELCERT_PROPERTIES              100
#define SELCERT_FINEPRINT               101
#define SELCERT_CERTLIST                102
#define SELCERT_HELP                    IDHELP
#define SELCERT_ISSUED_TO               103
#define SELCERT_VALIDITY                104
#define SELCERT_ALGORITHM               105
#define SELCERT_SERIAL_NUM              106
#define SELCERT_THUMBPRINT              107

typedef struct tagCSSA {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCSTR              pTemplateName;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_A, *PCERT_SELECT_STRUCT_A;

typedef struct tagCSSW {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCWSTR             pTemplateName;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_W, *PCERT_SELECT_STRUCT_W;

#ifdef UNICODE
typedef CERT_SELECT_STRUCT_W CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_W PCERT_SELECT_STRUCT;
#else
typedef CERT_SELECT_STRUCT_A CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_A PCERT_SELECT_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateA(
        IN OUT PCERT_SELECT_STRUCT_A pCertSelectInfo
        );
#ifdef MAC
#define CertSelectCertificate CertSelectCertificateA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateW(
        IN OUT PCERT_SELECT_STRUCT_W pCertSelectInfo
        );
#ifdef UNICODE
#define CertSelectCertificate CertSelectCertificateW
#else
#define CertSelectCertificate CertSelectCertificateA
#endif
#endif  // MAC

/////////////////////////////////////////////////////////////

#define CM_VIEWFLAGS_MASK       0x00ffffff
#define CM_ENABLEHOOK           0x00000001
#define CM_SHOW_HELP            0x00000002
#define CM_SHOW_HELPICON        0x00000004
#define CM_ENABLETEMPLATE       0x00000008
#define CM_HIDE_ADVANCEPAGE     0x00000010
#define CM_HIDE_TRUSTPAGE       0x00000020
#define CM_NO_NAMECHANGE        0x00000040
#define CM_NO_EDITTRUST         0x00000080
#define CM_HIDE_DETAILPAGE      0x00000100
#define CM_ADD_CERT_STORES      0x00000200
#define CERTVIEW_CRYPTUI_LPARAM 0x00800000

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_A, *PCERT_VIEWPROPERTIES_STRUCT_A;

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_W {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_W, *PCERT_VIEWPROPERTIES_STRUCT_W;

#ifdef UNICODE
typedef CERT_VIEWPROPERTIES_STRUCT_W CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_W PCERT_VIEWPROPERTIES_STRUCT;
#else
typedef CERT_VIEWPROPERTIES_STRUCT_A CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_A PCERT_VIEWPROPERTIES_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesA(
        PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo
        );
#ifdef MAC
#define CertViewProperties CertViewPropertiesA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesW(
        PCERT_VIEWPROPERTIES_STRUCT_W pCertViewInfo
        );

#ifdef UNICODE
#define CertViewProperties CertViewPropertiesW
#else
#define CertViewProperties CertViewPropertiesA
#endif
#endif  // MAC


//
//  We provide a default filter function that people can use to do some
//      of the most simple things.
//

#define CERT_FILTER_OP_EXISTS           1
#define CERT_FILTER_OP_NOT_EXISTS       2
#define CERT_FILTER_OP_EQUALITY         3

typedef struct tagCMOID {
    LPCSTR              szExtensionOID;         // Extension to filter on
    DWORD               dwTestOperation;
    LPBYTE              pbTestData;
    DWORD               cbTestData;
} CERT_FILTER_EXTENSION_MATCH;

#define CERT_FILTER_INCLUDE_V1_CERTS    0x0001
#define CERT_FILTER_VALID_TIME_RANGE    0x0002
#define CERT_FILTER_VALID_SIGNATURE     0x0004
#define CERT_FILTER_LEAF_CERTS_ONLY     0x0008
#define CERT_FILTER_ISSUER_CERTS_ONLY   0x0010
#define CERT_FILTER_KEY_EXISTS          0x0020

typedef struct tagCMFLTR {
    DWORD               dwSize;
    DWORD               cExtensionChecks;
    CERT_FILTER_EXTENSION_MATCH * arrayExtensionChecks;
    DWORD               dwCheckingFlags;
} CERT_FILTER_DATA;

//
//  Maybe this should not be here -- but until it goes into wincrypt.h
//

//
//   Get a formatted friendly name for a certificate

CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertA(PCCERT_CONTEXT pccert, LPSTR pchBuffer,
                             DWORD cchBuffer);
CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertW(PCCERT_CONTEXT pccert, LPWSTR pchBuffer,
                              DWORD cchBuffer);
#ifdef UNICODE
#define GetFriendlyNameOfCert GetFriendlyNameOfCertW
#else
#define GetFriendlyNameOfCert GetFriendlyNameOfCertA
#endif


//
//  We also provide a WinTrust provider which performs the same set of
//      parameter checking that we do in order to validate certificates.
//

#define CERT_CERTIFICATE_ACTION_VERIFY  \
  { /* 7801ebd0-cf4b-11d0-851f-0060979387ea */  \
    0x7801ebd0, \
    0xcf4b,     \
    0x11d0,     \
    {0x85, 0x1f, 0x00, 0x60, 0x97, 0x93, 0x87, 0xea} \
  }
#define szCERT_CERTIFICATE_ACTION_VERIFY    \
    "{7801ebd0-cf4b-11d0-851f-0060979387ea}"  

typedef HRESULT (WINAPI * PFNTRUSTHELPER)(
        IN PCCERT_CONTEXT       pCertContext,
        IN DWORD                lCustData,
        IN BOOL                 fLeafCertificate,
        IN LPBYTE               pbTrustBlob);
//
//  Failure Reasons:
//

#define CERT_VALIDITY_BEFORE_START              0x00000001
#define CERT_VALIDITY_AFTER_END                 0x00000002
#define CERT_VALIDITY_SIGNATURE_FAILS           0x00000004
#define CERT_VALIDITY_CERTIFICATE_REVOKED       0x00000008
#define CERT_VALIDITY_KEY_USAGE_EXT_FAILURE     0x00000010
#define CERT_VALIDITY_EXTENDED_USAGE_FAILURE    0x00000020
#define CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE  0x00000040
#define CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION 0x00000080
#define CERT_VALIDITY_ISSUER_INVALID            0x00000100
#define CERT_VALIDITY_OTHER_EXTENSION_FAILURE   0x00000200
#define CERT_VALIDITY_PERIOD_NESTING_FAILURE    0x00000400
#define CERT_VALIDITY_OTHER_ERROR               0x00000800
#define CERT_VALIDITY_ISSUER_DISTRUST           0x02000000
#define CERT_VALIDITY_EXPLICITLY_DISTRUSTED     0x01000000
#define CERT_VALIDITY_NO_ISSUER_CERT_FOUND      0x10000000
#define CERT_VALIDITY_NO_CRL_FOUND              0x20000000
#define CERT_VALIDITY_CRL_OUT_OF_DATE           0x40000000
#define CERT_VALIDITY_NO_TRUST_DATA             0x80000000
#define CERT_VALIDITY_MASK_TRUST                0xffff0000
#define CERT_VALIDITY_MASK_VALIDITY             0x0000ffff

#define CERT_TRUST_MASK                         0x00ffffff
#define CERT_TRUST_DO_FULL_SEARCH               0x00000001
#define CERT_TRUST_PERMIT_MISSING_CRLS          0x00000002
#define CERT_TRUST_DO_FULL_TRUST                0x00000005
#define CERT_TRUST_ADD_CERT_STORES              CM_ADD_CERT_STORES

//
//  Trust data structure
//
//      Returned data arrays will be allocated using LocalAlloc and must
//      be freed by the caller.  The data in the TrustInfo array are individually
//      allocated and must be freed.  The data in rgChain must be freed by
//      calling CertFreeCertificateContext.
//
//  Defaults:
//      pszUsageOid == NULL     indicates that no trust validation should be done
//      cRootStores == 0        Will default to User's Root store
//      cStores == 0            Will default to User's CA and system's SPC stores
//      cTrustStores == 0       Will default to User's TRUST store
//      hprov == NULL           Will default to RSABase
//      any returned item which has a null pointer will not return that item.
//  Notes:
//      pfnTrustHelper is nyi

typedef struct _CERT_VERIFY_CERTIFICATE_TRUST {
    DWORD               cbSize;         // Size of this structure
    PCCERT_CONTEXT      pccert;         // Certificate to be verified
    DWORD               dwFlags;        // CERT_TRUST_*
    DWORD               dwIgnoreErr;    // Errors to ignore (CERT_VALIDITY_*)
    DWORD *             pdwErrors;      // Location to return error flags
    LPSTR               pszUsageOid;    // Extended Usage OID for Certificate
    HCRYPTPROV          hprov;          // Crypt Provider to use for validation
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    DWORD               lCustData;      //
    PFNTRUSTHELPER      pfnTrustHelper; // Callback function for cert validation
    DWORD *             pcChain;        // Count of items in the chain array
    PCCERT_CONTEXT **   prgChain;       // Chain of certificates used
    DWORD **            prgdwErrors;    // Errors on a per certificate basis
    DATA_BLOB **        prgpbTrustInfo; // Array of trust information used
} CERT_VERIFY_CERTIFICATE_TRUST, * PCERT_VERIFY_CERTIFICATE_TRUST;

//
//  Trust list manipulation routine
//
//  CertModifyCertificatesToTrust can be used to do modifications to the set of certificates
//      on trust lists for a given purpose.
//      if hcertstoreTrust is NULL, the System Store TRUST in Current User will be used
//      if pccertSigner is specified, it will be used to sign the resulting trust lists,
//              it also restricts the set of trust lists that may be modified.
//

#define CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED      1
#define CTL_MODIFY_REQUEST_REMOVE               2
#define CTL_MODIFY_REQUEST_ADD_TRUSTED          3

typedef struct _CTL_MODIFY_REQUEST {
    PCCERT_CONTEXT      pccert;         // Certificate to change trust on
    DWORD               dwOperation;    // Operation to be performed
    DWORD               dwError;        // Operation error code
} CTL_MODIFY_REQUEST, * PCTL_MODIFY_REQUEST;

CRYPTDLGAPI
HRESULT
WINAPI
CertModifyCertificatesToTrust(
        int cCerts,                     // Count of modifications to be done
        PCTL_MODIFY_REQUEST rgCerts,    // Array of modification requests
        LPCSTR szPurpose,               // Purpose OID to for modifications
        HWND hwnd,                      // HWND for any dialogs
        HCERTSTORE hcertstoreTrust,     // Cert Store to store trust information in
        PCCERT_CONTEXT pccertSigner);   // Certificate to be used in signing trust list

#ifdef WIN16
// Need to define export functions in WATCOM.
BOOL
WINAPI CertConfigureTrustA(void);

BOOL
WINAPI FormatVerisignExtension(
    DWORD /*dwCertEncodingType*/,
    DWORD /*dwFormatType*/,
    DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/,
    LPCSTR /*lpszStructType*/,
    const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/,
    void * pbFormat,
    DWORD * pcbFormat);
#endif // !WIN16

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // (_WIN32_WINNT >= 0x0400)

#endif // _CRYPTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxclrhlp.h ===
HRESULT WINAPI DXColorFromBSTR( BSTR Color, DWORD *pdwColor );

typedef struct _COLORVALUE_PAIR
{
    const CHAR  *szName;
    DWORD        dwValue;
} COLORVALUE_PAIR;

const COLORVALUE_PAIR
rgColorNames[] =
{
    { ("aliceblue"),             0xfff0f8ff },
    { ("antiquewhite"),          0xfffaebd7 },
    { ("aqua"),                  0xff00ffff },
    { ("aquamarine"),            0xff7fffd4 },
    { ("azure"),                 0xfff0ffff },
    { ("beige"),                 0xfff5f5dc },
    { ("bisque"),                0xffffe4c4 },
    { ("black"),                 0xff000000 },
    { ("blanchedalmond"),        0xffffebcd },
    { ("blue"),                  0xff0000ff },
    { ("blueviolet"),            0xff8a2be2 },
    { ("brown"),                 0xffa52a2a },
    { ("burlywood"),             0xffdeb887 },
    { ("cadetblue"),             0xff5f9ea0 },
    { ("chartreuse"),            0xff7fff00 },
    { ("chocolate"),             0xffd2691e },
    { ("coral"),                 0xffff7f50 },
    { ("cornflowerblue"),        0xff6495ed },
    { ("cornsilk"),              0xfffff8dc },
    { ("crimson"),               0xffdc143c },
    { ("cyan"),                  0xff00ffff },
    { ("darkblue"),              0xff00008b },
    { ("darkcyan"),              0xff008b8b },
    { ("darkgoldenrod"),         0xffb8860b },
    { ("darkgray"),              0xffa9a9a9 },
    { ("darkgreen"),             0xff006400 },
    { ("darkkhaki"),             0xffbdb76b },
    { ("darkmagenta"),           0xff8b008b },
    { ("darkolivegreen"),        0xff556b2f },
    { ("darkorange"),            0xffff8c00 },
    { ("darkorchid"),            0xff9932cc },
    { ("darkred"),               0xff8b0000 },
    { ("darksalmon"),            0xffe9967a },
    { ("darkseagreen"),          0xff8fbc8f },
    { ("darkslateblue"),         0xff483d8b },
    { ("darkslategray"),         0xff2f4f4f },
    { ("darkturquoise"),         0xff00ced1 },
    { ("darkviolet"),            0xff9400d3 },
    { ("deeppink"),              0xffff1493 },
    { ("deepskyblue"),           0xff00bfff },
    { ("dimgray"),               0xff696969 },
    { ("dodgerblue"),            0xff1e90ff },
    { ("firebrick"),             0xffb22222 },
    { ("floralwhite"),           0xfffffaf0 },
    { ("forestgreen"),           0xff228b22 },
    { ("fuchsia"),               0xffff00ff },
    { ("gainsboro"),             0xffdcdcdc },
    { ("ghostwhite"),            0xfff8f8ff },
    { ("gold"),                  0xffffd700 },
    { ("goldenrod"),             0xffdaa520 },
    { ("gray"),                  0xff808080 },
    { ("green"),                 0xff008000 },
    { ("greenyellow"),           0xffadff2f },
    { ("honeydew"),              0xfff0fff0 },
    { ("hotpink"),               0xffff69b4 },
    { ("indianred"),             0xffcd5c5c },
    { ("indigo"),                0xff4b0082 },
    { ("ivory"),                 0xfffffff0 },
    { ("khaki"),                 0xfff0e68c },
    { ("lavender"),              0xffe6e6fa },
    { ("lavenderblush"),         0xfffff0f5 },
    { ("lawngreen"),             0xff7cfc00 },
    { ("lemonchiffon"),          0xfffffacd },
    { ("lightblue"),             0xffadd8e6 },
    { ("lightcoral"),            0xfff08080 },
    { ("lightcyan"),             0xffe0ffff },
    { ("lightgoldenrodyellow"),  0xfffafad2 },
    { ("lightgreen"),            0xff90ee90 },
    { ("lightgrey"),             0xffd3d3d3 },
    { ("lightpink"),             0xffffb6c1 },
    { ("lightsalmon"),           0xffffa07a },
    { ("lightseagreen"),         0xff20b2aa },
    { ("lightskyblue"),          0xff87cefa },
    { ("lightslategray"),        0xff778899 },
    { ("lightsteelblue"),        0xffb0c4de },
    { ("lightyellow"),           0xffffffe0 },
    { ("lime"),                  0xff00ff00 },
    { ("limegreen"),             0xff32cd32 },
    { ("linen"),                 0xfffaf0e6 },
    { ("magenta"),               0xffff00ff },
    { ("maroon"),                0xff800000 },
    { ("mediumaquamarine"),      0xff66cdaa },
    { ("mediumblue"),            0xff0000cd },
    { ("mediumorchid"),          0xffba55d3 },
    { ("mediumpurple"),          0xff9370db },
    { ("mediumseagreen"),        0xff3cb371 },
    { ("mediumslateblue"),       0xff7b68ee },
    { ("mediumspringgreen"),     0xff00fa9a },
    { ("mediumturquoise"),       0xff48d1cc },
    { ("mediumvioletred"),       0xffc71585 },
    { ("midnightblue"),          0xff191970 },
    { ("mintcream"),             0xfff5fffa },
    { ("mistyrose"),             0xffffe4e1 },
    { ("moccasin"),              0xffffe4b5 },
    { ("navajowhite"),           0xffffdead },
    { ("navy"),                  0xff000080 },
    { ("oldlace"),               0xfffdf5e6 },
    { ("olive"),                 0xff808000 },
    { ("olivedrab"),             0xff6b8e23 },
    { ("orange"),                0xffffa500 },
    { ("orangered"),             0xffff4500 },
    { ("orchid"),                0xffda70d6 },
    { ("palegoldenrod"),         0xffeee8aa },
    { ("palegreen"),             0xff98fb98 },
    { ("paleturquoise"),         0xffafeeee },
    { ("palevioletred"),         0xffdb7093 },
    { ("papayawhip"),            0xffffefd5 },
    { ("peachpuff"),             0xffffdab9 },
    { ("peru"),                  0xffcd853f },
    { ("pink"),                  0xffffc0cb },
    { ("plum"),                  0xffdda0dd },
    { ("powderblue"),            0xffb0e0e6 },
    { ("purple"),                0xff800080 },
    { ("red"),                   0xffff0000 },
    { ("rosybrown"),             0xffbc8f8f },
    { ("royalblue"),             0xff4169e1 },
    { ("saddlebrown"),           0xff8b4513 },
    { ("salmon"),                0xfffa8072 },
    { ("sandybrown"),            0xfff4a460 },
    { ("seagreen"),              0xff2e8b57 },
    { ("seashell"),              0xfffff5ee },
    { ("sienna"),                0xffa0522d },
    { ("silver"),                0xffc0c0c0 },
    { ("skyblue"),               0xff87ceeb },
    { ("slateblue"),             0xff6a5acd },
    { ("slategray"),             0xff708090 },
    { ("snow"),                  0xfffffafa },
    { ("springgreen"),           0xff00ff7f },
    { ("steelblue"),             0xff4682b4 },
    { ("tan"),                   0xffd2b48c },
    { ("teal"),                  0xff008080 },
    { ("thistle"),               0xffd8bfd8 },
    { ("tomato"),                0xffff6347 },
    { ("turquoise"),             0xff40e0d0 },
    { ("violet"),                0xffee82ee },
    { ("wheat"),                 0xfff5deb3 },
    { ("white"),                 0xffffffff },
    { ("whitesmoke"),            0xfff5f5f5 },
    { ("yellow"),                0xffffff00 },
    { ("yellowgreen"),           0xff9acd32 }

}; // rgColorNames[]

#define SIZE_OF_COLOR_TABLE (sizeof(rgColorNames) / sizeof(COLORVALUE_PAIR))

const COLORVALUE_PAIR 
rgSystemColorNames[] =
{
    { ("activeborder"),       COLOR_ACTIVEBORDER},    // Active window border.
    { ("activecaption"),      COLOR_ACTIVECAPTION},   // Active window caption.
    { ("appworkspace"),       COLOR_APPWORKSPACE},    // Background color of multiple document interface (MDI) applications.
    { ("background"),         COLOR_BACKGROUND},      // Desktop background.
    { ("buttonface"),         COLOR_BTNFACE},         // Face color for three-dimensional display elements.
    { ("buttonhighlight"),    COLOR_BTNHIGHLIGHT},    // Dark shadow for three-dimensional display elements.
    { ("buttonshadow"),       COLOR_BTNSHADOW},       // Shadow color for three-dimensional display elements (for edges facing away from the light source).
    { ("buttontext"),         COLOR_BTNTEXT},         // Text on push buttons.
    { ("captiontext"),        COLOR_CAPTIONTEXT},     // Text in caption, size box, and scroll bar arrow box.
    { ("graytext"),           COLOR_GRAYTEXT},        // Grayed (disabled) text. This color is set to 0 if the current display driver does not support a solid gray color.
    { ("highlight"),          COLOR_HIGHLIGHT},       // Item(s) selected in a control.
    { ("highlighttext"),      COLOR_HIGHLIGHTTEXT},   // Text of item(s) selected in a control.
    { ("inactiveborder"),     COLOR_INACTIVEBORDER},  // Inactive window border.
    { ("inactivecaption"),    COLOR_INACTIVECAPTION}, // Inactive window caption.
    { ("inactivecaptiontext"),COLOR_INACTIVECAPTIONTEXT}, // Color of text in an inactive caption.
    { ("infobackground"),     COLOR_INFOBK},          // Background color for tooltip controls.
    { ("infotext"),           COLOR_INFOTEXT},        // Text color for tooltip controls.
    { ("menu"),               COLOR_MENU},            // Menu background.
    { ("menutext"),           COLOR_MENUTEXT},        // Text in menus.
    { ("scrollbar"),          COLOR_SCROLLBAR},       // Scroll bar gray area.
    { ("threeddarkshadow"),   COLOR_3DDKSHADOW },     // Dark shadow for three-dimensional display elements.
    { ("threedface"),         COLOR_3DFACE},
    { ("threedhighlight"),    COLOR_3DHIGHLIGHT},     // Highlight color for three-dimensional display elements (for edges facing the light source.)
    { ("threedlightshadow"),  COLOR_3DLIGHT},         // Light color for three-dimensional display elements (for edges facing the light source.)
    { ("threedshadow"),       COLOR_3DSHADOW},        // Dark shadow for three-dimensional display elements.
    { ("window"),             COLOR_WINDOW},          // Window background.
    { ("windowframe"),        COLOR_WINDOWFRAME},     // Window frame.
    { ("windowtext"),         COLOR_WINDOWTEXT},      // Text in windows.
}; // rgSystemColorNames[]

#define SIZE_OF_SYSTEM_COLOR_TABLE (sizeof(rgSystemColorNames) / sizeof(COLORVALUE_PAIR))

//
// Used by DXColorFromBSTR to parse the hex string.
//

inline HRESULT _HexStrToDWORD( char * pch, DWORD * pdwColor )
{

    HRESULT hr = S_OK;
    short hexVals[8];
    int numVals;
    int i;
    DWORD dwmult;

    if( !pch || !pdwColor )
    {
        hr = E_FAIL;
    }
    else
    {
        //--- parse input string
        numVals = 0;
        while( *pch && numVals < 8 )
        {
            if( *pch >= '0' && *pch <= '9' )
            {
                hexVals[numVals++] = *pch++ - '0';
            }
            else if( *pch >= 'a' && *pch <= 'f' )
            {
                hexVals[numVals++] = *pch++ - 'a' + 10;
            }
            else if( *pch >= 'A' && *pch <= 'F' )
            {
                hexVals[numVals++] = *pch++ - 'A' + 10;
            }
            else
            {
                break;
            }
        }

        if( numVals < 6 )
        {
            hr = E_FAIL;
        }
        else
        {
            //--- if we were passed 7 hex digits, only use the first 6
            if( numVals == 7 )
            {
                numVals = 6;
            }

            //--- initialize multiplier
            dwmult = 1;
            *pdwColor = 0;

            //--- multiply hexVals by 16^i
            for( i = 0; i < numVals; i++ )
            {
                *pdwColor += (hexVals[numVals-(i+1)]*dwmult);
                dwmult <<= 4;
            }
        }
    }
   
    return hr;
}

// 
// Used by DXColorFromBSTR to convert a string to lower case
//

inline void StringToLowerCase( CHAR * pstrKey )
{
    if( pstrKey )
    {
        while( *pstrKey )
        {
            if( *pstrKey >= 'A' && *pstrKey <= 'Z' )
            {
                *pstrKey = 'a' + *pstrKey - 'A';
            }
            pstrKey++;
        }
    }
}


inline HRESULT WINAPI DXColorFromBSTR( BSTR Color, DWORD *pdwColor )
{
    HRESULT hr = S_OK;
    // validate arguments
    int strLen = wcslen(Color);
    if( strLen < 3 || DXIsBadReadPtr( Color, strLen ) || 
        DXIsBadWritePtr( pdwColor, sizeof(*pdwColor) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- first check for #AARRGGBB and #RRGGBB strings
        if( Color[0] == L'#' )
        {
            CHAR ch[11] = "0xffffffff";
            if( strLen > 9 ) strLen = 9;
            if( strLen >= 7 )
            {
                WideCharToMultiByte( CP_ACP, NULL, &Color[1], strLen-1, &ch[11-strLen], strLen, NULL, NULL );
                hr = _HexStrToDWORD( &ch[2], pdwColor);
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            //--- convert the string to lower case
            LPSTR pstrKey = (LPSTR) alloca((strLen + 1) * sizeof(CHAR));
            WideCharToMultiByte( CP_ACP, NULL, Color, strLen+1, pstrKey, strLen+1, NULL, NULL );
            StringToLowerCase( pstrKey );

            //--- search the string table using a binary search
            int nFirst = 0;
            int nLast = SIZE_OF_COLOR_TABLE - 1;
            int nCur, nCmp;
            bool bFound = false;
            while( (nFirst <= nLast) && !bFound )
            {
                nCur = (nFirst + nLast) / 2;
                nCmp = strcmp( rgColorNames[nCur].szName, pstrKey );
                if( nCmp < 0 )
                {
                    nFirst = nCur + 1;
                }
                else if( nCmp > 0 )
                {
                    nLast = nCur - 1;
                }
                else
                {
                    bFound = true;
                    *pdwColor = rgColorNames[nCur].dwValue;
                }
            }

            // String not in regular color table, try the system color table.

            if (!bFound)
            {
                nFirst  = 0;
                nLast   = SIZE_OF_SYSTEM_COLOR_TABLE - 1;

                while ((nFirst <= nLast) && !bFound)
                {
                    nCur = (nFirst + nLast) / 2;
                    nCmp = strcmp(rgSystemColorNames[nCur].szName, pstrKey);

                    if (nCmp < 0)
                    {
                        nFirst = nCur + 1;
                    }
                    else if (nCmp > 0)
                    {
                        nLast = nCur - 1;
                    }
                    else
                    {
                        bFound = true;
                        *pdwColor =  ::GetSysColor((int)rgSystemColorNames[nCur].dwValue);
                        *pdwColor |= 0xFF000000;
                    }
                }

                // String not found in regular or system color table.

                if (!bFound)
                {
                    hr = E_FAIL;
                }
            }
        }

    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxatlpb.h ===
#ifndef dxatlpb_h
#define dxatlpb_h

#include <atlctl.h>

#ifndef DXTDbg_h
#include <dxtdbg.h>
#endif

#define COM_INTERFACE_ENTRY_DXIMPL(x)\
	COM_INTERFACE_ENTRY_IID(IID_##x, x##DXImpl<_ComMapClass>)

/*** IOleObjectDXImpl
*   This is a simplified version used to allow a transform
*   to be hosted by IE
*/
template <class T>
class ATL_NO_VTABLE IOleObjectDXImpl
{
  public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
        STDMETHOD_(ULONG,AddRef)() = 0;
        STDMETHOD_(ULONG,Release)() = 0;

	// IOleObject
	//
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetClientSite" );
        HRESULT hr = S_OK;
        if( pClientSite && DXIsBadInterfacePtr( pClientSite ) )
        {
            hr = E_INVALIDARG;
        }
        else
        {
    		T* pT = static_cast<T*>(this);
            pT->m_cpOleClientSite = pClientSite;
        }
        return hr;
	}

	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetClientSite" );
        HRESULT hr = S_OK;
        if( DXIsBadWritePtr( ppClientSite, sizeof( *ppClientSite )) )
        {
            hr = E_POINTER;
        }
        else
        {
    		T* pT = static_cast<T*>(this);
            *ppClientSite = pT->m_cpOleClientSite;
        }
        return hr;
	}

	STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetHostNames" );
		return S_OK;
	}
	STDMETHOD(Close)(DWORD dwSaveOption)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Close" );
		return S_OK;
	}
	STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetMoniker" );
        return E_NOTIMPL;
	}
	STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetMoniker" );
        return E_NOTIMPL;
	}
	STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::InitFromData" );
        return E_NOTIMPL;
	}
	STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetClipboardData" );
        return E_NOTIMPL;
	}

	STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* lpmsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
									 HWND hwndParent, LPCRECT lprcPosRect)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::DoVerb" );
		return S_OK;
	}
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::DoVerb" );
		return OLEOBJ_E_NOVERBS;
	}
	STDMETHOD(Update)(void)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Update" );
		return S_OK;
	}
	STDMETHOD(IsUpToDate)(void)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::IsUpToDate" );
		return S_OK;
	}
	STDMETHOD(GetUserClassID)(CLSID *pClsid)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetUserClassID" );
		_ASSERTE(pClsid);
		if( DXIsBadWritePtr( pClsid, sizeof( *pClsid ) ) )
        {
			return E_POINTER;
        }
        else
        {
		    *pClsid = T::GetObjectCLSID();
		    return S_OK;
        }
	}
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetUserType" );
		return OLE_S_USEREG;
	}
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetExtent" );
        return S_OK;
	}
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetExtent" );
        HRESULT hr = S_OK;
        if( DXIsBadWritePtr( psizel, sizeof( *psizel ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            psizel->cx = 0;
            psizel->cy = 0;
        }
		return hr;
	}
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Advise" );
        return S_OK;
	}
	STDMETHOD(Unadvise)(DWORD dwConnection)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Unadvise" );
        return S_OK;
	}
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::EnumAdvise" );
        return E_FAIL;
	}
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetMiscStatus" );
		return OLE_S_USEREG;
	}
	STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetColorScheme" );
        return E_NOTIMPL;
	}
};

/*** CComPropBase
*
*/
class ATL_NO_VTABLE CComPropBase
{
public:
    HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag,
	    LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap)
    {
	    USES_CONVERSION;
	    CComPtr<IDispatch> pDispatch;
	    const IID* piidOld = NULL;
	    for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (pMap[i].szDesc == NULL)
			    continue;
		    CComVariant var;

		    if(pMap[i].piidDispatch != piidOld)
		    {
			    pDispatch.Release();
			    if(FAILED(PropQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			    {
				    ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
				    return E_FAIL;
			    }
			    piidOld = pMap[i].piidDispatch;
		    }

		    if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		    {
			    ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			    return E_FAIL;
		    }

		    HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
		    if (FAILED(hr))
		    {
			    if (hr == E_INVALIDARG)
			    {
				    ATLTRACE(_T("Property %s not in Bag\n"), OLE2CT(pMap[i].szDesc));
			    }
			    else
			    {
				    // Many containers return different ERROR values for Member not found
				    ATLTRACE(_T("Error attempting to read Property %s from PropertyBag \n"), OLE2CT(pMap[i].szDesc));
			    }
			    continue;
		    }

		    if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		    {
			    ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			    return E_FAIL;
		    }
	    }
	    return S_OK;

    }

    HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
	    BOOL fClearDirty, BOOL /*fSaveAllProperties*/, ATL_PROPMAP_ENTRY* pMap)
    {
	    if (pPropBag == NULL)
	    {
		    ATLTRACE(_T("PropBag pointer passed in was invalid\n"));
		    return E_POINTER;
	    }

	    CComPtr<IDispatch> pDispatch;
	    const IID* piidOld = NULL;
	    for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (pMap[i].szDesc == NULL)
			    continue;
		    CComVariant var;

		    if(pMap[i].piidDispatch != piidOld)
		    {
			    pDispatch.Release();
			    if(FAILED(PropQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			    {
				    ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
				    return E_FAIL;
			    }
			    piidOld = pMap[i].piidDispatch;
		    }

		    if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		    {
			    ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			    return E_FAIL;
		    }

		    if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
		    {
			    if (var.punkVal == NULL)
			    {
				    ATLTRACE(_T("Warning skipping empty IUnknown in Save\n"));
				    continue;
			    }
		    }

		    HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
		    if (FAILED(hr))
			    return hr;
	    }
	    m_bRequiresSave = FALSE;
	    return S_OK;
    }

    HRESULT ISpecifyPropertyPages_GetPages(CAUUID* pPages,
	    ATL_PROPMAP_ENTRY* pMap)
    {
	    _ASSERTE(pMap != NULL);
	    int nCnt = 0;
	    // Get count of unique pages
	    for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
			    nCnt++;
	    }
	    pPages->pElems = NULL;
	    pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*nCnt);
	    if (pPages->pElems == NULL)
		    return E_OUTOFMEMORY;
	    nCnt = 0;
	    for(i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
		    {
			    BOOL bMatch = FALSE;
			    for (int j=0;j<nCnt;j++)
			    {
				    if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))
				    {
					    bMatch = TRUE;
					    break;
				    }
			    }
			    if (!bMatch)
				    pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;
		    }
	    }
	    pPages->cElems = nCnt;
	    return S_OK;
    }
    virtual HRESULT PropQueryInterface(const IID& iid, void** ppv) = 0;
    BOOL m_bRequiresSave;
};


template <class T>
class ATL_NO_VTABLE CComPropertySupport :  public CComPropBase
{
public:
    virtual HRESULT PropQueryInterface(const IID& iid, void** ppv)
    {
        T* pT = static_cast<T*>(this);
	return pT->_InternalQueryInterface(iid, ppv);
    }
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//

template <class T> 
class ATL_NO_VTABLE IObjectSafetyImpl2
{
public:
        DWORD m_dwSafety[4];
        const IID *m_pIID[4];

        IObjectSafetyImpl2()
	{
            m_pIID[0] = &IID_IDispatch;
            m_pIID[1] = &IID_IPersistPropertyBag;
            m_pIID[2] = &IID_IPersistStorage;
            m_pIID[3] = &IID_IPersistStream;
            for (int i = 0; i < 4; i++)
            {
		m_dwSafety[i] = 0;
            }
	}

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IObjectSafetyImpl2)

	// IObjectSafety
	//
	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
			return E_POINTER;
                for (int i = 0; i < 4 && m_pIID[i]; i++)
                {
                    if (riid == *m_pIID[i]) {
			*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
			*pdwEnabledOptions = m_dwSafety[i] & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
                        return S_OK;
                    }
		}
            	*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		return E_NOINTERFACE;
	}
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
		// If we're being asked to set our safe for scripting option then oblige
                for (int i = 0; i < 4 && m_pIID[i]; i++)
                {
                    if (riid == *m_pIID[i]) {
			m_dwSafety[i] = dwEnabledOptions & dwOptionSetMask;
                        return S_OK;
                    }
		}
		return E_NOINTERFACE;
	}

};

#endif // This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dtbase.h ===
/*******************************************************************************
* DTBase.h *
*----------*
*   Description:
*       This is the header file for the CDXBaseNTo1 implementation. It is
*   used as a base class to implement discrete transform objects that support
*   DXSurfaces.
*-------------------------------------------------------------------------------
*  Created By: Ed Connell                            Date: 07/27/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DTBase_h
#define DTBase_h

//--- Additional includes
#ifndef DXHelper_h
#include <DXHelper.h>
#endif

#ifndef DXTmpl_h
#include <DXTmpl.h>
#endif

#ifndef dxatlpb_h
#include <dxatlpb.h>
#endif

#ifndef _ASSERT
#include <crtdbg.h>
#endif

#ifndef DXTDbg_h
#include <DXTDbg.h>
#endif

//=== Constants ====================================================
#define DXBOF_INPUTS_MESHBUILDER    0x00000001
#define DXBOF_OUTPUT_MESHBUILDER    0x00000002
#define DXBOF_SAME_SIZE_INPUTS      0x00000004
#define DXBOF_CENTER_INPUTS         0x00000008

#define DXB_MAX_IMAGE_BANDS         4           // Maximum of 4 image bands

//=== Class, Enum, Struct and Union Declarations ===================
class CDXBaseNTo1;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CDXDataPtr
*
*/
class CDXDataPtr
{
    friend CDXBaseNTo1;
public:
    IUnknown           *m_pUnkOriginalObject;
    IUnknown           *m_pNativeInterface;
    IDXBaseObject      *m_pBaseObj;
    DWORD               m_dwLastDirtyGenId;
    DXSAMPLEFORMATENUM  m_SampleFormat;

    CDXDataPtr() : 
        m_pUnkOriginalObject(NULL),
        m_pNativeInterface(NULL), 
        m_pBaseObj(NULL),
        m_dwLastUpdGenId(0),
        m_dwLastDirtyGenId(0),
        m_SampleFormat(DXPF_NONSTANDARD)
        {};
    ~CDXDataPtr() { Release(); }
    void Release()
    {
        if (m_pNativeInterface)
        {
            m_pNativeInterface->Release();
            m_pNativeInterface = NULL;
        }
        if (m_pBaseObj)
        {
            m_pBaseObj->Release();
            m_pBaseObj = NULL;
        }
        if (m_pUnkOriginalObject)
        {
            m_pUnkOriginalObject->Release();
            m_pUnkOriginalObject = NULL;
        }
    }
    HRESULT Assign(BOOL bMeshBuilder, IUnknown * pObject, IDXSurfaceFactory *pSurfFact);
    bool IsDirty(void);
    DWORD GenerationId(void);
    ULONG ObjectSize(void);
private:    // This should only be called by base class
    DWORD           m_dwLastUpdGenId;
    bool UpdateGenerationId(void);
};

/*--- CDXTWorkInfoNTo1
*   This structure is used to hold the arguments needed by the
*   image processing function defined by the derived class
*/
class CDXTWorkInfoNTo1
{
public:
    CDXTWorkInfoNTo1()
    { pvThis = NULL; pUserInstData = NULL; hr = S_OK; }
    void *   pvThis;          // The owning class object (must be cast to the right type)
    CDXDBnds DoBnds;          // The portion of the output space to render
    CDXDBnds OutputBnds;      // The portion of the output SURFACE to render
    void*    pUserInstData;   // User field for instance data
    HRESULT  hr;              // Error return code from work procedure
};

/*** CDXBaseNTo1
*   This is a base class used for implementing 1 in 1 out discrete transforms.
*/
class ATL_NO_VTABLE CDXBaseNTo1 : 
    public CComObjectRootEx<CComMultiThreadModel>,
#if(_ATL_VER < 0x0300)
    public IObjectSafetyImpl<CDXBaseNTo1>,
#else
    public IObjectSafetyImpl<CDXBaseNTo1,INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
#endif
    public IDXTransform,
    public IDXSurfacePick,
    public IObjectWithSite
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CDXBaseNTo1)
        COM_INTERFACE_ENTRY(IDXTransform)
        COM_INTERFACE_ENTRY(IDXBaseObject)
        COM_INTERFACE_ENTRY(IObjectWithSite)
#if(_ATL_VER < 0x0300)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
#else
        COM_INTERFACE_ENTRY(IObjectSafety)
#endif
        COM_INTERFACE_ENTRY_FUNC(IID_IDXSurfacePick, 0, QI2DPick)
    END_COM_MAP()

    //
    //  Only return the 2D pick inteface for surface to surface transforms
    //
    static HRESULT WINAPI QI2DPick(void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw)
    {
        CDXBaseNTo1 * pThis = (CDXBaseNTo1 *)pv;
        if (pThis->m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER))
        {
            return S_FALSE; // Continue processing COM map
        }
        *ppv = (IDXSurfacePick *)pThis;
        ((IDXSurfacePick *)pThis)->AddRef();
        return S_OK;
    }

    CComPtr<IOleClientSite> m_cpOleClientSite;

  /*=== Member Data ===*/
  protected:
    CComPtr<IUnknown>            m_cpUnkSite;
    CComPtr<IDXTransformFactory> m_cpTransFact;   
    CComPtr<IDXSurfaceFactory>   m_cpSurfFact;
    CComPtr<IDXTaskManager>      m_cpTaskMgr;
    CComPtr<IDirectDraw>         m_cpDirectDraw;
    CComPtr<IDirect3DRM3>        m_cpDirect3DRM;
    DWORD        m_dwMiscFlags;
    HANDLE       m_aEvent[DXB_MAX_IMAGE_BANDS];
    ULONG        m_ulNumProcessors;
    DWORD        m_dwGenerationId;
    DWORD        m_dwCleanGenId;
    BOOL         m_bPickDoneByBase;
    float        m_Duration;
    float        m_StepResolution;
    float        m_fQuality;        // Set DXTMF_QUALITY_SUPPORTED in m_dwMiscFlags if you use this property.    
    ULONG        m_ulNumInputs;
    DWORD        m_dwBltFlags;      // Ser prior to OnSetup and any Execute for classes with surface outputs
    BOOL         m_bInMultiThreadWorkProc;  // Base class sets to TRUE when scheduling tasks on multiple threads

    //
    //  Derived classes should set these values in their constructor or in FinalConstruct()
    //
    DWORD        m_dwOptionFlags;
    ULONG        m_ulLockTimeOut;     // The amount of time used for blocking
    ULONG        m_ulMaxInputs;
    ULONG        m_ulNumInRequired;
    ULONG        m_ulMaxImageBands;   // Only used for surface->Surface transforms
    float        m_Progress;

private:
    CDXDataPtr* m_aInputs;
    CDXDataPtr  m_Output;

    // m_fIsSetup   This is true when the DXTransform has been properly set up.

    unsigned    m_fIsSetup : 1;

  /*=== Methods =======*/
  public:
    //--- Constructors
    CDXBaseNTo1();
    ~CDXBaseNTo1();

    //--- Support virtuals for derived classes
    virtual HRESULT OnInitInstData( CDXTWorkInfoNTo1& /*WorkInfo*/, ULONG& /*ulNumBandsToDo*/) { return S_OK; }
    virtual HRESULT OnFreeInstData( CDXTWorkInfoNTo1& /*WorkInfo*/ ) { return S_OK; }
    virtual HRESULT OnSetup( DWORD /* dwFlags */) { return S_OK; }    // Override to be notified of a new non-null setup
    virtual void OnReleaseObjects() {}  // Override to be notified of NULL setup
    virtual HRESULT OnExecute(const GUID* /* pRequestID */, const DXBNDS * /*pClipBnds */,
                              const DXVEC * /*pPlacement */ ) { return E_FAIL; }
    virtual void OnUpdateGenerationId(void);
    virtual ULONG OnGetObjectSize(void);
    virtual HRESULT WorkProc(const CDXTWorkInfoNTo1 & WorkInfo, BOOL* pbContinueProcessing) { return E_FAIL; }   // Override to do work
    virtual HRESULT DetermineBnds(CDXCBnds & Bnds) { return S_OK; } // Override for mesh output transforms
    virtual HRESULT DetermineBnds(CDXDBnds & Bnds) { return S_OK; } // Override for surface output transforms
    //
    //  Only override this function if you need to do a customized point pick implementation.  Otherwise simply
    //  override GetPointPickOrder() and return appropriate information.
    //
    virtual HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec) { return E_NOTIMPL; }
    virtual void OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, ULONG aInIndex[], BYTE aWeight[])
    {
        m_bPickDoneByBase = true;
        ulInToTest  = 1;
        aInIndex[0] = 0;
        aWeight[0]  = 255;
    }

    //--- Private helpers
 private:
    static DXTASKPROC _TaskProc;
    void _ReleaseReferences();
    void _ReleaseServices();
    void _UpdateBltFlags(void);
    HRESULT _MakeInputsSameSize(void);
    HRESULT _ImageMapIn2Out(CDXDBnds & bnds, ULONG ulNumBnds, const CDXDBnds * pInBounds);
    HRESULT _MeshMapIn2Out(CDXCBnds & bnds, ULONG ulNumInBnds, CDXCBnds * pInBounds);


    //
    //--- Public helpers
    //
 public:
    float GetEffectProgress(void) { return m_Progress; }
    ULONG GetNumInputs(void) { return m_ulNumInputs; }

    //
    //  Use these inline functions to access input and output objects
    //
    BOOL HaveInput(ULONG i = 0) { return (m_ulNumInputs > i && m_aInputs[i].m_pNativeInterface); }

    IDirect3DRMMeshBuilder3 * OutputMeshBuilder()
    {
        _ASSERT(m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER);
        return (IDirect3DRMMeshBuilder3 *)m_Output.m_pNativeInterface;
    }

    IDXSurface * OutputSurface()
    {
        _ASSERT((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0);
        return (IDXSurface *)m_Output.m_pNativeInterface;
    }

    IDirect3DRMMeshBuilder3 * InputMeshBuilder(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT(m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER);
        return (IDirect3DRMMeshBuilder3 *)m_aInputs[i].m_pNativeInterface;
    }

    IDXSurface * InputSurface(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);
        return (IDXSurface *)m_aInputs[i].m_pNativeInterface;
    }

    DXSAMPLEFORMATENUM OutputSampleFormat(void)
    {
        _ASSERT((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0);
        return m_Output.m_SampleFormat;
    }

    DXSAMPLEFORMATENUM InputSampleFormat(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);
        return m_aInputs[i].m_SampleFormat;
    }

    BOOL HaveOutput(void) { return m_Output.m_pNativeInterface != NULL; }

    bool IsInputDirty(ULONG i = 0)
    {   
        _ASSERT(i < m_ulNumInputs);
        return m_aInputs[i].IsDirty();
    }

    bool IsOutputDirty()
    {   
        _ASSERT(HaveOutput());
        return m_Output.IsDirty();
    }

    //--- Public helpers.  Should be called with critical seciton claimed.
    inline BOOL DoOver(void) const
    { 
        return m_dwBltFlags & DXBOF_DO_OVER;
    }

    inline BOOL DoDither(void) const
    {
        return m_dwBltFlags & DXBOF_DITHER;
    }

    BOOL NeedSrcPMBuff(ULONG i = 0)
    {
        return ((m_dwBltFlags & DXBOF_DITHER) || InputSampleFormat(i) != DXPF_PMARGB32);
    }

    BOOL NeedDestPMBuff(void)
    {
        return OutputSampleFormat() != DXPF_PMARGB32;
    }

    void SetDirty() { m_dwGenerationId++; }
    void ClearDirty() { OnUpdateGenerationId(); m_dwCleanGenId = m_dwGenerationId; }
    BOOL IsTransformDirty() { OnUpdateGenerationId(); return m_dwCleanGenId != m_dwGenerationId; }

    
  public:
    //=== IObjectWithSite =======================================
    STDMETHOD( SetSite )( IUnknown *pUnkSite );
    STDMETHOD( GetSite )( REFIID riid, void ** ppvSite );

    //=== IDXBaseObject =========================================
    STDMETHOD( GetGenerationId ) (ULONG * pGenId);
    STDMETHOD( IncrementGenerationId) (BOOL bRefresh);
    STDMETHOD( GetObjectSize ) (ULONG * pcbSize); 

  
      //=== IDXTransform ===============================================
    STDMETHOD( Setup )( IUnknown * const * punkInputs, ULONG ulNumIn,
                        IUnknown * const * punkOutputs, ULONG ulNumOut, DWORD dwFlags );
    STDMETHOD( Execute )( const GUID* pRequestID,
                          const DXBNDS *pOutBounds, const DXVEC *pPlacement );
    STDMETHOD( MapBoundsIn2Out )( const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                  ULONG ulOutIndex, DXBNDS *pOutBounds );
    STDMETHOD( MapBoundsOut2In )( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds );
    STDMETHOD( SetMiscFlags ) ( DWORD dwOptionFlags );
    STDMETHOD( GetMiscFlags ) ( DWORD * pdwMiscFlags );
    STDMETHOD( GetInOutInfo )( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags, GUID * pIDs, ULONG * pcIDs, IUnknown **ppUnkCurObj);
    STDMETHOD( SetQuality )( float fQuality );
    STDMETHOD( GetQuality )( float *pfQuality );

    STDMETHOD (PointPick) (const DXVEC *pPoint,
                           ULONG * pulInputSurfaceIndex,
                           DXVEC *pInputPoint);

    //
    //  Effect interface
    //
    //  NOTE:  Derived classes MUST implement get_Capabilities.  Use macros below.
    //
    STDMETHODIMP get_Capabilities(long *pVal) { _ASSERT(true); return E_NOTIMPL; }
    //
    //  All other methods are implemented in the base.
    //
    STDMETHODIMP get_Progress(float *pVal);
    STDMETHODIMP put_Progress(float newVal);
    STDMETHODIMP get_StepResolution(float *pVal);
    STDMETHODIMP get_Duration(float *pVal);
    STDMETHODIMP put_Duration(float newVal);

    //
    //  Helper functions derived classes can use
    //

    //
    //  Static function for registering in one or more component categories
    //
    static HRESULT RegisterTransform(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                                     ULONG cCatReq, const CATID * pCatReq, BOOL bRegister);

};

//=== Inline Function Definitions ==================================

//=== Macro Definitions ============================================

#define DECLARE_REGISTER_DX_TRANSFORM(id, catid)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 1, &(catid), 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_TRANS_CATS(id, countimpl, pcatidsimpl, countreq, pcatidsreq)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), (count), (pcatids), (countreq), (pcatidsreq), bRegister); \
        } 

#define DECLARE_REGISTER_DX_IMAGE_TRANS(id) \
    DECLARE_REGISTER_DX_TRANSFORM(id, CATID_DXImageTransform)

#define DECLARE_REGISTER_DX_3D_TRANS(id) \
    DECLARE_REGISTER_DX_TRANSFORM(id, CATID_DX3DTransform)

#define DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(id) \
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            GUID a_Cats[2]; \
            a_Cats[0] = CATID_DXImageTransform; \
            a_Cats[1] = CATID_DXAuthoringTransform; \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 2, a_Cats, 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_3D_AUTHOR_TRANS(id) \
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            GUID a_Cats[2]; \
            a_Cats[0] = CATID_DX3DTransform; \
            a_Cats[1] = CATID_DXAuthoringTransform; \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 2, a_Cats, 0, NULL, bRegister); \
        } 

//
//  Effect interface
//
#define DECLARE_GET_CAPABILITIES(Caps)\
STDMETHODIMP get_Capabilities(long *pVal) { if (DXIsBadWritePtr(pVal, sizeof(*pVal))) return E_POINTER; *pVal = Caps; return S_OK; }

#define DECLARE_GET_PROGRESS()\
        STDMETHODIMP get_Progress(float *pVal) { return CDXBaseNTo1::get_Progress(pVal); }

#define DECLARE_PUT_PROGRESS()\
        STDMETHODIMP put_Progress(float newVal) { return CDXBaseNTo1::put_Progress(newVal); }

#define DECLARE_GET_STEPRESOLUTION()\
        STDMETHODIMP get_StepResolution(float *pVal) { return CDXBaseNTo1::get_StepResolution(pVal); }
        
#define DECLARE_GET_DURATION()\
        STDMETHODIMP get_Duration(float *pVal) { return CDXBaseNTo1::get_Duration(pVal); }

#define DECLARE_PUT_DURATION()\
        STDMETHODIMP put_Duration(float newVal) { return CDXBaseNTo1::put_Duration(newVal); }
        
#define DECLARE_IDXEFFECT_METHODS(Caps)\
        DECLARE_GET_CAPABILITIES(Caps)\
        DECLARE_GET_PROGRESS()\
        DECLARE_PUT_PROGRESS()\
        DECLARE_GET_STEPRESOLUTION()\
        DECLARE_GET_DURATION()\
        DECLARE_PUT_DURATION()

//=== Global Data Declarations =====================================

//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxhelp3.h ===
// DXHELP3.cpp : Contains definitions of routines shared by multiple effects

#ifndef __DXHELP3_H_
#define __DXHELP3_H_

#include <d3d.h>
#include <d3drm.h>
#include <math.h>


#ifndef PI
#define PI 3.1415926538
#endif

/*******************
This class is used to rotate a set of points about an axis.  An example of
how this is used is in Explode.cpp.  Basically you set up the axis and the
angle with the Set() function. The angle is in radians, and the Axis given
MUST be normalized.  That is the magnitude of the vector must be one. Then
you call RotatePoint() for each point.
*******************/
class Rotate
{
public:
    Rotate(){ D3DVECTOR v; v.x = 1; v.y = 0; v.z = 0; Set(v, PI); }
    Rotate(D3DVECTOR NormalAxis, double Angle) { Set(NormalAxis, Angle); }

    D3DVECTOR RotatePoint(D3DVECTOR Org)
    {
	D3DVECTOR Result;

	Result.x = Org.x * m_d3dvctrXComponent.x + 
		   Org.y * m_d3dvctrXComponent.y + 
		   Org.z * m_d3dvctrXComponent.z;

	Result.y = Org.x * m_d3dvctrYComponent.x + 
		   Org.y * m_d3dvctrYComponent.y + 
		   Org.z * m_d3dvctrYComponent.z;

	Result.z = Org.x * m_d3dvctrZComponent.x + 
		   Org.y * m_d3dvctrZComponent.y + 
		   Org.z * m_d3dvctrZComponent.z;

	return Result;
    }

    void Set(D3DVECTOR d3dvtcrAxis, double dAngle);

private:
    D3DVECTOR m_d3dvctrXComponent, m_d3dvctrYComponent, m_d3dvctrZComponent;
};

/******************
Copy the input MeshBuilder to the Output MeshBuilder.  
But, create independent vertices for each face in the output
mesh.  That is no two faces share a single vertice.
******************/
HRESULT DecoupleVertices(IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			 IDirect3DRMMeshBuilder3* lpMeshBuilderIn);

/******************
For each MeshBuilder in lpMeshBuilderIn find the corresponding 
MeshBuilder in lpMeshBuilderOut and call (*lpCallBack)(lpThis, lpmbOutX, lpmbInX).
If there is no corresponding output mesh for the input mesh, create it.
*******************/
HRESULT TraverseSubMeshes(HRESULT (*lpCallBack)(void *lpThis,
						IDirect3DRMMeshBuilder3* lpOut,
						IDirect3DRMMeshBuilder3* lpIn),
			  void *lpThis, 
			  IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			  IDirect3DRMMeshBuilder3* lpMeshBuilderIn);

/***********************
Given three points, return the normal to the plane defined by these three points.
For a Right Handed system points A, B, and C should be in a CW order on the plane.
From CRC Standard Mathematical Tables 22nd Edition, page 380.  
Direction Numbers and Direction Cosines.
***********************/
inline D3DVECTOR ComputeNormal(D3DVECTOR d3dptA, D3DVECTOR d3dptB, D3DVECTOR d3dptC)
{
    const D3DVECTOR d3dptOne = d3dptB - d3dptA;
    const D3DVECTOR d3dptTwo = d3dptC - d3dptB;

    D3DVECTOR d3dptRetValue;
    d3dptRetValue.x = d3dptOne.y * d3dptTwo.z - d3dptOne.z * d3dptTwo.y;
    d3dptRetValue.y = d3dptOne.z * d3dptTwo.x - d3dptOne.x * d3dptTwo.z;
    d3dptRetValue.z = d3dptOne.x * d3dptTwo.y - d3dptOne.y * d3dptTwo.x;

    float Magnitude = (float)sqrt(d3dptRetValue.x * d3dptRetValue.x + 
                                  d3dptRetValue.y * d3dptRetValue.y + 
                                  d3dptRetValue.z * d3dptRetValue.z);

    // There's no good answer for how to get around this problem. The magnitude
    // here can be zero if the points given are not unique or are collinear. In
    // that case, there is no single normal, but rather there is a whole range of
    // them (either there are two unique points describing a line, or there is
    // only one describing a point).  We choose simply to return the un-normalized
    // vector, which is probably almost a zero vector.
    if (fabs(Magnitude) < 1.0e-5)
        return d3dptRetValue;
    else
        return d3dptRetValue/Magnitude;
}

float GetDlgItemFloat(HWND hDlg, int id);
BOOL SetDlgItemFloat( HWND hDlg, int id, float f );
double GetDlgItemDouble(HWND hDlg, int id);
BOOL SetDlgItemDouble( HWND hDlg, int id, double d );

#endif // __DXHELP3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxhelp3.cpp ===
// DXHELP3.cpp : Contains routines shared by multiple 3D effects
#include "dxhelp3.h"
#include <malloc.h>
#include <math.h>
#include <stdio.h>

void Rotate::Set(D3DVECTOR d3dvctrNormal, double dAngle)
{
#ifdef _DEBUG
    float NormalSum =   d3dvctrNormal.x * d3dvctrNormal.x + 
                        d3dvctrNormal.y * d3dvctrNormal.y + 
                        d3dvctrNormal.z * d3dvctrNormal.z;
    _ASSERT(NormalSum == 0.0f || (0.99f < NormalSum && NormalSum < 1.01f));
#endif

    // The following transformation matrix routines are from
    // Graphics Gems (the first one) page 466 (Converting 
    // between Matrix and Axis-Amount Representations)
    float s = (float)sin(dAngle), c = (float)cos(dAngle);
    float t = 1.0f - c;

    m_d3dvctrXComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.x + c;
    m_d3dvctrXComponent.y = t * d3dvctrNormal.x * d3dvctrNormal.y - s * d3dvctrNormal.z;
    m_d3dvctrXComponent.z = t * d3dvctrNormal.x * d3dvctrNormal.z + s * d3dvctrNormal.y;

    m_d3dvctrYComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.y + s * d3dvctrNormal.z;
    m_d3dvctrYComponent.y = t * d3dvctrNormal.y * d3dvctrNormal.y + c;
    m_d3dvctrYComponent.z = t * d3dvctrNormal.y * d3dvctrNormal.z - s * d3dvctrNormal.x;

    m_d3dvctrZComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.z - s * d3dvctrNormal.y;
    m_d3dvctrZComponent.y = t * d3dvctrNormal.y * d3dvctrNormal.z + s * d3dvctrNormal.x;
    m_d3dvctrZComponent.z = t * d3dvctrNormal.z * d3dvctrNormal.z + c;
}

static HRESULT DecoupleOneMeshBuilder(void *lpThis /* Ignored */, 
				      IDirect3DRMMeshBuilder3 *lpMeshBuilderOut,
				      IDirect3DRMMeshBuilder3 *lpMeshBuilderIn)
{
    HRESULT hr = lpMeshBuilderOut->SetAppData(lpMeshBuilderIn->GetAppData());

    if(FAILED(hr))
    {
	return hr;
    }

    const int ciOutputFaceCount = lpMeshBuilderOut->GetFaceCount();
    const int ciMaxFaceCount = lpMeshBuilderIn->GetFaceCount();
    if(!ciMaxFaceCount)
    {
	return hr;
    }
    CComPtr<IDirect3DRMFaceArray> cpD3DRMFaceArray;

    hr = lpMeshBuilderIn->GetFaces(&cpD3DRMFaceArray);
    if(hr != D3DRM_OK)
    {
	return hr;
    }

    D3DVECTOR *lpvctrPosition = NULL;
    D3DVECTOR *lpvctrFaceNormals = NULL;
    DWORD dwMaxVertexCount = 0;

    // By reserving space we speed things up by a factor of 20 or 30 X!

    DWORD dwTotalVertexCount = lpMeshBuilderIn->GetVertexCount();
    _ASSERT(dwTotalVertexCount >= 3);
    if (dwTotalVertexCount/ciMaxFaceCount < 3)
    {
	dwTotalVertexCount = ciMaxFaceCount * 3;  // There will be at least 3 vertices per face.
    }
    hr = lpMeshBuilderOut->ReserveSpace(dwTotalVertexCount, dwTotalVertexCount, ciMaxFaceCount);

    if(hr != D3DRM_OK)
    {
	return hr;
    }

    // Need to have seperate vertices for each face in the output mesh.
    int iFaceIndex = 0;
    do
    {
	CComPtr<IDirect3DRMFace> cpd3dInFaceTemp;
	CComPtr<IDirect3DRMFace2> cpd3dOutFace;

        if(FAILED(hr = cpD3DRMFaceArray->GetElement((DWORD)iFaceIndex, &cpd3dInFaceTemp)))
        {
            break;
        }
        _ASSERT(cpd3dInFaceTemp);

	CComPtr<IDirect3DRMFace2> cpd3dInFace;
	if(FAILED(hr = cpd3dInFaceTemp->QueryInterface(
		IID_IDirect3DRMFace2, (void **)&cpd3dInFace)))
	{
	    break;
	}

        DWORD dwVertexCount;

        cpd3dInFace->GetVertices(&dwVertexCount, NULL, NULL);
        _ASSERT(dwVertexCount >= 3);

        if(dwVertexCount > dwMaxVertexCount)
        {
            dwMaxVertexCount = dwVertexCount;

	    D3DVECTOR *lpTemp = lpvctrPosition;
            D3DVECTOR *lpNormalTemp = lpvctrFaceNormals;

	    lpvctrPosition = (D3DVECTOR *)realloc(lpvctrPosition, dwMaxVertexCount * sizeof (*lpvctrPosition));
	    lpvctrFaceNormals = (D3DVECTOR *)realloc(lpvctrFaceNormals, dwMaxVertexCount * sizeof (*lpvctrFaceNormals));

	    if(!lpvctrPosition || !lpvctrFaceNormals)
	    {
		free(lpTemp);
		free(lpNormalTemp);
		hr = E_OUTOFMEMORY;
		break;
	    }

	    // We may have a problem in the amount of space reserved in the output meshbuilder.
	    if((ciMaxFaceCount -  iFaceIndex) * dwMaxVertexCount > dwTotalVertexCount)
	    {
		dwTotalVertexCount = (ciMaxFaceCount -  iFaceIndex) * dwMaxVertexCount;
		hr = lpMeshBuilderOut->ReserveSpace(dwTotalVertexCount, dwTotalVertexCount, ciMaxFaceCount - iFaceIndex);

		if(hr != D3DRM_OK)
		{
		    break;
		}
	    }
        }

        if(FAILED(hr = cpd3dInFace->GetVertices(&dwVertexCount, lpvctrPosition, lpvctrFaceNormals)) ||
	   FAILED(hr = lpMeshBuilderOut->CreateFace(&cpd3dOutFace)) ||
	   FAILED(hr = cpd3dOutFace->SetAppData(cpd3dInFace->GetAppData())))
        {
            break;
        }


	CComPtr<IDirect3DRMMaterial2> cpMaterial;
        CComPtr<IDirect3DRMTexture3> cpTexture;
        BOOL bU, bV;

        if(hr != D3DRM_OK ||
          (hr = cpd3dInFace->GetMaterial(&cpMaterial)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetMaterial(cpMaterial)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetColor(cpd3dInFace->GetColor())) != D3DRM_OK ||
          (hr = cpd3dInFace->GetTexture(&cpTexture)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetTexture(cpTexture)) != D3DRM_OK ||
          (hr = cpd3dInFace->GetTextureTopology(&bU, &bV)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetTextureTopology(bU, bV)) != D3DRM_OK)
        {
            break;
        }

        DWORD dwInFaceVertex = 0;
        do
        {
            int iVIndex = lpMeshBuilderOut->AddVertex(lpvctrPosition[dwInFaceVertex].x, 
					 lpvctrPosition[dwInFaceVertex].y, 
					 lpvctrPosition[dwInFaceVertex].z);
            int iNIndex = lpMeshBuilderOut->AddNormal(lpvctrFaceNormals[dwInFaceVertex].x, 
					 lpvctrFaceNormals[dwInFaceVertex].y, 
					 lpvctrFaceNormals[dwInFaceVertex].z);

            D3DVALUE U, V;

            if(FAILED(hr = cpd3dOutFace->AddVertexAndNormalIndexed(iVIndex, iNIndex)) ||
               FAILED(hr = cpd3dInFace->GetTextureCoordinates(dwInFaceVertex, &U, &V)) ||
               FAILED(hr = cpd3dOutFace->SetTextureCoordinates(dwInFaceVertex, U, V)))
            {
                break;
            }
        } while (++dwInFaceVertex < dwVertexCount);
	dwTotalVertexCount -= dwVertexCount;
    } while (hr == D3DRM_OK && ++iFaceIndex < ciMaxFaceCount);

    free(lpvctrPosition);
    free(lpvctrFaceNormals);

    return hr;
}

HRESULT TraverseSubMeshes(  HRESULT (*lpCallBack)(void *lpThis,
						IDirect3DRMMeshBuilder3* lpOut,
						IDirect3DRMMeshBuilder3* lpIn),
			    void *lpThis, 
			    IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			    IDirect3DRMMeshBuilder3* lpMeshBuilderIn)
{
    HRESULT hr;

    _ASSERT(lpCallBack);
    if(FAILED(hr = (*lpCallBack)(lpThis, lpMeshBuilderOut, lpMeshBuilderIn)))
	return hr;

    DWORD dwInSubMeshCount;
    hr = lpMeshBuilderIn->GetSubMeshes(&dwInSubMeshCount, NULL);

    if(FAILED(hr) || dwInSubMeshCount == 0)
	return hr;

    DWORD dwOutSubMeshCount;
    if(FAILED(hr = lpMeshBuilderOut->GetSubMeshes(&dwOutSubMeshCount, NULL)))
    {
	return hr;
    }

    const BOOL bCreateOutMeshes = (dwOutSubMeshCount == 0);
    _ASSERT(bCreateOutMeshes || dwInSubMeshCount == dwOutSubMeshCount);

    LPUNKNOWN *lplpunkInSubMeshes =
	(LPUNKNOWN *)malloc(dwInSubMeshCount * sizeof(*lplpunkInSubMeshes));

    LPUNKNOWN *lplpunkOutSubMeshes = (bCreateOutMeshes? NULL:
	(LPUNKNOWN *)malloc(dwOutSubMeshCount * sizeof(*lplpunkOutSubMeshes)));

    if(!lplpunkInSubMeshes || !bCreateOutMeshes && !lplpunkOutSubMeshes)
    {
	return E_OUTOFMEMORY;
    }

    if(FAILED(hr = lpMeshBuilderIn->GetSubMeshes(&dwInSubMeshCount, lplpunkInSubMeshes)) ||
	!bCreateOutMeshes && 
	FAILED(hr = lpMeshBuilderOut->GetSubMeshes(&dwOutSubMeshCount, lplpunkOutSubMeshes)))
    {
	return hr;
    }

    CComPtr<IDirect3DRMMeshBuilder3> cpInSubMesh, cpOutSubMesh;

    DWORD dwSubMesh;
    for(dwSubMesh = 0; SUCCEEDED(hr) && dwSubMesh < dwInSubMeshCount; dwSubMesh++)
    {
	cpInSubMesh = NULL;
	cpOutSubMesh = NULL;

	// Get the current input submesh.
	hr = lplpunkInSubMeshes[dwSubMesh]->QueryInterface(IID_IDirect3DRMMeshBuilder3, 
		(void **)&cpInSubMesh);

	if(FAILED(hr))
	    break;

	if(bCreateOutMeshes)
	{
	    // Create a new submesh in the output mesh to match the input submesh.	    
	    LPUNKNOWN lpunkSubmesh;

	    if(FAILED(hr = lpMeshBuilderOut->CreateSubMesh(&lpunkSubmesh)))
		break;

	    hr = lpunkSubmesh->QueryInterface(IID_IDirect3DRMMeshBuilder3,
							(void **)&cpOutSubMesh);
	    lpunkSubmesh->Release();
	}
	else
	{
	    // Get the current output submesh.
	    hr = lplpunkOutSubMeshes[dwSubMesh]->QueryInterface(IID_IDirect3DRMMeshBuilder3,
		    (void **)&cpOutSubMesh);
	}
	if(FAILED(hr))
	    break;

	// Do all the children for these two MeshBuilders.
	hr = TraverseSubMeshes(lpCallBack, lpThis, cpOutSubMesh, cpInSubMesh);
    }

    for(dwSubMesh = 0; dwSubMesh < dwInSubMeshCount; dwSubMesh++)
    {
	lplpunkInSubMeshes[dwSubMesh]->Release();

	if(lplpunkOutSubMeshes)
	{
	    lplpunkOutSubMeshes[dwSubMesh]->Release();
	}
    }

    free(lplpunkInSubMeshes);
    free(lplpunkOutSubMeshes);

    return hr;
}

HRESULT DecoupleVertices(IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			 IDirect3DRMMeshBuilder3* lpMeshBuilderIn)
{
    DWORD dwSubMeshCount;

    HRESULT hr = lpMeshBuilderOut->GetSubMeshes(&dwSubMeshCount, NULL);

    if(FAILED(hr))
	return hr;

    if(lpMeshBuilderOut->GetFaceCount() || dwSubMeshCount)
    {
	if(FAILED(hr = lpMeshBuilderOut->Empty(0)))
	    return hr;
    }
    hr = TraverseSubMeshes(DecoupleOneMeshBuilder, NULL,
			    lpMeshBuilderOut, lpMeshBuilderIn);
    return hr;
}

float GetDlgItemFloat(HWND hDlg, int id)
{
    TCHAR *pEnd;
    TCHAR szItemText[20];
    GetDlgItemText(hDlg, id, szItemText, 20);
    return (float)strtod(szItemText, &pEnd);
}

BOOL SetDlgItemFloat( HWND hDlg, int id, float f )
{
    TCHAR szItem[20];
     _stprintf( szItem, _T("%.2f"), f );
    return SetDlgItemText( hDlg, id, szItem );
}

double GetDlgItemDouble(HWND hDlg, int id)
{
    TCHAR *pEnd;
    TCHAR szItemText[20];
    GetDlgItemText(hDlg, id, szItemText, 20);
    return strtod(szItemText, &pEnd);
}

BOOL SetDlgItemDouble( HWND hDlg, int id, double d )
{
    TCHAR szItem[20];
     _stprintf( szItem, _T("%.2d"), d );
    return SetDlgItemText( hDlg, id, szItem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxhelper.h ===
/*******************************************************************************
* DXHelper.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/11/95
*  Copyright (C) 1995 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXHelper_h
#define DXHelper_h

#include <DXTError.h>
#include <DXBounds.h>
#include <DXTrans.h>

#include <limits.h>
#include <crtdbg.h>
#include <malloc.h>
#include <math.h>

//=== Constants ==============================================================

#define DX_MMX_COUNT_CUTOFF 16

//=== Class, Enum, Struct and Union Declarations =============================

/*** DXLIMAPINFO
*   This structure is used by the array linear interpolation and image
*   filtering routines.
*/
typedef struct DXLIMAPINFO
{
    float   IndexFrac;
    USHORT  Index;
    BYTE    Weight;
} DXLIMAPINFO;

//
//  Declare this class as a global to use for determining when to call MMX optimized
//  code.  You can use MinMMXOverCount to determine if MMX instructions are present.
//  Typically, you would only want to use MMX instructions when you have a reasonably
//  large number of pixels to work on.  In this case your code can always be coded like
//  this:
//
//  if (CountOfPixelsToDo >= g_MMXInfo.MinMMXOverCount())
//  {
//      Do MMX Stuff
//  } else {
//      Do integer / float based stuff
//  }    
//  
//  If you code your MMX sequences like this, you will not have to use a special test
//  for the presence of MMX since the MinMMXOverCount will be set to 0xFFFFFFFF if there
//  is no MMX present on the processor.
//
//  You do not need to use this unless your module needs to conditionally execute MMX vs
//  non-MMX code.  If you only call the helper functions provided by DXTrans.Dll, such as
//  DXOverArrayMMX, you do NOT need this test.  You can always call these functions and they
//  will use the MMX code path only when MMX instructions are present.
//
class CDXMMXInfo
{
    ULONG m_MinMMXOver;
public:
    CDXMMXInfo()
    {
#ifndef _X86_
        m_MinMMXOver = 0xFFFFFFFF;
#else
        m_MinMMXOver = DX_MMX_COUNT_CUTOFF;
        __try
        {
            __asm
            {
                //--- Try the MMX exit multi-media state instruction
                EMMS;
            }
        }
        __except( GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION )
        {
            //--- MMX instructions not available
            m_MinMMXOver = 0xFFFFFFFF;
        }
#endif
    }
    inline ULONG MinMMXOverCount() { return m_MinMMXOver; }
};



//=== Function Prototypes ==========================================
_DXTRANS_IMPL_EXT void WINAPI
    DXLinearInterpolateArray( const DXBASESAMPLE* pSamps, DXLIMAPINFO* pMapInfo,
                              DXBASESAMPLE* pResults, DWORD dwResultCount );
_DXTRANS_IMPL_EXT void WINAPI
    DXLinearInterpolateArray( const DXBASESAMPLE* pSamps, PUSHORT pIndexes,
                              PBYTE pWeights, DXBASESAMPLE* pResults,
                              DWORD dwResultCount );

//
//  DXOverArray
//
//  Composits an array of source samples over the samples in the pDest buffer.
//
//  pDest   - Pointer to the samples that will be modified by compositing the pSrc
//            samples over the pDest samples.
//  pSrc    - The samples to composit over the pDest samples
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXOverArray(DXPMSAMPLE* pDest, const DXPMSAMPLE* pSrc, ULONG nCount);

//
//  DXOverArrayMMX
//
//  Identical to DXOverArray except that the MMX instruction set will be used for
//  large arrays of samples.  If the CPU does not support MMX, you may still call
//  this function, which will perform the same operation without the use of the MMX
//  unit.
//
//  Note that it is LESS EFFICIENT to use this function if the majority of the pixels
//  in the pSrc buffer are either clear (alpha 0) or opaque (alpha 0xFF).  This is 
//  because the MMX code must process every pixel and can not special case clear or
//  opaque pixels.  If there are a large number of translucent pixels then this function
//  is much more efficent than DXOverArray.
//
//  pDest   - Pointer to the samples that will be modified by compositing the pSrc
//            samples over the pDest samples.
//  pSrc    - The samples to composit over the pDest samples
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXOverArrayMMX(DXPMSAMPLE* pDest, const DXPMSAMPLE* pSrc, ULONG nCount);

//
//  DXConstOverArray
//
//  Composits a single color over an array of samples.
//
//  pDest   - Pointer to the samples that will be modified by compositing the color (val)
//            over the pDest samples.
//  val     - The premultiplied color value to composit over the pDest array.
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXConstOverArray(DXPMSAMPLE* pDest, const DXPMSAMPLE & val, ULONG nCount);

//
//  DXConstOverArray
//
//  Composits a single color over an array of samples.
//
//  pDest   - Pointer to the samples that will be modified by compositing the samples
//            in the buffer over the color (val).
//  val     - The premultiplied color value to composit under the pDest array.
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXConstUnderArray(DXPMSAMPLE* pDest, const DXPMSAMPLE & val, ULONG nCount);

//===================================================================================
//
//  Dithering Helpers
//
//  Image transforms are sometimes asked to dither their output.  This helper function
//  should be used by all image transforms to enusure a consistant dither pattern.
//
//  DXDitherArray is used to dither pixels prior to writing them to a DXSurface.
//  The caller must fill in the DXDITHERDESC structure, setting X and Y to the
//  output surface X,Y coordinates that the pixels will be placed in.  The samples
//  will be modified in place.
//
//  Once the samples have been dithered, they should be written to or composited with
//  the destination surface.
//
#define DX_DITHER_HEIGHT    4       // The dither pattern is 4x4 pixels
#define DX_DITHER_WIDTH     4

typedef struct DXDITHERDESC
{
    DXBASESAMPLE *      pSamples;       // Pointer to the 32-bit samples to dither
    ULONG               cSamples;       // Count of number of samples in pSamples buffer
    ULONG               x;              // X coordinate of the output surface
    ULONG               y;              // Y coordinate of the output surface
    DXSAMPLEFORMATENUM  DestSurfaceFmt; // Pixel format of the output surface
} DXDITHERDESC;

_DXTRANS_IMPL_EXT void WINAPI
    DXDitherArray(const DXDITHERDESC *pDitherDesc);

//=== Enumerated Set Definitions =============================================


//=== Function Type Definitions ==============================================


//=== Class, Struct and Union Definitions ====================================


//=== Inline Functions =======================================================

//===================================================================================
//
//  Memory allocation helpers.
//
//  These macros are used to allocate arrays of samples from the stack (using _alloca)
//  and cast them to the appropriate type.  The ulNumSamples parameter is the count
//  of samples required.
//
#define DXBASESAMPLE_Alloca( ulNumSamples ) \
    (DXBASESAMPLE *)_alloca( (ulNumSamples) * sizeof( DXBASESAMPLE ) )

#define DXSAMPLE_Alloca( ulNumSamples ) \
    (DXSAMPLE *)_alloca( (ulNumSamples) * sizeof( DXSAMPLE ) )

#define DXPMSAMPLE_Alloca( ulNumSamples ) \
    (DXPMSAMPLE *)_alloca( (ulNumSamples) * sizeof( DXPMSAMPLE ) )

//===================================================================================
//
//  Critical section helpers.
//
//  These C++ classes, CDXAutoObjectLock and CDXAutoCritSecLock are used within functions
//  to automatically claim critical sections upon constuction, and the critical section
//  will be released when the object is destroyed (goes out of scope).
//
//  The macros DXAUTO_OBJ_LOCK and DX_AUTO_SEC_LOCK(s) are normally used at the beginning
//  of a function that requires a critical section.  Any exit from the scope in which the
//  auto-lock was taken will automatically release the lock.
//

#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used
class CDXAutoObjectLock
{
  protected:
    CComObjectRootEx<CComMultiThreadModel>* m_pObject;

  public:
    CDXAutoObjectLock(CComObjectRootEx<CComMultiThreadModel> * const pobject)
    {
        m_pObject = pobject;
        m_pObject->Lock();
    };

    ~CDXAutoObjectLock() {
        m_pObject->Unlock();
    };
};

#define DXAUTO_OBJ_LOCK CDXAutoObjectLock lck(this);
#define DXAUTO_OBJ_LOCK_( t ) CDXAutoObjectLock lck(t);

class CDXAutoCritSecLock
{
  protected:
    CComAutoCriticalSection* m_pSec;

  public:
    CDXAutoCritSecLock(CComAutoCriticalSection* pSec)
    {
        m_pSec = pSec;
        m_pSec->Lock();
    };

    ~CDXAutoCritSecLock()
    {
        m_pSec->Unlock();
    };
};

#define DXAUTO_SEC_LOCK( s ) CDXAutoCritSecLock lck(s);
#endif  // __ATLCOM_H__

//--- This function is used to compute the coefficient for a gaussian filter coordinate
inline float DXGaussCoeff( double x, double y, double Sigma )
{
    double TwoSigmaSq = 2 * ( Sigma * Sigma );
    return (float)(exp( ( -(x*x + y*y) / TwoSigmaSq  ) ) /
                        ( 3.1415927 * TwoSigmaSq ));
}

//--- This function is used to initialize a gaussian convolution filter
inline void DXInitGaussianFilter( float* pFilter, ULONG Width, ULONG Height, double Sigma )
{
    int i, NumCoeff = Width * Height;
    float  val, CoeffAdjust, FilterSum = 0.;
    double x, y;
    double LeftX   = -(double)(Width / 2);
    double RightX  =   Width - LeftX;
    double TopY    = -(double)(Height / 2);
    double BottomY =   Height - TopY;

    for( y = -TopY; y <= BottomY; y += 1. )
    {
        for( x = -LeftX; x <= RightX; x += 1. )
        {
            val = DXGaussCoeff( x, y, Sigma );
            pFilter[i++] = val;
        }
    }

    //--- Normalize filter (make it sum to 1.0)
    for( i = 0; i < NumCoeff; ++i ) FilterSum += pFilter[i];

    if( FilterSum < 1. )
    {
        CoeffAdjust = 1.f / FilterSum;
        for( i = 0; i < NumCoeff; ++i )
        {
            pFilter[i] *= CoeffAdjust;
        }
    }

} /* DXInitGaussianFilter*/

//
//  DXConvertToGray
//
//  Translates a color sample to a gray scale sample
//
//  Sample  - The sample to convert to gray scale.
//  Return value is the gray scale sample.
//
inline DXBASESAMPLE DXConvertToGray( DXBASESAMPLE Sample )
{
    DWORD v = Sample;
    DWORD r = (BYTE)(v >> 16);
    DWORD g = (BYTE)(v >> 8);
    DWORD b = (BYTE)(v);
    DWORD sat = (r*306 + g*601 + b*117) / 1024;
    v &= 0xFF000000;
    v |= (sat << 16) | (sat << 8) | sat;
    return v;
} /* DXConvertToGray */

//--- This returns into the destination the value of the source
//  sample scaled by its own alpha (producing a premultiplied alpha sample)
//
inline DXPMSAMPLE DXPreMultSample(const DXSAMPLE & Src)
{
    if(Src.Alpha == 255 )
    {
        return (DWORD)Src;
    }
    else if(Src.Alpha == 0 )
    {
        return 0;
    }
    else
    {
        unsigned t1, t2;
        t1 = (Src & 0x00ff00ff) * Src.Alpha + 0x00800080;
        t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

        t2 = (((Src >> 8) & 0x000000ff) | 0x01000000) * Src.Alpha + 0x00800080;
        t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;
        return (t1 | t2);
    }
} /* DXPreMultSample */

inline DXPMSAMPLE * DXPreMultArray(DXSAMPLE *pBuffer, ULONG cSamples)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        BYTE SrcAlpha = pBuffer[i].Alpha;
        if (SrcAlpha != 0xFF)
        {
            if (SrcAlpha == 0)
            {
                pBuffer[i] = 0;
            }
            else
            {
                DWORD S = pBuffer[i];
                DWORD t1 = (S & 0x00ff00ff) * SrcAlpha + 0x00800080;
                t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                DWORD t2 = (((S >> 8) & 0x000000ff) | 0x01000000) * SrcAlpha + 0x00800080;
                t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

                pBuffer[i] = (t1 | t2);
            }
        }
    }
    return (DXPMSAMPLE *)pBuffer;
}


inline DXSAMPLE DXUnPreMultSample(const DXPMSAMPLE & Src)
{
    if(Src.Alpha == 255 || Src.Alpha == 0)
    {
        return (DWORD)Src;
    }
    else
    {
        DXSAMPLE Dst;
        Dst.Blue  = (BYTE)((Src.Blue  * 255) / Src.Alpha);
        Dst.Green = (BYTE)((Src.Green * 255) / Src.Alpha);
        Dst.Red   = (BYTE)((Src.Red   * 255) / Src.Alpha);
        Dst.Alpha = Src.Alpha;
        return Dst;
    }
} /* DXUnPreMultSample */

inline DXSAMPLE * DXUnPreMultArray(DXPMSAMPLE *pBuffer, ULONG cSamples)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        BYTE SrcAlpha = pBuffer[i].Alpha;
        if (SrcAlpha != 0xFF && SrcAlpha != 0)
        {
            pBuffer[i].Blue  = (BYTE)((pBuffer[i].Blue  * 255) / SrcAlpha);
            pBuffer[i].Green = (BYTE)((pBuffer[i].Green * 255) / SrcAlpha);
            pBuffer[i].Red   = (BYTE)((pBuffer[i].Red   * 255) / SrcAlpha);
        }
    }
    return (DXSAMPLE *)pBuffer;
}


//
//  This returns the result of 255-Alpha which is computed by doing a NOT
//
inline BYTE DXInvertAlpha( BYTE Alpha ) { return (BYTE)~Alpha; }

inline DWORD DXScaleSample( DWORD Src, ULONG beta )
{
    ULONG t1, t2;

    t1 = (Src & 0x00ff00ff) * beta + 0x00800080;
    t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

    t2 = ((Src >> 8) & 0x00ff00ff) * beta + 0x00800080;
    t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

    return (DWORD)(t1 | t2);
}


inline DWORD DXScaleSamplePercent( DWORD Src, float Percent )
{
    if (Percent > (254.0f / 255.0f)) {
        return Src;
    }
    else
    {
        return DXScaleSample(Src, (BYTE)(Percent * 255));
    }
}

inline void DXCompositeOver(DXPMSAMPLE & Dst, const DXPMSAMPLE & Src)
{
    if (Src.Alpha)
    {
        ULONG Beta = DXInvertAlpha(Src.Alpha);
        if (Beta)
        {
            Dst = Src + DXScaleSample(Dst, Beta);
        }
        else
        {
            Dst = Src;
        }
    }
}


inline DXPMSAMPLE DXCompositeUnder(DXPMSAMPLE Dst, DXPMSAMPLE Src )
{
    return Dst + DXScaleSample(Src, DXInvertAlpha(Dst.Alpha));
}


inline DXBASESAMPLE DXApplyLookupTable(const DXBASESAMPLE Src, const BYTE * pTable)
{
    DXBASESAMPLE Dest;
    Dest.Blue   = pTable[Src.Blue];
    Dest.Green  = pTable[Src.Green];
    Dest.Red    = pTable[Src.Red];
    Dest.Alpha  = pTable[Src.Alpha];
    return Dest;
}

inline DXBASESAMPLE * DXApplyLookupTableArray(DXBASESAMPLE *pBuffer, ULONG cSamples, const BYTE * pTable)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        DWORD v = pBuffer[i];
        DWORD a = pTable[v >> 24];
        DWORD r = pTable[(BYTE)(v >> 16)];
        DWORD g = pTable[(BYTE)(v >> 8)];
        DWORD b = pTable[(BYTE)v];
        pBuffer[i] = (a << 24) | (r << 16) | (g << 8) | b;
    }
    return pBuffer;
}

inline DXBASESAMPLE * DXApplyColorChannelLookupArray(DXBASESAMPLE *pBuffer,
                                                     ULONG cSamples,
                                                     const BYTE * pAlphaTable,
                                                     const BYTE * pRedTable,
                                                     const BYTE * pGreenTable,
                                                     const BYTE * pBlueTable)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        pBuffer[i].Blue   = pBlueTable[pBuffer[i].Blue];
        pBuffer[i].Green  = pGreenTable[pBuffer[i].Green];
        pBuffer[i].Red    = pRedTable[pBuffer[i].Red];
        pBuffer[i].Alpha  = pAlphaTable[pBuffer[i].Alpha];
    }
    return pBuffer;
}


//
//  CDXScale helper class
//
//  This class uses a pre-computed lookup table to scale samples.  For scaling large
//  arrays of samples to a constant scale, this is much faster than using even MMX
//  instructions.  This class is usually declared as a member of another class and
//  is most often used to apply a global opacity to a set of samples.
//
//  When using this class, you must always check for the two special cases of clear
//  and opaque before calling any of the scaling member functions.  Do this by using
//  the ScaleType() inline function.  Your code should look somthing like this:
//
//  if (ScaleType() == DXRUNTYPE_CLEAR)
//      Do whatever you do for a 0 alpha set of samples -- usually just ignore them
//  else if (ScaleType() == DXRUNTYPE_OPAQUE)
//      Do whatever you would do for a non-scaled set of samples
//  else
//      Scale the samples by using ScaleSample or one of the ScaleArray members
//
//  If you call any of the scaling members when the ScaleType() is either clear or
//  opaque, you will GP fault becuase the lookup table will not be allocated.
//
//  The scale can be set using either a floating point number between 0 and 1 using:
//      CDXScale::SetScale / CDXScale::GetScale
//  or you can use a byte integer value by using:
//      CDXScale::SetScaleAlphaValue / CDXScale::GetScaleAlphaValue
//
class CDXScale
{
private:
    float       m_Scale;
    BYTE        m_AlphaScale;
    BYTE        *m_pTable;

HRESULT InternalSetScale(BYTE Scale)
{
    if (m_AlphaScale == Scale) return S_OK;
    if (Scale == 0 || Scale == 255) 
    {
        delete m_pTable;
        m_pTable = NULL;
    }
    else
    {
        if(!m_pTable)
        {
            m_pTable = new BYTE[256];
            if(!m_pTable )
            {
                return E_OUTOFMEMORY;
            }
        }
        for (int i = 0; i < 256; ++i )
        {
            m_pTable[i] = (BYTE)((i * Scale) / 255);
        }
    }
    m_AlphaScale = Scale;
    return S_OK;
}
public:
    CDXScale() : 
      m_Scale(1.0f),
      m_AlphaScale(0xFF),
      m_pTable(NULL)
      {}
    ~CDXScale()
    {
        delete m_pTable;
    }
    DXRUNTYPE ScaleType() 
    {
        if (m_AlphaScale == 0) return DXRUNTYPE_CLEAR;
        if (m_AlphaScale == 0xFF) return DXRUNTYPE_OPAQUE;
        return DXRUNTYPE_TRANS;
    }
    HRESULT SetScaleAlphaValue(BYTE Alpha)
    {
        HRESULT hr = InternalSetScale(Alpha);
        if (SUCCEEDED(hr))
        {
            m_Scale = ((float)Alpha) / 255.0f;
        }
        return hr;
    }
    BYTE GetScaleAlphaValue(void)
    {
        return m_AlphaScale;
    }
    HRESULT SetScale(float Scale)
    {
        HRESULT hr = S_OK;
        if(( Scale < 0.0f ) || ( Scale > 1.0f ) )
        {
            hr = E_INVALIDARG;
        }
        else
        {
            ULONG IntScale = (ULONG)(Scale * 256.0f);     // Round up alpha (.9999 = 255 = Solid)
            if (IntScale > 255) 
            {
                IntScale = 255;
            }
            hr = SetScaleAlphaValue((BYTE)IntScale);
            if (SUCCEEDED(hr))
            {
                m_Scale = Scale;
            }
        }
        return hr;
    }
    float GetScale() const
    {
        return m_Scale;
    }
    DXRUNTYPE ScaleType() const
    {
        return (m_pTable ? DXRUNTYPE_TRANS : (m_AlphaScale ? DXRUNTYPE_OPAQUE : DXRUNTYPE_CLEAR));
    }
    DWORD ScaleSample(const DWORD s) const
    {
        return DXApplyLookupTable((DXBASESAMPLE)s, m_pTable);
    }
    DXBASESAMPLE * ScaleBaseArray(DXBASESAMPLE * pBuffer, ULONG cSamples) const
    {
        return DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXPMSAMPLE * ScalePremultArray(DXPMSAMPLE * pBuffer, ULONG cSamples) const
    {
        return (DXPMSAMPLE *)DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXSAMPLE * ScaleArray(DXSAMPLE * pBuffer, ULONG cSamples) const
    {
        return (DXSAMPLE *)DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXSAMPLE * ScaleArrayAlphaOnly(DXSAMPLE *pBuffer, ULONG cSamples) const
    {
        const BYTE *pTable = m_pTable;
        for (ULONG i = 0; i < cSamples; i++)
        {
            pBuffer[i].Alpha  = pTable[pBuffer[i].Alpha];
        }
        return pBuffer;
    }
};

inline DWORD DXWeightedAverage( DXBASESAMPLE S1, DXBASESAMPLE S2, ULONG Wgt )
{
    _ASSERT( Wgt < 256 );
    ULONG t1, t2;
    ULONG InvWgt = Wgt ^ 0xFF;

    t1  = (((S1 & 0x00ff00ff) * Wgt) + ((S2 & 0x00ff00ff) * InvWgt )) + 0x00800080;
    t1  = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

    t2  = ((((S1 >> 8) & 0x00ff00ff) * Wgt) + (((S2 >> 8) & 0x00ff00ff) * InvWgt )) + 0x00800080;
    t2  = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

    return (t1 | t2);
} /* DXWeightedAverage */

inline void DXWeightedAverageArray( DXBASESAMPLE* pS1, DXBASESAMPLE* pS2, ULONG Wgt,
                                    DXBASESAMPLE* pResults, DWORD dwCount )
{
    _ASSERT( pS1 && pS2 && pResults && dwCount );
    for( DWORD i = 0; i < dwCount; ++i )
    {
        pResults[i] = DXWeightedAverage( pS1[i], pS2[i], Wgt );
    }
} /* DXWeightedAverageArray */

inline void DXWeightedAverageArrayOver( DXPMSAMPLE* pS1, DXPMSAMPLE* pS2, ULONG Wgt,
                                        DXPMSAMPLE* pResults, DWORD dwCount )
{
    _ASSERT( pS1 && pS2 && pResults && dwCount );
    DWORD i;

    if( Wgt == 255 )
    {
        for( i = 0; i < dwCount; ++i )
        {
            DXCompositeOver( pResults[i], pS1[i] );
        }
    }
    else
    {
        for( i = 0; i < dwCount; ++i )
        {
            DXPMSAMPLE Avg = DXWeightedAverage( (DXBASESAMPLE)pS1[i],
                                                (DXBASESAMPLE)pS2[i], Wgt );
            DXCompositeOver( pResults[i], Avg );
        }
    }

} /* DXWeightedAverageArrayOver */

inline void DXScalePremultArray(DXPMSAMPLE *pBuffer, ULONG cSamples, BYTE Weight)
{
    for (DXPMSAMPLE *pBuffLimit = pBuffer + cSamples; pBuffer < pBuffLimit; pBuffer++)
    {
        *pBuffer = DXScaleSample(*pBuffer, Weight);
    }
}



//
//
inline HRESULT DXClipToOutputWithPlacement(CDXDBnds & LogicalOutBnds, const CDXDBnds * pClipBnds, CDXDBnds & PhysicalOutBnds, const CDXDVec *pPlacement)
{
    if(pClipBnds && (!LogicalOutBnds.IntersectBounds(*pClipBnds)))
    {
        return S_FALSE;    // no intersect, we're done
    }
    else
    {
        CDXDVec vClipPos(false);
        LogicalOutBnds.GetMinVector( vClipPos );
        if (pPlacement)
        {
            vClipPos -= *pPlacement;
        }
        PhysicalOutBnds += vClipPos;
        if (!LogicalOutBnds.IntersectBounds(PhysicalOutBnds))
        {
            return S_FALSE;
        }
        PhysicalOutBnds = LogicalOutBnds;
        PhysicalOutBnds -= vClipPos;
    }
    return S_OK;
}



//
//  Helper for converting a color ref to a DXSAMPLE
//
inline DWORD DXSampleFromColorRef(COLORREF cr)
{
    DXSAMPLE Samp(0xFF, GetRValue(cr), GetGValue(cr), GetBValue(cr));
    return Samp;
}

//
//  Fill an entire surface with a color
//
inline HRESULT DXFillSurface( IDXSurface *pSurface, DXPMSAMPLE Color,
                              BOOL bDoOver = FALSE, ULONG ulTimeOut = 10000 )
{
    IDXARGBReadWritePtr * pPtr;
    HRESULT hr = pSurface->LockSurface( NULL, ulTimeOut, DXLOCKF_READWRITE, 
                                        IID_IDXARGBReadWritePtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        pPtr->FillRect(NULL, Color, bDoOver);
        pPtr->Release();
    }
    return hr;
} /* DXFillSurface */

//
//  Fill a specified sub-rectangle of a surface with a color.
//
inline HRESULT DXFillSurfaceRect( IDXSurface *pSurface, RECT & rect, DXPMSAMPLE Color,
                                  BOOL bDoOver = FALSE, ULONG ulTimeOut = 10000 )
{
    CDXDBnds bnds(rect);
    IDXARGBReadWritePtr * pPtr;
    HRESULT hr = pSurface->LockSurface( &bnds, ulTimeOut, DXLOCKF_READWRITE, 
                                         IID_IDXARGBReadWritePtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        pPtr->FillRect(NULL, Color, bDoOver);
        pPtr->Release();
    }
    return hr;
} /* DXFillSurfaceRect */



//
//  The DestBnds height and width must be greater than or equal to the source bounds.
//
//  The dwFlags parameter uses the flags defined by IDXSurfaceFactory::BitBlt:
// 
//    DXBOF_DO_OVER
//    DXBOF_DITHER
//
inline HRESULT DXBitBlt(IDXSurface * pDest, const CDXDBnds & DestBnds, 
                        IDXSurface * pSrc, const CDXDBnds & SrcBnds, 
                        DWORD dwFlags, ULONG ulTimeout)
{
    IDXARGBReadPtr * pIn;
    HRESULT hr;
    hr = pSrc->LockSurface( &SrcBnds, INFINITE,
                            (dwFlags & DXBOF_DO_OVER) ? (DXLOCKF_READ | DXLOCKF_WANTRUNINFO) : DXLOCKF_READ,
                            IID_IDXARGBReadPtr, (void**)&pIn, NULL);
    if(SUCCEEDED(hr))
    {
        IDXARGBReadWritePtr * pOut;
        hr = pDest->LockSurface( &DestBnds, INFINITE, DXLOCKF_READWRITE,
                                 IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
        if (SUCCEEDED(hr))
        {
            DXSAMPLEFORMATENUM InNativeType = pIn->GetNativeType(NULL);
            DXSAMPLEFORMATENUM OutNativeType = pOut->GetNativeType(NULL);
            BOOL bSrcIsOpaque = !(InNativeType & (DXPF_TRANSLUCENCY | DXPF_TRANSPARENCY));
            const ULONG Width = SrcBnds.Width();
            DXPMSAMPLE *pSrcBuff = NULL;
            if( InNativeType != DXPF_PMARGB32 )
            {
                pSrcBuff = DXPMSAMPLE_Alloca(Width);
            }
            //
            //  Don't dither unless the dest has a greater error term than the source.
            //
            if ((dwFlags & DXBOF_DITHER) && 
                ((OutNativeType & DXPF_ERRORMASK) <= (InNativeType & DXPF_ERRORMASK)))
            {
                dwFlags &= (~DXBOF_DITHER);
            }
            if ((dwFlags & DXBOF_DITHER) || ((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque== 0))
            {
                //--- Allocate a working output buffer if necessary
                DXPMSAMPLE *pDestBuff = NULL;
                if( OutNativeType != DXPF_PMARGB32 )
                {
                    pDestBuff = DXPMSAMPLE_Alloca(Width);
                }
                //--- Process each output row
                //    Note: Output coordinates are relative to the lock region
                const ULONG Height = SrcBnds.Height();
                if (dwFlags & DXBOF_DITHER)
                {
                    DXPMSAMPLE * pSrcDitherBuff = pSrcBuff;
                    if (pSrcDitherBuff == NULL)
                    {
                        pSrcDitherBuff = DXPMSAMPLE_Alloca(Width);
                    }
                    const BOOL bCopy = ((dwFlags & DXBOF_DO_OVER) == 0);
                    //
                    //  Set up the dither descriptor (some things are constant)
                    //
                    DXDITHERDESC dd;
                    dd.pSamples = pSrcDitherBuff;
                    dd.DestSurfaceFmt = OutNativeType;
                    for(ULONG Y = 0; Y < Height; ++Y )
                    {
                        dd.x = DestBnds.Left();
                        dd.y = DestBnds.Top() + Y;
                        const DXRUNINFO *pRunInfo;
                        ULONG cRuns = pIn->MoveAndGetRunInfo(Y, &pRunInfo);
                        pOut->MoveToRow( Y );
                        do
                        {
                            ULONG ulRunLen = pRunInfo->Count;
                            if (pRunInfo->Type == DXRUNTYPE_CLEAR)
                            {
                                pIn->Move(ulRunLen);
                                if (bCopy)
                                {
                                    //
                                    //  The only way to avoid calling a constructor function to create
                                    //  a pmsample from 0 is to declare a variable and then assign it!
                                    //
                                    DXPMSAMPLE NullColor;
                                    NullColor = 0;
                                    pOut->FillAndMove(pSrcDitherBuff, NullColor, ulRunLen, FALSE);
                                }
                                else
                                {
                                    pOut->Move(ulRunLen);
                                }
                                dd.x += ulRunLen;
                            }
                            else
                            {
                                pIn->UnpackPremult(pSrcDitherBuff, ulRunLen, TRUE);
                                dd.cSamples = ulRunLen;
                                DXDitherArray(&dd);
                                dd.x += ulRunLen;
                                if (bCopy || pRunInfo->Type == DXRUNTYPE_OPAQUE)
                                {
                                    pOut->PackPremultAndMove(pSrcDitherBuff, ulRunLen);
                                }
                                else
                                {
                                    pOut->OverArrayAndMove(pDestBuff, pSrcDitherBuff, ulRunLen);
                                }
                            }
                            pRunInfo++;
                            cRuns--;
                        } while (cRuns);
                    }
                }
                else
                {
                    for(ULONG Y = 0; Y < Height; ++Y )
                    {
                        const DXRUNINFO *pRunInfo;
                        ULONG cRuns = pIn->MoveAndGetRunInfo(Y, &pRunInfo);
                        pOut->MoveToRow( Y );
                        do
                        {
                            ULONG ulRunLen = pRunInfo->Count;
                            switch (pRunInfo->Type)
                            {
                              case DXRUNTYPE_CLEAR:
                                pIn->Move(ulRunLen);
                                pOut->Move(ulRunLen);
                                break;
                              case DXRUNTYPE_OPAQUE:
                                pOut->CopyAndMoveBoth(pDestBuff, pIn, ulRunLen, TRUE);
                                break;
                              case DXRUNTYPE_TRANS:
                              {
                                DXPMSAMPLE *pSrc = pIn->UnpackPremult(pSrcBuff, ulRunLen, TRUE);
                                DXPMSAMPLE *pDest = pOut->UnpackPremult(pDestBuff, ulRunLen, FALSE);                 
                                DXOverArrayMMX(pDest, pSrc, ulRunLen);
                                pOut->PackPremultAndMove(pDestBuff, ulRunLen);
                                break;
                              }

                              case DXRUNTYPE_UNKNOWN:
                              {
                                pOut->OverArrayAndMove(pDestBuff,
                                                       pIn->UnpackPremult(pSrcBuff, ulRunLen, TRUE),
                                                       ulRunLen);
                                break;
                              }
                            }
                            pRunInfo++;
                            cRuns--;
                        } while (cRuns);
                    }
                }
            }
            else // if ((dwFlags & DXBOF_DITHER) || ((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque== 0))
            {
                // This code is run if:
                //
                // !(dwFlags & DXBOF_DITHER) 
                // && !((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque == 0)
                //
                // In English:
                //
                // This code is run if 1) dithering is not required
                // and 2) blending with output is not required because it was
                // not requested or because it's not needed because the source
                // pixels are all opaque.

                // hrDD is initialized to failure so that in the event that the
                // pixel formats don't match or the pixel format supports
                // transparency, the CopyRect will still run.

                HRESULT             hrDD        = E_FAIL;
                DXSAMPLEFORMATENUM  formatIn    = pIn->GetNativeType(NULL);

                // If the pixel formats match and do not support transparency
                // (because it's not supported by ddraw yet) try to use a 
                // ddraw blit instead of CopyRect.

                if ((formatIn == pOut->GetNativeType(NULL))
                    && !(formatIn & DXPF_TRANSPARENCY))
                {
                    CComPtr<IDirectDrawSurface> cpDDSrc;

                    // Get source ddraw surface pointer.

                    hrDD = pSrc->QueryInterface(IID_IDirectDrawSurface, 
                                                (void **)&cpDDSrc);

                    if (SUCCEEDED(hrDD))
                    {
                        CComPtr<IDirectDrawSurface> cpDDDest;

                        // Get destination ddraw surface pointer.

                        hrDD = pDest->QueryInterface(IID_IDirectDrawSurface, 
                                                     (void **)&cpDDDest);

                        if (SUCCEEDED(hrDD))
                        {
                            RECT rcSrc;
                            RECT rcDest;

                            SrcBnds.GetXYRect(rcSrc);
                            DestBnds.GetXYRect(rcDest);

                            // Attempt the ddraw blit.

                            hrDD = cpDDDest->Blt(&rcDest, cpDDSrc, &rcSrc, 
                                                 0, NULL);
                        }
                    }
                }

                // If hrDD has failed at this point, it means a direct draw blit
                // was not possible and a CopyRect is needed to perform the 
                // copy.

                if (FAILED(hrDD))
                {
                    pOut->CopyRect(pSrcBuff, NULL, pIn, NULL, bSrcIsOpaque);
                }
            }
            pOut->Release();
        }
        pIn->Release();
    }
    return hr;
}

inline HRESULT DXSrcCopy(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, 
                         IDXSurface *pSrcSurface, int nXSrc, int nYSrc)
{
    IDXDCLock *pDCLock;
    HRESULT hr = pSrcSurface->LockSurfaceDC(NULL, INFINITE, DXLOCKF_READ, &pDCLock);
    if (SUCCEEDED(hr))
    {
        ::BitBlt(hdcDest, nXDest, nYDest, nWidth, nHeight, pDCLock->GetDC(), nXSrc, nYSrc, SRCCOPY);
        pDCLock->Release();
    }
    return hr;
}
//
//=== Pointer validation functions
//
inline BOOL DXIsBadReadPtr( const void* pMem, UINT Size )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ::IsBadReadPtr( pMem, Size );
#endif
}

inline BOOL DXIsBadWritePtr( void* pMem, UINT Size )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ::IsBadWritePtr( pMem, Size );
#endif
}


inline BOOL DXIsBadInterfacePtr( const IUnknown* pUnknown )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ( ::IsBadReadPtr( pUnknown, sizeof( *pUnknown ) ) ||
             ::IsBadCodePtr( (FARPROC)((void **)pUnknown)[0] ))?
            (true):(false);
#endif
}

#define DX_IS_BAD_OPTIONAL_WRITE_PTR(p) ((p) && DXIsBadWritePtr(p, sizeof(p)))
#define DX_IS_BAD_OPTIONAL_READ_PTR(p) ((p) && DXIsBadReadPtr(p, sizeof(p)))
#define DX_IS_BAD_OPTIONAL_INTERFACE_PTR(p) ((p) && DXIsBadInterfacePtr(p))


#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxbounds.h ===
/*******************************************************************************
* DXBounds.h *
*------------*
*   Description:
*       This is the header file for the bounds helper class implementation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/22/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXBounds_h
#define DXBounds_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_FLOAT
#include <float.h>
#endif

#ifndef __DXTrans_h__
#include <DXTrans.h>
#endif

#ifndef DXVector_h
#include <DXVector.h>
#endif

//=== Constants ====================================================

#ifdef _ASSERT
#define CHKTYPE() _ASSERT( eType == eBndType )
#else
#define CHKTYPE()
#endif

//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CDXBnds
*
*/
#define CDXB_C CDXBnds<TYPE, USTYPE, STTYPE, eBndType>
#define CDXB_T ((STTYPE*)u.D)
#define CDXB_O( OtherBnd ) ((STTYPE*)(OtherBnd).u.D)

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
class CDXBnds : public DXBNDS
{
  public:
  /*--- Constructors ---*/
    CDXBnds() { eType = eBndType; SetEmpty(); }
    CDXBnds( BOOL bInit ) { eType = eBndType; if (bInit) SetEmpty(); }
    CDXBnds( const DXBNDS& Other ) { eType = eBndType; Copy( Other ); }
    CDXBnds( const CDXB_C& Other ) { eType = eBndType; Copy( Other ); }
    CDXBnds( const RECT & Rect )    { eType = eBndType; SetXYRect( Rect ); }
    CDXBnds( TYPE Width, TYPE Height ) { eType = eBndType; SetXYSize( Width, Height ); }
    CDXBnds( IDXSurface *pSurface, HRESULT & hr) { _ASSERT(eBndType == DXBT_DISCRETE); eType = eBndType; hr = pSurface->GetBounds(this); }
    CDXBnds( IDirect3DRMMeshBuilder3 *pMesh, HRESULT & hr) { _ASSERT(eBndType == DXBT_CONTINUOUS); eType = eBndType; hr = SetToMeshBounds(pMesh); }
    CDXBnds( const CDXV_C& VecPoint ) { eType = eBndType; *this = VecPoint; }

    HRESULT InitFromSafeArray( SAFEARRAY *psa);
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void SetEmpty();
    void Copy( const DXBNDS& Other );
    void Copy( const CDXB_C& Other );

    /*--- Type casts ---*/
    operator STTYPE *   () { CHKTYPE(); return CDXB_T; }
    operator DXDBNDS&   () { CHKTYPE(); return u.D;  }
    operator DXDBNDS64& () { CHKTYPE(); return u.LD; }
    operator DXCBNDS&   () { CHKTYPE(); return u.C;  }
    operator DXCBNDS64& () { CHKTYPE(); return u.LC; }

    //--- Access methods
    USTYPE Width( DXBNDID i ) const { CHKTYPE(); return (USTYPE)(CDXB_T[i].Max - CDXB_T[i].Min); }

    USTYPE Width()    const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min); }
    USTYPE Height()   const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min); }
    USTYPE Depth()    const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min); }
    USTYPE Duration() const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min); }

    TYPE  Left()     const { CHKTYPE(); return CDXB_T[DXB_X].Min; }
    TYPE  Right()    const { CHKTYPE(); return CDXB_T[DXB_X].Max; }
    TYPE  Top()      const { CHKTYPE(); return CDXB_T[DXB_Y].Min; }
    TYPE  Bottom()   const { CHKTYPE(); return CDXB_T[DXB_Y].Max; }

    void SetBounds( TYPE xmin, TYPE xmax, TYPE ymin, TYPE ymax,
                    TYPE zmin, TYPE zmax, TYPE tmin, TYPE tmax );
    void SetXYRect( const RECT& xyRect);
    void SetXYSize( const SIZE& xySize);
    void SetXYSize( TYPE width, TYPE height);
    void SetXYPoint(const POINT& xyPoint);
    void Offset( TYPE x, TYPE y, TYPE z, TYPE t );
    void Offset( const CDXV_C& v );
    void SetPlacement(const CDXV_C& v);
    void SetToSize(void);
    void GetXYRect( RECT& xyRect ) const;
    void GetXYSize( SIZE& xySize ) const;
    void GetMinVector( CDXV_C& v ) const;
    void GetMaxVector( CDXV_C& v ) const;
    void GetSize( CDXB_C& SizeBounds ) const;
    CDXB_C Size( void ) const;
 


    //--- Region Functions
    void NormalizeBounds();
    BOOL BoundsAreEmpty() const;
    BOOL BoundsAreNull() const;
    BOOL TestIntersect( const CDXB_C& Other ) const;
    BOOL IntersectBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 );
    BOOL IntersectBounds( const CDXB_C& OtherBounds );
    void UnionBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 );

// Additional Operations
    STTYPE& operator[]( int index )    const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( long index )   const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( USHORT index ) const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( DWORD index )  const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( DXBNDID index) const { CHKTYPE(); return CDXB_T[index]; }

    void operator=(const CDXB_C& Bounds);
    void operator=(const CDXV_C& v);
    void operator+=(const POINT& point);
    void operator-=(const POINT& point);
    void operator+=(const SIZE& size);
    void operator-=(const SIZE& size);
    void operator+=(const CDXV_C& v);
    void operator-=(const CDXV_C& v);
    void operator+=(const CDXB_C& Bounds);
    void operator-=(const CDXB_C& Bounds);
    void operator&=(const CDXB_C& Bounds);
    void operator|=(const CDXB_C& Bounds);
    BOOL operator==(const CDXB_C& Bounds) const;
    BOOL operator!=(const CDXB_C& Bounds) const;

// Operators returning CDXDBnds values
    CDXB_C operator+(const POINT& point) const;
    CDXB_C operator-(const POINT& point) const;
    CDXB_C operator+(const SIZE& size) const;
    CDXB_C operator-(const SIZE& size) const;
    CDXB_C operator+(const CDXV_C& v) const;
    CDXB_C operator-(const CDXV_C& v) const;
    CDXB_C operator&(const CDXB_C& Bounds2) const;
    CDXB_C operator|(const CDXB_C& Bounds2) const;

//
// Helpers to grow bounds from their midpoints.
//
    void Scale(TYPE x, TYPE y = 1, TYPE z = 1, TYPE t = 1);
    void Scale(const CDXV_C& v);
    void Expand(TYPE x, TYPE y = 0, TYPE z = 0, TYPE t = 0);
    void Expand(const CDXV_C& v);

// Helpers for DXSurfaces  These functions only work with DISCRETE bounds
    HRESULT SetToSurfaceBounds(IDXSurface * pDXSurface);

// Helpers for D3DRM Meshes.  These functions only work with CONTINUOUS bounds.
    HRESULT SetToMeshBounds(IDirect3DRMMeshBuilder3 * pMesh);
};

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetEmpty()
{
    CHKTYPE(); 
    memset(CDXB_T, 0, sizeof(STTYPE) * 4);
} /* CDXBnds::SetEmpty() */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Copy( const CDXB_C& Other )
{
    CHKTYPE();
    memcpy( CDXB_T, CDXB_O(Other), sizeof( STTYPE ) * 4 );
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Copy( const DXBNDS& Other )
{
    CHKTYPE(); 
    if( eBndType == Other.eType )
    {
        memcpy( CDXB_T, CDXB_O(Other), sizeof( STTYPE ) * 4 );
    }
    else
    {
        int i = 4;
        switch( Other.eType )
        {
          case DXBT_DISCRETE:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.D[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.D[i].Max;
            }
            break;
          case DXBT_DISCRETE64:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.LD[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.LD[i].Max;
            }
            break;
          case DXBT_CONTINUOUS:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.C[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.C[i].Max;
            }
            break;
          case DXBT_CONTINUOUS64:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.LC[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.LC[i].Max;
            }
            break;
          default:
            _ASSERT(0);
        }
    }
} /* CDXBnds::Copy constructor */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::InitFromSafeArray( SAFEARRAY *pSA )
{
    CHKTYPE(); 
    HRESULT hr = S_OK;
    TYPE *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(TYPE) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                CDXB_T[i].Min = pData[i];
                CDXB_T[i].Max = pData[i+4];
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }

    return hr;
} /* CDXBnds::InitFromSafeArray */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::GetSafeArray( SAFEARRAY **ppSA ) const
{
    CHKTYPE(); 
    HRESULT hr = S_OK;
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 8;
        static VARTYPE VTypes[4] = { VT_I4, VT_I8, VT_R4, VT_R8 };

        pSA = SafeArrayCreate( VTypes[eBndType], 1, &rgsabound );

        if( pSA == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            TYPE *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = CDXB_T[i].Min;
                    pData[i+4] = CDXB_T[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }

    return hr;
} /* CDXBnds::GetSafeArray */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::NormalizeBounds()
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        if( CDXB_T[i].Max < CDXB_T[i].Min )
        {
            TYPE Temp = CDXB_T[i].Min;
            CDXB_T[i].Min = CDXB_T[i].Max;
            CDXB_T[i].Max = Temp;
        }
    }
} /* CDXBnds::NormalizeBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::IntersectBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 )
{
    CHKTYPE(); 
    BOOL bDoesIntersect = TRUE;

    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = max( CDXB_O( Bounds1 )[i].Min, CDXB_O( Bounds2 )[i].Min );
        CDXB_T[i].Max = min( CDXB_O( Bounds1 )[i].Max, CDXB_O( Bounds2 )[i].Max );

        if( CDXB_T[i].Max <= CDXB_T[i].Min )
        {
            //--- no intersection
            SetEmpty();
            bDoesIntersect = FALSE;
        }
    }
    return bDoesIntersect;
} /* CDXBnds::IntersectBounds */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::TestIntersect( const CDXB_C& Other ) const
{
    CHKTYPE(); 
    BOOL bDoesIntersect = TRUE;
    TYPE BndMin, BndMax;
    for( int i = 0; i < 4; ++i )
    {
        BndMin = max( CDXB_T[i].Min, CDXB_O( Other )[i].Min );
        BndMax = min( CDXB_T[i].Max, CDXB_O( Other )[i].Max );
        if( BndMax <= BndMin ) bDoesIntersect = FALSE;
    }
    return bDoesIntersect;
} /* CDXBnds::TestIntersect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::UnionBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 )
{
    CHKTYPE(); 
    // This assumes the bounds are already normalized.
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = min( CDXB_O( Bounds1 )[i].Min, CDXB_O( Bounds2 )[i].Min );
        CDXB_T[i].Max = max( CDXB_O( Bounds1 )[i].Max, CDXB_O( Bounds2 )[i].Max );
    }
} /* CDXDBnds::UnionBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::IntersectBounds( const CDXB_C& OtherBounds )
{
    CHKTYPE(); 
    return IntersectBounds( *this, OtherBounds );
} /* CDXBnds::IntersectBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::BoundsAreEmpty() const
{
    CHKTYPE(); 
    //--- Must exist in all dimensions
    for( int i = 0; i < 4; ++i )
    {
        if( CDXB_T[i].Max <= CDXB_T[i].Min ) return TRUE;
    }
    return FALSE;
} /* CDXBnds::BoundsAreEmpty */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::BoundsAreNull() const
{
    CHKTYPE(); 
    DWORD *pTest = (DWORD *)CDXB_T;
    DWORD *pLimit = pTest + (sizeof(STTYPE) * 4 / sizeof(*pTest));
    do
    {
        if (*pTest) return FALSE;
        pTest++;
    } while (pTest < pLimit);
    return TRUE;
} /* CDXDBnds::BoundsAreNull */

// Additional Operations
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator=( const CDXB_C& srcBounds )
{
    CHKTYPE(); 
    memcpy(CDXB_T, CDXB_O(srcBounds), sizeof(STTYPE)*4);
} /* CDXDBnds::operator= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator=( const CDXV_C& v )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = v[i];
        CDXB_T[i].Max = v[i] + 1;
    }
} /* CDXDBnds::operator= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::operator==( const CDXB_C& Bounds ) const
{
    CHKTYPE(); 
    for( ULONG i = 0; i < 4; ++i )
    {
        if( ( CDXB_T[i].Min != CDXB_O( Bounds )[i].Min ) ||
            ( CDXB_T[i].Max != CDXB_O( Bounds )[i].Max ) )
        {
            return false;
        }
    }
    return true;
} /* CDXB_C::operator== */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::operator!=( const CDXB_C& Bounds ) const
{
    CHKTYPE(); 
    for( ULONG i = 0; i < 4; ++i )
    {
        if( ( CDXB_T[i].Min != CDXB_O( Bounds )[i].Min ) ||
            ( CDXB_T[i].Max != CDXB_O( Bounds )[i].Max ) )
        {
            return true;
        }
    }
    return false;
} /* CDXBnds::operator!= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator&( const CDXB_C& Bounds2 ) const
{
    CHKTYPE(); 
    CDXB_C Result;
    Result.IntersectBounds( *this, Bounds2 );
    return Result;
} /* CDXBnds::operator& */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator|( const CDXB_C& Bounds2 ) const
{
    CHKTYPE(); 
    CDXB_C Result;
    Result.UnionBounds( *this, Bounds2 );
    return Result;
} /* CDXBnds::operator| */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetMinVector( CDXV_C& v ) const
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        v[i] = CDXB_T[i].Min;
    }
} /* CDXBnds::GetMinVector */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetMaxVector( CDXV_C& v ) const
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        v[i] = CDXB_T[i].Max;
    }
} /* CDXBnds::GetMaxVector */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetSize( CDXB_C& SizeBounds ) const
{
    CHKTYPE(); 
    SizeBounds.SetEmpty();
    SizeBounds[DXB_X].Max = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    SizeBounds[DXB_Y].Max = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
    SizeBounds[DXB_Z].Max = CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min;
    SizeBounds[DXB_T].Max = CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min;
} /* CDXBnds::GetSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::Size( void ) const
{
    CHKTYPE(); 
    CDXB_C Size;
    Size[DXB_X].Max = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    Size[DXB_Y].Max = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
    Size[DXB_Z].Max = CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min;
    Size[DXB_T].Max = CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min;
    return Size;
} /* CDXBnds::Size */

// Operations
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetBounds( TYPE xmin, TYPE xmax, TYPE ymin, TYPE ymax,
                        TYPE zmin, TYPE zmax, TYPE tmin, TYPE tmax )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min = xmin;
    CDXB_T[DXB_X].Max = xmax;
    CDXB_T[DXB_Y].Min = ymin;
    CDXB_T[DXB_Y].Max = ymax;
    CDXB_T[DXB_Z].Min = zmin;
    CDXB_T[DXB_Z].Max = zmax;
    CDXB_T[DXB_T].Min = tmin;
    CDXB_T[DXB_T].Max = tmax;
} /* CDXBnds::SetBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYRect( const RECT& xyRect )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Min = (TYPE)xyRect.left;
    CDXB_T[DXB_X].Max = (TYPE)xyRect.right;
    CDXB_T[DXB_Y].Min = (TYPE)xyRect.top;
    CDXB_T[DXB_Y].Max = (TYPE)xyRect.bottom;
    CDXB_T[DXB_Z].Max = 1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetXYRect( RECT& xyRect ) const
{
    CHKTYPE(); 
    xyRect.left   = CDXB_T[DXB_X].Min;
    xyRect.right  = CDXB_T[DXB_X].Max;
    xyRect.top    = CDXB_T[DXB_Y].Min;
    xyRect.bottom = CDXB_T[DXB_Y].Max;
} /* CDXBnds::GetXYRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetXYSize( SIZE& xySize ) const
{
    CHKTYPE(); 
    xySize.cx = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    xySize.cy = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
} /* CDXBnds::GetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYSize( const SIZE& xySize )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Max = (TYPE)xySize.cx;
    CDXB_T[DXB_Y].Max = (TYPE)xySize.cy;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYSize( TYPE width, TYPE height )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Max = (TYPE)width;
    CDXB_T[DXB_Y].Max = (TYPE)height;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYPoint( const POINT& xyPoint )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Min = (TYPE)xyPoint.x;
    CDXB_T[DXB_X].Max = (TYPE)xyPoint.x + 1;
    CDXB_T[DXB_Y].Min = (TYPE)xyPoint.y;
    CDXB_T[DXB_Y].Max = (TYPE)xyPoint.y + 1;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXDBnds::SetRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Offset( TYPE x, TYPE y, TYPE z, TYPE t )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += x;
    CDXB_T[DXB_X].Max += x;
    CDXB_T[DXB_Y].Min += y;
    CDXB_T[DXB_Y].Max += y;
    CDXB_T[DXB_Z].Min += z;
    CDXB_T[DXB_Z].Max += z;
    CDXB_T[DXB_T].Min += t;
    CDXB_T[DXB_T].Max += t;
} /* CDXBnds::Offset */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetToSize(void)
{
    CHKTYPE();
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Max -= CDXB_T[i].Min;
        CDXB_T[i].Min = 0;
    }
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetPlacement(const CDXV_C & v)
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Max += (CDXV_O( v )[i] - CDXB_T[i].Min);
        CDXB_T[i].Min = CDXV_O( v )[i];
    }
} /* CDXBnds::Offset */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Offset( const CDXV_C& v )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min += v[i];
        CDXB_T[i].Max += v[i];
    }
} /* CDXBnds::Offset */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const POINT &point)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += (TYPE)point.x;
    CDXB_T[DXB_X].Max += (TYPE)point.x;
    CDXB_T[DXB_Y].Min += (TYPE)point.y;
    CDXB_T[DXB_Y].Max += (TYPE)point.y;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const POINT &point)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= (TYPE)point.x;
    CDXB_T[DXB_X].Max -= (TYPE)point.x;
    CDXB_T[DXB_Y].Min -= (TYPE)point.y;
    CDXB_T[DXB_Y].Max -= (TYPE)point.y;
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const SIZE &size)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += (TYPE)size.cx;
    CDXB_T[DXB_X].Max += (TYPE)size.cx;
    CDXB_T[DXB_Y].Min += (TYPE)size.cy;
    CDXB_T[DXB_Y].Max += (TYPE)size.cy;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const SIZE &size)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= (TYPE)size.cx;
    CDXB_T[DXB_X].Max -= (TYPE)size.cx;
    CDXB_T[DXB_Y].Min -= (TYPE)size.cy;
    CDXB_T[DXB_Y].Max -= (TYPE)size.cy;
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const CDXV_C& v)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += CDXV_O( v )[DXB_X];
    CDXB_T[DXB_X].Max += CDXV_O( v )[DXB_X];
    CDXB_T[DXB_Y].Min += CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Y].Max += CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Z].Min += CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_Z].Max += CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_T].Min += CDXV_O( v )[DXB_T];
    CDXB_T[DXB_T].Max += CDXV_O( v )[DXB_T];
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const CDXV_C& v)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= CDXV_O( v )[DXB_X];
    CDXB_T[DXB_X].Max -= CDXV_O( v )[DXB_X];
    CDXB_T[DXB_Y].Min -= CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Y].Max -= CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Z].Min -= CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_Z].Max -= CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_T].Min -= CDXV_O( v )[DXB_T];
    CDXB_T[DXB_T].Max -= CDXV_O( v )[DXB_T];
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += CDXB_O( Bounds )[DXB_X].Min;
    CDXB_T[DXB_X].Max += CDXB_O( Bounds )[DXB_X].Max;
    CDXB_T[DXB_Y].Min += CDXB_O( Bounds )[DXB_Y].Min;
    CDXB_T[DXB_Y].Max += CDXB_O( Bounds )[DXB_Y].Max;
    CDXB_T[DXB_Z].Min += CDXB_O( Bounds )[DXB_Z].Min;
    CDXB_T[DXB_Z].Max += CDXB_O( Bounds )[DXB_Z].Max;
    CDXB_T[DXB_T].Min += CDXB_O( Bounds )[DXB_T].Min;
    CDXB_T[DXB_T].Max += CDXB_O( Bounds )[DXB_T].Max;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= CDXB_O( Bounds )[DXB_X].Min;
    CDXB_T[DXB_X].Max -= CDXB_O( Bounds )[DXB_X].Max;
    CDXB_T[DXB_Y].Min -= CDXB_O( Bounds )[DXB_Y].Min;
    CDXB_T[DXB_Y].Max -= CDXB_O( Bounds )[DXB_Y].Max;
    CDXB_T[DXB_Z].Min -= CDXB_O( Bounds )[DXB_Z].Min;
    CDXB_T[DXB_Z].Max -= CDXB_O( Bounds )[DXB_Z].Max;
    CDXB_T[DXB_T].Min -= CDXB_O( Bounds )[DXB_T].Min;
    CDXB_T[DXB_T].Max -= CDXB_O( Bounds )[DXB_T].Max;
} /* CDXB_C::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator&=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = max( CDXB_T[i].Min, CDXB_O( Bounds )[i].Min );
        CDXB_T[i].Max = min( CDXB_T[i].Max, CDXB_O( Bounds )[i].Max );
    }
} /* CDXB_C::operator&= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator|=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    for( long i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = min( CDXB_T[i].Min, CDXB_O( Bounds )[i].Min );
        CDXB_T[i].Max = max( CDXB_T[i].Max, CDXB_O( Bounds )[i].Max );
    }
} /* CDXB_C::operator|= */


// operators returning CDXDBnds values
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const POINT &point) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += point.x;
    CDXB_O( Result )[DXB_X].Max += point.x;
    CDXB_O( Result )[DXB_Y].Min += point.y;
    CDXB_O( Result )[DXB_Y].Max += point.y;
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-(const POINT &point) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= point.x;
    CDXB_O( Result )[DXB_X].Max -= point.x;
    CDXB_O( Result )[DXB_Y].Min -= point.y;
    CDXB_O( Result )[DXB_Y].Max -= point.y;
    return Result;
} /* CDXBnds::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const SIZE &size) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += size.cx;
    CDXB_O( Result )[DXB_X].Max += size.cx;
    CDXB_O( Result )[DXB_Y].Min += size.cy;
    CDXB_O( Result )[DXB_Y].Max += size.cy;
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-( const SIZE &size ) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= size.cx;
    CDXB_O( Result )[DXB_X].Max -= size.cx;
    CDXB_O( Result )[DXB_Y].Min -= size.cy;
    CDXB_O( Result )[DXB_Y].Max -= size.cy;
    return Result;
} /* CDXB_C::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const CDXV_C& v) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_X].Max += CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_Y].Min += CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Y].Max += CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Z].Min += CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_Z].Max += CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_T].Min += CDXV_O( v )[DXB_T];
    CDXB_O( Result )[DXB_T].Max += CDXV_O( v )[DXB_T];
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-(const CDXV_C& v) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_X].Max -= CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_Y].Min -= CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Y].Max -= CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Z].Min -= CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_Z].Max -= CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_T].Min -= CDXV_O( v )[DXB_T];
    CDXB_O( Result )[DXB_T].Max -= CDXV_O( v )[DXB_T];
    return Result;
} /* CDXBnds::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::SetToSurfaceBounds(IDXSurface * pDXSurface)
{
#if (eBndType != DXBT_DISCRETE)
#error SetToSurfacBounds requires a continuous bounds.
#endif
    CHKTYPE(); 
    return pDXSurface->GetBounds( this );
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::SetToMeshBounds(IDirect3DRMMeshBuilder3 * pMesh)
{
#if (eBndType != DXBT_CONTINUOUS)
#error SetToMeshBounds requires a continuous bounds.
#endif
    CHKTYPE(); 
    D3DRMBOX Box;
    HRESULT hr = pMesh->GetBox(&Box);
    u.C[DXB_X].Min = Box.min.x;
    u.C[DXB_X].Max = Box.max.x;
    u.C[DXB_Y].Min = Box.min.y;
    u.C[DXB_Y].Max = Box.max.y;
    u.C[DXB_Z].Min = Box.min.z;
    u.C[DXB_Z].Max = Box.max.z;
    u.C[DXB_T].Min = 0;
    u.C[DXB_T].Max = 1.;
    return hr;
}


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Scale(const CDXV_C& v)
{
    CHKTYPE(); 
    for(long i = 0; i < 4; ++i )
    {
        TYPE mid = (CDXB_T[i].Min + CDXB_T[i].Max) / 2;
        TYPE scale = CDXV_O(v)[i] * (CDXB_T[i].Max - mid);
        CDXB_T[i].Min = mid - scale;
        CDXB_T[i].Max = mid + scale;
    }
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Scale(TYPE x, TYPE y, TYPE z, TYPE t)
{
    Scale(CDXV_C(x, y, z, t));
}


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Expand(const CDXV_C& v)
{
    CHKTYPE(); 
    for(long i = 0; i < 4; ++i )
    {
        TYPE scale = CDXV_O(v)[i] / 2;
        CDXB_T[i].Min -= scale;
        CDXB_T[i].Max += scale;
    }
}

    
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Expand(TYPE x, TYPE y, TYPE z, TYPE t)
{
    Expand(CDXV_C(x, y, z, t));
}


//---
typedef CDXBnds<long, unsigned long, DXDBND, DXBT_DISCRETE> CDXDBnds;
typedef CDXBnds<LONGLONG, ULONGLONG, DXDBND64, DXBT_DISCRETE64> CDXDBnds64;
typedef CDXBnds<float, float, DXCBND, DXBT_CONTINUOUS> CDXCBnds;
typedef CDXBnds<double, double, DXCBND64, DXBT_CONTINUOUS64> CDXCBnds64;

//=== Macro Definitions ============================================


//=== Global Data Declarations =====================================


//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxsurfb.cpp ===
/*******************************************************************************
* DXSurfB.cpp *
*------------*
*   Description:
*    This module contains the CDXBaseSurface implementaion.
*-------------------------------------------------------------------------------
*  Created By: RAL                                  Date: 02/12/1998
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
//--- Additional includes
#include <DXTrans.h>
#include "DXSurfB.h"
#include "new.h"

CDXBaseSurface::CDXBaseSurface() :
    m_ulLocks(0),
    m_ulThreadsWaiting(0),
    m_Height(0),
    m_Width(0),
    m_pFreePtr(NULL),
    m_dwStatusFlags(DXSURF_READONLY),
    m_dwAppData(0)
{
    m_hSemaphore = CreateSemaphore(NULL, 0, MAXLONG, NULL);
    m_ulNumInRequired = m_ulMaxInputs = 0;
}

HRESULT CDXBaseSurface::FinalConstruct()
{
    return m_hSemaphore ? S_OK : E_OUTOFMEMORY;
}

void CDXBaseSurface::FinalRelease()
{
    while (m_pFreePtr)
    {
        CDXBaseARGBPtr *pNext = m_pFreePtr->m_pNext;
        DeleteARGBPointer(m_pFreePtr);
        m_pFreePtr = pNext;
    }
    if (m_hSemaphore)
    {
        CloseHandle(m_hSemaphore);
    }
}

STDMETHODIMP CDXBaseSurface::GetGenerationId(ULONG *pGenerationId)
{
    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
    {
        return E_POINTER;
    }
    Lock();
    OnUpdateGenerationId();
    *pGenerationId = m_dwGenerationId;
    Unlock();
    return S_OK;
}

STDMETHODIMP CDXBaseSurface::IncrementGenerationId(BOOL /*bRefresh */)
{
    Lock();
    m_dwGenerationId++;
    Unlock();
    return S_OK;
}


STDMETHODIMP CDXBaseSurface::GetObjectSize(ULONG *pcbSize)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pcbSize, sizeof(*pcbSize)))
    {
        hr = E_POINTER;
    }
    else
    {
	Lock();
        *pcbSize = OnGetObjectSize();
        Unlock();
    }
    return hr;
}

STDMETHODIMP CDXBaseSurface::MapBoundsIn2Out
    (const DXBNDS *pInBounds, ULONG ulNumInBnds, ULONG /*ulOutIndex*/, DXBNDS *pOutBounds)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pOutBounds, sizeof(*pOutBounds)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        new(pOutBounds) CDXDBnds(m_Width, m_Height);
        Unlock();
    }
    return hr;    
}

STDMETHODIMP CDXBaseSurface::InitSurface(IUnknown *pDirectDraw,
                                         const DDSURFACEDESC * pDDSurfaceDesc,
                                         const GUID * pFormatId,
                                         const DXBNDS *pBounds,
                                         DWORD dwFlags)
{
    HRESULT hr = S_OK;
    if (pDDSurfaceDesc || DXIsBadReadPtr(pBounds, sizeof(*pBounds)) || pBounds->eType != DXBT_DISCRETE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        _EnterCritWith0PtrLocks();
        if (m_Width)
        {
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
        }
        else
        {
            CDXDBnds *pbnds = (CDXDBnds *)pBounds;
            hr = OnSetSize(pbnds->Width(), pbnds->Height());
        }
        Unlock();
    }
    return hr;
}


STDMETHODIMP CDXBaseSurface::GetPixelFormat(GUID *pFormat, DXSAMPLEFORMATENUM *pSampleFormatEnum)
{
    HRESULT hr = S_OK;
    if (DX_IS_BAD_OPTIONAL_WRITE_PTR(pFormat) ||
        DX_IS_BAD_OPTIONAL_WRITE_PTR(pSampleFormatEnum))
    {
        hr = E_POINTER;
    }
    else
    {
        if (pFormat) *pFormat = SurfaceCLSID();
        if (pSampleFormatEnum) *pSampleFormatEnum = SampleFormatEnum();
    }
    return hr;
}

STDMETHODIMP CDXBaseSurface::GetBounds(DXBNDS* pBounds)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pBounds, sizeof(*pBounds)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        new(pBounds) CDXDBnds(m_Width, m_Height);
        Unlock();
    }
    return hr;    
} 

STDMETHODIMP CDXBaseSurface::GetStatusFlags(DWORD* pdwStatusFlags)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pdwStatusFlags, sizeof(*pdwStatusFlags)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        *pdwStatusFlags = m_dwStatusFlags;
        Unlock();
    }
    return hr;    
} 

STDMETHODIMP CDXBaseSurface::SetStatusFlags(DWORD dwStatusFlags )
{
    _EnterCritWith0PtrLocks();
    m_dwStatusFlags = dwStatusFlags | DXSURF_READONLY;
    m_dwGenerationId++;
    Unlock();
    return S_OK;
} 

STDMETHODIMP CDXBaseSurface::GetDirectDrawSurface(REFIID riid, void **ppSurface)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDXBaseSurface::LockSurface(const DXBNDS *pBounds, ULONG ulTimeOut,
                                         DWORD dwFlags, REFIID riid, void **ppPointer,
                                         DWORD * pGenerationId)
{
    HRESULT hr = S_OK;
    BOOL bMPLockOnly = m_bInMultiThreadWorkProc;

    if (!bMPLockOnly) Lock();
    m_MPWorkProcCrit.Lock();

    if (m_Width == 0)
    {
        hr = E_FAIL;
    }
    else
    {
        RECT r;
        r.top = r.left = 0;
        r.right = m_Width;
        r.bottom = m_Height;
        if (pBounds)
        {
            if (pBounds->eType != DXBT_DISCRETE)
            {
                hr = DXTERR_INVALID_BOUNDS;
            }
            else
            {
                ((CDXDBnds *)pBounds)->GetXYRect(r);
                if (r.top < 0 || r.left < 0 || (ULONG)r.right > m_Width || (ULONG)r.bottom > m_Height || r.bottom <= r.top || r.right <= r.left)
                {
                    hr = DXTERR_INVALID_BOUNDS;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            CDXBaseARGBPtr * pPtr = m_pFreePtr;
            if (pPtr)
            {
                m_pFreePtr = pPtr->m_pNext;
            }
            else
            {
                hr = CreateARGBPointer(this, &pPtr);
            }
            if (SUCCEEDED(hr))
            {
                hr = pPtr->InitFromLock(r, ulTimeOut, dwFlags, riid, ppPointer);
                if (pGenerationId)
                {
                    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
                    {
                        hr = E_POINTER;
                    }
                    else
                    {
                        *pGenerationId = m_dwGenerationId;
                    }
                }
                if (SUCCEEDED(hr))
                {
                    m_ulLocks++;
                }
                else
                {
                    pPtr->m_pNext = m_pFreePtr;
                    m_pFreePtr = pPtr;
                }
            }
        }
    }
    m_MPWorkProcCrit.Unlock();
    if (!bMPLockOnly) Unlock();
    return hr;
}

void CDXBaseSurface::_InternalUnlock(CDXBaseARGBPtr *pPtrToUnlock)
{
    BOOL bMPLockOnly = m_bInMultiThreadWorkProc;

    if (!bMPLockOnly) Lock();
    m_MPWorkProcCrit.Lock();
    pPtrToUnlock->m_pNext = m_pFreePtr;
    m_pFreePtr = pPtrToUnlock;
    m_ulLocks--;
    if ((m_ulLocks == 0) && m_ulThreadsWaiting)
    {
        ReleaseSemaphore(m_hSemaphore, m_ulThreadsWaiting, NULL);
        m_ulThreadsWaiting = 0;
    }
    m_MPWorkProcCrit.Unlock();
    if (!bMPLockOnly) Unlock();

    IUnknown *punkOuter = GetControllingUnknown();
    punkOuter->Release();   // Release pointer's reference to us
                            // which could kill us!  Don't touch
                            // any members after this point.
}

//
//  Picking interface needs to test the appropriate point for hit testing
//
HRESULT CDXBaseSurface::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec)
{
    HRESULT hr;
    IDXARGBReadPtr *pPtr;
    hr = LockSurface(&OutPoint, m_ulLockTimeOut, DXLOCKF_READ, 
                     IID_IDXARGBReadPtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        DXPMSAMPLE val;
        pPtr->UnpackPremult(&val, 1, FALSE);
        pPtr->Release();
        hr = val.Alpha ? DXT_S_HITOUTPUT : S_FALSE;
    }
    else
    {
        if (hr == DXTERR_INVALID_BOUNDS) hr = S_FALSE;
    }
    return hr;
}

/*****************************************************************************
* RegisterSurface (STATIC member function)
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXBaseSurface::
RegisterSurface(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                ULONG cCatReq, const CATID * pCatReq, BOOL bRegister)
{
    HRESULT hr = bRegister ? _Module.UpdateRegistryFromResource(ResourceId, bRegister) : S_OK;
    if (SUCCEEDED(hr))
    {
        CComPtr<ICatRegister> pCatRegister;
        HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_ALL, IID_ICatRegister, (void **)&pCatRegister);
        if (SUCCEEDED(hr))
        {
            if (bRegister)
            {
                hr = pCatRegister->RegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (SUCCEEDED(hr) && cCatReq && pCatReq) {
                    hr = pCatRegister->RegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            } 
            else
            {
                pCatRegister->UnRegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (cCatReq && pCatReq)
                {
                    pCatRegister->UnRegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            }
        }
    }
    if ((!bRegister) && SUCCEEDED(hr)) 
    { 
        _Module.UpdateRegistryFromResource(ResourceId, bRegister);
    }
    return hr;
}

//
//  CDXBaseARGBPtr
//
STDMETHODIMP CDXBaseARGBPtr::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualGUID(riid, IID_IUnknown) ||
        IsEqualGUID(riid, IID_IDXARGBReadPtr))
    {
        *ppv = (IDXARGBReadPtr *)this;
        m_ulRefCount++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::AddRef()
{
    return ++m_ulRefCount;
}

ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::Release()
{
    --m_ulRefCount;
    ULONG c = m_ulRefCount;
    if (c == 0)
    {
        m_pSurface->_InternalUnlock(this);  // Don't touch members after this call.
    }
    return c;
}

HRESULT STDMETHODCALLTYPE CDXBaseARGBPtr::GetSurface(REFIID riid, void **ppSurface)
{
    return m_pSurface->GetControllingUnknown()->QueryInterface(riid, ppSurface);
}


DXSAMPLEFORMATENUM STDMETHODCALLTYPE CDXBaseARGBPtr::GetNativeType(DXNATIVETYPEINFO *pInfo)
{
    if (pInfo)
    {
        memset(pInfo, 0, sizeof(pInfo));
    }
    return m_pSurface->SampleFormatEnum();
}


void STDMETHODCALLTYPE CDXBaseARGBPtr::Move(long cSamples)
{
    m_FillInfo.x += cSamples;
    //--- Moving one column past the end is okay
    _ASSERT((long)m_FillInfo.x <= m_LockedRect.right);
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::MoveToRow(ULONG y)
{
    m_FillInfo.x = m_LockedRect.left;
    m_FillInfo.y = y + m_LockedRect.top;
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::MoveToXY(ULONG x, ULONG y)
{
    m_FillInfo.x = x + m_LockedRect.left;
    m_FillInfo.y = y + m_LockedRect.top;
    //--- Moving one column past the end is okay
    _ASSERT((long)m_FillInfo.x <= m_LockedRect.right);
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
}

ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::MoveAndGetRunInfo(ULONG Row, const DXRUNINFO ** ppInfo)
{
    m_FillInfo.x = m_LockedRect.left;
    m_FillInfo.y = Row + m_LockedRect.top;
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
    *ppInfo = &m_RunInfo;
    return 1;
}

DXSAMPLE *STDMETHODCALLTYPE CDXBaseARGBPtr::Unpack(DXSAMPLE *pSamples, ULONG cSamples, BOOL bMove)
{
    m_FillInfo.pSamples = pSamples;
    m_FillInfo.cSamples = cSamples;
    m_FillInfo.bPremult = false;
    FillSamples(m_FillInfo);
    if (bMove) m_FillInfo.x += cSamples;
    return pSamples;
}

DXPMSAMPLE *STDMETHODCALLTYPE CDXBaseARGBPtr::UnpackPremult(DXPMSAMPLE *pSamples, ULONG cSamples, BOOL bMove)
{
    m_FillInfo.pSamples = pSamples;
    m_FillInfo.cSamples = cSamples;
    m_FillInfo.bPremult = true;
    FillSamples(m_FillInfo);
    if (bMove) m_FillInfo.x += cSamples;
    return pSamples;
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::UnpackRect(const DXPACKEDRECTDESC *pDesc)
{
    DXPtrFillInfo FillInfo;
    FillInfo.pSamples = pDesc->pSamples;
    FillInfo.cSamples = pDesc->rect.right - pDesc->rect.left;
    FillInfo.x = pDesc->rect.left + m_LockedRect.left;
    FillInfo.bPremult = pDesc->bPremult;
    ULONG YLimit = pDesc->rect.bottom + m_LockedRect.top;
    for (FillInfo.y = pDesc->rect.top + m_LockedRect.top;
         FillInfo.y < YLimit;
         FillInfo.y++)
    {
        FillSamples(FillInfo);
        FillInfo.pSamples += FillInfo.cSamples;
    }
}

HRESULT CDXBaseARGBPtr::InitFromLock(const RECT & rect, ULONG /*ulTimeOut*/, DWORD dwLockFlags, REFIID riid, void ** ppv)
{
    HRESULT hr = S_OK;
    if (dwLockFlags & DXLOCKF_READWRITE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_LockedRect = rect;
        m_RunInfo.Count = rect.right - rect.left;
        if (m_pSurface->SampleFormatEnum() & DXPF_TRANSPARENCY)
        {
            m_RunInfo.Type = DXRUNTYPE_UNKNOWN;
        }
        else
        {
            m_RunInfo.Type = DXRUNTYPE_OPAQUE;
        }
        m_FillInfo.x = rect.left;
        m_FillInfo.y = rect.top;
        hr = QueryInterface(riid, ppv);
        if (SUCCEEDED(hr))
        {
            m_pSurface->GetControllingUnknown()->AddRef();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxtdbg.h ===
/*******************************************************************************
* DXTDbg.h *
*----------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTDbg_h
#define DXTDbg_h

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#define DXTDBG_FUNC_TRACE   1
#define DXTDBG_INFO         2

class CDXTDbgFlags
{
  public:
    DWORD m_F;
    CDXTDbgFlags()
    {
        m_F = 0;
        HKEY hkResult;
        DWORD dwDisposition;
        if( RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("DXTDbgFlags"), 0, NULL, 0,
                            KEY_ALL_ACCESS, NULL, &hkResult, &dwDisposition )
                            == ERROR_SUCCESS )
        {
            if( dwDisposition == REG_CREATED_NEW_KEY )
            {
                RegSetValueEx( hkResult, _T("Flags"), NULL, REG_DWORD, (PBYTE)&m_F, sizeof( m_F ) );
            }
            else
            {
                DWORD BuffSize = sizeof( m_F );
                RegQueryValueEx( hkResult, _T("Flags"), NULL, NULL, (PBYTE)&m_F, &BuffSize );
            }
            RegCloseKey( hkResult );
        }
    }
};

class CDXTDbgScope
{
  public:
    static CDXTDbgFlags m_DebugFlags; 
    PCHAR  m_pFuncName;
    CDXTDbgScope( PCHAR pFuncName )
    {
        m_pFuncName = pFuncName;
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "\nEntering Function: %s\n", m_pFuncName );
        }
    }
    ~CDXTDbgScope()
    {
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "Leaving Function: %s\n", m_pFuncName );
        }
    }
};

//=== User macros ==============================================================
#ifdef _DEBUG
#define DXTDBG_FUNC( name ) CDXTDbgScope DXTDbgScope( name ); 
#define DXTDBG_MSG0( reportType, format ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF0( reportType, format );
#define DXTDBG_MSG1( reportType, format, arg1 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF4( reportType, format, arg1, arg2, arg3, arg4 )
#else
#define DXTDBG_FUNC( name )
#define DXTDBG_MSG0( reportType, format )
#define DXTDBG_MSG1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 )
#endif

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxsurfb.h ===
/*******************************************************************************
* DXSurfB.h *
*----------*
*   Description:
*       This is the header file for the CDXBaseSurface implementation. It is
*   used as a base class to implement read-only procedural DXSurfaces.
*-------------------------------------------------------------------------------
*  Created By: RAL                                  Date: 02/12/1998
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/

#ifndef __DXSurfB_H__
#define __DXSurfB_H__

#include "dtbase.h"

class CDXBaseSurface;
class CDXBaseARGBPtr;

class ATL_NO_VTABLE CDXBaseSurface :
    public CDXBaseNTo1, 
    public IDXSurface,
    public IDXSurfaceInit
{
    /*=== ATL Setup ===*/
    public:
        BEGIN_COM_MAP(CDXBaseSurface)
        COM_INTERFACE_ENTRY(IDXSurface)
        COM_INTERFACE_ENTRY(IDXSurfaceInit)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
        END_COM_MAP()

    DECLARE_GET_CONTROLLING_UNKNOWN()

    /*=== Member Data ===*/
    public:
        ULONG           m_Height;
        ULONG           m_Width;
        DWORD           m_dwStatusFlags;
        HANDLE          m_hSemaphore;
        ULONG           m_ulLocks;
        ULONG           m_ulThreadsWaiting;
        CDXBaseARGBPtr  *m_pFreePtr;
        DWORD_PTR       m_dwAppData;
        CComAutoCriticalSection m_MPWorkProcCrit;   // See comments in LockSurface for details

        CDXBaseSurface();
        HRESULT FinalConstruct();
        void FinalRelease();

        //
        //  IDXBaseObject
        //
        STDMETHODIMP GetGenerationId(ULONG *pGenId);
        STDMETHODIMP IncrementGenerationId(BOOL bRefresh);
        STDMETHODIMP GetObjectSize(ULONG *pulze);

        //
        //  Overridden methods of DXTransform
        //
        STDMETHODIMP MapBoundsIn2Out(const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                     ULONG /*ulOutIndex*/, DXBNDS *pOutBounds );

        //
        //  IDXSurfaceInit
        //
        STDMETHODIMP InitSurface(IUnknown *pDirectDraw,
                                 const DDSURFACEDESC * pDDSurfaceDesc,
                                 const GUID * pFormatId,
                                 const DXBNDS *pBounds,
                                 DWORD dwFlags);
        //
        //  IDXSurface methods
        //
        STDMETHODIMP GetPixelFormat(GUID *pFormat, DXSAMPLEFORMATENUM *pSampleEnum);
        STDMETHODIMP GetBounds(DXBNDS *pBounds);
        STDMETHODIMP GetStatusFlags(DWORD * pdwStatusFlags);
        STDMETHODIMP SetStatusFlags(DWORD dwStatusFlags);
        STDMETHODIMP GetDirectDrawSurface(REFIID riid, void **ppSurface);
        STDMETHODIMP LockSurface(const DXBNDS *pBounds, ULONG ulTimeOut, DWORD dwFlags,
                                 REFIID riid, void **ppPointer, DWORD * pGenerationId);
        STDMETHODIMP SetAppData(DWORD_PTR dwAppData)
        {
            m_dwAppData = dwAppData;
            return S_OK;
        }
        STDMETHODIMP GetAppData(DWORD_PTR *pdwAppData)
        {
            if (DXIsBadWritePtr(pdwAppData, sizeof(*pdwAppData)))
            {
                return E_POINTER;
            }
            *pdwAppData = m_dwAppData;
            return S_OK;
        }


        //
        //  These methods aren't supported by procedural surfaces...
        //
        STDMETHODIMP GetColorKey(DXSAMPLE *pColorKey)
        {
            return E_NOTIMPL;
        }

        STDMETHODIMP SetColorKey(DXSAMPLE pColorKey)
        {
            return E_NOTIMPL;
        }

        STDMETHODIMP LockSurfaceDC(const DXBNDS *pBounds, ULONG ulTimeOut, DWORD dwFlags, IDXDCLock **ppDXLock)
        {
            return E_NOTIMPL;
        }

        //
        //  Surfaces should override this.
        //
        virtual ULONG OnGetObjectSize(void) { return sizeof(*this); }

        //
        //  This work procedure can be overridden by the derived class to improve performance
        //  or execution of the transform by directly producing data in large blocks if desired.
        //
        virtual HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
        {
            return DXBitBlt(OutputSurface(), WI.OutputBnds, this, WI.DoBnds, m_dwBltFlags, m_ulLockTimeOut);
        }

        //
        //  Pick interface needs to test procedural surface.
        //
        virtual HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec);

        //
        //  Helper functions
        //

        //  _EnterCritWith0PtrLocks()
        //
        //  This function is similar to calling Lock() except that it will wait until there
        //  are no pointers to the surface before returning.  This should be used whenever you
        //  are going to change the state of a surface, for example the size or some other
        //  property that the read pointers rely on.
        //
        //  WARNING:  You must be sure that one of the following is true:
        //      1) The objects critical section has NOT been taken prior to calling this function
        //   or 2) There are no pointers to the surface taken prior to calling this function.
        //
        //  Case 2 is useful in nested function calls.  If the outer function has already used this
        //  function to enter the critical section, then it is OK to use it on the inner nested
        //  function.  If the object's lock is taken, but there are outstanding pointers, YOU WILL DEADLOCK!
        //
        inline void _EnterCritWith0PtrLocks(void)
        {
            while (TRUE)
            {
                Lock();
                if (m_ulLocks == 0) break;
                m_ulThreadsWaiting++;
                Unlock();
                WaitForSingleObject(m_hSemaphore, INFINITE);
            }
        }
        //
        //  Virtual functions derived class MUST override
        //
        virtual const GUID & SurfaceCLSID() = 0;
        virtual HRESULT CreateARGBPointer(CDXBaseSurface * pSurface, CDXBaseARGBPtr ** ppPtr) = 0;
        virtual void DeleteARGBPointer(CDXBaseARGBPtr *pPtr) = 0;
    
        //
        //  Class may override this virtual function to return a more accurate enum
        //  for example, no transparency or translucency.
        //
        virtual DXSAMPLEFORMATENUM SampleFormatEnum()
        {
            return (DXSAMPLEFORMATENUM)(DXPF_NONSTANDARD | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY);
        }

        //
        //  Class may override this virtual function to perform necessary computations
        //  when the size of the surface changes.  The base class will only call this
        //  function from InitSurface.  You may choose to call it from other interfaces
        //  you implement, for example IDXTScaleOutput.
        //
        //  This function will be called with the critical section taken and 0 outstanding
        //  surface pointers (_EnterCritWith0PtrLocks).
        //  
        virtual HRESULT OnSetSize(ULONG Width, ULONG Height)
        {
            if (m_Width != Width || m_Height != Height)
            {
                m_Width = Width;
                m_Height = Height;
                m_dwGenerationId++;
            }
            return S_OK;
        }

        //
        //  Internal functions for base class
        //
        void _InternalUnlock(CDXBaseARGBPtr *pPtrToUnlock);

        //
        //  Static member function for registering surface
        //
        static HRESULT RegisterSurface(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                                       ULONG cCatReq, const CATID * pCatReq, BOOL bRegister);
};

struct DXPtrFillInfo
{
    DXBASESAMPLE *  pSamples;
    ULONG           cSamples;
    ULONG           x;
    ULONG           y;
    BOOL            bPremult;
};


class CDXBaseARGBPtr : public IDXARGBReadPtr
{
public:
    CDXBaseARGBPtr    * m_pNext;
    CDXBaseSurface    * m_pSurface;
    ULONG               m_ulRefCount;
    DXPtrFillInfo       m_FillInfo;
    RECT                m_LockedRect;
    DXRUNINFO           m_RunInfo;
    
    CDXBaseARGBPtr(CDXBaseSurface *pSurface) :
        m_pSurface(pSurface),
        m_pNext(NULL),
        m_ulRefCount(0) {}

    //
    //  IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    //
    //  IDXARGBReadPtr
    //
    HRESULT STDMETHODCALLTYPE GetSurface(REFIID riid, void **ppSurface);
    DXSAMPLEFORMATENUM STDMETHODCALLTYPE GetNativeType(DXNATIVETYPEINFO *pInfo);
    void STDMETHODCALLTYPE Move(long cSamples);
    void STDMETHODCALLTYPE MoveToRow(ULONG y);
    void STDMETHODCALLTYPE MoveToXY(ULONG x, ULONG y);
    ULONG STDMETHODCALLTYPE MoveAndGetRunInfo(ULONG Row, const DXRUNINFO ** ppInfo);
    DXSAMPLE *STDMETHODCALLTYPE Unpack(DXSAMPLE *pSamples, ULONG cSamples, BOOL bMove);
    DXPMSAMPLE *STDMETHODCALLTYPE UnpackPremult(DXPMSAMPLE *pSamples, ULONG cSamples, BOOL bMove);
    void STDMETHODCALLTYPE UnpackRect(const DXPACKEDRECTDESC *pDesc);

    //
    //  Virtual function derived class MUST override
    //
    virtual void FillSamples(const DXPtrFillInfo & FillInfo) = 0;

    //
    //  Virtual functions derived class MAY want to override (but you will need to call the base class too)
    //
    virtual HRESULT InitFromLock(const RECT & rect, ULONG ulTimeOut, DWORD dwLockFlags, REFIID riid, void ** ppv);
};

//=== Macro Definitions ============================================

#define DECLARE_REGISTER_DX_SURFACE(id)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            CATID cat[2]; \
            cat[0] = CATID_DXSurface; \
            cat[1] = CATID_DXImageTransform; \
            return RegisterSurface(GetObjectCLSID(), (id), 2, cat, 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_AUTHORING_SURFACE(id)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            CATID cat[3]; \
            cat[0] = CATID_DXSurface; \
            cat[1] = CATID_DXImageTransform; \
            cat[2] = CATID_DXAuthoringTransform; \
            return RegisterSurface(GetObjectCLSID(), (id), 3, cat, 0, NULL, bRegister); \
        } 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxtguid.c ===
//
//  This .CPP file should be included once in your project.  It defines all GUIDs
//  used by DXTransforms as well as the Pixel formats for DX Surfaces
//

#define DX_DECLARE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
//
//  Pixel format definitions
//
// {e436eb78-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F3-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB2, 
0xbbf7d3f3, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb79-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {e436eb7a-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F6-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB332, 
0xbbf7d3f6, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D3F7-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB4444, 
0xbbf7d3f7, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7b-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F9-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR565, 
0xbbf7d3f9, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7c-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FB-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB1555, 
0xbbf7d3fb, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7d-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FD-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR24, 
0xbbf7d3fd, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7e-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FF-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR32, 
0xbbf7d3ff, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D401-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ABGR32, 
0xbbf7d401, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {773c9ac0-3274-11d0-B724-00aa006c1A01}
DX_DECLARE_GUID(DDPF_ARGB32, 
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 );
// {BBF7D403-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_PMARGB32, 
0xbbf7d403, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94E-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A1, 
0x7846f94e, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94F-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A2, 
0x7846f94f, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F950-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A4, 
0x7846f950, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F951-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A8, 
0x7846f951, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F952-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z8, 
0x7846f952, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F953-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z16, 
0x7846f953, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F954-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z24, 
0x7846f954, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F955-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z32, 
0x7846f955, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
//
//  Component categories
//
// {C501EDBE-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXImageTransform, 
0xc501edbe, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {C501EDBF-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DX3DTransform, 
0xc501edbf, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {ACAC94FC-E5CF-11d1-9066-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXAuthoringTransform,
0xacac94fc, 0xe5cf, 0x11d1, 0x90, 0x66, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {52BA7097-B52C-11d1-81CB-0000F87557DB}
DX_DECLARE_GUID(CATID_DXSurface, 
0x52ba7097, 0xb52c, 0x11d1, 0x81, 0xcb, 0x0, 0x0, 0xf8, 0x75, 0x57, 0xdb);

//
//  Service IDs.  
//
//  NOTE:  The service ID for direct draw is == IID_IDirectDraw3 for compatibility
//         with trident service ID's.  This should be the service ID for DirectDraw
//         no matter what version.
//
DX_DECLARE_GUID(SID_SDirectDraw,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
//
//  The service ID for Direct 3D Retain Mode is the same as IID_IDirect3DRM
//  
DX_DECLARE_GUID(SID_SDirect3DRM,
0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

//
//  The service ID for DirectDraw3 is the same as IID_IDirectDraw3
//  
DX_DECLARE_GUID(SID_SDirectDraw3,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\gaunt.h ===
#define IEVER_PRODUCTBUILD	2512
#define IEVER_PRODUCTBUILD_QFE	0001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxterror.h ===
/*******************************************************************************
* DXTError.h *
*------------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTError_h
#define DXTError_h

#ifndef _WINERROR_
#include <winerror.h>
#endif

//=== New codes ===============================================================
#define FACILITY_DXTRANS    0x87A

/*** DXTERR_UNINITIALIZED
*   The object (transform, surface, etc.) has not been properly initialized
*/
#define DXTERR_UNINITIALIZED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 1)

/*** DXTERR_ALREADY_INITIALIZED
*   The object (surface) has already been properly initialized
*/
#define DXTERR_ALREADY_INITIALIZED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 2)

/*** DXTERR_UNSUPPORTED_FORMAT
*   The caller has specified an unsupported format
*/
#define DXTERR_UNSUPPORTED_FORMAT   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 3)

/*** DXTERR_COPYRIGHT_IS_INVALID
*   The caller has specified an unsupported format
*/
#define DXTERR_COPYRIGHT_IS_INVALID   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 4)

/*** DXTERR_INVALID_BOUNDS
*   The caller has specified invalid bounds for this operation
*/
#define DXTERR_INVALID_BOUNDS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 5)

/*** DXTERR_INVALID_FLAGS
*   The caller has specified invalid flags for this operation
*/
#define DXTERR_INVALID_FLAGS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 6)

/*** DXTERR_OUTOFSTACK
*   There was not enough available stack space to complete the operation 
*/
#define DXTERR_OUTOFSTACK   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 7)

/*** DXTERR_REQ_IE_DLLNOTFOUND
*   Unable to load a required Internet Explorer DLL  
*/
#define DXTERR_REQ_IE_DLLNOTFOUND   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 8)

/*** DXT_S_HITOUTPUT
*   The specified point intersects the generated output
*/
#define DXT_S_HITOUTPUT   MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_DXTRANS, 1)

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\dxtmpl.h ===
/*****************************************************************************
* DXTmpl.h *
*-----------*
*       This is the header file contains the DX collection class templates. It
*   has been derived from the MFC collection templates for compatibility.
*-----------------------------------------------------------------------------
*   Created by: Ed Connell                     Date: 05/17/95
*
*****************************************************************************/
#ifndef DXTmpl_h
#define DXTmpl_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STRING
#include <string.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _INC_SEARCH
#include <search.h>
#endif

#define DXASSERT_VALID( pObj )

/////////////////////////////////////////////////////////////////////////////
typedef void* DXLISTPOS;
typedef DWORD DXLISTHANDLE;

#define DX_BEFORE_START_POSITION ((void*)-1L)

inline BOOL DXIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
template<class TYPE>
inline void DXConstructElements(TYPE* pElements, int nCount)
{
    _ASSERT( nCount == 0 ||
             DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
}

template<class TYPE>
inline void DXDestructElements(TYPE* pElements, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

template<class TYPE>
inline void DXCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
}

template<class TYPE, class ARG_TYPE>
BOOL DXCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    _ASSERT( DXIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    _ASSERT( DXIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT DXHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(void*)(DWORD)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CDXPlex

struct CDXPlex    // warning variable length structure
{
    CDXPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CDXPlex* PASCAL Create( CDXPlex*& pHead, UINT nMax, UINT cbElement )
    {
        CDXPlex* p = (CDXPlex*) new BYTE[sizeof(CDXPlex) + nMax * cbElement];
        if (p == NULL)
            return NULL;
        p->nMax = nMax;
        p->nCur = 0;
        p->pNext = pHead;
        pHead = p;  // change head (adds in reverse order for simplicity)
        return p;
    }

    void FreeDataChain()
    {
        CDXPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CDXPlex* pNext = p->pNext;
            delete bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXArray
{
public:
// Construction
    CDXArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    void SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CDXArray& src);
    void Copy(const CDXArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void RemoveAt(int nIndex, int nCount = 1);
    void InsertAt(int nStartIndex, CDXArray* pNewArray);
    void Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CDXArray();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CDXArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CDXArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::CDXArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::~CDXArray()
{
    DXASSERT_VALID( this );

    if (m_pData != NULL)
    {
        DXDestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    DXASSERT_VALID( this );
    _ASSERT( nNewSize >= 0 );

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            DXDestructElements(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        _ASSERT( nNewSize <= SIZE_T_MAX/sizeof(TYPE) );    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        DXConstructElements(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            DXConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            DXDestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        _ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        _ASSERT( nNewMax <= SIZE_T_MAX/sizeof(TYPE) ); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        // oh well, it's better than crashing
        if (pNewData == NULL)
            return;

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

        // construct remaining elements
        _ASSERT( nNewSize > m_nSize );
        DXConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

template<class TYPE, class ARG_TYPE>
int CDXArray<TYPE, ARG_TYPE>::Append(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);
    DXCopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
    return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Copy(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot copy to itself

    SetSize(src.m_nSize);
    DXCopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::FreeExtra()
{
    DXASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        _ASSERT( m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];

            // oh well, it's better than crashing
            if (pNewData == NULL)
                return;

            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nSize)
        SetSize(nIndex+1, -1);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );    // will expand to meet need
    _ASSERT( nCount > 0 );     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount, -1);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(TYPE));

        // re-init slots we copied from
        DXConstructElements(&m_pData[nIndex], nCount);
    }

    // insert new value in the gap
    _ASSERT( nIndex + nCount <= m_nSize );
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    _ASSERT( nCount >= 0 );
    _ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    DXDestructElements(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CDXArray* pNewArray)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewArray );
    _ASSERT( nStartIndex >= 0 );

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    DXASSERT_VALID( this );
    _ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, sizeof(TYPE), compare );
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_pData == NULL)
    {
        _ASSERT( m_nSize == 0 );
        _ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        _ASSERT( m_nSize >= 0 );
        _ASSERT( m_nMaxSize >= 0 );
        _ASSERT( m_nSize <= m_nMaxSize );
        _ASSERT( DXIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE), TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CDXList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    DXLISTPOS AddHead(ARG_TYPE newElement);
    DXLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CDXList* pNewList);
    void AddTail(CDXList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    DXLISTPOS GetHeadPosition() const;
    DXLISTPOS GetTailPosition() const;
    TYPE& GetNext(DXLISTPOS& rPosition); // return *Position++
    TYPE GetNext(DXLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(DXLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(DXLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(DXLISTPOS position);
    TYPE GetAt(DXLISTPOS position) const;
    void SetAt(DXLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(DXLISTPOS position);

    // inserting before or after a given position
    DXLISTPOS InsertBefore(DXLISTPOS position, ARG_TYPE newElement);
    DXLISTPOS InsertAfter(DXLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    DXLISTPOS Find(ARG_TYPE searchValue, DXLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    DXLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CDXList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CDXList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetHead()
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetHead() const
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetTail()
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetTail() const
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (DXLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (DXLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CDXList<TYPE, ARG_TYPE>::SetAt(DXLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CDXList( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAll()
{
    DXASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        DXDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::~CDXList()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CDXPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CDXPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CDXPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CNode*
CDXList<TYPE, ARG_TYPE>::NewNode(CDXList::CNode* pPrev, CDXList::CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CDXPlex* pNewBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    _ASSERT( m_pNodeFree != NULL );  // we must have something

    CDXList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow

    DXConstructElements(&pNode->data, 1);
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::FreeNode(CDXList::CNode* pNode)
{
    DXDestructElements(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddHead(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    DXLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddTail(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements
    DXLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveHead()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveTail()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertBefore(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeHead );
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertAfter(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeTail );
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAt(DXLISTPOS position)
{
    DXASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (DXLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, DXLISTPOS startAfter) const
{
    DXASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (DXCompareElements(&pNode->data, &searchValue))
            return (DXLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        _ASSERT( m_pNodeHead == NULL );
        _ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CDXMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CDXMap( int nBlockSize = 10 );

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    DXLISTPOS GetStartPosition() const;
    void GetNextAssoc(DXLISTPOS& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const;
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CDXMap();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline DXLISTPOS CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : DX_BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CDXMap( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    DXASSERT_VALID( this );
    _ASSERT( m_nCount == 0 );
    _ASSERT( nHashSize > 0 );

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];

        // oh well, it's better than crashing
        if (m_pHashTable == NULL)
            return;

        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }
    m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    DXASSERT_VALID( this );

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
              pAssoc = pAssoc->pNext)
            {
                DXDestructElements(&pAssoc->value, 1);
                DXDestructElements(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CDXMap()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CDXPlex* newBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CDXMap::CAssoc));
        // chain them into free list
        CDXMap::CAssoc* pAssoc = (CDXMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    _ASSERT( m_pFreeList != NULL );  // we must have something

    CDXMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow
    DXConstructElements(&pAssoc->key, 1);
    DXConstructElements(&pAssoc->value, 1);   // special construct values
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CDXMap::CAssoc* pAssoc)
{
    DXDestructElements(&pAssoc->value, 1);
    DXDestructElements(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = DXHashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    DXASSERT_VALID( this );

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[DXHashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(DXLISTPOS& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    DXASSERT_VALID( this );
    _ASSERT( m_pHashTable != NULL );  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    _ASSERT( pAssocRet != NULL );

    if (pAssocRet == (CAssoc*) DX_BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        _ASSERT( pAssocRet != NULL );  // must find something
    }

    // find next association
    _ASSERT( DXIsValidAddress(pAssocRet, sizeof(CAssoc), TRUE ));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (DXLISTPOS) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
    _ASSERT( m_nHashTableSize > 0 );
    _ASSERT( (m_nCount == 0 || m_pHashTable != NULL) );
        // non-empty map should have hash table
}
#endif //_DEBUG

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\exdispid.h ===
#ifndef EXDISPID_H_
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: exdispid.h
//
//--------------------------------------------------------------------------


//
// Dispatch IDS for IExplorer Dispatch Events.
//
#define DISPID_BEFORENAVIGATE     100   // this is sent before navigation to give a chance to abort
#define DISPID_NAVIGATECOMPLETE   101   // in async, this is sent when we have enough to show
#define DISPID_STATUSTEXTCHANGE   102
#define DISPID_QUIT               103
#define DISPID_DOWNLOADCOMPLETE   104
#define DISPID_COMMANDSTATECHANGE 105
#define DISPID_DOWNLOADBEGIN      106
#define DISPID_NEWWINDOW          107   // sent when a new window should be created
#define DISPID_PROGRESSCHANGE     108   // sent when download progress is updated
#define DISPID_WINDOWMOVE         109   // sent when main window has been moved
#define DISPID_WINDOWRESIZE       110   // sent when main window has been sized
#define DISPID_WINDOWACTIVATE     111   // sent when main window has been activated
#define DISPID_PROPERTYCHANGE     112   // sent when the PutProperty method is called
#define DISPID_TITLECHANGE        113   // sent when the document title changes
#define DISPID_TITLEICONCHANGE    114   // sent when the top level window icon may have changed.

#define DISPID_FRAMEBEFORENAVIGATE    200
#define DISPID_FRAMENAVIGATECOMPLETE  201
#define DISPID_FRAMENEWWINDOW         204

#define DISPID_BEFORENAVIGATE2      250   // hyperlink clicked on
#define DISPID_NEWWINDOW2           251
#define DISPID_NAVIGATECOMPLETE2    252   // UIActivate new document
#define DISPID_ONQUIT               253
#define DISPID_ONVISIBLE            254   // sent when the window goes visible/hidden
#define DISPID_ONTOOLBAR            255   // sent when the toolbar should be shown/hidden
#define DISPID_ONMENUBAR            256   // sent when the menubar should be shown/hidden
#define DISPID_ONSTATUSBAR          257   // sent when the statusbar should be shown/hidden
#define DISPID_ONFULLSCREEN         258   // sent when kiosk mode should be on/off
#define DISPID_DOCUMENTCOMPLETE     259   // new document goes ReadyState_Complete
#define DISPID_ONTHEATERMODE        260   // sent when theater mode should be on/off
#define DISPID_ONADDRESSBAR         261   // sent when the address bar should be shown/hidden
#define DISPID_WINDOWSETRESIZABLE   262   // sent to set the style of the host window frame
#define DISPID_WINDOWCLOSING        263   // sent before script window.close closes the window 
#define DISPID_WINDOWSETLEFT        264   // sent when the put_left method is called on the WebOC
#define DISPID_WINDOWSETTOP         265   // sent when the put_top method is called on the WebOC
#define DISPID_WINDOWSETWIDTH       266   // sent when the put_width method is called on the WebOC
#define DISPID_WINDOWSETHEIGHT      267   // sent when the put_height method is called on the WebOC 
#define DISPID_CLIENTTOHOSTWINDOW   268   // sent during window.open to request conversion of dimensions
#define DISPID_SETSECURELOCKICON    269   // sent to suggest the appropriate security icon to show
#define DISPID_FILEDOWNLOAD         270   // Fired to indicate the File Download dialog is opening
#define DISPID_NAVIGATEERROR        271   // Fired to indicate the a binding error has occured
#define DISPID_PRIVACYIMPACTEDSTATECHANGE   272  // Fired when the user's browsing experience is impacted

// Printing events
#define DISPID_PRINTTEMPLATEINSTANTIATION   225   // Fired to indicate that a print template is instantiated
#define DISPID_PRINTTEMPLATETEARDOWN        226   // Fired to indicate that a print templete is completely gone 
#define DISPID_UPDATEPAGESTATUS             227   // Fired to indicate that the spooling status has changed

// define the events for the shell wiwndow list
#define DISPID_WINDOWREGISTERED     200     // Window registered
#define DISPID_WINDOWREVOKED        201     // Window Revoked

#define DISPID_RESETFIRSTBOOTMODE       1
#define DISPID_RESETSAFEMODE            2
#define DISPID_REFRESHOFFLINEDESKTOP    3
#define DISPID_ADDFAVORITE              4
#define DISPID_ADDCHANNEL               5
#define DISPID_ADDDESKTOPCOMPONENT      6
#define DISPID_ISSUBSCRIBED             7
#define DISPID_NAVIGATEANDFIND          8
#define DISPID_IMPORTEXPORTFAVORITES    9
#define DISPID_AUTOCOMPLETESAVEFORM     10
#define DISPID_AUTOSCAN                 11
#define DISPID_AUTOCOMPLETEATTACH       12
#define DISPID_SHOWBROWSERUI            13
#define DISPID_SHELLUIHELPERLAST        13

#define DISPID_ADVANCEERROR             10
#define DISPID_RETREATERROR             11
#define DISPID_CANADVANCEERROR          12
#define DISPID_CANRETREATERROR          13
#define DISPID_GETERRORLINE             14
#define DISPID_GETERRORCHAR             15
#define DISPID_GETERRORCODE             16
#define DISPID_GETERRORMSG              17
#define DISPID_GETERRORURL              18
#define DISPID_GETDETAILSSTATE          19
#define DISPID_SETDETAILSSTATE          20
#define DISPID_GETPERERRSTATE           21
#define DISPID_SETPERERRSTATE           22
#define DISPID_GETALWAYSSHOWLOCKSTATE   23

// Dispatch IDS for ShellFavoritesNameSpace Dispatch Events.
//
#define DISPID_FAVSELECTIONCHANGE       1
#define DISPID_SELECTIONCHANGE          2
#define DISPID_DOUBLECLICK              3
#define DISPID_INITIALIZED              4

#define DISPID_MOVESELECTIONUP          1
#define DISPID_MOVESELECTIONDOWN        2
#define DISPID_RESETSORT                3
#define DISPID_NEWFOLDER                4
#define DISPID_SYNCHRONIZE              5
#define DISPID_IMPORT                   6
#define DISPID_EXPORT                   7
#define DISPID_INVOKECONTEXTMENU        8
#define DISPID_MOVESELECTIONTO          9
#define DISPID_SUBSCRIPTIONSENABLED     10
#define DISPID_CREATESUBSCRIPTION       11
#define DISPID_DELETESUBSCRIPTION       12
#define DISPID_SETROOT                  13
#define DISPID_ENUMOPTIONS              14
#define DISPID_SELECTEDITEM             15
#define DISPID_ROOT                     16
#define DISPID_DEPTH                    17
#define DISPID_MODE                     18
#define DISPID_FLAGS                    19
#define DISPID_TVFLAGS                  20
#define DISPID_NSCOLUMNS                21
#define DISPID_COUNTVIEWTYPES           22
#define DISPID_SETVIEWTYPE              23
#define DISPID_SELECTEDITEMS            24
#define DISPID_EXPAND                   25
#define DISPID_UNSELECTALL              26

#define EXDISPID_H_
#endif // EXDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\hlguids.h ===
/****************************************************************************
    hlguids.h

    Copyright (c) 1995-1998 Microsoft Corporation

    This file defines or declares (according to standard DEFINE_GUID protocol)
    the GUIDs used to interact with hyperlinks.

    NOTE: This header file is used by non-Office as well as Office parties to
    access functionality provided by hlink dll and hlinkprx dll.
****************************************************************************/

#ifndef HLGUIDS_H
#define HLGUIDS_H

/****************************************************************************
    hlink GUIDs
****************************************************************************/

// On Windows, we get these from uuid3.lib
#if MAC

/* 79eac9c0-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IBinding,
    0x79eac9c0,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c1-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IBindStatusCallback,
    0x79eac9c1,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c9-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IPersistMoniker,
    0x79eac9c9,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

#endif /* MAC */

/* 79eac9c2-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkSite,
    0x79eac9c2,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c3-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlink,
    0x79eac9c3,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c4-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkTarget,
    0x79eac9c4,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c5-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkFrame,
    0x79eac9c5,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c6-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IEnumHLITEM,
    0x79eac9c6,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c7-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkBrowseContext,
    0x79eac9c7,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9cb-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IExtensionServices,
    0x79eac9cb,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9d0-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(CLSID_StdHlink,
    0x79eac9d0,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9d1-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(CLSID_StdHlinkBrowseContext,
    0x79eac9d1,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* The GUID of the service SID_SHlinkFrame is the same as IID_IHlinkFrame */
/* 79eac9c5-baf9-11ce-8c82-00aa004ba90b */
#ifndef SID_SHlinkFrame                   /* Usually #defined in hlink.h */
DEFINE_GUID(SID_SHlinkFrame,
    0x79eac9c5,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);
#endif /* ! SID_SHlinkFrame */

/* The GUID of the service SID_SContainer */
/* 79eac9c4-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(SID_SContainer,
    0x79eac9c4,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);
#endif // HLGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\hlinkez.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: hlinkez.h
//
//--------------------------------------------------------------------------

struct IBindStatusCallback;

HRESULT HlinkSimpleNavigateToString(
    /* [in] */ LPCWSTR szTarget,      // required - target document - null if local jump w/in doc
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szAdditionalParams,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

HRESULT HlinkSimpleNavigateToMoniker(
    /* [in] */ IMoniker *pmkTarget,   // required - target document - (may be null if local jump w/in doc)
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szAddParams,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

HRESULT HlinkGoBack(IUnknown *pUnk);
HRESULT HlinkGoForward(IUnknown *pUnk);
HRESULT HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);
HRESULT HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\idispids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: idispids.h
//
//--------------------------------------------------------------------------

#define DISPID_READYSTATE                             (-525)
#define DISPID_READYSTATECHANGE                       (-609)
#define DISPID_AMBIENT_TRANSFERPRIORITY               (-728)
#define DISPID_AMBIENT_OFFLINEIFNOTCONNECTED          (-5501)
#define DISPID_AMBIENT_SILENT                         (-5502)

// Until these appear in OLECTL.H
#ifndef DISPID_AMBIENT_CODEPAGE
#define DISPID_AMBIENT_CODEPAGE         (-725)
#define DISPID_AMBIENT_CHARSET          (-727)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\httprequestid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows HTTP Services (WinHTTP)
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------


#ifndef __HTTPREQUESTID_H__
#define __HTTPREQUESTID_H__

#define DISPID_HTTPREQUEST_BASE                     0x00000001


#define DISPID_HTTPREQUEST_OPEN                     (DISPID_HTTPREQUEST_BASE)
#define DISPID_HTTPREQUEST_SETREQUESTHEADER         (DISPID_HTTPREQUEST_BASE + 1)
#define DISPID_HTTPREQUEST_GETRESPONSEHEADER        (DISPID_HTTPREQUEST_BASE + 2)
#define DISPID_HTTPREQUEST_GETALLRESPONSEHEADERS    (DISPID_HTTPREQUEST_BASE + 3)
#define DISPID_HTTPREQUEST_SEND                     (DISPID_HTTPREQUEST_BASE + 4)
#define DISPID_HTTPREQUEST_OPTION                   (DISPID_HTTPREQUEST_BASE + 5)
#define DISPID_HTTPREQUEST_STATUS                   (DISPID_HTTPREQUEST_BASE + 6)
#define DISPID_HTTPREQUEST_STATUSTEXT               (DISPID_HTTPREQUEST_BASE + 7)
#define DISPID_HTTPREQUEST_RESPONSETEXT             (DISPID_HTTPREQUEST_BASE + 8)
#define DISPID_HTTPREQUEST_RESPONSEBODY             (DISPID_HTTPREQUEST_BASE + 9)
#define DISPID_HTTPREQUEST_RESPONSESTREAM           (DISPID_HTTPREQUEST_BASE + 10)
#define DISPID_HTTPREQUEST_ABORT                    (DISPID_HTTPREQUEST_BASE + 11)
#define DISPID_HTTPREQUEST_SETPROXY                 (DISPID_HTTPREQUEST_BASE + 12)
#define DISPID_HTTPREQUEST_SETCREDENTIALS           (DISPID_HTTPREQUEST_BASE + 13)
#define DISPID_HTTPREQUEST_WAITFORRESPONSE          (DISPID_HTTPREQUEST_BASE + 14)
#define DISPID_HTTPREQUEST_SETTIMEOUTS              (DISPID_HTTPREQUEST_BASE + 15)
#define DISPID_HTTPREQUEST_SETCLIENTCERTIFICATE     (DISPID_HTTPREQUEST_BASE + 16)
#define DISPID_HTTPREQUEST_SETAUTOLOGONPOLICY       (DISPID_HTTPREQUEST_BASE + 17)

#endif // __HTTPREQUESTID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\ieverp.h ===
// DO NOT Edit this file w/o consulting with reinerf (mailto:reinerf)

#define VER_MAJOR_PRODUCTVER		6
#define VER_MINOR_PRODUCTVER		0

#undef VER_PRODUCTBUILD 
#define VER_PRODUCTBUILD            /* IE */   2800

#define VER_PRODUCTVERSION		VER_MAJOR_PRODUCTVER,VER_MINOR_PRODUCTVER,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W		(0x0600)
#define VER_PRODUCTVERSION_DW		(0x06000000 | VER_PRODUCTBUILD)


// READ THIS

// Do not change VER_PRODUCTVERSION_STRING.
//
//       Again
//
// Do not change VER_PRODUCTVERSION_STRING.
//
//       One more time
//
// Do not change VER_PRODUCTVERSION_STRING.
//
// ntverp.h will do the right thing wrt the minor version #'s by stringizing
// the VER_PRODUCTBUILD and VER_PRODUCTBUILD_QFE values and concatenating them to
// the end of VER_PRODUCTVERSION_STRING.  VER_PRODUCTVERSION_STRING only needs
// is the major product version #'s. (currently, 5.00)

#define VER_PRODUCTBETA_STR		/* Win9x */  ""
#define VER_PRODUCTVERSION_STRING	"6.00"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\iehelpid.h ===
//+-------------------------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//
//  Contents:   Helpids for iexplore.hlp.  iexplore.hlp only contains help for the binaries
//  distributed with a browser-only install of IE, such as:
//
//      shdocvw.dll
//      browseui.dll
//      inetcpl.cpl
//
//  Pure shell components, such as shell32.dll, use other .hlp files, such as shell.hlp,
//  and have their help ids defined in other headers (see shellids.h and help.h).
//+-------------------------------------------------------------------------------------------

#define IDH_IE_RUN_COMMAND              50000 // was 0x3000

// For Add To Favorites
#define IDH_BROWSELIST                  50001 // was 0x3001
#define IDH_NEWFOLDER                   50002 // was 0x3002
#define IDH_CREATEIN                    50003 // was 0x3003
#define IDH_NAMEEDIT                    50004 // was 0x3004

// For Open dialog
#define IDH_RUNBROWSE                   50005 // was 0x3005

// For Organize Favorites
#define IDH_ORG_FAVORITES_MOVE          50006 // was 0x3050
#define IDH_ORG_FAVORITES_RENAME        50007 // was 0x3051
#define IDH_ORG_FAVORITES_DELETE        50008 // was 0x3052
#define IDH_ORG_FAVORITES_OPEN          50009 // was 0x3053
#define IDH_ORG_FAVORITES_CLOSE         50010 // was 0x3054

//For Volvo QFE
#define IDH_AUTOCONFIG_BUTTON           50011 // was 0x3055
#define IDH_AUTOCONFIG_TEXT             50012 // was 0x3056
#define IDH_OPTS_CONNX_AUTOCNCT_REFRESH 50013 // was 0x3070

//Trident print features
#define IDH_PRINT_SCREEN                50014 // was 0x3057
#define IDH_PRINT_SEL_FRAME             50015 // was 0x3058
#define IDH_PRINT_ALL_FRAME             50016 // was 0x3059
#define IDH_PRINT_LINKS                 50017 // was 0x3060
#define IDH_PRINT_SHORTCUTS             50020 // was 5002



//Find Text dialog box
#define IDH_FIND_WHOLEA                  50022 // was 0x3063
#define IDH_FIND_CASEA                   50023 // was 0x3064
#define IDH_FIND_UPA                     50024 // was 0x3065
#define IDH_FIND_DOWNA                   50025 // was 0x3066
#define IDH_FIND_NEXTA                   50026 // was 0x3067
#define IDH_FIND_WHATA                   50027 // was 0x3068


//General Tab, Language button
#define IDH_OPTS_GEN_LANG_BUT           50028 // was 0x3071

//Language Preferences dialog box
#define IDH_LANG_PREFS_LIST             50029 // was 0x3075 //Language label and list box
#define IDH_LANG_PREFS_UP               50030 // was 0x3076 //Move up button
#define IDH_LANG_PREFS_DOWN             50031 // was 0x3077 //Move Down button
#define IDH_LANG_PREFS_REMOVE           50032 // was 0x3078 //Remove button
#define IDH_LANG_PREFS_ADD              50033 // was 0x3070 //Add button




//Content tab, Personal Information: Personal Profile and Microsoft Wallet
#define IDH_EDIT_PROFILE_BTN            50198 // Edit Profiles button

#define IDH_ADD_LANGUAGE_LANGUAGE_LIST  50037 // was 0x3102 //in Add Languages dialog box, Language list
#define IDH_ADD_LANGUAGE_USER_DEFINED   50038 // was 0x3103  //in Add Languages dialog box, User Defined label and text box

//Client Authentication dialog box
#define  IDH_CLIENT_AUTHENTICATION_LIST 50039 // was 0x3100         //Identification label, text, and list area
#define IDH_CLIENT_AUTHENTICATION_CERT_PROPS    50040  // was 0x3101 //View button

#define IDH_GROUPBOX                    50041 // was 1

///////////////////******************       Advanced tab, Advanced list


//Advanced Tab, Advanced List
//Multimedia
#define IDH_MM_PIC                      50042 // was 3 //Show Pictures
#define IDH_MM_ANIM                     50176 //Play animations
#define IDH_MM_SOUND                    50043 // was 4 //Play Sounds
#define IDH_MM_VIDEO                    50044 // was 5 //play videos
#define IDH_APPEAR_COLOR                50045 // was 6
#define IDH_SMART_DITH                  50177 //Smart dithering
#define IDH_MB_NO_ONLINE_CONTENT        50194 // MediaBar: Don't display online media content in the media bar 
//Browsing
#define IDH_DOWNLOAD_COMP                 50492 //Notify when downloads complete
#define IDH_AUTOCOMP                    50180 //Use AutoComplete
#define IDH_ADD_URL                     50111 // was 79//show friendly urls
#define IDH_ADD_SMOOTH                  50107 // was 75//use smooth scrolling
#define IDH_ADD_LINK                    50112 // was 80//highlight links
#define IDH_NEW_PROCESS                 50178 //Browse in a new process
#define IDH_CHANNELLOG                  50179 //Enable page hit counting
#define IDH_ENABLE_SUB_UPDATES          50181 //Enable scheduled subscription updates
#define IDH_UPDATE_SUB_NEW_PROC         50182 //Update subscriptions in a new process
//Security
#define IDH_PCT_ALLOW                   50130 // was 99//pct 1.0
#define IDH_SSL2_ALLOW                  50128 // was 97//ssl 3.0
#define IDH_SSL3_ALLOW                  50129 // was 98// ssl 3.0
#define IDH_CRYPT_NOSAVE_SSL            50127 // was 96//do not save pages to disk
#define IDH_PRIV_VIEW                   50089 // was 54//warn if changing between secure and unsecure
#define IDH_CHK_CERT_REVOC              50184 // Check for publisher'scertificate revocation
#define IDH_PRIV_INVALID                50119 // was 87//Warn about invalid site certs
#define IDH_TAKE_COOKIES_ALWAYS         50189 //Always accept cookies// Now: Allow cookies that are stored on your computer
#define IDH_PRIV_COOKIE                 50090 // was 55// prompt before accepting cookies //Now: Allow per-session cookies (not stored)
#define IDH_DISABLE_COOKIES             50190 //Disable all cookies// obsolete

//Java VM
#define IDH_ADD_JAVA_COMP               50110 // was 78//JAVA JIT complier enabled
#define IDH_ADD_JAVA_LOG                50109 // was 77//java logging enabled

//Printing
#define IDH_PRINT_BKGRND                50191 //Print background colors and images

//Searching
#define IDH_AUTOSCAN                    50192 //Autoscan common root domains
#define IDH_SEARCH_URL_FAILS            50193 //Search when URL fails; never, always, always

//Toolbar
#define IDH_TOOL_STD                    50048 // was 9 //small icons




#define IDH_RESTORE_DEFS            50196 //Restore Defaults button at bottom of advanced tab

////////////////******       End of Advanced tab **********////////////////////////////

#define IDH_APPEAR_OPTION               50046 // was 7
#define IDH_APPEAR_LINK                 50047 // was 8
#define IDH_FONT_INT                    50055 // was 16
#define IDH_FONT_MIME                   50056 // was 17
#define IDH_OPTS_GEN_FONTS_FONTSIZE     50057 // was 5003
#define IDH_CHAR_SET                    50058 // was 18
#define IDH_INTL_DEFAULT                50059 // was 19
#define IDH_INTL_FONT_PROP              50060 // was 21
#define IDH_INTL_FONT_FIXED             50061 // was 22
#define IDH_DIAL_CON                    50062 // was 24
#define IDH_DIAL_USE                    50063 // connection tab, checkbox: dial the default connection when needed
#define IDH_DIAL_PROP                   50064 // dialup server properties, properties button
#define IDH_DIAL_DIS                    50065 // was 27
#define IDH_DIAL_ADD                    50066 // Add button in connections tab
#define IDH_DIAL_SYS                    50067 // was 29
#define IDH_PROX_SERV                   50068 // proxy server group box, Manual Proxy Server option
#define IDH_PROX_SETTINGS               50069 // LAN Settings button
#define IDH_SERV_INFO                   50070 // was 34
#define IDH_SERV_SAME                   50071 // was 35
#define IDH_EXCEPT_PROX                 50072 // was 37
#define IDH_EXCEPT_LOCAL                50073 // was 38
#define IDH_CUST_ADDRESS                50076 // was 41
#define IDH_CUST_DEF                    50077 // was 42
#define IDH_CUST_CURR                   50078 // was 43
#define IDH_HIST_NUM                    50079 // was 44
#define IDH_HIST_CLEAR                  50080 // was 45
#define IDH_MAIL                        50082 // was 47
#define IDH_NEWS                        50083 // was 48
#define IDH_IE_DEF                      50085 // was 50

#define IDH_CERT_PERS                   50091 // was 56
#define IDH_CERT_SITE                   50092 // was 57
#define IDH_CERT_PUB                    50093 // was 58
#define IDH_ACT_CONTENT                 50097 // was 62
#define IDH_SAFE_EXPERT                 50099 // was 67
#define IDH_SAFE_NORM                   50100 // was 68
#define IDH_SAFE_NONE                   50101 // was 69
#define IDH_RATE_TOGGLE                 50102 // was 70
#define IDH_RATE_PROP                   50103 // was 71
#define IDH_TIF_VIEW                    50104 // was 72
#define IDH_TIF_SETTINGS                50105 // was 73


//Settings dialog
#define IDH_TEMP_EVERY                  50113 // was 81
#define IDH_TEMP_START                  50114 // was 82
#define IDH_TEMP_NEVER                  50115 // was 83
#define IDH_TEMP_AMOUNT                 50116 // was 84
#define IDH_TEMP_EMPTY                  50117 // was 85
#define IDH_TEMP_MOVE                   50118 // was 86
#define IDH_TEMP_AUTO           50491 // New for ie5

#define IDH_VIEW_CERT                   50124 // was 93
#define IDH_DEL_CERT                    50125 // was 94
#define IDH_LIST_CERT                   50126 // was 95



#define IDH_PAGESETUP_HEADER_LEFT       50136 // was      4129       // Page Setup dialog box, header and footer
#define IDH_CPL_GEN_USEBLANK            50137 // was    5100// Use Blank button
#define IDH_CPL_SEC_ZONE_DROPLIST       50138 // was    5110// Zone dropdown list
#define IDH_CPL_SEC_ADDSITES            50139 // was    5115// Add Sites button
#define IDH_CPL_SEC_CUSTOM_LEVEL        50140 // was    5140// Custom for expert users
#define IDH_CPL_SEC_SETTINGS            50141 // was    5135// Settings button
#define IDH_CPL_WEB_SITES_LIST          50142 // was    5145// Trusted Web sites list
#define IDH_CPL_WEB_SITES_REMOVE        50143 // was    5150// Web sites in- Remove button
#define IDH_CPL_REQ_VERIFICATION_CHKBOX 50144 // was    5155// Require server verification for all sites in this zone
#define IDH_CPL_WEB_SITES_ADD_THIS_TXT  50145 // was    5160// Add this web site text box
#define IDH_CPL_WEB_SITES_ADD_BUTTON    50146 // was    5165// Add button
#define IDH_CPL_SEC_SETTINGS_CURRENT    50147 // was    5170// Security: Current settings list box
#define IDH_CPL_SEC_SETTINGS_RESET      50148 // was    5175// Security: Reset to: text box

#define IDH_CPL_CNX_WIZARD              50149 // was    5230// Wizard button in Connection tab/Connection groupbox
#define IDH_CPL_CNX_SETTINGS            50150 // was    5235// Connection settings button
#define IDH_CPL_CNX_ACCESSBYLAN         50151 // was    5240// Access the Internet via a local area network
#define IDH_CPL_CNX_PROXY_ADDR_PORT     50152 // was    5180// Proxy server address and port
#define IDH_CPL_DUN_ATTEMPT_X_TIMES     50153 // was    5200// Dial-Up Settings: Attempt to connect x times
#define IDH_CPL_DUN_WAIT_X_SECS         50154 // was    5205// DUN: Wait x seconds between each attempt
#define IDH_CPL_DUN_SEND_MY_LOGIN       50155 // Do not allow Internet applications to use this connection
#define IDH_CPL_DUN_USERNAME            50156 // was    5215// DUN: User
#define IDH_CPL_DUN_PASSWORD            50157 // was    5220// DUN: Password
#define IDH_CPL_DUN_DOMAIN              50158 // was    5225// DUN: Domain
#define IDH_CPL_PROGRAMS_CAL            50159 // was    5250// Programs: Calendar
#define IDH_CPL_PROGRAMS_CONTACTS       50160 // was    5255// Programs: Contact List
#define IDH_CPL_PROGRAMS_INTERNET_CALL  50161 // was    5260// Programs: Internet Call
#define IDH_CPL_ADV_COLORS              50162 // was    5270// Colors button
#define IDH_CPL_ADV_ACCESSIBILITY       50163 // was    5275// Accessibility button
#define IDH_CPL_ACCESS_USE_MY_COLORS    50164 // was    5290// Accessibility: Always use my color settings
#define IDH_CPL_ACCESS_USE_MY_F_STYLE   50165 // was    5295// Accessibility: Always use my font style settings
#define IDH_CPL_ACCESS_USE_MY_F_SIZE    50166 // was    5300// Accessibility: Always use my font size settings
#define IDH_CPL_ACCESS_USE_MY_STYLESHEETS 50167 // was  5305// Accessibility: User Stylesheet check box and text box

//Security dialog box help
#define IDH_SEC_ENTER_SSL               50168 //Entering a secure site
#define IDH_SEC_ENTER_SSL_W_INVALIDCERT 50169 //Entering a secure site with an invalid certificate
#define IDH_SEC_SEND_N_REC_COOKIES      50171 //Sending and Receiving Information About Your Browsing
#define IDH_SEC_SIGNED_N_INVALID        50173 //Signed and Invalid ActiveX/Java Download
#define IDH_SEC_MIXED_DOWNLOAD_FROM_SSL 50175 //Insecure content download from a secure Web site
#define IDH_SEC_ENTER_NON_SECURE_SITE   50226 //Entering non-secure Web site without a cert, from a secure web site



//CERTIFICATE PROPERTIES DIALOG BOX
#define IDH_CERTVWPROP_GEN_FINEPRINT          50228
#define IDH_CERTVWPROP_DET_ISSUER_CERT        50229
#define IDH_CERTVWPROP_DET_FRIENDLY           50230
#define IDH_CERTVWPROP_DET_STATUS             50231
#define IDH_CERTVWPROP_TRUST_PURPOSE          50232
#define IDH_CERTVWPROP_TRUST_HIERAR           50233
#define IDH_CERTVWPROP_TRUST_VIEWCERT         50234
#define IDH_CERTVWPROP_TRUST_INHERIT          50235
#define IDH_CERTVWPROP_TRUST_EXPLICIT_TRUST   50236
#define IDH_CERTVWPROP_TRUST_EXPLICIT_DISTRUST 50237
#define IDH_CERTVWPROP_ADV_FIELD              50238
#define IDH_CERTVWPROP_ADV_DETAILS            50239

#define IDH_HOVERCOLOR                        50240//color dialog box
#define IDH_JAVA_PERMISSIONS                  50241//security tab, custom settings list

#define IDH_ENABLE_TRANSITIONS                50242//Advanced tab, inetcpl
#define IDH_UNDERLINE_LINKS                   50243//advanced tab, inetcpl
#define IDH_SECURITY_RESET_ZONE_DEFAULTS      50244//security tab, zones
#define IDH_SECURITY_RESET_LEVEL_DEFAULTS     50245//security tab, security settings, Reset custom settings

//Profile Assistant confirmation dialog box
#define IDH_PA_OPS_REQUEST                    50246//name and url of site making request
#define IDH_PA_OPS_LIST                       50247//Profile information requested--label and listbox
#define IDH_PA_USAGE_STRING                   50248//Usage label and text area
#define IDH_PA_VIEW_CERT                      50249//View Certificate button
#define IDH_PA_CONNECTION_SECURITY            50250//Connection Security label and text
#define IDH_PA_ALWAYS_SHARE                   50251//Always share text box

#define IDH_DISABLE_SCRIPT_DEBUG              50252//Advanced tab, intecpl

#define IDH_TEMP_INTERNET_VIEW_OBJECTS_BTN  50254 //Temporary Internet Files settings dialog, View Objects button

//download objects folder properties
#define IDH_DLOAD_TYPE                    50255
#define IDH_DLOAD_CREATED                 50256
#define IDH_DLOAD_LASTACC                 50257
#define IDH_DLOAD_TOTALSIZE               50258
#define IDH_DLOAD_ID                      50259
#define IDH_DLOAD_STATUS                  50260
#define IDH_DLOAD_CODEBASE                50261
#define IDH_DLOAD_FILE_DEP                50262
#define IDH_DLOAD_JAVAPKG_DEP             50263
#define IDH_DLOAD_VERSION                 50264
#define IDH_DLOAD_DESC                    50265
#define IDH_DLOAD_COMPANY                 50266
#define IDH_DLOAD_LANG                    50267
#define IDH_DLOAD_COPYRIGHT               50268

//Local Internet sites
#define IDH_ADD_SITES_ADVANCED_BTN                      50269
#define IDH_LOCAL_INTRA_INCLUDE_ALL_NOT_LISTED          50270
#define IDH_LOCAL_INTRA_INCLUDE_ALL_THAT_BYPASS_PROXY   50271
#define IDH_LOCAL_INTRA_INCLUDE_ALL_UNCS                50272

#define IDH_SITE_CERTS_ISSUER_TYPE        50273  //Site Certificates dialog box, Issuer Type drop down

#define IDH_JAVA_CUST_SETTINGS_BTN        50274  //security custom settings, Java Custom Settings button

//Add
#define IDH_SUBSCR_TO                     50021 //Favorites full subscription
#define IDH_SUBSCR_TO_CHANNEL             50275 //channel full subscription
#define IDH_SUBSCR_ADDTO_FAVS             50276 //Favorites no subscription
#define IDH_SUBSCR_PARTIAL                50278 //Favorites partial subscription
#define IDH_CHANNEL_ADDTO_CHANNELS        50279 //channels not subscription
#define IDH_CHANNEL_PARTIAL               50280 //channels partial subscription
#define IDH_CHANNEL_SUBSCR_CUST_BUTTON    50281 //Customization button

#define IDH_SOFTWARE_CHANNEL_PERMISSIONS  50282

#define IDH_USER_AUTHENTICATION           50283

#define IDH_DLOAD_OBJNAME                 50284

#define IDH_RESET_SHARING_OPS             50285 //Content tab
#define IDH_ADV_PROFILE_ASSISTANT         50286 //Advanced tab

#define IDH_ALWAYS_LAUNCH_FULL_SCREEN     50287 //Advanced tab, Browser, Always launch fullscreen browser
#define IDH_WARN_IF_FORMS_REDIRECTED      50288 //Advanced tab, Security, Warn if forms submit is being redirected
#define IDH_SHOW_FONT_BUTTON              50289 //Advanced tab, Toolbar, Show font button


//fixes for IE 4.01, New context-sensitive help topics for advanced tab and client authentication personal certificates import and export buttons
#define IDH_SHOW_IE_ON_DESKTOP   50290
#define IDH_SHOW_WELCOME_EACH_LOGON      50291
#define IDH_LAUNCH_CHANNELSIN_FULL             50292
#define IDH_DELETE_HISTORY_WHEN_CLOSING    50293
#define IDH_CLIENTAUTH_IMPORT                          50294
#define IDH_CLIENTAUTH_EXPORT                       50295
#define IDH_USEHTTP11_THRU_PROXY              50296
#define IDH_USEHTTP11                                     50297
#define IDH_ALWAYS_EXPAND_ALT_TEXT    50298
#define IDH_MOVE_SYSTEM_CARET                 50299
#define IDH_CHANNEL_ON_WITHOUT_ACT_DTP     50300
#define IDH_ENABLE_JAVA_CONSOLE             50301

//50302 to 50399 reserved for IEUNIX

#define IDH_MATCH_DIACRITIC 50401 //find dialog box
#define IDH_MATCH_KASHIDA 50402 //find dialog box
#define IDH_MATCH_ALEF_HAMZA 50403 //find dialog box



#define IDH_SUBPROPS_SCHEDTAB_CUSTOM_SCHEDULE 50412
#define IDH_SUBPROPS_SCHEDTAB_MANUAL_SCHEDULE 50414
#define IDH_SUBPROPS_SCHEDTAB_SCHEDDESC 50415
#define IDH_SUBPROPS_SCHED_DONTUPDATE 50417
#define IDH_SUBPROPS_RECTAB_ADVANCED 50420
#define IDH_SUBPROPS_RECTAB_EMAIL_NOTIFICATION 50421
#define IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_ADDRESS 50423
#define IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_SERVER 50424
#define IDH_SUBPROPS_RECTAB_CHANNEL_LOGIN 50425
#define IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID 50426
#define IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD 50427
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP 50428
#define IDH_SUBPROPS_RECTAB_ADVOPTS_FOLLOW_LINKS  50429
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_IMAGES 50430
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_SOUND 50431
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_ACTIVEX 50432
#define IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD 50433


#define IDH_CONNECTION_TAB_CONNECTOID_LIST  50434 //Dial-up connection list in connection tab
#define IDH_CONNECTION_TAB_REMOVE_CONNECTOID  50435 //Remove button in connection tab
#define IDH_BYPASS_AUTOCFG  50436
#define IDH_DISCONNECT_ON_IEEXIT  50437 //advanced dialup dialog box, checkbox: disconnect when all internet applications exit
#define IDH_USE_THIS_CNX_FOR_INTRANETS  50438
#define IDH_USETHIS_CNX_4_INTERNET  50439
#define IDH_FORTEZZA_ALLOW  50440

#define IDH_EDIT_OFFLINE_SCHED  50441
#define IDH_MAKE_AVAIL_OFFLINE  50442
#define IDH_NEWSCHED_EVERY_AT_TIME  50443
#define IDH_NEWSCHED_NAME   50444
#define IDH_NEW_OFFLINE_SCHED   50445
#define IDH_REMOVE_OFFLINE_SCHED    50446

#define IDH_CHANNEL_DOWNLOAD_ALL    50447
#define IDH_CHANNEL_DOWNLOAD_COVER_N_TOC    50448
#define IDH_SUBPROPS_SUBTAB_SUBSCRIBED_NAME 50449
#define IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL  50450
#define IDH_WEBDOC_HOTKEY   50451
#define IDH_WEBDOC_VISITS   50452
#define IDH_SUBPROPS_SUBTAB_LAST    50453
#define IDH_SUBPROPS_DLSIZE 50454
#define IDH_SUBPROPS_SUBTAB_RESULT  50455

//#define IDH_JIT_COMPONENT 50456
#define IDH_JIT_SIZE    50457
#define IDH_JIT_DOWNLOAD_TIME   50458
#define IDH_JIT_NEVER_DOWNLOAD_THESE_COMPONENTS 50459
//#define IDH_JIT_PROGRESS_INDICATOR    50460
#define IDH_JIT_DOWNLOAD_BUTTON 50461
#define IDH_JIT_CANCEL_BUTTON   50462
#define IDH_JIT_VRML    50463
#define IDH_JIT_JAVAVMJIT   50464
#define IDH_JIT_IELPKJA 50465
#define IDH_JIT_IELPKKO 50466
#define IDH_JIT_IELPKPE 50467
#define IDH_JIT_IELPKZHT    50468
#define IDH_JIT_IELPKZHC    50469
#define IDH_JIT_IELPKTH 50470
#define IDH_JIT_IELPKIW 50471
#define IDH_JIT_IELPKVI 50472
#define IDH_JIT_IELPKAR 50473
#define IDH_JIT_IELPKAD 50474
#define IDH_JIT_MEDIAPLAYER 50475
#define IDH_JIT_MEDIAFILTER 50476
#define IDH_JIT_ACTIVEPAYMENT   50477
#define IDH_JIT_AOLSUPP 50478
#define IDH_JIT_MOBILEPK    50479
#define IDH_JIT_ICW 50480
#define IDH_JIT_USP10   50481

//organize favorites new UI
#define IDH_ORGFAVS_UP  50482
#define IDH_ORGFAVS_DOWN    50483
#define IDH_ORGFAVS_NEW_FOLDER  50484
#define IDH_ORGFAVS_SORT    50485
#define IDH_ORGFAVS_SYNCHRO 50486
#define IDH_ORGFAVS_IMPORT  50487
#define IDH_ORGFAVS_EXPORT  50488
#define IDH_ORGFAVS_PROPERTIES  50489
#define IDH_ORGFAVS_LIST    50490
#define IDH_SAVEAS_TYPE 50493 //FileSave, Save As Type
#define IDH_CHAR_SET_SAVE_AS    50494//FileSave, Language

#define IDH_AUTH_SAVE_PASSWORD     50495 //client authentication login
#define IDH_AUTH_REALM     50496 //client authentication login
#define IDH_AUTH_DOMAIN     50497 //client authentication login
#define IDH_AUTH_SERVER_FIREWALL     50498 //client authentication login
#define IDH_CPL_SEC_SETTINGS_CURRENT_ADMINAPPROVED     50499 //Active X security settings
#define IDH_SUBPROPS_RECTAB_ADVOPTS_ONLY_HTML_LINKS   50500 // Advanced tab,
#define IDH_ADV_NOTIFY_DWNLD_COMPLETE     50501//Advanced tab: Notify when downloads complete
#define IDH_ADV_DISABLE_JIT     50502//Advanced tab: Enable Install on demand
#define IDH_ADV_DISABLE_CZECH_4NEWER_IE     50503//Advanced tab: Automatically check for Internet Explorer updates

//New JIT topics:
#define IDH_JIT_DIRECTANIMATION   50504
#define IDH_JIT_DIRECTOR   50505
#define IDH_JIT_HELPCONT   50506
#define IDH_JIT_MSN_AUTH   50507
#define IDH_JIT_TRIDATA   50508
#define IDH_JIT_EXTRAPACK   50509
#define IDH_JIT_OK_BUTTON   50510

#define IDH_TLS_PROTOCOL   50511 //Advanced tab, Transport Layer Security protocol checkbox

//New language ids, Yutakan
#define IDH_COMBO_UILANG   50512 // The dropdown listbox on the Menus and Dialogs dialog.
#define IDH_LANG_ADDSPK    50513 // Add satellite pack button: This button leads to the satellite pack downloading web site.
#define IDH_LANG_UI_PREF   50514 //the Change button on the Language Preference dialog, which invokes the Menus and Dialogs dialog.

//New Security tab ids, Lorenk
#define IDH_SEC_LVL_SLIDER 50515 //hook up to the description bullets text also
#define IDH_SEC_ZONE_LIST 50516  //the list of icons at the top of the security tab.

//Content tab,
#define IDH_OPTS_PROG_AUTOSUGGEST_BUT 50517 //Autosuggest button
#define IDH_INTELLIFORM 50524 //Autosuggest forms option//See 50180 for autosuggest address options
#define IDH_CLEAR_INTELLIFORM  50525 //Autosuggest forms clear history button

#define IDH_OPTS_PROG_WALLET_BUT 50518  //Wallet button

//Proxy server settings
#define IDH_PROX_SERV_AUTO  50519 //In proxy server group box (dialup settings) or Lan settings proxy server dialog box: Automatic discovery of proxy server
#define IDH_PROX_SERV_NONE  50520 //In proxy server group box (dialup settings) or Lan settings proxy server dialog box: No proxy server
#define IDH_PROX_SETTINGS_ADV 50521 ////In proxy server group box (dialup settings) or Lan settings proxy server dialog box: Advanced button
#define IDH_DIAL_PROP_ADV  50522 //In dial-up settings group box, Advanced button (for connection attempts and disconnecting settings

//Connections tab

#define IDH_DIAL_DEFAULT  50523 //Set Default button, makes selected connection your default


//advanced tab
#define IDH_ADV_ENABLE_SCRIPTERROR_NOTIFICATION 50526
#define IDH_ADV_ENABLE_SYNC_OF_OFFLINEITEMS_PER_SCHED 50527
#define IDH_ADV_CLOSE_UNUSED_FOLDERS 50528
#define IDH_AUTODISC_DET_ONCE 50529
#define IDH_AUTODISC_DET_DISABLE 50530
#define IDH_AUTODISC_DET_AFTER_NET_CHG 50531
#define IDH_AUTODISC_DET_FOR_ANY_SETTINGS_CHGS 50532

//web folders
#define IDH_WEB_FOLDERS_CKBOX   50533  //in FileOpen dialog box

//Programs tab
#define IDH_HTML_EDITOR 50534 //HTML Editor default

#define IDH_SENDURLS_AS_UTF8 50535 //Send URLS as UTF-8, Advanced tab

#define IDH_SHOW_GO_IN_ADDRESSBAR  50536

#define IDH_SHOW_FRIENDLY_HTTP_ERROR_MESSAGES  50537
#define IDH_INLINE_AUTOCOMP_WEB_ADDRESSES 50538
#define IDH_INLINE_AUTOCOMP_PATHS_N_SHARES 50539
#define IDH_INTELLIFORM_PW 50540
#define IDH_CLEAR_INTELLIFORM_PW 50541
#define IDH_CONNECT_TAB_PERFORM_SECUR_CHECKB4_DIALING 50542

#define IDH_ADD_COMP_RADIO 50543
#define IDH_REPAIR_CURRENT_INSTALLATION 50544
#define IDH_RESTORE_PREVIOUS_IE 50545
#define IDH_MAINT_ADV_BUT 50546
#define IDH_RESTORE_COMPONENT_LIST 50547
#define IDH_DELETE_BACKUP 50548
#define IDH_REMOVE_IE6_SETUP_FILES 50549

#define IDH_CHK_SITE_CERT_REVOC 50550 //Check for server certificate revocation

#define IDH_BROWSEUI_TB_TEXTOPTNS                           50551
#define IDH_BROWSEUI_TB_ICONOPTNS                           50552

#define IDH_JIT_FLASH     50553
#define IDH_JIT_WEBFLDRS     50554
#define IDH_JIT_MESSNGR    50555
#define IDH_JIT_VBSCRIPT    50556
#define IDH_JIT_VML     50557
#define IDH_JIT_WAB    50558

#define IDH_SHOW_PLACEHOLDERS     50559
#define IDH_WEBFTP_ON    50560
#define IDH_CNX_CURRENT_DEFAULT_LBL_N_DISP   50561

#define IDH_INTELLIFORM_PW_PROMPT   50562

//Outlook Express Fonts dialog box
#define IDH_INTL_DEFAULT_OE   50563
#define IDH_CHAR_SET_OE   50564
#define IDH_INTL_FONT_PROP_OE   50565
#define IDH_INTL_FONT_FIXED_OE   50566
#define IDH_FONT_MIME_OE   50567

//New connection radio buttons
#define IDH_NEVERDIAL   50568
#define IDH_DIALIF_NETCNX_GONE   50569

//New Autosearch options in advanced tab
#define IDH_ADDBAR_SRCH_GOTOBEST   50570
#define IDH_ADDBAR_SRCH_RESULTS_ONLY   50571
#define IDH_ADDBAR_DONT_SRCH   50572
#define IDH_ADDBAR_DISP_RESULTS_WHERE   50573

#define IDH_RESET_WEBSTGS_BUTTON 50574

//More Search Settings dialog box
#define IDH_MORESRCH_AVAIL_PROVIDERS  50575 // Available providers list
#define IDH_MORESRCH_PREFERREDPROVIDERS  50576 //Preferred providers list
#define IDH_MORESRCH_ADD_PROVID  50577 //Add button
#define IDH_MORESRCH_REMOVE_PROVID  50578 //Remove button
#define IDH_MORESRCH_PREFRD_MOVEUP  50579  //Move up button
#define IDH_MORESRCH_PREFRD_MOVEDN  50580//Move down button
#define IDH_MORESRCH_RESET  50581 //Reset button

//New IE5.01 Reuse Windows for launching shortcuts option and
//enable personalized favorites menu

#define IDH_REUSE_WINDOWS_FOR_SHORTCUTS 50582
#define IDH_ENABLE_PERSONALIZED_FAVORITES_MENU 50583

#define IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD_CONFIRM 50584 //Displaycpl, Web tab, My current Home page properties, Download tab, Login dialog box, password confirmation text box
#define IDH_SUBPROPS_NEW_SCHEDULE_AUTOCONNECT 50585 //Displaycpl, Web tab, My current home page properties, Schedule tab, Add, If my computer is not connected...checkbox
#define IDH_CONNECTION_SHARING 50586 //inetcpl, Connection tab, Sharing button for Internet Connection manager
#define IDH_RADIO_TOOLBAR_OPTION  50587  //inetcpl, Advanced tab, option to always display the internet radio toolbar.

#define IDH_DEL_COOKIE_THIRD_PARTY     50591 
#define IDH_COOKIE_THIRD_PARTY  50593
#define IDH_COOKIE_FIRST_PARTY  50594

//New help for INETCPL -> Privacy tab
#define IDH_PRIVACY_SLIDER 50601  //Privacy settings slider
#define IDH_PRIVACY_IMPORT 50602  //Import button
#define IDH_PRIVACY_RESET_DEFAULTS 50603  //Reset Defaults button
#define IDH_PRIVACY_ADVANCED 50612 //Advanced button

//New help for INETCPL ->Priv tab -> Adv
#define IDH_PRIVADV_OVERRIDE 50607 //check box
#define IDH_PRIVACYADV_ALLOW_SESSION 50608 //check box
#define IDH_PRIVADV_FIRST_PARTY 50609 //first-party settings radio buttons
#define IDH_PRIVACYADV_THIRD_PARTY 50610 //third-party settings radio buttons
#define IDH_PRIVACYADV_EDIT 50611 //edit button

//New help for INETCPL ->Priv tab -> Adv -> Edit
#define IDH_PRIVADV_ALLOW 50613 //Allow button
#define IDH_PRIVADV_REJECT 50614 //Reject button
#define IDH_PRIVADV_REMOVE 50615 //Remove button
#define IDH_PRIVADV_ADDRESS 50616 //Web site text box
#define IDH_PRIVADV_WEBSITES 50617 //Web site list
#define IDH_PRIVADV_REMOVE_ALL 50619 // Remove all button

//New help for INETCPL ->Content
#define IDH_ADV_CLEAR_SSL_CACHE 50623 //Clear SSL State button
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\icwcfg.h ===
/********************************************************************

  ICWCFG.H

  Copyright(c) Microsoft Corporation, 1996-1998

  *** N O T   F O R   E X T E R N A L   R E L E A S E *******
  *
  * This header file is not intended for distribution outside Microsoft.
  *
  ***********************************************************

  Header file for Internet Connection Wizard external configuration
  routines found in INETCFG.DLL.

  Routines:

  CheckConnectionWizard - Checks which parts of ICW are installed
		and if it has been run before.  It optionally will start
		either the full or manual path of ICW if it is insalled
		but has not been run before.

  History:	10/22/96	Created
		10/24/96	Added defines and typedefs
		2/25/97		Added CreateDirectoryService -- jmazner
		4/24/97		Removed InetCreate*, these are now owned
					by the Account Manager -- jmazner

  Support:	This header file (and INETCFG.DLL) is supported by the
			Internet Connection Wizard team (alias icwcore).  Please
			do not modify this directly.

*********************************************************************/

#ifndef _ICWCFG_H_

//
// defines
//

// ICW registry settings

// HKEY_CURRENT_USER
#define ICW_REGPATHSETTINGS	"Software\\Microsoft\\Internet Connection Wizard"
#define ICW_REGKEYCOMPLETED	"Completed"

// Maximum field lengths
#define ICW_MAX_ACCTNAME	256
#define ICW_MAX_PASSWORD	256	// PWLEN
#define ICW_MAX_LOGONNAME	256	// UNLEN
#define ICW_MAX_SERVERNAME	64
#define ICW_MAX_RASNAME		256	// RAS_MaxEntryName
#define ICW_MAX_EMAILNAME	64
#define ICW_MAX_EMAILADDR	128

// Bit-mapped flags

// CheckConnectionWizard input flags
#define ICW_CHECKSTATUS		0x0001

#define ICW_LAUNCHFULL		0x0100
#define ICW_LAUNCHMANUAL	0x0200
#define ICW_USE_SHELLNEXT	0x0400
#define ICW_FULL_SMARTSTART	0x0800

// CheckConnectionWizard output flags
#define ICW_FULLPRESENT		0x0001
#define ICW_MANUALPRESENT	0x0002
#define ICW_ALREADYRUN		0x0004

#define ICW_LAUNCHEDFULL	0x0100
#define ICW_LAUNCHEDMANUAL	0x0200

// InetCreateMailNewsAccount input flags
#define ICW_USEDEFAULTS		0x0001

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//
// external function typedefs
//
typedef DWORD	(WINAPI *PFNCHECKCONNECTIONWIZARD) (DWORD, LPDWORD);
typedef DWORD	(WINAPI *PFNSETSHELLNEXT) (CHAR *);

//
// external function declarations
//
DWORD	WINAPI CheckConnectionWizard(DWORD, LPDWORD);
DWORD	WINAPI SetShellNext(CHAR *);


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _ICWCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\iimgctx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1996-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: iimgctx.h
//
//--------------------------------------------------------------------------

#ifndef _IImgCtxObjects_H_
#define _IImgCtxObjects_H_

#ifdef __cplusplus
extern "C" {
#endif
typedef void (CALLBACK *PFNIMGCTXCALLBACK)(void *, void *);
#ifdef __cplusplus
}
#endif

#define IMGCHG_SIZE         0x0001
#define IMGCHG_VIEW         0x0002
#define IMGCHG_COMPLETE     0x0004
#define IMGCHG_ANIMATE      0x0008
#define IMGCHG_MASK         0x000F

#define IMGLOAD_NOTLOADED   0x00100000  // Image has not yet been loaded
#define IMGLOAD_LOADING     0x00200000  // Image in the process of being loaded
#define IMGLOAD_STOPPED     0x00400000  // Imaged aborted
#define IMGLOAD_ERROR       0x00800000  // Error loading image
#define IMGLOAD_COMPLETE    0x01000000  // Image loaded
#define IMGLOAD_MASK        0x01F00000

#define IMGBITS_NONE        0x02000000
#define IMGBITS_PARTIAL     0x04000000
#define IMGBITS_TOTAL       0x08000000
#define IMGBITS_MASK        0x0E000000

#define IMGANIM_ANIMATED    0x10000000
#define IMGANIM_MASK        0x10000000

#define IMGTRANS_OPAQUE     0x20000000
#define IMGTRANS_MASK       0x20000000

#define DWN_COLORMODE       0x0000003F  // Explicit color mode requested
#define DWN_DOWNLOADONLY    0x00000040  // Download data only, don't decode
#define DWN_FORCEDITHER     0x00000080  // Override automatic dithering
#define DWN_RAWIMAGE        0x00000100  // Disable dithering
#define DWN_MIRRORIMAGE     0x00000200  // Mirror the image

/* Definition of interface: IImgCtx */
#undef INTERFACE
#define INTERFACE IImgCtx

// {3050f3d7-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_IImgCtx, 0x3050f3d7, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DECLARE_INTERFACE_(IImgCtx, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IImgCtx methods */

    /* Initialization/Download methods */
    STDMETHOD(Load)(THIS_ LPCWSTR pszUrl, DWORD dwFlags) PURE;
    STDMETHOD(SelectChanges)(THIS_ ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal) PURE;
    STDMETHOD(SetCallback)(THIS_ PFNIMGCTXCALLBACK pfn, void * pvPrivateData) PURE;
    STDMETHOD(Disconnect)(THIS) PURE;

        /* Query methods */
    STDMETHOD(GetUpdateRects)(THIS_ struct tagRECT FAR* prc, struct tagRECT FAR* prcImg, long FAR* pcrc) PURE;
    STDMETHOD(GetStateInfo)(THIS_ ULONG FAR* pulState, struct tagSIZE FAR* psize, BOOL fClearChanges) PURE;
    STDMETHOD(GetPalette)(THIS_ HPALETTE FAR* phpal) PURE;

    /* Rendering methods */
    STDMETHOD(Draw)(THIS_ HDC hdc, struct tagRECT FAR* prcBounds) PURE;
    STDMETHOD(Tile)(THIS_ HDC hdc, struct tagPOINT FAR* pptBackOrg, struct tagRECT FAR* prcClip, struct tagSIZE FAR* psize) PURE;
    STDMETHOD(StretchBlt)(THIS_ HDC hdc, int dstX, int dstY, int dstXE, int dstYE, int srcX, int srcY, int srcXE, int srcYE, DWORD dwROP) PURE;
};

#ifdef COBJMACROS


#define IImgCtx_QueryInterface(This,riid,ppvObject)     \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImgCtx_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IImgCtx_Release(This)   \
    (This)->lpVtbl -> Release(This)

#define IImgCtx_Load(This, pszUrl, dwFlags)     \
        (This)->lpVtbl -> Load(This, pszUrl, dwFlags)

#define IImgCtx_Draw(This, hdc, prcBounds)              \
        (This)->lpVtbl -> Draw(This, hdc, prcBounds)

#define IImgCtx_Tile(This, hdc, pptBackOrg, prcClip, psize)             \
        (This)->lpVtbl -> Tile(This, hdc, pptBackOrg, prcClip, psize)

#define IImgCtx_GetUpdateRects(This, prc, prcImg, pcrc) \
        (This)->lpVtbl -> GetUpdateRects(This, prc, prcImg, pcrc)

#define IImgCtx_GetStateInfo(This, pulState, psize, fClearChanges)      \
        (This)->lpVtbl -> GetStateInfo(This, pulState, psize, fClearChanges)

#define IImgCtx_GetPalette(This, phpal) \
        (This)->lpVtbl -> GetPalette(This, phpal)
        
#define IImgCtx_SelectChanges(This, ulChgOn, ulChgOff, fSignal) \
        (This)->lpVtbl -> SelectChanges(This, ulChgOn, ulChgOff, fSignal)

#define IImgCtx_SetCallback(This, pfnCallback, pvPrivateData)   \
        (This)->lpVtbl -> SetCallback(This, pfnCallback, pvPrivateData)

#define IImgCtx_Disconnect(This) \
    (This)->lpVtbl -> Disconnect(This)

#define IImgCtx_StretchBlt(This, hdc, dstX, dstY, dstXE, dstYE, srcX, srcY, srcXE, srcYE, dwROP)   \
    (This)->lpVtbl -> StretchBlt(This, hdc, dstX, dstY, dstXE, dstYE, srcX, srcY, srcXE, srcYE, dwROP)

#endif /* COBJMACROS */


// {3050f3d6-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_IImgCtx, 0x3050f3d6, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\iert.h ===
// iert.h - Definitions, and Prototypes for the Internet Explorer 
//          implementation of the c-runtime library.
//
// History:
//     Created on 16-May-1997 by Vince Roggero (vincentr)
//

#ifdef __cplusplus
extern "C" 
{
#endif

/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/
char* __cdecl StrTokEx (char ** pstring, const char * control);


/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/
double __cdecl StrToDbl(const char *strIn, char **strStop);

#ifdef __cplusplus
}   // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\mimedisp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

#ifndef __MIMEDISP_H__
#define __MIMEDISP_H__

#define DISPID_IMIMEEDIT_BASE       100

#define DISPID_IMIMEEDIT_SRC        (DISPID_IMIMEEDIT_BASE + 1)
#define DISPID_IMIMEEDIT_STYLE      (DISPID_IMIMEEDIT_BASE + 2)
#define DISPID_IMIMEEDIT_EDITMODE   (DISPID_IMIMEEDIT_BASE + 3)
#define DISPID_IMIMEEDIT_MSGSRC     (DISPID_IMIMEEDIT_BASE + 4)
#define DISPID_IMIMEEDIT_TEXT       (DISPID_IMIMEEDIT_BASE + 5)
#define DISPID_IMIMEEDIT_HTML       (DISPID_IMIMEEDIT_BASE + 6)
#define DISPID_IMIMEEDIT_CLEAR      (DISPID_IMIMEEDIT_BASE + 7)
#define DISPID_IMIMEEDIT_DOCUMENT   (DISPID_IMIMEEDIT_BASE + 8)


#endif //__MIMEDISP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\inethelp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1998               **
//*********************************************************************

//
// HELP.H - IDHs for the Internet Control Panel
//

//
// GLOBALS... ie... used to give the same info on every page
//

#include <iehelpid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\inseng.h ===
//=--------------------------------------------------------------------------=
// inseng.h
//=--------------------------------------------------------------------------=
// Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
//
// interface declaration for the InstallEngine control.
//
#ifndef _INSENG_H_

#ifdef __cplusplus
extern "C"{
#endif

#define MAX_ID_LENGTH            48
#define MAX_DISPLAYNAME_LENGTH  128


#define ICI_NOTINSTALLED          0
#define ICI_INSTALLED             1
#define ICI_NEWVERSIONAVAILABLE   2
#define ICI_UNKNOWN               3
#define ICI_OLDVERSIONAVAILABLE   4
#define ICI_NOTINITIALIZED        0xffffffff

#define ABORTINSTALL_NORMAL       0
#define ABORTINSTALL_IMMEADIATE   1


#define ENGINESTATUS_NOTREADY     0
#define ENGINESTATUS_LOADING      1
#define ENGINESTATUS_INSTALLING   2
#define ENGINESTATUS_READY        3

#define CDINSTALL                     1
#define WEBINSTALL                    2
#define WEBINSTALL_DIFFERENTMACHINE   3
#define NETWORKINSTALL                4
#define LOCALINSTALL                  5

#define DEP_NEVER_INSTALL   'N'
#define DEP_INSTALL         'I'


#define SETACTION_NONE            0x00000000
#define SETACTION_INSTALL         0x00000001

#define INSTALLOPTIONS_NOCACHE             0x00000001
#define INSTALLOPTIONS_DOWNLOAD            0x00000002
#define INSTALLOPTIONS_INSTALL             0x00000004
#define INSTALLOPTIONS_DONTALLOWXPLATFORM  0x00000008
#define INSTALLOPTIONS_FORCEDEPENDENCIES    0x00000010

#define EXECUTEJOB_SILENT              0x00000001
#define EXECUTEJOB_DELETE_JOB          0x00000002

#define EXECUTEJOB_VERIFYFILES         0x00000008
#define EXECUTEJOB_IGNORETRUST         0x00000010
#define EXECUTEJOB_IGNOREDOWNLOADERROR 0x00000020
#define EXECUTEJOB_DONTALLOWCANCEL     0x00000040


#define E_FILESMISSING             _HRESULT_TYPEDEF_(0x80100003L)



HRESULT WINAPI CheckTrust(LPCSTR pszFilename, HWND hwndForUI, BOOL bShowBadUI);
HRESULT WINAPI CheckTrustEx(LPCSTR szURL, LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, DWORD dwReserved);
HRESULT WINAPI PurgeDownloadDir(LPCSTR pszDir);
HRESULT WINAPI CheckForVersionConflict();


typedef struct
{
   DWORD cbSize;
   DWORD dwInstallSize;
   DWORD dwWinDriveSize;
   DWORD dwDownloadSize;
   DWORD dwDependancySize;
   DWORD dwInstallDriveReq;
   DWORD dwWinDriveReq;
   DWORD dwDownloadDriveReq;
   CHAR  chWinDrive;
   CHAR  chInstallDrive;
   CHAR  chDownloadDrive;
   DWORD dwTotalDownloadSize;
} COMPONENT_SIZES;

typedef struct
{
   DWORD cbSize;
   DWORD dwDownloadKBRemaining;
   DWORD dwInstallKBRemaining;
   DWORD dwDownloadSecsRemaining;
   DWORD dwInstallSecsRemaining;
} INSTALLPROGRESS;


enum InstallStatus
{
   INSTALLSTATUS_INITIALIZING,
   INSTALLSTATUS_DEPENDENCY,
   INSTALLSTATUS_DOWNLOADING,
   INSTALLSTATUS_COPYING,
   INSTALLSTATUS_RETRYING,
   INSTALLSTATUS_CHECKINGTRUST,
   INSTALLSTATUS_EXTRACTING,
   INSTALLSTATUS_RUNNING,
   INSTALLSTATUS_FINISHED,
   INSTALLSTATUS_DOWNLOADFINISHED
};

// defines for engine problems  (OnEngineProblem)
#define ENGINEPROBLEM_DOWNLOADFAIL   0x00000001


// Actions particular to ENGINEPROBLEM_DOWNLOAD
#define DOWNLOADFAIL_RETRY   0x00000001


#define STOPINSTALL_REBOOTNEEDED   0x00000001
#define STOPINSTALL_REBOOTREFUSED  0x00000002


DEFINE_GUID(IID_IInstallEngineCallback,0x6E449685L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngineCallback

DECLARE_INTERFACE_(IInstallEngineCallback, IUnknown)
{
   // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;


   STDMETHOD(OnEngineStatusChange)(THIS_ DWORD dwEngineStatus, DWORD substatus) PURE;
   STDMETHOD(OnStartInstall)(THIS_ DWORD dwDLSize, DWORD dwInstallSize) PURE;
   STDMETHOD(OnStartComponent)(THIS_ LPCSTR pszID, DWORD dwDLSize, DWORD dwInstallSize, LPCSTR pszString) PURE;
   STDMETHOD(OnComponentProgress)(THIS_ LPCSTR pszID, DWORD dwPhase, LPCSTR pszString, LPCSTR pszMsgString, ULONG progress, ULONG themax) PURE;
   STDMETHOD(OnStopComponent)(THIS_ LPCSTR pszID, HRESULT hError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus) PURE;
   STDMETHOD(OnStopInstall)(THIS_ HRESULT hrError, LPCSTR szError, DWORD dwStatus) PURE;
   STDMETHOD(OnEngineProblem)(THIS_ DWORD dwEngineProblem, LPDWORD dwAction) PURE;
};



DEFINE_GUID(IID_IInstallEngine,0x6E449684L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngine

DECLARE_INTERFACE_(IInstallEngine , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   // Methods to set engine up for install
   STDMETHOD(GetEngineStatus)(THIS_ DWORD *theenginestatus) PURE;
   STDMETHOD(SetCifFile)(THIS_ LPCSTR pszCabName, LPCSTR pszCifName) PURE;
   STDMETHOD(DownloadComponents)(THIS_ DWORD dwFlags) PURE;
   STDMETHOD(InstallComponents)(THIS_ DWORD dwFlags) PURE;
   STDMETHOD(EnumInstallIDs)(THIS_ UINT uIndex, LPSTR *ppszID) PURE;
   STDMETHOD(EnumDownloadIDs)(THIS_ UINT uIndex, LPSTR *ppszID) PURE;
   STDMETHOD(IsComponentInstalled)(THIS_ LPCSTR pszID, DWORD *pdwStatus) PURE;
   STDMETHOD(RegisterInstallEngineCallback)(THIS_ IInstallEngineCallback *pcb) PURE;
   STDMETHOD(UnregisterInstallEngineCallback)(THIS) PURE;
   STDMETHOD(SetAction)(THIS_ LPCSTR pszID, DWORD dwAction, DWORD dwPriority) PURE;
   STDMETHOD(GetSizes)(THIS_ LPCSTR pszID, COMPONENT_SIZES *pSizes) PURE;
   STDMETHOD(LaunchExtraCommand)(THIS_ LPCSTR pszInfName, LPCSTR pszSection) PURE;
   STDMETHOD(GetDisplayName)(THIS_ LPCSTR pszID, LPSTR *ppszName) PURE;

   // Info about the install (should be structure to fill in
   //   like GetBindInfo (GetInstallInfo)
   STDMETHOD(SetBaseUrl)(THIS_ LPCSTR pszBaseName) PURE;
   STDMETHOD(SetDownloadDir)(THIS_ LPCSTR pszDownloadDir) PURE;
   STDMETHOD(SetInstallDrive)(THIS_ CHAR chDrive) PURE;
   STDMETHOD(SetInstallOptions)(THIS_ DWORD dwInsFlag) PURE;
   STDMETHOD(SetHWND)(THIS_ HWND hForUI) PURE;
   STDMETHOD(SetIStream)(THIS_ IStream *pstm) PURE;


   // Engine control during installation (seperate interface?)
   STDMETHOD(Abort)(THIS_ DWORD dwFlags) PURE;
   STDMETHOD(Suspend)(THIS) PURE;
   STDMETHOD(Resume)(THIS) PURE;

};

DEFINE_GUID(IID_IInstallEngineTiming,0x6E449687L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngineTiming

DECLARE_INTERFACE_(IInstallEngineTiming , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(GetRates)(THIS_ DWORD *pdwDownload, DWORD *pdwInstall) PURE;
   STDMETHOD(GetInstallProgress)(THIS_ INSTALLPROGRESS *pinsprog) PURE;
};


DEFINE_GUID(CLSID_InstallEngine,0x6E449686L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);


//  The site manager interface

typedef struct
{
   UINT cbSize;
   LPSTR pszLang;
   LPSTR pszRegion;
} SITEQUERYPARAMS;

typedef struct
{
   UINT cbSize;
   LPSTR pszUrl;
   LPSTR pszFriendlyName;
   LPSTR pszLang;
   LPSTR pszRegion;
} DOWNLOADSITE;


// {BFC880F3-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(IID_IDownloadSite,
0xbfc880f3, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

#undef INTERFACE
#define INTERFACE IDownloadSite

DECLARE_INTERFACE_(IDownloadSite , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(GetData)(THIS_ DOWNLOADSITE **pds) PURE;
};

// {BFC880F0-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(IID_IDownloadSiteMgr,
0xbfc880f0, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

#undef INTERFACE
#define INTERFACE IDownloadSiteMgr

DECLARE_INTERFACE_(IDownloadSiteMgr , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(Initialize)(THIS_ LPCSTR pszUrl, SITEQUERYPARAMS *pqp) PURE;
   STDMETHOD(EnumSites)(THIS_ DWORD dwIndex, IDownloadSite **pds) PURE;
};

// {BFC880F1-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(CLSID_DownloadSiteMgr,
0xbfc880f1, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);


// defines for dwUrlFlags
#define URLF_DEFAULT                0x00000000
#define URLF_EXTRACT                0x00000001
#define URLF_RELATIVEURL            0x00000002
#define URLF_DELETE_AFTER_EXTRACT   0x00000004

// types of dependancies
#define DEP_NEVER_INSTALL   'N'
#define DEP_INSTALL         'I'

// platform defines
#define PLATFORM_WIN95              0x00000001
#define PLATFORM_WIN98              0x00000002
#define PLATFORM_NT4                0x00000004
#define PLATFORM_NT5                0x00000008
#define PLATFORM_NT4ALPHA           0x00000010
#define PLATFORM_NT5ALPHA           0x00000020
#define PLATFORM_MILLEN		    0x00000040
#define PLATFORM_ALL     PLATFORM_WIN95 | PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_NT4ALPHA | PLATFORM_NT5ALPHA | PLATFORM_MILLEN
               

// The action to be taken on this component ((Get)SetInstallQueueStatus, SetAction
enum ComponentAction { ActionNone, ActionInstall, ActionUninstall };

// Type for commands
                     //   0            1           2           3             4
enum CommandType     { InfCommand, WExtractExe, Win32Exe, InfExCommand, HRESULTWin32Exe };



#undef INTERFACE
#define INTERFACE ICifComponent

DECLARE_INTERFACE(ICifComponent)
{
   // for properties
   STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize)PURE;
   STDMETHOD(GetGUID)(THIS_ LPSTR pszGUID, DWORD dwSize)PURE;
   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize)PURE;
   STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize) PURE;
   STDMETHOD(GetUrl)(THIS_ UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags)  PURE;
   STDMETHOD(GetFileExtractList)(THIS_ UINT uUrlNum, LPSTR pszExtract, DWORD dwSize)  PURE;
   STDMETHOD(GetUrlCheckRange)(THIS_ UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax)  PURE;
   STDMETHOD(GetCommand)(THIS_ UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches, 
                         DWORD dwSwitchSize, LPDWORD pdwType)  PURE;
   STDMETHOD(GetVersion)(THIS_ LPDWORD pdwVersion, LPDWORD pdwBuild)  PURE;
   STDMETHOD(GetLocale)(THIS_ LPSTR pszLocale, DWORD dwSize)  PURE;
   STDMETHOD(GetUninstallKey)(THIS_ LPSTR pszKey, DWORD dwSize)  PURE;
   STDMETHOD(GetInstalledSize)(THIS_ LPDWORD pdwWin, LPDWORD pdwApp)  PURE;
   STDMETHOD_(DWORD, GetDownloadSize)(THIS)  PURE;
   STDMETHOD_(DWORD, GetExtractSize)(THIS)  PURE;
   STDMETHOD(GetSuccessKey)(THIS_ LPSTR pszKey, DWORD dwSize)  PURE;
   STDMETHOD(GetProgressKeys)(THIS_ LPSTR pszProgress, DWORD dwProgSize, 
                              LPSTR pszCancel, DWORD dwCancelSize)  PURE;
   STDMETHOD(IsActiveSetupAware)(THIS)  PURE;
   STDMETHOD(IsRebootRequired)(THIS)  PURE;
   STDMETHOD(RequiresAdminRights)(THIS) PURE;
   STDMETHOD_(DWORD, GetPriority)(THIS)  PURE;
   STDMETHOD(GetDependency)(THIS_ UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild)  PURE;
   STDMETHOD_(DWORD, GetPlatform)(THIS)  PURE;
   STDMETHOD(GetMode)(THIS_ UINT uModeNum, LPSTR pszMode, DWORD dwSize)  PURE;
   STDMETHOD(GetGroup)(THIS_ LPSTR pszID, DWORD dwSize)  PURE;
   STDMETHOD(IsUIVisible)(THIS)  PURE;
   STDMETHOD(GetPatchID)(THIS_ LPSTR pszID, DWORD dwSize)  PURE;
   STDMETHOD(GetDetVersion)(THIS_ LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize) PURE;
   STDMETHOD(GetTreatAsOneComponents)(THIS_ UINT uNum, LPSTR pszID, DWORD dwBuf) PURE;
   STDMETHOD(GetCustomData)(LPSTR pszKey, LPSTR pszData, DWORD dwSize) PURE;

   // access to state
   STDMETHOD_(DWORD, IsComponentInstalled)(THIS)  PURE;
   STDMETHOD(IsComponentDownloaded)(THIS)  PURE;
   STDMETHOD_(DWORD, IsThisVersionInstalled)(THIS_ DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild) PURE;
   STDMETHOD_(DWORD, GetInstallQueueState)(THIS)  PURE;
   STDMETHOD(SetInstallQueueState)(THIS_ DWORD dwState)  PURE;
   STDMETHOD_(DWORD, GetActualDownloadSize)(THIS)  PURE;
   STDMETHOD_(DWORD, GetCurrentPriority)(THIS) PURE;
   STDMETHOD(SetCurrentPriority)(THIS_ DWORD dwPriority) PURE;
};

DECLARE_INTERFACE_(ICifRWComponent, ICifComponent)
{
   STDMETHOD(SetGUID)(THIS_ LPCSTR pszGUID)PURE;
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc)PURE;
   STDMETHOD(SetUrl)(THIS_ UINT uUrlNum, LPCSTR pszUrl, DWORD dwUrlFlags)  PURE;
   STDMETHOD(SetCommand)(THIS_ UINT uCmdNum, LPCSTR pszCmd, LPCSTR pszSwitches, DWORD dwType)  PURE;
   STDMETHOD(SetVersion)(THIS_ LPCSTR pszVersion)  PURE;
   STDMETHOD(SetUninstallKey)(THIS_ LPCSTR pszKey)  PURE;
   STDMETHOD(SetInstalledSize)(THIS_ DWORD dwWin, DWORD dwApp)  PURE;
   STDMETHOD(SetDownloadSize)(THIS_ DWORD)  PURE;
   STDMETHOD(SetExtractSize)(THIS_ DWORD)  PURE;
   STDMETHOD(DeleteDependency)(THIS_ LPCSTR pszID, char chType)  PURE;
   STDMETHOD(AddDependency)(THIS_ LPCSTR pszID, char chType)  PURE;
   STDMETHOD(SetUIVisible)(THIS_ BOOL)  PURE;
   STDMETHOD(SetGroup)(THIS_ LPCSTR pszID)  PURE;
   STDMETHOD(SetPlatform)(THIS_ DWORD)  PURE;
   STDMETHOD(SetPriority)(THIS_ DWORD)  PURE;
   STDMETHOD(SetReboot)(THIS_ BOOL)  PURE;
   
   STDMETHOD(DeleteFromModes)(THIS_ LPCSTR pszMode)  PURE;
   STDMETHOD(AddToMode)(THIS_ LPCSTR pszMode)  PURE;
   STDMETHOD(SetModes)(THIS_ LPCSTR pszMode)  PURE;
   STDMETHOD(CopyComponent)(THIS_ LPCSTR pszCifFile)  PURE;
   STDMETHOD(AddToTreatAsOne)(THIS_ LPCSTR pszCompID)  PURE;
   STDMETHOD(SetDetails)(THIS_ LPCSTR pszDesc) PURE;
};

DECLARE_INTERFACE_(IEnumCifComponents, IUnknown)
{
  // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
   
  // enum methods
   STDMETHOD(Next)(THIS_ ICifComponent **) PURE;
   STDMETHOD(Reset)(THIS) PURE;
};

DECLARE_INTERFACE(ICifGroup)
{
  // for properties
   STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize) PURE;
   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize) PURE;
   STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
  
   STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD_(DWORD, GetCurrentPriority)(THIS) PURE;

};

DECLARE_INTERFACE_(ICifRWGroup, ICifGroup)
{
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc) PURE;
   STDMETHOD(SetPriority)(THIS_ DWORD) PURE;
   STDMETHOD(SetDetails)(THIS_ LPCSTR pszDetails) PURE;
};

DECLARE_INTERFACE_(IEnumCifGroups, IUnknown)
{
  // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
   
  // enum methods
   STDMETHOD(Next)(THIS_ ICifGroup **) PURE;
   STDMETHOD(Reset)(THIS) PURE;
};

DECLARE_INTERFACE(ICifMode)
{
  // for properties
   STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize) PURE;
   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize) PURE;
   STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize) PURE;
  
   STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv) PURE;
};

DECLARE_INTERFACE_(ICifRWMode, ICifMode)
{
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc) PURE;
   STDMETHOD(SetDetails)(THIS_ LPCSTR pszDetails) PURE;
};

DECLARE_INTERFACE_(IEnumCifModes, IUnknown)
{
  // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
   
  // enum methods
   STDMETHOD(Next)(THIS_ ICifMode **) PURE;
   STDMETHOD(Reset)(THIS) PURE;
};

DEFINE_GUID(IID_ICifFile,0x6E449688L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

DECLARE_INTERFACE_(ICifFile, IUnknown)
{
 // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
 
   STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD(FindComponent)(THIS_ LPCSTR pszID, ICifComponent **p) PURE;

   STDMETHOD(EnumGroups)(THIS_ IEnumCifGroups **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD(FindGroup)(THIS_ LPCSTR pszID, ICifGroup **p) PURE;

   STDMETHOD(EnumModes)(THIS_ IEnumCifModes **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD(FindMode)(THIS_ LPCSTR pszID, ICifMode **p) PURE;

   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize) PURE;
   STDMETHOD(GetDetDlls)(THIS_ LPSTR pszDlls, DWORD dwSize) PURE;

};

DECLARE_INTERFACE_(ICifRWFile, ICifFile)
{
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc) PURE;    
   STDMETHOD(CreateComponent)(THIS_ LPCSTR pszID, ICifRWComponent **p) PURE;
   STDMETHOD(CreateGroup)(THIS_ LPCSTR pszID, ICifRWGroup **p) PURE;
   STDMETHOD(CreateMode)(THIS_ LPCSTR pszID, ICifRWMode **p) PURE;
   STDMETHOD(DeleteComponent)(THIS_ LPCSTR pszID) PURE;
   STDMETHOD(DeleteGroup)(THIS_ LPCSTR pszID) PURE;
   STDMETHOD(DeleteMode)(THIS_ LPCSTR pszID) PURE;
   STDMETHOD(Flush)(THIS) PURE;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Detection DLL 

// Returns from DetectVersion
#define DET_NOTINSTALLED          0
#define DET_INSTALLED             1
#define DET_NEWVERSIONINSTALLED   2
#define DET_OLDVERSIONINSTALLED   3


   
// Function prototype
typedef struct
{
   DWORD          dwSize;
   LPDWORD        pdwInstalledVer;
   LPDWORD        pdwInstalledBuild;
   LPSTR          pszGUID;
   LPSTR          pszLocale;
   DWORD          dwAskVer;
   DWORD          dwAskBuild;
   ICifFile      *pCifFile; 
   ICifComponent *pCifComp; 
} DETECTION_STRUCT;


typedef DWORD (WINAPI *DETECTVERSION)(DETECTION_STRUCT *pDetectionStruct);

///////////////////////////////////////////////////////////////////////////////////////////////////////////



DEFINE_GUID(IID_IInstallEngine2,0x6E449689L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngine2

DECLARE_INTERFACE_(IInstallEngine2 , IInstallEngine)
{
   STDMETHOD(SetLocalCif)(THIS_ LPCSTR pszCif) PURE;
   STDMETHOD(GetICifFile)(THIS_ ICifFile **picif) PURE;
};

HRESULT WINAPI GetICifFileFromFile(ICifFile **, LPCSTR pszFile);

HRESULT WINAPI GetICifRWFileFromFile(ICifRWFile **, LPCSTR pszFile);

#ifdef __cplusplus
}
#endif

#define _INSENG_H_
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\jobexec.h ===
//=--------------------------------------------------------------------------=
// jobexec.h
//=--------------------------------------------------------------------------=
// Copyright 1996-1998 Microsoft Corporation.  All Rights Reserved.
//
//
// interface declaration for the JobExecuter object.
//
#ifndef _JOBEXEC_H_

#ifdef __cplusplus
extern "C"{
#endif

typedef struct
{
   DWORD cbSize;
   DWORD dwKBReqWinDrive;
   DWORD dwKBAvailWinDrive;
   DWORD dwKBReqInstallDrive;
   DWORD dwKBAvailInstallDrive;
   DWORD dwKBReqDownloadDrive;
   DWORD dwKBAvailDownloadDrive;
} CHECKDISKSPACE;

// {7279B780-2867-11d0-A066-00AA00B6015C}
DEFINE_GUID(CLSID_JobExecuter, 0x7279b780, 0x2867, 0x11d0, 0xa0, 0x66, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

// {7279B781-2867-11d0-A066-00AA00B6015C}
DEFINE_GUID(IID_IJobExecuter, 0x7279b782, 0x2867, 0x11d0, 0xa0, 0x66, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

#undef INTERFACE
#define INTERFACE IJobExecuter

#define E_PARTIAL                   _HRESULT_TYPEDEF_(0x80100001L)
#define E_ABORTPARTIAL              _HRESULT_TYPEDEF_(0x80100002L)


DECLARE_INTERFACE_(IJobExecuter, IUnknown)
{
   // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(InitializeJob)(THIS_ LPCSTR pszJobName, char chMode) PURE;
   STDMETHOD(SetDownloadDir)(THIS_ LPCSTR pszDownloadDir) PURE;
   STDMETHOD(SetBaseUrls)(THIS_ LPCSTR pszBaseUrl) PURE;
   STDMETHOD(SetInstallDrive)(THIS_ CHAR chDrive) PURE;
   STDMETHOD(SetInstallMode)(THIS_ CHAR chMode) PURE;
   STDMETHOD(SetInstallOptions)(THIS_ DWORD dwInsFlag) PURE;
   STDMETHOD(CheckFreeSpace)(THIS_  CHECKDISKSPACE *pcds) PURE;

   STDMETHOD(DownloadJob)(THIS_ DWORD dwFlags, LPSTR *ppszSuccessStr, LPSTR *ppszErrorStr) PURE;
   STDMETHOD(InstallJob)(THIS_ DWORD dwFlags, DWORD *dwStatus,
                               LPSTR *ppszSuccessStr, LPSTR *ppszErrorStr) PURE;



   STDMETHOD(SetHWND)(THIS_ HWND hForUI) PURE;
   STDMETHOD(SetIStream)(THIS_ IStream *pstm) PURE;
};

// The job key, off of HKCU
#define KEY_JOB  "Software\\Microsoft\\Active Setup\\Jobs"

#define VALUE_BASEURL      "BaseUrl"
#define VALUE_CIFNAME      "InstallList"
#define VALUE_CABNAME      "CabName"
#define VALUE_MODELIST     "InstallModes"
#define VALUE_DEFAULTMODE  "DefaultMode"
#define VALUE_QUIETMODE    "QuietMode"
#define VALUE_LOCALURL     "LocalUrl"

// for support of suspend,resume,abort from outside jobexec.dll
#define VALUE_STATUS      "Status"
#define DATA_SUSPEND       1
#define DATA_RESUME        2
#define DATA_ABORT         3

#ifdef __cplusplus
}
#endif

#define _JOBEXEC_H_
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\inetreg.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1998               **
//*********************************************************************

//
//      INETREG.H - String literals for HKEYs in registry
//

#ifndef _INETREGSTRS_H_
#define _INETREGSTRS_H_


//
// HKEY: HKEY_CURRENT_USER
//

//
// Top level defines
//
#define TSZMICROSOFTPATH                  TEXT("Software\\Microsoft")
#define TSZIEPATH        TSZMICROSOFTPATH TEXT("\\Internet Explorer")
#define TSZWINCURVERPATH TSZMICROSOFTPATH TEXT("\\windows\\CurrentVersion")
#define TSZWININETPATH   TSZWINCURVERPATH TEXT("\\Internet Settings")

// Windows : HKLM
#define REGSTR_PATH_RUNONCE_KEY TSZWINCURVERPATH TEXT("\\RunOnce")

// INETCPL : HKLM
#define REGSTR_PATH_INETCPL_PS_EXTENTIONS TSZWINCURVERPATH TEXT("\\Controls Folder\\Internet")

//
// Explorer : HKCU
//
#define REGSTR_PATH_IEXPLORER           TSZIEPATH

// Main
#define SZ_IE_MAIN                      "Main"
#define REGSTR_PATH_MAIN                TSZIEPATH TEXT( "\\") TEXT(SZ_IE_MAIN)
#define REGSTR_KEY_MAIN                 TEXT(SZ_IE_MAIN)

#define REGSTR_VAL_SMOOTHSCROLL         TEXT("SmoothScroll")
#define REGSTR_VAL_SMOOTHSCROLL_DEF     TRUE

#define REGSTR_VAL_SHOWTOOLBAR          TEXT("Show_ToolBar")
#define REGSTR_VAL_SHOWADDRESSBAR       TEXT("Show_URLToolBar")
#define REGSTR_VAL_STARTPAGE            TEXT("Start Page")
#define REGSTRA_VAL_STARTPAGE           "Start Page"
#define REGSTR_VAL_SEARCHPAGE           TEXT("Search Page")
#define REGSTR_VAL_LOCALPAGE            TEXT("Local Page")

#define REGSTR_VAL_USESTYLESHEETS       TEXT("Use Stylesheets")
#define REGSTR_VAL_USESTYLESHEETS_TYPE  REG_SZ  // "yes" or "no"
#define REGSTR_VAL_USESTYLESHEETS_DEF   TEXT("yes")

#define REGSTR_VAL_USEICM               TEXT("UseICM")
#define REGSTR_VAL_USEICM_DEF           FALSE

#define REGSTR_VAL_SHOWFOCUS            TEXT("Tabstop - MouseDown")
#define REGSTR_VAL_SHOWFOCUS_TYPE       REG_SZ  // "yes" or "no"
#define REGSTR_VAL_SHOWFOCUS_DEF        TEXT("no")

#define REGSTR_VAL_LOADIMAGES           TEXT("Display Inline Images")
#define REGSTR_VAL_PLAYSOUNDS           TEXT("Play_Background_Sounds")
#define REGSTR_VAL_PLAYVIDEOS           TEXT("Display Inline Videos")
#define REGSTR_VAL_ANCHORUNDERLINE      TEXT("Anchor Underline")
#define REGSTR_VAL_USEDLGCOLORS         TEXT("Use_DlgBox_Colors")
#define REGSTR_VAL_CHECKASSOC           TEXT("Check_Associations")
#define REGSTR_VAL_SHOWFULLURLS         TEXT("Show_FullURL")
#define REGSTR_VAL_AUTOSEARCH           TEXT("Do404Search")
#define REGSTR_VAL_AUTONAVIGATE         TEXT("SearchForExtensions")
#define REGSTR_VAL_HTTP_ERRORS          TEXT("Friendly http errors")

#define REGSTR_VAL_PAGETRANSITIONS      TEXT("Page_Transitions")
#define REGSTR_VAL_PAGETRANSITIONS_DEF  TRUE

#define REGSTR_VAL_USEIBAR              TEXT("UseBar")

// Settings
#define SZ_IE_SETTINGS  "Settings"
#define REGSTR_PATH_IE_SETTINGS         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SETTINGS)
#define REGSTR_KEY_IE_SETTINGS          TEXT(SZ_IE_SETTINGS)

#define REGSTR_VAL_IE_CUSTOMCOLORS      TEXT("Custom Colors")
#define REGSTR_VAL_IE_CUSTOMCOLORS_TYPE REG_BINARY

#define REGSTR_VAL_ANCHORCOLOR          TEXT("Anchor Color")
#define REGSTR_VAL_ANCHORCOLORVISITED   TEXT("Anchor Color Visited")
#define REGSTR_VAL_BACKGROUNDCOLOR      TEXT("Background Color")
#define REGSTR_VAL_TEXTCOLOR            TEXT("Text Color")
#define REGSTR_VAL_ANCHORCOLORHOVER     TEXT("Anchor Color Hover")
#define REGSTR_VAL_USEHOVERCOLOR        TEXT("Use Anchor Hover Color")

// Security
#define SZ_IE_SECURITY  "Security"
#define REGSTR_PATH_IE_SECURITY         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SECURITY)
#define REGSTR_KEY_IE_SECURITY          TEXT(SZ_IE_SECURITY)

#define REGSTR_VAL_SAFETYWARNINGLEVEL   TEXT("Safety Warning Level")

// HTML Editing
#define SZ_IE_DEFAULT_HTML_EDITOR       "Default HTML Editor"
#define REGSTR_PATH_DEFAULT_HTML_EDITOR TSZIEPATH TEXT("\\") TEXT(SZ_IE_DEFAULT_HTML_EDITOR)
#define REGSTR_KEY_DEFAULT_HTML_EDITOR  TEXT(SZ_IE_DEFAULT_HTML_EDITOR)

// Autocomplete
#define REGSTR_PATH_AUTOCOMPLETE        TSZWINCURVERPATH TEXT("\\Explorer\\AutoComplete")
#define REGSTR_VAL_USEAUTOAPPEND        TEXT("Append Completion")
#define REGSTR_VAL_USEAUTOSUGGEST       TEXT("AutoSuggest")

// Old IE4 autocomplete key
#define REGSTR_VAL_USEAUTOCOMPLETE      TEXT("Use AutoComplete")

// iBar
#define SZ_IE_IBAR                      "Bar"
#define TSZIBARPATH                     TSZIEPATH TEXT( "\\") TEXT(SZ_IE_IBAR)
#define REGSTR_PATH_IBAR                TSZIBARPATH
#define REGSTR_KEY_IBAR                 TEXT(SZ_IE_IBAR)

#define SZ_IE_IBAR_BANDS                "Bands"
#define REGSTR_PATH_IBAR_BANDS          TSZIBARPATH TEXT("\\") TEXT(SZ_IE_IBAR_BANDS)
#define REGSTR_KEY_IBAR_BANDS           TEXT(SZ_IE_IBAR_BANDS)


//
// Internet : HKCU
//
// path to global internet settings (also under HKEY_CURRENT_USER)
#define REGSTR_PATH_INTERNETSETTINGS    TSZWININETPATH
#define REGSTR_PATH_INTERNET_SETTINGS   REGSTR_PATH_INTERNETSETTINGS

#define REGSTR_VAL_USERAGENT            TEXT("User Agent")

// path to lan-specific settings
#define REGSTR_PATH_INTERNET_LAN_SETTINGS REGSTR_PATH_INTERNETSETTINGS TEXT("\\LAN")

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_INTERNETENTRY        TEXT("InternetProfile")
#define REGSTR_VAL_INTERNETPROFILE      REGSTR_VAL_INTERNETENTRY

#define REGSTR_VAL_INTERNETENTRYBKUP    TEXT("BackupInternetProfile")

#define REGSTR_VAL_CODEDOWNLOAD         TEXT("Code Download")
#define REGSTR_VAL_CODEDOWNLOAD_DEF     TEXT("yes")
#define REGSTR_VAL_CODEDOWNLOAD_TYPE    REG_SZ // "yes" or "no"

// policy key for inetcpl restrictions

#define REGSTR_PATH_INETCPL_RESTRICTIONS  TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")

// reg valuenames to restrict whether a tab should be shown or not;
// a value of non-zero means don't show that tab.
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_GENERALTAB     TEXT("GeneralTab")
#define REGSTR_VAL_INETCPL_SECURITYTAB    TEXT("SecurityTab")
#define REGSTR_VAL_INETCPL_CONTENTTAB     TEXT("ContentTab")
#define REGSTR_VAL_INETCPL_CONNECTIONSTAB TEXT("ConnectionsTab")
#define REGSTR_VAL_INETCPL_PROGRAMSTAB    TEXT("ProgramsTab")
#define REGSTR_VAL_INETCPL_ADVANCEDTAB    TEXT("AdvancedTab")
#define REGSTR_VAL_INETCPL_PRIVACYTAB     TEXT("PrivacyTab")

// setting to indicate whether or not IEAK launched this instance of inetcpl so extra
// info can be exposed
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_IEAK           TEXT("IEAKContext")

//
//  Cache
//
#define REGSTR_PATH_CACHE  \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Cache")

#define REGSTR_PATH_CACHE_PATHS \
    REGSTR_PATH_CACHE TEXT("\\Paths")

#define REGSTR_PATH_EXTENSIBLE_CACHE \
    REGSTR_PATH_CACHE TEXT("\\Extensible Cache")

#define REGSTR_PATH_TRACKING \
    REGSTR_PATH_EXTENSIBLE_CACHE TEXT("\\Log")

#define REGSTR_PATH_CACHE_SPECIAL_PATHS \
    REGSTR_PATH_CACHE TEXT("Special Paths")

#define REGSTR_VAL_DIRECTORY           TEXT("Directory")
#define REGSTR_VAL_DIRECTORY_TYPE            REG_EXPAND_SZ

#define REGSTR_VAL_NEWDIRECTORY         TEXT("NewDirectory")
#define REGSTR_VAL_NEWDIRECTORY_TYPE    REG_EXPAND_SZ

#define REGSTR_VAL_CACHEPREFIX              TEXT("CachePrefix")
#define REGSTR_VAL_CACHEPREFIX_TYPE     REG_SZ

#define REGSTR_PATH_URLHISTORY \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Url History")

#define REGSTR_PATH_SUBSCRIPTION \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Subscription Folder")

//
// Search Format Strings
//
#define SZ_IE_SEARCHSTRINGS             "UrlTemplate"
#define REGSTR_PATH_SEARCHSTRINGS       REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_SEARCHSTRINGS)
#define REGSTR_KEY_SEARCHSTRINGS        TEXT(SZ_IE_SEARCHSTRINGS)

#define MAX_SEARCH_FORMAT_STRING        255

//
// Server error page dispaly/don't display length thresholds.
//
#define SZ_IE_THRESHOLDS                "ErrorThresholds"
#define REGSTR_PATH_THRESHOLDS          REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_THRESHOLDS)


//
// Access Medium
//
#define REGSTR_VAL_ACCESSMEDIUM         TEXT("AccessMedium")
// access type (MSN, other)
#define REGSTR_VAL_ACCESSTYPE           TEXT("AccessType")

//
// AutoDial
//
// name of connectoid-specific autodial handler dll and function
#define REGSTR_VAL_AUTODIALDLLNAME      TEXT("AutodialDllName")
#define REGSTR_VAL_AUTODIALFCNNAME      TEXT("AutodialFcnName")
// class name for window to receive Winsock activity messages
#define REGSTR_VAL_AUTODIAL_MONITORCLASSNAME    TEXT("MS_AutodialMonitor")
#define REGSTR_VAL_AUTODIAL_TRYONLYONCE         TEXT("TryAutodialOnce")

//
// Remote Access
//
// path to RNA values (under HKEY_CURRENT_USER)
#define REGSTR_PATH_REMOTEACCESS        TEXT("RemoteAccess")
#define REGSTR_PATH_REMOTEACESS         REGSTR_PATH_REMOTEACCESS
// this is under HKLM... we are using this to determine if RNA is installed
// or not. We can't rely on finding the DLL since removing this component
// with the control panel's "Add/Remove Software" does not remove the RNAdll.
#define REGSTR_PATH_RNACOMPONENT    TSZWINCURVERPATH    TEXT("\\Setup\\OptionalComponents\\RNA")
#define REGSTR_VAL_RNAINSTALLED     TEXT("Installed")

// values under HKCU\REGSTR_PATH_INTERNET_SETTINGS

// 4-byte REG_BINARY, autodialing is enabled if this value is present and
// non-zero, disabled otherwise
// If ForceAutodial is true, will always dial similar to IE4 behavior.
// If it's false, will only dial if network is not available.
#define REGSTR_VAL_ENABLEAUTODIAL               TEXT("EnableAutodial")
#define REGSTR_VAL_ENABLEUNATTENDED             TEXT("EnableUnattended")
#define REGSTR_VAL_NONETAUTODIAL                TEXT("NoNetAutodial")

#define REGSTR_VAL_REDIALATTEMPTS               TEXT("RedialAttempts")
#define REGSTR_VAL_REDIALINTERVAL               TEXT("RedialWait")

#define REGSTR_VAL_ENABLEAUTODIALDISCONNECT     TEXT("EnableAutodisconnect")
#define REGSTR_VAL_ENABLEAUTODISCONNECT         REGSTR_VAL_ENABLEAUTODIALDISCONNECT
#define REGSTR_VAL_ENABLEEXITDISCONNECT         TEXT("EnableExitDisconnect")

#define REGSTR_VAL_ENABLESECURITYCHECK          TEXT("EnableSecurityCheck")

#define REGSTR_VAL_COVEREXCLUDE                 TEXT("CoverExclude")
// 4-byte REG_BINARY containing number of minutes of idle time to allow
// before autodisconnect.  Autodisconnect is disabled if this value is zero
// or not present.
#define REGSTR_VAL_DISCONNECTIDLETIME   TEXT("DisconnectIdleTime")

//
// MOS
//
#define REGSTR_PATH_MOSDISCONNECT       TSZMICROSOFTPATH TEXT("\\MOS\\Preferences")
#define REGSTR_VAL_MOSDISCONNECT        TEXT("DisconnectTimeout")

//
// Proxy : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_PROXYENABLE          TEXT("ProxyEnable")
#define REGSTR_VAL_PROXYSERVER          TEXT("ProxyServer")
#define REGSTR_VAL_PROXYOVERRIDE        TEXT("ProxyOverride")
#define REGSTR_VAL_BYPASSAUTOCONFIG     TEXT("BypassAutoconfig")



//
// Security : HKCU\\WININETPATH
//
#define SZTRUSTWARNLEVEL                    "Trust Warning Level"
#define REGSTR_KEY_TRUSTWARNINGLEVEL        TSZWININETPATH  TEXT(SZTRUSTWARNLEVEL)
#define REGSTR_VAL_TRUSTWARNINGLEVEL        TEXT(SZTRUSTWARNLEVEL) //"none" will turn off WinVerifyTrust warnings.
#define REGSTR_VAL_TRUSTWARNINGLEVEL_TYPE   REG_SZ
#define REGSTR_VAL_TRUSTWARNINGLEVEL_HIGH   TEXT("High")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_MED    TEXT("Medium")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_LOW    TEXT("No Security")
// default depends on MSHTML's prefs nSafetyWarningLevel

#define REGSTR_VAL_SECURITYWARNONSEND       TEXT("WarnOnPost")
#define REGSTR_VAL_SECURITYWARNONSEND_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONSEND_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONSENDALWAYS         TEXT("WarnAlwaysOnPost")
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_TYPE    REG_BINARY // FALSE-Only if... TRUE-Always
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONVIEW       TEXT("WarnOnView")
#define REGSTR_VAL_SECURITYWARNONVIEW_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONVIEW_DEF   TRUE

#define REGSTR_VAL_SECURITYALLOWCOOKIES         TEXT("AllowCookies")
#define REGSTR_VAL_SECURITYALLOWCOOKIES_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYALLOWCOOKIES_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONZONECROSSING       TEXT("WarnOnZoneCrossing")
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING         TEXT("WarnOnBadCertRecving")
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING         TEXT("WarnOnBadCertSending")
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_DEF     TRUE

#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES       TEXT("DisableCachingOfSSLPages")
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_TYPE  REG_DWORD
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_DEF   FALSE


//
// Run/Show ActiveX / Java : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_SECURITYACTIVEX              TEXT("Security_RunActiveXControls")
#define REGSTR_VAL_SECURITYACTIVEX_TYPE         REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTIVEX_DEF          TRUE

#define REGSTR_VAL_SECURITYACTICEXSCRIPTS       TEXT("Security_RunScripts")
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_TYPE  REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_DEF   TRUE

#define REGSTR_VAL_SECURITYJAVA                 TEXT("Security_RunJavaApplets")
#define REGSTR_VAL_SECURITYJAVA_TYPE            REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYJAVA_DEF             TRUE

//
// Java VM exclusively : HKCU
//
#define SZJAVAVMPATH                            "\\Java VM"
#define REGSTR_PATH_JAVAVM                      TSZMICROSOFTPATH TEXT(SZJAVAVMPATH)

#define REGSTR_VAL_JAVAJIT                      TEXT("EnableJIT")
#define REGSTR_VAL_JAVAJIT_TYPE                 REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVAJIT_DEF                  FALSE

#define REGSTR_VAL_JAVALOGGING                   TEXT("EnableLogging")
#define REGSTR_VAL_JAVALOGGING_TYPE              REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVALOGGING_DEF               FALSE


//
// QuickLinks
//
// this is where custom quicklinks are stored
#define SZTOOLBAR               "\\Toolbar"
#define TSZTOOLBAR              TEXT(SZTOOLBAR)
#define REGSTR_PATH_TOOLBAR     TSZIEPATH TEXT(SZTOOLBAR)
#define REGSTR_KEY_QUICKLINKS   TSZIEPATH TSZTOOLBAR TEXT("\\Links")
#define REGSTR_VAL_DAYSTOKEEP   TEXT("DaysToKeep")

#define SZNOTEXT                "NoText"
#define REGSTR_VAL_NOTEXT       TEXT(SZNOTEXT)
#define REGSTR_KEY_NOTEXT       TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZNOTEXT)
#define SZVISIBLE               "VisibleBands"
#define REGSTR_VAL_VISIBLE      TEXT(SZVISIBLE)
#define REGSTR_KEY_VISIBLE      TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZVISIBLE)


#define REGSTR_VAL_VISIBLEBANDS         TEXT("VisibleBands")
#define REGSTR_VAL_VISIBLEBANDS_TYPE    REG_DWORD   // 3 bits (see below)
#define REGSTR_VAL_VISIBLEBANDS_DEF     0x7         // all three bands
#define TOOLSBAND                       0x1
#define ADDRESSBAND                     0x2
#define LINKSBAND                       0x4

#define SZBACKBITMAP          "BackBitmap"
#define REGSTR_VAL_BACKBITMAP       TEXT("BackBitmap")
#define REGSTR_VAL_BACKBITMAP_TYPE  REG_SZ
// "" = no bitmap or fillin with valid path, delete for default

#define REGSTR_KEY_BACKBITMAP   TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZBACKBITMAP)

//
// Schannel Settings: HKLM
//

#define TSZSCHANNELPATH             TEXT("SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL")
#define TSZSCHANNELPROTOCOLSPATH    TSZSCHANNELPATH TEXT("\\Protocols")

#define REGSTR_PATH_PCT1            TSZSCHANNELPROTOCOLSPATH TEXT("\\PCT 1.0\\Client")
#define REGSTR_PATH_SSL2            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 2.0\\Client")
#define REGSTR_PATH_SSL3            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 3.0\\Client")
#define REGSTR_PATH_UNIHELLO        TSZSCHANNELPROTOCOLSPATH TEXT("\\Multi-Protocol Unified Hello\\Client")

#define REGSTR_VAL_SCHANNELENABLEPROTOCOL         TEXT("Enabled")
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_TYPE    REG_DWORD
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_DEF     TRUE


//
// Mail and News: HKLM
//
#ifdef UNIX

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Microsoft\\Internet Explorer\\Unix")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\MailCommand")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\NewsCommand")
#define REGSTR_PATH_VSOURCECLIENTS  TSZINTERNETCLIENTSPATH  TEXT("\\VSourceCommand")
#define REGSTR_PATH_EDITORS         TSZINTERNETCLIENTSPATH  TEXT("\\Editors")
#define REGSTR_PATH_DEFAULT         TEXT("default")
#define REGSTR_PATH_CURRENT         TEXT("current")

#else

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Clients")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Mail")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\News")
#define REGSTR_PATH_CALENDARCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Calendar")
#define REGSTR_PATH_CONTACTCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Contacts")
#define REGSTR_PATH_CALLCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Internet Call")

#endif // !UNIX

#ifdef UNIX
// Registry item containing the exe name to check for disabling OE
#define IE_USE_OE_PRESENT_HKEY HKEY_LOCAL_MACHINE
#define IE_USE_OE_PRESENT_KEY  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\app.paths\\msimn.exe")
#define IE_USE_OE_PRESENT_VALUE NULL

// locations for new OE control variables for unix
#define IE_USE_OE_MAIL_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_MAIL_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\Mail")
#define IE_USE_OE_MAIL_VALUE TEXT("Use Outlook Express")

#define IE_USE_OE_NEWS_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_NEWS_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\News")
#define IE_USE_OE_NEWS_VALUE TEXT("Use Outlook Express")
#endif // UNIX

// this is under the mail and news paths
#define TSZPROTOCOLSPATH            TEXT("Protocols\\")
// and one these is under the protocols path
#define TSZMAILTOPROTOCOL           TEXT("mailto")
#define TSZNEWSPROTOCOL             TEXT("news")
#define TSZCALLTOPROTOCOL           TEXT("callto")
#define TSZLDAPPROTOCOL             TEXT("ldap")
#define TSZCALENDARPROTOCOL         TEXT("unk")

#ifdef UNIX
#define TSZVSOURCEPROTOCOL          TEXT("view source")
#endif

//
// International and Fonts: HKCU\\TSZIEPATH
//
#define REGSTR_PATH_INTERNATIONAL   TSZIEPATH   TEXT("\\International")

#define REGSTR_PATH_INTERNATIONAL_SCRIPTS  TSZIEPATH   TEXT("\\International\\Scripts")

#define REGSTR_VAL_DEFAULT_CODEPAGE         TEXT("Default_CodePage")
#define REGSTR_VAL_DEFAULT_CODEPAGE_TYPE    REG_SZ  // code page
                   // will grab default from system if not found

#define REGSTR_VAL_DEFAULT_SCRIPT         TEXT("Default_Script")
#define REGSTR_VAL_DEFAULT_SCRIPT_TYPE    REG_SZ  
                   // will grab default from system if not found


#define REGSTR_VAL_ACCEPT_LANGUAGE          TEXT("AcceptLanguage")
#define REGSTR_VAL_ACCETP_LANGUAGE_TYPE     REG_SZ


// each CHARSET has a unique key under REGSTR_PATH_INTERNATIONAL
// which has the following values defined
#define REGSTR_VAL_FONT_SCRIPTS          TEXT("Scripts")
#define REGSTR_VAL_FONT_SCRIPT           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_TYPE      REG_SZ  // friendly name of font if other than system
                                                 // no default

#define REGSTR_VAL_FONT_SCRIPT_NAME           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_NAME_TYPE      REG_SZ                                                        


#define REGSTR_VAL_DEF_ENCODING         TEXT("Default_Encoding")
#define REGSTR_VAL_DEF_ENCODING_TYPE    REG_SZ  // internal MIME table name
                                                // no default

#define REGSTR_VAL_DEF_INETENCODING         TEXT("Default_InternetEncoding")
#define REGSTR_VAL_DEF_INETENCODING_TYPE    REG_DWORD
                                                // no default

#define REGSTR_VAL_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_SCRIPT_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_SCRIPT_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_FONT_SIZE        TEXT("IEFontSize")
#define REGSTR_VAL_FONT_SIZE_TYPE   REG_BINARY
#define REGSTR_VAL_FONT_SIZE_DEF    2       // default size : Medium

#define REGSTR_VAL_AUTODETECT         TEXT("AutoDetect")
#define REGSTR_VAL_AUTODETECT_TYPE    REG_SZ

// MIME database charset extension
#define REGSTR_PATH_MIME_DATABASE           TEXT("MIME\\Database")
#define REGSTR_KEY_MIME_DATABASE_CHARSET    REGSTR_PATH_MIME_DATABASE TEXT("\\Charset")
#define REGSTR_KEY_MIME_DATABASE_CODEPAGE   REGSTR_PATH_MIME_DATABASE TEXT("\\CodePage")
#define REGSTR_KEY_MIME_DATABASE_RFC1766    REGSTR_PATH_MIME_DATABASE TEXT("\\Rfc1766")

#define REGSTR_VAL_CODEPAGE                 TEXT("CodePage")
#define REGSTR_VAL_CODEPAGE_TYPE            REG_DWORD

#define REGSTR_VAL_INETENCODING             TEXT("InternetEncoding")
#define REGSTR_VAL_INETENCODING_TYPE        REG_DWORD

#define REGSTR_VAL_FAMILY                   TEXT("Family")
#define REGSTR_VAL_FAMILY_TYPE              REG_DWORD

#define REGSTR_VAL_LEVEL                    TEXT("Level")
#define REGSTR_VAL_LEVEL_TYPE               REG_DWORD

#define REGSTR_VAL_ALIASTO                  TEXT("AliasForCharset")
#define REGSTR_VAL_ALIASTO_TYPE             REG_SZ

#define REGSTR_VAL_ENCODENAME               TEXT("EncodingName")
#define REGSTR_VAL_ENCODENAME_TYPE          REG_SZ

#define REGSTR_VAL_DESCRIPTION              TEXT("Description")
#define REGSTR_VAL_DESCRIPTION_TYPE         REG_SZ

#define REGSTR_VAL_WEBCHARSET               TEXT("WebCharset")
#define REGSTR_VAL_WEBCHARSET_TYPE          REG_SZ

#define REGSTR_VAL_BODYCHARSET              TEXT("BodyCharset")
#define REGSTR_VAL_BODYCHARSET_TYPE         REG_SZ

#define REGSTR_VAL_HEADERCHARSET            TEXT("HeaderCharset")
#define REGSTR_VAL_HEADERCHARSET_TYPE       REG_SZ

#define REGSTR_VAL_FIXEDWIDTHFONT           TEXT("FixedWidthFont")
#define REGSTR_VAL_FIXEDWIDTHFONT_TYPE      REG_SZ

#define REGSTR_VAL_PROPORTIONALFONT         TEXT("ProportionalFont")
#define REGSTR_VAL_PROPOPRTIONALFONT_TYPE   REG_SZ

#define REGSTR_VAL_PRIVCONVERTER            TEXT("PrivConverter")
#define REGSTR_VAL_PRIVCONVERTER_TYPE       REG_SZ

#endif // _INETREGSTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\makefile.inc ===
#
#
#  R E A D   T H I S
#
#  See the inference rules below (the section marked "Inference rules") to
#  see if any of them cover the rule that you want performed for your file.
#  The inference rules should cover most of the cases.  If they don't, try
#  to add a new inference rule rather than adding a special-case rule for
#  your file.
#

#
# Special rules for splitting out .w files
#

# wininet.h and wininetp.h

$(O)\wininet.x $(O)\wininetp.x: wininet.w
    hsplit -e -o $(O)\wininet.x $(O)\wininetp.x $?

$(O)\wininet.h: $(O)\wininet.x
    wcshdr < $? > $@

$(O)\wininetp.h: $(O)\wininetp.x
    wcshdr < $? > $@


$(O)\winhttp.h $(O)\winhttpi.h: winhttp.w
    hsplit -o $(O)\winhttp.h $(O)\winhttpi.h $?


#
# Non-obvious Dependencies
#


#
# Inference rules.  These help build whatever is in the NTTARGETFILES and
# NTTARGETFILE0 lists.  Most of these simply copy files.
#

.SUFFIXES:.h .w .hpp .tlb .dlg .c .cpp


{}.w{$O}.h:
    hsplit -e -o $(O)\$(?R).x $(O)\$(?R)p.x $?
    wcshdr < $(O)\$(?R).x > $*.h

{}.w{}.h:
    hsplit -e -o $(O)\$(?R).x $(O)\$(?R)p.x $?
    wcshdr < $(O)\$(?R).x > $(O)\$*.h

#
#   mshtml.h has special funkiness:
#
#       mshtml.idl -> obj\mshtml.h -[copy]-> sdk\inc\mshtmlc.h
#                     obj\mshtml.h -[sed]--> sdk\inc\mshtml.h
#
#   obj\mshtml.h is generated by MIDL and contains both C and C++ support.
#   splthdr.sed removes the C support; the result goes to sdk\inc\mshtml.h.
#   The C version goes to sdk\inc\mshtmlc.h.

$(O)\mshtmlcpp.h: $(O)\mshtml.h
    type << > $@
#if !defined(__cplusplus) || defined(CINTERFACE)
// Include the full header file that works for C
#include "mshtmlc.h"
#else
<<
    perl splthdr.pl < $? >> $@
    type << >> $@
#endif /* !defined(__cplusplus) || defined(CINTERFACE) */
<<
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\lendian.hpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       lendian.hpp
//
//  Contents:   Templatized data types for access to unaligned scalar values.
//
//----------------------------------------------------------------------------

// Implementation of LENDIAN data values.  This works for simple scalar values.
// This file is heavily macro-based.  The intent is to do this work with arithmetic.
// The functionality may be expressed much more consisely with memcpy, but I need an
// implementation faster than that.

// To create an LENDIAN type, use the MAKE_LENDIAN_TYPE macro.  For example, if
// you need an int_LENDIAN, say
//
//        MAKE_LENDIAN_TYPE( int, 4 );
//
// Note that you need to specifiy the size of the base type.  This is because the
// amount of work to be done needs to be known by the preprocessor, where sizeof()
// doesn't work.

// To use: The intent is that replace occurances of "type LENDIAN" in your code
// with "type_LENDIAN".  It's simply a lexical change.  You could automate this
// change in order to easily convert code.  More importantly, the reverse
// transformation may also be easily automated, making it easier to merge with code
// that doesn't use these types.

// LENDIAN64: The unaligned 64 types are an optimization.  They should only be used
// for values over four bytes in size (e.g. __int64, double).  They assume that the
// pointers are aligned to 4-bytes, so that access may be done with two 32-bit
// references, instead of 8 8-bit references.

#ifndef __lendian_h__
#define __lendian_h__

#if defined(_MSC_VER) && !defined(BIG_ENDIAN)

#define MAKE_LENDIAN_UNALIGNED_TYPE(base,size)    typedef base UNALIGNED   base##_LENDIAN_UNALIGNED
#define MAKE_LENDIAN_TYPE(base,size)              typedef base             base##_LENDIAN_UNALIGNED; \
                                                  typedef base   base##_LENDIAN \

//
// Use MAKE_UNALIGNED64_TYPE for QWORD data that may only be DWORD aligned on 64-bit 
// machines.  Only 64-bit architectures pay the penalty for accessing such data.
//   
#if defined(ALPHA)
#  define MAKE_LENDIAN64_UNALIGNED_TYPE(base,size)  typedef base UNALIGNED base##_LENDIAN64_UNALIGNED
#else
#  define MAKE_LENDIAN64_UNALIGNED_TYPE(base,size)  typedef base base##_LENDIAN64_UNALIGNED
#endif
#define MAKE_LENDIAN64_TYPE(base,size)  typedef base base##_LENDIAN64

#define MAKE_LENDIANPTR_UNALIGNED_TYPE(base)      typedef base UNALIGNED *base##_LENDIANPTR_UNALIGNED
#define MAKE_LENDIANPTR_TYPE(base)                typedef base *base##_LENDIANPTR

#else // _MSC_VER

#define SET2(val,data)                          \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET2(data)                          \
    ( ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET4(val,data)                          \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET4(data)                              \
    ( ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET8(val,data)                          \
    data[7] = (val) >> 56,                      \
    data[6] = (val) >> 48,                      \
    data[5] = (val) >> 40,                      \
    data[4] = (val) >> 32,                      \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET8(data)                              \
    ( ( data[7] << 56 ) |                       \
      ( data[6] << 48 ) |                       \
      ( data[5] << 40 ) |                       \
      ( data[4] << 32 ) |                       \
      ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#if defined( ux10 )
#define SET02(x,y)  SET2(x,y)
#define GET02(x)    GET2(x)
#define SET04(x,y)  SET4(x,y)
#define GET04(x)    GET4(x)
#define SET08(x,y)  SET8(x,y)
#define GET08(x)    GET8(x)
#endif

#define SET648(val,data)                        \
    data[1] = (val) >> 32,                      \
    data[0] = (val)

#define GET648(data)                            \
    ( ( data[1] << 32 ) |                       \
      ( data[0] ) )

#define GROUP(type,size,get,set,sfx)                                                            \
    LEndian##sfx##size( type v ) { set##size( v, data ); }                                      \
    type operator = ( type v )   { set##size( v, data ); return v; }                            \
    operator type()              { return get##size( data ); }                                  \
    type operator += (const type v) { set##size( get##size(data) + v, data); return *this; }    \
    type operator -= (const type v) { set##size( get##size(data) - v, data); return *this; }    \
    type operator <<= (const type v) { set##size( get##size(data) << v, data); return *this; }  \
    type operator <= (const type v) { set##size( get##size(data) < v, data); return *this; }    \
    type operator >= (const type v) { set##size( get##size(data) > v, data); return *this; }    \
    type operator *= (const type v) { set##size( get##size(data) * v, data); return *this; }    \
    type operator /= (const type v) { set##size( get##size(data) / v, data); return *this; }    \
    type operator %= (const type v) { set##size( get##size(data) % v, data); return *this; }    \
    type operator >>= (const type v) { set##size( get##size(data) >> v, data); return *this; }  \
    type operator ^= (const type v) { set##size( get##size(data) ^ v, data); return *this; }    \
    type operator &= (const type v) { set##size( get##size(data) & v, data); return *this; }    \
    type operator |= (const type v) { set##size( get##size(data) | v, data); return *this; }


#define MAKE_TEMPLATE(size,type,sfx)                            \
template<class BASE>                                            \
class LEndian##sfx##size                                        \
{                                                               \
  protected:                                                    \
    type data[ size / sizeof(type) ];                           \
                                                                \
  public:                                                       \
                                                                \
    GROUP( signed char,      size, GET##sfx, SET##sfx, sfx )    \
    GROUP( short,            size, GET##sfx, SET##sfx, sfx )    \
    GROUP( int,              size, GET##sfx, SET##sfx, sfx )    \
    GROUP( wchar_t,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( long,             size, GET##sfx, SET##sfx, sfx )    \
    GROUP( __int64,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned char,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned short,   size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned int,     size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned long,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned __int64, size, GET##sfx, SET##sfx, sfx )    \
}


#if defined( ux10 )
MAKE_TEMPLATE( 2, unsigned char, 0);
MAKE_TEMPLATE( 4, unsigned char, 0);
MAKE_TEMPLATE( 8, unsigned char, 0);
#else
MAKE_TEMPLATE( 2, unsigned char, );
MAKE_TEMPLATE( 4, unsigned char, );
MAKE_TEMPLATE( 8, unsigned char, );
#endif
MAKE_TEMPLATE( 8, unsigned int, 64 );

#if defined( ux10 )
template<class BASE>
class LEndianPtr : LEndian04<BASE> {
public:
	LEndianPtr(const void * v) : LEndian04<BASE>((int)v) { }
	void *operator = (void * v)        { SET4((int)v,data); return v; }
	const void *operator = (const void * v)        { SET4((int)v,data); return v; }
	operator BASE()              { return (BASE)GET4(data); }
};

#else

template<class BASE>
class LEndianPtr : LEndian4<BASE> {
public:
	LEndianPtr(const void * v) : LEndian4<BASE>((int)v) { }
	void *operator = (void * v)        { SET4((int)v,data); return v; }
	const void *operator = (const void * v)        { SET4((int)v,data); return v; }
	operator BASE()              { return (BASE)GET4(data); }
};

#endif


#undef SET2
#undef SET4
#undef SET8
#undef SET648
#undef GROUP
#undef MAKE_TEMPLATE

#if defined( ux10 )
#define MAKE_LENDIAN_TYPE(base,size)            \
   typedef LEndian0##size<base>   base##_LENDIAN; \
   typedef LEndian0##size<base>   base##_LENDIAN_UNALIGNED
#else
#define MAKE_LENDIAN_TYPE(base,size)            \
   typedef LEndian##size<base>   base##_LENDIAN; \
   typedef LEndian##size<base>   base##_LENDIAN_UNALIGNED
#endif

#define MAKE_LENDIAN64_TYPE(base,size)                          \
  typedef LEndian64##size<base> base##_LENDIAN64;                \
  typedef LEndian64##size<base> base##_LENDIAN64_UNALIGNED

#define MAKE_LENDIANPTR_TYPE(base)                              \
  typedef LEndianPtr<base>      base##_LENDIANPTR;               \
  typedef LEndianPtr<base>      base##_LENDIANPTR_UNALIGNED

#endif  // _MSC_VER

// Predefine some of the basic types.

MAKE_LENDIAN_TYPE( short, 2 );
MAKE_LENDIAN_TYPE( int, 4 );
MAKE_LENDIAN_TYPE( long, 4 );
MAKE_LENDIAN_TYPE( WORD, 2 );
MAKE_LENDIAN_TYPE( DWORD, 4 );
MAKE_LENDIAN_TYPE( USHORT, 4 );
MAKE_LENDIAN_TYPE( SHORT, 4 );
MAKE_LENDIAN_TYPE( __int64, 8 );
MAKE_LENDIAN64_TYPE( __int64, 8 );

#endif // __lendian_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\marqinfo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0101 */
/* at Thu Mar 28 23:04:03 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __marqinfo_h__
#define __marqinfo_h__

#ifdef __cplusplus
extern "C"{
#endif

extern const DECLSPEC_SELECTANY IID IID_IMarqueeInfo = {0x0bdc6ae0,0x6d11,0x11cf,{0xbe,0x62,0x00,0x80,0xc7,0x2e,0xdd,0x2d}};
/* Forward Declarations */

#ifndef __IMarqueeInfo_FWD_DEFINED__
#define __IMarqueeInfo_FWD_DEFINED__
typedef interface IMarqueeInfo IMarqueeInfo;
#endif 	/* __IMarqueeInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Mar 28 23:04:03 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */


			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IMarqueeInfo_INTERFACE_DEFINED__
#define __IMarqueeInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMarqueeInfo
 * at Thu Mar 28 23:04:03 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */


#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMarqueeInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetDocCoords(
            /* [out] */ LPRECT prcView,
            /* [in] */ BOOL bGetOnlyIfFullyLoaded,
            /* [out] */ BOOL __RPC_FAR *pfFullyLoaded,
            /* [in] */ int WidthToFormatPageTo) = 0;

    };

#else 	/* C style interface */

    typedef struct IMarqueeInfoVtbl
    {

        HRESULT ( __stdcall __RPC_FAR *QueryInterface )(
            IMarqueeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( __stdcall __RPC_FAR *AddRef )(
            IMarqueeInfo __RPC_FAR * This);

        ULONG ( __stdcall __RPC_FAR *Release )(
            IMarqueeInfo __RPC_FAR * This);

        HRESULT ( __stdcall __RPC_FAR *GetDocCoords )(
            IMarqueeInfo __RPC_FAR * This,
            /* [out] */ LPRECT prcView,
            /* [in] */ BOOL bGetOnlyIfFullyLoaded,
            /* [out] */ BOOL __RPC_FAR *pfFullyLoaded,
            /* [in] */ int WidthToFormatPageTo);

    } IMarqueeInfoVtbl;

    interface IMarqueeInfo
    {
        CONST_VTBL struct IMarqueeInfoVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMarqueeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarqueeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarqueeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarqueeInfo_GetDocCoords(This,prcView,bGetOnlyIfFullyLoaded,pfFullyLoaded,WidthToFormatPageTo)	\
    (This)->lpVtbl -> GetDocCoords(This,prcView,bGetOnlyIfFullyLoaded,pfFullyLoaded,WidthToFormatPageTo)

#endif /* COBJMACROS */


#endif 	/* C style interface */

#endif 	/* __IMarqueeInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\mshtmlp.c ===
#define HDC_UserSize HWND_UserSize
#define HDC_UserMarshal HWND_UserMarshal
#define HDC_UserUnmarshal HWND_UserUnmarshal
#define HDC_UserFree HWND_UserFree
 
#pragma warning(disable:4028)
#include "mshtml_p.c"
#pragma warning(default:4028)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\mshtmcid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1998               **
//*********************************************************************

#ifndef __mshtmcid_h__
#define __mshtmcid_h__

//----------------------------------------------------------------------------
//
// MSHTML Command IDs
//
//----------------------------------------------------------------------------

#define IDM_UNKNOWN                 0
#define IDM_ALIGNBOTTOM             1
#define IDM_ALIGNHORIZONTALCENTERS  2
#define IDM_ALIGNLEFT               3
#define IDM_ALIGNRIGHT              4
#define IDM_ALIGNTOGRID             5
#define IDM_ALIGNTOP                6
#define IDM_ALIGNVERTICALCENTERS    7
#define IDM_ARRANGEBOTTOM           8
#define IDM_ARRANGERIGHT            9
#define IDM_BRINGFORWARD            10
#define IDM_BRINGTOFRONT            11
#define IDM_CENTERHORIZONTALLY      12
#define IDM_CENTERVERTICALLY        13
#define IDM_CODE                    14
#define IDM_DELETE                  17
#define IDM_FONTNAME                18
#define IDM_FONTSIZE                19
#define IDM_GROUP                   20
#define IDM_HORIZSPACECONCATENATE   21
#define IDM_HORIZSPACEDECREASE      22
#define IDM_HORIZSPACEINCREASE      23
#define IDM_HORIZSPACEMAKEEQUAL     24
#define IDM_INSERTOBJECT            25
#define IDM_MULTILEVELREDO          30
#define IDM_SENDBACKWARD            32
#define IDM_SENDTOBACK              33
#define IDM_SHOWTABLE               34
#define IDM_SIZETOCONTROL           35
#define IDM_SIZETOCONTROLHEIGHT     36
#define IDM_SIZETOCONTROLWIDTH      37
#define IDM_SIZETOFIT               38
#define IDM_SIZETOGRID              39
#define IDM_SNAPTOGRID              40
#define IDM_TABORDER                41
#define IDM_TOOLBOX                 42
#define IDM_MULTILEVELUNDO          44
#define IDM_UNGROUP                 45
#define IDM_VERTSPACECONCATENATE    46
#define IDM_VERTSPACEDECREASE       47
#define IDM_VERTSPACEINCREASE       48
#define IDM_VERTSPACEMAKEEQUAL      49
#define IDM_JUSTIFYFULL             50
#define IDM_BACKCOLOR               51
#define IDM_BOLD                    52
#define IDM_BORDERCOLOR             53
#define IDM_FLAT                    54
#define IDM_FORECOLOR               55
#define IDM_ITALIC                  56
#define IDM_JUSTIFYCENTER           57
#define IDM_JUSTIFYGENERAL          58
#define IDM_JUSTIFYLEFT             59
#define IDM_JUSTIFYRIGHT            60
#define IDM_RAISED                  61
#define IDM_SUNKEN                  62
#define IDM_UNDERLINE               63
#define IDM_CHISELED                64
#define IDM_ETCHED                  65
#define IDM_SHADOWED                66
#define IDM_FIND                    67
#define IDM_SHOWGRID                69
#define IDM_OBJECTVERBLIST0         72
#define IDM_OBJECTVERBLIST1         73
#define IDM_OBJECTVERBLIST2         74
#define IDM_OBJECTVERBLIST3         75
#define IDM_OBJECTVERBLIST4         76
#define IDM_OBJECTVERBLIST5         77
#define IDM_OBJECTVERBLIST6         78
#define IDM_OBJECTVERBLIST7         79
#define IDM_OBJECTVERBLIST8         80
#define IDM_OBJECTVERBLIST9         81
#define IDM_OBJECTVERBLISTLAST IDM_OBJECTVERBLIST9
#define IDM_CONVERTOBJECT           82
#define IDM_CUSTOMCONTROL           83
#define IDM_CUSTOMIZEITEM           84
#define IDM_RENAME                  85
#define IDM_IMPORT                  86
#define IDM_NEWPAGE                 87
#define IDM_MOVE                    88
#define IDM_CANCEL                  89
#define IDM_FONT                    90
#define IDM_STRIKETHROUGH           91
#define IDM_DELETEWORD              92
#define IDM_EXECPRINT               93
#define IDM_JUSTIFYNONE             94
#define IDM_TRISTATEBOLD            95
#define IDM_TRISTATEITALIC          96
#define IDM_TRISTATEUNDERLINE       97

#define IDM_FOLLOW_ANCHOR           2008

#define IDM_INSINPUTIMAGE           2114
#define IDM_INSINPUTBUTTON          2115
#define IDM_INSINPUTRESET           2116
#define IDM_INSINPUTSUBMIT          2117
#define IDM_INSINPUTUPLOAD          2118
#define IDM_INSFIELDSET             2119

#define IDM_PASTEINSERT             2120
#define IDM_REPLACE                 2121
#define IDM_EDITSOURCE              2122
#define IDM_BOOKMARK                2123
#define IDM_HYPERLINK               2124
#define IDM_UNLINK                  2125
#define IDM_BROWSEMODE              2126
#define IDM_EDITMODE                2127
#define IDM_UNBOOKMARK              2128

#define IDM_TOOLBARS                2130
#define IDM_STATUSBAR               2131
#define IDM_FORMATMARK              2132
#define IDM_TEXTONLY                2133
#define IDM_OPTIONS                 2135
#define IDM_FOLLOWLINKC             2136
#define IDM_FOLLOWLINKN             2137
#define IDM_VIEWSOURCE              2139
#define IDM_ZOOMPOPUP               2140

// IDM_BASELINEFONT1, IDM_BASELINEFONT2, IDM_BASELINEFONT3, IDM_BASELINEFONT4,
// and IDM_BASELINEFONT5 should be consecutive integers;
//
#define IDM_BASELINEFONT1           2141
#define IDM_BASELINEFONT2           2142
#define IDM_BASELINEFONT3           2143
#define IDM_BASELINEFONT4           2144
#define IDM_BASELINEFONT5           2145

#define IDM_HORIZONTALLINE          2150
#define IDM_LINEBREAKNORMAL         2151
#define IDM_LINEBREAKLEFT           2152
#define IDM_LINEBREAKRIGHT          2153
#define IDM_LINEBREAKBOTH           2154
#define IDM_NONBREAK                2155
#define IDM_SPECIALCHAR             2156
#define IDM_HTMLSOURCE              2157
#define IDM_IFRAME                  2158
#define IDM_HTMLCONTAIN             2159
#define IDM_TEXTBOX                 2161
#define IDM_TEXTAREA                2162
#define IDM_CHECKBOX                2163
#define IDM_RADIOBUTTON             2164
#define IDM_DROPDOWNBOX             2165
#define IDM_LISTBOX                 2166
#define IDM_BUTTON                  2167
#define IDM_IMAGE                   2168
#define IDM_OBJECT                  2169
#define IDM_1D                      2170
#define IDM_IMAGEMAP                2171
#define IDM_FILE                    2172
#define IDM_COMMENT                 2173
#define IDM_SCRIPT                  2174
#define IDM_JAVAAPPLET              2175
#define IDM_PLUGIN                  2176
#define IDM_PAGEBREAK               2177
#define IDM_HTMLAREA                2178

#define IDM_PARAGRAPH               2180
#define IDM_FORM                    2181
#define IDM_MARQUEE                 2182
#define IDM_LIST                    2183
#define IDM_ORDERLIST               2184
#define IDM_UNORDERLIST             2185
#define IDM_INDENT                  2186
#define IDM_OUTDENT                 2187
#define IDM_PREFORMATTED            2188
#define IDM_ADDRESS                 2189
#define IDM_BLINK                   2190
#define IDM_DIV                     2191

#define IDM_TABLEINSERT             2200
#define IDM_RCINSERT                2201
#define IDM_CELLINSERT              2202
#define IDM_CAPTIONINSERT           2203
#define IDM_CELLMERGE               2204
#define IDM_CELLSPLIT               2205
#define IDM_CELLSELECT              2206
#define IDM_ROWSELECT               2207
#define IDM_COLUMNSELECT            2208
#define IDM_TABLESELECT             2209
#define IDM_TABLEPROPERTIES         2210
#define IDM_CELLPROPERTIES          2211
#define IDM_ROWINSERT               2212
#define IDM_COLUMNINSERT            2213

#define IDM_HELP_CONTENT            2220
#define IDM_HELP_ABOUT              2221
#define IDM_HELP_README             2222

#define IDM_REMOVEFORMAT            2230
#define IDM_PAGEINFO                2231
#define IDM_TELETYPE                2232
#define IDM_GETBLOCKFMTS            2233
#define IDM_BLOCKFMT                2234
#define IDM_SHOWHIDE_CODE           2235
#define IDM_TABLE                   2236

#define IDM_COPYFORMAT              2237
#define IDM_PASTEFORMAT             2238
#define IDM_GOTO                    2239

#define IDM_CHANGEFONT              2240
#define IDM_CHANGEFONTSIZE          2241
#define IDM_CHANGECASE              2246
#define IDM_SHOWSPECIALCHAR         2249

#define IDM_SUBSCRIPT               2247
#define IDM_SUPERSCRIPT             2248

#define IDM_CENTERALIGNPARA         2250
#define IDM_LEFTALIGNPARA           2251
#define IDM_RIGHTALIGNPARA          2252
#define IDM_REMOVEPARAFORMAT        2253
#define IDM_APPLYNORMAL             2254
#define IDM_APPLYHEADING1           2255
#define IDM_APPLYHEADING2           2256
#define IDM_APPLYHEADING3           2257

#define IDM_DOCPROPERTIES           2260
#define IDM_ADDFAVORITES            2261
#define IDM_COPYSHORTCUT            2262
#define IDM_SAVEBACKGROUND          2263
#define IDM_SETWALLPAPER            2264
#define IDM_COPYBACKGROUND          2265
#define IDM_CREATESHORTCUT          2266
#define IDM_PAGE                    2267
#define IDM_SAVETARGET              2268
#define IDM_SHOWPICTURE             2269
#define IDM_SAVEPICTURE             2270
#define IDM_DYNSRCPLAY              2271
#define IDM_DYNSRCSTOP              2272
#define IDM_PRINTTARGET             2273
#define IDM_IMGARTPLAY              2274
#define IDM_IMGARTSTOP              2275
#define IDM_IMGARTREWIND            2276
#define IDM_PRINTQUERYJOBSPENDING   2277
#define IDM_SETDESKTOPITEM          2278

#define IDM_CONTEXTMENU             2280
#define IDM_GOBACKWARD              2282
#define IDM_GOFORWARD               2283
#define IDM_PRESTOP                 2284

#define IDM_MP_MYPICS               2287
#define IDM_MP_EMAILPICTURE         2288
#define IDM_MP_PRINTPICTURE         2289

#define IDM_CREATELINK              2290
#define IDM_COPYCONTENT             2291

#define IDM_LANGUAGE                2292
 
#define IDM_GETPRINTTEMPLATE        2295
#define IDM_SETPRINTTEMPLATE        2296
#define IDM_TEMPLATE_PAGESETUP      2298

#define IDM_REFRESH                 2300
#define IDM_STOPDOWNLOAD            2301

#define IDM_ENABLE_INTERACTION      2302

#define IDM_LAUNCHDEBUGGER          2310
#define IDM_BREAKATNEXT             2311

#define IDM_INSINPUTHIDDEN          2312
#define IDM_INSINPUTPASSWORD        2313

#define IDM_OVERWRITE               2314

#define IDM_PARSECOMPLETE           2315

#define IDM_HTMLEDITMODE            2316

#define IDM_REGISTRYREFRESH         2317
#define IDM_COMPOSESETTINGS         2318

#define IDM_SHOWALLTAGS             2327
#define IDM_SHOWALIGNEDSITETAGS     2321
#define IDM_SHOWSCRIPTTAGS          2322
#define IDM_SHOWSTYLETAGS           2323
#define IDM_SHOWCOMMENTTAGS         2324
#define IDM_SHOWAREATAGS            2325
#define IDM_SHOWUNKNOWNTAGS         2326
#define IDM_SHOWMISCTAGS            2320
#define IDM_SHOWZEROBORDERATDESIGNTIME         2328

#define IDM_AUTODETECT              2329

#define IDM_SCRIPTDEBUGGER          2330

#define IDM_GETBYTESDOWNLOADED      2331

#define IDM_NOACTIVATENORMALOLECONTROLS        2332
#define IDM_NOACTIVATEDESIGNTIMECONTROLS       2333
#define IDM_NOACTIVATEJAVAAPPLETS              2334
#define IDM_NOFIXUPURLSONPASTE                 2335

#define IDM_EMPTYGLYPHTABLE         2336
#define IDM_ADDTOGLYPHTABLE         2337
#define IDM_REMOVEFROMGLYPHTABLE    2338
#define IDM_REPLACEGLYPHCONTENTS    2339

#define IDM_SHOWWBRTAGS             2340

#define IDM_PERSISTSTREAMSYNC       2341
#define IDM_SETDIRTY                2342

#define IDM_RUNURLSCRIPT            2343

#ifdef IE5_ZOOM
#define IDM_ZOOMRATIO               2344
#define IDM_GETZOOMNUMERATOR        2345
#define IDM_GETZOOMDENOMINATOR      2346
#endif  // IE5_ZOOM

// COMMANDS FOR COMPLEX TEXT
#define IDM_DIRLTR                  2350
#define IDM_DIRRTL                  2351
#define IDM_BLOCKDIRLTR             2352
#define IDM_BLOCKDIRRTL             2353
#define IDM_INLINEDIRLTR            2354
#define IDM_INLINEDIRRTL            2355

// SHDOCVW
#define IDM_ISTRUSTEDDLG            2356

// MSHTMLED
#define IDM_INSERTSPAN              2357
#define IDM_LOCALIZEEDITOR          2358

// XML MIMEVIEWER
#define IDM_SAVEPRETRANSFORMSOURCE  2370
#define IDM_VIEWPRETRANSFORMSOURCE  2371

// Scrollbar context menu
#define IDM_SCROLL_HERE             2380
#define IDM_SCROLL_TOP              2381
#define IDM_SCROLL_BOTTOM           2382
#define IDM_SCROLL_PAGEUP           2383
#define IDM_SCROLL_PAGEDOWN         2384
#define IDM_SCROLL_UP               2385
#define IDM_SCROLL_DOWN             2386
#define IDM_SCROLL_LEFTEDGE         2387
#define IDM_SCROLL_RIGHTEDGE        2388
#define IDM_SCROLL_PAGELEFT         2389
#define IDM_SCROLL_PAGERIGHT        2390
#define IDM_SCROLL_LEFT             2391
#define IDM_SCROLL_RIGHT            2392

// IE 6 Form Editing Commands
#define IDM_MULTIPLESELECTION       2393
#define IDM_2D_POSITION             2394
#define IDM_2D_ELEMENT              2395
#define IDM_1D_ELEMENT              2396
#define IDM_ABSOLUTE_POSITION       2397
#define IDM_LIVERESIZE              2398
#define IDM_ATOMICSELECTION			2399

// Auto URL detection mode
#define IDM_AUTOURLDETECT_MODE      2400

// Legacy IE50 compatible paste
#define IDM_IE50_PASTE              2401

// ie50 paste mode
#define IDM_IE50_PASTE_MODE         2402

//;begin_internal
#define IDM_GETIPRINT               2403
//;end_internal

// for disabling selection handles
#define IDM_DISABLE_EDITFOCUS_UI    2404

// for visibility/display in design
#define IDM_RESPECTVISIBILITY_INDESIGN  2405

// set css mode
#define IDM_CSSEDITING_LEVEL            2406

// New outdent
#define IDM_UI_OUTDENT                  2407

// Printing Status
#define IDM_UPDATEPAGESTATUS            2408

// IME Reconversion 
#define IDM_IME_ENABLE_RECONVERSION		2409

#define	IDM_KEEPSELECTION				2410

#define IDM_UNLOADDOCUMENT              2411

#define IDM_OVERRIDE_CURSOR             2420

#define IDM_PEERHITTESTSAMEINEDIT       2423

#define IDM_TRUSTAPPCACHE               2425

#define IDM_BACKGROUNDIMAGECACHE        2430

#define IDM_DEFAULTBLOCK                6046

#define IDM_MIMECSET__FIRST__           3609
#define IDM_MIMECSET__LAST__            3699

#define IDM_MENUEXT_FIRST__       3700
#define IDM_MENUEXT_LAST__        3732
#define IDM_MENUEXT_COUNT         3733

// Commands mapped from the standard set.  We should
// consider deleting them from public header files.

#define IDM_OPEN                    2000
#define IDM_NEW                     2001
#define IDM_SAVE                    70
#define IDM_SAVEAS                  71
#define IDM_SAVECOPYAS              2002
#define IDM_PRINTPREVIEW            2003
#define IDM_SHOWPRINT               2010
#define IDM_SHOWPAGESETUP           2011
#define IDM_PRINT                   27
#define IDM_PAGESETUP               2004
#define IDM_SPELL                   2005
#define IDM_PASTESPECIAL            2006
#define IDM_CLEARSELECTION          2007
#define IDM_PROPERTIES              28
#define IDM_REDO                    29
#define IDM_UNDO                    43
#define IDM_SELECTALL               31
#define IDM_ZOOMPERCENT             50
#define IDM_GETZOOM                 68
#define IDM_STOP                    2138
#define IDM_COPY                    15
#define IDM_CUT                     16
#define IDM_PASTE                   26

// Defines for IDM_ZOOMPERCENT
#define CMD_ZOOM_PAGEWIDTH -1
#define CMD_ZOOM_ONEPAGE -2
#define CMD_ZOOM_TWOPAGES -3
#define CMD_ZOOM_SELECTION -4
#define CMD_ZOOM_FIT -5

// IDMs for CGID_EditStateCommands group 
#define IDM_CONTEXT                 1 
#define IDM_HWND                    2

// Shdocvw Execs on CGID_DocHostCommandHandler
#define IDM_NEW_TOPLEVELWINDOW      7050

//
// Undo persistence comands
//
#define IDM_PRESERVEUNDOALWAYS      6049
#define IDM_PERSISTDEFAULTVALUES    7100
#define IDM_PROTECTMETATAGS         7101

#define IDM_GETFRAMEZONE            6037

//;begin_internal
// <New in IE6>
#define IDM_FIRE_PRINTTEMPLATEUP        15000
#define IDM_FIRE_PRINTTEMPLATEDOWN      15001
#define IDM_SETPRINTHANDLES             15002
#define IDM_CLEARAUTHENTICATIONCACHE	15003
//;end_internal


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\mshtmdbg.h ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       mshtmdbg.h
//
//  Contents:   External include file for mshtmdbg.dll
//
// ----------------------------------------------------------------------------

#ifndef _MSHTMDBG_H_
#define _MSHTMDBG_H_

#ifdef __cplusplus
extern "C" {
#endif

#define MSHTMDBG_API_VERSION    (7)     // Increment whenever API changes

struct IUnknown;

typedef INT     TRACETAG;
typedef INT_PTR PERFTAG;
typedef INT_PTR PERFMETERTAG;

DWORD       WINAPI  DbgExGetVersion();
BOOL        WINAPI  DbgExIsFullDebug();
void        WINAPI  DbgExSetDllMain(HANDLE hDllHandle, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));

void        WINAPI  DbgExDoTracePointsDialog(BOOL fWait);
void        WINAPI  DbgExRestoreDefaultDebugState();

BOOL        WINAPI  DbgExEnableTag(TRACETAG tag, BOOL fEnable);
BOOL        WINAPI  DbgExSetDiskFlag(TRACETAG tag, BOOL fSendToDisk);
BOOL        WINAPI  DbgExSetBreakFlag(TRACETAG tag, BOOL fBreak);
BOOL        WINAPI  DbgExIsTagEnabled(TRACETAG tag);
TRACETAG    WINAPI  DbgExFindTag(char * szTagDesc);

TRACETAG    WINAPI  DbgExTagError();
TRACETAG    WINAPI  DbgExTagWarning();
TRACETAG    WINAPI  DbgExTagThread();
TRACETAG    WINAPI  DbgExTagAssertExit();
TRACETAG    WINAPI  DbgExTagAssertStacks();
TRACETAG    WINAPI  DbgExTagMemoryStrict();
TRACETAG    WINAPI  DbgExTagCoMemoryStrict();
TRACETAG    WINAPI  DbgExTagMemoryStrictTail();
TRACETAG    WINAPI  DbgExTagMemoryStrictAlign();
TRACETAG    WINAPI  DbgExTagOLEWatch();
TRACETAG    WINAPI  DbgExTagRegisterTrace(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagRegisterOther(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagPerf();

BOOL        __cdecl DbgExTaggedTrace(TRACETAG tag, CHAR * szFmt, ...);
BOOL        __cdecl DbgExTaggedTraceEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, ...);
BOOL        WINAPI  DbgExTaggedTraceListEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker);
void        WINAPI  DbgExTaggedTraceCallers(TRACETAG tag, int iStart, int cTotal);

BOOL        WINAPI  DbgExAssertImpl(char const * szFile, int iLine, char const * szMessage);
void        WINAPI  DbgExAssertThreadDisable(BOOL fDisable);
HRESULT     __cdecl DbgExCheckAndReturnResult(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, ...);
HRESULT     WINAPI  DbgExCheckAndReturnResultList(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list valMarker);

size_t      WINAPI  DbgExPreAlloc(size_t cbRequest);
void *      WINAPI  DbgExPostAlloc(void *pv);
void *      WINAPI  DbgExPreFree(void *pv);
void        WINAPI  DbgExPostFree();
size_t      WINAPI  DbgExPreRealloc(void *pvRequest, size_t cbRequest, void **ppv);
void *      WINAPI  DbgExPostRealloc(void *pv);
void *      WINAPI  DbgExPreGetSize(void *pvRequest);
size_t      WINAPI  DbgExPostGetSize(size_t cb);
void *      WINAPI  DbgExPreDidAlloc(void *pvRequest);
BOOL        WINAPI  DbgExPostDidAlloc(void *pvRequest, BOOL fActual);

void        WINAPI  DbgExMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExCoMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExMemoryBlockTrackDisable(void * pv);
void        WINAPI  DbgExMemSetHeader(void * pvRequest, size_t cb, PERFMETERTAG mt);
void *      WINAPI  DbgExGetMallocSpy();
void        WINAPI  DbgExTraceMemoryLeaks();
BOOL        WINAPI  DbgExValidateInternalHeap();

LONG_PTR    WINAPI  DbgExTraceFailL(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
LONG_PTR    WINAPI  DbgExTraceWin32L(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceOLE(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite);
void        WINAPI  DbgExTraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExTraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExSetSimFailCounts(int firstFailure, int cInterval);
void        WINAPI  DbgExShowSimFailDlg();
BOOL        WINAPI  DbgExFFail();
int         WINAPI  DbgExGetFailCount();
void        WINAPI  DbgExTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv);

void        WINAPI  DbgExOpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize);
void        WINAPI  DbgExOpenMemoryMonitor();
void        WINAPI  DbgExOpenLogFile(LPCSTR szFName);

void *      __cdecl DbgExMemSetName(void *pvRequest, char * szFmt, ...);
void *      WINAPI  DbgExMemSetNameList(void * pvRequest, char * szFmt, va_list valMarker);
char *      WINAPI  DbgExMemGetName(void *pvRequest);

HRESULT     WINAPI  DbgExWsClear(HANDLE hProcess);
HRESULT     WINAPI  DbgExWsTakeSnapshot(HANDLE hProcess);
BSTR        WINAPI  DbgExWsGetModule(long row);
BSTR        WINAPI  DbgExWsGetSection(long row);
long        WINAPI  DbgExWsSize(long row);
long        WINAPI  DbgExWsCount();
long        WINAPI  DbgExWsTotal();
HRESULT     WINAPI  DbgExWsStartDelta(HANDLE hProcess);
long        WINAPI  DbgExWsEndDelta(HANDLE hProcess);

void        WINAPI  DbgExDumpProcessHeaps();

PERFTAG     WINAPI  DbgExPerfRegister(char * szTag, char * szOwner, char * szDescrip);
void        __cdecl DbgExPerfLogFn(PERFTAG tag, void * pvObj, const char * pchFmt, ...);
void        WINAPI  DbgExPerfLogFnList(PERFTAG tag, void * pvObj, const char * pchFmt, va_list valMarker);
void        WINAPI  DbgExPerfDump();
void        WINAPI  DbgExPerfClear();
void        WINAPI  DbgExPerfTags();
void        WINAPI  DbgExPerfEnable(BOOL fEnable);

char *      WINAPI  DbgExDecodeMessage(UINT msg);

PERFMETERTAG WINAPI  DbgExMtRegister(char * szTag, char * szOwner, char * szDescrip);
void        WINAPI  DbgExMtAdd(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal);
void        WINAPI  DbgExMtSet(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal);
char *      WINAPI  DbgExMtGetName(PERFMETERTAG mt);
char *      WINAPI  DbgExMtGetDesc(PERFMETERTAG mt);
BOOL        WINAPI  DbgExMtSimulateOutOfMemory(PERFMETERTAG mt, LONG_PTR lNewValue);
void        WINAPI  DbgExMtOpenMonitor();
void        WINAPI  DbgExMtLogDump(LPSTR pchFile);
PERFMETERTAG WINAPI  DbgExMtLookupMeter(char * szTag);
long        WINAPI  DbgExMtGetMeterCnt(PERFMETERTAG mt, BOOL fExclusive);
long        WINAPI  DbgExMtGetMeterVal(PERFMETERTAG mt, BOOL fExclusive);

void        WINAPI  DbgExSetTopUrl(LPWSTR pstrUrl);
void        WINAPI  DbgExGetSymbolFromAddress(void * pvAddr, char * pszBuf, DWORD cchBuf);

BOOL        WINAPI  DbgExGetChkStkFill(DWORD * pdwFill);
int         WINAPI  DbgExGetStackTrace(int iStart, int cTotal, BYTE *pbBuffer, int cbBuffer, int cchModule, int cchSymbol);

#ifdef __cplusplus
}
#endif

// Performance Logging --------------------------------------------------------

#ifdef PERFTAGS

#define     IsPerfEnabled(tag) (*(BOOL *)tag)
#define     PerfTag(tag, szOwner, szDescrip) PERFTAG tag(DbgExPerfRegister(#tag, szOwner, szDescrip));
#define     PerfExtern(tag) extern PERFTAG tag;
#define     PerfLog(tag,pv,f) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f) : 0
#define     PerfLog1(tag,pv,f,a1) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1) : 0
#define     PerfLog2(tag,pv,f,a1,a2) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2) : 0
#define     PerfLog3(tag,pv,f,a1,a2,a3) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3) : 0
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4) : 0
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5) : 0
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6) : 0
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) : 0
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) : 0
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) : 0
#define     PerfDump()  DbgExPerfDump()
#define     PerfClear() DbgExPerfClear()
#define     PerfTags()  DbgExPerfTags()
#define     PerfEnable(fEnable) DbgExPerfEnable(fEnable)

#else

#define     IsPerfEnabled(tag) (FALSE)
#define     PerfTag(tag, szOwner, szDescrip)
#define     PerfExtern(tag)
#define     PerfLog(tag,pv,f)
#define     PerfLog1(tag,pv,f,a1)
#define     PerfLog2(tag,pv,f,a1,a2)
#define     PerfLog3(tag,pv,f,a1,a2,a3)
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4)
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define     PerfDump()
#define     PerfClear()
#define     PerfTags()
#define     PerfEnable(fEnable)

#endif

// Performance Metering -------------------------------------------------------

#ifdef PERFMETER

#define     Mt(x)                               g_mt##x
#define     MtExtern(tag)                       extern PERFMETERTAG g_mt##tag;
#define     MtDefine(tag, tagOwner, szDescrip)  PERFMETERTAG g_mt##tag(DbgExMtRegister("mt" #tag, "mt" #tagOwner, szDescrip));
#define     MtAdd(mt, lCnt, lVal)               DbgExMtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)               DbgExMtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewVal)  DbgExMtSimulateOutOfMemory(mt, lNewVal)
#define     MtOpenMonitor()                     DbgExMtOpenMonitor()

#else

#define     Mt(x)                               ((PERFMETERTAG)0)
#define     MtExtern(tag)
#define     MtDefine(tag, szOwner, szDescrip)
#define     MtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewValue)
#define     MtOpenMonitor()

#endif

// MSHTML perf control --------------------------------------------------------

#define HTMPERFCTL_NAME     "#MSHTML#PERF#"

enum
{
    HTMPF_CALLBACK_ONLOAD   = 0x00000001,   // callback when topdoc loaded (dwArg1:HTMPF_CALLBACK_ONLOAD, dwArg2: strURL)
    HTMPF_ENABLE_PROFILE    = 0x00000002,   // enable profiling
    HTMPF_ENABLE_MEMWATCH   = 0x00000004,   // enable memwatch sampling
    HTMPF_DISABLE_PADEVENTS = 0x00000008,   // disable firing of events from mshtmpad.exe
    HTMPF_DISABLE_IMGCACHE  = 0x00000010,   // disable image cache in mshtml
    HTMPF_DISABLE_OFFSCREEN = 0x00000020,   // disable offscreen buffering
    HTMPF_DISABLE_ALERTS    = 0x00000040,   // disable alert() and confirm() methods
    HTMPF_SYNC_DATABIND     = 0x00000080,   // grab all records at once for databinding
    HTMPF_CALLBACK_ONLOAD2  = 0x00000100,   // callback when topdoc loaded (dwArg1:HTMPF_CALLBACK_ONLOAD, dwArg2: CDoc IUnk)
    HTMPF_CALLBACK_ONVIEWQ  = 0x00000200,   // callback when ensure view is queued (dwArg1: HTMPF_CALLBACK_ONVIEWQ, dwArg2: CDoc IUnk)
    HTMPF_CALLBACK_ONVIEWD  = 0x00000400,   // callback when ensure view is dequeued (dwArg1: HTMPF_CALLBACK_ONVIEWD, dwArg2: CDoc IUnk)
#ifndef NO_ETW_TRACING
    HTMPF_CALLBACK_ONEVENT  = 0x00000800    // callback when event tracing for windows is enabled
                                            // (dwArg1: UCHAR EVENT-TYPE, dwArg2: WCHAR* URL)
                                            // See shlwapi.w for event types.
#endif
};

typedef void (WINAPI *HTMPFCBFN)(DWORD dwArg1, void * pvArg2);

typedef struct HTMPERFCTL
{
    DWORD       dwSize;     // set to sizeof(MSHTMLPERF)
    DWORD       dwFlags;    // see HTMPF_*
    HTMPFCBFN   pfnCall;    // Callback function
    void *      pvHost;     // Private data for host
} HTMPERFCTL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\mshtmlrc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident/MSHTML
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       mshtmlrc.h
//
//  Contents:   Resource identifiers
//
//----------------------------------------------------------------------------


#ifndef I_MSHTMLRC_H_
#define I_MSHTMLRC_H_
#pragma INCMSG("--- Beg 'mshtmlrc.h'")


#define IDC_SELBAR                      2008    // Text select cursor for text site

#define IDC_NOSCROLLVH                  2025


#define IDC_HYPERLINK                   9801
#define IDC_HYPERLINK_OFFLINE           9802
#define IDC_HIBEAM                      9803
#define IDC_RESIZEROW2				    9804 
#define IDC_RESIZECOL2				    9805

#define IDR_DRAG_CONTEXT_MENU       24645  //0x6045  // bad id - not in core range

// HTML Form
#define IDR_HTMLFORM_MENUDESIGN     907
#define IDR_HTMLFORM_MENURUN        908
#define IDR_HTMLFORM_DOCDIR         909
#define IDS_HTMLFORM_USERTYPESHORT  181
#define IDS_HTMLFORM_USERTYPEFULL   180

// Form
#define IDR_ACCELS_SITE_DESIGN          41
#define IDR_ACCELS_SITE_RUN             40
#define IDR_ACCELS_FRAMESET_DESIGN      47
#define IDR_ACCELS_FRAMESET_RUN         46
#define IDR_ACCELS_INPUTTXT_DESIGN      43
#define IDR_ACCELS_INPUTTXT_RUN         42
#define IDR_ACCELS_TCELL_DESIGN         45
#define IDR_ACCELS_TCELL_RUN            44
#define IDR_ACCELS_BODY_RUN             48
#define IDR_ACCELS_BODY_DESIGN          49
#define IDR_ACCELS_TXTSITE_RUN          50
#define IDR_ACCELS_TXTSITE_DESIGN       51


//+------------------------------------------------------------------------
//
//  Error strings
//
//-------------------------------------------------------------------------
#define IDS_USERTYPEAPP                 2212    // Microsoft Forms 2.0
#define IDS_MESSAGE_BOX_TITLE           2213    // Microsoft Forms
#define IDS_ERROR_SOLUTION              2214    // Solution:\n<0s>
#define IDS_EA_SETTING_PROPERTY         2216    // Could not set property ...
#define IDS_EA_GETTING_PROPERTY         2217    // Could not get property ...
#define IDS_EA_CALLING_METHOD           2326    // Could not call method ...
#define IDS_EE_INVALID_PROPERTY_VALUE   2218    // The value entered is not valid ..
#define IDS_ES_ENTER_VALUE_IN_RANGE     2220    // Enter a value between..
#define IDS_ES_ENTER_VALUE_GT_ZERO      2221    // Enter a value greater than
#define IDS_ES_ENTER_VALUE_GE_ZERO      2222    // Enter a value greater than
#define IDS_EE_SETNOTSUPPORTEDATRUNTIME 2321    // Set property is not support at runtime.
#define IDS_EE_METHODNOTAPPLICABLE      2324
#define IDS_ES_ENTER_PROPER_VALUE       2325    // Enter a proper value
#define IDS_EE_INVALIDPICTURETYPE       2227    // CTL_E_INVALIDPICTURETYPE mouse icon must be a mouse icon
#define IDS_EE_CANTMOVEFOCUSTOCTRL      2322    // can't move focus to control because...
#define IDS_EE_INVALIDPICTURE           2331    // CTL_E_INVALIDPICTURE
#define IDS_EE_FAIL                     2330    // E_FAIL
#define IDS_EE_UNEXPECTED               2329    // E_UNEXPECTED
#define IDS_EE_INVALIDARG               2336    // E_INVALIDARG
#define IDS_EE_INVALIDPROPERTYARRAYINDEX 2332   // CTL_E_INVALIDPROPERTYARRAYINDEX
#define IDS_EE_INVALIDPROPERTYVALUE     2333    // CTL_E_INVALIDPROPERTYVALUE
#define IDS_EE_OVERFLOW                 2334    // CTL_E_OVERFLOW
#define IDS_EE_PERMISSIONDENIED         2335    // CTL_E_PERMISSIONDENIED
#define IDS_MSG_SAVE_MODIFIED_OBJECT    2223    // Save modified object?

#define IDS_CTRLPROPERTIES              2229
#define IDS_NAMEDCTRLPROPERTIES         2230
#define IDS_EA_PASTE_CONTROL            2235
#define IDS_EA_INSERT_CONTROL           2236

#define IDS_UNKNOWN_ERROR               2215    // Unknown error <0x>
#define IDS_EE_CONTROLNEEDSFOCUS        2327    // The control needs to have the focus
#define IDS_EE_NOTLICENSED              2337    // CLASS_E_NOTLICENSED
#define IDS_EE_INVALIDPASTETARGET       2338    // CTL_E_INVALIDPASTETARGET
#define IDS_EE_INVALIDPASTESOURCE       2339    // CTL_E_INVALIDPASTESOURCE

#define IDS_UNKNOWN                     2340

#define IDS_EE_INTERNET_INVALID_URL         2341
#define IDS_EE_INTERNET_NAME_NOT_RESOLVED   2342
#define IDS_EE_MISMATCHEDTAG                2345    // CTL_E_MISMATCHEDTAG
#define IDS_EE_INCOMPATIBLEPOINTERS         2346    // CTL_E_INCOMPATIBLEPOINTERS
#define IDS_EE_UNPOSITIONEDPOINTER          2347    // CTL_E_UNPOSITIONEDPOINTER
#define IDS_EE_UNPOSITIONEDELEMENT          2348    // CTL_E_UNPOSITIONEDELEMENT

#define IDS_EDITVERB                    2210
#define IDS_PROPVERB                    2211

//----------------------------------------------------------------------------
//
// Generic property page (52xx)
//
//----------------------------------------------------------------------------

#define IDS_PPG_GENERIC             5211
#define IDS_PPG_INLINE_STYLE        5212
#define IDC_PROPNAME                5204
#define IDE_PROPVALUE               5208

//----------------------------------------------------------------------------
//
// Misc strings
//
//----------------------------------------------------------------------------

//  The following IDS's must be kept in order, such that the
//    string for a given unit has the id IDS_UNITS_BASE + units
//    Otherwise, the StringToHimetric and HimetricToString functions
//    in himetric.cxx will break.  (chrisz)

#define IDS_UNITS_BASE                  2240
#define IDS_UNITS_INCH                  (IDS_UNITS_BASE+0)
#define IDS_UNITS_CM                    (IDS_UNITS_BASE+1)
#define IDS_UNITS_POINT                 (IDS_UNITS_BASE+2)


//----------------------------------------------------------------------------
//
// Undo strings
//
//----------------------------------------------------------------------------

#define IDS_UNDO                        (IDS_UNITS_POINT + 1)
#define IDS_REDO                        (IDS_UNDO + 1)
#define IDS_CANTUNDO                    (IDS_UNDO + 2)
#define IDS_CANTREDO                    (IDS_UNDO + 3)
#define IDS_UNDONEWCTRL                 (IDS_UNDO + 4)
#define IDS_UNDODELETE                  (IDS_UNDO + 5)
#define IDS_UNDOPROPCHANGE              (IDS_UNDO + 6)
#define IDS_UNDOMOVE                    (IDS_UNDO + 7)
#define IDS_UNDODRAGDROP                (IDS_UNDO + 9)
#define IDS_UNDOPASTE                   (IDS_UNDO + 15)
#define IDS_UNDOTYPING                  (IDS_UNDO + 16)
#define IDS_UNDOGENERICTEXT             (IDS_UNDO + 19)

#define IDS_E_CMDNOTSUPPORTED           2206


#define IDS_SITE_BASE      7999
#define IDS_HTMLDEFAULTFONT          (IDS_SITE_BASE + 19)
#define IDS_RUNAWAYSCRIPT            (IDS_SITE_BASE + 29)
#define IDS_PROTECTEDFROMUNSAFEOCX   (IDS_SITE_BASE + 31)
#define IDS_PROTECTEDFROMOCXINIT     (IDS_SITE_BASE + 32)
#define IDS_REPOSTFORMDATA           (IDS_SITE_BASE + 33)
#define IDS_OCXDISABLED              (IDS_SITE_BASE + 34)
#define IDS_MISMATCHEDXML            (IDS_SITE_BASE + 35)
#define IDS_DEBUGCONTINUE            (IDS_SITE_BASE + 36)
#define IDS_FMTDEBUGCONTINUE         (IDS_SITE_BASE + 37)

#define IDS_ERR_SAVEPICTUREAS        (IDS_SITE_BASE + 26)
#define IDS_ERR_SETWALLPAPER         (IDS_SITE_BASE + 27)
#define IDS_ERR_SETDESKTOPITEM       (IDS_SITE_BASE + 38)


//+----------------------------------------------------------------------------
//
// string used by script window
//
//----------------------------------------------------------------------------

#define IDS_OMWINDOW_FIRST             8300
#define IDS_VAR2STR_VTERROR             (IDS_OMWINDOW_FIRST + 0)
#define IDS_VAR2STR_VTNULL              (IDS_OMWINDOW_FIRST + 1)
#define IDS_VAR2STR_VTBOOL_TRUE         (IDS_OMWINDOW_FIRST + 2)
#define IDS_VAR2STR_VTBOOL_FALSE        (IDS_OMWINDOW_FIRST + 3)

//+----------------------------------------------------------------------------
//
// string used in conversion GetIDsOfNames
//
//----------------------------------------------------------------------------

#define IDS_DISPID_FIRST                8200                       // matches:
#define IDS_DISPID_FONTNAME             (IDS_DISPID_FIRST +  1)    // DISPID_CommonCtrl_FONTNAME
#define IDS_DISPID_FONTSIZE             (IDS_DISPID_FIRST +  2)    // DISPID_CommonCtrl_FONTSIZE
#define IDS_DISPID_FONTBOLD             (IDS_DISPID_FIRST +  3)    // DISPID_CommonCtrl_FONTBOLD
#define IDS_DISPID_FONTITAL             (IDS_DISPID_FIRST +  4)    // DISPID_CommonCtrl_FONTITAL
#define IDS_DISPID_FONTUNDER            (IDS_DISPID_FIRST +  5)    // DISPID_CommonCtrl_FONTUNDER
#define IDS_DISPID_BACKCOLOR            (IDS_DISPID_FIRST +  7)    // DISPID_BACKCOLOR
#define IDS_DISPID_BORDERCOLOR          (IDS_DISPID_FIRST +  9)    // DISPID_BORDERCOLOR
#define IDS_DISPID_BORDERSTYLE          (IDS_DISPID_FIRST + 10)    // DISPID_BORDERSTYLE
#define IDS_DISPID_TEXTALIGN            (IDS_DISPID_FIRST + 11)    // DISPID_CommonCtrl_TextAlign
#define IDS_DISPID_SPECIALEFFECT        (IDS_DISPID_FIRST + 12)    // DISPID_CommonCtrl_SpecialEffect
#define IDS_DISPID_FONTSUPERSCRIPT      (IDS_DISPID_FIRST + 13)    // DISPID_CommonCtrl_FONTSUPERSCRIPT
#define IDS_DISPID_FONTSUBSCRIPT        (IDS_DISPID_FIRST + 14)    // DISPID_CommonCtrl_FONTSUBSCRIPT

//+----------------------------------------------------------------------------
//
//  Button caption constants
//
//----------------------------------------------------------------------------

#define IDS_BUTTONCAPTION_RESET         8500
#define IDS_BUTTONCAPTION_SUBMIT        8501
#define IDS_BUTTONCAPTION_UPLOAD        8502

//+----------------------------------------------------------------------------
//
//  Printing constants
//
//----------------------------------------------------------------------------

#define IDS_PRINT_URLTITLE              8400
#define IDS_PRINT_URLCOL1HEAD           8401
#define IDS_PRINT_URLCOL2HEAD           8402
#define IDS_DEFAULTHEADER               8403
#define IDS_DEFAULTFOOTER               8404
#define IDS_DEFAULTMARGINTOP            8405
#define IDS_DEFAULTMARGINBOTTOM         8406
#define IDS_DEFAULTMARGINLEFT           8407
#define IDS_DEFAULTMARGINRIGHT          8408

//+----------------------------------------------------------------------------
//
// Progress status text strings
//
//-----------------------------------------------------------------------------

#define IDS_BINDSTATUS_DOWNLOADING                  8154
#define IDS_BINDSTATUS_DOWNLOADINGDATA_PICTURE      8155
#define IDS_BINDSTATUS_GENERATINGDATA_TEXT          8156
#define IDS_BINDSTATUS_DOWNLOADINGDATA_TEXT         8157
#define IDS_BINDSTATUS_INSTALLINGCOMPONENTS         8160
#define IDS_BINDSTATUS_DOWNLOADINGDATA_BITS         8167

#define IDS_DONE                                    8169

#define IDS_LOADINGTABLE                            8170
#define IDS_DATABINDING                             8171

#define IDS_FRIENDLYURL_SHORTCUTTO                  8172
#define IDS_FRIENDLYURL_AT                          8173
#define IDS_FRIENDLYURL_SENDSMAILTO                 8174
#define IDS_FRIENDLYURL_LOCAL                       8175
#define IDS_FRIENDLYURL_GOPHER                      8176
#define IDS_FRIENDLYURL_FTP                         8177
#define IDS_FRIENDLYURL_SECUREWEBSITE               8178

#define IDS_CANNOTLOAD                              8193
#define IDS_ONBEFOREUNLOAD_PREAMBLE                 8194
#define IDS_ONBEFOREUNLOAD_POSTAMBLE                8197

#define IDS_DEFAULT_ISINDEX_PROMPT                  8196


#define IDS_UNKNOWNPROTOCOL             2511    
#define IDS_SECURECONNECTIONINFO        2512
#define IDS_SECURE_LOW                  2513
#define IDS_SECURE_MEDIUM               2514
#define IDS_SECURE_HIGH                 2515
#define IDS_SECURESOURCE                2516

// Jave Script prompt() dialog
#define IDD_PROMPT_MSHTML                   8131
#define IDC_PROMPT_PROMPT                   8132
#define IDC_PROMPT_EDIT                     8133

// Plugin/ActiveX Viewer Not Installed dialog
#define IDD_PLUGIN_UPGRADE                  8134
#define IDC_PLUGIN_UPGRADE_CHECK            8135
#define IDC_PLUGIN_UPGRADE_EXTENSION        8136
#define IDC_PLUGIN_UPGRADE_MIME_TYPE        8137

#define IDS_PROPERTYOPENPICTURE     5010
#define IDS_PROPERTYOPENMOUSEICON   5011

#define IDS_HTMLFORM_SAVE                   8114

#define IDS_SAVEPICTUREAS_GIF               8116
#define IDS_SAVEPICTUREAS_JPG               8117
#define IDS_SAVEPICTUREAS_BMP               8118
#define IDS_SAVEPICTUREAS_XBM               8119
#define IDS_SAVEPICTUREAS_ART               8120
#define IDS_SAVEPICTUREAS_WMF               8121
#define IDS_SAVEPICTUREAS_EMF               8122
#define IDS_SAVEPICTUREAS_AVI               8123
#define IDS_SAVEPICTUREAS_MPG               8124
#define IDS_SAVEPICTUREAS_MOV               8125
#define IDS_SAVEPICTUREAS_ORIGINAL          8126
#define IDS_UNTITLED_BITMAP                 8127
#define IDS_UNTITLED_MSHTML                 8128
#define IDS_WALLPAPER_BMP                   8129
#define IDS_SAVEPICTUREAS_PNG               8138
#define IDS_UPLOADFILE              5444

#ifdef UNIX
#  define IDS_PRINT_ERROR             5445
#  define IDS_PRINT_ERROR_MSG         5446
#endif


#define IDS_DLAY_ERROR_BASE      8999
#define IDS_MSG_DB_CANTSAVE         (IDS_DLAY_ERROR_BASE + 1)
#define IDS_EE_DB_COERCE            (IDS_DLAY_ERROR_BASE + 2)
#define IDS_EE_DB_DELROW            (IDS_DLAY_ERROR_BASE + 3)
#define IDS_EE_DB_READ              (IDS_DLAY_ERROR_BASE + 4)
#define IDS_EE_DB_SCHEMA            (IDS_DLAY_ERROR_BASE + 5)
#define IDS_EE_DB_CANCELED          (IDS_DLAY_ERROR_BASE + 6)
#define IDS_EE_DB_OTHER_STATUS      (IDS_DLAY_ERROR_BASE + 7)

#define IDS_MENUHELP(idm) (10000 + (idm))
#define IDS_TOOLTIP(idm)  (20000 + (idm))

//+----------------------------------------------------------------------------
//
// HTML Block Format String
//
//-----------------------------------------------------------------------------

#define IDS_BLOCKFMT_NORMAL    1000
#define IDS_BLOCKFMT_PRE       1001
#define IDS_BLOCKFMT_ADDRESS   1002
#define IDS_BLOCKFMT_H1        1003
#define IDS_BLOCKFMT_H2        1004
#define IDS_BLOCKFMT_H3        1005
#define IDS_BLOCKFMT_H4        1006
#define IDS_BLOCKFMT_H5        1007
#define IDS_BLOCKFMT_H6        1008
#define IDS_BLOCKFMT_OL        1009
#define IDS_BLOCKFMT_UL        1010
#define IDS_BLOCKFMT_DIR       1011
#define IDS_BLOCKFMT_MENU      1012
#define IDS_BLOCKFMT_DT        1013
#define IDS_BLOCKFMT_DD        1014
#define IDS_BLOCKFMT_P         1016

#define IDS_HELPABOUT_STRING   1017

//+----------------------------------------------------------------------------
//
// default title caption for untitled HTML documents
//
//-----------------------------------------------------------------------------

#define IDS_NULL_TITLE         1020

// default document security property
#define IDS_DEFAULT_DOC_SECURITY_PROP       8130

//+----------------------------------------------------------------------------
//
//   MailTo constants
//
//----------------------------------------------------------------------------
#define IDS_MAILTO_DEFAULTSUBJECT       8600
#define IDS_MAILTO_MAILCLIENTNOTFOUND   8601
#define IDS_MAILTO_SUBMITALERT          8602

// New Encoding Menu
#define RES_STRING_ENCODING_MORE            4700

#if DBG == 1

#define IDS_COLOR_BLACK             5430
#define IDS_COLOR_NAVY              5431
#define IDS_COLOR_BLUE              5432
#define IDS_COLOR_CYAN              5433
#define IDS_COLOR_RED               5434
#define IDS_COLOR_LIME              5435
#define IDS_COLOR_GRAY              5436
#define IDS_COLOR_GREEN             5437
#define IDS_COLOR_YELLOW            5438
#define IDS_COLOR_PINK              5439
#define IDS_COLOR_VIOLET            5440
#define IDS_COLOR_WHITE             5441
// 5442 and 5443 replaced by html dialogs

#endif // DBG == 1

//----------------------------------------------------------------------------
//
// HTML dialog (53xx)
//
//----------------------------------------------------------------------------

#define IDS_WEBPAGEDIALOG           5301
#define IDS_CODEPAGE                5302

//----------------------------------------------------------------------------
//
// Icons
//
//----------------------------------------------------------------------------

#define RES_ICO_FRAME                   2660
#define RES_ICO_HTML                    2661
#define IDI_APPEARANCE                  2662
#define IDI_ADVANCED                    2663
#define IDI_GOTOURL                     2664
#define IDI_HOMEPAGE_MSHTML             2665
#define IDI_FINDTEXT                    2666
#define IDI_UNKNOWN_FILETYPE            2667
#define RES_ICO_GIF                     2668
#define RES_ICO_JPEG                    2669
#define RES_ICON_FOLDER_OPEN            2670
#define RES_ICON_FOLDER_CLOSED          2671
#define RES_ICON_URL_FILE               2672
#define RES_ICO_NOICON                  2673
#define RES_ICO_FINDING                 2674
#define RES_ICO_CONNECTING              2675
#define RES_ICO_ACCESSING               2676
#define RES_ICO_RECEIVING               2677
#define IDI_INTERNET                    2678
#define IDI_SECURITY                    2679
#define IDI_NEWS                        2680
#define IDI_VRML                        2681

#define IDB_DITHER                      2502
#define IDR_HATCHBMP                    2503    // Bitmap for border hatching
#define IDB_NOTLOADED                   2030
#define IDB_MISSING                     2031

//----------------------------------------------------------------------------
//
// Tab order dialog (3250 - 3260)
//
//----------------------------------------------------------------------------
#define IDR_TABORDERLBL             3250
#define IDR_TABORDERLSTBOX          3251
#define IDR_BTNMOVEUP               3252
#define IDR_BTNMOVEDOWN             3253
//#define IDR_BTNAUTOORDER            3254
#define IDR_TABORDERDLG             3255
//#define IDR_TABORDERMOVELBL         3256

// Menu index
#define MENU_INDEX_EDIT             1
#define MENU_INDEX_VIEW             2
#define MENU_INDEX_INSERT           3
#define MENU_INDEX_FORMAT           4


//

// unfortunately, these macros can't be used in defining
//  the symbols below: the resource compiler doesn't like them.
#define IDS_USERTYPEFULL(base)  ((base)/5)
#define IDS_USERTYPESHORT(base) ((base)/5 + 1)

#define IDR_FORM_CONTEXT_MENU       24640  //0x6040  // bad id - not in core range

#define CX_CONTEXTMENUOFFSET    2
#define CY_CONTEXTMENUOFFSET    2

#define RT_FILE                         2110



// siterc.h

// Add controls to the save as dialog.
#define IDC_SAVE_CHARSET_MSHTML    8194
#define IDR_BASE_HTMLFORM           900

#ifndef NO_HTML_DIALOG
// find resources are now located in shdocvw (peterlee)
//#define IDR_FINDDIALOG              _T("find.dlg")
//#define IDR_BIDIFINDDIALOG          _T("bidifind.dlg")
#define IDR_REPLACEDIALOG           _T("replace.dlg")
#define IDR_FORPARDIALOG            _T("forpar.dlg")
#define IDR_FORCHARDIALOG           _T("forchar.dlg")
#define IDR_GOBOOKDIALOG            _T("gobook.dlg")
#define IDR_INSIMAGEDIALOG          _T("insimage.dlg")
#define IDR_EDLINKDIALOG            _T("edlink.dlg")
#define IDR_EDBOOKDIALOG            _T("edbook.dlg")
#endif // NO_HTML_DIALOG


// otherrc.h
#define IDD_GENERICPAGE             5202
#define IDB_APPLY                   5209
#define IDB_OPENDLG                 5210

// window.close dialog string ID.
//
// BUGBUG (scotrobe): This same ID exists in
// resource.h in shdocvw. Don't change one 
// without the other.
//
#define IDS_CONFIRM_SCRIPT_CLOSE_TEXT 0x3035

#pragma INCMSG("--- End 'mshtmlrc.h'")
#else
#pragma INCMSG("*** Dup 'mshtmlrc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\msiehost.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//  File:       msiehost.idl
//
//  Contents:   Definitions for Web Browser OC host (not automatable)
//
//----------------------------------------------------------------------------
//=--------------------------------------------------------------------------=
// msiehost.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

//---------------------------------------------------------------------------=
// Definitions for IOleCommandTarget IDs


#ifndef _MSIEHOST_H
#define _MSIEHOST_H

EXTERN_C const GUID CGID_InternetExplorer;

// CGID_InternetExplorer CMDID definitions
#define IECMDID_CLEAR_AUTOCOMPLETE_FOR_FORMS        0
#define IECMDID_SETID_AUTOCOMPLETE_FOR_FORMS        1

#define IECMDID_BEFORENAVIGATE_GETSHELLBROWSE     2
#define IECMDID_BEFORENAVIGATE_DOEXTERNALBROWSE   3
#define IECMDID_BEFORENAVIGATE_GETIDLIST          4

// Values for first parameter of IEID_CLEAR_AUTOCOMPLETE_FOR_FORMS
#define IECMDID_ARG_CLEAR_FORMS_ALL                 0
#define IECMDID_ARG_CLEAR_FORMS_ALL_BUT_PASSWORDS   1
#define IECMDID_ARG_CLEAR_FORMS_PASSWORDS_ONLY      2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\mshtmdid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __COREDISP_H__
#define __COREDISP_H__
//;end_internal

//;begin_internal
//
// The following dispid must be the smallest possible dispid so that it
// always ends up first in our attr array.
// It does not need to be exposed to the outside world
#define DISPID_AAHEADER                 MINLONG             // DISPID is 0x80000000
#define DISPID_RECALC_INFO              MINLONG+1
//;end_internal


#define DISPID_XOBJ_MIN                 0x80010000
#define DISPID_XOBJ_MAX                 0x8001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN
#define DISPID_HTMLOBJECT               (DISPID_XOBJ_BASE   + 500)
#define DISPID_ELEMENT                  (DISPID_HTMLOBJECT  + 500)
#define DISPID_SITE                     (DISPID_ELEMENT     + 1000)
#define DISPID_OBJECT                   (DISPID_SITE        + 1000)
#define DISPID_STYLE                    (DISPID_OBJECT      + 1000)
#define DISPID_ATTRS                    (DISPID_STYLE       + 1000)
#define DISPID_EVENTS                   (DISPID_ATTRS       + 1000)
#define DISPID_XOBJ_EXPANDO             (DISPID_EVENTS      + 1000)
#define DISPID_XOBJ_ORDINAL             (DISPID_XOBJ_EXPANDO+ 1000)

//;begin_internal
// Expandos for ActiveX controls, note these are very limited compared to
// normal expandos on an element.

#define DISPID_ACTIVEX_EXPANDO_BASE      DISPID_XOBJ_EXPANDO
#define DISPID_ACTIVEX_EXPANDO_MAX       (DISPID_ACTIVEX_EXPANDO_BASE + 999)

#define DISPID_OBJECT_ORDINAL_BASE       DISPID_XOBJ_ORDINAL
#define DISPID_OBJECT_ORDINAL_MAX       (DISPID_OBJECT_ORDINAL_BASE + 999)

#define DISPID_COLLECTION_MIN           1000000
#define DISPID_COLLECTION_MAX           2999999

// Divide collection dispid space into "named member" half and "ordinal access" half
// for stylesheets collection.
#define DISPID_STYLESHEETSCOLLECTION_NAMED_BASE        (DISPID_COLLECTION_MIN)
#define DISPID_STYLESHEETSCOLLECTION_NAMED_MAX         (DISPID_COLLECTION_MIN+((DISPID_COLLECTION_MAX-DISPID_COLLECTION_MIN)/2))
#define DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE      (DISPID_STYLESHEETSCOLLECTION_NAMED_MAX+1)
#define DISPID_STYLESHEETSCOLLECTION_ORDINAL_MAX       (DISPID_COLLECTION_MAX)

// DISPID range for expandos not associated with an ActiveX control
#define DISPID_EXPANDO_BASE             3000000
#define DISPID_EXPANDO_MAX              3999999

#define IsStandardDispid(dispid)        (dispid <= 0)
#define IsExpandoDispid(dispid)         (DISPID_EXPANDO_BASE <= dispid && dispid <= DISPID_EXPANDO_MAX)

#define DISPID_EVENTHOOK_SENSITIVE_BASE   4000000
#define DISPID_EVENTHOOK_SENSITIVE_MAX    4499999
#define DISPID_EVENTHOOK_INSENSITIVE_BASE 4500000
#define DISPID_EVENTHOOK_INSENSITIVE_MAX  4999999

#define DISPID_PEER_HOLDER_BASE         5000000

#define IsPeerDispid(dispid)            (DISPID_PEER_HOLDER_BASE <= dispid)

//;end_internal

//;begin_internal
//
// IE 4 dispids that no longer exist
//
//;end_internal
#define DISPID_HTMLOPTIONBUTTONELEMENTEVENTS_ONCHANGE       DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONCHANGE

//;begin_internal
//
// Standard control properties
//
//;end_internal

//;begin_internal
//;QUESTION: rgardner - why do we use these names ???
//;end_internal
#define DISPID_CommonCtrl_FONTNAME        1
#define DISPID_CommonCtrl_FONTSIZE        2
#define DISPID_CommonCtrl_FONTBOLD        3
#define DISPID_CommonCtrl_FONTITAL        4
#define DISPID_CommonCtrl_FONTUNDER       5
#define DISPID_CommonCtrl_FONTSTRIKE      6
#define DISPID_CommonCtrl_FONTWEIGHT      7
#define DISPID_CommonCtrl_FONTCHARSET     8
#define DISPID_CommonCtrl_FONTSUPERSCRIPT 9
#define DISPID_CommonCtrl_FONTSUBSCRIPT   10

// Data Binding DISPID's
#define DISPID_MSDATASRCINTERFACE       (-3900)
#define DISPID_ADVISEDATASRCCHANGEEVENT (-3901)


//;begin_internal
// DISPID values for HTML Dialogs files per interface
//;end_internal

#define DISPID_HTMLDLG                          25000
#define DISPID_HTMLDLGMODEL                     26000

//;begin_internal
// DISPID values for HTML Popup files per interface
//;end_internal

#define DISPID_HTMLPOPUP                        27000

//;begin_internal
// DISPID values for HTML Application files per interface
//;end_internal

#define DISPID_HTMLAPP                          5000

//;begin_internal
//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These values match those used by VB and are for the benefit of controls
//  with hard coded knowledge of VB.
//
//----------------------------------------------------------------------------
//;end_internal

#define STDPROPID_XOBJ_NAME                 (DISPID_XOBJ_BASE + 0x0)
#define STDPROPID_XOBJ_INDEX                (DISPID_XOBJ_BASE + 0x1)
//;begin_internal
// for IE3 compatibility

#define STDPROPID_IE3XOBJ_OBJECTALIGN     (DISPID_XOBJ_BASE + 0x1) 

// STDPROPID_XOBJ_BASEHREF is a constant used by IE3
//;end_internal
#define STDPROPID_XOBJ_BASEHREF             (DISPID_XOBJ_BASE + 0x2) 
#define STDPROPID_XOBJ_LEFT                 (DISPID_XOBJ_BASE + 0x3)
#define STDPROPID_XOBJ_TOP                  (DISPID_XOBJ_BASE + 0x4)
#define STDPROPID_XOBJ_WIDTH                (DISPID_XOBJ_BASE + 0x5)
#define STDPROPID_XOBJ_HEIGHT               (DISPID_XOBJ_BASE + 0x6)
#define STDPROPID_XOBJ_VISIBLE              (DISPID_XOBJ_BASE + 0x7)
#define STDPROPID_XOBJ_PARENT               (DISPID_XOBJ_BASE + 0x8)
#define STDPROPID_XOBJ_DRAGMODE             (DISPID_XOBJ_BASE + 0x9)
#define STDPROPID_XOBJ_DRAGICON             (DISPID_XOBJ_BASE + 0xA)
#define STDPROPID_XOBJ_TAG                  (DISPID_XOBJ_BASE + 0xB)
#define STDPROPID_XOBJ_TABSTOP              (DISPID_XOBJ_BASE + 0xE)
#define STDPROPID_XOBJ_TABINDEX             (DISPID_XOBJ_BASE + 0xF)
#define STDPROPID_XOBJ_HELPCONTEXTID        (DISPID_XOBJ_BASE + 0x32)
#define STDPROPID_XOBJ_DEFAULT              (DISPID_XOBJ_BASE + 0x37)
#define STDPROPID_XOBJ_CANCEL               (DISPID_XOBJ_BASE + 0x38)
#define STDPROPID_XOBJ_LEFTNORUN            (DISPID_XOBJ_BASE + 0x39)
#define STDPROPID_XOBJ_TOPNORUN             (DISPID_XOBJ_BASE + 0x3A)
#define STDPROPID_XOBJ_ALIGNPERSIST         (DISPID_XOBJ_BASE + 0x3C)
#define STDPROPID_XOBJ_LINKTIMEOUT          (DISPID_XOBJ_BASE + 0x3D)
#define STDPROPID_XOBJ_LINKTOPIC            (DISPID_XOBJ_BASE + 0x3E)
#define STDPROPID_XOBJ_LINKITEM             (DISPID_XOBJ_BASE + 0x3F)
#define STDPROPID_XOBJ_LINKMODE             (DISPID_XOBJ_BASE + 0x40)
#define STDPROPID_XOBJ_DATACHANGED          (DISPID_XOBJ_BASE + 0x41)
#define STDPROPID_XOBJ_DATAFIELD            (DISPID_XOBJ_BASE + 0x42)
#define STDPROPID_XOBJ_DATASOURCE           (DISPID_XOBJ_BASE + 0x43)
#define STDPROPID_XOBJ_WHATSTHISHELPID      (DISPID_XOBJ_BASE + 0x44)
#define STDPROPID_XOBJ_CONTROLTIPTEXT       (DISPID_XOBJ_BASE + 0x45)
#define STDPROPID_XOBJ_STATUSBARTEXT        (DISPID_XOBJ_BASE + 0x46)
#define STDPROPID_XOBJ_APPLICATION          (DISPID_XOBJ_BASE + 0x47)
#define STDPROPID_XOBJ_BLOCKALIGN           (DISPID_XOBJ_BASE + 0x48)
#define STDPROPID_XOBJ_CONTROLALIGN         (DISPID_XOBJ_BASE + 0x49)
#define STDPROPID_XOBJ_STYLE                (DISPID_XOBJ_BASE + 0x4A)
#define STDPROPID_XOBJ_COUNT                (DISPID_XOBJ_BASE + 0x4B)
#define STDPROPID_XOBJ_DISABLED             (DISPID_XOBJ_BASE + 0x4C)
#define STDPROPID_XOBJ_RIGHT                (DISPID_XOBJ_BASE + 0x4D)
#define STDPROPID_XOBJ_BOTTOM               (DISPID_XOBJ_BASE + 0x4E)

//;begin_internal
//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These are events that are fired for all sites
//----------------------------------------------------------------------------
//;end_internal

#define STDDISPID_XOBJ_ONBLUR                           (DISPID_XOBJ_BASE)
#define STDDISPID_XOBJ_ONFOCUS                          (DISPID_XOBJ_BASE + 1)
#define STDDISPID_XOBJ_BEFOREUPDATE                     (DISPID_XOBJ_BASE + 4)
#define STDDISPID_XOBJ_AFTERUPDATE                      (DISPID_XOBJ_BASE + 5)
#define STDDISPID_XOBJ_ONROWEXIT                        (DISPID_XOBJ_BASE + 6)
#define STDDISPID_XOBJ_ONROWENTER                       (DISPID_XOBJ_BASE + 7)
#define STDDISPID_XOBJ_ONMOUSEOVER                      (DISPID_XOBJ_BASE + 8)
#define STDDISPID_XOBJ_ONMOUSEOUT                       (DISPID_XOBJ_BASE + 9)
#define STDDISPID_XOBJ_ONHELP                           (DISPID_XOBJ_BASE + 10)
#define STDDISPID_XOBJ_ONDRAGSTART                      (DISPID_XOBJ_BASE + 11)
#define STDDISPID_XOBJ_ONSELECTSTART                    (DISPID_XOBJ_BASE + 12)
#define STDDISPID_XOBJ_ERRORUPDATE                      (DISPID_XOBJ_BASE + 13)
#define STDDISPID_XOBJ_ONDATASETCHANGED                 (DISPID_XOBJ_BASE + 14)
#define STDDISPID_XOBJ_ONDATAAVAILABLE                  (DISPID_XOBJ_BASE + 15)
#define STDDISPID_XOBJ_ONDATASETCOMPLETE                (DISPID_XOBJ_BASE + 16)
#define STDDISPID_XOBJ_ONFILTER                         (DISPID_XOBJ_BASE + 17)
#define STDDISPID_XOBJ_ONLOSECAPTURE                    (DISPID_XOBJ_BASE + 18)
#define STDDISPID_XOBJ_ONPROPERTYCHANGE                 (DISPID_XOBJ_BASE + 19)
#define STDDISPID_XOBJ_ONDRAG                           (DISPID_XOBJ_BASE + 20)
#define STDDISPID_XOBJ_ONDRAGEND                        (DISPID_XOBJ_BASE + 21)
#define STDDISPID_XOBJ_ONDRAGENTER                      (DISPID_XOBJ_BASE + 22)
#define STDDISPID_XOBJ_ONDRAGOVER                       (DISPID_XOBJ_BASE + 23)
#define STDDISPID_XOBJ_ONDRAGLEAVE                      (DISPID_XOBJ_BASE + 24)
#define STDDISPID_XOBJ_ONDROP                           (DISPID_XOBJ_BASE + 25)
#define STDDISPID_XOBJ_ONCUT                            (DISPID_XOBJ_BASE + 26)
#define STDDISPID_XOBJ_ONCOPY                           (DISPID_XOBJ_BASE + 27)
#define STDDISPID_XOBJ_ONPASTE                          (DISPID_XOBJ_BASE + 28)
#define STDDISPID_XOBJ_ONBEFORECUT                      (DISPID_XOBJ_BASE + 29)
#define STDDISPID_XOBJ_ONBEFORECOPY                     (DISPID_XOBJ_BASE + 30)
#define STDDISPID_XOBJ_ONBEFOREPASTE                    (DISPID_XOBJ_BASE + 31)
#define STDDISPID_XOBJ_ONROWSDELETE                     (DISPID_XOBJ_BASE + 32)
#define STDDISPID_XOBJ_ONROWSINSERTED                   (DISPID_XOBJ_BASE + 33)
#define STDDISPID_XOBJ_ONCELLCHANGE                     (DISPID_XOBJ_BASE + 34)

//;begin_internal
//----------------------------------------------------------------------------
//
//  Base DISPIDs for each class.
//
//  Object and its base classes must use ids in the reserved x-object range.
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_NORMAL_FIRST                     1000
#define DISPID_ANCHOR                           DISPID_NORMAL_FIRST
#define DISPID_BLOCK                            DISPID_NORMAL_FIRST
#define DISPID_BODY                             (DISPID_TEXTSITE + 1000)
#define DISPID_BR                               DISPID_NORMAL_FIRST
#define DISPID_BGSOUND                          DISPID_NORMAL_FIRST
#define DISPID_DD                               DISPID_NORMAL_FIRST
#define DISPID_DIR                              DISPID_NORMAL_FIRST
#define DISPID_DIV                              DISPID_NORMAL_FIRST
#define DISPID_DL                               DISPID_NORMAL_FIRST
#define DISPID_DT                               DISPID_NORMAL_FIRST
#define DISPID_EFONT                            DISPID_NORMAL_FIRST
#define DISPID_FORM                             DISPID_NORMAL_FIRST
#define DISPID_HEADER                           DISPID_NORMAL_FIRST
#define DISPID_HEDELEMS                         DISPID_NORMAL_FIRST
#define DISPID_HR                               DISPID_NORMAL_FIRST
#define DISPID_LABEL                            DISPID_NORMAL_FIRST
#define DISPID_LI                               DISPID_NORMAL_FIRST
#define DISPID_IMGBASE                          DISPID_NORMAL_FIRST
#define DISPID_IMG                              (DISPID_IMGBASE + 1000)
#define DISPID_INPUTIMAGE                       (DISPID_IMGBASE + 1000)
#define DISPID_INPUT                            (DISPID_TEXTSITE + 1000)
#define DISPID_INPUTTEXTBASE                    (DISPID_INPUT+1000)
#define DISPID_INPUTTEXT                        (DISPID_INPUTTEXTBASE+1000)
#define DISPID_MENU                             DISPID_NORMAL_FIRST
#define DISPID_OL                               DISPID_NORMAL_FIRST
#define DISPID_PARA                             DISPID_NORMAL_FIRST
#define DISPID_SELECT                           DISPID_NORMAL_FIRST
#define DISPID_SELECTOBJ                        DISPID_NORMAL_FIRST
#define DISPID_TABLE                            DISPID_NORMAL_FIRST
#define DISPID_TEXTSITE                         DISPID_NORMAL_FIRST
#define DISPID_TEXTAREA                         (DISPID_INPUTTEXT + 1000)
#define DISPID_MARQUEE                          (DISPID_TEXTAREA + 1000)
#define DISPID_RICHTEXT                         (DISPID_MARQUEE + 1000)
#define DISPID_BUTTON                           (DISPID_RICHTEXT + 1000)
#define DISPID_UL                               DISPID_NORMAL_FIRST
#define DISPID_PHRASE                           DISPID_NORMAL_FIRST
#define DISPID_UNKNOWNPDL                       DISPID_NORMAL_FIRST
#define DISPID_COMMENTPDL                       DISPID_NORMAL_FIRST
#define DISPID_TABLECELL                        (DISPID_TEXTSITE + 1000)
#define DISPID_RANGE                            DISPID_NORMAL_FIRST
#define DISPID_SELECTION                        DISPID_NORMAL_FIRST
#define DISPID_OPTION                           DISPID_NORMAL_FIRST
#define DISPID_1D                               (DISPID_TEXTSITE + 1000)
#define DISPID_MAP                              DISPID_NORMAL_FIRST
#define DISPID_AREA                             DISPID_NORMAL_FIRST
#define DISPID_PARAM                            DISPID_NORMAL_FIRST
#define DISPID_TABLESECTION                     DISPID_NORMAL_FIRST
#define DISPID_TABLEROW                         DISPID_NORMAL_FIRST
#define DISPID_TABLECOL                         DISPID_NORMAL_FIRST
#define DISPID_SCRIPT                           DISPID_NORMAL_FIRST
#define DISPID_STYLESHEET                       DISPID_NORMAL_FIRST
#define DISPID_STYLERULE                        DISPID_NORMAL_FIRST
#define DISPID_STYLEPAGE                        DISPID_NORMAL_FIRST
#define DISPID_STYLESHEETS_COL                  DISPID_NORMAL_FIRST
#define DISPID_STYLERULES_COL                   DISPID_NORMAL_FIRST
#define DISPID_STYLEPAGES_COL                   DISPID_NORMAL_FIRST
#define DISPID_MIMETYPES_COL                    DISPID_NORMAL_FIRST
#define DISPID_PLUGINS_COL                      DISPID_NORMAL_FIRST
#define DISPID_2D                               DISPID_NORMAL_FIRST
#define DISPID_OMWINDOW                         DISPID_NORMAL_FIRST
#define DISPID_EVENTOBJ                         DISPID_NORMAL_FIRST
#define DISPID_PERSISTDATA                      DISPID_NORMAL_FIRST
#define DISPID_OLESITE                          DISPID_NORMAL_FIRST
#define DISPID_FRAMESET                         DISPID_NORMAL_FIRST
#define DISPID_LINK                             DISPID_NORMAL_FIRST
#define DISPID_STYLEELEMENT                     DISPID_NORMAL_FIRST
#define DISPID_FILTERS                          DISPID_NORMAL_FIRST
#define DISPID_TABLESECTION                     DISPID_NORMAL_FIRST
#define DISPID_OMRECT                           DISPID_NORMAL_FIRST
#define DISPID_DOMATTRIBUTE                     DISPID_NORMAL_FIRST
#define DISPID_DOMTEXTNODE                      DISPID_NORMAL_FIRST
#define DISPID_GENERIC                          DISPID_NORMAL_FIRST
#define DISPID_URN_COLL                         DISPID_NORMAL_FIRST
#define DISPID_NAMESPACE_COLLECTION             DISPID_NORMAL_FIRST
#define DISPID_NAMESPACE                        DISPID_NORMAL_FIRST
#define DISPID_TAGNAMES_COLLECTION              DISPID_NORMAL_FIRST

#define DISPID_HTMLDOCUMENT                     DISPID_NORMAL_FIRST
#define DISPID_OMDOCUMENT                       DISPID_NORMAL_FIRST
#define DISPID_DATATRANSFER                     DISPID_NORMAL_FIRST
#define DISPID_XMLDECL                          DISPID_NORMAL_FIRST
#define DISPID_DOCFRAG                          DISPID_NORMAL_FIRST
#define DISPID_ILINEINFO                        DISPID_NORMAL_FIRST
#define DISPID_IHTMLCOMPUTEDSTYLE               DISPID_NORMAL_FIRST
//;begin_internal
    // Special case for compatability with IE4 -> therefore the 1:
//;end_internal
#define DISPID_WINDOW                           1
#define DISPID_SCREEN                           DISPID_NORMAL_FIRST
#define DISPID_FRAMESCOLLECTION                 DISPID_NORMAL_FIRST
#define DISPID_HISTORY                          1
#define DISPID_LOCATION                         1
#define DISPID_NAVIGATOR                        1
#define DISPID_COLLECTION                       (DISPID_NORMAL_FIRST+500)
#define DISPID_OPTIONS_COL                      (DISPID_NORMAL_FIRST+500)

#define DISPID_CHECKBOX                         DISPID_NORMAL_FIRST
#define DISPID_RADIO                            (DISPID_CHECKBOX + 1000)

#define DISPID_FRAMESITE                        (DISPID_SITE        + 1000)
#define DISPID_FRAME                            (DISPID_FRAMESITE   + 1000)
#define DISPID_IFRAME                           (DISPID_FRAMESITE   + 1000)

#define WEBOC_DISPIDBASE                        (DISPID_FRAMESITE   + 2000)
#define WEBOC_DISPIDMAX                         (WEBOC_DISPIDBASE   +  100)

#define DISPID_PROTECTEDELEMENT                 DISPID_NORMAL_FIRST
#define DISPID_DEFAULTS                         DISPID_NORMAL_FIRST
#define DISPID_MARKUP                           DISPID_NORMAL_FIRST
#define DISPID_DOMIMPLEMENTATION                DISPID_NORMAL_FIRST

//;begin_internal
//----------------------------------------------------------------------------
//
//  Reserved negative DISPIDs
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_WINDOWOBJECT                     (-5500)
#define DISPID_LOCATIONOBJECT                   (-5506)
#define DISPID_HISTORYOBJECT                    (-5507)
#define DISPID_NAVIGATOROBJECT                  (-5508)
#define DISPID_SECURITYCTX                      (-5511)
#define DISPID_AMBIENT_DLCONTROL                (-5512)
#define DISPID_AMBIENT_USERAGENT                (-5513)
#define DISPID_SECURITYDOMAIN                   (-5514)
//;begin_internal
#define DISPID_DEBUG_ISSECUREPROXY              (-5515)
#define DISPID_DEBUG_TRUSTEDPROXY               (-5516)
#define DISPID_DEBUG_INTERNALWINDOW             (-5517)
#define DISPID_DEBUG_ENABLESECUREPROXYASSERTS   (-5518)
//;end_internal
#define DLCTL_DLIMAGES                          0x00000010
#define DLCTL_VIDEOS                            0x00000020
#define DLCTL_BGSOUNDS                          0x00000040
#define DLCTL_NO_SCRIPTS                        0x00000080
#define DLCTL_NO_JAVA                           0x00000100
#define DLCTL_NO_RUNACTIVEXCTLS                 0x00000200
#define DLCTL_NO_DLACTIVEXCTLS                  0x00000400
#define DLCTL_DOWNLOADONLY                      0x00000800
#define DLCTL_NO_FRAMEDOWNLOAD                  0x00001000
#define DLCTL_RESYNCHRONIZE                     0x00002000
#define DLCTL_PRAGMA_NO_CACHE                   0x00004000
#define DLCTL_NO_BEHAVIORS                      0x00008000
#define DLCTL_NO_METACHARSET                    0x00010000
#define DLCTL_URL_ENCODING_DISABLE_UTF8         0x00020000
#define DLCTL_URL_ENCODING_ENABLE_UTF8          0x00040000
#define DLCTL_NOFRAMES                          0x00080000
#define DLCTL_FORCEOFFLINE                      0x10000000
#define DLCTL_NO_CLIENTPULL                     0x20000000
#define DLCTL_SILENT                            0x40000000
#define DLCTL_OFFLINEIFNOTCONNECTED             0x80000000
#define DLCTL_OFFLINE                           DLCTL_OFFLINEIFNOTCONNECTED

//;begin_internal
//----------------------------------------------------------------------------
//
//  DISPID for each non xobject event
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_ONABORT                          (DISPID_NORMAL_FIRST)
#define DISPID_ONCHANGE                         (DISPID_NORMAL_FIRST + 1)
#define DISPID_ONERROR                          (DISPID_NORMAL_FIRST + 2)
#define DISPID_ONLOAD                           (DISPID_NORMAL_FIRST + 3)
#define DISPID_ONSELECT                         (DISPID_NORMAL_FIRST + 6)
#define DISPID_ONSUBMIT                         (DISPID_NORMAL_FIRST + 7)
#define DISPID_ONUNLOAD                         (DISPID_NORMAL_FIRST + 8)
#define DISPID_ONBOUNCE                         (DISPID_NORMAL_FIRST + 9)
#define DISPID_ONFINISH                         (DISPID_NORMAL_FIRST + 10)
#define DISPID_ONSTART                          (DISPID_NORMAL_FIRST + 11)
#define DISPID_ONLAYOUT                         (DISPID_NORMAL_FIRST + 13)
#define DISPID_ONSCROLL                         (DISPID_NORMAL_FIRST + 14)
#define DISPID_ONRESET                          (DISPID_NORMAL_FIRST + 15)
#define DISPID_ONRESIZE                         (DISPID_NORMAL_FIRST + 16)
#define DISPID_ONBEFOREUNLOAD                   (DISPID_NORMAL_FIRST + 17)
#define DISPID_ONCHANGEFOCUS                    (DISPID_NORMAL_FIRST + 18)
#define DISPID_ONCHANGEBLUR                     (DISPID_NORMAL_FIRST + 19)
#define DISPID_ONPERSIST                        (DISPID_NORMAL_FIRST + 20)
#define DISPID_ONPERSISTSAVE                    (DISPID_NORMAL_FIRST + 21)
#define DISPID_ONPERSISTLOAD                    (DISPID_NORMAL_FIRST + 22)
#define DISPID_ONCONTEXTMENU                    (DISPID_NORMAL_FIRST + 23)
#define DISPID_ONBEFOREPRINT                    (DISPID_NORMAL_FIRST + 24)
#define DISPID_ONAFTERPRINT                     (DISPID_NORMAL_FIRST + 25)
#define DISPID_ONSTOP                           (DISPID_NORMAL_FIRST + 26)
#define DISPID_ONBEFOREEDITFOCUS                (DISPID_NORMAL_FIRST + 27)
#define DISPID_ONMOUSEHOVER                     (DISPID_NORMAL_FIRST + 28)
#define DISPID_ONCONTENTREADY                   (DISPID_NORMAL_FIRST + 29)
#define DISPID_ONLAYOUTCOMPLETE                 (DISPID_NORMAL_FIRST + 30)
#define DISPID_ONPAGE                           (DISPID_NORMAL_FIRST + 31)
#define DISPID_ONLINKEDOVERFLOW                 (DISPID_NORMAL_FIRST + 32)
#define DISPID_ONMOUSEWHEEL                     (DISPID_NORMAL_FIRST + 33)
#define DISPID_ONBEFOREDEACTIVATE               (DISPID_NORMAL_FIRST + 34)
#define DISPID_ONMOVE                           (DISPID_NORMAL_FIRST + 35)
#define DISPID_ONCONTROLSELECT                  (DISPID_NORMAL_FIRST + 36)
#define DISPID_ONSELECTIONCHANGE                (DISPID_NORMAL_FIRST + 37)
#define DISPID_ONMOVESTART                      (DISPID_NORMAL_FIRST + 38)
#define DISPID_ONMOVEEND                        (DISPID_NORMAL_FIRST + 39)
#define DISPID_ONRESIZESTART                    (DISPID_NORMAL_FIRST + 40)
#define DISPID_ONRESIZEEND                      (DISPID_NORMAL_FIRST + 41)
#define DISPID_ONMOUSEENTER                     (DISPID_NORMAL_FIRST + 42)
#define DISPID_ONMOUSELEAVE                     (DISPID_NORMAL_FIRST + 43)
#define DISPID_ONACTIVATE                       (DISPID_NORMAL_FIRST + 44)
#define DISPID_ONDEACTIVATE                     (DISPID_NORMAL_FIRST + 45)
#define DISPID_ONMULTILAYOUTCLEANUP             (DISPID_NORMAL_FIRST + 46)
#define DISPID_ONBEFOREACTIVATE                 (DISPID_NORMAL_FIRST + 47)
#define DISPID_ONFOCUSIN                        (DISPID_NORMAL_FIRST + 48)
#define DISPID_ONFOCUSOUT                       (DISPID_NORMAL_FIRST + 49)

//;begin_internal
//----------------------------------------------------------------------------
//
//  DISPID for each unique HtmlAttribute/CssAttribute
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_A_FIRST                          DISPID_ATTRS
#define DISPID_A_MIN                            DISPID_ATTRS
#define DISPID_A_MAX                            (DISPID_ATTRS+999)

#define DISPID_A_BACKGROUNDIMAGE                (DISPID_A_FIRST+1)
#define DISPID_A_COLOR                          (DISPID_A_FIRST+2)
#define DISPID_A_TEXTTRANSFORM                  (DISPID_A_FIRST+4)
#define DISPID_A_NOWRAP                         (DISPID_A_FIRST+5)
#define DISPID_A_LINEHEIGHT                     (DISPID_A_FIRST+6)
#define DISPID_A_TEXTINDENT                     (DISPID_A_FIRST+7)
#define DISPID_A_LETTERSPACING                  (DISPID_A_FIRST+8)
#define DISPID_A_LANG                           (DISPID_A_FIRST+9)
#define DISPID_A_OVERFLOW                       (DISPID_A_FIRST+10)

#define DISPID_A_PADDING                        (DISPID_A_FIRST+11)
#define DISPID_A_PADDINGTOP                     (DISPID_A_FIRST+12)
#define DISPID_A_PADDINGRIGHT                   (DISPID_A_FIRST+13)
#define DISPID_A_PADDINGBOTTOM                  (DISPID_A_FIRST+14)
#define DISPID_A_PADDINGLEFT                    (DISPID_A_FIRST+15)

#define DISPID_A_CLEAR                          (DISPID_A_FIRST+16)
#define DISPID_A_LISTTYPE                       (DISPID_A_FIRST+17)
#define DISPID_A_FONTFACE                       (DISPID_A_FIRST+18)
#define DISPID_A_FONTSIZE                       (DISPID_A_FIRST+19)

#define DISPID_A_TEXTDECORATIONLINETHROUGH      (DISPID_A_FIRST+20)
#define DISPID_A_TEXTDECORATIONUNDERLINE        (DISPID_A_FIRST+21)
#define DISPID_A_TEXTDECORATIONBLINK            (DISPID_A_FIRST+22)
#define DISPID_A_TEXTDECORATIONNONE             (DISPID_A_FIRST+23)


#define DISPID_A_FONTSTYLE                      (DISPID_A_FIRST+24)
#define DISPID_A_FONTVARIANT                    (DISPID_A_FIRST+25)
#define DISPID_A_BASEFONT                       (DISPID_A_FIRST+26)
#define DISPID_A_FONTWEIGHT                     (DISPID_A_FIRST+27)

#define DISPID_A_TABLEBORDERCOLOR               (DISPID_A_FIRST+28)
#define DISPID_A_TABLEBORDERCOLORLIGHT          (DISPID_A_FIRST+29)
#define DISPID_A_TABLEBORDERCOLORDARK           (DISPID_A_FIRST+30)
#define DISPID_A_TABLEVALIGN                    (DISPID_A_FIRST+31)

#define DISPID_A_BACKGROUND                     (DISPID_A_FIRST+32)
#define DISPID_A_BACKGROUNDPOSX                 (DISPID_A_FIRST+33)
#define DISPID_A_BACKGROUNDPOSY                 (DISPID_A_FIRST+34)

#define DISPID_A_TEXTDECORATION                 (DISPID_A_FIRST+35)

#define DISPID_A_MARGIN                         (DISPID_A_FIRST+36)
#define DISPID_A_MARGINTOP                      (DISPID_A_FIRST+37)
#define DISPID_A_MARGINRIGHT                    (DISPID_A_FIRST+38)
#define DISPID_A_MARGINBOTTOM                   (DISPID_A_FIRST+39)
#define DISPID_A_MARGINLEFT                     (DISPID_A_FIRST+40)

#define DISPID_A_FONT                           (DISPID_A_FIRST+41)
#define DISPID_A_FONTSIZEKEYWORD                (DISPID_A_FIRST+42)
#define DISPID_A_FONTSIZECOMBINE                (DISPID_A_FIRST+43)

#define DISPID_A_BACKGROUNDREPEAT               (DISPID_A_FIRST+44)
#define DISPID_A_BACKGROUNDATTACHMENT           (DISPID_A_FIRST+45)
#define DISPID_A_BACKGROUNDPOSITION             (DISPID_A_FIRST+46)
#define DISPID_A_WORDSPACING                    (DISPID_A_FIRST+47)
#define DISPID_A_VERTICALALIGN                  (DISPID_A_FIRST+48)
#define DISPID_A_BORDER                         (DISPID_A_FIRST+49)
#define DISPID_A_BORDERTOP                      (DISPID_A_FIRST+50)
#define DISPID_A_BORDERRIGHT                    (DISPID_A_FIRST+51)
#define DISPID_A_BORDERBOTTOM                   (DISPID_A_FIRST+52)
#define DISPID_A_BORDERLEFT                     (DISPID_A_FIRST+53)
#define DISPID_A_BORDERCOLOR                    (DISPID_A_FIRST+54)
#define DISPID_A_BORDERTOPCOLOR                 (DISPID_A_FIRST+55)
#define DISPID_A_BORDERRIGHTCOLOR               (DISPID_A_FIRST+56)
#define DISPID_A_BORDERBOTTOMCOLOR              (DISPID_A_FIRST+57)
#define DISPID_A_BORDERLEFTCOLOR                (DISPID_A_FIRST+58)
#define DISPID_A_BORDERWIDTH                    (DISPID_A_FIRST+59)
#define DISPID_A_BORDERTOPWIDTH                 (DISPID_A_FIRST+60)
#define DISPID_A_BORDERRIGHTWIDTH               (DISPID_A_FIRST+61)
#define DISPID_A_BORDERBOTTOMWIDTH              (DISPID_A_FIRST+62)
#define DISPID_A_BORDERLEFTWIDTH                (DISPID_A_FIRST+63)
#define DISPID_A_BORDERSTYLE                    (DISPID_A_FIRST+64)
#define DISPID_A_BORDERTOPSTYLE                 (DISPID_A_FIRST+65)
#define DISPID_A_BORDERRIGHTSTYLE               (DISPID_A_FIRST+66)
#define DISPID_A_BORDERBOTTOMSTYLE              (DISPID_A_FIRST+67)
#define DISPID_A_BORDERLEFTSTYLE                (DISPID_A_FIRST+68)
#define DISPID_A_TEXTDECORATIONOVERLINE         (DISPID_A_FIRST+69)
#define DISPID_A_FLOAT                          (DISPID_A_FIRST+70)
#define DISPID_A_DISPLAY                        (DISPID_A_FIRST+71)
#define DISPID_A_LISTSTYLETYPE                  (DISPID_A_FIRST+72)
#define DISPID_A_LISTSTYLEPOSITION              (DISPID_A_FIRST+73)
#define DISPID_A_LISTSTYLEIMAGE                 (DISPID_A_FIRST+74)
#define DISPID_A_LISTSTYLE                      (DISPID_A_FIRST+75)
#define DISPID_A_WHITESPACE                     (DISPID_A_FIRST+76)
#define DISPID_A_PAGEBREAKBEFORE                (DISPID_A_FIRST+77)
#define DISPID_A_PAGEBREAKAFTER                 (DISPID_A_FIRST+78)
#define DISPID_A_SCROLL                         (DISPID_A_FIRST+79)
#define DISPID_A_VISIBILITY                     (DISPID_A_FIRST+80)
//;begin_internal
// This dispid is available
#define DISPID_A_HIDDEN                         (DISPID_A_FIRST+81)
//;end_internal
#define DISPID_A_FILTER                         (DISPID_A_FIRST+82)

#define DISPID_DEFAULTVALUE                     (DISPID_A_FIRST+83)

#define DISPID_A_BORDERCOLLAPSE                 (DISPID_A_FIRST+84)

#define DISPID_A_POSITION                       (DISPID_A_FIRST+90)
#define DISPID_A_ZINDEX                         (DISPID_A_FIRST+91)
#define DISPID_A_CLIP                           (DISPID_A_FIRST+92)
#define DISPID_A_CLIPRECTTOP                    (DISPID_A_FIRST+93)
#define DISPID_A_CLIPRECTRIGHT                  (DISPID_A_FIRST+94)
#define DISPID_A_CLIPRECTBOTTOM                 (DISPID_A_FIRST+95)
#define DISPID_A_CLIPRECTLEFT                   (DISPID_A_FIRST+96)

#define DISPID_A_FONTFACESRC                    (DISPID_A_FIRST+97)
#define DISPID_A_TABLELAYOUT                    (DISPID_A_FIRST+98)

//;begin_internal
// The style as a text string
//;end_internal
#define DISPID_A_STYLETEXT                      (DISPID_A_FIRST+99)

//;begin_internal
// Known attributes that have special meaning
//;end_internal
#define DISPID_A_LANGUAGE                       (DISPID_A_FIRST+100)

#define DISPID_A_VALUE                          (DISPID_A_FIRST+101)
#define DISPID_A_CURSOR                         (DISPID_A_FIRST+102)


//;begin_internal
//+-----------------------------------------------------------------------
//  A couple of dispids that are used internally for firing
//  events and prop notifies.
// Keep all the internal dispid's together, otherwise we'll trip up 

#define DISPID_A_EVENTSINK                      (DISPID_A_FIRST+103)
#define DISPID_A_PROPNOTIFYSINK                 (DISPID_A_FIRST+104)
#define DISPID_A_ROWSETNOTIFYSINK               (DISPID_A_FIRST+105)
#define DISPID_INTERNAL_INLINESTYLEAA           (DISPID_A_FIRST+106) // In line style Attr Array
#define DISPID_INTERNAL_CSTYLEPTRCACHE          (DISPID_A_FIRST+107) // Cached CStyle Ptr
#define DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE   (DISPID_A_FIRST+108) // runtime style ptr obj
#define DISPID_INTERNAL_INVOKECONTEXT           (DISPID_A_FIRST+109) // Cached Invoke context

#define DISPID_A_BGURLIMGCTXCACHEINDEX          (DISPID_A_FIRST+110)
#define DISPID_A_LIURLIMGCTXCACHEINDEX          (DISPID_A_FIRST+111)
#define DISPID_A_ROWSETASYNCHNOTIFYSINK         (DISPID_A_FIRST+112)
#define DISPID_INTERNAL_FILTERPTRCACHE          (DISPID_A_FIRST+113) // FilterCollection in AttrArray
#define DISPID_A_ROWPOSITIONCHANGESINK          (DISPID_A_FIRST+114)
//;end_internal

#define DISPID_A_BEHAVIOR                       (DISPID_A_FIRST+115) // xtags
#define DISPID_A_READYSTATE                     (DISPID_A_FIRST+116) // ready state

#define DISPID_A_DIR                            (DISPID_A_FIRST+117) // Complex Text support for bidi
#define DISPID_A_UNICODEBIDI                    (DISPID_A_FIRST+118) // Complex Text support for CSS2 unicode-bidi
#define DISPID_A_DIRECTION                      (DISPID_A_FIRST+119) // Complex Text support for CSS2 direction

#define DISPID_A_IMEMODE                        (DISPID_A_FIRST+120) 

#define DISPID_A_RUBYALIGN                      (DISPID_A_FIRST+121)
#define DISPID_A_RUBYPOSITION                   (DISPID_A_FIRST+122)
#define DISPID_A_RUBYOVERHANG                   (DISPID_A_FIRST+123)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_CONTENTREADY  (DISPID_A_FIRST+124)
#define DISPID_INTERNAL_ONBEHAVIOR_DOCUMENTREADY (DISPID_A_FIRST+125)
#define DISPID_INTERNAL_CDOMCHILDRENPTRCACHE     (DISPID_A_FIRST+126)
//;end_internal

#define DISPID_A_LAYOUTGRIDCHAR                 (DISPID_A_FIRST+127)
#define DISPID_A_LAYOUTGRIDLINE                 (DISPID_A_FIRST+128)
#define DISPID_A_LAYOUTGRIDMODE                 (DISPID_A_FIRST+129)
#define DISPID_A_LAYOUTGRIDTYPE                 (DISPID_A_FIRST+130)
#define DISPID_A_LAYOUTGRID                     (DISPID_A_FIRST+131)

#define DISPID_A_TEXTAUTOSPACE                  (DISPID_A_FIRST+132)

#define DISPID_A_LINEBREAK                      (DISPID_A_FIRST+133)
#define DISPID_A_WORDBREAK                      (DISPID_A_FIRST+134)

#define DISPID_A_TEXTJUSTIFY                    (DISPID_A_FIRST+135)
#define DISPID_A_TEXTJUSTIFYTRIM                (DISPID_A_FIRST+136)
#define DISPID_A_TEXTKASHIDA                    (DISPID_A_FIRST+137)

#define DISPID_A_OVERFLOWX                      (DISPID_A_FIRST+139)
#define DISPID_A_OVERFLOWY                      (DISPID_A_FIRST+140)

#define DISPID_A_HTCDISPATCHITEM_VALUE          (DISPID_A_FIRST+141)
#define DISPID_A_DOCFRAGMENT                    (DISPID_A_FIRST+142)

#define DISPID_A_HTCDD_ELEMENT                  (DISPID_A_FIRST+143)
#define DISPID_A_HTCDD_CREATEEVENTOBJECT        (DISPID_A_FIRST+144)

#define DISPID_A_URNATOM                        (DISPID_A_FIRST+145)
#define DISPID_A_UNIQUEPEERNUMBER               (DISPID_A_FIRST+146)

#define DISPID_A_ACCELERATOR                    (DISPID_A_FIRST+147)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_APPLYSTYLE       (DISPID_A_FIRST+148)
#define DISPID_INTERNAL_RUNTIMESTYLEAA              (DISPID_A_FIRST+149)
#define DISPID_A_HTCDISPATCHITEM_VALUE_SCRIPTSONLY  (DISPID_A_FIRST+150)
//;end_internal

#define DISPID_A_EXTENDEDTAGDESC                (DISPID_A_FIRST+151)

#define DISPID_A_ROTATE                         (DISPID_A_FIRST+152)
#define DISPID_A_ZOOM                           (DISPID_A_FIRST+153)

#define DISPID_A_HTCDD_PROTECTEDELEMENT         (DISPID_A_FIRST+154)
#define DISPID_A_LAYOUTFLOW                     (DISPID_A_FIRST+155)
// DISPID_A_FIRST+156 unused -- removing 'rectangular'
// #define DISPID_A_RECTANGULAR                    (DISPID_A_FIRST+156)

#define DISPID_A_HTCDD_ISMARKUPSHARED           (DISPID_A_FIRST+157)
#define DISPID_A_WORDWRAP                       (DISPID_A_FIRST+158)
#define DISPID_A_TEXTUNDERLINEPOSITION          (DISPID_A_FIRST+159)
#define DISPID_A_HASLAYOUT                      (DISPID_A_FIRST+160)
#define DISPID_A_MEDIA                          (DISPID_A_FIRST+161)
#define DISPID_A_EDITABLE                       (DISPID_A_FIRST+162)
#define DISPID_A_HIDEFOCUS                      (DISPID_A_FIRST+163)

//;begin_internal
#define DISPID_INTERNAL_LAYOUTRECTREGISTRYPTRCACHE  (DISPID_A_FIRST+164)
//;end_internal

#define DISPID_A_HTCDD_DEFAULTS                 (DISPID_A_FIRST+165)

#define DISPID_A_TEXTLINETHROUGHSTYLE           (DISPID_A_FIRST+166)
#define DISPID_A_TEXTUNDERLINESTYLE             (DISPID_A_FIRST+167)
#define DISPID_A_TEXTEFFECT                     (DISPID_A_FIRST+168)
#define DISPID_A_TEXTBACKGROUNDCOLOR            (DISPID_A_FIRST+169)
#define DISPID_A_RENDERINGPRIORITY              (DISPID_A_FIRST+170)

//;begin_internal
#define DISPID_INTERNAL_DWNPOSTPTRCACHE             (DISPID_A_FIRST+171)
#define DISPID_INTERNAL_CODEPAGESETTINGSPTRCACHE    (DISPID_A_FIRST+172)
#define DISPID_INTERNAL_DWNDOCPTRCACHE              (DISPID_A_FIRST+173)
#define DISPID_INTERNAL_DATABINDTASKPTRCACHE        (DISPID_A_FIRST+174)
#define DISPID_INTERNAL_URLLOCATIONCACHE            (DISPID_A_FIRST+175)
#define DISPID_INTERNAL_ARYELEMENTRELEASENOTIFYPTRCACHE (DISPID_A_FIRST+176)
#define DISPID_INTERNAL_PEERFACTORYURLMAPPTRCACHE   (DISPID_A_FIRST+177)
#define DISPID_INTERNAL_STMDIRTYPTRCACHE            (DISPID_A_FIRST+178)
//;end_internal

//;begin_internal
#define DISPID_INTERNAL_COMPUTEFORMATSTATECACHE     (DISPID_A_FIRST+179)
//;end_internal

//
#define DISPID_A_SCROLLBARBASECOLOR             (DISPID_A_FIRST+180)
#define DISPID_A_SCROLLBARFACECOLOR             (DISPID_A_FIRST+181)
#define DISPID_A_SCROLLBAR3DLIGHTCOLOR          (DISPID_A_FIRST+182)
#define DISPID_A_SCROLLBARSHADOWCOLOR           (DISPID_A_FIRST+183)
#define DISPID_A_SCROLLBARHIGHLIGHTCOLOR        (DISPID_A_FIRST+184)
#define DISPID_A_SCROLLBARDARKSHADOWCOLOR       (DISPID_A_FIRST+185)
#define DISPID_A_SCROLLBARARROWCOLOR            (DISPID_A_FIRST+186)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_CONTENTSAVE  (DISPID_A_FIRST+187)
//;end_internal

#define DISPID_A_DEFAULTTEXTSELECTION           (DISPID_A_FIRST+188)
#define DISPID_A_TEXTDECORATIONCOLOR            (DISPID_A_FIRST+189)
#define DISPID_A_TEXTCOLOR                      (DISPID_A_FIRST+190)
#define DISPID_A_STYLETEXTDECORATION            (DISPID_A_FIRST+191)

#define DISPID_A_WRITINGMODE                    (DISPID_A_FIRST+192)

//;begin_internal
#define DISPID_INTERNAL_MEDIA_REFERENCE         (DISPID_A_FIRST+193)
#define DISPID_INTERNAL_GENERICCOMPLUSREF       (DISPID_A_FIRST+194)
//;end_internal

//;begin_internal
#define DISPID_INTERNAL_FOCUSITEMS              (DISPID_A_FIRST+195)
//;end_internal

#define DISPID_A_SCROLLBARTRACKCOLOR            (DISPID_A_FIRST+196)

//;begin_internal
#define DISPID_INTERNAL_DWNHEADERCACHE          (DISPID_A_FIRST+197)
//;end_internal

#define DISPID_A_FROZEN                         (DISPID_A_FIRST+198)
#define DISPID_A_VIEWINHERITSTYLE               (DISPID_A_FIRST+199)

//;begin_internal
#define DISPID_INTERNAL_FRAMESCOLLECTION        (DISPID_A_FIRST+200)
//;end_internal

//;begin_internal
#define DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE    (DISPID_A_FIRST+201)
#define DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER  (DISPID_A_FIRST+202)
//;end_internal

#define DISPID_A_TEXTALIGNLAST                  (DISPID_A_FIRST+203)
#define DISPID_A_TEXTKASHIDASPACE               (DISPID_A_FIRST+204)

//;begin_internal
#define DISPID_INTERNAL_FONTHISTORYINDEX        (DISPID_A_FIRST+205)
//;end_internal

#define DISPID_A_ALLOWTRANSPARENCY              (DISPID_A_FIRST+206)

#define DISPID_INTERNAL_URLSEARCHCACHE          (DISPID_A_FIRST+207)

#define DISPID_A_ISBLOCK                        (DISPID_A_FIRST+208)

#define DISPID_A_TEXTOVERFLOW                   (DISPID_A_FIRST+209)

//;begin_internal
#define DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE  (DISPID_A_FIRST+210)
//;end_internal

#define DISPID_A_MINHEIGHT                      (DISPID_A_FIRST+211)

//;begin_internal
//------------------------------------------------------------------------
//
//  Event property and method dispids
//
//------------------------------------------------------------------------
//;end_internal

#define DISPID_EVPROP_ONMOUSEOVER           (DISPID_EVENTS +  0)
#define DISPID_EVMETH_ONMOUSEOVER            STDDISPID_XOBJ_ONMOUSEOVER
#define DISPID_EVPROP_ONMOUSEOUT            (DISPID_EVENTS +  1)
#define DISPID_EVMETH_ONMOUSEOUT             STDDISPID_XOBJ_ONMOUSEOUT
#define DISPID_EVPROP_ONMOUSEDOWN           (DISPID_EVENTS +  2)
#define DISPID_EVMETH_ONMOUSEDOWN            DISPID_MOUSEDOWN
#define DISPID_EVPROP_ONMOUSEUP             (DISPID_EVENTS +  3)
#define DISPID_EVMETH_ONMOUSEUP              DISPID_MOUSEUP
#define DISPID_EVPROP_ONMOUSEMOVE           (DISPID_EVENTS +  4)
#define DISPID_EVMETH_ONMOUSEMOVE            DISPID_MOUSEMOVE
#define DISPID_EVPROP_ONKEYDOWN             (DISPID_EVENTS +  5)
#define DISPID_EVMETH_ONKEYDOWN              DISPID_KEYDOWN
#define DISPID_EVPROP_ONKEYUP               (DISPID_EVENTS +  6)
#define DISPID_EVMETH_ONKEYUP                DISPID_KEYUP
#define DISPID_EVPROP_ONKEYPRESS            (DISPID_EVENTS +  7)
#define DISPID_EVMETH_ONKEYPRESS             DISPID_KEYPRESS
#define DISPID_EVPROP_ONCLICK               (DISPID_EVENTS +  8)
#define DISPID_EVMETH_ONCLICK                DISPID_CLICK
#define DISPID_EVPROP_ONDBLCLICK            (DISPID_EVENTS +  9)
#define DISPID_EVMETH_ONDBLCLICK             DISPID_DBLCLICK
#define DISPID_EVPROP_ONSELECT              (DISPID_EVENTS + 10)
#define DISPID_EVMETH_ONSELECT               DISPID_ONSELECT
#define DISPID_EVPROP_ONSUBMIT              (DISPID_EVENTS + 11)
#define DISPID_EVMETH_ONSUBMIT               DISPID_ONSUBMIT
#define DISPID_EVPROP_ONRESET               (DISPID_EVENTS + 12)
#define DISPID_EVMETH_ONRESET                DISPID_ONRESET
#define DISPID_EVPROP_ONHELP                (DISPID_EVENTS + 13)
#define DISPID_EVMETH_ONHELP                 STDDISPID_XOBJ_ONHELP
#define DISPID_EVPROP_ONFOCUS               (DISPID_EVENTS + 14)
#define DISPID_EVMETH_ONFOCUS                STDDISPID_XOBJ_ONFOCUS
#define DISPID_EVPROP_ONBLUR                (DISPID_EVENTS + 15)
#define DISPID_EVMETH_ONBLUR                 STDDISPID_XOBJ_ONBLUR
#define DISPID_EVPROP_ONROWEXIT             (DISPID_EVENTS + 18)
#define DISPID_EVMETH_ONROWEXIT              STDDISPID_XOBJ_ONROWEXIT
#define DISPID_EVPROP_ONROWENTER            (DISPID_EVENTS + 19)
#define DISPID_EVMETH_ONROWENTER             STDDISPID_XOBJ_ONROWENTER
#define DISPID_EVPROP_ONBOUNCE              (DISPID_EVENTS + 20)
#define DISPID_EVMETH_ONBOUNCE               DISPID_ONBOUNCE
#define DISPID_EVPROP_ONBEFOREUPDATE        (DISPID_EVENTS + 21)
#define DISPID_EVMETH_ONBEFOREUPDATE         STDDISPID_XOBJ_BEFOREUPDATE
#define DISPID_EVPROP_ONAFTERUPDATE         (DISPID_EVENTS + 22)
#define DISPID_EVMETH_ONAFTERUPDATE          STDDISPID_XOBJ_AFTERUPDATE
#define DISPID_EVPROP_ONBEFOREDRAGOVER      (DISPID_EVENTS + 23)
#define DISPID_EVMETH_ONBEFOREDRAGOVER       EVENTID_CommonCtrlEvent_BeforeDragOver
#define DISPID_EVPROP_ONBEFOREDROPORPASTE   (DISPID_EVENTS + 24)
#define DISPID_EVMETH_ONBEFOREDROPORPASTE    EVENTID_CommonCtrlEvent_BeforeDropOrPaste
#define DISPID_EVPROP_ONREADYSTATECHANGE    (DISPID_EVENTS + 25)
#define DISPID_EVMETH_ONREADYSTATECHANGE     DISPID_READYSTATECHANGE
#define DISPID_EVPROP_ONFINISH              (DISPID_EVENTS + 26)
#define DISPID_EVMETH_ONFINISH               DISPID_ONFINISH
#define DISPID_EVPROP_ONSTART               (DISPID_EVENTS + 27)
#define DISPID_EVMETH_ONSTART                DISPID_ONSTART
#define DISPID_EVPROP_ONABORT               (DISPID_EVENTS + 28)
#define DISPID_EVMETH_ONABORT                DISPID_ONABORT
#define DISPID_EVPROP_ONERROR               (DISPID_EVENTS + 29)
#define DISPID_EVMETH_ONERROR                DISPID_ONERROR
#define DISPID_EVPROP_ONCHANGE              (DISPID_EVENTS + 30)
#define DISPID_EVMETH_ONCHANGE               DISPID_ONCHANGE
#define DISPID_EVPROP_ONSCROLL              (DISPID_EVENTS + 31)
#define DISPID_EVMETH_ONSCROLL               DISPID_ONSCROLL
#define DISPID_EVPROP_ONLOAD                (DISPID_EVENTS + 32)
#define DISPID_EVMETH_ONLOAD                 DISPID_ONLOAD
#define DISPID_EVPROP_ONUNLOAD              (DISPID_EVENTS + 33)
#define DISPID_EVMETH_ONUNLOAD               DISPID_ONUNLOAD
#define DISPID_EVPROP_ONLAYOUT              (DISPID_EVENTS + 34)
#define DISPID_EVMETH_ONLAYOUT               DISPID_ONLAYOUT
#define DISPID_EVPROP_ONDRAGSTART           (DISPID_EVENTS + 35)
#define DISPID_EVMETH_ONDRAGSTART            STDDISPID_XOBJ_ONDRAGSTART
#define DISPID_EVPROP_ONRESIZE              (DISPID_EVENTS + 36)
#define DISPID_EVMETH_ONRESIZE               DISPID_ONRESIZE
#define DISPID_EVPROP_ONSELECTSTART         (DISPID_EVENTS + 37)
#define DISPID_EVMETH_ONSELECTSTART          STDDISPID_XOBJ_ONSELECTSTART
#define DISPID_EVPROP_ONERRORUPDATE         (DISPID_EVENTS + 38)
#define DISPID_EVMETH_ONERRORUPDATE          STDDISPID_XOBJ_ERRORUPDATE
#define DISPID_EVPROP_ONBEFOREUNLOAD        (DISPID_EVENTS + 39)
#define DISPID_EVMETH_ONBEFOREUNLOAD         DISPID_ONBEFOREUNLOAD
#define DISPID_EVPROP_ONDATASETCHANGED      (DISPID_EVENTS + 40)
#define DISPID_EVMETH_ONDATASETCHANGED       STDDISPID_XOBJ_ONDATASETCHANGED
#define DISPID_EVPROP_ONDATAAVAILABLE       (DISPID_EVENTS + 41)
#define DISPID_EVMETH_ONDATAAVAILABLE        STDDISPID_XOBJ_ONDATAAVAILABLE
#define DISPID_EVPROP_ONDATASETCOMPLETE     (DISPID_EVENTS + 42)
#define DISPID_EVMETH_ONDATASETCOMPLETE      STDDISPID_XOBJ_ONDATASETCOMPLETE
#define DISPID_EVPROP_ONFILTER              (DISPID_EVENTS + 43)
#define DISPID_EVMETH_ONFILTER               STDDISPID_XOBJ_ONFILTER
#define DISPID_EVPROP_ONCHANGEFOCUS         (DISPID_EVENTS + 44)
#define DISPID_EVMETH_ONCHANGEFOCUS          DISPID_ONCHANGEFOCUS
#define DISPID_EVPROP_ONCHANGEBLUR          (DISPID_EVENTS + 45)
#define DISPID_EVMETH_ONCHANGEBLUR           DISPID_ONCHANGEBLUR
#define DISPID_EVPROP_ONLOSECAPTURE         (DISPID_EVENTS + 46)
#define DISPID_EVMETH_ONLOSECAPTURE          STDDISPID_XOBJ_ONLOSECAPTURE
#define DISPID_EVPROP_ONPROPERTYCHANGE      (DISPID_EVENTS + 47)
#define DISPID_EVMETH_ONPROPERTYCHANGE       STDDISPID_XOBJ_ONPROPERTYCHANGE
#define DISPID_EVPROP_ONPERSISTSAVE         (DISPID_EVENTS + 48)
#define DISPID_EVMETH_ONPERSISTSAVE          DISPID_ONPERSISTSAVE
#define DISPID_EVPROP_ONDRAG                (DISPID_EVENTS + 49)
#define DISPID_EVMETH_ONDRAG                 STDDISPID_XOBJ_ONDRAG
#define DISPID_EVPROP_ONDRAGEND             (DISPID_EVENTS + 50)
#define DISPID_EVMETH_ONDRAGEND              STDDISPID_XOBJ_ONDRAGEND
#define DISPID_EVPROP_ONDRAGENTER           (DISPID_EVENTS + 51)
#define DISPID_EVMETH_ONDRAGENTER            STDDISPID_XOBJ_ONDRAGENTER
#define DISPID_EVPROP_ONDRAGOVER            (DISPID_EVENTS + 52)
#define DISPID_EVMETH_ONDRAGOVER             STDDISPID_XOBJ_ONDRAGOVER
#define DISPID_EVPROP_ONDRAGLEAVE           (DISPID_EVENTS + 53)
#define DISPID_EVMETH_ONDRAGLEAVE            STDDISPID_XOBJ_ONDRAGLEAVE
#define DISPID_EVPROP_ONDROP                (DISPID_EVENTS + 54)
#define DISPID_EVMETH_ONDROP                 STDDISPID_XOBJ_ONDROP
#define DISPID_EVPROP_ONCUT                 (DISPID_EVENTS + 55)
#define DISPID_EVMETH_ONCUT                  STDDISPID_XOBJ_ONCUT
#define DISPID_EVPROP_ONCOPY                (DISPID_EVENTS + 56)
#define DISPID_EVMETH_ONCOPY                 STDDISPID_XOBJ_ONCOPY
#define DISPID_EVPROP_ONPASTE               (DISPID_EVENTS + 57)
#define DISPID_EVMETH_ONPASTE                STDDISPID_XOBJ_ONPASTE
#define DISPID_EVPROP_ONBEFORECUT           (DISPID_EVENTS + 58)
#define DISPID_EVMETH_ONBEFORECUT            STDDISPID_XOBJ_ONBEFORECUT
#define DISPID_EVPROP_ONBEFORECOPY          (DISPID_EVENTS + 59)
#define DISPID_EVMETH_ONBEFORECOPY           STDDISPID_XOBJ_ONBEFORECOPY
#define DISPID_EVPROP_ONBEFOREPASTE         (DISPID_EVENTS + 60)
#define DISPID_EVMETH_ONBEFOREPASTE          STDDISPID_XOBJ_ONBEFOREPASTE
#define DISPID_EVPROP_ONPERSISTLOAD         (DISPID_EVENTS + 61)
#define DISPID_EVMETH_ONPERSISTLOAD          DISPID_ONPERSISTLOAD
#define DISPID_EVPROP_ONROWSDELETE          (DISPID_EVENTS + 62)
#define DISPID_EVMETH_ONROWSDELETE           STDDISPID_XOBJ_ONROWSDELETE
#define DISPID_EVPROP_ONROWSINSERTED        (DISPID_EVENTS + 63)
#define DISPID_EVMETH_ONROWSINSERTED         STDDISPID_XOBJ_ONROWSINSERTED
#define DISPID_EVPROP_ONCELLCHANGE          (DISPID_EVENTS + 64)
#define DISPID_EVMETH_ONCELLCHANGE           STDDISPID_XOBJ_ONCELLCHANGE
#define DISPID_EVPROP_ONCONTEXTMENU         (DISPID_EVENTS + 65)
#define DISPID_EVMETH_ONCONTEXTMENU          DISPID_ONCONTEXTMENU
#define DISPID_EVPROP_ONBEFOREPRINT         (DISPID_EVENTS + 66)
#define DISPID_EVMETH_ONBEFOREPRINT          DISPID_ONBEFOREPRINT
#define DISPID_EVPROP_ONAFTERPRINT          (DISPID_EVENTS + 67)
#define DISPID_EVMETH_ONAFTERPRINT           DISPID_ONAFTERPRINT
#define DISPID_EVPROP_ONSTOP                (DISPID_EVENTS + 68)
#define DISPID_EVMETH_ONSTOP                DISPID_ONSTOP
#define DISPID_EVPROP_ONBEFOREEDITFOCUS     (DISPID_EVENTS + 69)
#define DISPID_EVMETH_ONBEFOREEDITFOCUS      DISPID_ONBEFOREEDITFOCUS
#define DISPID_EVPROP_ONATTACHEVENT         (DISPID_EVENTS + 70)
#define DISPID_EVPROP_ONMOUSEHOVER          (DISPID_EVENTS + 71)
#define DISPID_EVMETH_ONMOUSEHOVER           DISPID_ONMOUSEHOVER
#define DISPID_EVPROP_ONCONTENTREADY        (DISPID_EVENTS + 72)
#define DISPID_EVMETH_ONCONTENTREADY         DISPID_ONCONTENTREADY
#define DISPID_EVPROP_ONLAYOUTCOMPLETE      (DISPID_EVENTS + 73)
#define DISPID_EVMETH_ONLAYOUTCOMPLETE       DISPID_ONLAYOUTCOMPLETE
#define DISPID_EVPROP_ONPAGE                (DISPID_EVENTS + 74)
#define DISPID_EVMETH_ONPAGE                 DISPID_ONPAGE
#define DISPID_EVPROP_ONLINKEDOVERFLOW      (DISPID_EVENTS + 75)
#define DISPID_EVMETH_ONLINKEDOVERFLOW       DISPID_ONLINKEDOVERFLOW
#define DISPID_EVPROP_ONMOUSEWHEEL          (DISPID_EVENTS + 76)
#define DISPID_EVMETH_ONMOUSEWHEEL           DISPID_ONMOUSEWHEEL
#define DISPID_EVPROP_ONBEFOREDEACTIVATE    (DISPID_EVENTS + 77)
#define DISPID_EVMETH_ONBEFOREDEACTIVATE     DISPID_ONBEFOREDEACTIVATE
#define DISPID_EVPROP_ONMOVE                (DISPID_EVENTS + 78)
#define DISPID_EVMETH_ONMOVE                 DISPID_ONMOVE
#define DISPID_EVPROP_ONCONTROLSELECT       (DISPID_EVENTS + 79)
#define DISPID_EVMETH_ONCONTROLSELECT        DISPID_ONCONTROLSELECT
#define DISPID_EVPROP_ONSELECTIONCHANGE     (DISPID_EVENTS + 80)
#define DISPID_EVMETH_ONSELECTIONCHANGE      DISPID_ONSELECTIONCHANGE
#define DISPID_EVPROP_ONMOVESTART           (DISPID_EVENTS + 81)
#define DISPID_EVMETH_ONMOVESTART            DISPID_ONMOVESTART
#define DISPID_EVPROP_ONMOVEEND             (DISPID_EVENTS + 82)
#define DISPID_EVMETH_ONMOVEEND              DISPID_ONMOVEEND
#define DISPID_EVPROP_ONRESIZESTART         (DISPID_EVENTS + 83)
#define DISPID_EVMETH_ONRESIZESTART          DISPID_ONRESIZESTART
#define DISPID_EVPROP_ONRESIZEEND           (DISPID_EVENTS + 84)
#define DISPID_EVMETH_ONRESIZEEND            DISPID_ONRESIZEEND
#define DISPID_EVPROP_ONMOUSEENTER          (DISPID_EVENTS + 85)
#define DISPID_EVMETH_ONMOUSEENTER           DISPID_ONMOUSEENTER
#define DISPID_EVPROP_ONMOUSELEAVE          (DISPID_EVENTS + 86)
#define DISPID_EVMETH_ONMOUSELEAVE           DISPID_ONMOUSELEAVE
#define DISPID_EVPROP_ONACTIVATE            (DISPID_EVENTS + 87)
#define DISPID_EVMETH_ONACTIVATE             DISPID_ONACTIVATE
#define DISPID_EVPROP_ONDEACTIVATE          (DISPID_EVENTS + 88)
#define DISPID_EVMETH_ONDEACTIVATE           DISPID_ONDEACTIVATE
#define DISPID_EVPROP_ONMULTILAYOUTCLEANUP  (DISPID_EVENTS + 89)
#define DISPID_EVMETH_ONMULTILAYOUTCLEANUP   DISPID_ONMULTILAYOUTCLEANUP
#define DISPID_EVPROP_ONBEFOREACTIVATE      (DISPID_EVENTS + 90)
#define DISPID_EVMETH_ONBEFOREACTIVATE       DISPID_ONBEFOREACTIVATE
#define DISPID_EVPROP_ONFOCUSIN             (DISPID_EVENTS + 91)
#define DISPID_EVMETH_ONFOCUSIN              DISPID_ONFOCUSIN
#define DISPID_EVPROP_ONFOCUSOUT            (DISPID_EVENTS + 92)
#define DISPID_EVMETH_ONFOCUSOUT             DISPID_ONFOCUSOUT
#define DISPID_EVPROPS_COUNT                (                93)


//;begin_internal
#endif // __COREDISP_H__
//;end_internal

//    DISPIDs for interface IHTMLFiltersCollection

#define DISPID_IHTMLFILTERSCOLLECTION_LENGTH                      DISPID_FILTERS+1
#define DISPID_IHTMLFILTERSCOLLECTION__NEWENUM                    DISPID_NEWENUM
#define DISPID_IHTMLFILTERSCOLLECTION_ITEM                        DISPID_VALUE

//    DISPIDs for interface IDispatchEx

#define DISPID_IDISPATCHEX_GETDISPID                              
#define DISPID_IDISPATCHEX_INVOKEEX                               
#define DISPID_IDISPATCHEX_DELETEMEMBERBYNAME                     
#define DISPID_IDISPATCHEX_DELETEMEMBERBYDISPID                   
#define DISPID_IDISPATCHEX_GETMEMBERPROPERTIES                    
#define DISPID_IDISPATCHEX_GETMEMBERNAME                          
#define DISPID_IDISPATCHEX_GETNEXTDISPID                          
#define DISPID_IDISPATCHEX_GETNAMESPACEPARENT                     

//    DISPIDs for interface IObjectIdentity

#define DISPID_IOBJECTIDENTITY_ISEQUALOBJECT                      

//    DISPIDs for interface IPerPropertyBrowsing

#define DISPID_IPERPROPERTYBROWSING_GETDISPLAYSTRING              
#define DISPID_IPERPROPERTYBROWSING_MAPPROPERTYTOPAGE             
#define DISPID_IPERPROPERTYBROWSING_GETPREDEFINEDSTRINGS          
#define DISPID_IPERPROPERTYBROWSING_GETPREDEFINEDVALUE            

//    DISPIDs for interface IHTMLStyle

#define DISPID_IHTMLSTYLE_FONTFAMILY                              DISPID_A_FONTFACE
#define DISPID_IHTMLSTYLE_FONTSTYLE                               DISPID_A_FONTSTYLE
#define DISPID_IHTMLSTYLE_FONTVARIANT                             DISPID_A_FONTVARIANT
#define DISPID_IHTMLSTYLE_FONTWEIGHT                              DISPID_A_FONTWEIGHT
#define DISPID_IHTMLSTYLE_FONTSIZE                                DISPID_A_FONTSIZE
#define DISPID_IHTMLSTYLE_FONT                                    DISPID_A_FONT
#define DISPID_IHTMLSTYLE_COLOR                                   DISPID_A_COLOR
#define DISPID_IHTMLSTYLE_BACKGROUND                              DISPID_A_BACKGROUND
#define DISPID_IHTMLSTYLE_BACKGROUNDCOLOR                         DISPID_BACKCOLOR
#define DISPID_IHTMLSTYLE_BACKGROUNDIMAGE                         DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLSTYLE_BACKGROUNDREPEAT                        DISPID_A_BACKGROUNDREPEAT
#define DISPID_IHTMLSTYLE_BACKGROUNDATTACHMENT                    DISPID_A_BACKGROUNDATTACHMENT
#define DISPID_IHTMLSTYLE_BACKGROUNDPOSITION                      DISPID_A_BACKGROUNDPOSITION
#define DISPID_IHTMLSTYLE_BACKGROUNDPOSITIONX                     DISPID_A_BACKGROUNDPOSX
#define DISPID_IHTMLSTYLE_BACKGROUNDPOSITIONY                     DISPID_A_BACKGROUNDPOSY
#define DISPID_IHTMLSTYLE_WORDSPACING                             DISPID_A_WORDSPACING
#define DISPID_IHTMLSTYLE_LETTERSPACING                           DISPID_A_LETTERSPACING
#define DISPID_IHTMLSTYLE_TEXTDECORATION                          DISPID_A_TEXTDECORATION
#define DISPID_IHTMLSTYLE_TEXTDECORATIONNONE                      DISPID_A_TEXTDECORATIONNONE
#define DISPID_IHTMLSTYLE_TEXTDECORATIONUNDERLINE                 DISPID_A_TEXTDECORATIONUNDERLINE
#define DISPID_IHTMLSTYLE_TEXTDECORATIONOVERLINE                  DISPID_A_TEXTDECORATIONOVERLINE
#define DISPID_IHTMLSTYLE_TEXTDECORATIONLINETHROUGH               DISPID_A_TEXTDECORATIONLINETHROUGH
#define DISPID_IHTMLSTYLE_TEXTDECORATIONBLINK                     DISPID_A_TEXTDECORATIONBLINK
#define DISPID_IHTMLSTYLE_VERTICALALIGN                           DISPID_A_VERTICALALIGN
#define DISPID_IHTMLSTYLE_TEXTTRANSFORM                           DISPID_A_TEXTTRANSFORM
#define DISPID_IHTMLSTYLE_TEXTALIGN                               STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLSTYLE_TEXTINDENT                              DISPID_A_TEXTINDENT
#define DISPID_IHTMLSTYLE_LINEHEIGHT                              DISPID_A_LINEHEIGHT
#define DISPID_IHTMLSTYLE_MARGINTOP                               DISPID_A_MARGINTOP
#define DISPID_IHTMLSTYLE_MARGINRIGHT                             DISPID_A_MARGINRIGHT
#define DISPID_IHTMLSTYLE_MARGINBOTTOM                            DISPID_A_MARGINBOTTOM
#define DISPID_IHTMLSTYLE_MARGINLEFT                              DISPID_A_MARGINLEFT
#define DISPID_IHTMLSTYLE_MARGIN                                  DISPID_A_MARGIN
#define DISPID_IHTMLSTYLE_PADDINGTOP                              DISPID_A_PADDINGTOP
#define DISPID_IHTMLSTYLE_PADDINGRIGHT                            DISPID_A_PADDINGRIGHT
#define DISPID_IHTMLSTYLE_PADDINGBOTTOM                           DISPID_A_PADDINGBOTTOM
#define DISPID_IHTMLSTYLE_PADDINGLEFT                             DISPID_A_PADDINGLEFT
#define DISPID_IHTMLSTYLE_PADDING                                 DISPID_A_PADDING
#define DISPID_IHTMLSTYLE_BORDER                                  DISPID_A_BORDER
#define DISPID_IHTMLSTYLE_BORDERTOP                               DISPID_A_BORDERTOP
#define DISPID_IHTMLSTYLE_BORDERRIGHT                             DISPID_A_BORDERRIGHT
#define DISPID_IHTMLSTYLE_BORDERBOTTOM                            DISPID_A_BORDERBOTTOM
#define DISPID_IHTMLSTYLE_BORDERLEFT                              DISPID_A_BORDERLEFT
#define DISPID_IHTMLSTYLE_BORDERCOLOR                             DISPID_A_BORDERCOLOR
#define DISPID_IHTMLSTYLE_BORDERTOPCOLOR                          DISPID_A_BORDERTOPCOLOR
#define DISPID_IHTMLSTYLE_BORDERRIGHTCOLOR                        DISPID_A_BORDERRIGHTCOLOR
#define DISPID_IHTMLSTYLE_BORDERBOTTOMCOLOR                       DISPID_A_BORDERBOTTOMCOLOR
#define DISPID_IHTMLSTYLE_BORDERLEFTCOLOR                         DISPID_A_BORDERLEFTCOLOR
#define DISPID_IHTMLSTYLE_BORDERWIDTH                             DISPID_A_BORDERWIDTH
#define DISPID_IHTMLSTYLE_BORDERTOPWIDTH                          DISPID_A_BORDERTOPWIDTH
#define DISPID_IHTMLSTYLE_BORDERRIGHTWIDTH                        DISPID_A_BORDERRIGHTWIDTH
#define DISPID_IHTMLSTYLE_BORDERBOTTOMWIDTH                       DISPID_A_BORDERBOTTOMWIDTH
#define DISPID_IHTMLSTYLE_BORDERLEFTWIDTH                         DISPID_A_BORDERLEFTWIDTH
#define DISPID_IHTMLSTYLE_BORDERSTYLE                             DISPID_A_BORDERSTYLE
#define DISPID_IHTMLSTYLE_BORDERTOPSTYLE                          DISPID_A_BORDERTOPSTYLE
#define DISPID_IHTMLSTYLE_BORDERRIGHTSTYLE                        DISPID_A_BORDERRIGHTSTYLE
#define DISPID_IHTMLSTYLE_BORDERBOTTOMSTYLE                       DISPID_A_BORDERBOTTOMSTYLE
#define DISPID_IHTMLSTYLE_BORDERLEFTSTYLE                         DISPID_A_BORDERLEFTSTYLE
#define DISPID_IHTMLSTYLE_WIDTH                                   STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLSTYLE_HEIGHT                                  STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLSTYLE_STYLEFLOAT                              DISPID_A_FLOAT
#define DISPID_IHTMLSTYLE_CLEAR                                   DISPID_A_CLEAR
#define DISPID_IHTMLSTYLE_DISPLAY                                 DISPID_A_DISPLAY
#define DISPID_IHTMLSTYLE_VISIBILITY                              DISPID_A_VISIBILITY
#define DISPID_IHTMLSTYLE_LISTSTYLETYPE                           DISPID_A_LISTSTYLETYPE
#define DISPID_IHTMLSTYLE_LISTSTYLEPOSITION                       DISPID_A_LISTSTYLEPOSITION
#define DISPID_IHTMLSTYLE_LISTSTYLEIMAGE                          DISPID_A_LISTSTYLEIMAGE
#define DISPID_IHTMLSTYLE_LISTSTYLE                               DISPID_A_LISTSTYLE
#define DISPID_IHTMLSTYLE_WHITESPACE                              DISPID_A_WHITESPACE
#define DISPID_IHTMLSTYLE_TOP                                     STDPROPID_XOBJ_TOP
#define DISPID_IHTMLSTYLE_LEFT                                    STDPROPID_XOBJ_LEFT
#define DISPID_IHTMLSTYLE_POSITION                                DISPID_A_POSITION
#define DISPID_IHTMLSTYLE_ZINDEX                                  DISPID_A_ZINDEX
#define DISPID_IHTMLSTYLE_OVERFLOW                                DISPID_A_OVERFLOW
#define DISPID_IHTMLSTYLE_PAGEBREAKBEFORE                         DISPID_A_PAGEBREAKBEFORE
#define DISPID_IHTMLSTYLE_PAGEBREAKAFTER                          DISPID_A_PAGEBREAKAFTER
#define DISPID_IHTMLSTYLE_CSSTEXT                                 DISPID_A_STYLETEXT
#define DISPID_IHTMLSTYLE_PIXELTOP                                DISPID_STYLE+0
#define DISPID_IHTMLSTYLE_PIXELLEFT                               DISPID_STYLE+1
#define DISPID_IHTMLSTYLE_PIXELWIDTH                              DISPID_STYLE+2
#define DISPID_IHTMLSTYLE_PIXELHEIGHT                             DISPID_STYLE+3
#define DISPID_IHTMLSTYLE_POSTOP                                  DISPID_STYLE+4
#define DISPID_IHTMLSTYLE_POSLEFT                                 DISPID_STYLE+5
#define DISPID_IHTMLSTYLE_POSWIDTH                                DISPID_STYLE+6
#define DISPID_IHTMLSTYLE_POSHEIGHT                               DISPID_STYLE+7
#define DISPID_IHTMLSTYLE_CURSOR                                  DISPID_A_CURSOR
#define DISPID_IHTMLSTYLE_CLIP                                    DISPID_A_CLIP
#define DISPID_IHTMLSTYLE_FILTER                                  DISPID_A_FILTER
#define DISPID_IHTMLSTYLE_SETATTRIBUTE                            DISPID_HTMLOBJECT+1
#define DISPID_IHTMLSTYLE_GETATTRIBUTE                            DISPID_HTMLOBJECT+2
#define DISPID_IHTMLSTYLE_REMOVEATTRIBUTE                         DISPID_HTMLOBJECT+3
#define DISPID_IHTMLSTYLE_TOSTRING                                DISPID_STYLE+8

//    DISPIDs for interface IHTMLStyle2

#define DISPID_IHTMLSTYLE2_TABLELAYOUT                            DISPID_A_TABLELAYOUT
#define DISPID_IHTMLSTYLE2_BORDERCOLLAPSE                         DISPID_A_BORDERCOLLAPSE
#define DISPID_IHTMLSTYLE2_DIRECTION                              DISPID_A_DIRECTION
#define DISPID_IHTMLSTYLE2_BEHAVIOR                               DISPID_A_BEHAVIOR
#define DISPID_IHTMLSTYLE2_SETEXPRESSION                          DISPID_HTMLOBJECT+4
#define DISPID_IHTMLSTYLE2_GETEXPRESSION                          DISPID_HTMLOBJECT+5
#define DISPID_IHTMLSTYLE2_REMOVEEXPRESSION                       DISPID_HTMLOBJECT+6
#define DISPID_IHTMLSTYLE2_POSITION                               DISPID_A_POSITION
#define DISPID_IHTMLSTYLE2_UNICODEBIDI                            DISPID_A_UNICODEBIDI
#define DISPID_IHTMLSTYLE2_BOTTOM                                 STDPROPID_XOBJ_BOTTOM
#define DISPID_IHTMLSTYLE2_RIGHT                                  STDPROPID_XOBJ_RIGHT
#define DISPID_IHTMLSTYLE2_PIXELBOTTOM                            DISPID_STYLE+9
#define DISPID_IHTMLSTYLE2_PIXELRIGHT                             DISPID_STYLE+10
#define DISPID_IHTMLSTYLE2_POSBOTTOM                              DISPID_STYLE+11
#define DISPID_IHTMLSTYLE2_POSRIGHT                               DISPID_STYLE+12
#define DISPID_IHTMLSTYLE2_IMEMODE                                DISPID_A_IMEMODE
#define DISPID_IHTMLSTYLE2_RUBYALIGN                              DISPID_A_RUBYALIGN
#define DISPID_IHTMLSTYLE2_RUBYPOSITION                           DISPID_A_RUBYPOSITION
#define DISPID_IHTMLSTYLE2_RUBYOVERHANG                           DISPID_A_RUBYOVERHANG
#define DISPID_IHTMLSTYLE2_LAYOUTGRIDCHAR                         DISPID_A_LAYOUTGRIDCHAR
#define DISPID_IHTMLSTYLE2_LAYOUTGRIDLINE                         DISPID_A_LAYOUTGRIDLINE
#define DISPID_IHTMLSTYLE2_LAYOUTGRIDMODE                         DISPID_A_LAYOUTGRIDMODE
#define DISPID_IHTMLSTYLE2_LAYOUTGRIDTYPE                         DISPID_A_LAYOUTGRIDTYPE
#define DISPID_IHTMLSTYLE2_LAYOUTGRID                             DISPID_A_LAYOUTGRID
#define DISPID_IHTMLSTYLE2_WORDBREAK                              DISPID_A_WORDBREAK
#define DISPID_IHTMLSTYLE2_LINEBREAK                              DISPID_A_LINEBREAK
#define DISPID_IHTMLSTYLE2_TEXTJUSTIFY                            DISPID_A_TEXTJUSTIFY
#define DISPID_IHTMLSTYLE2_TEXTJUSTIFYTRIM                        DISPID_A_TEXTJUSTIFYTRIM
#define DISPID_IHTMLSTYLE2_TEXTKASHIDA                            DISPID_A_TEXTKASHIDA
#define DISPID_IHTMLSTYLE2_TEXTAUTOSPACE                          DISPID_A_TEXTAUTOSPACE
#define DISPID_IHTMLSTYLE2_OVERFLOWX                              DISPID_A_OVERFLOWX
#define DISPID_IHTMLSTYLE2_OVERFLOWY                              DISPID_A_OVERFLOWY
#define DISPID_IHTMLSTYLE2_ACCELERATOR                            DISPID_A_ACCELERATOR

//    DISPIDs for interface IHTMLStyle3

#define DISPID_IHTMLSTYLE3_LAYOUTFLOW                             DISPID_A_LAYOUTFLOW
#define DISPID_IHTMLSTYLE3_ZOOM                                   DISPID_A_ZOOM
#define DISPID_IHTMLSTYLE3_WORDWRAP                               DISPID_A_WORDWRAP
#define DISPID_IHTMLSTYLE3_TEXTUNDERLINEPOSITION                  DISPID_A_TEXTUNDERLINEPOSITION
#define DISPID_IHTMLSTYLE3_SCROLLBARBASECOLOR                     DISPID_A_SCROLLBARBASECOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARFACECOLOR                     DISPID_A_SCROLLBARFACECOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBAR3DLIGHTCOLOR                  DISPID_A_SCROLLBAR3DLIGHTCOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARSHADOWCOLOR                   DISPID_A_SCROLLBARSHADOWCOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARHIGHLIGHTCOLOR                DISPID_A_SCROLLBARHIGHLIGHTCOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARDARKSHADOWCOLOR               DISPID_A_SCROLLBARDARKSHADOWCOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARARROWCOLOR                    DISPID_A_SCROLLBARARROWCOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARTRACKCOLOR                    DISPID_A_SCROLLBARTRACKCOLOR
#define DISPID_IHTMLSTYLE3_WRITINGMODE                            DISPID_A_WRITINGMODE
#define DISPID_IHTMLSTYLE3_TEXTALIGNLAST                          DISPID_A_TEXTALIGNLAST
#define DISPID_IHTMLSTYLE3_TEXTKASHIDASPACE                       DISPID_A_TEXTKASHIDASPACE

//    DISPIDs for interface IHTMLStyle4

#define DISPID_IHTMLSTYLE4_TEXTOVERFLOW                           DISPID_A_TEXTOVERFLOW
#define DISPID_IHTMLSTYLE4_MINHEIGHT                              DISPID_A_MINHEIGHT

//    DISPIDs for interface IHTMLRuleStyle

#define DISPID_IHTMLRULESTYLE_FONTFAMILY                          DISPID_A_FONTFACE
#define DISPID_IHTMLRULESTYLE_FONTSTYLE                           DISPID_A_FONTSTYLE
#define DISPID_IHTMLRULESTYLE_FONTVARIANT                         DISPID_A_FONTVARIANT
#define DISPID_IHTMLRULESTYLE_FONTWEIGHT                          DISPID_A_FONTWEIGHT
#define DISPID_IHTMLRULESTYLE_FONTSIZE                            DISPID_A_FONTSIZE
#define DISPID_IHTMLRULESTYLE_FONT                                DISPID_A_FONT
#define DISPID_IHTMLRULESTYLE_COLOR                               DISPID_A_COLOR
#define DISPID_IHTMLRULESTYLE_BACKGROUND                          DISPID_A_BACKGROUND
#define DISPID_IHTMLRULESTYLE_BACKGROUNDCOLOR                     DISPID_BACKCOLOR
#define DISPID_IHTMLRULESTYLE_BACKGROUNDIMAGE                     DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLRULESTYLE_BACKGROUNDREPEAT                    DISPID_A_BACKGROUNDREPEAT
#define DISPID_IHTMLRULESTYLE_BACKGROUNDATTACHMENT                DISPID_A_BACKGROUNDATTACHMENT
#define DISPID_IHTMLRULESTYLE_BACKGROUNDPOSITION                  DISPID_A_BACKGROUNDPOSITION
#define DISPID_IHTMLRULESTYLE_BACKGROUNDPOSITIONX                 DISPID_A_BACKGROUNDPOSX
#define DISPID_IHTMLRULESTYLE_BACKGROUNDPOSITIONY                 DISPID_A_BACKGROUNDPOSY
#define DISPID_IHTMLRULESTYLE_WORDSPACING                         DISPID_A_WORDSPACING
#define DISPID_IHTMLRULESTYLE_LETTERSPACING                       DISPID_A_LETTERSPACING
#define DISPID_IHTMLRULESTYLE_TEXTDECORATION                      DISPID_A_TEXTDECORATION
#define DISPID_IHTMLRULESTYLE_TEXTDECORATIONNONE                  DISPID_A_TEXTDECORATIONNONE
#define DISPID_IHTMLRULESTYLE_TEXTDECORATIONUNDERLINE             DISPID_A_TEXTDECORATIONUNDERLINE
#define DISPID_IHTMLRULESTYLE_TEXTDECORATIONOVERLINE              DISPID_A_TEXTDECORATIONOVERLINE
#define DISPID_IHTMLRULESTYLE_TEXTDECORATIONLINETHROUGH           DISPID_A_TEXTDECORATIONLINETHROUGH
#define DISPID_IHTMLRULESTYLE_TEXTDECORATIONBLINK                 DISPID_A_TEXTDECORATIONBLINK
#define DISPID_IHTMLRULESTYLE_VERTICALALIGN                       DISPID_A_VERTICALALIGN
#define DISPID_IHTMLRULESTYLE_TEXTTRANSFORM                       DISPID_A_TEXTTRANSFORM
#define DISPID_IHTMLRULESTYLE_TEXTALIGN                           STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLRULESTYLE_TEXTINDENT                          DISPID_A_TEXTINDENT
#define DISPID_IHTMLRULESTYLE_LINEHEIGHT                          DISPID_A_LINEHEIGHT
#define DISPID_IHTMLRULESTYLE_MARGINTOP                           DISPID_A_MARGINTOP
#define DISPID_IHTMLRULESTYLE_MARGINRIGHT                         DISPID_A_MARGINRIGHT
#define DISPID_IHTMLRULESTYLE_MARGINBOTTOM                        DISPID_A_MARGINBOTTOM
#define DISPID_IHTMLRULESTYLE_MARGINLEFT                          DISPID_A_MARGINLEFT
#define DISPID_IHTMLRULESTYLE_MARGIN                              DISPID_A_MARGIN
#define DISPID_IHTMLRULESTYLE_PADDINGTOP                          DISPID_A_PADDINGTOP
#define DISPID_IHTMLRULESTYLE_PADDINGRIGHT                        DISPID_A_PADDINGRIGHT
#define DISPID_IHTMLRULESTYLE_PADDINGBOTTOM                       DISPID_A_PADDINGBOTTOM
#define DISPID_IHTMLRULESTYLE_PADDINGLEFT                         DISPID_A_PADDINGLEFT
#define DISPID_IHTMLRULESTYLE_PADDING                             DISPID_A_PADDING
#define DISPID_IHTMLRULESTYLE_BORDER                              DISPID_A_BORDER
#define DISPID_IHTMLRULESTYLE_BORDERTOP                           DISPID_A_BORDERTOP
#define DISPID_IHTMLRULESTYLE_BORDERRIGHT                         DISPID_A_BORDERRIGHT
#define DISPID_IHTMLRULESTYLE_BORDERBOTTOM                        DISPID_A_BORDERBOTTOM
#define DISPID_IHTMLRULESTYLE_BORDERLEFT                          DISPID_A_BORDERLEFT
#define DISPID_IHTMLRULESTYLE_BORDERCOLOR                         DISPID_A_BORDERCOLOR
#define DISPID_IHTMLRULESTYLE_BORDERTOPCOLOR                      DISPID_A_BORDERTOPCOLOR
#define DISPID_IHTMLRULESTYLE_BORDERRIGHTCOLOR                    DISPID_A_BORDERRIGHTCOLOR
#define DISPID_IHTMLRULESTYLE_BORDERBOTTOMCOLOR                   DISPID_A_BORDERBOTTOMCOLOR
#define DISPID_IHTMLRULESTYLE_BORDERLEFTCOLOR                     DISPID_A_BORDERLEFTCOLOR
#define DISPID_IHTMLRULESTYLE_BORDERWIDTH                         DISPID_A_BORDERWIDTH
#define DISPID_IHTMLRULESTYLE_BORDERTOPWIDTH                      DISPID_A_BORDERTOPWIDTH
#define DISPID_IHTMLRULESTYLE_BORDERRIGHTWIDTH                    DISPID_A_BORDERRIGHTWIDTH
#define DISPID_IHTMLRULESTYLE_BORDERBOTTOMWIDTH                   DISPID_A_BORDERBOTTOMWIDTH
#define DISPID_IHTMLRULESTYLE_BORDERLEFTWIDTH                     DISPID_A_BORDERLEFTWIDTH
#define DISPID_IHTMLRULESTYLE_BORDERSTYLE                         DISPID_A_BORDERSTYLE
#define DISPID_IHTMLRULESTYLE_BORDERTOPSTYLE                      DISPID_A_BORDERTOPSTYLE
#define DISPID_IHTMLRULESTYLE_BORDERRIGHTSTYLE                    DISPID_A_BORDERRIGHTSTYLE
#define DISPID_IHTMLRULESTYLE_BORDERBOTTOMSTYLE                   DISPID_A_BORDERBOTTOMSTYLE
#define DISPID_IHTMLRULESTYLE_BORDERLEFTSTYLE                     DISPID_A_BORDERLEFTSTYLE
#define DISPID_IHTMLRULESTYLE_WIDTH                               STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLRULESTYLE_HEIGHT                              STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLRULESTYLE_STYLEFLOAT                          DISPID_A_FLOAT
#define DISPID_IHTMLRULESTYLE_CLEAR                               DISPID_A_CLEAR
#define DISPID_IHTMLRULESTYLE_DISPLAY                             DISPID_A_DISPLAY
#define DISPID_IHTMLRULESTYLE_VISIBILITY                          DISPID_A_VISIBILITY
#define DISPID_IHTMLRULESTYLE_LISTSTYLETYPE                       DISPID_A_LISTSTYLETYPE
#define DISPID_IHTMLRULESTYLE_LISTSTYLEPOSITION                   DISPID_A_LISTSTYLEPOSITION
#define DISPID_IHTMLRULESTYLE_LISTSTYLEIMAGE                      DISPID_A_LISTSTYLEIMAGE
#define DISPID_IHTMLRULESTYLE_LISTSTYLE                           DISPID_A_LISTSTYLE
#define DISPID_IHTMLRULESTYLE_WHITESPACE                          DISPID_A_WHITESPACE
#define DISPID_IHTMLRULESTYLE_TOP                                 STDPROPID_XOBJ_TOP
#define DISPID_IHTMLRULESTYLE_LEFT                                STDPROPID_XOBJ_LEFT
#define DISPID_IHTMLRULESTYLE_POSITION                            DISPID_A_POSITION
#define DISPID_IHTMLRULESTYLE_ZINDEX                              DISPID_A_ZINDEX
#define DISPID_IHTMLRULESTYLE_OVERFLOW                            DISPID_A_OVERFLOW
#define DISPID_IHTMLRULESTYLE_PAGEBREAKBEFORE                     DISPID_A_PAGEBREAKBEFORE
#define DISPID_IHTMLRULESTYLE_PAGEBREAKAFTER                      DISPID_A_PAGEBREAKAFTER
#define DISPID_IHTMLRULESTYLE_CSSTEXT                             DISPID_A_STYLETEXT
#define DISPID_IHTMLRULESTYLE_CURSOR                              DISPID_A_CURSOR
#define DISPID_IHTMLRULESTYLE_CLIP                                DISPID_A_CLIP
#define DISPID_IHTMLRULESTYLE_FILTER                              DISPID_A_FILTER
#define DISPID_IHTMLRULESTYLE_SETATTRIBUTE                        DISPID_HTMLOBJECT+1
#define DISPID_IHTMLRULESTYLE_GETATTRIBUTE                        DISPID_HTMLOBJECT+2
#define DISPID_IHTMLRULESTYLE_REMOVEATTRIBUTE                     DISPID_HTMLOBJECT+3

//    DISPIDs for interface IHTMLRuleStyle2

#define DISPID_IHTMLRULESTYLE2_TABLELAYOUT                        DISPID_A_TABLELAYOUT
#define DISPID_IHTMLRULESTYLE2_BORDERCOLLAPSE                     DISPID_A_BORDERCOLLAPSE
#define DISPID_IHTMLRULESTYLE2_DIRECTION                          DISPID_A_DIRECTION
#define DISPID_IHTMLRULESTYLE2_BEHAVIOR                           DISPID_A_BEHAVIOR
#define DISPID_IHTMLRULESTYLE2_POSITION                           DISPID_A_POSITION
#define DISPID_IHTMLRULESTYLE2_UNICODEBIDI                        DISPID_A_UNICODEBIDI
#define DISPID_IHTMLRULESTYLE2_BOTTOM                             STDPROPID_XOBJ_BOTTOM
#define DISPID_IHTMLRULESTYLE2_RIGHT                              STDPROPID_XOBJ_RIGHT
#define DISPID_IHTMLRULESTYLE2_PIXELBOTTOM                        DISPID_STYLE+9
#define DISPID_IHTMLRULESTYLE2_PIXELRIGHT                         DISPID_STYLE+10
#define DISPID_IHTMLRULESTYLE2_POSBOTTOM                          DISPID_STYLE+11
#define DISPID_IHTMLRULESTYLE2_POSRIGHT                           DISPID_STYLE+12
#define DISPID_IHTMLRULESTYLE2_IMEMODE                            DISPID_A_IMEMODE
#define DISPID_IHTMLRULESTYLE2_RUBYALIGN                          DISPID_A_RUBYALIGN
#define DISPID_IHTMLRULESTYLE2_RUBYPOSITION                       DISPID_A_RUBYPOSITION
#define DISPID_IHTMLRULESTYLE2_RUBYOVERHANG                       DISPID_A_RUBYOVERHANG
#define DISPID_IHTMLRULESTYLE2_LAYOUTGRIDCHAR                     DISPID_A_LAYOUTGRIDCHAR
#define DISPID_IHTMLRULESTYLE2_LAYOUTGRIDLINE                     DISPID_A_LAYOUTGRIDLINE
#define DISPID_IHTMLRULESTYLE2_LAYOUTGRIDMODE                     DISPID_A_LAYOUTGRIDMODE
#define DISPID_IHTMLRULESTYLE2_LAYOUTGRIDTYPE                     DISPID_A_LAYOUTGRIDTYPE
#define DISPID_IHTMLRULESTYLE2_LAYOUTGRID                         DISPID_A_LAYOUTGRID
#define DISPID_IHTMLRULESTYLE2_TEXTAUTOSPACE                      DISPID_A_TEXTAUTOSPACE
#define DISPID_IHTMLRULESTYLE2_WORDBREAK                          DISPID_A_WORDBREAK
#define DISPID_IHTMLRULESTYLE2_LINEBREAK                          DISPID_A_LINEBREAK
#define DISPID_IHTMLRULESTYLE2_TEXTJUSTIFY                        DISPID_A_TEXTJUSTIFY
#define DISPID_IHTMLRULESTYLE2_TEXTJUSTIFYTRIM                    DISPID_A_TEXTJUSTIFYTRIM
#define DISPID_IHTMLRULESTYLE2_TEXTKASHIDA                        DISPID_A_TEXTKASHIDA
#define DISPID_IHTMLRULESTYLE2_OVERFLOWX                          DISPID_A_OVERFLOWX
#define DISPID_IHTMLRULESTYLE2_OVERFLOWY                          DISPID_A_OVERFLOWY
#define DISPID_IHTMLRULESTYLE2_ACCELERATOR                        DISPID_A_ACCELERATOR

//    DISPIDs for interface IHTMLRuleStyle3

#define DISPID_IHTMLRULESTYLE3_LAYOUTFLOW                         DISPID_A_LAYOUTFLOW
#define DISPID_IHTMLRULESTYLE3_ZOOM                               DISPID_A_ZOOM
#define DISPID_IHTMLRULESTYLE3_WORDWRAP                           DISPID_A_WORDWRAP
#define DISPID_IHTMLRULESTYLE3_TEXTUNDERLINEPOSITION              DISPID_A_TEXTUNDERLINEPOSITION
#define DISPID_IHTMLRULESTYLE3_SCROLLBARBASECOLOR                 DISPID_A_SCROLLBARBASECOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARFACECOLOR                 DISPID_A_SCROLLBARFACECOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBAR3DLIGHTCOLOR              DISPID_A_SCROLLBAR3DLIGHTCOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARSHADOWCOLOR               DISPID_A_SCROLLBARSHADOWCOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARHIGHLIGHTCOLOR            DISPID_A_SCROLLBARHIGHLIGHTCOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARDARKSHADOWCOLOR           DISPID_A_SCROLLBARDARKSHADOWCOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARARROWCOLOR                DISPID_A_SCROLLBARARROWCOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARTRACKCOLOR                DISPID_A_SCROLLBARTRACKCOLOR
#define DISPID_IHTMLRULESTYLE3_WRITINGMODE                        DISPID_A_WRITINGMODE
#define DISPID_IHTMLRULESTYLE3_TEXTALIGNLAST                      DISPID_A_TEXTALIGNLAST
#define DISPID_IHTMLRULESTYLE3_TEXTKASHIDASPACE                   DISPID_A_TEXTKASHIDASPACE

//    DISPIDs for interface IHTMLRuleStyle4

#define DISPID_IHTMLRULESTYLE4_TEXTOVERFLOW                       DISPID_A_TEXTOVERFLOW
#define DISPID_IHTMLRULESTYLE4_MINHEIGHT                          DISPID_A_MINHEIGHT

//    DISPIDs for interface IHTMLRenderStyle

#define DISPID_IHTMLRENDERSTYLE_TEXTLINETHROUGHSTYLE              DISPID_A_TEXTLINETHROUGHSTYLE
#define DISPID_IHTMLRENDERSTYLE_TEXTUNDERLINESTYLE                DISPID_A_TEXTUNDERLINESTYLE
#define DISPID_IHTMLRENDERSTYLE_TEXTEFFECT                        DISPID_A_TEXTEFFECT
#define DISPID_IHTMLRENDERSTYLE_TEXTCOLOR                         DISPID_A_TEXTCOLOR
#define DISPID_IHTMLRENDERSTYLE_TEXTBACKGROUNDCOLOR               DISPID_A_TEXTBACKGROUNDCOLOR
#define DISPID_IHTMLRENDERSTYLE_TEXTDECORATIONCOLOR               DISPID_A_TEXTDECORATIONCOLOR
#define DISPID_IHTMLRENDERSTYLE_RENDERINGPRIORITY                 DISPID_A_RENDERINGPRIORITY
#define DISPID_IHTMLRENDERSTYLE_DEFAULTTEXTSELECTION              DISPID_A_DEFAULTTEXTSELECTION
#define DISPID_IHTMLRENDERSTYLE_TEXTDECORATION                    DISPID_A_STYLETEXTDECORATION

//    DISPIDs for interface IHTMLCurrentStyle

#define DISPID_IHTMLCURRENTSTYLE_POSITION                         DISPID_A_POSITION
#define DISPID_IHTMLCURRENTSTYLE_STYLEFLOAT                       DISPID_A_FLOAT
#define DISPID_IHTMLCURRENTSTYLE_COLOR                            DISPID_A_COLOR
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDCOLOR                  DISPID_BACKCOLOR
#define DISPID_IHTMLCURRENTSTYLE_FONTFAMILY                       DISPID_A_FONTFACE
#define DISPID_IHTMLCURRENTSTYLE_FONTSTYLE                        DISPID_A_FONTSTYLE
#define DISPID_IHTMLCURRENTSTYLE_FONTVARIANT                      DISPID_A_FONTVARIANT
#define DISPID_IHTMLCURRENTSTYLE_FONTWEIGHT                       DISPID_A_FONTWEIGHT
#define DISPID_IHTMLCURRENTSTYLE_FONTSIZE                         DISPID_A_FONTSIZE
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDIMAGE                  DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDPOSITIONX              DISPID_A_BACKGROUNDPOSX
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDPOSITIONY              DISPID_A_BACKGROUNDPOSY
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDREPEAT                 DISPID_A_BACKGROUNDREPEAT
#define DISPID_IHTMLCURRENTSTYLE_BORDERLEFTCOLOR                  DISPID_A_BORDERLEFTCOLOR
#define DISPID_IHTMLCURRENTSTYLE_BORDERTOPCOLOR                   DISPID_A_BORDERTOPCOLOR
#define DISPID_IHTMLCURRENTSTYLE_BORDERRIGHTCOLOR                 DISPID_A_BORDERRIGHTCOLOR
#define DISPID_IHTMLCURRENTSTYLE_BORDERBOTTOMCOLOR                DISPID_A_BORDERBOTTOMCOLOR
#define DISPID_IHTMLCURRENTSTYLE_BORDERTOPSTYLE                   DISPID_A_BORDERTOPSTYLE
#define DISPID_IHTMLCURRENTSTYLE_BORDERRIGHTSTYLE                 DISPID_A_BORDERRIGHTSTYLE
#define DISPID_IHTMLCURRENTSTYLE_BORDERBOTTOMSTYLE                DISPID_A_BORDERBOTTOMSTYLE
#define DISPID_IHTMLCURRENTSTYLE_BORDERLEFTSTYLE                  DISPID_A_BORDERLEFTSTYLE
#define DISPID_IHTMLCURRENTSTYLE_BORDERTOPWIDTH                   DISPID_A_BORDERTOPWIDTH
#define DISPID_IHTMLCURRENTSTYLE_BORDERRIGHTWIDTH                 DISPID_A_BORDERRIGHTWIDTH
#define DISPID_IHTMLCURRENTSTYLE_BORDERBOTTOMWIDTH                DISPID_A_BORDERBOTTOMWIDTH
#define DISPID_IHTMLCURRENTSTYLE_BORDERLEFTWIDTH                  DISPID_A_BORDERLEFTWIDTH
#define DISPID_IHTMLCURRENTSTYLE_LEFT                             STDPROPID_XOBJ_LEFT
#define DISPID_IHTMLCURRENTSTYLE_TOP                              STDPROPID_XOBJ_TOP
#define DISPID_IHTMLCURRENTSTYLE_WIDTH                            STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLCURRENTSTYLE_HEIGHT                           STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLCURRENTSTYLE_PADDINGLEFT                      DISPID_A_PADDINGLEFT
#define DISPID_IHTMLCURRENTSTYLE_PADDINGTOP                       DISPID_A_PADDINGTOP
#define DISPID_IHTMLCURRENTSTYLE_PADDINGRIGHT                     DISPID_A_PADDINGRIGHT
#define DISPID_IHTMLCURRENTSTYLE_PADDINGBOTTOM                    DISPID_A_PADDINGBOTTOM
#define DISPID_IHTMLCURRENTSTYLE_TEXTALIGN                        STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLCURRENTSTYLE_TEXTDECORATION                   DISPID_A_TEXTDECORATION
#define DISPID_IHTMLCURRENTSTYLE_DISPLAY                          DISPID_A_DISPLAY
#define DISPID_IHTMLCURRENTSTYLE_VISIBILITY                       DISPID_A_VISIBILITY
#define DISPID_IHTMLCURRENTSTYLE_ZINDEX                           DISPID_A_ZINDEX
#define DISPID_IHTMLCURRENTSTYLE_LETTERSPACING                    DISPID_A_LETTERSPACING
#define DISPID_IHTMLCURRENTSTYLE_LINEHEIGHT                       DISPID_A_LINEHEIGHT
#define DISPID_IHTMLCURRENTSTYLE_TEXTINDENT                       DISPID_A_TEXTINDENT
#define DISPID_IHTMLCURRENTSTYLE_VERTICALALIGN                    DISPID_A_VERTICALALIGN
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDATTACHMENT             DISPID_A_BACKGROUNDATTACHMENT
#define DISPID_IHTMLCURRENTSTYLE_MARGINTOP                        DISPID_A_MARGINTOP
#define DISPID_IHTMLCURRENTSTYLE_MARGINRIGHT                      DISPID_A_MARGINRIGHT
#define DISPID_IHTMLCURRENTSTYLE_MARGINBOTTOM                     DISPID_A_MARGINBOTTOM
#define DISPID_IHTMLCURRENTSTYLE_MARGINLEFT                       DISPID_A_MARGINLEFT
#define DISPID_IHTMLCURRENTSTYLE_CLEAR                            DISPID_A_CLEAR
#define DISPID_IHTMLCURRENTSTYLE_LISTSTYLETYPE                    DISPID_A_LISTSTYLETYPE
#define DISPID_IHTMLCURRENTSTYLE_LISTSTYLEPOSITION                DISPID_A_LISTSTYLEPOSITION
#define DISPID_IHTMLCURRENTSTYLE_LISTSTYLEIMAGE                   DISPID_A_LISTSTYLEIMAGE
#define DISPID_IHTMLCURRENTSTYLE_CLIPTOP                          DISPID_A_CLIPRECTTOP
#define DISPID_IHTMLCURRENTSTYLE_CLIPRIGHT                        DISPID_A_CLIPRECTRIGHT
#define DISPID_IHTMLCURRENTSTYLE_CLIPBOTTOM                       DISPID_A_CLIPRECTBOTTOM
#define DISPID_IHTMLCURRENTSTYLE_CLIPLEFT                         DISPID_A_CLIPRECTLEFT
#define DISPID_IHTMLCURRENTSTYLE_OVERFLOW                         DISPID_A_OVERFLOW
#define DISPID_IHTMLCURRENTSTYLE_PAGEBREAKBEFORE                  DISPID_A_PAGEBREAKBEFORE
#define DISPID_IHTMLCURRENTSTYLE_PAGEBREAKAFTER                   DISPID_A_PAGEBREAKAFTER
#define DISPID_IHTMLCURRENTSTYLE_CURSOR                           DISPID_A_CURSOR
#define DISPID_IHTMLCURRENTSTYLE_TABLELAYOUT                      DISPID_A_TABLELAYOUT
#define DISPID_IHTMLCURRENTSTYLE_BORDERCOLLAPSE                   DISPID_A_BORDERCOLLAPSE
#define DISPID_IHTMLCURRENTSTYLE_DIRECTION                        DISPID_A_DIRECTION
#define DISPID_IHTMLCURRENTSTYLE_BEHAVIOR                         DISPID_A_BEHAVIOR
#define DISPID_IHTMLCURRENTSTYLE_GETATTRIBUTE                     DISPID_HTMLOBJECT+2
#define DISPID_IHTMLCURRENTSTYLE_UNICODEBIDI                      DISPID_A_UNICODEBIDI
#define DISPID_IHTMLCURRENTSTYLE_RIGHT                            STDPROPID_XOBJ_RIGHT
#define DISPID_IHTMLCURRENTSTYLE_BOTTOM                           STDPROPID_XOBJ_BOTTOM
#define DISPID_IHTMLCURRENTSTYLE_IMEMODE                          DISPID_A_IMEMODE
#define DISPID_IHTMLCURRENTSTYLE_RUBYALIGN                        DISPID_A_RUBYALIGN
#define DISPID_IHTMLCURRENTSTYLE_RUBYPOSITION                     DISPID_A_RUBYPOSITION
#define DISPID_IHTMLCURRENTSTYLE_RUBYOVERHANG                     DISPID_A_RUBYOVERHANG
#define DISPID_IHTMLCURRENTSTYLE_TEXTAUTOSPACE                    DISPID_A_TEXTAUTOSPACE
#define DISPID_IHTMLCURRENTSTYLE_LINEBREAK                        DISPID_A_LINEBREAK
#define DISPID_IHTMLCURRENTSTYLE_WORDBREAK                        DISPID_A_WORDBREAK
#define DISPID_IHTMLCURRENTSTYLE_TEXTJUSTIFY                      DISPID_A_TEXTJUSTIFY
#define DISPID_IHTMLCURRENTSTYLE_TEXTJUSTIFYTRIM                  DISPID_A_TEXTJUSTIFYTRIM
#define DISPID_IHTMLCURRENTSTYLE_TEXTKASHIDA                      DISPID_A_TEXTKASHIDA
#define DISPID_IHTMLCURRENTSTYLE_BLOCKDIRECTION                   DISPID_A_DIR
#define DISPID_IHTMLCURRENTSTYLE_LAYOUTGRIDCHAR                   DISPID_A_LAYOUTGRIDCHAR
#define DISPID_IHTMLCURRENTSTYLE_LAYOUTGRIDLINE                   DISPID_A_LAYOUTGRIDLINE
#define DISPID_IHTMLCURRENTSTYLE_LAYOUTGRIDMODE                   DISPID_A_LAYOUTGRIDMODE
#define DISPID_IHTMLCURRENTSTYLE_LAYOUTGRIDTYPE                   DISPID_A_LAYOUTGRIDTYPE
#define DISPID_IHTMLCURRENTSTYLE_BORDERSTYLE                      DISPID_A_BORDERSTYLE
#define DISPID_IHTMLCURRENTSTYLE_BORDERCOLOR                      DISPID_A_BORDERCOLOR
#define DISPID_IHTMLCURRENTSTYLE_BORDERWIDTH                      DISPID_A_BORDERWIDTH
#define DISPID_IHTMLCURRENTSTYLE_PADDING                          DISPID_A_PADDING
#define DISPID_IHTMLCURRENTSTYLE_MARGIN                           DISPID_A_MARGIN
#define DISPID_IHTMLCURRENTSTYLE_ACCELERATOR                      DISPID_A_ACCELERATOR
#define DISPID_IHTMLCURRENTSTYLE_OVERFLOWX                        DISPID_A_OVERFLOWX
#define DISPID_IHTMLCURRENTSTYLE_OVERFLOWY                        DISPID_A_OVERFLOWY
#define DISPID_IHTMLCURRENTSTYLE_TEXTTRANSFORM                    DISPID_A_TEXTTRANSFORM

//    DISPIDs for interface IHTMLCurrentStyle2

#define DISPID_IHTMLCURRENTSTYLE2_LAYOUTFLOW                      DISPID_A_LAYOUTFLOW
#define DISPID_IHTMLCURRENTSTYLE2_WORDWRAP                        DISPID_A_WORDWRAP
#define DISPID_IHTMLCURRENTSTYLE2_TEXTUNDERLINEPOSITION           DISPID_A_TEXTUNDERLINEPOSITION
#define DISPID_IHTMLCURRENTSTYLE2_HASLAYOUT                       DISPID_A_HASLAYOUT
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARBASECOLOR              DISPID_A_SCROLLBARBASECOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARFACECOLOR              DISPID_A_SCROLLBARFACECOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBAR3DLIGHTCOLOR           DISPID_A_SCROLLBAR3DLIGHTCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARSHADOWCOLOR            DISPID_A_SCROLLBARSHADOWCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARHIGHLIGHTCOLOR         DISPID_A_SCROLLBARHIGHLIGHTCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARDARKSHADOWCOLOR        DISPID_A_SCROLLBARDARKSHADOWCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARARROWCOLOR             DISPID_A_SCROLLBARARROWCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARTRACKCOLOR             DISPID_A_SCROLLBARTRACKCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_WRITINGMODE                     DISPID_A_WRITINGMODE
#define DISPID_IHTMLCURRENTSTYLE2_ZOOM                            DISPID_A_ZOOM
#define DISPID_IHTMLCURRENTSTYLE2_FILTER                          DISPID_A_FILTER
#define DISPID_IHTMLCURRENTSTYLE2_TEXTALIGNLAST                   DISPID_A_TEXTALIGNLAST
#define DISPID_IHTMLCURRENTSTYLE2_TEXTKASHIDASPACE                DISPID_A_TEXTKASHIDASPACE
#define DISPID_IHTMLCURRENTSTYLE2_ISBLOCK                         DISPID_A_ISBLOCK

//    DISPIDs for interface IHTMLCurrentStyle3

#define DISPID_IHTMLCURRENTSTYLE3_TEXTOVERFLOW                    DISPID_A_TEXTOVERFLOW
#define DISPID_IHTMLCURRENTSTYLE3_MINHEIGHT                       DISPID_A_MINHEIGHT
#define DISPID_IHTMLCURRENTSTYLE3_WORDSPACING                     DISPID_A_WORDSPACING
#define DISPID_IHTMLCURRENTSTYLE3_WHITESPACE                      DISPID_A_WHITESPACE

//    DISPIDs for interface IHTMLRect

#define DISPID_IHTMLRECT_LEFT                                     DISPID_OMRECT+1
#define DISPID_IHTMLRECT_TOP                                      DISPID_OMRECT+2
#define DISPID_IHTMLRECT_RIGHT                                    DISPID_OMRECT+3
#define DISPID_IHTMLRECT_BOTTOM                                   DISPID_OMRECT+4

//    DISPIDs for interface IHTMLRectCollection

#define DISPID_IHTMLRECTCOLLECTION_LENGTH                         DISPID_COLLECTION
#define DISPID_IHTMLRECTCOLLECTION__NEWENUM                       DISPID_NEWENUM
#define DISPID_IHTMLRECTCOLLECTION_ITEM                           DISPID_VALUE

//    DISPIDs for interface IHTMLDOMNode

#define DISPID_IHTMLDOMNODE_NODETYPE                              DISPID_ELEMENT+46
#define DISPID_IHTMLDOMNODE_PARENTNODE                            DISPID_ELEMENT+47
#define DISPID_IHTMLDOMNODE_HASCHILDNODES                         DISPID_ELEMENT+48
#define DISPID_IHTMLDOMNODE_CHILDNODES                            DISPID_ELEMENT+49
#define DISPID_IHTMLDOMNODE_ATTRIBUTES                            DISPID_ELEMENT+50
#define DISPID_IHTMLDOMNODE_INSERTBEFORE                          DISPID_ELEMENT+51
#define DISPID_IHTMLDOMNODE_REMOVECHILD                           DISPID_ELEMENT+52
#define DISPID_IHTMLDOMNODE_REPLACECHILD                          DISPID_ELEMENT+53
#define DISPID_IHTMLDOMNODE_CLONENODE                             DISPID_ELEMENT+61
#define DISPID_IHTMLDOMNODE_REMOVENODE                            DISPID_ELEMENT+66
#define DISPID_IHTMLDOMNODE_SWAPNODE                              DISPID_ELEMENT+68
#define DISPID_IHTMLDOMNODE_REPLACENODE                           DISPID_ELEMENT+67
#define DISPID_IHTMLDOMNODE_APPENDCHILD                           DISPID_ELEMENT+73
#define DISPID_IHTMLDOMNODE_NODENAME                              DISPID_ELEMENT+74
#define DISPID_IHTMLDOMNODE_NODEVALUE                             DISPID_ELEMENT+75
#define DISPID_IHTMLDOMNODE_FIRSTCHILD                            DISPID_ELEMENT+76
#define DISPID_IHTMLDOMNODE_LASTCHILD                             DISPID_ELEMENT+77
#define DISPID_IHTMLDOMNODE_PREVIOUSSIBLING                       DISPID_ELEMENT+78
#define DISPID_IHTMLDOMNODE_NEXTSIBLING                           DISPID_ELEMENT+79

//    DISPIDs for interface IHTMLDOMNode2

#define DISPID_IHTMLDOMNODE2_OWNERDOCUMENT                        DISPID_ELEMENT+113

//    DISPIDs for interface IHTMLDOMAttribute

#define DISPID_IHTMLDOMATTRIBUTE_NODENAME                         DISPID_DOMATTRIBUTE
#define DISPID_IHTMLDOMATTRIBUTE_NODEVALUE                        DISPID_DOMATTRIBUTE+2
#define DISPID_IHTMLDOMATTRIBUTE_SPECIFIED                        DISPID_DOMATTRIBUTE+1

//    DISPIDs for interface IHTMLDOMAttribute2

#define DISPID_IHTMLDOMATTRIBUTE2_NAME                            DISPID_DOMATTRIBUTE+3
#define DISPID_IHTMLDOMATTRIBUTE2_VALUE                           DISPID_DOMATTRIBUTE+4
#define DISPID_IHTMLDOMATTRIBUTE2_EXPANDO                         DISPID_DOMATTRIBUTE+5
#define DISPID_IHTMLDOMATTRIBUTE2_NODETYPE                        DISPID_DOMATTRIBUTE+6
#define DISPID_IHTMLDOMATTRIBUTE2_PARENTNODE                      DISPID_DOMATTRIBUTE+7
#define DISPID_IHTMLDOMATTRIBUTE2_CHILDNODES                      DISPID_DOMATTRIBUTE+8
#define DISPID_IHTMLDOMATTRIBUTE2_FIRSTCHILD                      DISPID_DOMATTRIBUTE+9
#define DISPID_IHTMLDOMATTRIBUTE2_LASTCHILD                       DISPID_DOMATTRIBUTE+10
#define DISPID_IHTMLDOMATTRIBUTE2_PREVIOUSSIBLING                 DISPID_DOMATTRIBUTE+11
#define DISPID_IHTMLDOMATTRIBUTE2_NEXTSIBLING                     DISPID_DOMATTRIBUTE+12
#define DISPID_IHTMLDOMATTRIBUTE2_ATTRIBUTES                      DISPID_DOMATTRIBUTE+13
#define DISPID_IHTMLDOMATTRIBUTE2_OWNERDOCUMENT                   DISPID_DOMATTRIBUTE+14
#define DISPID_IHTMLDOMATTRIBUTE2_INSERTBEFORE                    DISPID_DOMATTRIBUTE+15
#define DISPID_IHTMLDOMATTRIBUTE2_REPLACECHILD                    DISPID_DOMATTRIBUTE+16
#define DISPID_IHTMLDOMATTRIBUTE2_REMOVECHILD                     DISPID_DOMATTRIBUTE+17
#define DISPID_IHTMLDOMATTRIBUTE2_APPENDCHILD                     DISPID_DOMATTRIBUTE+18
#define DISPID_IHTMLDOMATTRIBUTE2_HASCHILDNODES                   DISPID_DOMATTRIBUTE+19
#define DISPID_IHTMLDOMATTRIBUTE2_CLONENODE                       DISPID_DOMATTRIBUTE+20

//    DISPIDs for interface IHTMLDOMTextNode

#define DISPID_IHTMLDOMTEXTNODE_DATA                              DISPID_DOMTEXTNODE
#define DISPID_IHTMLDOMTEXTNODE_TOSTRING                          DISPID_DOMTEXTNODE+1
#define DISPID_IHTMLDOMTEXTNODE_LENGTH                            DISPID_DOMTEXTNODE+2
#define DISPID_IHTMLDOMTEXTNODE_SPLITTEXT                         DISPID_DOMTEXTNODE+3

//    DISPIDs for interface IHTMLDOMTextNode2

#define DISPID_IHTMLDOMTEXTNODE2_SUBSTRINGDATA                    DISPID_DOMTEXTNODE+4
#define DISPID_IHTMLDOMTEXTNODE2_APPENDDATA                       DISPID_DOMTEXTNODE+5
#define DISPID_IHTMLDOMTEXTNODE2_INSERTDATA                       DISPID_DOMTEXTNODE+6
#define DISPID_IHTMLDOMTEXTNODE2_DELETEDATA                       DISPID_DOMTEXTNODE+7
#define DISPID_IHTMLDOMTEXTNODE2_REPLACEDATA                      DISPID_DOMTEXTNODE+8

//    DISPIDs for interface IHTMLDOMImplementation

#define DISPID_IHTMLDOMIMPLEMENTATION_HASFEATURE                  DISPID_DOMIMPLEMENTATION

//    DISPIDs for interface IHTMLAttributeCollection

#define DISPID_IHTMLATTRIBUTECOLLECTION_LENGTH                    DISPID_COLLECTION
#define DISPID_IHTMLATTRIBUTECOLLECTION__NEWENUM                  DISPID_NEWENUM
#define DISPID_IHTMLATTRIBUTECOLLECTION_ITEM                      DISPID_VALUE

//    DISPIDs for interface IHTMLAttributeCollection2

#define DISPID_IHTMLATTRIBUTECOLLECTION2_GETNAMEDITEM             DISPID_COLLECTION+1
#define DISPID_IHTMLATTRIBUTECOLLECTION2_SETNAMEDITEM             DISPID_COLLECTION+2
#define DISPID_IHTMLATTRIBUTECOLLECTION2_REMOVENAMEDITEM          DISPID_COLLECTION+3

//    DISPIDs for interface IHTMLDOMChildrenCollection

#define DISPID_IHTMLDOMCHILDRENCOLLECTION_LENGTH                  DISPID_COLLECTION
#define DISPID_IHTMLDOMCHILDRENCOLLECTION__NEWENUM                DISPID_NEWENUM
#define DISPID_IHTMLDOMCHILDRENCOLLECTION_ITEM                    DISPID_VALUE

//    DISPIDs for interface IHTMLElement

#define DISPID_IHTMLELEMENT_SETATTRIBUTE                          DISPID_HTMLOBJECT+1
#define DISPID_IHTMLELEMENT_GETATTRIBUTE                          DISPID_HTMLOBJECT+2
#define DISPID_IHTMLELEMENT_REMOVEATTRIBUTE                       DISPID_HTMLOBJECT+3
#define DISPID_IHTMLELEMENT_CLASSNAME                             DISPID_ELEMENT+1
#define DISPID_IHTMLELEMENT_ID                                    DISPID_ELEMENT+2
#define DISPID_IHTMLELEMENT_TAGNAME                               DISPID_ELEMENT+4
#define DISPID_IHTMLELEMENT_PARENTELEMENT                         STDPROPID_XOBJ_PARENT
#define DISPID_IHTMLELEMENT_STYLE                                 STDPROPID_XOBJ_STYLE
#define DISPID_IHTMLELEMENT_ONHELP                                DISPID_EVPROP_ONHELP
#define DISPID_IHTMLELEMENT_ONCLICK                               DISPID_EVPROP_ONCLICK
#define DISPID_IHTMLELEMENT_ONDBLCLICK                            DISPID_EVPROP_ONDBLCLICK
#define DISPID_IHTMLELEMENT_ONKEYDOWN                             DISPID_EVPROP_ONKEYDOWN
#define DISPID_IHTMLELEMENT_ONKEYUP                               DISPID_EVPROP_ONKEYUP
#define DISPID_IHTMLELEMENT_ONKEYPRESS                            DISPID_EVPROP_ONKEYPRESS
#define DISPID_IHTMLELEMENT_ONMOUSEOUT                            DISPID_EVPROP_ONMOUSEOUT
#define DISPID_IHTMLELEMENT_ONMOUSEOVER                           DISPID_EVPROP_ONMOUSEOVER
#define DISPID_IHTMLELEMENT_ONMOUSEMOVE                           DISPID_EVPROP_ONMOUSEMOVE
#define DISPID_IHTMLELEMENT_ONMOUSEDOWN                           DISPID_EVPROP_ONMOUSEDOWN
#define DISPID_IHTMLELEMENT_ONMOUSEUP                             DISPID_EVPROP_ONMOUSEUP
#define DISPID_IHTMLELEMENT_DOCUMENT                              DISPID_ELEMENT+18
#define DISPID_IHTMLELEMENT_TITLE                                 STDPROPID_XOBJ_CONTROLTIPTEXT
#define DISPID_IHTMLELEMENT_LANGUAGE                              DISPID_A_LANGUAGE
#define DISPID_IHTMLELEMENT_ONSELECTSTART                         DISPID_EVPROP_ONSELECTSTART
#define DISPID_IHTMLELEMENT_SCROLLINTOVIEW                        DISPID_ELEMENT+19
#define DISPID_IHTMLELEMENT_CONTAINS                              DISPID_ELEMENT+20
#define DISPID_IHTMLELEMENT_SOURCEINDEX                           DISPID_ELEMENT+24
#define DISPID_IHTMLELEMENT_RECORDNUMBER                          DISPID_ELEMENT+25
#define DISPID_IHTMLELEMENT_LANG                                  DISPID_A_LANG
#define DISPID_IHTMLELEMENT_OFFSETLEFT                            DISPID_ELEMENT+8
#define DISPID_IHTMLELEMENT_OFFSETTOP                             DISPID_ELEMENT+9
#define DISPID_IHTMLELEMENT_OFFSETWIDTH                           DISPID_ELEMENT+10
#define DISPID_IHTMLELEMENT_OFFSETHEIGHT                          DISPID_ELEMENT+11
#define DISPID_IHTMLELEMENT_OFFSETPARENT                          DISPID_ELEMENT+12
#define DISPID_IHTMLELEMENT_INNERHTML                             DISPID_ELEMENT+26
#define DISPID_IHTMLELEMENT_INNERTEXT                             DISPID_ELEMENT+27
#define DISPID_IHTMLELEMENT_OUTERHTML                             DISPID_ELEMENT+28
#define DISPID_IHTMLELEMENT_OUTERTEXT                             DISPID_ELEMENT+29
#define DISPID_IHTMLELEMENT_INSERTADJACENTHTML                    DISPID_ELEMENT+30
#define DISPID_IHTMLELEMENT_INSERTADJACENTTEXT                    DISPID_ELEMENT+31
#define DISPID_IHTMLELEMENT_PARENTTEXTEDIT                        DISPID_ELEMENT+32
#define DISPID_IHTMLELEMENT_ISTEXTEDIT                            DISPID_ELEMENT+34
#define DISPID_IHTMLELEMENT_CLICK                                 DISPID_ELEMENT+33
#define DISPID_IHTMLELEMENT_FILTERS                               DISPID_ELEMENT+35
#define DISPID_IHTMLELEMENT_ONDRAGSTART                           DISPID_EVPROP_ONDRAGSTART
#define DISPID_IHTMLELEMENT_TOSTRING                              DISPID_ELEMENT+36
#define DISPID_IHTMLELEMENT_ONBEFOREUPDATE                        DISPID_EVPROP_ONBEFOREUPDATE
#define DISPID_IHTMLELEMENT_ONAFTERUPDATE                         DISPID_EVPROP_ONAFTERUPDATE
#define DISPID_IHTMLELEMENT_ONERRORUPDATE                         DISPID_EVPROP_ONERRORUPDATE
#define DISPID_IHTMLELEMENT_ONROWEXIT                             DISPID_EVPROP_ONROWEXIT
#define DISPID_IHTMLELEMENT_ONROWENTER                            DISPID_EVPROP_ONROWENTER
#define DISPID_IHTMLELEMENT_ONDATASETCHANGED                      DISPID_EVPROP_ONDATASETCHANGED
#define DISPID_IHTMLELEMENT_ONDATAAVAILABLE                       DISPID_EVPROP_ONDATAAVAILABLE
#define DISPID_IHTMLELEMENT_ONDATASETCOMPLETE                     DISPID_EVPROP_ONDATASETCOMPLETE
#define DISPID_IHTMLELEMENT_ONFILTERCHANGE                        DISPID_EVPROP_ONFILTER
#define DISPID_IHTMLELEMENT_CHILDREN                              DISPID_ELEMENT+37
#define DISPID_IHTMLELEMENT_ALL                                   DISPID_ELEMENT+38

//    DISPIDs for interface IHTMLElement2

#define DISPID_IHTMLELEMENT2_SCOPENAME                            DISPID_ELEMENT+39
#define DISPID_IHTMLELEMENT2_SETCAPTURE                           DISPID_ELEMENT+40
#define DISPID_IHTMLELEMENT2_RELEASECAPTURE                       DISPID_ELEMENT+41
#define DISPID_IHTMLELEMENT2_ONLOSECAPTURE                        DISPID_EVPROP_ONLOSECAPTURE
#define DISPID_IHTMLELEMENT2_COMPONENTFROMPOINT                   DISPID_ELEMENT+42
#define DISPID_IHTMLELEMENT2_DOSCROLL                             DISPID_ELEMENT+43
#define DISPID_IHTMLELEMENT2_ONSCROLL                             DISPID_EVPROP_ONSCROLL
#define DISPID_IHTMLELEMENT2_ONDRAG                               DISPID_EVPROP_ONDRAG
#define DISPID_IHTMLELEMENT2_ONDRAGEND                            DISPID_EVPROP_ONDRAGEND
#define DISPID_IHTMLELEMENT2_ONDRAGENTER                          DISPID_EVPROP_ONDRAGENTER
#define DISPID_IHTMLELEMENT2_ONDRAGOVER                           DISPID_EVPROP_ONDRAGOVER
#define DISPID_IHTMLELEMENT2_ONDRAGLEAVE                          DISPID_EVPROP_ONDRAGLEAVE
#define DISPID_IHTMLELEMENT2_ONDROP                               DISPID_EVPROP_ONDROP
#define DISPID_IHTMLELEMENT2_ONBEFORECUT                          DISPID_EVPROP_ONBEFORECUT
#define DISPID_IHTMLELEMENT2_ONCUT                                DISPID_EVPROP_ONCUT
#define DISPID_IHTMLELEMENT2_ONBEFORECOPY                         DISPID_EVPROP_ONBEFORECOPY
#define DISPID_IHTMLELEMENT2_ONCOPY                               DISPID_EVPROP_ONCOPY
#define DISPID_IHTMLELEMENT2_ONBEFOREPASTE                        DISPID_EVPROP_ONBEFOREPASTE
#define DISPID_IHTMLELEMENT2_ONPASTE                              DISPID_EVPROP_ONPASTE
#define DISPID_IHTMLELEMENT2_CURRENTSTYLE                         DISPID_ELEMENT+7
#define DISPID_IHTMLELEMENT2_ONPROPERTYCHANGE                     DISPID_EVPROP_ONPROPERTYCHANGE
#define DISPID_IHTMLELEMENT2_GETCLIENTRECTS                       DISPID_ELEMENT+44
#define DISPID_IHTMLELEMENT2_GETBOUNDINGCLIENTRECT                DISPID_ELEMENT+45
#define DISPID_IHTMLELEMENT2_SETEXPRESSION                        DISPID_HTMLOBJECT+4
#define DISPID_IHTMLELEMENT2_GETEXPRESSION                        DISPID_HTMLOBJECT+5
#define DISPID_IHTMLELEMENT2_REMOVEEXPRESSION                     DISPID_HTMLOBJECT+6
#define DISPID_IHTMLELEMENT2_TABINDEX                             STDPROPID_XOBJ_TABINDEX
#define DISPID_IHTMLELEMENT2_FOCUS                                DISPID_SITE+0
#define DISPID_IHTMLELEMENT2_ACCESSKEY                            DISPID_SITE+5
#define DISPID_IHTMLELEMENT2_ONBLUR                               DISPID_EVPROP_ONBLUR
#define DISPID_IHTMLELEMENT2_ONFOCUS                              DISPID_EVPROP_ONFOCUS
#define DISPID_IHTMLELEMENT2_ONRESIZE                             DISPID_EVPROP_ONRESIZE
#define DISPID_IHTMLELEMENT2_BLUR                                 DISPID_SITE+2
#define DISPID_IHTMLELEMENT2_ADDFILTER                            DISPID_SITE+17
#define DISPID_IHTMLELEMENT2_REMOVEFILTER                         DISPID_SITE+18
#define DISPID_IHTMLELEMENT2_CLIENTHEIGHT                         DISPID_SITE+19
#define DISPID_IHTMLELEMENT2_CLIENTWIDTH                          DISPID_SITE+20
#define DISPID_IHTMLELEMENT2_CLIENTTOP                            DISPID_SITE+21
#define DISPID_IHTMLELEMENT2_CLIENTLEFT                           DISPID_SITE+22
#define DISPID_IHTMLELEMENT2_ATTACHEVENT                          DISPID_HTMLOBJECT+7
#define DISPID_IHTMLELEMENT2_DETACHEVENT                          DISPID_HTMLOBJECT+8
#define DISPID_IHTMLELEMENT2_READYSTATE                           DISPID_A_READYSTATE
#define DISPID_IHTMLELEMENT2_ONREADYSTATECHANGE                   DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLELEMENT2_ONROWSDELETE                         DISPID_EVPROP_ONROWSDELETE
#define DISPID_IHTMLELEMENT2_ONROWSINSERTED                       DISPID_EVPROP_ONROWSINSERTED
#define DISPID_IHTMLELEMENT2_ONCELLCHANGE                         DISPID_EVPROP_ONCELLCHANGE
#define DISPID_IHTMLELEMENT2_DIR                                  DISPID_A_DIR
#define DISPID_IHTMLELEMENT2_CREATECONTROLRANGE                   DISPID_ELEMENT+56
#define DISPID_IHTMLELEMENT2_SCROLLHEIGHT                         DISPID_ELEMENT+57
#define DISPID_IHTMLELEMENT2_SCROLLWIDTH                          DISPID_ELEMENT+58
#define DISPID_IHTMLELEMENT2_SCROLLTOP                            DISPID_ELEMENT+59
#define DISPID_IHTMLELEMENT2_SCROLLLEFT                           DISPID_ELEMENT+60
#define DISPID_IHTMLELEMENT2_CLEARATTRIBUTES                      DISPID_ELEMENT+62
#define DISPID_IHTMLELEMENT2_MERGEATTRIBUTES                      DISPID_ELEMENT+63
#define DISPID_IHTMLELEMENT2_ONCONTEXTMENU                        DISPID_EVPROP_ONCONTEXTMENU
#define DISPID_IHTMLELEMENT2_INSERTADJACENTELEMENT                DISPID_ELEMENT+69
#define DISPID_IHTMLELEMENT2_APPLYELEMENT                         DISPID_ELEMENT+65
#define DISPID_IHTMLELEMENT2_GETADJACENTTEXT                      DISPID_ELEMENT+70
#define DISPID_IHTMLELEMENT2_REPLACEADJACENTTEXT                  DISPID_ELEMENT+71
#define DISPID_IHTMLELEMENT2_CANHAVECHILDREN                      DISPID_ELEMENT+72
#define DISPID_IHTMLELEMENT2_ADDBEHAVIOR                          DISPID_ELEMENT+80
#define DISPID_IHTMLELEMENT2_REMOVEBEHAVIOR                       DISPID_ELEMENT+81
#define DISPID_IHTMLELEMENT2_RUNTIMESTYLE                         DISPID_ELEMENT+64
#define DISPID_IHTMLELEMENT2_BEHAVIORURNS                         DISPID_ELEMENT+82
#define DISPID_IHTMLELEMENT2_TAGURN                               DISPID_ELEMENT+83
#define DISPID_IHTMLELEMENT2_ONBEFOREEDITFOCUS                    DISPID_EVPROP_ONBEFOREEDITFOCUS
#define DISPID_IHTMLELEMENT2_READYSTATEVALUE                      DISPID_ELEMENT+84
#define DISPID_IHTMLELEMENT2_GETELEMENTSBYTAGNAME                 DISPID_ELEMENT+85

//    DISPIDs for interface IHTMLElement3

#define DISPID_IHTMLELEMENT3_MERGEATTRIBUTES                      DISPID_ELEMENT+96
#define DISPID_IHTMLELEMENT3_ISMULTILINE                          DISPID_ELEMENT+97
#define DISPID_IHTMLELEMENT3_CANHAVEHTML                          DISPID_ELEMENT+98
#define DISPID_IHTMLELEMENT3_ONLAYOUTCOMPLETE                     DISPID_EVPROP_ONLAYOUTCOMPLETE
#define DISPID_IHTMLELEMENT3_ONPAGE                               DISPID_EVPROP_ONPAGE
#define DISPID_IHTMLELEMENT3_INFLATEBLOCK                         DISPID_ELEMENT+100
#define DISPID_IHTMLELEMENT3_ONBEFOREDEACTIVATE                   DISPID_EVPROP_ONBEFOREDEACTIVATE
#define DISPID_IHTMLELEMENT3_SETACTIVE                            DISPID_ELEMENT+101
#define DISPID_IHTMLELEMENT3_CONTENTEDITABLE                      DISPID_A_EDITABLE
#define DISPID_IHTMLELEMENT3_ISCONTENTEDITABLE                    DISPID_ELEMENT+102
#define DISPID_IHTMLELEMENT3_HIDEFOCUS                            DISPID_A_HIDEFOCUS
#define DISPID_IHTMLELEMENT3_DISABLED                             STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLELEMENT3_ISDISABLED                           DISPID_ELEMENT+105
#define DISPID_IHTMLELEMENT3_ONMOVE                               DISPID_EVPROP_ONMOVE
#define DISPID_IHTMLELEMENT3_ONCONTROLSELECT                      DISPID_EVPROP_ONCONTROLSELECT
#define DISPID_IHTMLELEMENT3_FIREEVENT                            DISPID_ELEMENT+106
#define DISPID_IHTMLELEMENT3_ONRESIZESTART                        DISPID_EVPROP_ONRESIZESTART
#define DISPID_IHTMLELEMENT3_ONRESIZEEND                          DISPID_EVPROP_ONRESIZEEND
#define DISPID_IHTMLELEMENT3_ONMOVESTART                          DISPID_EVPROP_ONMOVESTART
#define DISPID_IHTMLELEMENT3_ONMOVEEND                            DISPID_EVPROP_ONMOVEEND
#define DISPID_IHTMLELEMENT3_ONMOUSEENTER                         DISPID_EVPROP_ONMOUSEENTER
#define DISPID_IHTMLELEMENT3_ONMOUSELEAVE                         DISPID_EVPROP_ONMOUSELEAVE
#define DISPID_IHTMLELEMENT3_ONACTIVATE                           DISPID_EVPROP_ONACTIVATE
#define DISPID_IHTMLELEMENT3_ONDEACTIVATE                         DISPID_EVPROP_ONDEACTIVATE
#define DISPID_IHTMLELEMENT3_DRAGDROP                             DISPID_ELEMENT+107
#define DISPID_IHTMLELEMENT3_GLYPHMODE                            DISPID_ELEMENT+108

//    DISPIDs for interface IHTMLElement4

#define DISPID_IHTMLELEMENT4_ONMOUSEWHEEL                         DISPID_EVPROP_ONMOUSEWHEEL
#define DISPID_IHTMLELEMENT4_NORMALIZE                            DISPID_ELEMENT+112
#define DISPID_IHTMLELEMENT4_GETATTRIBUTENODE                     DISPID_ELEMENT+109
#define DISPID_IHTMLELEMENT4_SETATTRIBUTENODE                     DISPID_ELEMENT+110
#define DISPID_IHTMLELEMENT4_REMOVEATTRIBUTENODE                  DISPID_ELEMENT+111
#define DISPID_IHTMLELEMENT4_ONBEFOREACTIVATE                     DISPID_EVPROP_ONBEFOREACTIVATE
#define DISPID_IHTMLELEMENT4_ONFOCUSIN                            DISPID_EVPROP_ONFOCUSIN
#define DISPID_IHTMLELEMENT4_ONFOCUSOUT                           DISPID_EVPROP_ONFOCUSOUT

//    DISPIDs for interface IHTMLElementRender

#define DISPID_IHTMLELEMENTRENDER_DRAWTODC                        
#define DISPID_IHTMLELEMENTRENDER_SETDOCUMENTPRINTER              

//    DISPIDs for interface IHTMLUniqueName

#define DISPID_IHTMLUNIQUENAME_UNIQUENUMBER                       DISPID_ELEMENT+54
#define DISPID_IHTMLUNIQUENAME_UNIQUEID                           DISPID_ELEMENT+55

//    DISPIDs for interface IHTMLDatabinding

#define DISPID_IHTMLDATABINDING_DATAFLD                           DISPID_ELEMENT+21
#define DISPID_IHTMLDATABINDING_DATASRC                           DISPID_ELEMENT+22
#define DISPID_IHTMLDATABINDING_DATAFORMATAS                      DISPID_ELEMENT+23

//    DISPIDs for event set HTMLElementEvents2

#define DISPID_HTMLELEMENTEVENTS2_ONHELP                          DISPID_EVMETH_ONHELP
#define DISPID_HTMLELEMENTEVENTS2_ONCLICK                         DISPID_EVMETH_ONCLICK
#define DISPID_HTMLELEMENTEVENTS2_ONDBLCLICK                      DISPID_EVMETH_ONDBLCLICK
#define DISPID_HTMLELEMENTEVENTS2_ONKEYPRESS                      DISPID_EVMETH_ONKEYPRESS
#define DISPID_HTMLELEMENTEVENTS2_ONKEYDOWN                       DISPID_EVMETH_ONKEYDOWN
#define DISPID_HTMLELEMENTEVENTS2_ONKEYUP                         DISPID_EVMETH_ONKEYUP
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEOUT                      DISPID_EVMETH_ONMOUSEOUT
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEOVER                     DISPID_EVMETH_ONMOUSEOVER
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEMOVE                     DISPID_EVMETH_ONMOUSEMOVE
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEDOWN                     DISPID_EVMETH_ONMOUSEDOWN
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEUP                       DISPID_EVMETH_ONMOUSEUP
#define DISPID_HTMLELEMENTEVENTS2_ONSELECTSTART                   DISPID_EVMETH_ONSELECTSTART
#define DISPID_HTMLELEMENTEVENTS2_ONFILTERCHANGE                  DISPID_EVMETH_ONFILTER
#define DISPID_HTMLELEMENTEVENTS2_ONDRAGSTART                     DISPID_EVMETH_ONDRAGSTART
#define DISPID_HTMLELEMENTEVENTS2_ONBEFOREUPDATE                  DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLELEMENTEVENTS2_ONAFTERUPDATE                   DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLELEMENTEVENTS2_ONERRORUPDATE                   DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLELEMENTEVENTS2_ONROWEXIT                       DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLELEMENTEVENTS2_ONROWENTER                      DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLELEMENTEVENTS2_ONDATASETCHANGED                DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLELEMENTEVENTS2_ONDATAAVAILABLE                 DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLELEMENTEVENTS2_ONDATASETCOMPLETE               DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLELEMENTEVENTS2_ONLOSECAPTURE                   DISPID_EVMETH_ONLOSECAPTURE
#define DISPID_HTMLELEMENTEVENTS2_ONPROPERTYCHANGE                DISPID_EVMETH_ONPROPERTYCHANGE
#define DISPID_HTMLELEMENTEVENTS2_ONSCROLL                        DISPID_EVMETH_ONSCROLL
#define DISPID_HTMLELEMENTEVENTS2_ONFOCUS                         DISPID_EVMETH_ONFOCUS
#define DISPID_HTMLELEMENTEVENTS2_ONBLUR                          DISPID_EVMETH_ONBLUR
#define DISPID_HTMLELEMENTEVENTS2_ONRESIZE                        DISPID_EVMETH_ONRESIZE
#define DISPID_HTMLELEMENTEVENTS2_ONDRAG                          DISPID_EVMETH_ONDRAG
#define DISPID_HTMLELEMENTEVENTS2_ONDRAGEND                       DISPID_EVMETH_ONDRAGEND
#define DISPID_HTMLELEMENTEVENTS2_ONDRAGENTER                     DISPID_EVMETH_ONDRAGENTER
#define DISPID_HTMLELEMENTEVENTS2_ONDRAGOVER                      DISPID_EVMETH_ONDRAGOVER
#define DISPID_HTMLELEMENTEVENTS2_ONDRAGLEAVE                     DISPID_EVMETH_ONDRAGLEAVE
#define DISPID_HTMLELEMENTEVENTS2_ONDROP                          DISPID_EVMETH_ONDROP
#define DISPID_HTMLELEMENTEVENTS2_ONBEFORECUT                     DISPID_EVMETH_ONBEFORECUT
#define DISPID_HTMLELEMENTEVENTS2_ONCUT                           DISPID_EVMETH_ONCUT
#define DISPID_HTMLELEMENTEVENTS2_ONBEFORECOPY                    DISPID_EVMETH_ONBEFORECOPY
#define DISPID_HTMLELEMENTEVENTS2_ONCOPY                          DISPID_EVMETH_ONCOPY
#define DISPID_HTMLELEMENTEVENTS2_ONBEFOREPASTE                   DISPID_EVMETH_ONBEFOREPASTE
#define DISPID_HTMLELEMENTEVENTS2_ONPASTE                         DISPID_EVMETH_ONPASTE
#define DISPID_HTMLELEMENTEVENTS2_ONCONTEXTMENU                   DISPID_EVMETH_ONCONTEXTMENU
#define DISPID_HTMLELEMENTEVENTS2_ONROWSDELETE                    DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLELEMENTEVENTS2_ONROWSINSERTED                  DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLELEMENTEVENTS2_ONCELLCHANGE                    DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLELEMENTEVENTS2_ONREADYSTATECHANGE              DISPID_EVMETH_ONREADYSTATECHANGE
#define DISPID_HTMLELEMENTEVENTS2_ONLAYOUTCOMPLETE                DISPID_EVMETH_ONLAYOUTCOMPLETE
#define DISPID_HTMLELEMENTEVENTS2_ONPAGE                          DISPID_EVMETH_ONPAGE
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEENTER                    DISPID_EVMETH_ONMOUSEENTER
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSELEAVE                    DISPID_EVMETH_ONMOUSELEAVE
#define DISPID_HTMLELEMENTEVENTS2_ONACTIVATE                      DISPID_EVMETH_ONACTIVATE
#define DISPID_HTMLELEMENTEVENTS2_ONDEACTIVATE                    DISPID_EVMETH_ONDEACTIVATE
#define DISPID_HTMLELEMENTEVENTS2_ONBEFOREDEACTIVATE              DISPID_EVMETH_ONBEFOREDEACTIVATE
#define DISPID_HTMLELEMENTEVENTS2_ONBEFOREACTIVATE                DISPID_EVMETH_ONBEFOREACTIVATE
#define DISPID_HTMLELEMENTEVENTS2_ONFOCUSIN                       DISPID_EVMETH_ONFOCUSIN
#define DISPID_HTMLELEMENTEVENTS2_ONFOCUSOUT                      DISPID_EVMETH_ONFOCUSOUT
#define DISPID_HTMLELEMENTEVENTS2_ONMOVE                          DISPID_EVMETH_ONMOVE
#define DISPID_HTMLELEMENTEVENTS2_ONCONTROLSELECT                 DISPID_EVMETH_ONCONTROLSELECT
#define DISPID_HTMLELEMENTEVENTS2_ONMOVESTART                     DISPID_EVMETH_ONMOVESTART
#define DISPID_HTMLELEMENTEVENTS2_ONMOVEEND                       DISPID_EVMETH_ONMOVEEND
#define DISPID_HTMLELEMENTEVENTS2_ONRESIZESTART                   DISPID_EVMETH_ONRESIZESTART
#define DISPID_HTMLELEMENTEVENTS2_ONRESIZEEND                     DISPID_EVMETH_ONRESIZEEND
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEWHEEL                    DISPID_EVMETH_ONMOUSEWHEEL

//    DISPIDs for event set HTMLElementEvents

#define DISPID_HTMLELEMENTEVENTS_ONHELP                           DISPID_EVMETH_ONHELP
#define DISPID_HTMLELEMENTEVENTS_ONCLICK                          DISPID_EVMETH_ONCLICK
#define DISPID_HTMLELEMENTEVENTS_ONDBLCLICK                       DISPID_EVMETH_ONDBLCLICK
#define DISPID_HTMLELEMENTEVENTS_ONKEYPRESS                       DISPID_EVMETH_ONKEYPRESS
#define DISPID_HTMLELEMENTEVENTS_ONKEYDOWN                        DISPID_EVMETH_ONKEYDOWN
#define DISPID_HTMLELEMENTEVENTS_ONKEYUP                          DISPID_EVMETH_ONKEYUP
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT                       DISPID_EVMETH_ONMOUSEOUT
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEOVER                      DISPID_EVMETH_ONMOUSEOVER
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEMOVE                      DISPID_EVMETH_ONMOUSEMOVE
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN                      DISPID_EVMETH_ONMOUSEDOWN
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEUP                        DISPID_EVMETH_ONMOUSEUP
#define DISPID_HTMLELEMENTEVENTS_ONSELECTSTART                    DISPID_EVMETH_ONSELECTSTART
#define DISPID_HTMLELEMENTEVENTS_ONFILTERCHANGE                   DISPID_EVMETH_ONFILTER
#define DISPID_HTMLELEMENTEVENTS_ONDRAGSTART                      DISPID_EVMETH_ONDRAGSTART
#define DISPID_HTMLELEMENTEVENTS_ONBEFOREUPDATE                   DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLELEMENTEVENTS_ONAFTERUPDATE                    DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLELEMENTEVENTS_ONERRORUPDATE                    DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLELEMENTEVENTS_ONROWEXIT                        DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLELEMENTEVENTS_ONROWENTER                       DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLELEMENTEVENTS_ONDATASETCHANGED                 DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLELEMENTEVENTS_ONDATAAVAILABLE                  DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLELEMENTEVENTS_ONDATASETCOMPLETE                DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLELEMENTEVENTS_ONLOSECAPTURE                    DISPID_EVMETH_ONLOSECAPTURE
#define DISPID_HTMLELEMENTEVENTS_ONPROPERTYCHANGE                 DISPID_EVMETH_ONPROPERTYCHANGE
#define DISPID_HTMLELEMENTEVENTS_ONSCROLL                         DISPID_EVMETH_ONSCROLL
#define DISPID_HTMLELEMENTEVENTS_ONFOCUS                          DISPID_EVMETH_ONFOCUS
#define DISPID_HTMLELEMENTEVENTS_ONBLUR                           DISPID_EVMETH_ONBLUR
#define DISPID_HTMLELEMENTEVENTS_ONRESIZE                         DISPID_EVMETH_ONRESIZE
#define DISPID_HTMLELEMENTEVENTS_ONDRAG                           DISPID_EVMETH_ONDRAG
#define DISPID_HTMLELEMENTEVENTS_ONDRAGEND                        DISPID_EVMETH_ONDRAGEND
#define DISPID_HTMLELEMENTEVENTS_ONDRAGENTER                      DISPID_EVMETH_ONDRAGENTER
#define DISPID_HTMLELEMENTEVENTS_ONDRAGOVER                       DISPID_EVMETH_ONDRAGOVER
#define DISPID_HTMLELEMENTEVENTS_ONDRAGLEAVE                      DISPID_EVMETH_ONDRAGLEAVE
#define DISPID_HTMLELEMENTEVENTS_ONDROP                           DISPID_EVMETH_ONDROP
#define DISPID_HTMLELEMENTEVENTS_ONBEFORECUT                      DISPID_EVMETH_ONBEFORECUT
#define DISPID_HTMLELEMENTEVENTS_ONCUT                            DISPID_EVMETH_ONCUT
#define DISPID_HTMLELEMENTEVENTS_ONBEFORECOPY                     DISPID_EVMETH_ONBEFORECOPY
#define DISPID_HTMLELEMENTEVENTS_ONCOPY                           DISPID_EVMETH_ONCOPY
#define DISPID_HTMLELEMENTEVENTS_ONBEFOREPASTE                    DISPID_EVMETH_ONBEFOREPASTE
#define DISPID_HTMLELEMENTEVENTS_ONPASTE                          DISPID_EVMETH_ONPASTE
#define DISPID_HTMLELEMENTEVENTS_ONCONTEXTMENU                    DISPID_EVMETH_ONCONTEXTMENU
#define DISPID_HTMLELEMENTEVENTS_ONROWSDELETE                     DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLELEMENTEVENTS_ONROWSINSERTED                   DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLELEMENTEVENTS_ONCELLCHANGE                     DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLELEMENTEVENTS_ONREADYSTATECHANGE               DISPID_EVMETH_ONREADYSTATECHANGE
#define DISPID_HTMLELEMENTEVENTS_ONBEFOREEDITFOCUS                DISPID_EVMETH_ONBEFOREEDITFOCUS
#define DISPID_HTMLELEMENTEVENTS_ONLAYOUTCOMPLETE                 DISPID_EVMETH_ONLAYOUTCOMPLETE
#define DISPID_HTMLELEMENTEVENTS_ONPAGE                           DISPID_EVMETH_ONPAGE
#define DISPID_HTMLELEMENTEVENTS_ONBEFOREDEACTIVATE               DISPID_EVMETH_ONBEFOREDEACTIVATE
#define DISPID_HTMLELEMENTEVENTS_ONBEFOREACTIVATE                 DISPID_EVMETH_ONBEFOREACTIVATE
#define DISPID_HTMLELEMENTEVENTS_ONMOVE                           DISPID_EVMETH_ONMOVE
#define DISPID_HTMLELEMENTEVENTS_ONCONTROLSELECT                  DISPID_EVMETH_ONCONTROLSELECT
#define DISPID_HTMLELEMENTEVENTS_ONMOVESTART                      DISPID_EVMETH_ONMOVESTART
#define DISPID_HTMLELEMENTEVENTS_ONMOVEEND                        DISPID_EVMETH_ONMOVEEND
#define DISPID_HTMLELEMENTEVENTS_ONRESIZESTART                    DISPID_EVMETH_ONRESIZESTART
#define DISPID_HTMLELEMENTEVENTS_ONRESIZEEND                      DISPID_EVMETH_ONRESIZEEND
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEENTER                     DISPID_EVMETH_ONMOUSEENTER
#define DISPID_HTMLELEMENTEVENTS_ONMOUSELEAVE                     DISPID_EVMETH_ONMOUSELEAVE
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEWHEEL                     DISPID_EVMETH_ONMOUSEWHEEL
#define DISPID_HTMLELEMENTEVENTS_ONACTIVATE                       DISPID_EVMETH_ONACTIVATE
#define DISPID_HTMLELEMENTEVENTS_ONDEACTIVATE                     DISPID_EVMETH_ONDEACTIVATE
#define DISPID_HTMLELEMENTEVENTS_ONFOCUSIN                        DISPID_EVMETH_ONFOCUSIN
#define DISPID_HTMLELEMENTEVENTS_ONFOCUSOUT                       DISPID_EVMETH_ONFOCUSOUT

//    DISPIDs for interface IHTMLElementDefaults

#define DISPID_IHTMLELEMENTDEFAULTS_STYLE                         DISPID_DEFAULTS+1
#define DISPID_IHTMLELEMENTDEFAULTS_TABSTOP                       DISPID_DEFAULTS+2
#define DISPID_IHTMLELEMENTDEFAULTS_VIEWINHERITSTYLE              DISPID_A_VIEWINHERITSTYLE
#define DISPID_IHTMLELEMENTDEFAULTS_VIEWMASTERTAB                 DISPID_DEFAULTS+6
#define DISPID_IHTMLELEMENTDEFAULTS_SCROLLSEGMENTX                DISPID_DEFAULTS+3
#define DISPID_IHTMLELEMENTDEFAULTS_SCROLLSEGMENTY                DISPID_DEFAULTS+4
#define DISPID_IHTMLELEMENTDEFAULTS_ISMULTILINE                   DISPID_DEFAULTS+8
#define DISPID_IHTMLELEMENTDEFAULTS_CONTENTEDITABLE               DISPID_A_EDITABLE
#define DISPID_IHTMLELEMENTDEFAULTS_CANHAVEHTML                   DISPID_DEFAULTS+9
#define DISPID_IHTMLELEMENTDEFAULTS_VIEWLINK                      DISPID_DEFAULTS+11
#define DISPID_IHTMLELEMENTDEFAULTS_FROZEN                        DISPID_A_FROZEN

//    DISPIDs for interface IHTCDefaultDispatch

#define DISPID_IHTCDEFAULTDISPATCH_ELEMENT                        DISPID_A_HTCDD_ELEMENT
#define DISPID_IHTCDEFAULTDISPATCH_CREATEEVENTOBJECT              DISPID_A_HTCDD_CREATEEVENTOBJECT
#define DISPID_IHTCDEFAULTDISPATCH_DEFAULTS                       DISPID_A_HTCDD_DEFAULTS
#define DISPID_IHTCDEFAULTDISPATCH_DOCUMENT                       DISPID_A_DOCFRAGMENT

//    DISPIDs for interface IHTCPropertyBehavior

#define DISPID_IHTCPROPERTYBEHAVIOR_FIRECHANGE                    DISPID_HTMLOBJECT+0
#define DISPID_IHTCPROPERTYBEHAVIOR_VALUE                         DISPID_A_HTCDISPATCHITEM_VALUE

//    DISPIDs for interface IHTCEventBehavior

#define DISPID_IHTCEVENTBEHAVIOR_FIRE                             DISPID_HTMLOBJECT+0

//    DISPIDs for interface IHTCAttachBehavior

#define DISPID_IHTCATTACHBEHAVIOR_FIREEVENT                       DISPID_VALUE
#define DISPID_IHTCATTACHBEHAVIOR_DETACHEVENT                     DISPID_HTMLOBJECT+0

//    DISPIDs for interface IHTCAttachBehavior2

#define DISPID_IHTCATTACHBEHAVIOR2_FIREEVENT                      DISPID_VALUE

//    DISPIDs for interface IHTCDescBehavior

#define DISPID_IHTCDESCBEHAVIOR_URN                               DISPID_HTMLOBJECT+0
#define DISPID_IHTCDESCBEHAVIOR_NAME                              DISPID_HTMLOBJECT+1

//    DISPIDs for interface IHTMLUrnCollection

#define DISPID_IHTMLURNCOLLECTION_LENGTH                          DISPID_URN_COLL+1
#define DISPID_IHTMLURNCOLLECTION_ITEM                            DISPID_VALUE

//    DISPIDs for interface IHTMLGenericElement

#define DISPID_IHTMLGENERICELEMENT_RECORDSET                      DISPID_GENERIC+1
#define DISPID_IHTMLGENERICELEMENT_NAMEDRECORDSET                 DISPID_GENERIC+2

//    DISPIDs for interface IHTMLStyleSheetRule

#define DISPID_IHTMLSTYLESHEETRULE_SELECTORTEXT                   DISPID_STYLERULE+1
#define DISPID_IHTMLSTYLESHEETRULE_STYLE                          STDPROPID_XOBJ_STYLE
#define DISPID_IHTMLSTYLESHEETRULE_READONLY                       DISPID_STYLERULE+2

//    DISPIDs for interface IHTMLStyleSheetRulesCollection

#define DISPID_IHTMLSTYLESHEETRULESCOLLECTION_LENGTH              DISPID_STYLERULES_COL+1
#define DISPID_IHTMLSTYLESHEETRULESCOLLECTION_ITEM                DISPID_VALUE

//    DISPIDs for interface IHTMLStyleSheetPage

#define DISPID_IHTMLSTYLESHEETPAGE_SELECTOR                       DISPID_STYLEPAGE+1
#define DISPID_IHTMLSTYLESHEETPAGE_PSEUDOCLASS                    DISPID_STYLEPAGE+2

//    DISPIDs for interface IHTMLStyleSheetPagesCollection

#define DISPID_IHTMLSTYLESHEETPAGESCOLLECTION_LENGTH              DISPID_STYLEPAGES_COL+1
#define DISPID_IHTMLSTYLESHEETPAGESCOLLECTION_ITEM                DISPID_VALUE

//    DISPIDs for interface IHTMLStyleSheet

#define DISPID_IHTMLSTYLESHEET_TITLE                              DISPID_STYLESHEET+1
#define DISPID_IHTMLSTYLESHEET_PARENTSTYLESHEET                   DISPID_STYLESHEET+2
#define DISPID_IHTMLSTYLESHEET_OWNINGELEMENT                      DISPID_STYLESHEET+3
#define DISPID_IHTMLSTYLESHEET_DISABLED                           STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLSTYLESHEET_READONLY                           DISPID_STYLESHEET+4
#define DISPID_IHTMLSTYLESHEET_IMPORTS                            DISPID_STYLESHEET+5
#define DISPID_IHTMLSTYLESHEET_HREF                               DISPID_STYLESHEET+6
#define DISPID_IHTMLSTYLESHEET_TYPE                               DISPID_STYLESHEET+7
#define DISPID_IHTMLSTYLESHEET_ID                                 DISPID_STYLESHEET+8
#define DISPID_IHTMLSTYLESHEET_ADDIMPORT                          DISPID_STYLESHEET+9
#define DISPID_IHTMLSTYLESHEET_ADDRULE                            DISPID_STYLESHEET+10
#define DISPID_IHTMLSTYLESHEET_REMOVEIMPORT                       DISPID_STYLESHEET+11
#define DISPID_IHTMLSTYLESHEET_REMOVERULE                         DISPID_STYLESHEET+12
#define DISPID_IHTMLSTYLESHEET_MEDIA                              DISPID_STYLESHEET+13
#define DISPID_IHTMLSTYLESHEET_CSSTEXT                            DISPID_STYLESHEET+14
#define DISPID_IHTMLSTYLESHEET_RULES                              DISPID_STYLESHEET+15

//    DISPIDs for interface IHTMLStyleSheet2

#define DISPID_IHTMLSTYLESHEET2_PAGES                             DISPID_STYLESHEET+16
#define DISPID_IHTMLSTYLESHEET2_ADDPAGERULE                       DISPID_STYLESHEET+17

//    DISPIDs for interface IHTMLStyleSheetsCollection

#define DISPID_IHTMLSTYLESHEETSCOLLECTION_LENGTH                  DISPID_STYLESHEETS_COL+1
#define DISPID_IHTMLSTYLESHEETSCOLLECTION__NEWENUM                DISPID_NEWENUM
#define DISPID_IHTMLSTYLESHEETSCOLLECTION_ITEM                    DISPID_VALUE

//    DISPIDs for interface IHTMLLinkElement

#define DISPID_IHTMLLINKELEMENT_HREF                              DISPID_HEDELEMS+5
#define DISPID_IHTMLLINKELEMENT_REL                               DISPID_HEDELEMS+6
#define DISPID_IHTMLLINKELEMENT_REV                               DISPID_HEDELEMS+7
#define DISPID_IHTMLLINKELEMENT_TYPE                              DISPID_HEDELEMS+8
#define DISPID_IHTMLLINKELEMENT_READYSTATE                        DISPID_A_READYSTATE
#define DISPID_IHTMLLINKELEMENT_ONREADYSTATECHANGE                DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLLINKELEMENT_ONLOAD                            DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLLINKELEMENT_ONERROR                           DISPID_EVPROP_ONERROR
#define DISPID_IHTMLLINKELEMENT_STYLESHEET                        DISPID_HEDELEMS+14
#define DISPID_IHTMLLINKELEMENT_DISABLED                          STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLLINKELEMENT_MEDIA                             DISPID_HEDELEMS+16

//    DISPIDs for interface IHTMLLinkElement2

#define DISPID_IHTMLLINKELEMENT2_TARGET                           DISPID_HEDELEMS+17

//    DISPIDs for interface IHTMLLinkElement3

#define DISPID_IHTMLLINKELEMENT3_CHARSET                          DISPID_HEDELEMS+18
#define DISPID_IHTMLLINKELEMENT3_HREFLANG                         DISPID_HEDELEMS+19

//    DISPIDs for event set HTMLLinkElementEvents2

#define DISPID_HTMLLINKELEMENTEVENTS2_ONLOAD                      DISPID_EVMETH_ONLOAD
#define DISPID_HTMLLINKELEMENTEVENTS2_ONERROR                     DISPID_EVMETH_ONERROR

//    DISPIDs for event set HTMLLinkElementEvents

#define DISPID_HTMLLINKELEMENTEVENTS_ONLOAD                       DISPID_EVMETH_ONLOAD
#define DISPID_HTMLLINKELEMENTEVENTS_ONERROR                      DISPID_EVMETH_ONERROR

//    DISPIDs for interface IHTMLTxtRange

#define DISPID_IHTMLTXTRANGE_HTMLTEXT                             DISPID_RANGE+3
#define DISPID_IHTMLTXTRANGE_TEXT                                 DISPID_RANGE+4
#define DISPID_IHTMLTXTRANGE_PARENTELEMENT                        DISPID_RANGE+6
#define DISPID_IHTMLTXTRANGE_DUPLICATE                            DISPID_RANGE+8
#define DISPID_IHTMLTXTRANGE_INRANGE                              DISPID_RANGE+10
#define DISPID_IHTMLTXTRANGE_ISEQUAL                              DISPID_RANGE+11
#define DISPID_IHTMLTXTRANGE_SCROLLINTOVIEW                       DISPID_RANGE+12
#define DISPID_IHTMLTXTRANGE_COLLAPSE                             DISPID_RANGE+13
#define DISPID_IHTMLTXTRANGE_EXPAND                               DISPID_RANGE+14
#define DISPID_IHTMLTXTRANGE_MOVE                                 DISPID_RANGE+15
#define DISPID_IHTMLTXTRANGE_MOVESTART                            DISPID_RANGE+16
#define DISPID_IHTMLTXTRANGE_MOVEEND                              DISPID_RANGE+17
#define DISPID_IHTMLTXTRANGE_SELECT                               DISPID_RANGE+24
#define DISPID_IHTMLTXTRANGE_PASTEHTML                            DISPID_RANGE+26
#define DISPID_IHTMLTXTRANGE_MOVETOELEMENTTEXT                    DISPID_RANGE+1
#define DISPID_IHTMLTXTRANGE_SETENDPOINT                          DISPID_RANGE+25
#define DISPID_IHTMLTXTRANGE_COMPAREENDPOINTS                     DISPID_RANGE+18
#define DISPID_IHTMLTXTRANGE_FINDTEXT                             DISPID_RANGE+19
#define DISPID_IHTMLTXTRANGE_MOVETOPOINT                          DISPID_RANGE+20
#define DISPID_IHTMLTXTRANGE_GETBOOKMARK                          DISPID_RANGE+21
#define DISPID_IHTMLTXTRANGE_MOVETOBOOKMARK                       DISPID_RANGE+9
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDSUPPORTED                DISPID_RANGE+27
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDENABLED                  DISPID_RANGE+28
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDSTATE                    DISPID_RANGE+29
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDINDETERM                 DISPID_RANGE+30
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDTEXT                     DISPID_RANGE+31
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDVALUE                    DISPID_RANGE+32
#define DISPID_IHTMLTXTRANGE_EXECCOMMAND                          DISPID_RANGE+33
#define DISPID_IHTMLTXTRANGE_EXECCOMMANDSHOWHELP                  DISPID_RANGE+34

//    DISPIDs for interface IHTMLTextRangeMetrics

#define DISPID_IHTMLTEXTRANGEMETRICS_OFFSETTOP                    DISPID_RANGE+35
#define DISPID_IHTMLTEXTRANGEMETRICS_OFFSETLEFT                   DISPID_RANGE+36
#define DISPID_IHTMLTEXTRANGEMETRICS_BOUNDINGTOP                  DISPID_RANGE+37
#define DISPID_IHTMLTEXTRANGEMETRICS_BOUNDINGLEFT                 DISPID_RANGE+38
#define DISPID_IHTMLTEXTRANGEMETRICS_BOUNDINGWIDTH                DISPID_RANGE+39
#define DISPID_IHTMLTEXTRANGEMETRICS_BOUNDINGHEIGHT               DISPID_RANGE+40

//    DISPIDs for interface IHTMLTextRangeMetrics2

#define DISPID_IHTMLTEXTRANGEMETRICS2_GETCLIENTRECTS              DISPID_RANGE+41
#define DISPID_IHTMLTEXTRANGEMETRICS2_GETBOUNDINGCLIENTRECT       DISPID_RANGE+42

//    DISPIDs for interface IHTMLTxtRangeCollection

#define DISPID_IHTMLTXTRANGECOLLECTION_LENGTH                     DISPID_COLLECTION
#define DISPID_IHTMLTXTRANGECOLLECTION__NEWENUM                   DISPID_NEWENUM
#define DISPID_IHTMLTXTRANGECOLLECTION_ITEM                       DISPID_VALUE

//    DISPIDs for interface IHTMLFormElement

#define DISPID_IHTMLFORMELEMENT_ACTION                            DISPID_FORM+1
#define DISPID_IHTMLFORMELEMENT_DIR                               DISPID_A_DIR
#define DISPID_IHTMLFORMELEMENT_ENCODING                          DISPID_FORM+3
#define DISPID_IHTMLFORMELEMENT_METHOD                            DISPID_FORM+4
#define DISPID_IHTMLFORMELEMENT_ELEMENTS                          DISPID_FORM+5
#define DISPID_IHTMLFORMELEMENT_TARGET                            DISPID_FORM+6
#define DISPID_IHTMLFORMELEMENT_NAME                              STDPROPID_XOBJ_NAME
#define DISPID_IHTMLFORMELEMENT_ONSUBMIT                          DISPID_EVPROP_ONSUBMIT
#define DISPID_IHTMLFORMELEMENT_ONRESET                           DISPID_EVPROP_ONRESET
#define DISPID_IHTMLFORMELEMENT_SUBMIT                            DISPID_FORM+9
#define DISPID_IHTMLFORMELEMENT_RESET                             DISPID_FORM+10
#define DISPID_IHTMLFORMELEMENT_LENGTH                            DISPID_COLLECTION
#define DISPID_IHTMLFORMELEMENT__NEWENUM                          DISPID_NEWENUM
#define DISPID_IHTMLFORMELEMENT_ITEM                              DISPID_VALUE
#define DISPID_IHTMLFORMELEMENT_TAGS                              DISPID_COLLECTION+2

//    DISPIDs for interface IHTMLFormElement2

#define DISPID_IHTMLFORMELEMENT2_ACCEPTCHARSET                    DISPID_FORM+11
#define DISPID_IHTMLFORMELEMENT2_URNS                             DISPID_COLLECTION+5

//    DISPIDs for interface IHTMLFormElement3

#define DISPID_IHTMLFORMELEMENT3_NAMEDITEM                        DISPID_COLLECTION+6

//    DISPIDs for interface IHTMLSubmitData

#define DISPID_IHTMLSUBMITDATA_APPENDNAMEVALUEPAIR                DISPID_FORM+12
#define DISPID_IHTMLSUBMITDATA_APPENDNAMEFILEPAIR                 DISPID_FORM+13
#define DISPID_IHTMLSUBMITDATA_APPENDITEMSEPARATOR                DISPID_FORM+14

//    DISPIDs for event set HTMLFormElementEvents2

#define DISPID_HTMLFORMELEMENTEVENTS2_ONSUBMIT                    DISPID_EVMETH_ONSUBMIT
#define DISPID_HTMLFORMELEMENTEVENTS2_ONRESET                     DISPID_EVMETH_ONRESET

//    DISPIDs for event set HTMLFormElementEvents

#define DISPID_HTMLFORMELEMENTEVENTS_ONSUBMIT                     DISPID_EVMETH_ONSUBMIT
#define DISPID_HTMLFORMELEMENTEVENTS_ONRESET                      DISPID_EVMETH_ONRESET

//    DISPIDs for interface IHTMLControlElement

#define DISPID_IHTMLCONTROLELEMENT_TABINDEX                       STDPROPID_XOBJ_TABINDEX
#define DISPID_IHTMLCONTROLELEMENT_FOCUS                          DISPID_SITE+0
#define DISPID_IHTMLCONTROLELEMENT_ACCESSKEY                      DISPID_SITE+5
#define DISPID_IHTMLCONTROLELEMENT_ONBLUR                         DISPID_EVPROP_ONBLUR
#define DISPID_IHTMLCONTROLELEMENT_ONFOCUS                        DISPID_EVPROP_ONFOCUS
#define DISPID_IHTMLCONTROLELEMENT_ONRESIZE                       DISPID_EVPROP_ONRESIZE
#define DISPID_IHTMLCONTROLELEMENT_BLUR                           DISPID_SITE+2
#define DISPID_IHTMLCONTROLELEMENT_ADDFILTER                      DISPID_SITE+17
#define DISPID_IHTMLCONTROLELEMENT_REMOVEFILTER                   DISPID_SITE+18
#define DISPID_IHTMLCONTROLELEMENT_CLIENTHEIGHT                   DISPID_SITE+19
#define DISPID_IHTMLCONTROLELEMENT_CLIENTWIDTH                    DISPID_SITE+20
#define DISPID_IHTMLCONTROLELEMENT_CLIENTTOP                      DISPID_SITE+21
#define DISPID_IHTMLCONTROLELEMENT_CLIENTLEFT                     DISPID_SITE+22

//    DISPIDs for interface IHTMLTextContainer

#define DISPID_IHTMLTEXTCONTAINER_CREATECONTROLRANGE              DISPID_TEXTSITE+1
#define DISPID_IHTMLTEXTCONTAINER_SCROLLHEIGHT                    DISPID_TEXTSITE+2
#define DISPID_IHTMLTEXTCONTAINER_SCROLLWIDTH                     DISPID_TEXTSITE+3
#define DISPID_IHTMLTEXTCONTAINER_SCROLLTOP                       DISPID_TEXTSITE+4
#define DISPID_IHTMLTEXTCONTAINER_SCROLLLEFT                      DISPID_TEXTSITE+5
#define DISPID_IHTMLTEXTCONTAINER_ONSCROLL                        DISPID_EVPROP_ONSCROLL

//    DISPIDs for event set HTMLTextContainerEvents2

#define DISPID_HTMLTEXTCONTAINEREVENTS2_ONCHANGE                  DISPID_EVMETH_ONCHANGE
#define DISPID_HTMLTEXTCONTAINEREVENTS2_ONSELECT                  DISPID_EVMETH_ONSELECT

//    DISPIDs for event set HTMLTextContainerEvents

#define DISPID_HTMLTEXTCONTAINEREVENTS_ONCHANGE                   DISPID_EVMETH_ONCHANGE
#define DISPID_HTMLTEXTCONTAINEREVENTS_ONSELECT                   DISPID_EVMETH_ONSELECT

//    DISPIDs for interface IHTMLControlRange

#define DISPID_IHTMLCONTROLRANGE_SELECT                           DISPID_RANGE+2
#define DISPID_IHTMLCONTROLRANGE_ADD                              DISPID_RANGE+3
#define DISPID_IHTMLCONTROLRANGE_REMOVE                           DISPID_RANGE+4
#define DISPID_IHTMLCONTROLRANGE_ITEM                             DISPID_VALUE
#define DISPID_IHTMLCONTROLRANGE_SCROLLINTOVIEW                   DISPID_RANGE+6
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDSUPPORTED            DISPID_RANGE+7
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDENABLED              DISPID_RANGE+8
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDSTATE                DISPID_RANGE+9
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDINDETERM             DISPID_RANGE+10
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDTEXT                 DISPID_RANGE+11
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDVALUE                DISPID_RANGE+12
#define DISPID_IHTMLCONTROLRANGE_EXECCOMMAND                      DISPID_RANGE+13
#define DISPID_IHTMLCONTROLRANGE_EXECCOMMANDSHOWHELP              DISPID_RANGE+14
#define DISPID_IHTMLCONTROLRANGE_COMMONPARENTELEMENT              DISPID_RANGE+15
#define DISPID_IHTMLCONTROLRANGE_LENGTH                           DISPID_RANGE+5

//    DISPIDs for interface IHTMLControlRange2

#define DISPID_IHTMLCONTROLRANGE2_ADDELEMENT                      DISPID_RANGE+16

//    DISPIDs for interface IHTMLImgElement

#define DISPID_IHTMLIMGELEMENT_ISMAP                              DISPID_IMG+2
#define DISPID_IHTMLIMGELEMENT_USEMAP                             DISPID_IMG+8
#define DISPID_IHTMLIMGELEMENT_MIMETYPE                           DISPID_IMG+10
#define DISPID_IHTMLIMGELEMENT_FILESIZE                           DISPID_IMG+11
#define DISPID_IHTMLIMGELEMENT_FILECREATEDDATE                    DISPID_IMG+12
#define DISPID_IHTMLIMGELEMENT_FILEMODIFIEDDATE                   DISPID_IMG+13
#define DISPID_IHTMLIMGELEMENT_FILEUPDATEDDATE                    DISPID_IMG+14
#define DISPID_IHTMLIMGELEMENT_PROTOCOL                           DISPID_IMG+15
#define DISPID_IHTMLIMGELEMENT_HREF                               DISPID_IMG+16
#define DISPID_IHTMLIMGELEMENT_NAMEPROP                           DISPID_IMG+17
#define DISPID_IHTMLIMGELEMENT_BORDER                             DISPID_IMGBASE+4
#define DISPID_IHTMLIMGELEMENT_VSPACE                             DISPID_IMGBASE+5
#define DISPID_IHTMLIMGELEMENT_HSPACE                             DISPID_IMGBASE+6
#define DISPID_IHTMLIMGELEMENT_ALT                                DISPID_IMGBASE+2
#define DISPID_IHTMLIMGELEMENT_SRC                                DISPID_IMGBASE+3
#define DISPID_IHTMLIMGELEMENT_LOWSRC                             DISPID_IMGBASE+7
#define DISPID_IHTMLIMGELEMENT_VRML                               DISPID_IMGBASE+8
#define DISPID_IHTMLIMGELEMENT_DYNSRC                             DISPID_IMGBASE+9
#define DISPID_IHTMLIMGELEMENT_READYSTATE                         DISPID_A_READYSTATE
#define DISPID_IHTMLIMGELEMENT_COMPLETE                           DISPID_IMGBASE+10
#define DISPID_IHTMLIMGELEMENT_LOOP                               DISPID_IMGBASE+11
#define DISPID_IHTMLIMGELEMENT_ALIGN                              STDPROPID_XOBJ_CONTROLALIGN
#define DISPID_IHTMLIMGELEMENT_ONLOAD                             DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLIMGELEMENT_ONERROR                            DISPID_EVPROP_ONERROR
#define DISPID_IHTMLIMGELEMENT_ONABORT                            DISPID_EVPROP_ONABORT
#define DISPID_IHTMLIMGELEMENT_NAME                               STDPROPID_XOBJ_NAME
#define DISPID_IHTMLIMGELEMENT_WIDTH                              STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLIMGELEMENT_HEIGHT                             STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLIMGELEMENT_START                              DISPID_IMGBASE+13

//    DISPIDs for interface IHTMLImgElement2

#define DISPID_IHTMLIMGELEMENT2_LONGDESC                          DISPID_IMG+19

//    DISPIDs for interface IHTMLImageElementFactory

#define DISPID_IHTMLIMAGEELEMENTFACTORY_CREATE                    DISPID_VALUE

//    DISPIDs for event set HTMLImgEvents2

#define DISPID_HTMLIMGEVENTS2_ONLOAD                              DISPID_EVMETH_ONLOAD
#define DISPID_HTMLIMGEVENTS2_ONERROR                             DISPID_EVMETH_ONERROR
#define DISPID_HTMLIMGEVENTS2_ONABORT                             DISPID_EVMETH_ONABORT

//    DISPIDs for event set HTMLImgEvents

#define DISPID_HTMLIMGEVENTS_ONLOAD                               DISPID_EVMETH_ONLOAD
#define DISPID_HTMLIMGEVENTS_ONERROR                              DISPID_EVMETH_ONERROR
#define DISPID_HTMLIMGEVENTS_ONABORT                              DISPID_EVMETH_ONABORT

//    DISPIDs for interface IHTMLBodyElement

#define DISPID_IHTMLBODYELEMENT_BACKGROUND                        DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLBODYELEMENT_BGPROPERTIES                      DISPID_A_BACKGROUNDATTACHMENT
#define DISPID_IHTMLBODYELEMENT_LEFTMARGIN                        DISPID_A_MARGINLEFT
#define DISPID_IHTMLBODYELEMENT_TOPMARGIN                         DISPID_A_MARGINTOP
#define DISPID_IHTMLBODYELEMENT_RIGHTMARGIN                       DISPID_A_MARGINRIGHT
#define DISPID_IHTMLBODYELEMENT_BOTTOMMARGIN                      DISPID_A_MARGINBOTTOM
#define DISPID_IHTMLBODYELEMENT_NOWRAP                            DISPID_A_NOWRAP
#define DISPID_IHTMLBODYELEMENT_BGCOLOR                           DISPID_BACKCOLOR
#define DISPID_IHTMLBODYELEMENT_TEXT                              DISPID_A_COLOR
#define DISPID_IHTMLBODYELEMENT_LINK                              DISPID_BODY+10
#define DISPID_IHTMLBODYELEMENT_VLINK                             DISPID_BODY+12
#define DISPID_IHTMLBODYELEMENT_ALINK                             DISPID_BODY+11
#define DISPID_IHTMLBODYELEMENT_ONLOAD                            DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLBODYELEMENT_ONUNLOAD                          DISPID_EVPROP_ONUNLOAD
#define DISPID_IHTMLBODYELEMENT_SCROLL                            DISPID_A_SCROLL
#define DISPID_IHTMLBODYELEMENT_ONSELECT                          DISPID_EVPROP_ONSELECT
#define DISPID_IHTMLBODYELEMENT_ONBEFOREUNLOAD                    DISPID_EVPROP_ONBEFOREUNLOAD
#define DISPID_IHTMLBODYELEMENT_CREATETEXTRANGE                   DISPID_BODY+13

//    DISPIDs for interface IHTMLBodyElement2

#define DISPID_IHTMLBODYELEMENT2_ONBEFOREPRINT                    DISPID_EVPROP_ONBEFOREPRINT
#define DISPID_IHTMLBODYELEMENT2_ONAFTERPRINT                     DISPID_EVPROP_ONAFTERPRINT

//    DISPIDs for interface IHTMLFontElement

#define DISPID_IHTMLFONTELEMENT_COLOR                             DISPID_A_COLOR
#define DISPID_IHTMLFONTELEMENT_FACE                              DISPID_A_FONTFACE
#define DISPID_IHTMLFONTELEMENT_SIZE                              DISPID_A_FONTSIZE

//    DISPIDs for interface IHTMLAnchorElement

#define DISPID_IHTMLANCHORELEMENT_HREF                            DISPID_VALUE
#define DISPID_IHTMLANCHORELEMENT_TARGET                          DISPID_ANCHOR+3
#define DISPID_IHTMLANCHORELEMENT_REL                             DISPID_ANCHOR+5
#define DISPID_IHTMLANCHORELEMENT_REV                             DISPID_ANCHOR+6
#define DISPID_IHTMLANCHORELEMENT_URN                             DISPID_ANCHOR+7
#define DISPID_IHTMLANCHORELEMENT_METHODS                         DISPID_ANCHOR+8
#define DISPID_IHTMLANCHORELEMENT_NAME                            STDPROPID_XOBJ_NAME
#define DISPID_IHTMLANCHORELEMENT_HOST                            DISPID_ANCHOR+12
#define DISPID_IHTMLANCHORELEMENT_HOSTNAME                        DISPID_ANCHOR+13
#define DISPID_IHTMLANCHORELEMENT_PATHNAME                        DISPID_ANCHOR+14
#define DISPID_IHTMLANCHORELEMENT_PORT                            DISPID_ANCHOR+15
#define DISPID_IHTMLANCHORELEMENT_PROTOCOL                        DISPID_ANCHOR+16
#define DISPID_IHTMLANCHORELEMENT_SEARCH                          DISPID_ANCHOR+17
#define DISPID_IHTMLANCHORELEMENT_HASH                            DISPID_ANCHOR+18
#define DISPID_IHTMLANCHORELEMENT_ONBLUR                          DISPID_EVPROP_ONBLUR
#define DISPID_IHTMLANCHORELEMENT_ONFOCUS                         DISPID_EVPROP_ONFOCUS
#define DISPID_IHTMLANCHORELEMENT_ACCESSKEY                       DISPID_SITE+5
#define DISPID_IHTMLANCHORELEMENT_PROTOCOLLONG                    DISPID_ANCHOR+31
#define DISPID_IHTMLANCHORELEMENT_MIMETYPE                        DISPID_ANCHOR+30
#define DISPID_IHTMLANCHORELEMENT_NAMEPROP                        DISPID_ANCHOR+32
#define DISPID_IHTMLANCHORELEMENT_TABINDEX                        STDPROPID_XOBJ_TABINDEX
#define DISPID_IHTMLANCHORELEMENT_FOCUS                           DISPID_SITE+0
#define DISPID_IHTMLANCHORELEMENT_BLUR                            DISPID_SITE+2

//    DISPIDs for interface IHTMLAnchorElement2

#define DISPID_IHTMLANCHORELEMENT2_CHARSET                        DISPID_ANCHOR+23
#define DISPID_IHTMLANCHORELEMENT2_COORDS                         DISPID_ANCHOR+24
#define DISPID_IHTMLANCHORELEMENT2_HREFLANG                       DISPID_ANCHOR+25
#define DISPID_IHTMLANCHORELEMENT2_SHAPE                          DISPID_ANCHOR+26
#define DISPID_IHTMLANCHORELEMENT2_TYPE                           DISPID_ANCHOR+27

//    DISPIDs for interface IHTMLLabelElement

#define DISPID_IHTMLLABELELEMENT_HTMLFOR                          DISPID_LABEL
#define DISPID_IHTMLLABELELEMENT_ACCESSKEY                        DISPID_SITE+5

//    DISPIDs for interface IHTMLLabelElement2

#define DISPID_IHTMLLABELELEMENT2_FORM                            DISPID_LABEL+2

//    DISPIDs for interface IHTMLListElement2

#define DISPID_IHTMLLISTELEMENT2_COMPACT                          DISPID_DIR+1

//    DISPIDs for interface IHTMLUListElement

#define DISPID_IHTMLULISTELEMENT_COMPACT                          DISPID_DIR+1
#define DISPID_IHTMLULISTELEMENT_TYPE                             DISPID_A_LISTTYPE

//    DISPIDs for interface IHTMLOListElement

#define DISPID_IHTMLOLISTELEMENT_COMPACT                          DISPID_DIR+1
#define DISPID_IHTMLOLISTELEMENT_START                            DISPID_OL+3
#define DISPID_IHTMLOLISTELEMENT_TYPE                             DISPID_A_LISTTYPE

//    DISPIDs for interface IHTMLLIElement

#define DISPID_IHTMLLIELEMENT_TYPE                                DISPID_A_LISTTYPE
#define DISPID_IHTMLLIELEMENT_VALUE                               DISPID_LI+1

//    DISPIDs for interface IHTMLBlockElement

#define DISPID_IHTMLBLOCKELEMENT_CLEAR                            DISPID_A_CLEAR

//    DISPIDs for interface IHTMLBlockElement2

#define DISPID_IHTMLBLOCKELEMENT2_CITE                            DISPID_BLOCK+1
#define DISPID_IHTMLBLOCKELEMENT2_WIDTH                           DISPID_BLOCK+2

//    DISPIDs for interface IHTMLDivElement

#define DISPID_IHTMLDIVELEMENT_ALIGN                              STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLDIVELEMENT_NOWRAP                             DISPID_A_NOWRAP

//    DISPIDs for interface IHTMLDDElement

#define DISPID_IHTMLDDELEMENT_NOWRAP                              DISPID_A_NOWRAP

//    DISPIDs for interface IHTMLDTElement

#define DISPID_IHTMLDTELEMENT_NOWRAP                              DISPID_A_NOWRAP

//    DISPIDs for interface IHTMLBRElement

#define DISPID_IHTMLBRELEMENT_CLEAR                               DISPID_A_CLEAR

//    DISPIDs for interface IHTMLDListElement

#define DISPID_IHTMLDLISTELEMENT_COMPACT                          DISPID_DIR+1

//    DISPIDs for interface IHTMLHRElement

#define DISPID_IHTMLHRELEMENT_ALIGN                               STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLHRELEMENT_COLOR                               DISPID_A_COLOR
#define DISPID_IHTMLHRELEMENT_NOSHADE                             DISPID_HR+1
#define DISPID_IHTMLHRELEMENT_WIDTH                               STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLHRELEMENT_SIZE                                STDPROPID_XOBJ_HEIGHT

//    DISPIDs for interface IHTMLParaElement

#define DISPID_IHTMLPARAELEMENT_ALIGN                             STDPROPID_XOBJ_BLOCKALIGN

//    DISPIDs for interface IHTMLElementCollection

#define DISPID_IHTMLELEMENTCOLLECTION_TOSTRING                    DISPID_COLLECTION+1
#define DISPID_IHTMLELEMENTCOLLECTION_LENGTH                      DISPID_COLLECTION
#define DISPID_IHTMLELEMENTCOLLECTION__NEWENUM                    DISPID_NEWENUM
#define DISPID_IHTMLELEMENTCOLLECTION_ITEM                        DISPID_VALUE
#define DISPID_IHTMLELEMENTCOLLECTION_TAGS                        DISPID_COLLECTION+2

//    DISPIDs for interface IHTMLElementCollection2

#define DISPID_IHTMLELEMENTCOLLECTION2_URNS                       DISPID_COLLECTION+5

//    DISPIDs for interface IHTMLElementCollection3

#define DISPID_IHTMLELEMENTCOLLECTION3_NAMEDITEM                  DISPID_COLLECTION+6

//    DISPIDs for interface IHTMLHeaderElement

#define DISPID_IHTMLHEADERELEMENT_ALIGN                           STDPROPID_XOBJ_BLOCKALIGN

//    DISPIDs for interface IHTMLSelectElement

#define DISPID_IHTMLSELECTELEMENT_SIZE                            DISPID_SELECT+2
#define DISPID_IHTMLSELECTELEMENT_MULTIPLE                        DISPID_SELECT+3
#define DISPID_IHTMLSELECTELEMENT_NAME                            STDPROPID_XOBJ_NAME
#define DISPID_IHTMLSELECTELEMENT_OPTIONS                         DISPID_SELECT+5
#define DISPID_IHTMLSELECTELEMENT_ONCHANGE                        DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLSELECTELEMENT_SELECTEDINDEX                   DISPID_SELECT+10
#define DISPID_IHTMLSELECTELEMENT_TYPE                            DISPID_SELECT+12
#define DISPID_IHTMLSELECTELEMENT_VALUE                           DISPID_SELECT+11
#define DISPID_IHTMLSELECTELEMENT_DISABLED                        STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLSELECTELEMENT_FORM                            DISPID_SITE+4
#define DISPID_IHTMLSELECTELEMENT_ADD                             DISPID_COLLECTION+3
#define DISPID_IHTMLSELECTELEMENT_REMOVE                          DISPID_COLLECTION+4
#define DISPID_IHTMLSELECTELEMENT_LENGTH                          DISPID_COLLECTION
#define DISPID_IHTMLSELECTELEMENT__NEWENUM                        DISPID_NEWENUM
#define DISPID_IHTMLSELECTELEMENT_ITEM                            DISPID_VALUE
#define DISPID_IHTMLSELECTELEMENT_TAGS                            DISPID_COLLECTION+2

//    DISPIDs for interface IHTMLSelectElement2

#define DISPID_IHTMLSELECTELEMENT2_URNS                           DISPID_COLLECTION+5

//    DISPIDs for interface IHTMLSelectElement4

#define DISPID_IHTMLSELECTELEMENT4_NAMEDITEM                      DISPID_COLLECTION+6

//    DISPIDs for event set HTMLSelectElementEvents2

#define DISPID_HTMLSELECTELEMENTEVENTS2_ONCHANGE                  DISPID_EVMETH_ONCHANGE

//    DISPIDs for event set HTMLSelectElementEvents

#define DISPID_HTMLSELECTELEMENTEVENTS_ONCHANGE                   DISPID_EVMETH_ONCHANGE

//    DISPIDs for interface IHTMLSelectionObject

#define DISPID_IHTMLSELECTIONOBJECT_CREATERANGE                   DISPID_SELECTOBJ+1
#define DISPID_IHTMLSELECTIONOBJECT_EMPTY                         DISPID_SELECTOBJ+2
#define DISPID_IHTMLSELECTIONOBJECT_CLEAR                         DISPID_SELECTOBJ+3
#define DISPID_IHTMLSELECTIONOBJECT_TYPE                          DISPID_SELECTOBJ+4

//    DISPIDs for interface IHTMLSelectionObject2

#define DISPID_IHTMLSELECTIONOBJECT2_CREATERANGECOLLECTION        DISPID_SELECTOBJ+5
#define DISPID_IHTMLSELECTIONOBJECT2_TYPEDETAIL                   DISPID_SELECTOBJ+6

//    DISPIDs for interface IHTMLOptionElement

#define DISPID_IHTMLOPTIONELEMENT_SELECTED                        DISPID_OPTION+1
#define DISPID_IHTMLOPTIONELEMENT_VALUE                           DISPID_OPTION+2
#define DISPID_IHTMLOPTIONELEMENT_DEFAULTSELECTED                 DISPID_OPTION+3
#define DISPID_IHTMLOPTIONELEMENT_INDEX                           DISPID_OPTION+5
#define DISPID_IHTMLOPTIONELEMENT_TEXT                            DISPID_OPTION+4
#define DISPID_IHTMLOPTIONELEMENT_FORM                            DISPID_OPTION+6

//    DISPIDs for interface IHTMLOptionElement3

#define DISPID_IHTMLOPTIONELEMENT3_LABEL                          DISPID_OPTION+7

//    DISPIDs for interface IHTMLOptionElementFactory

#define DISPID_IHTMLOPTIONELEMENTFACTORY_CREATE                   DISPID_VALUE

//    DISPIDs for interface IHTMLInputElement

#define DISPID_IHTMLINPUTELEMENT_TYPE                             DISPID_INPUT
#define DISPID_IHTMLINPUTELEMENT_VALUE                            DISPID_A_VALUE
#define DISPID_IHTMLINPUTELEMENT_NAME                             STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTELEMENT_STATUS                           DISPID_INPUT+1
#define DISPID_IHTMLINPUTELEMENT_DISABLED                         STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTELEMENT_FORM                             DISPID_SITE+4
#define DISPID_IHTMLINPUTELEMENT_SIZE                             DISPID_INPUT+2
#define DISPID_IHTMLINPUTELEMENT_MAXLENGTH                        DISPID_INPUT+3
#define DISPID_IHTMLINPUTELEMENT_SELECT                           DISPID_INPUT+4
#define DISPID_IHTMLINPUTELEMENT_ONCHANGE                         DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLINPUTELEMENT_ONSELECT                         DISPID_EVPROP_ONSELECT
#define DISPID_IHTMLINPUTELEMENT_DEFAULTVALUE                     DISPID_DEFAULTVALUE
#define DISPID_IHTMLINPUTELEMENT_READONLY                         DISPID_INPUT+5
#define DISPID_IHTMLINPUTELEMENT_CREATETEXTRANGE                  DISPID_INPUT+6
#define DISPID_IHTMLINPUTELEMENT_INDETERMINATE                    DISPID_INPUT+7
#define DISPID_IHTMLINPUTELEMENT_DEFAULTCHECKED                   DISPID_INPUT+8
#define DISPID_IHTMLINPUTELEMENT_CHECKED                          DISPID_INPUT+9
#define DISPID_IHTMLINPUTELEMENT_BORDER                           DISPID_INPUT+12
#define DISPID_IHTMLINPUTELEMENT_VSPACE                           DISPID_INPUT+13
#define DISPID_IHTMLINPUTELEMENT_HSPACE                           DISPID_INPUT+14
#define DISPID_IHTMLINPUTELEMENT_ALT                              DISPID_INPUT+10
#define DISPID_IHTMLINPUTELEMENT_SRC                              DISPID_INPUT+11
#define DISPID_IHTMLINPUTELEMENT_LOWSRC                           DISPID_INPUT+15
#define DISPID_IHTMLINPUTELEMENT_VRML                             DISPID_INPUT+16
#define DISPID_IHTMLINPUTELEMENT_DYNSRC                           DISPID_INPUT+17
#define DISPID_IHTMLINPUTELEMENT_READYSTATE                       DISPID_A_READYSTATE
#define DISPID_IHTMLINPUTELEMENT_COMPLETE                         DISPID_INPUT+18
#define DISPID_IHTMLINPUTELEMENT_LOOP                             DISPID_INPUT+19
#define DISPID_IHTMLINPUTELEMENT_ALIGN                            STDPROPID_XOBJ_CONTROLALIGN
#define DISPID_IHTMLINPUTELEMENT_ONLOAD                           DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLINPUTELEMENT_ONERROR                          DISPID_EVPROP_ONERROR
#define DISPID_IHTMLINPUTELEMENT_ONABORT                          DISPID_EVPROP_ONABORT
#define DISPID_IHTMLINPUTELEMENT_WIDTH                            STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLINPUTELEMENT_HEIGHT                           STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLINPUTELEMENT_START                            DISPID_INPUT+20

//    DISPIDs for interface IHTMLInputElement2

#define DISPID_IHTMLINPUTELEMENT2_ACCEPT                          DISPID_INPUT+22
#define DISPID_IHTMLINPUTELEMENT2_USEMAP                          DISPID_INPUT+23

//    DISPIDs for interface IHTMLInputButtonElement

#define DISPID_IHTMLINPUTBUTTONELEMENT_TYPE                       DISPID_INPUT
#define DISPID_IHTMLINPUTBUTTONELEMENT_VALUE                      DISPID_A_VALUE
#define DISPID_IHTMLINPUTBUTTONELEMENT_NAME                       STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTBUTTONELEMENT_STATUS                     DISPID_INPUT+21
#define DISPID_IHTMLINPUTBUTTONELEMENT_DISABLED                   STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTBUTTONELEMENT_FORM                       DISPID_SITE+4
#define DISPID_IHTMLINPUTBUTTONELEMENT_CREATETEXTRANGE            DISPID_INPUT+6

//    DISPIDs for interface IHTMLInputHiddenElement

#define DISPID_IHTMLINPUTHIDDENELEMENT_TYPE                       DISPID_INPUT
#define DISPID_IHTMLINPUTHIDDENELEMENT_VALUE                      DISPID_A_VALUE
#define DISPID_IHTMLINPUTHIDDENELEMENT_NAME                       STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTHIDDENELEMENT_STATUS                     DISPID_INPUT+21
#define DISPID_IHTMLINPUTHIDDENELEMENT_DISABLED                   STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTHIDDENELEMENT_FORM                       DISPID_SITE+4
#define DISPID_IHTMLINPUTHIDDENELEMENT_CREATETEXTRANGE            DISPID_INPUT+6

//    DISPIDs for interface IHTMLInputTextElement

#define DISPID_IHTMLINPUTTEXTELEMENT_TYPE                         DISPID_INPUT
#define DISPID_IHTMLINPUTTEXTELEMENT_VALUE                        DISPID_A_VALUE
#define DISPID_IHTMLINPUTTEXTELEMENT_NAME                         STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTTEXTELEMENT_STATUS                       DISPID_INPUT+21
#define DISPID_IHTMLINPUTTEXTELEMENT_DISABLED                     STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTTEXTELEMENT_FORM                         DISPID_SITE+4
#define DISPID_IHTMLINPUTTEXTELEMENT_DEFAULTVALUE                 DISPID_DEFAULTVALUE
#define DISPID_IHTMLINPUTTEXTELEMENT_SIZE                         DISPID_INPUT+2
#define DISPID_IHTMLINPUTTEXTELEMENT_MAXLENGTH                    DISPID_INPUT+3
#define DISPID_IHTMLINPUTTEXTELEMENT_SELECT                       DISPID_INPUT+4
#define DISPID_IHTMLINPUTTEXTELEMENT_ONCHANGE                     DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLINPUTTEXTELEMENT_ONSELECT                     DISPID_EVPROP_ONSELECT
#define DISPID_IHTMLINPUTTEXTELEMENT_READONLY                     DISPID_INPUT+5
#define DISPID_IHTMLINPUTTEXTELEMENT_CREATETEXTRANGE              DISPID_INPUT+6

//    DISPIDs for interface IHTMLInputFileElement

#define DISPID_IHTMLINPUTFILEELEMENT_TYPE                         DISPID_INPUT
#define DISPID_IHTMLINPUTFILEELEMENT_NAME                         STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTFILEELEMENT_STATUS                       DISPID_INPUT+21
#define DISPID_IHTMLINPUTFILEELEMENT_DISABLED                     STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTFILEELEMENT_FORM                         DISPID_SITE+4
#define DISPID_IHTMLINPUTFILEELEMENT_SIZE                         DISPID_INPUT+2
#define DISPID_IHTMLINPUTFILEELEMENT_MAXLENGTH                    DISPID_INPUT+3
#define DISPID_IHTMLINPUTFILEELEMENT_SELECT                       DISPID_INPUT+4
#define DISPID_IHTMLINPUTFILEELEMENT_ONCHANGE                     DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLINPUTFILEELEMENT_ONSELECT                     DISPID_EVPROP_ONSELECT
#define DISPID_IHTMLINPUTFILEELEMENT_VALUE                        DISPID_A_VALUE

//    DISPIDs for interface IHTMLOptionButtonElement

#define DISPID_IHTMLOPTIONBUTTONELEMENT_VALUE                     DISPID_A_VALUE
#define DISPID_IHTMLOPTIONBUTTONELEMENT_TYPE                      DISPID_INPUT
#define DISPID_IHTMLOPTIONBUTTONELEMENT_NAME                      STDPROPID_XOBJ_NAME
#define DISPID_IHTMLOPTIONBUTTONELEMENT_CHECKED                   DISPID_INPUT+9
#define DISPID_IHTMLOPTIONBUTTONELEMENT_DEFAULTCHECKED            DISPID_INPUT+8
#define DISPID_IHTMLOPTIONBUTTONELEMENT_ONCHANGE                  DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLOPTIONBUTTONELEMENT_DISABLED                  STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLOPTIONBUTTONELEMENT_STATUS                    DISPID_INPUT+1
#define DISPID_IHTMLOPTIONBUTTONELEMENT_INDETERMINATE             DISPID_INPUT+7
#define DISPID_IHTMLOPTIONBUTTONELEMENT_FORM                      DISPID_SITE+4

//    DISPIDs for interface IHTMLInputImage

#define DISPID_IHTMLINPUTIMAGE_TYPE                               DISPID_INPUT
#define DISPID_IHTMLINPUTIMAGE_DISABLED                           STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTIMAGE_BORDER                             DISPID_INPUT+12
#define DISPID_IHTMLINPUTIMAGE_VSPACE                             DISPID_INPUT+13
#define DISPID_IHTMLINPUTIMAGE_HSPACE                             DISPID_INPUT+14
#define DISPID_IHTMLINPUTIMAGE_ALT                                DISPID_INPUT+10
#define DISPID_IHTMLINPUTIMAGE_SRC                                DISPID_INPUT+11
#define DISPID_IHTMLINPUTIMAGE_LOWSRC                             DISPID_INPUT+15
#define DISPID_IHTMLINPUTIMAGE_VRML                               DISPID_INPUT+16
#define DISPID_IHTMLINPUTIMAGE_DYNSRC                             DISPID_INPUT+17
#define DISPID_IHTMLINPUTIMAGE_READYSTATE                         DISPID_A_READYSTATE
#define DISPID_IHTMLINPUTIMAGE_COMPLETE                           DISPID_INPUT+18
#define DISPID_IHTMLINPUTIMAGE_LOOP                               DISPID_INPUT+19
#define DISPID_IHTMLINPUTIMAGE_ALIGN                              STDPROPID_XOBJ_CONTROLALIGN
#define DISPID_IHTMLINPUTIMAGE_ONLOAD                             DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLINPUTIMAGE_ONERROR                            DISPID_EVPROP_ONERROR
#define DISPID_IHTMLINPUTIMAGE_ONABORT                            DISPID_EVPROP_ONABORT
#define DISPID_IHTMLINPUTIMAGE_NAME                               STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTIMAGE_WIDTH                              STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLINPUTIMAGE_HEIGHT                             STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLINPUTIMAGE_START                              DISPID_INPUT+20

//    DISPIDs for event set HTMLInputTextElementEvents2

#define DISPID_HTMLINPUTTEXTELEMENTEVENTS2_ONCHANGE               DISPID_EVMETH_ONCHANGE
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS2_ONSELECT               DISPID_EVMETH_ONSELECT
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS2_ONLOAD                 DISPID_EVMETH_ONLOAD
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS2_ONERROR                DISPID_EVMETH_ONERROR
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS2_ONABORT                DISPID_EVMETH_ONABORT

//    DISPIDs for event set HTMLInputImageEvents2

#define DISPID_HTMLINPUTIMAGEEVENTS2_ONLOAD                       DISPID_EVMETH_ONLOAD
#define DISPID_HTMLINPUTIMAGEEVENTS2_ONERROR                      DISPID_EVMETH_ONERROR
#define DISPID_HTMLINPUTIMAGEEVENTS2_ONABORT                      DISPID_EVMETH_ONABORT

//    DISPIDs for event set HTMLInputTextElementEvents

#define DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONCHANGE                DISPID_EVMETH_ONCHANGE
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONSELECT                DISPID_EVMETH_ONSELECT
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONLOAD                  DISPID_EVMETH_ONLOAD
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONERROR                 DISPID_EVMETH_ONERROR
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONABORT                 DISPID_EVMETH_ONABORT

//    DISPIDs for event set HTMLInputImageEvents

#define DISPID_HTMLINPUTIMAGEEVENTS_ONLOAD                        DISPID_EVMETH_ONLOAD
#define DISPID_HTMLINPUTIMAGEEVENTS_ONERROR                       DISPID_EVMETH_ONERROR
#define DISPID_HTMLINPUTIMAGEEVENTS_ONABORT                       DISPID_EVMETH_ONABORT

//    DISPIDs for interface IHTMLTextAreaElement

#define DISPID_IHTMLTEXTAREAELEMENT_TYPE                          DISPID_INPUT
#define DISPID_IHTMLTEXTAREAELEMENT_VALUE                         DISPID_A_VALUE
#define DISPID_IHTMLTEXTAREAELEMENT_NAME                          STDPROPID_XOBJ_NAME
#define DISPID_IHTMLTEXTAREAELEMENT_STATUS                        DISPID_INPUT+1
#define DISPID_IHTMLTEXTAREAELEMENT_DISABLED                      STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLTEXTAREAELEMENT_FORM                          DISPID_SITE+4
#define DISPID_IHTMLTEXTAREAELEMENT_DEFAULTVALUE                  DISPID_DEFAULTVALUE
#define DISPID_IHTMLTEXTAREAELEMENT_SELECT                        DISPID_RICHTEXT+5
#define DISPID_IHTMLTEXTAREAELEMENT_ONCHANGE                      DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLTEXTAREAELEMENT_ONSELECT                      DISPID_EVPROP_ONSELECT
#define DISPID_IHTMLTEXTAREAELEMENT_READONLY                      DISPID_RICHTEXT+4
#define DISPID_IHTMLTEXTAREAELEMENT_ROWS                          DISPID_RICHTEXT+1
#define DISPID_IHTMLTEXTAREAELEMENT_COLS                          DISPID_RICHTEXT+2
#define DISPID_IHTMLTEXTAREAELEMENT_WRAP                          DISPID_RICHTEXT+3
#define DISPID_IHTMLTEXTAREAELEMENT_CREATETEXTRANGE               DISPID_RICHTEXT+6

//    DISPIDs for interface IHTMLButtonElement

#define DISPID_IHTMLBUTTONELEMENT_TYPE                            DISPID_INPUT
#define DISPID_IHTMLBUTTONELEMENT_VALUE                           DISPID_A_VALUE
#define DISPID_IHTMLBUTTONELEMENT_NAME                            STDPROPID_XOBJ_NAME
#define DISPID_IHTMLBUTTONELEMENT_STATUS                          DISPID_BUTTON+1
#define DISPID_IHTMLBUTTONELEMENT_DISABLED                        STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLBUTTONELEMENT_FORM                            DISPID_SITE+4
#define DISPID_IHTMLBUTTONELEMENT_CREATETEXTRANGE                 DISPID_BUTTON+2

//    DISPIDs for interface IHTMLMarqueeElement

#define DISPID_IHTMLMARQUEEELEMENT_BGCOLOR                        DISPID_BACKCOLOR
#define DISPID_IHTMLMARQUEEELEMENT_SCROLLDELAY                    DISPID_MARQUEE
#define DISPID_IHTMLMARQUEEELEMENT_DIRECTION                      DISPID_MARQUEE+1
#define DISPID_IHTMLMARQUEEELEMENT_BEHAVIOR                       DISPID_MARQUEE+2
#define DISPID_IHTMLMARQUEEELEMENT_SCROLLAMOUNT                   DISPID_MARQUEE+3
#define DISPID_IHTMLMARQUEEELEMENT_LOOP                           DISPID_MARQUEE+4
#define DISPID_IHTMLMARQUEEELEMENT_VSPACE                         DISPID_MARQUEE+5
#define DISPID_IHTMLMARQUEEELEMENT_HSPACE                         DISPID_MARQUEE+6
#define DISPID_IHTMLMARQUEEELEMENT_ONFINISH                       DISPID_EVPROP_ONFINISH
#define DISPID_IHTMLMARQUEEELEMENT_ONSTART                        DISPID_EVPROP_ONSTART
#define DISPID_IHTMLMARQUEEELEMENT_ONBOUNCE                       DISPID_EVPROP_ONBOUNCE
#define DISPID_IHTMLMARQUEEELEMENT_WIDTH                          STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLMARQUEEELEMENT_HEIGHT                         STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLMARQUEEELEMENT_TRUESPEED                      DISPID_MARQUEE+7
#define DISPID_IHTMLMARQUEEELEMENT_START                          DISPID_MARQUEE+10
#define DISPID_IHTMLMARQUEEELEMENT_STOP                           DISPID_MARQUEE+11

//    DISPIDs for event set HTMLMarqueeElementEvents2

#define DISPID_HTMLMARQUEEELEMENTEVENTS2_ONBOUNCE                 DISPID_EVMETH_ONBOUNCE
#define DISPID_HTMLMARQUEEELEMENTEVENTS2_ONFINISH                 DISPID_EVMETH_ONFINISH
#define DISPID_HTMLMARQUEEELEMENTEVENTS2_ONSTART                  DISPID_EVMETH_ONSTART

//    DISPIDs for event set HTMLMarqueeElementEvents

#define DISPID_HTMLMARQUEEELEMENTEVENTS_ONBOUNCE                  DISPID_EVMETH_ONBOUNCE
#define DISPID_HTMLMARQUEEELEMENTEVENTS_ONFINISH                  DISPID_EVMETH_ONFINISH
#define DISPID_HTMLMARQUEEELEMENTEVENTS_ONSTART                   DISPID_EVMETH_ONSTART

//    DISPIDs for interface IHTMLHtmlElement

#define DISPID_IHTMLHTMLELEMENT_VERSION                           DISPID_HEDELEMS+1

//    DISPIDs for interface IHTMLHeadElement

#define DISPID_IHTMLHEADELEMENT_PROFILE                           DISPID_HEDELEMS+1

//    DISPIDs for interface IHTMLTitleElement

#define DISPID_IHTMLTITLEELEMENT_TEXT                             DISPID_A_VALUE

//    DISPIDs for interface IHTMLMetaElement

#define DISPID_IHTMLMETAELEMENT_HTTPEQUIV                         DISPID_HEDELEMS+1
#define DISPID_IHTMLMETAELEMENT_CONTENT                           DISPID_HEDELEMS+2
#define DISPID_IHTMLMETAELEMENT_NAME                              STDPROPID_XOBJ_NAME
#define DISPID_IHTMLMETAELEMENT_URL                               DISPID_HEDELEMS+3
#define DISPID_IHTMLMETAELEMENT_CHARSET                           DISPID_HEDELEMS+13

//    DISPIDs for interface IHTMLMetaElement2

#define DISPID_IHTMLMETAELEMENT2_SCHEME                           DISPID_HEDELEMS+20

//    DISPIDs for interface IHTMLBaseElement

#define DISPID_IHTMLBASEELEMENT_HREF                              DISPID_HEDELEMS+3
#define DISPID_IHTMLBASEELEMENT_TARGET                            DISPID_HEDELEMS+4

//    DISPIDs for interface IHTMLIsIndexElement

#define DISPID_IHTMLISINDEXELEMENT_PROMPT                         DISPID_HEDELEMS+10
#define DISPID_IHTMLISINDEXELEMENT_ACTION                         DISPID_HEDELEMS+11

//    DISPIDs for interface IHTMLIsIndexElement2

#define DISPID_IHTMLISINDEXELEMENT2_FORM                          DISPID_HEDELEMS+12

//    DISPIDs for interface IHTMLNextIdElement

#define DISPID_IHTMLNEXTIDELEMENT_N                               DISPID_HEDELEMS+12

//    DISPIDs for interface IHTMLBaseFontElement

#define DISPID_IHTMLBASEFONTELEMENT_COLOR                         DISPID_A_COLOR
#define DISPID_IHTMLBASEFONTELEMENT_FACE                          DISPID_A_FONTFACE
#define DISPID_IHTMLBASEFONTELEMENT_SIZE                          DISPID_A_BASEFONT

//    DISPIDs for interface IOmHistory

#define DISPID_IOMHISTORY_LENGTH                                  DISPID_HISTORY
#define DISPID_IOMHISTORY_BACK                                    DISPID_HISTORY+1
#define DISPID_IOMHISTORY_FORWARD                                 DISPID_HISTORY+2
#define DISPID_IOMHISTORY_GO                                      DISPID_HISTORY+3

//    DISPIDs for interface IHTMLMimeTypesCollection

#define DISPID_IHTMLMIMETYPESCOLLECTION_LENGTH                    1

//    DISPIDs for interface IHTMLPluginsCollection

#define DISPID_IHTMLPLUGINSCOLLECTION_LENGTH                      1
#define DISPID_IHTMLPLUGINSCOLLECTION_REFRESH                     2

//    DISPIDs for interface IHTMLOpsProfile

#define DISPID_IHTMLOPSPROFILE_ADDREQUEST                         1
#define DISPID_IHTMLOPSPROFILE_CLEARREQUEST                       2
#define DISPID_IHTMLOPSPROFILE_DOREQUEST                          3
#define DISPID_IHTMLOPSPROFILE_GETATTRIBUTE                       4
#define DISPID_IHTMLOPSPROFILE_SETATTRIBUTE                       5
#define DISPID_IHTMLOPSPROFILE_COMMITCHANGES                      6
#define DISPID_IHTMLOPSPROFILE_ADDREADREQUEST                     7
#define DISPID_IHTMLOPSPROFILE_DOREADREQUEST                      8
#define DISPID_IHTMLOPSPROFILE_DOWRITEREQUEST                     9

//    DISPIDs for interface IOmNavigator

#define DISPID_IOMNAVIGATOR_APPCODENAME                           DISPID_NAVIGATOR
#define DISPID_IOMNAVIGATOR_APPNAME                               DISPID_NAVIGATOR+1
#define DISPID_IOMNAVIGATOR_APPVERSION                            DISPID_NAVIGATOR+2
#define DISPID_IOMNAVIGATOR_USERAGENT                             DISPID_NAVIGATOR+3
#define DISPID_IOMNAVIGATOR_JAVAENABLED                           DISPID_NAVIGATOR+4
#define DISPID_IOMNAVIGATOR_TAINTENABLED                          DISPID_NAVIGATOR+5
#define DISPID_IOMNAVIGATOR_MIMETYPES                             DISPID_NAVIGATOR+6
#define DISPID_IOMNAVIGATOR_PLUGINS                               DISPID_NAVIGATOR+7
#define DISPID_IOMNAVIGATOR_COOKIEENABLED                         DISPID_NAVIGATOR+8
#define DISPID_IOMNAVIGATOR_OPSPROFILE                            DISPID_NAVIGATOR+9
#define DISPID_IOMNAVIGATOR_TOSTRING                              DISPID_NAVIGATOR+10
#define DISPID_IOMNAVIGATOR_CPUCLASS                              DISPID_NAVIGATOR+11
#define DISPID_IOMNAVIGATOR_SYSTEMLANGUAGE                        DISPID_NAVIGATOR+12
#define DISPID_IOMNAVIGATOR_BROWSERLANGUAGE                       DISPID_NAVIGATOR+13
#define DISPID_IOMNAVIGATOR_USERLANGUAGE                          DISPID_NAVIGATOR+14
#define DISPID_IOMNAVIGATOR_PLATFORM                              DISPID_NAVIGATOR+15
#define DISPID_IOMNAVIGATOR_APPMINORVERSION                       DISPID_NAVIGATOR+16
#define DISPID_IOMNAVIGATOR_CONNECTIONSPEED                       DISPID_NAVIGATOR+17
#define DISPID_IOMNAVIGATOR_ONLINE                                DISPID_NAVIGATOR+18
#define DISPID_IOMNAVIGATOR_USERPROFILE                           DISPID_NAVIGATOR+19

//    DISPIDs for interface IHTMLLocation

#define DISPID_IHTMLLOCATION_HREF                                 DISPID_VALUE
#define DISPID_IHTMLLOCATION_PROTOCOL                             DISPID_LOCATION
#define DISPID_IHTMLLOCATION_HOST                                 DISPID_LOCATION+1
#define DISPID_IHTMLLOCATION_HOSTNAME                             DISPID_LOCATION+2
#define DISPID_IHTMLLOCATION_PORT                                 DISPID_LOCATION+3
#define DISPID_IHTMLLOCATION_PATHNAME                             DISPID_LOCATION+4
#define DISPID_IHTMLLOCATION_SEARCH                               DISPID_LOCATION+5
#define DISPID_IHTMLLOCATION_HASH                                 DISPID_LOCATION+6
#define DISPID_IHTMLLOCATION_RELOAD                               DISPID_LOCATION+7
#define DISPID_IHTMLLOCATION_REPLACE                              DISPID_LOCATION+8
#define DISPID_IHTMLLOCATION_ASSIGN                               DISPID_LOCATION+9
#define DISPID_IHTMLLOCATION_TOSTRING                             DISPID_LOCATION+10

//    DISPIDs for interface IHTMLBookmarkCollection

#define DISPID_IHTMLBOOKMARKCOLLECTION_LENGTH                     DISPID_OPTIONS_COL+1
#define DISPID_IHTMLBOOKMARKCOLLECTION__NEWENUM                   DISPID_NEWENUM
#define DISPID_IHTMLBOOKMARKCOLLECTION_ITEM                       DISPID_VALUE

//    DISPIDs for interface IHTMLDataTransfer

#define DISPID_IHTMLDATATRANSFER_SETDATA                          DISPID_DATATRANSFER+1
#define DISPID_IHTMLDATATRANSFER_GETDATA                          DISPID_DATATRANSFER+2
#define DISPID_IHTMLDATATRANSFER_CLEARDATA                        DISPID_DATATRANSFER+3
#define DISPID_IHTMLDATATRANSFER_DROPEFFECT                       DISPID_DATATRANSFER+4
#define DISPID_IHTMLDATATRANSFER_EFFECTALLOWED                    DISPID_DATATRANSFER+5

//    DISPIDs for interface IHTMLEventObj

#define DISPID_IHTMLEVENTOBJ_SRCELEMENT                           DISPID_EVENTOBJ+1
#define DISPID_IHTMLEVENTOBJ_ALTKEY                               DISPID_EVENTOBJ+2
#define DISPID_IHTMLEVENTOBJ_CTRLKEY                              DISPID_EVENTOBJ+3
#define DISPID_IHTMLEVENTOBJ_SHIFTKEY                             DISPID_EVENTOBJ+4
#define DISPID_IHTMLEVENTOBJ_RETURNVALUE                          DISPID_EVENTOBJ+7
#define DISPID_IHTMLEVENTOBJ_CANCELBUBBLE                         DISPID_EVENTOBJ+8
#define DISPID_IHTMLEVENTOBJ_FROMELEMENT                          DISPID_EVENTOBJ+9
#define DISPID_IHTMLEVENTOBJ_TOELEMENT                            DISPID_EVENTOBJ+10
#define DISPID_IHTMLEVENTOBJ_KEYCODE                              DISPID_EVENTOBJ+11
#define DISPID_IHTMLEVENTOBJ_BUTTON                               DISPID_EVENTOBJ+12
#define DISPID_IHTMLEVENTOBJ_TYPE                                 DISPID_EVENTOBJ+13
#define DISPID_IHTMLEVENTOBJ_QUALIFIER                            DISPID_EVENTOBJ+14
#define DISPID_IHTMLEVENTOBJ_REASON                               DISPID_EVENTOBJ+15
#define DISPID_IHTMLEVENTOBJ_X                                    DISPID_EVENTOBJ+5
#define DISPID_IHTMLEVENTOBJ_Y                                    DISPID_EVENTOBJ+6
#define DISPID_IHTMLEVENTOBJ_CLIENTX                              DISPID_EVENTOBJ+20
#define DISPID_IHTMLEVENTOBJ_CLIENTY                              DISPID_EVENTOBJ+21
#define DISPID_IHTMLEVENTOBJ_OFFSETX                              DISPID_EVENTOBJ+22
#define DISPID_IHTMLEVENTOBJ_OFFSETY                              DISPID_EVENTOBJ+23
#define DISPID_IHTMLEVENTOBJ_SCREENX                              DISPID_EVENTOBJ+24
#define DISPID_IHTMLEVENTOBJ_SCREENY                              DISPID_EVENTOBJ+25
#define DISPID_IHTMLEVENTOBJ_SRCFILTER                            DISPID_EVENTOBJ+26

//    DISPIDs for interface IHTMLEventObj2

#define DISPID_IHTMLEVENTOBJ2_SETATTRIBUTE                        DISPID_HTMLOBJECT+1
#define DISPID_IHTMLEVENTOBJ2_GETATTRIBUTE                        DISPID_HTMLOBJECT+2
#define DISPID_IHTMLEVENTOBJ2_REMOVEATTRIBUTE                     DISPID_HTMLOBJECT+3
#define DISPID_IHTMLEVENTOBJ2_PROPERTYNAME                        DISPID_EVENTOBJ+27
#define DISPID_IHTMLEVENTOBJ2_BOOKMARKS                           DISPID_EVENTOBJ+31
#define DISPID_IHTMLEVENTOBJ2_RECORDSET                           DISPID_EVENTOBJ+32
#define DISPID_IHTMLEVENTOBJ2_DATAFLD                             DISPID_EVENTOBJ+33
#define DISPID_IHTMLEVENTOBJ2_BOUNDELEMENTS                       DISPID_EVENTOBJ+34
#define DISPID_IHTMLEVENTOBJ2_REPEAT                              DISPID_EVENTOBJ+35
#define DISPID_IHTMLEVENTOBJ2_SRCURN                              DISPID_EVENTOBJ+36
#define DISPID_IHTMLEVENTOBJ2_SRCELEMENT                          DISPID_EVENTOBJ+1
#define DISPID_IHTMLEVENTOBJ2_ALTKEY                              DISPID_EVENTOBJ+2
#define DISPID_IHTMLEVENTOBJ2_CTRLKEY                             DISPID_EVENTOBJ+3
#define DISPID_IHTMLEVENTOBJ2_SHIFTKEY                            DISPID_EVENTOBJ+4
#define DISPID_IHTMLEVENTOBJ2_FROMELEMENT                         DISPID_EVENTOBJ+9
#define DISPID_IHTMLEVENTOBJ2_TOELEMENT                           DISPID_EVENTOBJ+10
#define DISPID_IHTMLEVENTOBJ2_BUTTON                              DISPID_EVENTOBJ+12
#define DISPID_IHTMLEVENTOBJ2_TYPE                                DISPID_EVENTOBJ+13
#define DISPID_IHTMLEVENTOBJ2_QUALIFIER                           DISPID_EVENTOBJ+14
#define DISPID_IHTMLEVENTOBJ2_REASON                              DISPID_EVENTOBJ+15
#define DISPID_IHTMLEVENTOBJ2_X                                   DISPID_EVENTOBJ+5
#define DISPID_IHTMLEVENTOBJ2_Y                                   DISPID_EVENTOBJ+6
#define DISPID_IHTMLEVENTOBJ2_CLIENTX                             DISPID_EVENTOBJ+20
#define DISPID_IHTMLEVENTOBJ2_CLIENTY                             DISPID_EVENTOBJ+21
#define DISPID_IHTMLEVENTOBJ2_OFFSETX                             DISPID_EVENTOBJ+22
#define DISPID_IHTMLEVENTOBJ2_OFFSETY                             DISPID_EVENTOBJ+23
#define DISPID_IHTMLEVENTOBJ2_SCREENX                             DISPID_EVENTOBJ+24
#define DISPID_IHTMLEVENTOBJ2_SCREENY                             DISPID_EVENTOBJ+25
#define DISPID_IHTMLEVENTOBJ2_SRCFILTER                           DISPID_EVENTOBJ+26
#define DISPID_IHTMLEVENTOBJ2_DATATRANSFER                        DISPID_EVENTOBJ+37

//    DISPIDs for interface IHTMLEventObj3

#define DISPID_IHTMLEVENTOBJ3_CONTENTOVERFLOW                     DISPID_EVENTOBJ+38
#define DISPID_IHTMLEVENTOBJ3_SHIFTLEFT                           DISPID_EVENTOBJ+39
#define DISPID_IHTMLEVENTOBJ3_ALTLEFT                             DISPID_EVENTOBJ+40
#define DISPID_IHTMLEVENTOBJ3_CTRLLEFT                            DISPID_EVENTOBJ+41
#define DISPID_IHTMLEVENTOBJ3_IMECOMPOSITIONCHANGE                DISPID_EVENTOBJ+42
#define DISPID_IHTMLEVENTOBJ3_IMENOTIFYCOMMAND                    DISPID_EVENTOBJ+43
#define DISPID_IHTMLEVENTOBJ3_IMENOTIFYDATA                       DISPID_EVENTOBJ+44
#define DISPID_IHTMLEVENTOBJ3_IMEREQUEST                          DISPID_EVENTOBJ+46
#define DISPID_IHTMLEVENTOBJ3_IMEREQUESTDATA                      DISPID_EVENTOBJ+47
#define DISPID_IHTMLEVENTOBJ3_KEYBOARDLAYOUT                      DISPID_EVENTOBJ+45
#define DISPID_IHTMLEVENTOBJ3_BEHAVIORCOOKIE                      DISPID_EVENTOBJ+48
#define DISPID_IHTMLEVENTOBJ3_BEHAVIORPART                        DISPID_EVENTOBJ+49
#define DISPID_IHTMLEVENTOBJ3_NEXTPAGE                            DISPID_EVENTOBJ+50

//    DISPIDs for interface IHTMLEventObj4

#define DISPID_IHTMLEVENTOBJ4_WHEELDELTA                          DISPID_EVENTOBJ+51

//    DISPIDs for interface IHTMLFramesCollection2

#define DISPID_IHTMLFRAMESCOLLECTION2_ITEM                        0
#define DISPID_IHTMLFRAMESCOLLECTION2_LENGTH                      1001

//    DISPIDs for interface IHTMLScreen

#define DISPID_IHTMLSCREEN_COLORDEPTH                             DISPID_SCREEN+1
#define DISPID_IHTMLSCREEN_BUFFERDEPTH                            DISPID_SCREEN+2
#define DISPID_IHTMLSCREEN_WIDTH                                  DISPID_SCREEN+3
#define DISPID_IHTMLSCREEN_HEIGHT                                 DISPID_SCREEN+4
#define DISPID_IHTMLSCREEN_UPDATEINTERVAL                         DISPID_SCREEN+5
#define DISPID_IHTMLSCREEN_AVAILHEIGHT                            DISPID_SCREEN+6
#define DISPID_IHTMLSCREEN_AVAILWIDTH                             DISPID_SCREEN+7
#define DISPID_IHTMLSCREEN_FONTSMOOTHINGENABLED                   DISPID_SCREEN+8

//    DISPIDs for interface IHTMLScreen2

#define DISPID_IHTMLSCREEN2_LOGICALXDPI                           DISPID_SCREEN+9
#define DISPID_IHTMLSCREEN2_LOGICALYDPI                           DISPID_SCREEN+10
#define DISPID_IHTMLSCREEN2_DEVICEXDPI                            DISPID_SCREEN+11
#define DISPID_IHTMLSCREEN2_DEVICEYDPI                            DISPID_SCREEN+12

//    DISPIDs for interface IHTMLWindow2

#define DISPID_IHTMLWINDOW2_FRAMES                                1100
#define DISPID_IHTMLWINDOW2_DEFAULTSTATUS                         1101
#define DISPID_IHTMLWINDOW2_STATUS                                1102
#define DISPID_IHTMLWINDOW2_SETTIMEOUT                            1172
#define DISPID_IHTMLWINDOW2_CLEARTIMEOUT                          1104
#define DISPID_IHTMLWINDOW2_ALERT                                 1105
#define DISPID_IHTMLWINDOW2_CONFIRM                               1110
#define DISPID_IHTMLWINDOW2_PROMPT                                1111
#define DISPID_IHTMLWINDOW2_IMAGE                                 1125
#define DISPID_IHTMLWINDOW2_LOCATION                              14
#define DISPID_IHTMLWINDOW2_HISTORY                               2
#define DISPID_IHTMLWINDOW2_CLOSE                                 3
#define DISPID_IHTMLWINDOW2_OPENER                                4
#define DISPID_IHTMLWINDOW2_NAVIGATOR                             5
#define DISPID_IHTMLWINDOW2_NAME                                  11
#define DISPID_IHTMLWINDOW2_PARENT                                12
#define DISPID_IHTMLWINDOW2_OPEN                                  13
#define DISPID_IHTMLWINDOW2_SELF                                  20
#define DISPID_IHTMLWINDOW2_TOP                                   21
#define DISPID_IHTMLWINDOW2_WINDOW                                22
#define DISPID_IHTMLWINDOW2_NAVIGATE                              25
#define DISPID_IHTMLWINDOW2_ONFOCUS                               DISPID_EVPROP_ONFOCUS
#define DISPID_IHTMLWINDOW2_ONBLUR                                DISPID_EVPROP_ONBLUR
#define DISPID_IHTMLWINDOW2_ONLOAD                                DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLWINDOW2_ONBEFOREUNLOAD                        DISPID_EVPROP_ONBEFOREUNLOAD
#define DISPID_IHTMLWINDOW2_ONUNLOAD                              DISPID_EVPROP_ONUNLOAD
#define DISPID_IHTMLWINDOW2_ONHELP                                DISPID_EVPROP_ONHELP
#define DISPID_IHTMLWINDOW2_ONERROR                               DISPID_EVPROP_ONERROR
#define DISPID_IHTMLWINDOW2_ONRESIZE                              DISPID_EVPROP_ONRESIZE
#define DISPID_IHTMLWINDOW2_ONSCROLL                              DISPID_EVPROP_ONSCROLL
#define DISPID_IHTMLWINDOW2_DOCUMENT                              1151
#define DISPID_IHTMLWINDOW2_EVENT                                 1152
#define DISPID_IHTMLWINDOW2__NEWENUM                              1153
#define DISPID_IHTMLWINDOW2_SHOWMODALDIALOG                       1154
#define DISPID_IHTMLWINDOW2_SHOWHELP                              1155
#define DISPID_IHTMLWINDOW2_SCREEN                                1156
#define DISPID_IHTMLWINDOW2_OPTION                                1157
#define DISPID_IHTMLWINDOW2_FOCUS                                 1158
#define DISPID_IHTMLWINDOW2_CLOSED                                23
#define DISPID_IHTMLWINDOW2_BLUR                                  1159
#define DISPID_IHTMLWINDOW2_SCROLL                                1160
#define DISPID_IHTMLWINDOW2_CLIENTINFORMATION                     1161
#define DISPID_IHTMLWINDOW2_SETINTERVAL                           1173
#define DISPID_IHTMLWINDOW2_CLEARINTERVAL                         1163
#define DISPID_IHTMLWINDOW2_OFFSCREENBUFFERING                    1164
#define DISPID_IHTMLWINDOW2_EXECSCRIPT                            1165
#define DISPID_IHTMLWINDOW2_TOSTRING                              1166
#define DISPID_IHTMLWINDOW2_SCROLLBY                              1167
#define DISPID_IHTMLWINDOW2_SCROLLTO                              1168
#define DISPID_IHTMLWINDOW2_MOVETO                                6
#define DISPID_IHTMLWINDOW2_MOVEBY                                7
#define DISPID_IHTMLWINDOW2_RESIZETO                              9
#define DISPID_IHTMLWINDOW2_RESIZEBY                              8
#define DISPID_IHTMLWINDOW2_EXTERNAL                              1169

//    DISPIDs for interface IHTMLWindow3

#define DISPID_IHTMLWINDOW3_SCREENLEFT                            1170
#define DISPID_IHTMLWINDOW3_SCREENTOP                             1171
#define DISPID_IHTMLWINDOW3_ATTACHEVENT                           DISPID_HTMLOBJECT+7
#define DISPID_IHTMLWINDOW3_DETACHEVENT                           DISPID_HTMLOBJECT+8
#define DISPID_IHTMLWINDOW3_SETTIMEOUT                            1103
#define DISPID_IHTMLWINDOW3_SETINTERVAL                           1162
#define DISPID_IHTMLWINDOW3_PRINT                                 1174
#define DISPID_IHTMLWINDOW3_ONBEFOREPRINT                         DISPID_EVPROP_ONBEFOREPRINT
#define DISPID_IHTMLWINDOW3_ONAFTERPRINT                          DISPID_EVPROP_ONAFTERPRINT
#define DISPID_IHTMLWINDOW3_CLIPBOARDDATA                         1175
#define DISPID_IHTMLWINDOW3_SHOWMODELESSDIALOG                    1176

//    DISPIDs for interface IHTMLWindow4

#define DISPID_IHTMLWINDOW4_CREATEPOPUP                           1180
#define DISPID_IHTMLWINDOW4_FRAMEELEMENT                          1181

//    DISPIDs for event set HTMLWindowEvents2

#define DISPID_HTMLWINDOWEVENTS2_ONLOAD                           DISPID_EVMETH_ONLOAD
#define DISPID_HTMLWINDOWEVENTS2_ONUNLOAD                         DISPID_EVMETH_ONUNLOAD
#define DISPID_HTMLWINDOWEVENTS2_ONHELP                           DISPID_EVMETH_ONHELP
#define DISPID_HTMLWINDOWEVENTS2_ONFOCUS                          DISPID_EVMETH_ONFOCUS
#define DISPID_HTMLWINDOWEVENTS2_ONBLUR                           DISPID_EVMETH_ONBLUR
#define DISPID_HTMLWINDOWEVENTS2_ONERROR                          DISPID_EVMETH_ONERROR
#define DISPID_HTMLWINDOWEVENTS2_ONRESIZE                         DISPID_EVMETH_ONRESIZE
#define DISPID_HTMLWINDOWEVENTS2_ONSCROLL                         DISPID_EVMETH_ONSCROLL
#define DISPID_HTMLWINDOWEVENTS2_ONBEFOREUNLOAD                   DISPID_EVMETH_ONBEFOREUNLOAD
#define DISPID_HTMLWINDOWEVENTS2_ONBEFOREPRINT                    DISPID_EVMETH_ONBEFOREPRINT
#define DISPID_HTMLWINDOWEVENTS2_ONAFTERPRINT                     DISPID_EVMETH_ONAFTERPRINT

//    DISPIDs for event set HTMLWindowEvents

#define DISPID_HTMLWINDOWEVENTS_ONLOAD                            DISPID_EVMETH_ONLOAD
#define DISPID_HTMLWINDOWEVENTS_ONUNLOAD                          DISPID_EVMETH_ONUNLOAD
#define DISPID_HTMLWINDOWEVENTS_ONHELP                            DISPID_EVMETH_ONHELP
#define DISPID_HTMLWINDOWEVENTS_ONFOCUS                           DISPID_EVMETH_ONFOCUS
#define DISPID_HTMLWINDOWEVENTS_ONBLUR                            DISPID_EVMETH_ONBLUR
#define DISPID_HTMLWINDOWEVENTS_ONERROR                           DISPID_EVMETH_ONERROR
#define DISPID_HTMLWINDOWEVENTS_ONRESIZE                          DISPID_EVMETH_ONRESIZE
#define DISPID_HTMLWINDOWEVENTS_ONSCROLL                          DISPID_EVMETH_ONSCROLL
#define DISPID_HTMLWINDOWEVENTS_ONBEFOREUNLOAD                    DISPID_EVMETH_ONBEFOREUNLOAD
#define DISPID_HTMLWINDOWEVENTS_ONBEFOREPRINT                     DISPID_EVMETH_ONBEFOREPRINT
#define DISPID_HTMLWINDOWEVENTS_ONAFTERPRINT                      DISPID_EVMETH_ONAFTERPRINT

//    DISPIDs for interface IHTMLDocument

#define DISPID_IHTMLDOCUMENT_SCRIPT                               DISPID_OMDOCUMENT+1

//    DISPIDs for interface IHTMLDocument2

#define DISPID_IHTMLDOCUMENT2_ALL                                 DISPID_OMDOCUMENT+3
#define DISPID_IHTMLDOCUMENT2_BODY                                DISPID_OMDOCUMENT+4
#define DISPID_IHTMLDOCUMENT2_ACTIVEELEMENT                       DISPID_OMDOCUMENT+5
#define DISPID_IHTMLDOCUMENT2_IMAGES                              DISPID_OMDOCUMENT+11
#define DISPID_IHTMLDOCUMENT2_APPLETS                             DISPID_OMDOCUMENT+8
#define DISPID_IHTMLDOCUMENT2_LINKS                               DISPID_OMDOCUMENT+9
#define DISPID_IHTMLDOCUMENT2_FORMS                               DISPID_OMDOCUMENT+10
#define DISPID_IHTMLDOCUMENT2_ANCHORS                             DISPID_OMDOCUMENT+7
#define DISPID_IHTMLDOCUMENT2_TITLE                               DISPID_OMDOCUMENT+12
#define DISPID_IHTMLDOCUMENT2_SCRIPTS                             DISPID_OMDOCUMENT+13
#define DISPID_IHTMLDOCUMENT2_DESIGNMODE                          DISPID_OMDOCUMENT+14
#define DISPID_IHTMLDOCUMENT2_SELECTION                           DISPID_OMDOCUMENT+17
#define DISPID_IHTMLDOCUMENT2_READYSTATE                          DISPID_OMDOCUMENT+18
#define DISPID_IHTMLDOCUMENT2_FRAMES                              DISPID_OMDOCUMENT+19
#define DISPID_IHTMLDOCUMENT2_EMBEDS                              DISPID_OMDOCUMENT+15
#define DISPID_IHTMLDOCUMENT2_PLUGINS                             DISPID_OMDOCUMENT+21
#define DISPID_IHTMLDOCUMENT2_ALINKCOLOR                          DISPID_OMDOCUMENT+22
#define DISPID_IHTMLDOCUMENT2_BGCOLOR                             DISPID_BACKCOLOR
#define DISPID_IHTMLDOCUMENT2_FGCOLOR                             DISPID_A_COLOR
#define DISPID_IHTMLDOCUMENT2_LINKCOLOR                           DISPID_OMDOCUMENT+24
#define DISPID_IHTMLDOCUMENT2_VLINKCOLOR                          DISPID_OMDOCUMENT+23
#define DISPID_IHTMLDOCUMENT2_REFERRER                            DISPID_OMDOCUMENT+27
#define DISPID_IHTMLDOCUMENT2_LOCATION                            DISPID_OMDOCUMENT+26
#define DISPID_IHTMLDOCUMENT2_LASTMODIFIED                        DISPID_OMDOCUMENT+28
#define DISPID_IHTMLDOCUMENT2_URL                                 DISPID_OMDOCUMENT+25
#define DISPID_IHTMLDOCUMENT2_DOMAIN                              DISPID_OMDOCUMENT+29
#define DISPID_IHTMLDOCUMENT2_COOKIE                              DISPID_OMDOCUMENT+30
#define DISPID_IHTMLDOCUMENT2_EXPANDO                             DISPID_OMDOCUMENT+31
#define DISPID_IHTMLDOCUMENT2_CHARSET                             DISPID_OMDOCUMENT+32
#define DISPID_IHTMLDOCUMENT2_DEFAULTCHARSET                      DISPID_OMDOCUMENT+33
#define DISPID_IHTMLDOCUMENT2_MIMETYPE                            DISPID_OMDOCUMENT+41
#define DISPID_IHTMLDOCUMENT2_FILESIZE                            DISPID_OMDOCUMENT+42
#define DISPID_IHTMLDOCUMENT2_FILECREATEDDATE                     DISPID_OMDOCUMENT+43
#define DISPID_IHTMLDOCUMENT2_FILEMODIFIEDDATE                    DISPID_OMDOCUMENT+44
#define DISPID_IHTMLDOCUMENT2_FILEUPDATEDDATE                     DISPID_OMDOCUMENT+45
#define DISPID_IHTMLDOCUMENT2_SECURITY                            DISPID_OMDOCUMENT+46
#define DISPID_IHTMLDOCUMENT2_PROTOCOL                            DISPID_OMDOCUMENT+47
#define DISPID_IHTMLDOCUMENT2_NAMEPROP                            DISPID_OMDOCUMENT+48
#define DISPID_IHTMLDOCUMENT2_WRITE                               DISPID_OMDOCUMENT+54
#define DISPID_IHTMLDOCUMENT2_WRITELN                             DISPID_OMDOCUMENT+55
#define DISPID_IHTMLDOCUMENT2_OPEN                                DISPID_OMDOCUMENT+56
#define DISPID_IHTMLDOCUMENT2_CLOSE                               DISPID_OMDOCUMENT+57
#define DISPID_IHTMLDOCUMENT2_CLEAR                               DISPID_OMDOCUMENT+58
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDSUPPORTED               DISPID_OMDOCUMENT+59
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDENABLED                 DISPID_OMDOCUMENT+60
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDSTATE                   DISPID_OMDOCUMENT+61
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDINDETERM                DISPID_OMDOCUMENT+62
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDTEXT                    DISPID_OMDOCUMENT+63
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDVALUE                   DISPID_OMDOCUMENT+64
#define DISPID_IHTMLDOCUMENT2_EXECCOMMAND                         DISPID_OMDOCUMENT+65
#define DISPID_IHTMLDOCUMENT2_EXECCOMMANDSHOWHELP                 DISPID_OMDOCUMENT+66
#define DISPID_IHTMLDOCUMENT2_CREATEELEMENT                       DISPID_OMDOCUMENT+67
#define DISPID_IHTMLDOCUMENT2_ONHELP                              DISPID_EVPROP_ONHELP
#define DISPID_IHTMLDOCUMENT2_ONCLICK                             DISPID_EVPROP_ONCLICK
#define DISPID_IHTMLDOCUMENT2_ONDBLCLICK                          DISPID_EVPROP_ONDBLCLICK
#define DISPID_IHTMLDOCUMENT2_ONKEYUP                             DISPID_EVPROP_ONKEYUP
#define DISPID_IHTMLDOCUMENT2_ONKEYDOWN                           DISPID_EVPROP_ONKEYDOWN
#define DISPID_IHTMLDOCUMENT2_ONKEYPRESS                          DISPID_EVPROP_ONKEYPRESS
#define DISPID_IHTMLDOCUMENT2_ONMOUSEUP                           DISPID_EVPROP_ONMOUSEUP
#define DISPID_IHTMLDOCUMENT2_ONMOUSEDOWN                         DISPID_EVPROP_ONMOUSEDOWN
#define DISPID_IHTMLDOCUMENT2_ONMOUSEMOVE                         DISPID_EVPROP_ONMOUSEMOVE
#define DISPID_IHTMLDOCUMENT2_ONMOUSEOUT                          DISPID_EVPROP_ONMOUSEOUT
#define DISPID_IHTMLDOCUMENT2_ONMOUSEOVER                         DISPID_EVPROP_ONMOUSEOVER
#define DISPID_IHTMLDOCUMENT2_ONREADYSTATECHANGE                  DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLDOCUMENT2_ONAFTERUPDATE                       DISPID_EVPROP_ONAFTERUPDATE
#define DISPID_IHTMLDOCUMENT2_ONROWEXIT                           DISPID_EVPROP_ONROWEXIT
#define DISPID_IHTMLDOCUMENT2_ONROWENTER                          DISPID_EVPROP_ONROWENTER
#define DISPID_IHTMLDOCUMENT2_ONDRAGSTART                         DISPID_EVPROP_ONDRAGSTART
#define DISPID_IHTMLDOCUMENT2_ONSELECTSTART                       DISPID_EVPROP_ONSELECTSTART
#define DISPID_IHTMLDOCUMENT2_ELEMENTFROMPOINT                    DISPID_OMDOCUMENT+68
#define DISPID_IHTMLDOCUMENT2_PARENTWINDOW                        DISPID_OMDOCUMENT+34
#define DISPID_IHTMLDOCUMENT2_STYLESHEETS                         DISPID_OMDOCUMENT+69
#define DISPID_IHTMLDOCUMENT2_ONBEFOREUPDATE                      DISPID_EVPROP_ONBEFOREUPDATE
#define DISPID_IHTMLDOCUMENT2_ONERRORUPDATE                       DISPID_EVPROP_ONERRORUPDATE
#define DISPID_IHTMLDOCUMENT2_TOSTRING                            DISPID_OMDOCUMENT+70
#define DISPID_IHTMLDOCUMENT2_CREATESTYLESHEET                    DISPID_OMDOCUMENT+71

//    DISPIDs for interface IHTMLDocument3

#define DISPID_IHTMLDOCUMENT3_RELEASECAPTURE                      DISPID_OMDOCUMENT+72
#define DISPID_IHTMLDOCUMENT3_RECALC                              DISPID_OMDOCUMENT+73
#define DISPID_IHTMLDOCUMENT3_CREATETEXTNODE                      DISPID_OMDOCUMENT+74
#define DISPID_IHTMLDOCUMENT3_DOCUMENTELEMENT                     DISPID_OMDOCUMENT+75
#define DISPID_IHTMLDOCUMENT3_UNIQUEID                            DISPID_OMDOCUMENT+77
#define DISPID_IHTMLDOCUMENT3_ATTACHEVENT                         DISPID_HTMLOBJECT+7
#define DISPID_IHTMLDOCUMENT3_DETACHEVENT                         DISPID_HTMLOBJECT+8
#define DISPID_IHTMLDOCUMENT3_ONROWSDELETE                        DISPID_EVPROP_ONROWSDELETE
#define DISPID_IHTMLDOCUMENT3_ONROWSINSERTED                      DISPID_EVPROP_ONROWSINSERTED
#define DISPID_IHTMLDOCUMENT3_ONCELLCHANGE                        DISPID_EVPROP_ONCELLCHANGE
#define DISPID_IHTMLDOCUMENT3_ONDATASETCHANGED                    DISPID_EVPROP_ONDATASETCHANGED
#define DISPID_IHTMLDOCUMENT3_ONDATAAVAILABLE                     DISPID_EVPROP_ONDATAAVAILABLE
#define DISPID_IHTMLDOCUMENT3_ONDATASETCOMPLETE                   DISPID_EVPROP_ONDATASETCOMPLETE
#define DISPID_IHTMLDOCUMENT3_ONPROPERTYCHANGE                    DISPID_EVPROP_ONPROPERTYCHANGE
#define DISPID_IHTMLDOCUMENT3_DIR                                 DISPID_A_DIR
#define DISPID_IHTMLDOCUMENT3_ONCONTEXTMENU                       DISPID_EVPROP_ONCONTEXTMENU
#define DISPID_IHTMLDOCUMENT3_ONSTOP                              DISPID_EVPROP_ONSTOP
#define DISPID_IHTMLDOCUMENT3_CREATEDOCUMENTFRAGMENT              DISPID_OMDOCUMENT+76
#define DISPID_IHTMLDOCUMENT3_PARENTDOCUMENT                      DISPID_OMDOCUMENT+78
#define DISPID_IHTMLDOCUMENT3_ENABLEDOWNLOAD                      DISPID_OMDOCUMENT+79
#define DISPID_IHTMLDOCUMENT3_BASEURL                             DISPID_OMDOCUMENT+80
#define DISPID_IHTMLDOCUMENT3_CHILDNODES                          DISPID_ELEMENT+49
#define DISPID_IHTMLDOCUMENT3_INHERITSTYLESHEETS                  DISPID_OMDOCUMENT+82
#define DISPID_IHTMLDOCUMENT3_ONBEFOREEDITFOCUS                   DISPID_EVPROP_ONBEFOREEDITFOCUS
#define DISPID_IHTMLDOCUMENT3_GETELEMENTSBYNAME                   DISPID_OMDOCUMENT+86
#define DISPID_IHTMLDOCUMENT3_GETELEMENTBYID                      DISPID_OMDOCUMENT+88
#define DISPID_IHTMLDOCUMENT3_GETELEMENTSBYTAGNAME                DISPID_OMDOCUMENT+87

//    DISPIDs for interface IHTMLDocument4

#define DISPID_IHTMLDOCUMENT4_FOCUS                               DISPID_OMDOCUMENT+89
#define DISPID_IHTMLDOCUMENT4_HASFOCUS                            DISPID_OMDOCUMENT+90
#define DISPID_IHTMLDOCUMENT4_ONSELECTIONCHANGE                   DISPID_EVPROP_ONSELECTIONCHANGE
#define DISPID_IHTMLDOCUMENT4_NAMESPACES                          DISPID_OMDOCUMENT+91
#define DISPID_IHTMLDOCUMENT4_CREATEDOCUMENTFROMURL               DISPID_OMDOCUMENT+92
#define DISPID_IHTMLDOCUMENT4_MEDIA                               DISPID_OMDOCUMENT+93
#define DISPID_IHTMLDOCUMENT4_CREATEEVENTOBJECT                   DISPID_OMDOCUMENT+94
#define DISPID_IHTMLDOCUMENT4_FIREEVENT                           DISPID_OMDOCUMENT+95
#define DISPID_IHTMLDOCUMENT4_CREATERENDERSTYLE                   DISPID_OMDOCUMENT+96
#define DISPID_IHTMLDOCUMENT4_ONCONTROLSELECT                     DISPID_EVPROP_ONCONTROLSELECT
#define DISPID_IHTMLDOCUMENT4_URLUNENCODED                        DISPID_OMDOCUMENT+97

//    DISPIDs for interface IHTMLDocument5

#define DISPID_IHTMLDOCUMENT5_ONMOUSEWHEEL                        DISPID_EVPROP_ONMOUSEWHEEL
#define DISPID_IHTMLDOCUMENT5_DOCTYPE                             DISPID_OMDOCUMENT+98
#define DISPID_IHTMLDOCUMENT5_IMPLEMENTATION                      DISPID_OMDOCUMENT+99
#define DISPID_IHTMLDOCUMENT5_CREATEATTRIBUTE                     DISPID_OMDOCUMENT+100
#define DISPID_IHTMLDOCUMENT5_CREATECOMMENT                       DISPID_OMDOCUMENT+101
#define DISPID_IHTMLDOCUMENT5_ONFOCUSIN                           DISPID_EVPROP_ONFOCUSIN
#define DISPID_IHTMLDOCUMENT5_ONFOCUSOUT                          DISPID_EVPROP_ONFOCUSOUT
#define DISPID_IHTMLDOCUMENT5_ONACTIVATE                          DISPID_EVPROP_ONACTIVATE
#define DISPID_IHTMLDOCUMENT5_ONDEACTIVATE                        DISPID_EVPROP_ONDEACTIVATE
#define DISPID_IHTMLDOCUMENT5_ONBEFOREACTIVATE                    DISPID_EVPROP_ONBEFOREACTIVATE
#define DISPID_IHTMLDOCUMENT5_ONBEFOREDEACTIVATE                  DISPID_EVPROP_ONBEFOREDEACTIVATE
#define DISPID_IHTMLDOCUMENT5_COMPATMODE                          DISPID_OMDOCUMENT+102

//    DISPIDs for event set HTMLDocumentEvents2

#define DISPID_HTMLDOCUMENTEVENTS2_ONHELP                         DISPID_EVMETH_ONHELP
#define DISPID_HTMLDOCUMENTEVENTS2_ONCLICK                        DISPID_EVMETH_ONCLICK
#define DISPID_HTMLDOCUMENTEVENTS2_ONDBLCLICK                     DISPID_EVMETH_ONDBLCLICK
#define DISPID_HTMLDOCUMENTEVENTS2_ONKEYDOWN                      DISPID_EVMETH_ONKEYDOWN
#define DISPID_HTMLDOCUMENTEVENTS2_ONKEYUP                        DISPID_EVMETH_ONKEYUP
#define DISPID_HTMLDOCUMENTEVENTS2_ONKEYPRESS                     DISPID_EVMETH_ONKEYPRESS
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEDOWN                    DISPID_EVMETH_ONMOUSEDOWN
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEMOVE                    DISPID_EVMETH_ONMOUSEMOVE
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEUP                      DISPID_EVMETH_ONMOUSEUP
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEOUT                     DISPID_EVMETH_ONMOUSEOUT
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEOVER                    DISPID_EVMETH_ONMOUSEOVER
#define DISPID_HTMLDOCUMENTEVENTS2_ONREADYSTATECHANGE             DISPID_EVMETH_ONREADYSTATECHANGE
#define DISPID_HTMLDOCUMENTEVENTS2_ONBEFOREUPDATE                 DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONAFTERUPDATE                  DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONROWEXIT                      DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLDOCUMENTEVENTS2_ONROWENTER                     DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLDOCUMENTEVENTS2_ONDRAGSTART                    DISPID_EVMETH_ONDRAGSTART
#define DISPID_HTMLDOCUMENTEVENTS2_ONSELECTSTART                  DISPID_EVMETH_ONSELECTSTART
#define DISPID_HTMLDOCUMENTEVENTS2_ONERRORUPDATE                  DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONCONTEXTMENU                  DISPID_EVMETH_ONCONTEXTMENU
#define DISPID_HTMLDOCUMENTEVENTS2_ONSTOP                         DISPID_EVMETH_ONSTOP
#define DISPID_HTMLDOCUMENTEVENTS2_ONROWSDELETE                   DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLDOCUMENTEVENTS2_ONROWSINSERTED                 DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLDOCUMENTEVENTS2_ONCELLCHANGE                   DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLDOCUMENTEVENTS2_ONPROPERTYCHANGE               DISPID_EVMETH_ONPROPERTYCHANGE
#define DISPID_HTMLDOCUMENTEVENTS2_ONDATASETCHANGED               DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLDOCUMENTEVENTS2_ONDATAAVAILABLE                DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLDOCUMENTEVENTS2_ONDATASETCOMPLETE              DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLDOCUMENTEVENTS2_ONBEFOREEDITFOCUS              DISPID_EVMETH_ONBEFOREEDITFOCUS
#define DISPID_HTMLDOCUMENTEVENTS2_ONSELECTIONCHANGE              DISPID_EVMETH_ONSELECTIONCHANGE
#define DISPID_HTMLDOCUMENTEVENTS2_ONCONTROLSELECT                DISPID_EVMETH_ONCONTROLSELECT
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEWHEEL                   DISPID_EVMETH_ONMOUSEWHEEL
#define DISPID_HTMLDOCUMENTEVENTS2_ONFOCUSIN                      DISPID_EVMETH_ONFOCUSIN
#define DISPID_HTMLDOCUMENTEVENTS2_ONFOCUSOUT                     DISPID_EVMETH_ONFOCUSOUT
#define DISPID_HTMLDOCUMENTEVENTS2_ONACTIVATE                     DISPID_EVMETH_ONACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONDEACTIVATE                   DISPID_EVMETH_ONDEACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONBEFOREACTIVATE               DISPID_EVMETH_ONBEFOREACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONBEFOREDEACTIVATE             DISPID_EVMETH_ONBEFOREDEACTIVATE

//    DISPIDs for event set HTMLDocumentEvents

#define DISPID_HTMLDOCUMENTEVENTS_ONHELP                          DISPID_EVMETH_ONHELP
#define DISPID_HTMLDOCUMENTEVENTS_ONCLICK                         DISPID_EVMETH_ONCLICK
#define DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK                      DISPID_EVMETH_ONDBLCLICK
#define DISPID_HTMLDOCUMENTEVENTS_ONKEYDOWN                       DISPID_EVMETH_ONKEYDOWN
#define DISPID_HTMLDOCUMENTEVENTS_ONKEYUP                         DISPID_EVMETH_ONKEYUP
#define DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS                      DISPID_EVMETH_ONKEYPRESS
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN                     DISPID_EVMETH_ONMOUSEDOWN
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEMOVE                     DISPID_EVMETH_ONMOUSEMOVE
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEUP                       DISPID_EVMETH_ONMOUSEUP
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOUT                      DISPID_EVMETH_ONMOUSEOUT
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOVER                     DISPID_EVMETH_ONMOUSEOVER
#define DISPID_HTMLDOCUMENTEVENTS_ONREADYSTATECHANGE              DISPID_EVMETH_ONREADYSTATECHANGE
#define DISPID_HTMLDOCUMENTEVENTS_ONBEFOREUPDATE                  DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLDOCUMENTEVENTS_ONAFTERUPDATE                   DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLDOCUMENTEVENTS_ONROWEXIT                       DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLDOCUMENTEVENTS_ONROWENTER                      DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLDOCUMENTEVENTS_ONDRAGSTART                     DISPID_EVMETH_ONDRAGSTART
#define DISPID_HTMLDOCUMENTEVENTS_ONSELECTSTART                   DISPID_EVMETH_ONSELECTSTART
#define DISPID_HTMLDOCUMENTEVENTS_ONERRORUPDATE                   DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLDOCUMENTEVENTS_ONCONTEXTMENU                   DISPID_EVMETH_ONCONTEXTMENU
#define DISPID_HTMLDOCUMENTEVENTS_ONSTOP                          DISPID_EVMETH_ONSTOP
#define DISPID_HTMLDOCUMENTEVENTS_ONROWSDELETE                    DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLDOCUMENTEVENTS_ONROWSINSERTED                  DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLDOCUMENTEVENTS_ONCELLCHANGE                    DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLDOCUMENTEVENTS_ONPROPERTYCHANGE                DISPID_EVMETH_ONPROPERTYCHANGE
#define DISPID_HTMLDOCUMENTEVENTS_ONDATASETCHANGED                DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLDOCUMENTEVENTS_ONDATAAVAILABLE                 DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLDOCUMENTEVENTS_ONDATASETCOMPLETE               DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLDOCUMENTEVENTS_ONBEFOREEDITFOCUS               DISPID_EVMETH_ONBEFOREEDITFOCUS
#define DISPID_HTMLDOCUMENTEVENTS_ONSELECTIONCHANGE               DISPID_EVMETH_ONSELECTIONCHANGE
#define DISPID_HTMLDOCUMENTEVENTS_ONCONTROLSELECT                 DISPID_EVMETH_ONCONTROLSELECT
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEWHEEL                    DISPID_EVMETH_ONMOUSEWHEEL
#define DISPID_HTMLDOCUMENTEVENTS_ONFOCUSIN                       DISPID_EVMETH_ONFOCUSIN
#define DISPID_HTMLDOCUMENTEVENTS_ONFOCUSOUT                      DISPID_EVMETH_ONFOCUSOUT
#define DISPID_HTMLDOCUMENTEVENTS_ONACTIVATE                      DISPID_EVMETH_ONACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS_ONDEACTIVATE                    DISPID_EVMETH_ONDEACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS_ONBEFOREACTIVATE                DISPID_EVMETH_ONBEFOREACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS_ONBEFOREDEACTIVATE              DISPID_EVMETH_ONBEFOREDEACTIVATE

//    DISPIDs for interface IWebBridge

#define DISPID_IWEBBRIDGE_URL                                     1
#define DISPID_IWEBBRIDGE_SCROLLBAR                               2
#define DISPID_IWEBBRIDGE_EMBED                                   3
#define DISPID_IWEBBRIDGE_EVENT                                   DISPID_IHTMLWINDOW2_EVENT
#define DISPID_IWEBBRIDGE_READYSTATE                              DISPID_READYSTATE
#define DISPID_IWEBBRIDGE_ABOUTBOX                                DISPID_ABOUTBOX

//    DISPIDs for interface IWBScriptControl

#define DISPID_IWBSCRIPTCONTROL_RAISEEVENT                        1
#define DISPID_IWBSCRIPTCONTROL_BUBBLEEVENT                       2
#define DISPID_IWBSCRIPTCONTROL_SETCONTEXTMENU                    3
#define DISPID_IWBSCRIPTCONTROL_SELECTABLECONTENT                 4
#define DISPID_IWBSCRIPTCONTROL_FROZEN                            5
#define DISPID_IWBSCRIPTCONTROL_SCROLLBAR                         7
#define DISPID_IWBSCRIPTCONTROL_VERSION                           8
#define DISPID_IWBSCRIPTCONTROL_VISIBILITY                        9
#define DISPID_IWBSCRIPTCONTROL_ONVISIBILITYCHANGE                10

//    DISPIDs for event set DWebBridgeEvents

#define DISPID_DWEBBRIDGEEVENTS_ONSCRIPTLETEVENT                  1
#define DISPID_DWEBBRIDGEEVENTS_ONREADYSTATECHANGE                DISPID_HTMLDOCUMENTEVENTS_ONREADYSTATECHANGE
#define DISPID_DWEBBRIDGEEVENTS_ONCLICK                           DISPID_HTMLDOCUMENTEVENTS_ONCLICK
#define DISPID_DWEBBRIDGEEVENTS_ONDBLCLICK                        DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK
#define DISPID_DWEBBRIDGEEVENTS_ONKEYDOWN                         DISPID_HTMLDOCUMENTEVENTS_ONKEYDOWN
#define DISPID_DWEBBRIDGEEVENTS_ONKEYUP                           DISPID_HTMLDOCUMENTEVENTS_ONKEYUP
#define DISPID_DWEBBRIDGEEVENTS_ONKEYPRESS                        DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS
#define DISPID_DWEBBRIDGEEVENTS_ONMOUSEDOWN                       DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN
#define DISPID_DWEBBRIDGEEVENTS_ONMOUSEMOVE                       DISPID_HTMLDOCUMENTEVENTS_ONMOUSEMOVE
#define DISPID_DWEBBRIDGEEVENTS_ONMOUSEUP                         DISPID_HTMLDOCUMENTEVENTS_ONMOUSEUP

//    DISPIDs for interface IHTMLEmbedElement

#define DISPID_IHTMLEMBEDELEMENT_HIDDEN                           DISPID_OBJECT+10
#define DISPID_IHTMLEMBEDELEMENT_PALETTE                          DISPID_OBJECT+4
#define DISPID_IHTMLEMBEDELEMENT_PLUGINSPAGE                      DISPID_OBJECT+5
#define DISPID_IHTMLEMBEDELEMENT_SRC                              DISPID_OBJECT+6
#define DISPID_IHTMLEMBEDELEMENT_UNITS                            DISPID_OBJECT+8
#define DISPID_IHTMLEMBEDELEMENT_NAME                             STDPROPID_XOBJ_NAME
#define DISPID_IHTMLEMBEDELEMENT_WIDTH                            STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLEMBEDELEMENT_HEIGHT                           STDPROPID_XOBJ_HEIGHT

//    DISPIDs for interface IHTMLAreasCollection

#define DISPID_IHTMLAREASCOLLECTION_LENGTH                        DISPID_COLLECTION
#define DISPID_IHTMLAREASCOLLECTION__NEWENUM                      DISPID_NEWENUM
#define DISPID_IHTMLAREASCOLLECTION_ITEM                          DISPID_VALUE
#define DISPID_IHTMLAREASCOLLECTION_TAGS                          DISPID_COLLECTION+2
#define DISPID_IHTMLAREASCOLLECTION_ADD                           DISPID_COLLECTION+3
#define DISPID_IHTMLAREASCOLLECTION_REMOVE                        DISPID_COLLECTION+4

//    DISPIDs for interface IHTMLAreasCollection2

#define DISPID_IHTMLAREASCOLLECTION2_URNS                         DISPID_COLLECTION+5

//    DISPIDs for interface IHTMLAreasCollection3

#define DISPID_IHTMLAREASCOLLECTION3_NAMEDITEM                    DISPID_COLLECTION+6

//    DISPIDs for interface IHTMLMapElement

#define DISPID_IHTMLMAPELEMENT_AREAS                              DISPID_MAP+2
#define DISPID_IHTMLMAPELEMENT_NAME                               STDPROPID_XOBJ_NAME

//    DISPIDs for interface IHTMLAreaElement

#define DISPID_IHTMLAREAELEMENT_SHAPE                             DISPID_AREA+1
#define DISPID_IHTMLAREAELEMENT_COORDS                            DISPID_AREA+2
#define DISPID_IHTMLAREAELEMENT_HREF                              DISPID_VALUE
#define DISPID_IHTMLAREAELEMENT_TARGET                            DISPID_AREA+4
#define DISPID_IHTMLAREAELEMENT_ALT                               DISPID_AREA+5
#define DISPID_IHTMLAREAELEMENT_NOHREF                            DISPID_AREA+6
#define DISPID_IHTMLAREAELEMENT_HOST                              DISPID_AREA+7
#define DISPID_IHTMLAREAELEMENT_HOSTNAME                          DISPID_AREA+8
#define DISPID_IHTMLAREAELEMENT_PATHNAME                          DISPID_AREA+9
#define DISPID_IHTMLAREAELEMENT_PORT                              DISPID_AREA+10
#define DISPID_IHTMLAREAELEMENT_PROTOCOL                          DISPID_AREA+11
#define DISPID_IHTMLAREAELEMENT_SEARCH                            DISPID_AREA+12
#define DISPID_IHTMLAREAELEMENT_HASH                              DISPID_AREA+13
#define DISPID_IHTMLAREAELEMENT_ONBLUR                            DISPID_EVPROP_ONBLUR
#define DISPID_IHTMLAREAELEMENT_ONFOCUS                           DISPID_EVPROP_ONFOCUS
#define DISPID_IHTMLAREAELEMENT_TABINDEX                          STDPROPID_XOBJ_TABINDEX
#define DISPID_IHTMLAREAELEMENT_FOCUS                             DISPID_SITE+0
#define DISPID_IHTMLAREAELEMENT_BLUR                              DISPID_SITE+2

//    DISPIDs for interface IHTMLTableCaption

#define DISPID_IHTMLTABLECAPTION_ALIGN                            STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLTABLECAPTION_VALIGN                           DISPID_A_TABLEVALIGN

//    DISPIDs for interface IHTMLCommentElement

#define DISPID_IHTMLCOMMENTELEMENT_TEXT                           DISPID_COMMENTPDL+1
#define DISPID_IHTMLCOMMENTELEMENT_ATOMIC                         DISPID_COMMENTPDL+2

//    DISPIDs for interface IHTMLCommentElement2

#define DISPID_IHTMLCOMMENTELEMENT2_DATA                          DISPID_COMMENTPDL+3
#define DISPID_IHTMLCOMMENTELEMENT2_LENGTH                        DISPID_COMMENTPDL+4
#define DISPID_IHTMLCOMMENTELEMENT2_SUBSTRINGDATA                 DISPID_COMMENTPDL+5
#define DISPID_IHTMLCOMMENTELEMENT2_APPENDDATA                    DISPID_COMMENTPDL+6
#define DISPID_IHTMLCOMMENTELEMENT2_INSERTDATA                    DISPID_COMMENTPDL+7
#define DISPID_IHTMLCOMMENTELEMENT2_DELETEDATA                    DISPID_COMMENTPDL+8
#define DISPID_IHTMLCOMMENTELEMENT2_REPLACEDATA                   DISPID_COMMENTPDL+9

//    DISPIDs for interface IHTMLPhraseElement2

#define DISPID_IHTMLPHRASEELEMENT2_CITE                           DISPID_PHRASE+1
#define DISPID_IHTMLPHRASEELEMENT2_DATETIME                       DISPID_PHRASE+2

//    DISPIDs for interface IHTMLTable

#define DISPID_IHTMLTABLE_COLS                                    DISPID_TABLE+1
#define DISPID_IHTMLTABLE_BORDER                                  DISPID_TABLE+2
#define DISPID_IHTMLTABLE_FRAME                                   DISPID_TABLE+4
#define DISPID_IHTMLTABLE_RULES                                   DISPID_TABLE+3
#define DISPID_IHTMLTABLE_CELLSPACING                             DISPID_TABLE+5
#define DISPID_IHTMLTABLE_CELLPADDING                             DISPID_TABLE+6
#define DISPID_IHTMLTABLE_BACKGROUND                              DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLTABLE_BGCOLOR                                 DISPID_BACKCOLOR
#define DISPID_IHTMLTABLE_BORDERCOLOR                             DISPID_A_TABLEBORDERCOLOR
#define DISPID_IHTMLTABLE_BORDERCOLORLIGHT                        DISPID_A_TABLEBORDERCOLORLIGHT
#define DISPID_IHTMLTABLE_BORDERCOLORDARK                         DISPID_A_TABLEBORDERCOLORDARK
#define DISPID_IHTMLTABLE_ALIGN                                   STDPROPID_XOBJ_CONTROLALIGN
#define DISPID_IHTMLTABLE_REFRESH                                 DISPID_TABLE+15
#define DISPID_IHTMLTABLE_ROWS                                    DISPID_TABLE+16
#define DISPID_IHTMLTABLE_WIDTH                                   STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLTABLE_HEIGHT                                  STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLTABLE_DATAPAGESIZE                            DISPID_TABLE+17
#define DISPID_IHTMLTABLE_NEXTPAGE                                DISPID_TABLE+18
#define DISPID_IHTMLTABLE_PREVIOUSPAGE                            DISPID_TABLE+19
#define DISPID_IHTMLTABLE_THEAD                                   DISPID_TABLE+20
#define DISPID_IHTMLTABLE_TFOOT                                   DISPID_TABLE+21
#define DISPID_IHTMLTABLE_TBODIES                                 DISPID_TABLE+24
#define DISPID_IHTMLTABLE_CAPTION                                 DISPID_TABLE+25
#define DISPID_IHTMLTABLE_CREATETHEAD                             DISPID_TABLE+26
#define DISPID_IHTMLTABLE_DELETETHEAD                             DISPID_TABLE+27
#define DISPID_IHTMLTABLE_CREATETFOOT                             DISPID_TABLE+28
#define DISPID_IHTMLTABLE_DELETETFOOT                             DISPID_TABLE+29
#define DISPID_IHTMLTABLE_CREATECAPTION                           DISPID_TABLE+30
#define DISPID_IHTMLTABLE_DELETECAPTION                           DISPID_TABLE+31
#define DISPID_IHTMLTABLE_INSERTROW                               DISPID_TABLE+32
#define DISPID_IHTMLTABLE_DELETEROW                               DISPID_TABLE+33
#define DISPID_IHTMLTABLE_READYSTATE                              DISPID_A_READYSTATE
#define DISPID_IHTMLTABLE_ONREADYSTATECHANGE                      DISPID_EVPROP_ONREADYSTATECHANGE

//    DISPIDs for interface IHTMLTable2

#define DISPID_IHTMLTABLE2_FIRSTPAGE                              DISPID_TABLE+35
#define DISPID_IHTMLTABLE2_LASTPAGE                               DISPID_TABLE+36
#define DISPID_IHTMLTABLE2_CELLS                                  DISPID_TABLE+37
#define DISPID_IHTMLTABLE2_MOVEROW                                DISPID_TABLE+38

//    DISPIDs for interface IHTMLTable3

#define DISPID_IHTMLTABLE3_SUMMARY                                DISPID_TABLE+39

//    DISPIDs for interface IHTMLTableCol

#define DISPID_IHTMLTABLECOL_SPAN                                 DISPID_TABLECOL+1
#define DISPID_IHTMLTABLECOL_WIDTH                                STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLTABLECOL_ALIGN                                STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLTABLECOL_VALIGN                               DISPID_A_TABLEVALIGN

//    DISPIDs for interface IHTMLTableCol2

#define DISPID_IHTMLTABLECOL2_CH                                  DISPID_TABLECOL+2
#define DISPID_IHTMLTABLECOL2_CHOFF                               DISPID_TABLECOL+3

//    DISPIDs for interface IHTMLTableSection

#define DISPID_IHTMLTABLESECTION_ALIGN                            STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLTABLESECTION_VALIGN                           DISPID_A_TABLEVALIGN
#define DISPID_IHTMLTABLESECTION_BGCOLOR                          DISPID_BACKCOLOR
#define DISPID_IHTMLTABLESECTION_ROWS                             DISPID_TABLESECTION
#define DISPID_IHTMLTABLESECTION_INSERTROW                        DISPID_TABLESECTION+1
#define DISPID_IHTMLTABLESECTION_DELETEROW                        DISPID_TABLESECTION+2

//    DISPIDs for interface IHTMLTableSection2

#define DISPID_IHTMLTABLESECTION2_MOVEROW                         DISPID_TABLESECTION+3

//    DISPIDs for interface IHTMLTableSection3

#define DISPID_IHTMLTABLESECTION3_CH                              DISPID_TABLESECTION+4
#define DISPID_IHTMLTABLESECTION3_CHOFF                           DISPID_TABLESECTION+5

//    DISPIDs for interface IHTMLTableRow

#define DISPID_IHTMLTABLEROW_ALIGN                                STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLTABLEROW_VALIGN                               DISPID_A_TABLEVALIGN
#define DISPID_IHTMLTABLEROW_BGCOLOR                              DISPID_BACKCOLOR
#define DISPID_IHTMLTABLEROW_BORDERCOLOR                          DISPID_A_TABLEBORDERCOLOR
#define DISPID_IHTMLTABLEROW_BORDERCOLORLIGHT                     DISPID_A_TABLEBORDERCOLORLIGHT
#define DISPID_IHTMLTABLEROW_BORDERCOLORDARK                      DISPID_A_TABLEBORDERCOLORDARK
#define DISPID_IHTMLTABLEROW_ROWINDEX                             DISPID_TABLEROW
#define DISPID_IHTMLTABLEROW_SECTIONROWINDEX                      DISPID_TABLEROW+1
#define DISPID_IHTMLTABLEROW_CELLS                                DISPID_TABLEROW+2
#define DISPID_IHTMLTABLEROW_INSERTCELL                           DISPID_TABLEROW+3
#define DISPID_IHTMLTABLEROW_DELETECELL                           DISPID_TABLEROW+4

//    DISPIDs for interface IHTMLTableRow2

#define DISPID_IHTMLTABLEROW2_HEIGHT                              STDPROPID_XOBJ_HEIGHT

//    DISPIDs for interface IHTMLTableRow3

#define DISPID_IHTMLTABLEROW3_CH                                  DISPID_TABLEROW+9
#define DISPID_IHTMLTABLEROW3_CHOFF                               DISPID_TABLEROW+10

//    DISPIDs for interface IHTMLTableRowMetrics

#define DISPID_IHTMLTABLEROWMETRICS_CLIENTHEIGHT                  DISPID_SITE+19
#define DISPID_IHTMLTABLEROWMETRICS_CLIENTWIDTH                   DISPID_SITE+20
#define DISPID_IHTMLTABLEROWMETRICS_CLIENTTOP                     DISPID_SITE+21
#define DISPID_IHTMLTABLEROWMETRICS_CLIENTLEFT                    DISPID_SITE+22

//    DISPIDs for interface IHTMLTableCell

#define DISPID_IHTMLTABLECELL_ROWSPAN                             DISPID_TABLECELL+1
#define DISPID_IHTMLTABLECELL_COLSPAN                             DISPID_TABLECELL+2
#define DISPID_IHTMLTABLECELL_ALIGN                               STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLTABLECELL_VALIGN                              DISPID_A_TABLEVALIGN
#define DISPID_IHTMLTABLECELL_BGCOLOR                             DISPID_BACKCOLOR
#define DISPID_IHTMLTABLECELL_NOWRAP                              DISPID_A_NOWRAP
#define DISPID_IHTMLTABLECELL_BACKGROUND                          DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLTABLECELL_BORDERCOLOR                         DISPID_A_TABLEBORDERCOLOR
#define DISPID_IHTMLTABLECELL_BORDERCOLORLIGHT                    DISPID_A_TABLEBORDERCOLORLIGHT
#define DISPID_IHTMLTABLECELL_BORDERCOLORDARK                     DISPID_A_TABLEBORDERCOLORDARK
#define DISPID_IHTMLTABLECELL_WIDTH                               STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLTABLECELL_HEIGHT                              STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLTABLECELL_CELLINDEX                           DISPID_TABLECELL+3

//    DISPIDs for interface IHTMLTableCell2

#define DISPID_IHTMLTABLECELL2_ABBR                               DISPID_TABLECELL+4
#define DISPID_IHTMLTABLECELL2_AXIS                               DISPID_TABLECELL+5
#define DISPID_IHTMLTABLECELL2_CH                                 DISPID_TABLECELL+6
#define DISPID_IHTMLTABLECELL2_CHOFF                              DISPID_TABLECELL+7
#define DISPID_IHTMLTABLECELL2_HEADERS                            DISPID_TABLECELL+8
#define DISPID_IHTMLTABLECELL2_SCOPE                              DISPID_TABLECELL+9

//    DISPIDs for interface IHTMLScriptElement

#define DISPID_IHTMLSCRIPTELEMENT_SRC                             DISPID_SCRIPT+1
#define DISPID_IHTMLSCRIPTELEMENT_HTMLFOR                         DISPID_SCRIPT+4
#define DISPID_IHTMLSCRIPTELEMENT_EVENT                           DISPID_SCRIPT+5
#define DISPID_IHTMLSCRIPTELEMENT_TEXT                            DISPID_SCRIPT+6
#define DISPID_IHTMLSCRIPTELEMENT_DEFER                           DISPID_SCRIPT+7
#define DISPID_IHTMLSCRIPTELEMENT_READYSTATE                      DISPID_A_READYSTATE
#define DISPID_IHTMLSCRIPTELEMENT_ONERROR                         DISPID_EVPROP_ONERROR
#define DISPID_IHTMLSCRIPTELEMENT_TYPE                            DISPID_SCRIPT+9

//    DISPIDs for interface IHTMLScriptElement2

#define DISPID_IHTMLSCRIPTELEMENT2_CHARSET                        DISPID_SCRIPT+10

//    DISPIDs for event set HTMLScriptEvents2

#define DISPID_HTMLSCRIPTEVENTS2_ONERROR                          DISPID_EVMETH_ONERROR

//    DISPIDs for event set HTMLScriptEvents

#define DISPID_HTMLSCRIPTEVENTS_ONERROR                           DISPID_EVMETH_ONERROR

//    DISPIDs for interface IHTMLObjectElement

#define DISPID_IHTMLOBJECTELEMENT_OBJECT                          DISPID_OBJECT+1
#define DISPID_IHTMLOBJECTELEMENT_CLASSID                         DISPID_OBJECT+2
#define DISPID_IHTMLOBJECTELEMENT_DATA                            DISPID_OBJECT+3
#define DISPID_IHTMLOBJECTELEMENT_RECORDSET                       DISPID_OBJECT+5
#define DISPID_IHTMLOBJECTELEMENT_ALIGN                           STDPROPID_XOBJ_CONTROLALIGN
#define DISPID_IHTMLOBJECTELEMENT_NAME                            STDPROPID_XOBJ_NAME
#define DISPID_IHTMLOBJECTELEMENT_CODEBASE                        DISPID_OBJECT+6
#define DISPID_IHTMLOBJECTELEMENT_CODETYPE                        DISPID_OBJECT+7
#define DISPID_IHTMLOBJECTELEMENT_CODE                            DISPID_OBJECT+8
#define DISPID_IHTMLOBJECTELEMENT_BASEHREF                        STDPROPID_XOBJ_BASEHREF
#define DISPID_IHTMLOBJECTELEMENT_TYPE                            DISPID_OBJECT+9
#define DISPID_IHTMLOBJECTELEMENT_FORM                            DISPID_SITE+4
#define DISPID_IHTMLOBJECTELEMENT_WIDTH                           STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLOBJECTELEMENT_HEIGHT                          STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLOBJECTELEMENT_READYSTATE                      DISPID_OBJECT+10
#define DISPID_IHTMLOBJECTELEMENT_ONREADYSTATECHANGE              DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLOBJECTELEMENT_ONERROR                         DISPID_EVPROP_ONERROR
#define DISPID_IHTMLOBJECTELEMENT_ALTHTML                         DISPID_OBJECT+11
#define DISPID_IHTMLOBJECTELEMENT_VSPACE                          DISPID_OBJECT+12
#define DISPID_IHTMLOBJECTELEMENT_HSPACE                          DISPID_OBJECT+13

//    DISPIDs for interface IHTMLObjectElement2

#define DISPID_IHTMLOBJECTELEMENT2_NAMEDRECORDSET                 DISPID_OBJECT+14
#define DISPID_IHTMLOBJECTELEMENT2_CLASSID                        DISPID_OBJECT+2
#define DISPID_IHTMLOBJECTELEMENT2_DATA                           DISPID_OBJECT+3

//    DISPIDs for interface IHTMLObjectElement3

#define DISPID_IHTMLOBJECTELEMENT3_ARCHIVE                        DISPID_OBJECT+15
#define DISPID_IHTMLOBJECTELEMENT3_ALT                            DISPID_OBJECT+16
#define DISPID_IHTMLOBJECTELEMENT3_DECLARE                        DISPID_OBJECT+17
#define DISPID_IHTMLOBJECTELEMENT3_STANDBY                        DISPID_OBJECT+18
#define DISPID_IHTMLOBJECTELEMENT3_BORDER                         DISPID_OBJECT+19
#define DISPID_IHTMLOBJECTELEMENT3_USEMAP                         DISPID_OBJECT+20

//    DISPIDs for interface IHTMLParamElement

#define DISPID_IHTMLPARAMELEMENT_NAME                             DISPID_PARAM+1
#define DISPID_IHTMLPARAMELEMENT_VALUE                            DISPID_PARAM+2
#define DISPID_IHTMLPARAMELEMENT_TYPE                             DISPID_PARAM+3
#define DISPID_IHTMLPARAMELEMENT_VALUETYPE                        DISPID_PARAM+4

//    DISPIDs for event set HTMLObjectElementEvents2

#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONBEFOREUPDATE            DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONAFTERUPDATE             DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONERRORUPDATE             DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONROWEXIT                 DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONROWENTER                DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONDATASETCHANGED          DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONDATAAVAILABLE           DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONDATASETCOMPLETE         DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONERROR                   DISPID_XOBJ_BASE+19
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONROWSDELETE              DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONROWSINSERTED            DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONCELLCHANGE              DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONREADYSTATECHANGE        DISPID_XOBJ_BASE+20

//    DISPIDs for event set HTMLObjectElementEvents

#define DISPID_HTMLOBJECTELEMENTEVENTS_ONBEFOREUPDATE             DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONAFTERUPDATE              DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONERRORUPDATE              DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONROWEXIT                  DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONROWENTER                 DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONDATASETCHANGED           DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONDATAAVAILABLE            DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONDATASETCOMPLETE          DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONERROR                    DISPID_XOBJ_BASE+19
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONROWSDELETE               DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONROWSINSERTED             DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONCELLCHANGE               DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONREADYSTATECHANGE         DISPID_XOBJ_BASE+20

//    DISPIDs for interface IHTMLFrameBase

#define DISPID_IHTMLFRAMEBASE_SRC                                 DISPID_FRAMESITE+0
#define DISPID_IHTMLFRAMEBASE_NAME                                STDPROPID_XOBJ_NAME
#define DISPID_IHTMLFRAMEBASE_BORDER                              DISPID_FRAMESITE+2
#define DISPID_IHTMLFRAMEBASE_FRAMEBORDER                         DISPID_FRAMESITE+3
#define DISPID_IHTMLFRAMEBASE_FRAMESPACING                        DISPID_FRAMESITE+4
#define DISPID_IHTMLFRAMEBASE_MARGINWIDTH                         DISPID_FRAMESITE+5
#define DISPID_IHTMLFRAMEBASE_MARGINHEIGHT                        DISPID_FRAMESITE+6
#define DISPID_IHTMLFRAMEBASE_NORESIZE                            DISPID_FRAMESITE+7
#define DISPID_IHTMLFRAMEBASE_SCROLLING                           DISPID_FRAMESITE+8

//    DISPIDs for interface IHTMLFrameBase2

#define DISPID_IHTMLFRAMEBASE2_CONTENTWINDOW                      DISPID_FRAMESITE+9
#define DISPID_IHTMLFRAMEBASE2_ONLOAD                             DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLFRAMEBASE2_ONREADYSTATECHANGE                 DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLFRAMEBASE2_READYSTATE                         DISPID_A_READYSTATE
#define DISPID_IHTMLFRAMEBASE2_ALLOWTRANSPARENCY                  DISPID_A_ALLOWTRANSPARENCY

//    DISPIDs for interface IHTMLFrameBase3

#define DISPID_IHTMLFRAMEBASE3_LONGDESC                           DISPID_FRAMESITE+10

//    DISPIDs for event set HTMLFrameSiteEvents2

#define DISPID_HTMLFRAMESITEEVENTS2_ONLOAD                        DISPID_EVMETH_ONLOAD

//    DISPIDs for event set HTMLFrameSiteEvents

#define DISPID_HTMLFRAMESITEEVENTS_ONLOAD                         DISPID_EVMETH_ONLOAD

//    DISPIDs for interface IHTMLFrameElement

#define DISPID_IHTMLFRAMEELEMENT_BORDERCOLOR                      DISPID_FRAME+1

//    DISPIDs for interface IHTMLFrameElement2

#define DISPID_IHTMLFRAMEELEMENT2_HEIGHT                          STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLFRAMEELEMENT2_WIDTH                           STDPROPID_XOBJ_WIDTH

//    DISPIDs for interface IHTMLIFrameElement

#define DISPID_IHTMLIFRAMEELEMENT_VSPACE                          DISPID_IFRAME+1
#define DISPID_IHTMLIFRAMEELEMENT_HSPACE                          DISPID_IFRAME+2
#define DISPID_IHTMLIFRAMEELEMENT_ALIGN                           STDPROPID_XOBJ_CONTROLALIGN

//    DISPIDs for interface IHTMLIFrameElement2

#define DISPID_IHTMLIFRAMEELEMENT2_HEIGHT                         STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLIFRAMEELEMENT2_WIDTH                          STDPROPID_XOBJ_WIDTH

//    DISPIDs for interface IHTMLDivPosition

#define DISPID_IHTMLDIVPOSITION_ALIGN                             STDPROPID_XOBJ_CONTROLALIGN

//    DISPIDs for interface IHTMLFieldSetElement

#define DISPID_IHTMLFIELDSETELEMENT_ALIGN                         STDPROPID_XOBJ_CONTROLALIGN

//    DISPIDs for interface IHTMLFieldSetElement2

#define DISPID_IHTMLFIELDSETELEMENT2_FORM                         DISPID_SITE+4

//    DISPIDs for interface IHTMLLegendElement

#define DISPID_IHTMLLEGENDELEMENT_ALIGN                           STDPROPID_XOBJ_CONTROLALIGN

//    DISPIDs for interface IHTMLLegendElement2

#define DISPID_IHTMLLEGENDELEMENT2_FORM                           DISPID_SITE+4

//    DISPIDs for interface IHTMLSpanFlow

#define DISPID_IHTMLSPANFLOW_ALIGN                                STDPROPID_XOBJ_CONTROLALIGN

//    DISPIDs for interface IHTMLFrameSetElement

#define DISPID_IHTMLFRAMESETELEMENT_ROWS                          DISPID_FRAMESET
#define DISPID_IHTMLFRAMESETELEMENT_COLS                          DISPID_FRAMESET+1
#define DISPID_IHTMLFRAMESETELEMENT_BORDER                        DISPID_FRAMESET+2
#define DISPID_IHTMLFRAMESETELEMENT_BORDERCOLOR                   DISPID_FRAMESET+3
#define DISPID_IHTMLFRAMESETELEMENT_FRAMEBORDER                   DISPID_FRAMESET+4
#define DISPID_IHTMLFRAMESETELEMENT_FRAMESPACING                  DISPID_FRAMESET+5
#define DISPID_IHTMLFRAMESETELEMENT_NAME                          STDPROPID_XOBJ_NAME
#define DISPID_IHTMLFRAMESETELEMENT_ONLOAD                        DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLFRAMESETELEMENT_ONUNLOAD                      DISPID_EVPROP_ONUNLOAD
#define DISPID_IHTMLFRAMESETELEMENT_ONBEFOREUNLOAD                DISPID_EVPROP_ONBEFOREUNLOAD

//    DISPIDs for interface IHTMLFrameSetElement2

#define DISPID_IHTMLFRAMESETELEMENT2_ONBEFOREPRINT                DISPID_EVPROP_ONBEFOREPRINT
#define DISPID_IHTMLFRAMESETELEMENT2_ONAFTERPRINT                 DISPID_EVPROP_ONAFTERPRINT

//    DISPIDs for interface IHTMLBGsound

#define DISPID_IHTMLBGSOUND_SRC                                   DISPID_BGSOUND+1
#define DISPID_IHTMLBGSOUND_LOOP                                  DISPID_BGSOUND+2
#define DISPID_IHTMLBGSOUND_VOLUME                                DISPID_BGSOUND+3
#define DISPID_IHTMLBGSOUND_BALANCE                               DISPID_BGSOUND+4

//    DISPIDs for interface IHTMLFontNamesCollection

#define DISPID_IHTMLFONTNAMESCOLLECTION_LENGTH                    DISPID_OPTIONS_COL+1
#define DISPID_IHTMLFONTNAMESCOLLECTION__NEWENUM                  DISPID_NEWENUM
#define DISPID_IHTMLFONTNAMESCOLLECTION_ITEM                      DISPID_VALUE

//    DISPIDs for interface IHTMLFontSizesCollection

#define DISPID_IHTMLFONTSIZESCOLLECTION_LENGTH                    DISPID_OPTIONS_COL+2
#define DISPID_IHTMLFONTSIZESCOLLECTION__NEWENUM                  DISPID_NEWENUM
#define DISPID_IHTMLFONTSIZESCOLLECTION_FORFONT                   DISPID_OPTIONS_COL+3
#define DISPID_IHTMLFONTSIZESCOLLECTION_ITEM                      DISPID_VALUE

//    DISPIDs for interface IHTMLOptionsHolder

#define DISPID_IHTMLOPTIONSHOLDER_DOCUMENT                        DISPID_OPTIONS_COL+3
#define DISPID_IHTMLOPTIONSHOLDER_FONTS                           DISPID_OPTIONS_COL+4
#define DISPID_IHTMLOPTIONSHOLDER_EXECARG                         DISPID_OPTIONS_COL+5
#define DISPID_IHTMLOPTIONSHOLDER_ERRORLINE                       DISPID_OPTIONS_COL+6
#define DISPID_IHTMLOPTIONSHOLDER_ERRORCHARACTER                  DISPID_OPTIONS_COL+7
#define DISPID_IHTMLOPTIONSHOLDER_ERRORCODE                       DISPID_OPTIONS_COL+8
#define DISPID_IHTMLOPTIONSHOLDER_ERRORMESSAGE                    DISPID_OPTIONS_COL+9
#define DISPID_IHTMLOPTIONSHOLDER_ERRORDEBUG                      DISPID_OPTIONS_COL+10
#define DISPID_IHTMLOPTIONSHOLDER_UNSECUREDWINDOWOFDOCUMENT       DISPID_OPTIONS_COL+11
#define DISPID_IHTMLOPTIONSHOLDER_FINDTEXT                        DISPID_OPTIONS_COL+12
#define DISPID_IHTMLOPTIONSHOLDER_ANYTHINGAFTERFRAMESET           DISPID_OPTIONS_COL+13
#define DISPID_IHTMLOPTIONSHOLDER_SIZES                           DISPID_OPTIONS_COL+14
#define DISPID_IHTMLOPTIONSHOLDER_OPENFILEDLG                     DISPID_OPTIONS_COL+15
#define DISPID_IHTMLOPTIONSHOLDER_SAVEFILEDLG                     DISPID_OPTIONS_COL+16
#define DISPID_IHTMLOPTIONSHOLDER_CHOOSECOLORDLG                  DISPID_OPTIONS_COL+17
#define DISPID_IHTMLOPTIONSHOLDER_SHOWSECURITYINFO                DISPID_OPTIONS_COL+18
#define DISPID_IHTMLOPTIONSHOLDER_ISAPARTMENTMODEL                DISPID_OPTIONS_COL+19
#define DISPID_IHTMLOPTIONSHOLDER_GETCHARSET                      DISPID_OPTIONS_COL+20
#define DISPID_IHTMLOPTIONSHOLDER_SECURECONNECTIONINFO            DISPID_OPTIONS_COL+21

//    DISPIDs for interface IHTMLStyleElement

#define DISPID_IHTMLSTYLEELEMENT_TYPE                             DISPID_STYLEELEMENT+2
#define DISPID_IHTMLSTYLEELEMENT_READYSTATE                       DISPID_A_READYSTATE
#define DISPID_IHTMLSTYLEELEMENT_ONREADYSTATECHANGE               DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLSTYLEELEMENT_ONLOAD                           DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLSTYLEELEMENT_ONERROR                          DISPID_EVPROP_ONERROR
#define DISPID_IHTMLSTYLEELEMENT_STYLESHEET                       DISPID_STYLEELEMENT+4
#define DISPID_IHTMLSTYLEELEMENT_DISABLED                         STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLSTYLEELEMENT_MEDIA                            DISPID_STYLEELEMENT+6

//    DISPIDs for event set HTMLStyleElementEvents2

#define DISPID_HTMLSTYLEELEMENTEVENTS2_ONLOAD                     DISPID_EVMETH_ONLOAD
#define DISPID_HTMLSTYLEELEMENTEVENTS2_ONERROR                    DISPID_EVMETH_ONERROR

//    DISPIDs for event set HTMLStyleElementEvents

#define DISPID_HTMLSTYLEELEMENTEVENTS_ONLOAD                      DISPID_EVMETH_ONLOAD
#define DISPID_HTMLSTYLEELEMENTEVENTS_ONERROR                     DISPID_EVMETH_ONERROR

//    DISPIDs for interface IHTMLStyleFontFace

#define DISPID_IHTMLSTYLEFONTFACE_FONTSRC                         DISPID_A_FONTFACESRC

//    DISPIDs for interface ICSSFilterSite

#define DISPID_ICSSFILTERSITE_GETELEMENT                          
#define DISPID_ICSSFILTERSITE_FIREONFILTERCHANGEEVENT             

//    DISPIDs for interface ICSSFilter

#define DISPID_ICSSFILTER_SETSITE                                 
#define DISPID_ICSSFILTER_ONAMBIENTPROPERTYCHANGE                 

//    DISPIDs for interface ISecureUrlHost

#define DISPID_ISECUREURLHOST_VALIDATESECUREURL                   

//    DISPIDs for interface IMarkupServices

#define DISPID_IMARKUPSERVICES_CREATEMARKUPPOINTER                
#define DISPID_IMARKUPSERVICES_CREATEMARKUPCONTAINER              
#define DISPID_IMARKUPSERVICES_CREATEELEMENT                      
#define DISPID_IMARKUPSERVICES_CLONEELEMENT                       
#define DISPID_IMARKUPSERVICES_INSERTELEMENT                      
#define DISPID_IMARKUPSERVICES_REMOVEELEMENT                      
#define DISPID_IMARKUPSERVICES_REMOVE                             
#define DISPID_IMARKUPSERVICES_COPY                               
#define DISPID_IMARKUPSERVICES_MOVE                               
#define DISPID_IMARKUPSERVICES_INSERTTEXT                         
#define DISPID_IMARKUPSERVICES_PARSESTRING                        
#define DISPID_IMARKUPSERVICES_PARSEGLOBAL                        
#define DISPID_IMARKUPSERVICES_ISSCOPEDELEMENT                    
#define DISPID_IMARKUPSERVICES_GETELEMENTTAGID                    
#define DISPID_IMARKUPSERVICES_GETTAGIDFORNAME                    
#define DISPID_IMARKUPSERVICES_GETNAMEFORTAGID                    
#define DISPID_IMARKUPSERVICES_MOVEPOINTERSTORANGE                
#define DISPID_IMARKUPSERVICES_MOVERANGETOPOINTERS                
#define DISPID_IMARKUPSERVICES_BEGINUNDOUNIT                      
#define DISPID_IMARKUPSERVICES_ENDUNDOUNIT                        

//    DISPIDs for interface IMarkupServices2

#define DISPID_IMARKUPSERVICES2_PARSEGLOBALEX                     
#define DISPID_IMARKUPSERVICES2_VALIDATEELEMENTS                  
#define DISPID_IMARKUPSERVICES2_SAVESEGMENTSTOCLIPBOARD           

//    DISPIDs for interface IMarkupContainer

#define DISPID_IMARKUPCONTAINER_OWNINGDOC                         

//    DISPIDs for interface IMarkupContainer2

#define DISPID_IMARKUPCONTAINER2_CREATECHANGELOG                  
#define DISPID_IMARKUPCONTAINER2_REGISTERFORDIRTYRANGE            
#define DISPID_IMARKUPCONTAINER2_UNREGISTERFORDIRTYRANGE          
#define DISPID_IMARKUPCONTAINER2_GETANDCLEARDIRTYRANGE            
#define DISPID_IMARKUPCONTAINER2_GETVERSIONNUMBER                 
#define DISPID_IMARKUPCONTAINER2_GETMASTERELEMENT                 

//    DISPIDs for interface IHTMLChangePlayback

#define DISPID_IHTMLCHANGEPLAYBACK_EXECCHANGE                     

//    DISPIDs for interface IMarkupPointer

#define DISPID_IMARKUPPOINTER_OWNINGDOC                           
#define DISPID_IMARKUPPOINTER_GRAVITY                             
#define DISPID_IMARKUPPOINTER_SETGRAVITY                          
#define DISPID_IMARKUPPOINTER_CLING                               
#define DISPID_IMARKUPPOINTER_SETCLING                            
#define DISPID_IMARKUPPOINTER_UNPOSITION                          
#define DISPID_IMARKUPPOINTER_ISPOSITIONED                        
#define DISPID_IMARKUPPOINTER_GETCONTAINER                        
#define DISPID_IMARKUPPOINTER_MOVEADJACENTTOELEMENT               
#define DISPID_IMARKUPPOINTER_MOVETOPOINTER                       
#define DISPID_IMARKUPPOINTER_MOVETOCONTAINER                     
#define DISPID_IMARKUPPOINTER_LEFT                                
#define DISPID_IMARKUPPOINTER_RIGHT                               
#define DISPID_IMARKUPPOINTER_CURRENTSCOPE                        
#define DISPID_IMARKUPPOINTER_ISLEFTOF                            
#define DISPID_IMARKUPPOINTER_ISLEFTOFOREQUALTO                   
#define DISPID_IMARKUPPOINTER_ISRIGHTOF                           
#define DISPID_IMARKUPPOINTER_ISRIGHTOFOREQUALTO                  
#define DISPID_IMARKUPPOINTER_ISEQUALTO                           
#define DISPID_IMARKUPPOINTER_MOVEUNIT                            
#define DISPID_IMARKUPPOINTER_FINDTEXT                            

//    DISPIDs for interface IMarkupPointer2

#define DISPID_IMARKUPPOINTER2_ISATWORDBREAK                      
#define DISPID_IMARKUPPOINTER2_GETMARKUPPOSITION                  
#define DISPID_IMARKUPPOINTER2_MOVETOMARKUPPOSITION               
#define DISPID_IMARKUPPOINTER2_MOVEUNITBOUNDED                    
#define DISPID_IMARKUPPOINTER2_ISINSIDEURL                        
#define DISPID_IMARKUPPOINTER2_MOVETOCONTENT                      

//    DISPIDs for interface IMarkupTextFrags

#define DISPID_IMARKUPTEXTFRAGS_GETTEXTFRAGCOUNT                  
#define DISPID_IMARKUPTEXTFRAGS_GETTEXTFRAG                       
#define DISPID_IMARKUPTEXTFRAGS_REMOVETEXTFRAG                    
#define DISPID_IMARKUPTEXTFRAGS_INSERTTEXTFRAG                    
#define DISPID_IMARKUPTEXTFRAGS_FINDTEXTFRAGFROMMARKUPPOINTER     

//    DISPIDs for interface IHTMLChangeLog

#define DISPID_IHTMLCHANGELOG_GETNEXTCHANGE                       

//    DISPIDs for interface IHTMLChangeSink

#define DISPID_IHTMLCHANGESINK_NOTIFY                             

//    DISPIDs for interface IXMLGenericParse

#define DISPID_IXMLGENERICPARSE_SETGENERICPARSE                   

//    DISPIDs for interface IHTMLEditHost

#define DISPID_IHTMLEDITHOST_SNAPRECT                             

//    DISPIDs for interface IHTMLEditHost2

#define DISPID_IHTMLEDITHOST2_PREDRAG                             

//    DISPIDs for interface ISegment

#define DISPID_ISEGMENT_GETPOINTERS                               

//    DISPIDs for interface ISegmentListIterator

#define DISPID_ISEGMENTLISTITERATOR_CURRENT                       
#define DISPID_ISEGMENTLISTITERATOR_FIRST                         
#define DISPID_ISEGMENTLISTITERATOR_ISDONE                        
#define DISPID_ISEGMENTLISTITERATOR_ADVANCE                       

//    DISPIDs for interface ISegmentList

#define DISPID_ISEGMENTLIST_CREATEITERATOR                        
#define DISPID_ISEGMENTLIST_GETTYPE                               
#define DISPID_ISEGMENTLIST_ISEMPTY                               

//    DISPIDs for interface ISequenceNumber

#define DISPID_ISEQUENCENUMBER_GETSEQUENCENUMBER                  

//    DISPIDs for interface IIMEServices

#define DISPID_IIMESERVICES_GETACTIVEIMM                          

//    DISPIDs for interface IHTMLCaret

#define DISPID_IHTMLCARET_MOVECARETTOPOINTER                      
#define DISPID_IHTMLCARET_MOVECARETTOPOINTEREX                    
#define DISPID_IHTMLCARET_MOVEMARKUPPOINTERTOCARET                
#define DISPID_IHTMLCARET_MOVEDISPLAYPOINTERTOCARET               
#define DISPID_IHTMLCARET_ISVISIBLE                               
#define DISPID_IHTMLCARET_SHOW                                    
#define DISPID_IHTMLCARET_HIDE                                    
#define DISPID_IHTMLCARET_INSERTTEXT                              
#define DISPID_IHTMLCARET_SCROLLINTOVIEW                          
#define DISPID_IHTMLCARET_GETLOCATION                             
#define DISPID_IHTMLCARET_GETCARETDIRECTION                       
#define DISPID_IHTMLCARET_SETCARETDIRECTION                       

//    DISPIDs for interface IHighlightRenderingServices

#define DISPID_IHIGHLIGHTRENDERINGSERVICES_ADDSEGMENT             
#define DISPID_IHIGHLIGHTRENDERINGSERVICES_MOVESEGMENTTOPOINTERS  
#define DISPID_IHIGHLIGHTRENDERINGSERVICES_REMOVESEGMENT          

//    DISPIDs for interface ISelectionServicesListener

#define DISPID_ISELECTIONSERVICESLISTENER_BEGINSELECTIONUNDO      
#define DISPID_ISELECTIONSERVICESLISTENER_ENDSELECTIONUNDO        
#define DISPID_ISELECTIONSERVICESLISTENER_ONSELECTEDELEMENTEXIT   
#define DISPID_ISELECTIONSERVICESLISTENER_ONCHANGETYPE            
#define DISPID_ISELECTIONSERVICESLISTENER_GETTYPEDETAIL           

//    DISPIDs for interface ISelectionServices

#define DISPID_ISELECTIONSERVICES_SETSELECTIONTYPE                
#define DISPID_ISELECTIONSERVICES_GETMARKUPCONTAINER              
#define DISPID_ISELECTIONSERVICES_ADDSEGMENT                      
#define DISPID_ISELECTIONSERVICES_ADDELEMENTSEGMENT               
#define DISPID_ISELECTIONSERVICES_REMOVESEGMENT                   
#define DISPID_ISELECTIONSERVICES_GETSELECTIONSERVICESLISTENER    

//    DISPIDs for interface IElementSegment

#define DISPID_IELEMENTSEGMENT_GETELEMENT                         
#define DISPID_IELEMENTSEGMENT_SETPRIMARY                         
#define DISPID_IELEMENTSEGMENT_ISPRIMARY                          

//    DISPIDs for interface IHTMLEditDesigner

#define DISPID_IHTMLEDITDESIGNER_PREHANDLEEVENT                   
#define DISPID_IHTMLEDITDESIGNER_POSTHANDLEEVENT                  
#define DISPID_IHTMLEDITDESIGNER_TRANSLATEACCELERATOR             
#define DISPID_IHTMLEDITDESIGNER_POSTEDITOREVENTNOTIFY            

//    DISPIDs for interface IHTMLEditServices

#define DISPID_IHTMLEDITSERVICES_ADDDESIGNER                      
#define DISPID_IHTMLEDITSERVICES_REMOVEDESIGNER                   
#define DISPID_IHTMLEDITSERVICES_GETSELECTIONSERVICES             
#define DISPID_IHTMLEDITSERVICES_MOVETOSELECTIONANCHOR            
#define DISPID_IHTMLEDITSERVICES_MOVETOSELECTIONEND               
#define DISPID_IHTMLEDITSERVICES_SELECTRANGE                      

//    DISPIDs for interface IHTMLEditServices2

#define DISPID_IHTMLEDITSERVICES2_MOVETOSELECTIONANCHOREX         
#define DISPID_IHTMLEDITSERVICES2_MOVETOSELECTIONENDEX            
#define DISPID_IHTMLEDITSERVICES2_FREEZEVIRTUALCARETPOS           
#define DISPID_IHTMLEDITSERVICES2_UNFREEZEVIRTUALCARETPOS         

//    DISPIDs for interface ILineInfo

#define DISPID_ILINEINFO_X                                        DISPID_ILINEINFO+1
#define DISPID_ILINEINFO_BASELINE                                 DISPID_ILINEINFO+2
#define DISPID_ILINEINFO_TEXTDESCENT                              DISPID_ILINEINFO+3
#define DISPID_ILINEINFO_TEXTHEIGHT                               DISPID_ILINEINFO+4
#define DISPID_ILINEINFO_LINEDIRECTION                            DISPID_ILINEINFO+5

//    DISPIDs for interface IHTMLComputedStyle

#define DISPID_IHTMLCOMPUTEDSTYLE_BOLD                            DISPID_IHTMLCOMPUTEDSTYLE+1
#define DISPID_IHTMLCOMPUTEDSTYLE_ITALIC                          DISPID_IHTMLCOMPUTEDSTYLE+2
#define DISPID_IHTMLCOMPUTEDSTYLE_UNDERLINE                       DISPID_IHTMLCOMPUTEDSTYLE+3
#define DISPID_IHTMLCOMPUTEDSTYLE_OVERLINE                        DISPID_IHTMLCOMPUTEDSTYLE+4
#define DISPID_IHTMLCOMPUTEDSTYLE_STRIKEOUT                       DISPID_IHTMLCOMPUTEDSTYLE+5
#define DISPID_IHTMLCOMPUTEDSTYLE_SUBSCRIPT                       DISPID_IHTMLCOMPUTEDSTYLE+6
#define DISPID_IHTMLCOMPUTEDSTYLE_SUPERSCRIPT                     DISPID_IHTMLCOMPUTEDSTYLE+7
#define DISPID_IHTMLCOMPUTEDSTYLE_EXPLICITFACE                    DISPID_IHTMLCOMPUTEDSTYLE+8
#define DISPID_IHTMLCOMPUTEDSTYLE_FONTWEIGHT                      DISPID_IHTMLCOMPUTEDSTYLE+9
#define DISPID_IHTMLCOMPUTEDSTYLE_FONTSIZE                        DISPID_IHTMLCOMPUTEDSTYLE+10
#define DISPID_IHTMLCOMPUTEDSTYLE_FONTNAME                        DISPID_IHTMLCOMPUTEDSTYLE+11
#define DISPID_IHTMLCOMPUTEDSTYLE_HASBGCOLOR                      DISPID_IHTMLCOMPUTEDSTYLE+12
#define DISPID_IHTMLCOMPUTEDSTYLE_TEXTCOLOR                       DISPID_IHTMLCOMPUTEDSTYLE+13
#define DISPID_IHTMLCOMPUTEDSTYLE_BACKGROUNDCOLOR                 DISPID_IHTMLCOMPUTEDSTYLE+14
#define DISPID_IHTMLCOMPUTEDSTYLE_PREFORMATTED                    DISPID_IHTMLCOMPUTEDSTYLE+15
#define DISPID_IHTMLCOMPUTEDSTYLE_DIRECTION                       DISPID_IHTMLCOMPUTEDSTYLE+16
#define DISPID_IHTMLCOMPUTEDSTYLE_BLOCKDIRECTION                  DISPID_IHTMLCOMPUTEDSTYLE+17
#define DISPID_IHTMLCOMPUTEDSTYLE_OL                              DISPID_IHTMLCOMPUTEDSTYLE+18
#define DISPID_IHTMLCOMPUTEDSTYLE_ISEQUAL                         

//    DISPIDs for interface IDisplayPointer

#define DISPID_IDISPLAYPOINTER_MOVETOPOINT                        
#define DISPID_IDISPLAYPOINTER_MOVEUNIT                           
#define DISPID_IDISPLAYPOINTER_POSITIONMARKUPPOINTER              
#define DISPID_IDISPLAYPOINTER_MOVETOPOINTER                      
#define DISPID_IDISPLAYPOINTER_SETPOINTERGRAVITY                  
#define DISPID_IDISPLAYPOINTER_GETPOINTERGRAVITY                  
#define DISPID_IDISPLAYPOINTER_SETDISPLAYGRAVITY                  
#define DISPID_IDISPLAYPOINTER_GETDISPLAYGRAVITY                  
#define DISPID_IDISPLAYPOINTER_ISPOSITIONED                       
#define DISPID_IDISPLAYPOINTER_UNPOSITION                         
#define DISPID_IDISPLAYPOINTER_ISEQUALTO                          
#define DISPID_IDISPLAYPOINTER_ISLEFTOF                           
#define DISPID_IDISPLAYPOINTER_ISRIGHTOF                          
#define DISPID_IDISPLAYPOINTER_ISATBOL                            
#define DISPID_IDISPLAYPOINTER_MOVETOMARKUPPOINTER                
#define DISPID_IDISPLAYPOINTER_SCROLLINTOVIEW                     
#define DISPID_IDISPLAYPOINTER_GETLINEINFO                        
#define DISPID_IDISPLAYPOINTER_GETFLOWELEMENT                     
#define DISPID_IDISPLAYPOINTER_QUERYBREAKS                        

//    DISPIDs for interface IDisplayServices

#define DISPID_IDISPLAYSERVICES_CREATEDISPLAYPOINTER              
#define DISPID_IDISPLAYSERVICES_TRANSFORMRECT                     
#define DISPID_IDISPLAYSERVICES_TRANSFORMPOINT                    
#define DISPID_IDISPLAYSERVICES_GETCARET                          
#define DISPID_IDISPLAYSERVICES_GETCOMPUTEDSTYLE                  
#define DISPID_IDISPLAYSERVICES_SCROLLRECTINTOVIEW                
#define DISPID_IDISPLAYSERVICES_HASFLOWLAYOUT                     

//    DISPIDs for interface IHtmlDlgSafeHelper

#define DISPID_IHTMLDLGSAFEHELPER_CHOOSECOLORDLG                  1
#define DISPID_IHTMLDLGSAFEHELPER_GETCHARSET                      2
#define DISPID_IHTMLDLGSAFEHELPER_FONTS                           3
#define DISPID_IHTMLDLGSAFEHELPER_BLOCKFORMATS                    4

//    DISPIDs for interface IBlockFormats

#define DISPID_IBLOCKFORMATS__NEWENUM                             DISPID_NEWENUM
#define DISPID_IBLOCKFORMATS_COUNT                                1
#define DISPID_IBLOCKFORMATS_ITEM                                 DISPID_VALUE

//    DISPIDs for interface IFontNames

#define DISPID_IFONTNAMES__NEWENUM                                DISPID_NEWENUM
#define DISPID_IFONTNAMES_COUNT                                   1
#define DISPID_IFONTNAMES_ITEM                                    DISPID_VALUE

//    DISPIDs for interface IHTMLNamespace

#define DISPID_IHTMLNAMESPACE_NAME                                DISPID_NAMESPACE+0
#define DISPID_IHTMLNAMESPACE_URN                                 DISPID_NAMESPACE+1
#define DISPID_IHTMLNAMESPACE_TAGNAMES                            DISPID_NAMESPACE+2
#define DISPID_IHTMLNAMESPACE_READYSTATE                          DISPID_A_READYSTATE
#define DISPID_IHTMLNAMESPACE_ONREADYSTATECHANGE                  DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLNAMESPACE_DOIMPORT                            DISPID_NAMESPACE+3
#define DISPID_IHTMLNAMESPACE_ATTACHEVENT                         DISPID_HTMLOBJECT+7
#define DISPID_IHTMLNAMESPACE_DETACHEVENT                         DISPID_HTMLOBJECT+8

//    DISPIDs for interface IHTMLNamespaceCollection

#define DISPID_IHTMLNAMESPACECOLLECTION_LENGTH                    DISPID_NAMESPACE_COLLECTION+0
#define DISPID_IHTMLNAMESPACECOLLECTION_ITEM                      DISPID_VALUE
#define DISPID_IHTMLNAMESPACECOLLECTION_ADD                       DISPID_NAMESPACE_COLLECTION+1

//    DISPIDs for event set HTMLNamespaceEvents

#define DISPID_HTMLNAMESPACEEVENTS_ONREADYSTATECHANGE             DISPID_EVMETH_ONREADYSTATECHANGE

//    DISPIDs for interface IHTMLPainter

#define DISPID_IHTMLPAINTER_DRAW                                  
#define DISPID_IHTMLPAINTER_ONRESIZE                              
#define DISPID_IHTMLPAINTER_GETPAINTERINFO                        
#define DISPID_IHTMLPAINTER_HITTESTPOINT                          

//    DISPIDs for interface IHTMLPainterEventInfo

#define DISPID_IHTMLPAINTEREVENTINFO_GETEVENTINFOFLAGS            
#define DISPID_IHTMLPAINTEREVENTINFO_GETEVENTTARGET               
#define DISPID_IHTMLPAINTEREVENTINFO_SETCURSOR                    
#define DISPID_IHTMLPAINTEREVENTINFO_STRINGFROMPARTID             

//    DISPIDs for interface IHTMLPainterOverlay

#define DISPID_IHTMLPAINTEROVERLAY_ONMOVE                         

//    DISPIDs for interface IHTMLPaintSite

#define DISPID_IHTMLPAINTSITE_INVALIDATEPAINTERINFO               
#define DISPID_IHTMLPAINTSITE_INVALIDATERECT                      
#define DISPID_IHTMLPAINTSITE_INVALIDATEREGION                    
#define DISPID_IHTMLPAINTSITE_GETDRAWINFO                         
#define DISPID_IHTMLPAINTSITE_TRANSFORMGLOBALTOLOCAL              
#define DISPID_IHTMLPAINTSITE_TRANSFORMLOCALTOGLOBAL              
#define DISPID_IHTMLPAINTSITE_GETHITTESTCOOKIE                    

//    DISPIDs for interface IHTMLIPrintCollection

#define DISPID_IHTMLIPRINTCOLLECTION_LENGTH                       DISPID_OPTIONS_COL+1
#define DISPID_IHTMLIPRINTCOLLECTION__NEWENUM                     DISPID_NEWENUM
#define DISPID_IHTMLIPRINTCOLLECTION_ITEM                         DISPID_VALUE

//    DISPIDs for interface IEnumPrivacyRecords

#define DISPID_IENUMPRIVACYRECORDS_RESET                          
#define DISPID_IENUMPRIVACYRECORDS_GETSIZE                        
#define DISPID_IENUMPRIVACYRECORDS_GETPRIVACYIMPACTED             
#define DISPID_IENUMPRIVACYRECORDS_NEXT                           

//    DISPIDs for interface IHTMLDialog

#define DISPID_IHTMLDIALOG_DIALOGTOP                              STDPROPID_XOBJ_TOP
#define DISPID_IHTMLDIALOG_DIALOGLEFT                             STDPROPID_XOBJ_LEFT
#define DISPID_IHTMLDIALOG_DIALOGWIDTH                            STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLDIALOG_DIALOGHEIGHT                           STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLDIALOG_DIALOGARGUMENTS                        DISPID_HTMLDLG+0
#define DISPID_IHTMLDIALOG_MENUARGUMENTS                          DISPID_HTMLDLG+13
#define DISPID_IHTMLDIALOG_RETURNVALUE                            DISPID_HTMLDLG+1
#define DISPID_IHTMLDIALOG_CLOSE                                  DISPID_HTMLDLG+11
#define DISPID_IHTMLDIALOG_TOSTRING                               DISPID_HTMLDLG+12

//    DISPIDs for interface IHTMLDialog2

#define DISPID_IHTMLDIALOG2_STATUS                                DISPID_HTMLDLG+14
#define DISPID_IHTMLDIALOG2_RESIZABLE                             DISPID_HTMLDLG+15

//    DISPIDs for interface IHTMLDialog3

#define DISPID_IHTMLDIALOG3_UNADORNED                             DISPID_HTMLDLG+16
#define DISPID_IHTMLDIALOG3_DIALOGHIDE                            DISPID_HTMLDLG+7

//    DISPIDs for interface IHTMLModelessInit

#define DISPID_IHTMLMODELESSINIT_PARAMETERS                       DISPID_HTMLDLG+0
#define DISPID_IHTMLMODELESSINIT_OPTIONSTRING                     DISPID_HTMLDLG+1
#define DISPID_IHTMLMODELESSINIT_MONIKER                          DISPID_HTMLDLG+6
#define DISPID_IHTMLMODELESSINIT_DOCUMENT                         DISPID_HTMLDLG+7

//    DISPIDs for interface IHTMLPopup

#define DISPID_IHTMLPOPUP_SHOW                                    DISPID_HTMLPOPUP+1
#define DISPID_IHTMLPOPUP_HIDE                                    DISPID_HTMLPOPUP+2
#define DISPID_IHTMLPOPUP_DOCUMENT                                DISPID_HTMLPOPUP+3
#define DISPID_IHTMLPOPUP_ISOPEN                                  DISPID_HTMLPOPUP+4

//    DISPIDs for interface IHTMLAppBehavior

#define DISPID_IHTMLAPPBEHAVIOR_APPLICATIONNAME                   DISPID_HTMLAPP+0
#define DISPID_IHTMLAPPBEHAVIOR_VERSION                           DISPID_HTMLAPP+1
#define DISPID_IHTMLAPPBEHAVIOR_ICON                              DISPID_HTMLAPP+2
#define DISPID_IHTMLAPPBEHAVIOR_SINGLEINSTANCE                    DISPID_HTMLAPP+3
#define DISPID_IHTMLAPPBEHAVIOR_MINIMIZEBUTTON                    DISPID_HTMLAPP+5
#define DISPID_IHTMLAPPBEHAVIOR_MAXIMIZEBUTTON                    DISPID_HTMLAPP+6
#define DISPID_IHTMLAPPBEHAVIOR_BORDER                            DISPID_HTMLAPP+7
#define DISPID_IHTMLAPPBEHAVIOR_BORDERSTYLE                       DISPID_HTMLAPP+8
#define DISPID_IHTMLAPPBEHAVIOR_SYSMENU                           DISPID_HTMLAPP+9
#define DISPID_IHTMLAPPBEHAVIOR_CAPTION                           DISPID_HTMLAPP+10
#define DISPID_IHTMLAPPBEHAVIOR_WINDOWSTATE                       DISPID_HTMLAPP+11
#define DISPID_IHTMLAPPBEHAVIOR_SHOWINTASKBAR                     DISPID_HTMLAPP+12
#define DISPID_IHTMLAPPBEHAVIOR_COMMANDLINE                       DISPID_HTMLAPP+13

//    DISPIDs for interface IHTMLAppBehavior2

#define DISPID_IHTMLAPPBEHAVIOR2_CONTEXTMENU                      DISPID_HTMLAPP+14
#define DISPID_IHTMLAPPBEHAVIOR2_INNERBORDER                      DISPID_HTMLAPP+15
#define DISPID_IHTMLAPPBEHAVIOR2_SCROLL                           DISPID_HTMLAPP+16
#define DISPID_IHTMLAPPBEHAVIOR2_SCROLLFLAT                       DISPID_HTMLAPP+17
#define DISPID_IHTMLAPPBEHAVIOR2_SELECTION                        DISPID_HTMLAPP+18

//    DISPIDs for interface IHTMLAppBehavior3

#define DISPID_IHTMLAPPBEHAVIOR3_NAVIGABLE                        DISPID_HTMLAPP+19

//    DISPIDs for interface IHTMLPrivateWindow

#define DISPID_IHTMLPRIVATEWINDOW_SUPERNAVIGATE                   
#define DISPID_IHTMLPRIVATEWINDOW_GETPENDINGURL                   
#define DISPID_IHTMLPRIVATEWINDOW_SETPICSTARGET                   
#define DISPID_IHTMLPRIVATEWINDOW_PICSCOMPLETE                    
#define DISPID_IHTMLPRIVATEWINDOW_FINDWINDOWBYNAME                
#define DISPID_IHTMLPRIVATEWINDOW_GETADDRESSBARURL                

//    DISPIDs for interface IHTMLPrivateWindow2

#define DISPID_IHTMLPRIVATEWINDOW2_NAVIGATEEX                     
#define DISPID_IHTMLPRIVATEWINDOW2_GETINNERWINDOWUNKNOWN          

//    DISPIDs for interface IHTMLPrivateWindow3

#define DISPID_IHTMLPRIVATEWINDOW3_OPENEX                         

//    DISPIDs for interface ISubDivisionProvider

#define DISPID_ISUBDIVISIONPROVIDER_GETSUBDIVISIONCOUNT           
#define DISPID_ISUBDIVISIONPROVIDER_GETSUBDIVISIONTABS            
#define DISPID_ISUBDIVISIONPROVIDER_SUBDIVISIONFROMPT             

//    DISPIDs for interface IElementBehaviorUI

#define DISPID_IELEMENTBEHAVIORUI_ONRECEIVEFOCUS                  
#define DISPID_IELEMENTBEHAVIORUI_GETSUBDIVISIONPROVIDER          
#define DISPID_IELEMENTBEHAVIORUI_CANTAKEFOCUS                    

//    DISPIDs for interface IElementAdorner

#define DISPID_IELEMENTADORNER_DRAW                               
#define DISPID_IELEMENTADORNER_HITTESTPOINT                       
#define DISPID_IELEMENTADORNER_GETSIZE                            
#define DISPID_IELEMENTADORNER_GETPOSITION                        
#define DISPID_IELEMENTADORNER_ONPOSITIONSET                      

//    DISPIDs for interface IHTMLEditor

#define DISPID_IHTMLEDITOR_PREHANDLEEVENT                         
#define DISPID_IHTMLEDITOR_POSTHANDLEEVENT                        
#define DISPID_IHTMLEDITOR_TRANSLATEACCELERATOR                   
#define DISPID_IHTMLEDITOR_INITIALIZE                             
#define DISPID_IHTMLEDITOR_NOTIFY                                 
#define DISPID_IHTMLEDITOR_GETCOMMANDTARGET                       
#define DISPID_IHTMLEDITOR_GETELEMENTTOTABFROM                    
#define DISPID_IHTMLEDITOR_ISEDITCONTEXTUIACTIVE                  
#define DISPID_IHTMLEDITOR_TERMINATEIMECOMPOSITION                
#define DISPID_IHTMLEDITOR_ENABLEMODELESS                         

//    DISPIDs for interface IHTMLEditingServices

#define DISPID_IHTMLEDITINGSERVICES_DELETE                        
#define DISPID_IHTMLEDITINGSERVICES_PASTE                         
#define DISPID_IHTMLEDITINGSERVICES_PASTEFROMCLIPBOARD            
#define DISPID_IHTMLEDITINGSERVICES_LAUNDERSPACES                 
#define DISPID_IHTMLEDITINGSERVICES_INSERTSANITIZEDTEXT           
#define DISPID_IHTMLEDITINGSERVICES_URLAUTODETECTCURRENTWORD      
#define DISPID_IHTMLEDITINGSERVICES_URLAUTODETECTRANGE            
#define DISPID_IHTMLEDITINGSERVICES_SHOULDUPDATEANCHORTEXT        
#define DISPID_IHTMLEDITINGSERVICES_ADJUSTPOINTERFORINSERT        
#define DISPID_IHTMLEDITINGSERVICES_FINDSITESELECTABLEELEMENT     
#define DISPID_IHTMLEDITINGSERVICES_ISELEMENTSITESELECTABLE       
#define DISPID_IHTMLEDITINGSERVICES_ISELEMENTUIACTIVATABLE        
#define DISPID_IHTMLEDITINGSERVICES_ISELEMENTATOMIC               
#define DISPID_IHTMLEDITINGSERVICES_POSITIONPOINTERSINMASTER      

//    DISPIDs for interface ISelectionObject2

#define DISPID_ISELECTIONOBJECT2_SELECT                           
#define DISPID_ISELECTIONOBJECT2_ISPOINTERINSELECTION             
#define DISPID_ISELECTIONOBJECT2_EMPTYSELECTION                   
#define DISPID_ISELECTIONOBJECT2_DESTROYSELECTION                 
#define DISPID_ISELECTIONOBJECT2_DESTROYALLSELECTION              

//    DISPIDs for interface IEditDebugServices

#define DISPID_IEDITDEBUGSERVICES_GETCP                           
#define DISPID_IEDITDEBUGSERVICES_SETDEBUGNAME                    
#define DISPID_IEDITDEBUGSERVICES_SETDISPLAYPOINTERDEBUGNAME      
#define DISPID_IEDITDEBUGSERVICES_DUMPTREE                        
#define DISPID_IEDITDEBUGSERVICES_LINESINELEMENT                  
#define DISPID_IEDITDEBUGSERVICES_FONTSONLINE                     
#define DISPID_IEDITDEBUGSERVICES_GETPIXEL                        
#define DISPID_IEDITDEBUGSERVICES_ISUSINGBCKGRNRECALC             
#define DISPID_IEDITDEBUGSERVICES_ISENCODINGAUTOSELECT            
#define DISPID_IEDITDEBUGSERVICES_ENABLEENCODINGAUTOSELECT        
#define DISPID_IEDITDEBUGSERVICES_ISUSINGTABLEINCRECALC           

//    DISPIDs for interface IPrivacyServices

#define DISPID_IPRIVACYSERVICES_ADDPRIVACYINFOTOLIST              

//    DISPIDs for interface IHTMLOMWindowServices

#define DISPID_IHTMLOMWINDOWSERVICES_MOVETO                       
#define DISPID_IHTMLOMWINDOWSERVICES_MOVEBY                       
#define DISPID_IHTMLOMWINDOWSERVICES_RESIZETO                     
#define DISPID_IHTMLOMWINDOWSERVICES_RESIZEBY                     

//    DISPIDs for interface IHTMLFilterPainter

#define DISPID_IHTMLFILTERPAINTER_INVALIDATERECTUNFILTERED        
#define DISPID_IHTMLFILTERPAINTER_INVALIDATERGNUNFILTERED         
#define DISPID_IHTMLFILTERPAINTER_CHANGEELEMENTVISIBILITY         

//    DISPIDs for interface IHTMLFilterPaintSite

#define DISPID_IHTMLFILTERPAINTSITE_DRAWUNFILTERED                
#define DISPID_IHTMLFILTERPAINTSITE_HITTESTPOINTUNFILTERED        
#define DISPID_IHTMLFILTERPAINTSITE_INVALIDATERECTFILTERED        
#define DISPID_IHTMLFILTERPAINTSITE_INVALIDATERGNFILTERED         
#define DISPID_IHTMLFILTERPAINTSITE_CHANGEFILTERVISIBILITY        
#define DISPID_IHTMLFILTERPAINTSITE_ENSUREVIEWFORFILTERSITE       
#define DISPID_IHTMLFILTERPAINTSITE_GETDIRECTDRAW                 
#define DISPID_IHTMLFILTERPAINTSITE_GETFILTERFLAGS                

//    DISPIDs for interface IElementNamespacePrivate

#define DISPID_IELEMENTNAMESPACEPRIVATE_ADDTAGPRIVATE             

//    DISPIDs for interface IElementBehaviorFactory

#define DISPID_IELEMENTBEHAVIORFACTORY_FINDBEHAVIOR               

//    DISPIDs for interface IElementNamespace

#define DISPID_IELEMENTNAMESPACE_ADDTAG                           

//    DISPIDs for interface IElementNamespaceTable

#define DISPID_IELEMENTNAMESPACETABLE_ADDNAMESPACE                

//    DISPIDs for interface IElementNamespaceFactory

#define DISPID_IELEMENTNAMESPACEFACTORY_CREATE                    

//    DISPIDs for interface IElementNamespaceFactory2

#define DISPID_IELEMENTNAMESPACEFACTORY2_CREATEWITHIMPLEMENTATION 

//    DISPIDs for interface IElementNamespaceFactoryCallback

#define DISPID_IELEMENTNAMESPACEFACTORYCALLBACK_RESOLVE           

//    DISPIDs for interface IElementBehavior

#define DISPID_IELEMENTBEHAVIOR_INIT                              
#define DISPID_IELEMENTBEHAVIOR_NOTIFY                            
#define DISPID_IELEMENTBEHAVIOR_DETACH                            

//    DISPIDs for interface IElementBehaviorSite

#define DISPID_IELEMENTBEHAVIORSITE_GETELEMENT                    
#define DISPID_IELEMENTBEHAVIORSITE_REGISTERNOTIFICATION          

//    DISPIDs for interface IElementBehaviorSiteOM

#define DISPID_IELEMENTBEHAVIORSITEOM_REGISTEREVENT               
#define DISPID_IELEMENTBEHAVIORSITEOM_GETEVENTCOOKIE              
#define DISPID_IELEMENTBEHAVIORSITEOM_FIREEVENT                   
#define DISPID_IELEMENTBEHAVIORSITEOM_CREATEEVENTOBJECT           
#define DISPID_IELEMENTBEHAVIORSITEOM_REGISTERNAME                
#define DISPID_IELEMENTBEHAVIORSITEOM_REGISTERURN                 

//    DISPIDs for interface IElementBehaviorSiteOM2

#define DISPID_IELEMENTBEHAVIORSITEOM2_GETDEFAULTS                

//    DISPIDs for interface IElementBehaviorRender

#define DISPID_IELEMENTBEHAVIORRENDER_DRAW                        
#define DISPID_IELEMENTBEHAVIORRENDER_GETRENDERINFO               
#define DISPID_IELEMENTBEHAVIORRENDER_HITTESTPOINT                

//    DISPIDs for interface IElementBehaviorSiteRender

#define DISPID_IELEMENTBEHAVIORSITERENDER_INVALIDATE              
#define DISPID_IELEMENTBEHAVIORSITERENDER_INVALIDATERENDERINFO    
#define DISPID_IELEMENTBEHAVIORSITERENDER_INVALIDATESTYLE         

//    DISPIDs for interface IElementBehaviorCategory

#define DISPID_IELEMENTBEHAVIORCATEGORY_GETCATEGORY               

//    DISPIDs for interface IElementBehaviorSiteCategory

#define DISPID_IELEMENTBEHAVIORSITECATEGORY_GETRELATEDBEHAVIORS   

//    DISPIDs for interface IElementBehaviorSubmit

#define DISPID_IELEMENTBEHAVIORSUBMIT_GETSUBMITINFO               
#define DISPID_IELEMENTBEHAVIORSUBMIT_RESET                       

//    DISPIDs for interface IElementBehaviorFocus

#define DISPID_IELEMENTBEHAVIORFOCUS_GETFOCUSRECT                 

//    DISPIDs for interface IElementBehaviorLayout

#define DISPID_IELEMENTBEHAVIORLAYOUT_GETSIZE                     
#define DISPID_IELEMENTBEHAVIORLAYOUT_GETLAYOUTINFO               
#define DISPID_IELEMENTBEHAVIORLAYOUT_GETPOSITION                 
#define DISPID_IELEMENTBEHAVIORLAYOUT_MAPSIZE                     

//    DISPIDs for interface IElementBehaviorLayout2

#define DISPID_IELEMENTBEHAVIORLAYOUT2_GETTEXTDESCENT             

//    DISPIDs for interface IElementBehaviorSiteLayout

#define DISPID_IELEMENTBEHAVIORSITELAYOUT_INVALIDATELAYOUTINFO    
#define DISPID_IELEMENTBEHAVIORSITELAYOUT_INVALIDATESIZE          
#define DISPID_IELEMENTBEHAVIORSITELAYOUT_GETMEDIARESOLUTION      

//    DISPIDs for interface IElementBehaviorSiteLayout2

#define DISPID_IELEMENTBEHAVIORSITELAYOUT2_GETFONTINFO            

//    DISPIDs for interface IHostBehaviorInit

#define DISPID_IHOSTBEHAVIORINIT_POPULATENAMESPACETABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\mstimeid.h ===
// Copyright (C) Microsoft Corporation, 1999
//
// IDs for HTML+TIME
//
// Just follow the template when adding either DISPIDs or new interfaces.
//

#ifndef __TIMEDISPID_H__
#define __TIMEDISPID_H__

// Base offset:

//
// need to reposition our IDs low for DHTML Behaviors
//

#define DISPID_BASE                                             0x00000000

// Interface offsets:
#define TIMEELEMENT_OFFSET                                      0x0100
#define TIMEBODYELEMENT_OFFSET                                  0x0200
#define TIMEANIMATIONELEMENT_OFFSET                             0x0300
#define TIMEMEDIAELEMENT_OFFSET                                 0x0400
#define TIMEFACTORY_OFFSET                                      0x0500
#define TIMECOLLECTION_OFFSET                                   0x0600
#define TIMECOLLECTION_RESERVED_OFFSET                          0x0700
#define TIMEMEDIAPLAYER_OFFSET                                  0x0800
#define TIMEMEDIAPLAYERAUDIO_OFFSET                             0x0900
#define TIMEEVENTELEMENT_OFFSET                                 0x0A00
#define TIMEPLAYLIST_OFFSET                                     0x0B00
#define TIMEPLAYITEM_OFFSET                                     0x0C00
#define TIMEDVDPLAYEROBJECT_OFFSET                              0x0D00
#define SMILANIMATIONCOMPSITE_OFFSET                            0x0E00
#define SMILANIMATIONFRAGMENT_OFFSET                            0x0F00
#define TIMESTATE_OFFSET                                        0x1000
#define TIMEDMPLAYEROBJECT_OFFSET                               0x1100
#define TIMEMEDIAPLAYERSITE_OFFSET                              0x1200
#define TIMEMEDIAPLAYERCONTROL_OFFSET                           0x1300
#define TIMEMEDIAELEMENT2_OFFSET                                0x1400
#define TIMETRANSITIONELEMENT_OFFSET                            0x1500
#define TIMEMEDIAPLAYERNETWORK_OFFSET                           0x1600

#define DISPID_TIME_MIN                                         0x0001
#define DISPID_TIME_MAX                                         0x270F

// Interface bases:
#define DISPID_TIMEELEMENT_BASE                                 (DISPID_BASE + TIMEELEMENT_OFFSET)
#define DISPID_TIMEBODYELEMENT_BASE                             (DISPID_BASE + TIMEBODYELEMENT_OFFSET)
#define DISPID_TIMEMEDIAELEMENT_BASE                            (DISPID_BASE + TIMEMEDIAELEMENT_OFFSET)
#define DISPID_TIMEEVENTELEMENT_BASE                            (DISPID_BASE + TIMEEVENTELEMENT_OFFSET)
#define DISPID_TIMEFACTORY_BASE                                 (DISPID_BASE + TIMEFACTORY_OFFSET)
#define DISPID_TIMECOLLECTION_BASE                              (DISPID_BASE + TIMECOLLECTION_OFFSET)
#define DISPID_TIMECOLLECTION_RESERVED_BASE                     (DISPID_BASE + TIMECOLLECTION_RESERVED_OFFSET)
#define DISPID_TIMEMEDIAPLAYER_BASE                             (DISPID_BASE + TIMEMEDIAPLAYER_OFFSET)
#define DISPID_TIMEMEDIAPLAYERAUDIO_BASE                        (DISPID_BASE + TIMEMEDIAPLAYERAUDIO_OFFSET)
#define DISPID_TIMEPLAYLIST_BASE                                (DISPID_BASE + TIMEPLAYLIST_OFFSET)
#define DISPID_TIMEPLAYITEM_BASE                                (DISPID_BASE + TIMEPLAYITEM_OFFSET)
#define DISPID_TIMEDVDPLAYEROBJECT_BASE                         (DISPID_BASE + TIMEDVDPLAYEROBJECT_OFFSET)
#define DISPID_TIMEANIMATIONELEMENT_BASE                        (DISPID_BASE + TIMEANIMATIONELEMENT_OFFSET)
#define DISPID_SMILANIMATIONCOMPSITE_BASE                       (DISPID_BASE + SMILANIMATIONCOMPSITE_OFFSET)
#define DISPID_SMILANIMATIONFRAGMENT_BASE                       (DISPID_BASE + SMILANIMATIONFRAGMENT_OFFSET)
#define DISPID_TIMESTATE_BASE                                   (DISPID_BASE + TIMESTATE_OFFSET)
#define DISPID_TIMEDMPLAYEROBJECT_BASE                          (DISPID_BASE + TIMEDMPLAYEROBJECT_OFFSET)
#define DISPID_TIMEMEDIAPLAYERSITE_BASE                         (DISPID_BASE + TIMEMEDIAPLAYERSITE_OFFSET)
#define DISPID_TIMEMEDIAPLAYERCONTROL_BASE                      (DISPID_BASE + TIMEMEDIAPLAYERCONTROL_OFFSET)
#define DISPID_TIMEMEDIAELEMENT2_BASE                           (DISPID_BASE + TIMEMEDIAELEMENT2_OFFSET)
#define DISPID_TIMETRANSITIONELEMENT_BASE                       (DISPID_BASE + TIMETRANSITIONELEMENT_OFFSET)
#define DISPID_TIMEMEDIAPLAYERNETWORK_BASE                      (DISPID_BASE + TIMEMEDIAPLAYERNETWORK_OFFSET)

// Collection Reserve (for expando's and ordinal's)
#define DISPID_COLLECTION_RESERVED_MIN                          DISPID_TIMECOLLECTION_RESERVED_BASE
#define DISPID_COLLECTION_RESERVED_MAX                          0x0000007FF

// =============================================
// ITIMEElement DISPIDs:
// =============================================

// XML Attributes
#define DISPID_TIMEELEMENT_ACCELERATE                           (DISPID_TIMEELEMENT_BASE + 0x01)
#define DISPID_TIMEELEMENT_ACCELERATEFROM                       (DISPID_TIMEELEMENT_BASE + 0x02)
#define DISPID_TIMEELEMENT_AUTOREVERSE                          (DISPID_TIMEELEMENT_BASE + 0x03)
#define DISPID_TIMEELEMENT_BEGIN                                (DISPID_TIMEELEMENT_BASE + 0x04)
#define DISPID_TIMEELEMENT_DECELERATE                           (DISPID_TIMEELEMENT_BASE + 0x05)
#define DISPID_TIMEELEMENT_DECELERATETO                         (DISPID_TIMEELEMENT_BASE + 0x06)
#define DISPID_TIMEELEMENT_DUR                                  (DISPID_TIMEELEMENT_BASE + 0x07)
#define DISPID_TIMEELEMENT_END                                  (DISPID_TIMEELEMENT_BASE + 0x08)
#define DISPID_TIMEELEMENT_FILL                                 (DISPID_TIMEELEMENT_BASE + 0x0a)
#define DISPID_TIMEELEMENT_MUTE                                 (DISPID_TIMEELEMENT_BASE + 0x0b)
#define DISPID_TIMEELEMENT_REPEATCOUNT                          (DISPID_TIMEELEMENT_BASE + 0x0c)
#define DISPID_TIMEELEMENT_REPEATDUR                            (DISPID_TIMEELEMENT_BASE + 0x0d)
#define DISPID_TIMEELEMENT_RESTART                              (DISPID_TIMEELEMENT_BASE + 0x0e)
#define DISPID_TIMEELEMENT_SPEED                                (DISPID_TIMEELEMENT_BASE + 0x0f)
#define DISPID_TIMEELEMENT_SYNCBEHAVIOR                         (DISPID_TIMEELEMENT_BASE + 0x10)
#define DISPID_TIMEELEMENT_SYNCMASTER                           (DISPID_TIMEELEMENT_BASE + 0x11)
#define DISPID_TIMEELEMENT_SYNCTOLERANCE                        (DISPID_TIMEELEMENT_BASE + 0x12)
#define DISPID_TIMEELEMENT_TIMEACTION                           (DISPID_TIMEELEMENT_BASE + 0x13)
#define DISPID_TIMEELEMENT_TIMECONTAINER                        (DISPID_TIMEELEMENT_BASE + 0x14)
#define DISPID_TIMEELEMENT_UPDATEMODE                           (DISPID_TIMEELEMENT_BASE + 0x15)
#define DISPID_TIMEELEMENT_VOLUME                               (DISPID_TIMEELEMENT_BASE + 0x16)

// Properties
#define DISPID_TIMEELEMENT_CURRTIMESTATE                        (DISPID_TIMEELEMENT_BASE + 0x20)
#define DISPID_TIMEELEMENT_TIMEALL                              (DISPID_TIMEELEMENT_BASE + 0x21)
#define DISPID_TIMEELEMENT_TIMECHILDREN                         (DISPID_TIMEELEMENT_BASE + 0x22)
#define DISPID_TIMEELEMENT_TIMEPARENT                           (DISPID_TIMEELEMENT_BASE + 0x23)
#define DISPID_TIMEELEMENT_ISPAUSED                             (DISPID_TIMEELEMENT_BASE + 0x24)

// Methods
#define DISPID_TIMEELEMENT_BEGINELEMENT                         (DISPID_TIMEELEMENT_BASE + 0x30)
#define DISPID_TIMEELEMENT_BEGINELEMENTAT                       (DISPID_TIMEELEMENT_BASE + 0x31)
#define DISPID_TIMEELEMENT_ENDELEMENT                           (DISPID_TIMEELEMENT_BASE + 0x32)
#define DISPID_TIMEELEMENT_ENDELEMENTAT                         (DISPID_TIMEELEMENT_BASE + 0x33)
#define DISPID_TIMEELEMENT_PAUSEELEMENT                         (DISPID_TIMEELEMENT_BASE + 0x34)
#define DISPID_TIMEELEMENT_RESET                                (DISPID_TIMEELEMENT_BASE + 0x35)
#define DISPID_TIMEELEMENT_RESUMEELEMENT                        (DISPID_TIMEELEMENT_BASE + 0x36)
#define DISPID_TIMEELEMENT_SEEKACTIVETIME                       (DISPID_TIMEELEMENT_BASE + 0x37)
#define DISPID_TIMEELEMENT_SEEKSEGMENTTIME                      (DISPID_TIMEELEMENT_BASE + 0x38)
#define DISPID_TIMEELEMENT_SEEKTO                               (DISPID_TIMEELEMENT_BASE + 0x39)
#define DISPID_TIMEELEMENT_UPDATE                               (DISPID_TIMEELEMENT_BASE + 0x3a)
#define DISPID_TIMEELEMENT_DOCUMENTTIMETOPARENTTIME             (DISPID_TIMEELEMENT_BASE + 0x3b)
#define DISPID_TIMEELEMENT_PARENTTIMETODOCUMENTTIME             (DISPID_TIMEELEMENT_BASE + 0x3c)
#define DISPID_TIMEELEMENT_PARENTTIMETOACTIVETIME               (DISPID_TIMEELEMENT_BASE + 0x3d)
#define DISPID_TIMEELEMENT_ACTIVETIMETOPARENTTIME               (DISPID_TIMEELEMENT_BASE + 0x3e)
#define DISPID_TIMEELEMENT_ACTIVETIMETOSEGMENTTIME              (DISPID_TIMEELEMENT_BASE + 0x3f)
#define DISPID_TIMEELEMENT_SEGMENTTIMETOACTIVETIME              (DISPID_TIMEELEMENT_BASE + 0x40)
#define DISPID_TIMEELEMENT_SEGMENTTIMETOSIMPLETIME              (DISPID_TIMEELEMENT_BASE + 0x41)
#define DISPID_TIMEELEMENT_SIMPLETIMETOSEGMENTTIME              (DISPID_TIMEELEMENT_BASE + 0x42)

// Container attributes
#define DISPID_TIMEELEMENT_ENDSYNC                              (DISPID_TIMEELEMENT_BASE + 0x50)

// Container Properties
#define DISPID_TIMEELEMENT_ACTIVEELEMENTS                       (DISPID_TIMEELEMENT_BASE + 0x60)
#define DISPID_TIMEELEMENT_HASMEDIA                             (DISPID_TIMEELEMENT_BASE + 0x61)

// Container Methods
#define DISPID_TIMEELEMENT_NEXTELEMENT                          (DISPID_TIMEELEMENT_BASE + 0x70)
#define DISPID_TIMEELEMENT_PREVELEMENT                          (DISPID_TIMEELEMENT_BASE + 0x71)

//
// ITIMEBodyElement DISPIDs:
//

// empty interface


// =============================================
// ITIMEMediaElement DISPIDs:
// =============================================

// XML Attributes
#define DISPID_TIMEMEDIAELEMENT_CLIPBEGIN                       (DISPID_TIMEMEDIAELEMENT_BASE + 0x01)
#define DISPID_TIMEMEDIAELEMENT_CLIPEND                         (DISPID_TIMEMEDIAELEMENT_BASE + 0x02)
#define DISPID_TIMEMEDIAELEMENT_PLAYER                          (DISPID_TIMEMEDIAELEMENT_BASE + 0x03)
#define DISPID_TIMEMEDIAELEMENT_SRC                             (DISPID_TIMEMEDIAELEMENT_BASE + 0x04)
#define DISPID_TIMEMEDIAELEMENT_TYPE                            (DISPID_TIMEMEDIAELEMENT_BASE + 0x05)

// Properties
#define DISPID_TIMEMEDIAELEMENT_ABSTRACT                        (DISPID_TIMEMEDIAELEMENT_BASE + 0x10)
#define DISPID_TIMEMEDIAELEMENT_AUTHOR                          (DISPID_TIMEMEDIAELEMENT_BASE + 0x11)
#define DISPID_TIMEMEDIAELEMENT_COPYRIGHT                       (DISPID_TIMEMEDIAELEMENT_BASE + 0x12)
#define DISPID_TIMEMEDIAELEMENT_HASAUDIO                        (DISPID_TIMEMEDIAELEMENT_BASE + 0x13)
#define DISPID_TIMEMEDIAELEMENT_HASVISUAL                       (DISPID_TIMEMEDIAELEMENT_BASE + 0x14)
#define DISPID_TIMEMEDIAELEMENT_MEDIACAPS                       (DISPID_TIMEMEDIAELEMENT_BASE + 0x15)
#define DISPID_TIMEMEDIAELEMENT_MEDIADUR                        (DISPID_TIMEMEDIAELEMENT_BASE + 0x16)
#define DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT                     (DISPID_TIMEMEDIAELEMENT_BASE + 0x17)
#define DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH                      (DISPID_TIMEMEDIAELEMENT_BASE + 0x18)
#define DISPID_TIMEMEDIAELEMENT_PLAYEROBJECT                    (DISPID_TIMEMEDIAELEMENT_BASE + 0x19)
#define DISPID_TIMEMEDIAELEMENT_PLAYLIST                        (DISPID_TIMEMEDIAELEMENT_BASE + 0x1a)
#define DISPID_TIMEMEDIAELEMENT_RATING                          (DISPID_TIMEMEDIAELEMENT_BASE + 0x1b)
#define DISPID_TIMEMEDIAELEMENT_TITLE                           (DISPID_TIMEMEDIAELEMENT_BASE + 0x1c)
#define DISPID_TIMEMEDIAELEMENT_HASPLAYLIST                     (DISPID_TIMEMEDIAELEMENT_BASE + 0x1d)


// Media Caps
#define DISPID_TIMEMEDIAELEMENT_CANPAUSE                        (DISPID_TIMEMEDIAELEMENT_BASE + 0x30)
#define DISPID_TIMEMEDIAELEMENT_CANSEEK                         (DISPID_TIMEMEDIAELEMENT_BASE + 0x32)

// Methods

// =============================================
// ITIMEAnimationElement DISPIDs
// =============================================

#define DISPID_TIMEANIMATIONELEMENT_ATTRIBUTENAME               (DISPID_TIMEANIMATIONELEMENT_BASE + 0x01)
#define DISPID_TIMEANIMATIONELEMENT_BY                          (DISPID_TIMEANIMATIONELEMENT_BASE + 0x02)
#define DISPID_TIMEANIMATIONELEMENT_CALCMODE                    (DISPID_TIMEANIMATIONELEMENT_BASE + 0x03)
#define DISPID_TIMEANIMATIONELEMENT_FROM                        (DISPID_TIMEANIMATIONELEMENT_BASE + 0x04)
#define DISPID_TIMEANIMATIONELEMENT_KEYSPLINES                  (DISPID_TIMEANIMATIONELEMENT_BASE + 0x05)
#define DISPID_TIMEANIMATIONELEMENT_KEYTIMES                    (DISPID_TIMEANIMATIONELEMENT_BASE + 0x06)
#define DISPID_TIMEANIMATIONELEMENT_TARGETELEMENT               (DISPID_TIMEANIMATIONELEMENT_BASE + 0x07)
#define DISPID_TIMEANIMATIONELEMENT_TO                          (DISPID_TIMEANIMATIONELEMENT_BASE + 0x08)
#define DISPID_TIMEANIMATIONELEMENT_VALUES                      (DISPID_TIMEANIMATIONELEMENT_BASE + 0x09)

#define DISPID_TIMEANIMATIONELEMENT_ORIGIN                      (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0a)
#define DISPID_TIMEANIMATIONELEMENT_PATH                        (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0b)

#define DISPID_TIMEANIMATIONELEMENT_ADDITIVE                    (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0c)
#define DISPID_TIMEANIMATIONELEMENT_ACCUMULATE                  (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0d)

#define DISPID_TIMEANIMATIONELEMENT_TYPE                        (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0e)
#define DISPID_TIMEANIMATIONELEMENT_SUBTYPE                     (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0f)
#define DISPID_TIMEANIMATIONELEMENT_MODE                        (DISPID_TIMEANIMATIONELEMENT_BASE + 0x10)
#define DISPID_TIMEANIMATIONELEMENT_FADECOLOR                   (DISPID_TIMEANIMATIONELEMENT_BASE + 0x11)

// IAnimationComposerSite DISPIDs
#define DISPID_SMILANIMATIONCOMPSITE_ADDFRAGMENT                (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x01)
#define DISPID_SMILANIMATIONCOMPSITE_REMOVEFRAGMENT             (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x02)
#define DISPID_SMILANIMATIONCOMPSITE_INSERTFRAGMENT             (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x03)
#define DISPID_SMILANIMATIONCOMPSITE_ENUMERATEFRAGMENTS         (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x04)
#define DISPID_SMILANIMATIONCOMPSITE_REGISTERFACTORY            (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x05)
#define DISPID_SMILANIMATIONCOMPSITE_UNREGISTER_FACTORY         (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x06)

// IAnimationFragment
#define DISPID_SMILANIMATIONFRAGMENT_ELEMENT                    (DISPID_SMILANIMATIONFRAGMENT_BASE + 0x01)
#define DISPID_SMILANIMATIONFRAGMENT_VALUE                      (DISPID_SMILANIMATIONFRAGMENT_BASE + 0x02)
#define DISPID_SMILANIMATIONFRAGMENT_DETACHFROMCOMPOSER         (DISPID_SMILANIMATIONFRAGMENT_BASE + 0x03)

// ITIMEEventElement DISPIDs:
#define DISPID_TIMEEVENTELEMENT_TYPE                            (DISPID_TIMEEVENTELEMENT_BASE + 0x01)
#define DISPID_TIMEEVENTELEMENT_ACTIVE                          (DISPID_TIMEEVENTELEMENT_BASE + 0x02)

// ITIMEFactory DISPIDs:
#define DISPID_TIMEFACTORY_CREATETIMEELEMENT                    (DISPID_TIMEFACTORY_BASE + 0x01)
#define DISPID_TIMEFACTORY_CREATETIMEELEMENTBODY                (DISPID_TIMEFACTORY_BASE + 0x02)
#define DISPID_TIMEFACTORY_CREATETIMEDAELEMENT                  (DISPID_TIMEFACTORY_BASE + 0x03)
#define DISPID_TIMEFACTORY_CREATETIMEMEDIAELEMENT               (DISPID_TIMEFACTORY_BASE + 0x04)

//
// ITIMEElementCollection
//
#define DISPID_TIMEELEMENTCOLLECTION_LENGTH                     (DISPID_TIMECOLLECTION_BASE + 0x01)
#define DISPID_TIMEELEMENTCOLLECTION__NEWENUM                   (DISPID_NEWENUM)
#define DISPID_TIMEELEMENTCOLLECTION_ITEM                       (DISPID_VALUE)
#define DISPID_TIMEELEMENTCOLLECTION_TAGS                       (DISPID_TIMECOLLECTION_BASE + 0x02)

//
// ITIMEMediaPlayerSite
//

#define DISPID_TIMEMEDIAPLAYERSITE_TIMEELEMENT                  (DISPID_TIMEMEDIAPLAYERSITE_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYERSITE_TIMESTATE                    (DISPID_TIMEMEDIAPLAYERSITE_BASE + 0x02)
#define DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR                  (DISPID_TIMEMEDIAPLAYERSITE_BASE + 0x03)

//
// ITIMEMediaPlayer
//

#define DISPID_TIMEMEDIAPLAYER_INIT                             (DISPID_TIMEMEDIAPLAYER_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYER_DETACH                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x02)

#define DISPID_TIMEMEDIAPLAYER_BEGIN                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x10)
#define DISPID_TIMEMEDIAPLAYER_END                              (DISPID_TIMEMEDIAPLAYER_BASE + 0x11)
#define DISPID_TIMEMEDIAPLAYER_RESUME                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x12)
#define DISPID_TIMEMEDIAPLAYER_PAUSE                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x13)
#define DISPID_TIMEMEDIAPLAYER_REPEAT                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x14)
#define DISPID_TIMEMEDIAPLAYER_RESET                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x15)
#define DISPID_TIMEMEDIAPLAYER_SEEK                             (DISPID_TIMEMEDIAPLAYER_BASE + 0x16)

// Properties - w
#define DISPID_TIMEMEDIAPLAYER_SRC                              (DISPID_TIMEMEDIAPLAYER_BASE + 0x20)
#define DISPID_TIMEMEDIAPLAYER_CLIPBEGIN                        (DISPID_TIMEMEDIAPLAYER_BASE + 0x21)
#define DISPID_TIMEMEDIAPLAYER_CLIPEND                          (DISPID_TIMEMEDIAPLAYER_BASE + 0x22)

// Properties - r/o
#define DISPID_TIMEMEDIAPLAYER_ABSTRACT                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x30)
#define DISPID_TIMEMEDIAPLAYER_AUTHOR                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x31)
#define DISPID_TIMEMEDIAPLAYER_CANPAUSE                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x32)
#define DISPID_TIMEMEDIAPLAYER_CANSEEK                          (DISPID_TIMEMEDIAPLAYER_BASE + 0x34)
#define DISPID_TIMEMEDIAPLAYER_CLIPDUR                          (DISPID_TIMEMEDIAPLAYER_BASE + 0x35)
#define DISPID_TIMEMEDIAPLAYER_COPYRIGHT                        (DISPID_TIMEMEDIAPLAYER_BASE + 0x36)
#define DISPID_TIMEMEDIAPLAYER_CURRTIME                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x37)
#define DISPID_TIMEMEDIAPLAYER_CUSTOM_OBJECT                    (DISPID_TIMEMEDIAPLAYER_BASE + 0x38)
#define DISPID_TIMEMEDIAPLAYER_HASAUDIO                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x39)
#define DISPID_TIMEMEDIAPLAYER_HASVISUAL                        (DISPID_TIMEMEDIAPLAYER_BASE + 0x3A)
#define DISPID_TIMEMEDIAPLAYER_MEDIADUR                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x3B)
#define DISPID_TIMEMEDIAPLAYER_MEDIAHEIGHT                      (DISPID_TIMEMEDIAPLAYER_BASE + 0x3C)
#define DISPID_TIMEMEDIAPLAYER_MEDIAWIDTH                       (DISPID_TIMEMEDIAPLAYER_BASE + 0x3D)
#define DISPID_TIMEMEDIAPLAYER_PLAYLIST                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x3E)
#define DISPID_TIMEMEDIAPLAYER_RATING                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x3F)
#define DISPID_TIMEMEDIAPLAYER_STATE                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x40)
#define DISPID_TIMEMEDIAPLAYER_TITLE                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x41)

//
// ITIMEMediaPlayerAudio
//
#define DISPID_TIMEMEDIAPLAYERAUDIO_VOLUME                      (DISPID_TIMEMEDIAPLAYERAUDIO_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYERAUDIO_MUTE                        (DISPID_TIMEMEDIAPLAYERAUDIO_BASE + 0x02)

//
// ITIMEMediaPlayerNetwork
//
#define DISPID_TIMEMEDIAPLAYERNETWORK_HASDOWNLOADPROGRESS       (DISPID_TIMEMEDIAPLAYERNETWORK_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYERNETWORK_DOWNLOADPROGRESS          (DISPID_TIMEMEDIAPLAYERNETWORK_BASE + 0x02)
#define DISPID_TIMEMEDIAPLAYERNETWORK_ISBUFFERED                (DISPID_TIMEMEDIAPLAYERNETWORK_BASE + 0x03)
#define DISPID_TIMEMEDIAPLAYERNETWORK_BUFFERINGPROGRESS         (DISPID_TIMEMEDIAPLAYERNETWORK_BASE + 0x04)

//
// ITIMEMediaPlayerControl
//

#define DISPID_TIMEMEDIAPLAYERCONTROL_GETCONTROL                (DISPID_TIMEMEDIAPLAYERCONTROL_BASE + 0x01)

// ITIMEActiveElementsCollection
#define DISPID_ACTIVEELMENTS_LENGTH                             (0x000005dc) //special dispid specific to collections
#define DISPID_ACTIVEELMENTS_NEWENUM                            (DISPID_NEWENUM)
#define DISPID_ACTIVEELMENTS_ITEM                               (0x00000000) //designates this as the default value for this collection.


// ITIMEPlayList collectoion
#define DISPID_TIMEPLAYLIST_ACTIVETRACK                         (DISPID_TIMEPLAYLIST_BASE + 0x01)
#define DISPID_TIMEPLAYLIST_DUR                                 (DISPID_TIMEPLAYLIST_BASE + 0x02)
#define DISPID_TIMEPLAYLIST_ITEM                                (0x00000000) //designates this as the default value for this collection.
#define DISPID_TIMEPLAYLIST_LENGTH                              (0x000005dc) //special dispid specific to collections
#define DISPID_TIMEPLAYLIST_NEWENUM                             (DISPID_NEWENUM)
#define DISPID_TIMEPLAYLIST_NEXTTRACK                           (DISPID_TIMEPLAYLIST_BASE + 0x03)
#define DISPID_TIMEPLAYLIST_PREVTRACK                           (DISPID_TIMEPLAYLIST_BASE + 0x04)

//ITIMEPlayItem interface
#define DISPID_TIMEPLAYITEM_ABSTRACT                            (DISPID_TIMEPLAYITEM_BASE + 0x01)
#define DISPID_TIMEPLAYITEM_AUTHOR                              (DISPID_TIMEPLAYITEM_BASE + 0x02)
#define DISPID_TIMEPLAYITEM_COPYRIGHT                           (DISPID_TIMEPLAYITEM_BASE + 0x03)
#define DISPID_TIMEPLAYITEM_DUR                                 (DISPID_TIMEPLAYITEM_BASE + 0x04)
#define DISPID_TIMEPLAYITEM_INDEX                               (DISPID_TIMEPLAYITEM_BASE + 0x05)
#define DISPID_TIMEPLAYITEM_RATING                              (DISPID_TIMEPLAYITEM_BASE + 0x06)
#define DISPID_TIMEPLAYITEM_SRC                                 (DISPID_TIMEPLAYITEM_BASE + 0x07)
#define DISPID_TIMEPLAYITEM_TITLE                               (DISPID_TIMEPLAYITEM_BASE + 0x08)
        
//Methods
#define DISPID_TIMEPLAYITEM_SETACTIVE                           (DISPID_TIMEPLAYITEM_BASE + 0x0a)

//ITIMEPlayItem2 interface continues ITIMEPlayItem interface
#define DISPID_TIMEPLAYITEM_BANNER                              (DISPID_TIMEPLAYITEM_BASE + 0x10)
#define DISPID_TIMEPLAYITEM_BANNERABSTRACT                      (DISPID_TIMEPLAYITEM_BASE + 0x11)
#define DISPID_TIMEPLAYITEM_BANNERMOREINFO                      (DISPID_TIMEPLAYITEM_BASE + 0x12)

#define DISPID_ITIMEDVDPLAYEROBJECT_UPPERBUTTONSEL              (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x01)
#define DISPID_ITIMEDVDPLAYEROBJECT_LOWERBUTTONSEL              (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x02)
#define DISPID_ITIMEDVDPLAYEROBJECT_LEFTBUTTONSEL               (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x03)
#define DISPID_ITIMEDVDPLAYEROBJECT_RIGHTBUTTONSEL              (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x04)
#define DISPID_ITIMEDVDPLAYEROBJECT_BUTTONACTIVATE              (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x05)
#define DISPID_ITIMEDVDPLAYEROBJECT_GOTOMENU                    (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x06)

// =============================================
// ITIMEState
// =============================================

#define DISPID_TIMESTATE_ACTIVEDUR                              (DISPID_TIMESTATE_BASE + 0x01)
#define DISPID_TIMESTATE_ACTIVETIME                             (DISPID_TIMESTATE_BASE + 0x02)
#define DISPID_TIMESTATE_ISACTIVE                               (DISPID_TIMESTATE_BASE + 0x03)
#define DISPID_TIMESTATE_ISON                                   (DISPID_TIMESTATE_BASE + 0x04)
#define DISPID_TIMESTATE_ISPAUSED                               (DISPID_TIMESTATE_BASE + 0x05)
#define DISPID_TIMESTATE_ISMUTED                                (DISPID_TIMESTATE_BASE + 0x06)
#define DISPID_TIMESTATE_PARENTTIMEBEGIN                        (DISPID_TIMESTATE_BASE + 0x07)
#define DISPID_TIMESTATE_PARENTTIMEEND                          (DISPID_TIMESTATE_BASE + 0x08)
#define DISPID_TIMESTATE_PROGRESS                               (DISPID_TIMESTATE_BASE + 0x09)
#define DISPID_TIMESTATE_REPEATCOUNT                            (DISPID_TIMESTATE_BASE + 0x0a)
#define DISPID_TIMESTATE_SEGMENTDUR                             (DISPID_TIMESTATE_BASE + 0x0b)
#define DISPID_TIMESTATE_SEGMENTTIME                            (DISPID_TIMESTATE_BASE + 0x0c)
#define DISPID_TIMESTATE_SIMPLEDUR                              (DISPID_TIMESTATE_BASE + 0x0d)
#define DISPID_TIMESTATE_SIMPLETIME                             (DISPID_TIMESTATE_BASE + 0x0e)
#define DISPID_TIMESTATE_SPEED                                  (DISPID_TIMESTATE_BASE + 0x0f)
#define DISPID_TIMESTATE_STATE                                  (DISPID_TIMESTATE_BASE + 0x10)
#define DISPID_TIMESTATE_STATESTRING                            (DISPID_TIMESTATE_BASE + 0x11)
#define DISPID_TIMESTATE_VOLUME                                 (DISPID_TIMESTATE_BASE + 0x12)

#define DISPID_ITIMEDMPLAYEROBJECT_HASDM                        (DISPID_TIMEDMPLAYEROBJECT_BASE +0x01)

// =============================================
// Transitions related stuff
// =============================================

#define DISPID_TIMEMEDIAELEMENT2_EARLIESTTIME                   (DISPID_TIMEMEDIAELEMENT2_BASE + 0x03)
#define DISPID_TIMEMEDIAELEMENT2_LATESTTTIME                    (DISPID_TIMEMEDIAELEMENT2_BASE + 0x04)
#define DISPID_TIMEMEDIAELEMENT2_MINBUFF                        (DISPID_TIMEMEDIAELEMENT2_BASE + 0x05)
#define DISPID_TIMEMEDIAELEMENT2_DLTOTAL                        (DISPID_TIMEMEDIAELEMENT2_BASE + 0x06)
#define DISPID_TIMEMEDIAELEMENT2_DLCURRENT                      (DISPID_TIMEMEDIAELEMENT2_BASE + 0x07)
#define DISPID_TIMEMEDIAELEMENT2_ISSTREAMED                     (DISPID_TIMEMEDIAELEMENT2_BASE + 0x08)
#define DISPID_TIMEMEDIAELEMENT2_BUFPROG                        (DISPID_TIMEMEDIAELEMENT2_BASE + 0x09)
#define DISPID_TIMEMEDIAELEMENT2_HASDLPROGRESS                  (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0a)
#define DISPID_TIMEMEDIAELEMENT2_MIMETYPE                       (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0b)
#define DISPID_TIMEMEDIAELEMENT2_SEEKTOFRAME                    (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0c)
#define DISPID_TIMEMEDIAELEMENT2_DECODEMIMETYPE                 (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0d)
#define DISPID_TIMEMEDIAELEMENT_CURRFRAME                       (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0e)
#define DISPID_TIMEMEDIAELEMENT2_DLPROG                         (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0f)

#define DISPID_TIMETRANSITIONELEMENT_TYPE                       (DISPID_TIMETRANSITIONELEMENT_BASE + 0x01)
#define DISPID_TIMETRANSITIONELEMENT_SUBTYPE                    (DISPID_TIMETRANSITIONELEMENT_BASE + 0x02)
#define DISPID_TIMETRANSITIONELEMENT_DUR                        (DISPID_TIMETRANSITIONELEMENT_BASE + 0x03)
#define DISPID_TIMETRANSITIONELEMENT_STARTPROGRESS              (DISPID_TIMETRANSITIONELEMENT_BASE + 0x04)
#define DISPID_TIMETRANSITIONELEMENT_ENDPROGRESS                (DISPID_TIMETRANSITIONELEMENT_BASE + 0x05)
#define DISPID_TIMETRANSITIONELEMENT_DIRECTION                  (DISPID_TIMETRANSITIONELEMENT_BASE + 0x06)
#define DISPID_TIMETRANSITIONELEMENT_REPEATCOUNT                (DISPID_TIMETRANSITIONELEMENT_BASE + 0x07)
#define DISPID_TIMETRANSITIONELEMENT_BEGIN                      (DISPID_TIMETRANSITIONELEMENT_BASE + 0x08)
#define DISPID_TIMETRANSITIONELEMENT_END                        (DISPID_TIMETRANSITIONELEMENT_BASE + 0x09)

#endif  //__TIMEDISPID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\msxmldid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1999               **
//*********************************************************************

#ifndef __MSXMLDID_H__
#define __MSXMLDID_H__

#define DISPID_XOBJ_MIN                 0x00010000
#define DISPID_XOBJ_MAX                 0x0001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN


#define DISPID_XMLELEMENTCOLLECTION             DISPID_XOBJ_BASE

#define DISPID_XMLELEMENTCOLLECTION_LENGTH     DISPID_XMLELEMENTCOLLECTION + 1
#define DISPID_XMLELEMENTCOLLECTION_NEWENUM     DISPID_NEWENUM
#define DISPID_XMLELEMENTCOLLECTION_ITEM        DISPID_XMLELEMENTCOLLECTION + 3


#define DISPID_XMLDOCUMENT                      DISPID_XMLELEMENTCOLLECTION + 100

#define DISPID_XMLDOCUMENT_ROOT                 DISPID_XMLDOCUMENT + 1
#define DISPID_XMLDOCUMENT_FILESIZE             DISPID_XMLDOCUMENT + 2
#define DISPID_XMLDOCUMENT_FILEMODIFIEDDATE     DISPID_XMLDOCUMENT + 3
#define DISPID_XMLDOCUMENT_FILEUPDATEDDATE      DISPID_XMLDOCUMENT + 4
#define DISPID_XMLDOCUMENT_URL                  DISPID_XMLDOCUMENT + 5
#define DISPID_XMLDOCUMENT_MIMETYPE             DISPID_XMLDOCUMENT + 6
#define DISPID_XMLDOCUMENT_READYSTATE           DISPID_XMLDOCUMENT + 7
#define DISPID_XMLDOCUMENT_CREATEELEMENT        DISPID_XMLDOCUMENT + 8
#define DISPID_XMLDOCUMENT_CHARSET              DISPID_XMLDOCUMENT + 9
#define DISPID_XMLDOCUMENT_VERSION              DISPID_XMLDOCUMENT + 10
#define DISPID_XMLDOCUMENT_DOCTYPE              DISPID_XMLDOCUMENT + 11
#define DISPID_XMLDOCUMENT_DTDURL               DISPID_XMLDOCUMENT + 12
#define DISPID_XMLDOCUMENT_ASYNC                DISPID_XMLDOCUMENT + 13
#define DISPID_XMLDOCUMENT_CASEINSENSITIVE      DISPID_XMLDOCUMENT + 14

#define DISPID_XMLELEMENT                       DISPID_XMLDOCUMENT + 100

#define DISPID_XMLELEMENT_TAGNAME               DISPID_XMLELEMENT + 1
#define DISPID_XMLELEMENT_PARENT                DISPID_XMLELEMENT + 2
#define DISPID_XMLELEMENT_SETATTRIBUTE          DISPID_XMLELEMENT + 3
#define DISPID_XMLELEMENT_GETATTRIBUTE          DISPID_XMLELEMENT + 4
#define DISPID_XMLELEMENT_REMOVEATTRIBUTE       DISPID_XMLELEMENT + 5
#define DISPID_XMLELEMENT_CHILDREN              DISPID_XMLELEMENT + 6
#define DISPID_XMLELEMENT_TYPE                  DISPID_XMLELEMENT + 7
#define DISPID_XMLELEMENT_TEXT                  DISPID_XMLELEMENT + 8
#define DISPID_XMLELEMENT_ADDCHILD              DISPID_XMLELEMENT + 9
#define DISPID_XMLELEMENT_REMOVECHILD           DISPID_XMLELEMENT + 10
#define DISPID_XMLELEMENT_ATTRIBUTES            DISPID_XMLELEMENT + 11

#define DISPID_XMLNOTIFSINK                     DISPID_XMLELEMENT + 100

#define DISPID_XMLNOTIFSINK_CHILDADDED          DISPID_XMLNOTIFSINK + 1

#define DISPID_XMLATTRIBUTE                     DISPID_XMLNOTIFSINK + 100

#define DISPID_XMLATTRIBUTE_NAME                DISPID_XMLATTRIBUTE + 1
#define DISPID_XMLATTRIBUTE_VALUE               DISPID_XMLATTRIBUTE + 2


#endif // __MSXMLDID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\msoav.h ===
#pragma once

#ifndef _MSOAV_H
#define _MSOAV_H

typedef struct _msoavinfo
{
int cbsize;			//size of this struct
struct {
	ULONG fPath:1;			//when true use pwzFullPath else use lpstg
	ULONG fReadOnlyRequest:1;	//user requests file to be opened read/only
	ULONG fInstalled:1;	//the file at pwzFullPath is an installed file
	ULONG fHttpDownload:1;	//the file at pwzFullPath is a temp file downloaded from http/ftp
	};
HWND hwnd;			//parent window of the Office9 app
union {
	WCHAR *pwzFullPath;	//full path to the file about to be opened
	LPSTORAGE lpstg;	//OLE Storage of the doc about to be opened
	}u;
WCHAR *pwzHostName;	 // Host Office 9 apps name
WCHAR *pwzOrigURL;	 		// URL of the origin of this downloaded file.
}MSOAVINFO;

 // {56FFCC30-D398-11d0-B2AE-00A0C908FA49}
DEFINE_GUID(IID_IOfficeAntiVirus,
0x56ffcc30, 0xd398, 0x11d0, 0xb2, 0xae, 0x0, 0xa0, 0xc9, 0x8, 0xfa, 0x49);

 // {56FFCC31-D398-11d0-B2AE-00A0C908FA49}
DEFINE_GUID(CATID_MSOfficeAntiVirus,
0x56ffcc30, 0xd398, 0x11d0, 0xb2, 0xae, 0x0, 0xa0, 0xc9, 0x8, 0xfa, 0x49);



#undef  INTERFACE
#define INTERFACE  IOfficeAntiVirus
DECLARE_INTERFACE_(IOfficeAntiVirus, IUnknown)
{
    BEGIN_INTERFACE

    // *** IUnknown methods ***

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    STDMETHOD_(ULONG, AddRef)(THIS) PURE;

    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IOfficeAntiVirus methods ***

	STDMETHOD_(HRESULT, Scan)(THIS_ MSOAVINFO *pmsoavinfo ) PURE;
};

#ifndef AVVENDOR
MSOAPI_(BOOL) MsoFAnyAntiVirus(HMSOINST hmsoinst);
MSOAPI_(BOOL) MsoFDoAntiVirusScan(HMSOINST hmsoinst, MSOAVINFO *msoavinfo);
MSOAPI_(void) MsoFreeMsoavStuff(HMSOINST hmsoinst);
MSOAPI_(BOOL) MsoFDoSecurityLevelDlg(HMSOINST hmsoinst,DWORD msorid, int *pSecurityLevel, 
	BOOL *pfTrustInstalled, HWND hwndParent, BOOL fShowVirusCheckers,
	WCHAR *wzHelpFile, DWORD dwHelpId);

//output of the Enable/disable macro (edm) dialog
#define msoedmEnable	1
#define	msoedmDisable	2
#define	msoedmDontOpen	3

MSOAPI_(int) MsoMsoedmDialog(HMSOINST hmsoinst, BOOL fAppIsActive, BOOL fHasVBMacros, 
	BOOL fHasXLMMacros, void *pvDigSigStore, void *pvMacro, int nAppID, HWND hwnd, 
	const WCHAR *pwtzPath, int iClient, int iSecurityLevel, int *pmsodsv, 
	WCHAR *wzHelpFile, DWORD dwHelpId, HANDLE hFileDLL, BOOL fUserControl);


//Security level
#define	msoslUndefined	0
#define msoslNone   1
#define	msoslMedium	2
#define msoslHigh	3

MSOAPI_(int) MsoMsoslGetSL(HMSOINST hmsoinst);
MSOAPI_(int) MsoMsoslSetSL(DWORD msorid, HMSOINST hmsoinst);

//output of the digital signature verification (dsv)
#define	msodsvNoMacros	0
#define msodsvUnsigned	1
// msodsvPassedTrusted is very unfortunately named because it has nothing to do with
// trust - it just means that the doc is signed and the signature matched. Too late 
// to change the name now so I'm adding a msodsvPassedTrustedCert to mean the doc was
// signed and cert was trusted.
#define	msodsvPassedTrusted	2
#define	msodsvFailed		3
#define	msodsvLowSecurityLevel 4
#define msodsvPassedTrustedCert 5

#endif //!AVVENDOR


#endif // _MSOAV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\perftags.h ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       perftags.h
//
//  Contents:   External include file for perftags.dll
//
//-------------------------------------------------------------------------

#ifdef PERFTAGS

typedef int  PERFTAG;
int          PerfRegister(char * szTag, char * szOwner, char * szDescrip);
void __cdecl PerfLogFn(int tag, void * pvObj, const char * pchFmt, ...);
void         PerfDump();
void         PerfClear();
void         PerfTags();
#define      IsPerfEnabled(tag) (*(BOOL *)tag)
#define      PerfTag(tag, szOwner, szDescrip) PERFTAG tag(PerfRegister(#tag, szOwner, szDescrip));
#define      PerfExtern(tag) extern PERFTAG tag;
#define      PerfLog(tag,pv,f) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f) : 0
#define      PerfLog1(tag,pv,f,a1) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1) : 0
#define      PerfLog2(tag,pv,f,a1,a2) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2) : 0
#define      PerfLog3(tag,pv,f,a1,a2,a3) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3) : 0
#define      PerfLog4(tag,pv,f,a1,a2,a3,a4) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4) : 0
#define      PerfLog5(tag,pv,f,a1,a2,a3,a4,a5) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5) : 0
#define      PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6) : 0
#define      PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) : 0
#define      PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) : 0
#define      PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) : 0

#else

#define      PerfTags()
#define      PerfTag(tag, szOwner, szDescrip)
#define      PerfExtern(tag)
#define      PerfDump()
#define      PerfClear()
#define      IsPerfEnabled(tag) FALSE
#define      PerfLog(tag,pv,f)
#define      PerfLog1(tag,pv,f,a1)
#define      PerfLog2(tag,pv,f,a1,a2)
#define      PerfLog3(tag,pv,f,a1,a2,a3)
#define      PerfLog4(tag,pv,f,a1,a2,a3,a4)
#define      PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
#define      PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
#define      PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
#define      PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
#define      PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\pkgguid.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    pkgguid.h

--*/

#ifndef __PKGGUID_H__
#define __PKGGUID_H__

// {D2073C40-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_ICodeStoreDBEntry,
0xD2073C40, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {DF3D9C22-AB4E-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_ICodeStoreDB,
0xDF3D9C22, 0xAB4E, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {DF3D9C23-AB4E-11d0-A732-00A0C9082637}
DEFINE_GUID(CLSID_CodeStoreDB,
0xDF3D9C23, 0xAB4E, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C42-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IEnumCodeStoreDBEntry,
0xD2073C42, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C43-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IJavaPackageManager,
0xD2073C43, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C46-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IJavaPackage,
0xD2073C46, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C48-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IJavaFile,
0xD2073C48, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C47-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_ICreateJavaPackageMgr,
0xD2073C47, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C44-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(CLSID_JavaPackageManager,
0xD2073C44, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C45-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IEnumJavaPackage,
0xD2073C45, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C49-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IEnumJavaFile,
0xD2073C49, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

#endif // __PKGGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\newimp.h ===
#ifndef _INC_NEWIMP_H
#define _INC_NEWIMP_H


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// WARNING:  If you make changes to this header, you must also update  //
//           inetcore\published\inc\newimp.h !!!                       //
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


#ifndef NO_IMPORT_ERROR

#define HR_IMP_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, n)
#define HR_IMP_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, n)
#define HR_IMP      0x3000

#define hrFolderOpenFail    HR_IMP_E(HR_IMP + 1)
#define hrFolderReadFail    HR_IMP_E(HR_IMP + 2)
#define hrMapiInitFail      HR_IMP_E(HR_IMP + 3)
#define hrNoProfilesFound   HR_IMP_E(HR_IMP + 4)
#define hrDiskFull          HR_IMP_E(HR_IMP + 5)
#define hrUserCancel        HR_IMP_E(HR_IMP + 6)

#endif // NO_IMPORT_ERROR

typedef enum tagIMPORTFOLDERTYPE
    {
    FOLDER_TYPE_NORMAL = 0,
    FOLDER_TYPE_INBOX,
    FOLDER_TYPE_OUTBOX,
    FOLDER_TYPE_SENT,
    FOLDER_TYPE_DELETED,
    FOLDER_TYPE_DRAFT,
    CFOLDERTYPE
    } IMPORTFOLDERTYPE;

typedef struct IMSG IMSG;

typedef enum
    {
    MSG_TYPE_MAIL = 0,
    MSG_TYPE_NEWS
    } MSGTYPE;

#define MSG_STATE_UNREAD    0x0001
#define MSG_STATE_UNSENT    0x0002
#define MSG_STATE_SUBMITTED 0x0004
#define MSG_PRI_LOW         0x0010
#define MSG_PRI_NORMAL      0x0020
#define MSG_PRI_HIGH        0x0040
#define MSG_PRI_MASK        0x0070

// {E4499DE7-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IFolderImport, 0xE4499DE7L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IFolderImport IFolderImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IFolderImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMessageCount(ULONG cMsg) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(IMSG *pimsg) = 0;
    };
#else   /* C style interface */
typedef struct IFolderImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IFolderImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IFolderImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IFolderImport * This);

    HRESULT ( STDMETHODCALLTYPE *SetMessageCount )(
		IFolderImport * This,
		ULONG cMsg);
    HRESULT ( STDMETHODCALLTYPE *ImportMessageEx )(
		IFolderImport * This,
		MSGTYPE type, 
		DWORD dwState, 
		LPSTREAM pstm, 
		const TCHAR **rgszAttach, 
		DWORD cAttach);
    HRESULT ( STDMETHODCALLTYPE *ImportMessage )(
		IFolderImport * This,
		IMSG *pimsg);
    END_INTERFACE
} IFolderImportVtbl;

interface IFolderImport
{
    CONST_VTBL struct IFolderImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IFolderImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IFolderImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IFolderImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IFolderImport_SetMessageCount(This,cMsg)	\
	(This)->lpVtbl -> SetMessageCount(This,cMsg)
#define IFolderImport_ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)	\
	(This)->lpVtbl -> ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)
#define IFolderImport_ImportMessage(This,pimsg)	\
	(This)->lpVtbl -> ImportMessage(This,pimsg)
#endif /* COBJMACROS */

#endif  /* C style interface */



// {E4499DE8-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImporter, 0xE4499DE8L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IMailImporter IMailImporter;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImporter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenFolder(DWORD_PTR dwCookie, const TCHAR *szFolder, IMPORTFOLDERTYPE type, DWORD dwFlags, IFolderImport **ppFldrImp, DWORD_PTR *pdwCookie) = 0;
    };
#else   /* C style interface */
typedef struct IMailImporterVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImporter * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImporter * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImporter * This);

    HRESULT ( STDMETHODCALLTYPE *OpenFolder )(
		IMailImporter * This,
		DWORD_PTR dwCookie, 
		const TCHAR *szFolder, 
		IMPORTFOLDERTYPE type, 
		DWORD dwFlags, 
		IFolderImport **ppFldrImp, 
		DWORD_PTR *pdwCookie);
    END_INTERFACE
} IMailImporterVtbl;

interface IMailImporter
{
    CONST_VTBL struct IMailImporterVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImporter_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImporter_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImporter_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImporter_OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)	\
   (This)->lpVtbl -> OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)

#endif /* COBJMACROS */

#endif  /* C style interface */

typedef struct tagIMPORTFOLDER
    {
    DWORD_PTR           dwCookie;
    TCHAR               szName[MAX_PATH];
    IMPORTFOLDERTYPE    type;
    // DWORD       cMsg;
    BOOL                fSubFolders;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    } IMPORTFOLDER;

// {E4499DE9-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IEnumFOLDERS, 0xE4499DE9L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IEnumFOLDERS IEnumFOLDERS;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IEnumFOLDERS : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(IMPORTFOLDER *pfldr) = 0;
        virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
    };
#else   /* C style interface */
typedef struct IEnumFOLDERSVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IEnumFOLDERS * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IEnumFOLDERS * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IEnumFOLDERS * This);

    HRESULT ( STDMETHODCALLTYPE *Next )(
		IEnumFOLDERS * This,
        IMPORTFOLDER *pfldr);
    HRESULT ( STDMETHODCALLTYPE *Reset )(
		IEnumFOLDERS * This);
    END_INTERFACE
} IEnumFOLDERSVtbl;

interface IEnumFOLDERS
{
    CONST_VTBL struct IEnumFOLDERSVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IEnumFOLDERS_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IEnumFOLDERS_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IEnumFOLDERS_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IEnumFOLDERS_Next(This,pfldr)	\
   (This)->lpVtbl -> Next(This,pfldr);
#define IEnumFOLDERS_Reset(This)	\
   (This)->lpVtbl -> Reset(This);
#endif /* COBJMACROS */

#endif  /* C style interface */


#define COOKIE_ROOT     MAXULONG_PTR

// {E4499DEA-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImport, 0xE4499DEAL, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IMailImport IMailImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetDirectory(char *szDir, UINT cch) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetDirectory(char *szDir) = 0;
        virtual HRESULT STDMETHODCALLTYPE EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport) = 0;
    };
#else   /* C style interface */
typedef struct IMailImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImport * This);

    HRESULT ( STDMETHODCALLTYPE *InitializeImport )(
		IMailImport * This,
        HWND hwnd);
    HRESULT ( STDMETHODCALLTYPE *GetDirectory )(
		IMailImport * This,
        char *szDir, 
        UINT cch);
    HRESULT ( STDMETHODCALLTYPE *SetDirectory )(
		IMailImport * This,
        char *szDir);
    HRESULT ( STDMETHODCALLTYPE *EnumerateFolders )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IEnumFOLDERS **ppEnum);
    HRESULT ( STDMETHODCALLTYPE *ImportFolder )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IFolderImport *pImport);

    END_INTERFACE
} IMailImportVtbl;

interface IMailImport
{
    CONST_VTBL struct IMailImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImport_InitializeImport(This,hwnd) \
    (This)->lpVtbl -> InitializeImport(This,hwnd)
#define IMailImport_GetDirectory(This,szDir,cch)    \
    (This)->lpVtbl -> GetDirectory(This,szDir,cch)
#define IMailImport_SetDirectory(This,szDir)    \
    (This)->lpVtbl -> SetDirectory(This,szDir)
#define IMailImport_EnumerateFolders(This,dwCookie,ppEnum)  \
    (This)->lpVtbl -> EnumerateFolders(This,dwCookie,ppEnum)
#define IMailImport_ImportFolder(This,dwCookie,pImport) \
    (This)->lpVtbl -> ImportFolder(This,dwCookie,pImport)

#endif /* COBJMACROS */

#endif  /* C style interface */

#define achPerformImport    "PerformImport"
void PerformImport(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef void (*PFNPERFORMIMPORT)(HWND, IMailImporter *, DWORD);

#define achPerformMigration "PerformMigration"
HRESULT PerformMigration(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef HRESULT (*PFNPERFORMMIGRATION)(HWND, IMailImporter *, DWORD);

#endif // _INC_NEWIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\platform.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//  File:       platform.h
//
//  Contents:   Macros for portable access to platform dependent values.
//
//
// This file contains macros for easy cross platform developing.
// There are macros for compiler differences and platform/layer differences.
//
//----------------------------------------------------------------------------


#ifndef __PLATFORM_H_
#define __PLATFORM_H_

#ifdef __cplusplus
   // +++ Unaligned memory access templates/macros
#  include <unaligned.hpp>
#endif

////////////////////////////////////////////////////////////////////
//
// Global defines (should be moved to NT public headers)
//

#define VER_PLATFORM_WIN32_UNIX 9

////////////////////////////////////////////////////////////////////
//
// Compiler differences
//

#if !defined(_MSC_VER) && !defined(__APOGEE__)
    // For compilers lacking VC++ extensions

#   define __cdecl
#   define INLINEOP      /* Inline operators not available IEUNIX */

#   ifdef UNIX
        // Unix specific compiler problems
#       define UNSIZED_ARRAY 1
#   else
#       define UNSIZED_ARRAY
#   endif // UNIX

#else // !_MSC_VER

    // VC++ compilers

#   define INLINEOP inline
#   define UNSIZED_ARRAY

#endif

#define EMPTY_SIZE UNSIZED_ARRAY

////////////////////////////////////////////////////////////////////
//
// Platform / Layer dependent sections.
//
// NOTE! #ifdefing based on WIN32 is invalid as some layers define
//       WIN32 for compatability.
//

#define ENDEXCEPT  __endexcept
#define ENDFINALLY __endfinally

#if !defined( UNIX )
#define __endexcept
#define __endfinally
#endif // UNIX

// +++ File Separators

#if defined( UNIX )
// UNIX

#  ifndef FILENAME_SEPARATOR
#  define FILENAME_SEPARATOR       '/'
#  endif

#  ifndef FILENAME_SEPARATOR_W
#  define FILENAME_SEPARATOR_W     L'/'
#  endif

#  ifndef FILENAME_SEPARATOR_STR
#  define FILENAME_SEPARATOR_STR   "/"
#  endif

#  ifndef FILENAME_SEPARATOR_STR_W
#  define FILENAME_SEPARATOR_STR_W L"/"
#  endif

#  ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR           ':'
#  endif

#  ifndef PATH_SEPARATOR_W
#  define PATH_SEPARATOR_W         L':'
#  endif

#  ifndef PATH_SEPARATOR_STR
#  define PATH_SEPARATOR_STR       ":"
#  endif

#  ifndef PATH_SEPARATOR_STR_W
#  define PATH_SEPARATOR_STR_W     L":"
#  endif

#  ifndef LINE_SEPARATOR_STR
#  define LINE_SEPARATOR_STR       "\n"
#  endif

#  ifndef LINE_SEPARATOR_STR_W
#  define LINE_SEPARATOR_STR_W     L"\n"
#  endif

#else // UNIX

// Windows / MAC

#  ifndef FILENAME_SEPARATOR
#  define FILENAME_SEPARATOR       '\\'
#  endif

#  ifndef FILENAME_SEPARATOR_W
#  define FILENAME_SEPARATOR_W     L'\\'
#  endif

#  ifndef FILENAME_SEPARATOR_STR
#  define FILENAME_SEPARATOR_STR   "\\"
#  endif

#  ifndef FILENAME_SEPARATOR_STR_W
#  define FILENAME_SEPARATOR_STR_W L"\\"
#  endif

#  ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR           ';'
#  endif

#  ifndef PATH_SEPARATOR_W
#  define PATH_SEPARATOR_W         L';'
#  endif

#  ifndef PATH_SEPARATOR_STR
#  define PATH_SEPARATOR_STR       ";"
#  endif

#  ifndef PATH_SEPARATOR_STR_W
#  define PATH_SEPARATOR_STR_W     L";"
#  endif

#  ifndef LINE_SEPARATOR_STR
#  define LINE_SEPARATOR_STR       "\r\n"
#  endif

#  ifndef LINE_SEPARATOR_STR_W
#  define LINE_SEPARATOR_STR_W     L"\r\n"
#  endif

#endif // Windows / MAC



#ifdef UNIX


#  define PLATFORM_ACCEL_KEY ALT
#  define PLATFORM_ACCEL_STR "Alt"  // --  Look in rc.sed files
#  define FACCELKEY FALT

#define VK_OEM_SLASH 0xBF

#else   /* UNIX  */

#define INTERFACE_PROLOGUE(a)
#define INTERFACE_EPILOGUE(a)
#define INTERFACE_PROLOGUE_(a,b)
#define INTERFACE_EPILOGUE_(a,b)


#  define PLATFORM_ACCEL_KEY CONTROL
#  define PLATFORM_ACCEL_STR "Ctrl"  // --  Look in rc.sed files
#  define FACCELKEY FCONTROL

#define VK_OEM_SLASH '/'

#endif  /* UNIX */

#define MAKELONGLONG(low,high) ((LONGLONG)(((DWORD)(low)) | ((LONGLONG)((DWORD)(high))) << 32))

#ifdef BIG_ENDIAN
#define MAKE_LI(low,high) { high, low }
#define PALETTE_ENTRY( r, g, b, f )  { f, b, g, r }
#else
#define MAKE_LI(low,high) { low, high }
#define PALETTE_ENTRY( r, g, b, f )  { r, g, b, f }
#endif

#endif // __PLATFORM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1998               **
//*********************************************************************

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>
#include <shlwapi.h>

STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable);
STDAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                             LPCSTR pszRatingInfo, LPBYTE pData,
                             DWORD cbData, void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2(HWND hDlg, LPCSTR pszUsername, void *pRatingDetails);
STDAPI RatingFreeDetails(void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, void *lpvRatingDetails), HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif


STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();

//;BUGBUG Quick & dirty way to check if ratings are installed. We still need to calling
//;BUGBUG ratings dll to find out for sure but this allows us to delay load ratings.
_inline BOOL IS_RATINGS_ENABLED()
{
    TCHAR szSup[200];
    DWORD dwType;
    DWORD cbSize = sizeof(szSup);

    return (SHGetValue(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"),
                       TEXT("Key"),
                       &dwType, &szSup, &cbSize) == ERROR_SUCCESS);
}

#define S_RATING_ALLOW        S_OK
#define S_RATING_DENY         S_FALSE
#define S_RATING_FOUND        0x00000002
#define E_RATING_NOT_FOUND    0x80000001

/************************************************************************

IObtainRating interface

This interface is used to obtain the rating (PICS label) for a URL.
It is entirely up to the server to determine how to come up with the
label.  The ObtainRating call may be synchronous.

GetSortOrder returns a ULONG which is used to sort this rating helper
into the list of installed helpers.  The helpers are sorted in ascending
order, so a lower numbered helper will be called before a higher numbered
one.

************************************************************************/

DECLARE_INTERFACE_(IObtainRating, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(ObtainRating) (THIS_ LPCSTR pszTargetUrl, HANDLE hAbortEvent,
                             IMalloc *pAllocator, LPSTR *ppRatingOut) PURE;

    STDMETHOD_(ULONG,GetSortOrder) (THIS) PURE;
};

#define RATING_ORDER_REMOTESITE        0x80000000
#define RATING_ORDER_LOCALLIST        0xC0000000

#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\rowpos.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 17:20:43 1997
 */
/* Compiler settings for msdadc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rowpos_h__
#define __rowpos_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRowPosition_FWD_DEFINED__
#define __IRowPosition_FWD_DEFINED__
typedef interface IRowPosition IRowPosition;
#endif 	/* __IRowPosition_FWD_DEFINED__ */


#ifndef __IRowPositionChange_FWD_DEFINED__
#define __IRowPositionChange_FWD_DEFINED__
typedef interface IRowPositionChange IRowPositionChange;
#endif 	/* __IRowPositionChange_FWD_DEFINED__ */


#ifndef __RowPosition_FWD_DEFINED__
#define __RowPosition_FWD_DEFINED__

#ifdef __cplusplus
typedef class RowPosition RowPosition;
#else
typedef struct RowPosition RowPosition;
#endif /* __cplusplus */

#endif 	/* __RowPosition_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __IRowPosition_INTERFACE_DEFINED__
#define __IRowPosition_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPosition
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 


typedef DWORD DBPOSITIONFLAGS;


enum DBPOSITIONFLAGSENUM
    {	DBPOSITION_OK	= 0,
	DBPOSITION_NOROW	= DBPOSITION_OK + 1,
	DBPOSITION_BOF	= DBPOSITION_NOROW + 1,
	DBPOSITION_EOF	= DBPOSITION_BOF + 1
    };

EXTERN_C const IID IID_IRowPosition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a94-2a1c-11ce-ade5-00aa0044773d")
    IRowPosition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ClearRowPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowPosition( 
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowset( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown __RPC_FAR *pRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRowPosition( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPosition __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearRowPosition )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowset )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags);
        
        END_INTERFACE
    } IRowPositionVtbl;

    interface IRowPosition
    {
        CONST_VTBL struct IRowPositionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPosition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPosition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPosition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPosition_ClearRowPosition(This)	\
    (This)->lpVtbl -> ClearRowPosition(This)

#define IRowPosition_GetRowPosition(This,phChapter,phRow,pdwPositionFlags)	\
    (This)->lpVtbl -> GetRowPosition(This,phChapter,phRow,pdwPositionFlags)

#define IRowPosition_GetRowset(This,riid,ppRowset)	\
    (This)->lpVtbl -> GetRowset(This,riid,ppRowset)

#define IRowPosition_Initialize(This,pRowset)	\
    (This)->lpVtbl -> Initialize(This,pRowset)

#define IRowPosition_SetRowPosition(This,hChapter,hRow,dwPositionFlags)	\
    (This)->lpVtbl -> SetRowPosition(This,hChapter,hRow,dwPositionFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPosition_ClearRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This);


void __RPC_STUB IRowPosition_ClearRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [out] */ HCHAPTER __RPC_FAR *phChapter,
    /* [out] */ HROW __RPC_FAR *phRow,
    /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);


void __RPC_STUB IRowPosition_GetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowset_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);


void __RPC_STUB IRowPosition_GetRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_Initialize_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pRowset);


void __RPC_STUB IRowPosition_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_SetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow,
    /* [in] */ DBPOSITIONFLAGS dwPositionFlags);


void __RPC_STUB IRowPosition_SetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPosition_INTERFACE_DEFINED__ */


#ifndef __IRowPositionChange_INTERFACE_DEFINED__
#define __IRowPositionChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPositionChange
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



enum DBREASONPOSITIONENUM
    {	DBREASON_ROWPOSITION_CHANGED	= DBREASON_ROWSET_CHANGED + 1,
	DBREASON_ROWPOSITION_CHAPTERCHANGED	= DBREASON_ROWPOSITION_CHANGED + 1,
	DBREASON_ROWPOSITION_CLEARED	= DBREASON_ROWPOSITION_CHAPTERCHANGED + 1
    };

EXTERN_C const IID IID_IRowPositionChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0997a571-126e-11d0-9f8a-00a0c9a0631e")
    IRowPositionChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnRowPositionChange( 
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPositionChange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPositionChange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnRowPositionChange )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny);
        
        END_INTERFACE
    } IRowPositionChangeVtbl;

    interface IRowPositionChange
    {
        CONST_VTBL struct IRowPositionChangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPositionChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPositionChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPositionChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPositionChange_OnRowPositionChange(This,eReason,ePhase,fCantDeny)	\
    (This)->lpVtbl -> OnRowPositionChange(This,eReason,ePhase,fCantDeny)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPositionChange_OnRowPositionChange_Proxy( 
    IRowPositionChange __RPC_FAR * This,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny);


void __RPC_STUB IRowPositionChange_OnRowPositionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPositionChange_INTERFACE_DEFINED__ */



#ifndef __MSDAUTILLib_LIBRARY_DEFINED__
#define __MSDAUTILLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSDAUTILLib
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RowPosition;

class DECLSPEC_UUID("2048EEE6-7FA2-11D0-9E6A-00A0C9138C29")
RowPosition;

DEFINE_GUID(CLSID_RowPosition, 0x2048eee6, 0x7fa2, 0x11d0, 0x9e, 0x6a, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x29);
DEFINE_GUID(IID_IRowPosition,  0x0c733a94, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x0, 0xaa, 0x0, 0x44, 0x77, 0x3d);
DEFINE_GUID(IID_IRowPositionChange,  0x0997a571, 0x126e, 0x11d0, 0x9f, 0x8a, 0x0, 0xa0, 0xc9, 0xa0, 0x63, 0x1e);


#endif
#endif /* __MSDAUTILLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\wab.h ===
/*
 * WAB.H
 *
 * Top level public header for WAB API functions.
 *
 */

#include <wabdefs.h>
#include <wabcode.h>
#include <wabtags.h>
#include <wabutil.h>
#include <wabiab.h>
#include <wabapi.h>
#include <wabmem.h>
#include <wabnot.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\scrptids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1996-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: scrptids.h
//
//--------------------------------------------------------------------------

// Invent DISPIDs for the things that don't have built-in dispid's
#define DISPID_LOAD		1
#define DISPID_UNLOAD	2
#define DISPID_SUBMIT	3
#define DISPID_FOCUS	4
#define DISPID_CHANGE	5
#define DISPID_BLUR		6
#define DISPID_SELECT	7
#define DISPID_MOUSEOVER 8
#define DISPID_PARSECOMPLETE 9
#define DISPID_ABORT	10
#define DISPID_ERROR	11
#define DISPID_MOUSEOUT 12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\pkgmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Fri Jul 11 15:30:21 1997
 */
/* Compiler settings for pkgmgr.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __pkgmgr_h__
#define __pkgmgr_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumCodeStoreDBEntry_FWD_DEFINED__
#define __IEnumCodeStoreDBEntry_FWD_DEFINED__
typedef interface IEnumCodeStoreDBEntry IEnumCodeStoreDBEntry;
#endif 	/* __IEnumCodeStoreDBEntry_FWD_DEFINED__ */


#ifndef __ICodeStoreDBEntry_FWD_DEFINED__
#define __ICodeStoreDBEntry_FWD_DEFINED__
typedef interface ICodeStoreDBEntry ICodeStoreDBEntry;
#endif 	/* __ICodeStoreDBEntry_FWD_DEFINED__ */


#ifndef __ICodeStoreDB_FWD_DEFINED__
#define __ICodeStoreDB_FWD_DEFINED__
typedef interface ICodeStoreDB ICodeStoreDB;
#endif 	/* __ICodeStoreDB_FWD_DEFINED__ */


#ifndef __IJavaPackageManager_FWD_DEFINED__
#define __IJavaPackageManager_FWD_DEFINED__
typedef interface IJavaPackageManager IJavaPackageManager;
#endif 	/* __IJavaPackageManager_FWD_DEFINED__ */


#ifndef __IJavaPackage_FWD_DEFINED__
#define __IJavaPackage_FWD_DEFINED__
typedef interface IJavaPackage IJavaPackage;
#endif 	/* __IJavaPackage_FWD_DEFINED__ */


#ifndef __ICreateJavaPackageMgr_FWD_DEFINED__
#define __ICreateJavaPackageMgr_FWD_DEFINED__
typedef interface ICreateJavaPackageMgr ICreateJavaPackageMgr;
#endif 	/* __ICreateJavaPackageMgr_FWD_DEFINED__ */


#ifndef __IJavaFile_FWD_DEFINED__
#define __IJavaFile_FWD_DEFINED__
typedef interface IJavaFile IJavaFile;
#endif 	/* __IJavaFile_FWD_DEFINED__ */


#ifndef __IEnumJavaPackage_FWD_DEFINED__
#define __IEnumJavaPackage_FWD_DEFINED__
typedef interface IEnumJavaPackage IEnumJavaPackage;
#endif 	/* __IEnumJavaPackage_FWD_DEFINED__ */


#ifndef __IEnumJavaFile_FWD_DEFINED__
#define __IEnumJavaFile_FWD_DEFINED__
typedef interface IEnumJavaFile IEnumJavaFile;
#endif 	/* __IEnumJavaFile_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 







typedef const BYTE __RPC_FAR *LPCBYTE;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0000_0001
    {	JPMPII_SYSTEMCLASS	= 0,
	JPMPII_NONSYSTEMCLASS	= 1,
	JPMPII_NEEDSTRUSTEDSOURCE	= 2,
	ALL_JPMPII_FLAGS	= JPMPII_SYSTEMCLASS | JPMPII_NONSYSTEMCLASS | JPMPII_NEEDSTRUSTEDSOURCE
    }	JPMPII_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0000_0002
    {	JPMINST_NOVERSIONCHECK	= 1,
	JPMINST_NOSIGNERCHECK	= 2,
	JPMINST_AUTODETECTPACKAGES	= 4,
	JPMINST_DELETEINPUTFILE	= 8,
	ALL_JPMINST_FLAGS	= JPMINST_NOVERSIONCHECK | JPMINST_NOSIGNERCHECK | JPMINST_AUTODETECTPACKAGES | JPMINST_DELETEINPUTFILE
    }	JPMINST_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0000_0003
    {	JPMINST_CAB	= 0,
	JPMINST_ZIP	= 1,
	JPMINST_JAR	= 2
    }	JPMINST_FILETYPES;

typedef struct  tagPACKAGEINSTALLINFO
    {
    DWORD cbStruct;
    LPCOLESTR pszPackageName;
    DWORD dwVersionMS;
    DWORD dwVersionLS;
    DWORD dwFlags;
    LPCOLESTR pszCodebaseURL;
    LPCOLESTR pszDistributionUnit;
    LPUNKNOWN pUnknown;
    HRESULT result;
    }	PACKAGEINSTALLINFO;

typedef /* [unique] */ PACKAGEINSTALLINFO __RPC_FAR *LPPACKAGEINSTALLINFO;

typedef /* [unique] */ const PACKAGEINSTALLINFO __RPC_FAR *LPCPACKAGEINSTALLINFO;

typedef struct  tagPACKAGESECURITYINFO
    {
    DWORD cbStruct;
    LPCBYTE pCapabilities;
    DWORD cbCapabilities;
    LPCBYTE pSigner;
    DWORD cbSigner;
    BOOL fAllPermissions;
    }	PACKAGESECURITYINFO;

typedef /* [unique] */ const PACKAGESECURITYINFO __RPC_FAR *LPCPACKAGESECURITYINFO;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;


#ifndef __JPKGMGR_LIBRARY_DEFINED__
#define __JPKGMGR_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: JPKGMGR
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [public] */ 
enum __MIDL___MIDL__intf_0071_0001
    {	CRF_REMOVECHILDREN	= 1,
	CRF_REMOVEVALUESONLY	= 2,
	CRF_REMOVEEMPTYPARENTSALSO	= 4
    }	CSDB_REMOVE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0071_0002
    {	CGF_FULLYQUALIFIED	= 1
    }	CSDB_GETNAME_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0073_0001
    {	JPMFI_NEEDS_TRUSTED_SOURCE	= 0x1,
	JPMFI_IS_STREAM	= 0x2,
	JPMFI_IS_PE_NATIVE	= 0x8,
	JPMFI_FROM_PKG_DATABASE	= 0x10,
	JPMFI_FROM_CLASSPATH	= 0x20
    }	JPM_FILEINFO_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0073_0002
    {	JPMGFN_SIMPLE	= 1,
	JPMGFN_FULLYQUALIFIED	= 2,
	JPMGFN_LOCALFILEPATH	= 3
    }	JPM_GETFILENAME_TYPE;


EXTERN_C const IID LIBID_JPKGMGR;

#ifndef __IEnumCodeStoreDBEntry_INTERFACE_DEFINED__
#define __IEnumCodeStoreDBEntry_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCodeStoreDBEntry
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumCodeStoreDBEntry __RPC_FAR *LPENUMCODESTOREDBENTRY;


EXTERN_C const IID IID_IEnumCodeStoreDBEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumCodeStoreDBEntry : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCodeStoreDBEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumCodeStoreDBEntryVtbl;

    interface IEnumCodeStoreDBEntry
    {
        CONST_VTBL struct IEnumCodeStoreDBEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCodeStoreDBEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCodeStoreDBEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCodeStoreDBEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCodeStoreDBEntry_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCodeStoreDBEntry_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCodeStoreDBEntry_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCodeStoreDBEntry_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Next_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCodeStoreDBEntry_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Skip_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCodeStoreDBEntry_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Reset_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This);


void __RPC_STUB IEnumCodeStoreDBEntry_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Clone_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This,
    /* [out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCodeStoreDBEntry_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCodeStoreDBEntry_INTERFACE_DEFINED__ */


#ifndef __ICodeStoreDBEntry_INTERFACE_DEFINED__
#define __ICodeStoreDBEntry_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICodeStoreDBEntry
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICodeStoreDBEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICodeStoreDBEntry : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateChild( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveChild( 
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChild( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumChildren( 
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteProperty( 
            /* [in] */ LPCOLESTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDWORDPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [out] */ DWORD __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDWORDPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPSTR pszVal,
            /* [in] */ DWORD cbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStringPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeStoreDBEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICodeStoreDBEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICodeStoreDBEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateChild )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveChild )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChild )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumChildren )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProperty )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDWORDPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ DWORD __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDWORDPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPSTR pszVal,
            /* [in] */ DWORD cbVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStringPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszVal);
        
        END_INTERFACE
    } ICodeStoreDBEntryVtbl;

    interface ICodeStoreDBEntry
    {
        CONST_VTBL struct ICodeStoreDBEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeStoreDBEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeStoreDBEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodeStoreDBEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodeStoreDBEntry_GetName(This,dwFlags,pbstrName)	\
    (This)->lpVtbl -> GetName(This,dwFlags,pbstrName)

#define ICodeStoreDBEntry_CreateChild(This,pszName,ppEntry)	\
    (This)->lpVtbl -> CreateChild(This,pszName,ppEntry)

#define ICodeStoreDBEntry_RemoveChild(This,pszName,dwFlags)	\
    (This)->lpVtbl -> RemoveChild(This,pszName,dwFlags)

#define ICodeStoreDBEntry_GetChild(This,pszName,ppEntry)	\
    (This)->lpVtbl -> GetChild(This,pszName,ppEntry)

#define ICodeStoreDBEntry_EnumChildren(This,ppEntry)	\
    (This)->lpVtbl -> EnumChildren(This,ppEntry)

#define ICodeStoreDBEntry_GetParent(This,ppParent)	\
    (This)->lpVtbl -> GetParent(This,ppParent)

#define ICodeStoreDBEntry_GetProperty(This,pszName,pvarProperty)	\
    (This)->lpVtbl -> GetProperty(This,pszName,pvarProperty)

#define ICodeStoreDBEntry_SetProperty(This,pszName,pvarProperty)	\
    (This)->lpVtbl -> SetProperty(This,pszName,pvarProperty)

#define ICodeStoreDBEntry_DeleteProperty(This,pszName)	\
    (This)->lpVtbl -> DeleteProperty(This,pszName)

#define ICodeStoreDBEntry_GetDWORDPropertyA(This,pszName,pVal)	\
    (This)->lpVtbl -> GetDWORDPropertyA(This,pszName,pVal)

#define ICodeStoreDBEntry_SetDWORDPropertyA(This,pszName,dwVal)	\
    (This)->lpVtbl -> SetDWORDPropertyA(This,pszName,dwVal)

#define ICodeStoreDBEntry_GetStringPropertyA(This,pszName,pszVal,cbVal)	\
    (This)->lpVtbl -> GetStringPropertyA(This,pszName,pszVal,cbVal)

#define ICodeStoreDBEntry_SetStringPropertyA(This,pszName,pszVal)	\
    (This)->lpVtbl -> SetStringPropertyA(This,pszName,pszVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetName_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB ICodeStoreDBEntry_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_CreateChild_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDBEntry_CreateChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_RemoveChild_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    DWORD dwFlags);


void __RPC_STUB ICodeStoreDBEntry_RemoveChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetChild_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDBEntry_GetChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_EnumChildren_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDBEntry_EnumChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetParent_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB ICodeStoreDBEntry_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetProperty_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);


void __RPC_STUB ICodeStoreDBEntry_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_SetProperty_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);


void __RPC_STUB ICodeStoreDBEntry_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_DeleteProperty_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName);


void __RPC_STUB ICodeStoreDBEntry_DeleteProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetDWORDPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ DWORD __RPC_FAR *pVal);


void __RPC_STUB ICodeStoreDBEntry_GetDWORDPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_SetDWORDPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwVal);


void __RPC_STUB ICodeStoreDBEntry_SetDWORDPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetStringPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ LPSTR pszVal,
    /* [in] */ DWORD cbVal);


void __RPC_STUB ICodeStoreDBEntry_GetStringPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_SetStringPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPCSTR pszVal);


void __RPC_STUB ICodeStoreDBEntry_SetStringPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodeStoreDBEntry_INTERFACE_DEFINED__ */


#ifndef __ICodeStoreDB_INTERFACE_DEFINED__
#define __ICodeStoreDB_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICodeStoreDB
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICodeStoreDB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICodeStoreDB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEntry( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveEntry( 
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntry( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRootEntries( 
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeStoreDBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICodeStoreDB __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICodeStoreDB __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEntry )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveEntry )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEntry )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRootEntries )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        END_INTERFACE
    } ICodeStoreDBVtbl;

    interface ICodeStoreDB
    {
        CONST_VTBL struct ICodeStoreDBVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeStoreDB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeStoreDB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodeStoreDB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodeStoreDB_CreateEntry(This,pszName,ppEntry)	\
    (This)->lpVtbl -> CreateEntry(This,pszName,ppEntry)

#define ICodeStoreDB_RemoveEntry(This,pszName,dwFlags)	\
    (This)->lpVtbl -> RemoveEntry(This,pszName,dwFlags)

#define ICodeStoreDB_GetEntry(This,pszName,ppEntry)	\
    (This)->lpVtbl -> GetEntry(This,pszName,ppEntry)

#define ICodeStoreDB_EnumRootEntries(This,ppEntry)	\
    (This)->lpVtbl -> EnumRootEntries(This,ppEntry)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodeStoreDB_CreateEntry_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDB_CreateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDB_RemoveEntry_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    DWORD dwFlags);


void __RPC_STUB ICodeStoreDB_RemoveEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDB_GetEntry_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDB_GetEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDB_EnumRootEntries_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDB_EnumRootEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodeStoreDB_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CLSID_CodeStoreDB;

class CLSID_CodeStoreDB;
#endif

#ifndef __IJavaPackageManager_INTERFACE_DEFINED__
#define __IJavaPackageManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaPackageManager
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IJavaPackageManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaPackageManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InstallPackage( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFileType,
            /* [out][in] */ LPPACKAGEINSTALLINFO pPackageInfo,
            /* [in] */ UINT cPackages,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCPACKAGESECURITYINFO pSecurityInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UninstallPackage( 
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPackages( 
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPackage( 
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *ppPackage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFile( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IJavaFile __RPC_FAR *__RPC_FAR *ppFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExplicitClassPath( 
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExplicitClassPath( 
            /* [in] */ LPCOLESTR pszPath,
            /* [in] */ BOOL fAppend) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentDirectory( 
            /* [in] */ LPCOLESTR pszDir) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaPackageManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaPackageManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaPackageManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallPackage )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFileType,
            /* [out][in] */ LPPACKAGEINSTALLINFO pPackageInfo,
            /* [in] */ UINT cPackages,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCPACKAGESECURITYINFO pSecurityInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UninstallPackage )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumPackages )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPackage )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *ppPackage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFile )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IJavaFile __RPC_FAR *__RPC_FAR *ppFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExplicitClassPath )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExplicitClassPath )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPath,
            /* [in] */ BOOL fAppend);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCurrentDirectory )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszDir);
        
        END_INTERFACE
    } IJavaPackageManagerVtbl;

    interface IJavaPackageManager
    {
        CONST_VTBL struct IJavaPackageManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaPackageManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaPackageManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaPackageManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaPackageManager_InstallPackage(This,pszFileName,pszNamespace,dwFileType,pPackageInfo,cPackages,dwFlags,pSecurityInfo)	\
    (This)->lpVtbl -> InstallPackage(This,pszFileName,pszNamespace,dwFileType,pPackageInfo,cPackages,dwFlags,pSecurityInfo)

#define IJavaPackageManager_UninstallPackage(This,pszPackageName,pszNamespace,dwFlags)	\
    (This)->lpVtbl -> UninstallPackage(This,pszPackageName,pszNamespace,dwFlags)

#define IJavaPackageManager_EnumPackages(This,pszNamespace,ppEnum)	\
    (This)->lpVtbl -> EnumPackages(This,pszNamespace,ppEnum)

#define IJavaPackageManager_GetPackage(This,pszPackageName,pszNamespace,ppPackage)	\
    (This)->lpVtbl -> GetPackage(This,pszPackageName,pszNamespace,ppPackage)

#define IJavaPackageManager_GetFile(This,pszFileName,pszNamespace,dwFlags,ppFile)	\
    (This)->lpVtbl -> GetFile(This,pszFileName,pszNamespace,dwFlags,ppFile)

#define IJavaPackageManager_GetExplicitClassPath(This,pbstrPath)	\
    (This)->lpVtbl -> GetExplicitClassPath(This,pbstrPath)

#define IJavaPackageManager_SetExplicitClassPath(This,pszPath,fAppend)	\
    (This)->lpVtbl -> SetExplicitClassPath(This,pszPath,fAppend)

#define IJavaPackageManager_SetCurrentDirectory(This,pszDir)	\
    (This)->lpVtbl -> SetCurrentDirectory(This,pszDir)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaPackageManager_InstallPackage_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFileName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [in] */ DWORD dwFileType,
    /* [out][in] */ LPPACKAGEINSTALLINFO pPackageInfo,
    /* [in] */ UINT cPackages,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCPACKAGESECURITYINFO pSecurityInfo);


void __RPC_STUB IJavaPackageManager_InstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_UninstallPackage_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszPackageName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IJavaPackageManager_UninstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_EnumPackages_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [retval][out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IJavaPackageManager_EnumPackages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_GetPackage_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszPackageName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [retval][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *ppPackage);


void __RPC_STUB IJavaPackageManager_GetPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_GetFile_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFileName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IJavaFile __RPC_FAR *__RPC_FAR *ppFile);


void __RPC_STUB IJavaPackageManager_GetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_GetExplicitClassPath_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IJavaPackageManager_GetExplicitClassPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_SetExplicitClassPath_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszPath,
    /* [in] */ BOOL fAppend);


void __RPC_STUB IJavaPackageManager_SetExplicitClassPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_SetCurrentDirectory_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszDir);


void __RPC_STUB IJavaPackageManager_SetCurrentDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaPackageManager_INTERFACE_DEFINED__ */


#ifndef __IJavaPackage_INTERFACE_DEFINED__
#define __IJavaPackage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaPackage
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IJavaPackage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaPackage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPackageName( 
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
            /* [out] */ DWORD __RPC_FAR *pdwVersionLS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilePath( 
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSystemClass( 
            /* [out] */ BOOL __RPC_FAR *pfIsSystemClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NeedsTrustedSource( 
            /* [out] */ BOOL __RPC_FAR *pfNeedsTrustedSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ LPCBYTE __RPC_FAR *ppCapabilities,
            /* [out] */ DWORD __RPC_FAR *pcbCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSigner( 
            /* [out] */ LPCBYTE __RPC_FAR *ppSigner,
            /* [out] */ DWORD __RPC_FAR *pcbSigner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDatabaseEntry( 
            /* [out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFiles( 
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilePathA( 
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaPackageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaPackage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaPackage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaPackage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPackageName )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
            /* [out] */ DWORD __RPC_FAR *pdwVersionLS);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilePath )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSystemClass )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsSystemClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NeedsTrustedSource )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfNeedsTrustedSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ LPCBYTE __RPC_FAR *ppCapabilities,
            /* [out] */ DWORD __RPC_FAR *pcbCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSigner )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ LPCBYTE __RPC_FAR *ppSigner,
            /* [out] */ DWORD __RPC_FAR *pcbSigner);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDatabaseEntry )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumFiles )( 
            IJavaPackage __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilePathA )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath);
        
        END_INTERFACE
    } IJavaPackageVtbl;

    interface IJavaPackage
    {
        CONST_VTBL struct IJavaPackageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaPackage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaPackage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaPackage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaPackage_GetPackageName(This,pbstrName)	\
    (This)->lpVtbl -> GetPackageName(This,pbstrName)

#define IJavaPackage_GetVersion(This,pdwVersionMS,pdwVersionLS)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersionMS,pdwVersionLS)

#define IJavaPackage_GetFilePath(This,pbstrPath)	\
    (This)->lpVtbl -> GetFilePath(This,pbstrPath)

#define IJavaPackage_IsSystemClass(This,pfIsSystemClass)	\
    (This)->lpVtbl -> IsSystemClass(This,pfIsSystemClass)

#define IJavaPackage_NeedsTrustedSource(This,pfNeedsTrustedSource)	\
    (This)->lpVtbl -> NeedsTrustedSource(This,pfNeedsTrustedSource)

#define IJavaPackage_GetCapabilities(This,ppCapabilities,pcbCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,ppCapabilities,pcbCapabilities)

#define IJavaPackage_GetSigner(This,ppSigner,pcbSigner)	\
    (This)->lpVtbl -> GetSigner(This,ppSigner,pcbSigner)

#define IJavaPackage_GetDatabaseEntry(This,ppEntry)	\
    (This)->lpVtbl -> GetDatabaseEntry(This,ppEntry)

#define IJavaPackage_EnumFiles(This,dwFlags,ppEnum)	\
    (This)->lpVtbl -> EnumFiles(This,dwFlags,ppEnum)

#define IJavaPackage_GetFilePathA(This,pszPath,cbPath)	\
    (This)->lpVtbl -> GetFilePathA(This,pszPath,cbPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaPackage_GetPackageName_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IJavaPackage_GetPackageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetVersion_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
    /* [out] */ DWORD __RPC_FAR *pdwVersionLS);


void __RPC_STUB IJavaPackage_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetFilePath_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IJavaPackage_GetFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_IsSystemClass_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsSystemClass);


void __RPC_STUB IJavaPackage_IsSystemClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_NeedsTrustedSource_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfNeedsTrustedSource);


void __RPC_STUB IJavaPackage_NeedsTrustedSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetCapabilities_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ LPCBYTE __RPC_FAR *ppCapabilities,
    /* [out] */ DWORD __RPC_FAR *pcbCapabilities);


void __RPC_STUB IJavaPackage_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetSigner_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ LPCBYTE __RPC_FAR *ppSigner,
    /* [out] */ DWORD __RPC_FAR *pcbSigner);


void __RPC_STUB IJavaPackage_GetSigner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetDatabaseEntry_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB IJavaPackage_GetDatabaseEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_EnumFiles_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [retval][out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IJavaPackage_EnumFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetFilePathA_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ LPSTR pszPath,
    /* [in] */ DWORD cbPath);


void __RPC_STUB IJavaPackage_GetFilePathA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaPackage_INTERFACE_DEFINED__ */


#ifndef __ICreateJavaPackageMgr_INTERFACE_DEFINED__
#define __ICreateJavaPackageMgr_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICreateJavaPackageMgr
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ICreateJavaPackageMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICreateJavaPackageMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPackageManager( 
            /* [out] */ IJavaPackageManager __RPC_FAR *__RPC_FAR *ppPackageMgr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateJavaPackageMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICreateJavaPackageMgr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICreateJavaPackageMgr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICreateJavaPackageMgr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPackageManager )( 
            ICreateJavaPackageMgr __RPC_FAR * This,
            /* [out] */ IJavaPackageManager __RPC_FAR *__RPC_FAR *ppPackageMgr);
        
        END_INTERFACE
    } ICreateJavaPackageMgrVtbl;

    interface ICreateJavaPackageMgr
    {
        CONST_VTBL struct ICreateJavaPackageMgrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateJavaPackageMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateJavaPackageMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateJavaPackageMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateJavaPackageMgr_GetPackageManager(This,ppPackageMgr)	\
    (This)->lpVtbl -> GetPackageManager(This,ppPackageMgr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICreateJavaPackageMgr_GetPackageManager_Proxy( 
    ICreateJavaPackageMgr __RPC_FAR * This,
    /* [out] */ IJavaPackageManager __RPC_FAR *__RPC_FAR *ppPackageMgr);


void __RPC_STUB ICreateJavaPackageMgr_GetPackageManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateJavaPackageMgr_INTERFACE_DEFINED__ */


#ifndef __IJavaFile_INTERFACE_DEFINED__
#define __IJavaFile_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaFile
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IJavaFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ DWORD dwType,
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileStream( 
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPENativePath( 
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPENativePathA( 
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimestamp( 
            /* [out] */ DWORD __RPC_FAR *pdwTimestamp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaFile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaFile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IJavaFile __RPC_FAR * This,
            /* [in] */ DWORD dwType,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileStream )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPENativePath )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPENativePathA )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTimestamp )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwTimestamp);
        
        END_INTERFACE
    } IJavaFileVtbl;

    interface IJavaFile
    {
        CONST_VTBL struct IJavaFileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaFile_GetName(This,dwType,pbstrName)	\
    (This)->lpVtbl -> GetName(This,dwType,pbstrName)

#define IJavaFile_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IJavaFile_GetFileStream(This,ppStream)	\
    (This)->lpVtbl -> GetFileStream(This,ppStream)

#define IJavaFile_GetPENativePath(This,pbstrPath)	\
    (This)->lpVtbl -> GetPENativePath(This,pbstrPath)

#define IJavaFile_GetPENativePathA(This,pszPath,cbPath)	\
    (This)->lpVtbl -> GetPENativePathA(This,pszPath,cbPath)

#define IJavaFile_GetTimestamp(This,pdwTimestamp)	\
    (This)->lpVtbl -> GetTimestamp(This,pdwTimestamp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaFile_GetName_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [in] */ DWORD dwType,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IJavaFile_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IJavaFile_GetFlags_Proxy( 
    IJavaFile __RPC_FAR * This);


void __RPC_STUB IJavaFile_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetFileStream_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IJavaFile_GetFileStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetPENativePath_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IJavaFile_GetPENativePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetPENativePathA_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ LPSTR pszPath,
    /* [in] */ DWORD cbPath);


void __RPC_STUB IJavaFile_GetPENativePathA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetTimestamp_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwTimestamp);


void __RPC_STUB IJavaFile_GetTimestamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaFile_INTERFACE_DEFINED__ */


#ifndef __IEnumJavaPackage_INTERFACE_DEFINED__
#define __IEnumJavaPackage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumJavaPackage
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumJavaPackage __RPC_FAR *LPENUMJAVAPACKAGE;


EXTERN_C const IID IID_IEnumJavaPackage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumJavaPackage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumJavaPackageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumJavaPackage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumJavaPackage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumJavaPackage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumJavaPackageVtbl;

    interface IEnumJavaPackage
    {
        CONST_VTBL struct IEnumJavaPackageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumJavaPackage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumJavaPackage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumJavaPackage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumJavaPackage_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumJavaPackage_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumJavaPackage_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumJavaPackage_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Next_Proxy( 
    IEnumJavaPackage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumJavaPackage_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Skip_Proxy( 
    IEnumJavaPackage __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumJavaPackage_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Reset_Proxy( 
    IEnumJavaPackage __RPC_FAR * This);


void __RPC_STUB IEnumJavaPackage_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Clone_Proxy( 
    IEnumJavaPackage __RPC_FAR * This,
    /* [out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumJavaPackage_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumJavaPackage_INTERFACE_DEFINED__ */


#ifndef __IEnumJavaFile_INTERFACE_DEFINED__
#define __IEnumJavaFile_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumJavaFile
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumJavaFile __RPC_FAR *LPENUMJAVAFILE;


EXTERN_C const IID IID_IEnumJavaFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumJavaFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaFile __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumJavaFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumJavaFile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaFile __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumJavaFileVtbl;

    interface IEnumJavaFile
    {
        CONST_VTBL struct IEnumJavaFileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumJavaFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumJavaFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumJavaFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumJavaFile_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumJavaFile_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumJavaFile_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumJavaFile_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumJavaFile_Next_Proxy( 
    IEnumJavaFile __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IJavaFile __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumJavaFile_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaFile_Skip_Proxy( 
    IEnumJavaFile __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumJavaFile_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaFile_Reset_Proxy( 
    IEnumJavaFile __RPC_FAR * This);


void __RPC_STUB IEnumJavaFile_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaFile_Clone_Proxy( 
    IEnumJavaFile __RPC_FAR * This,
    /* [out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumJavaFile_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumJavaFile_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CLSID_JavaPackageManager;

class CLSID_JavaPackageManager;
#endif
#endif /* __JPKGMGR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\unixdef.h ===
#ifdef _WIN64
typedef __int64 DWORD_PTR, *PDWORD_PTR;
#else
typedef long DWORD_PTR, *PDWORD_PTR;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\wabmem.h ===
#if !defined(WABMEM_H)
#define WABMEM_H

#if !defined(MAPIX_H)
typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE MAPIFREEBUFFER)(
	LPVOID			lpBuffer
);

typedef MAPIALLOCATEBUFFER FAR	*LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE FAR	*LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER FAR 		*LPMAPIFREEBUFFER;

#endif  // MAPIX_H

typedef SCODE (STDMETHODCALLTYPE WABALLOCATEBUFFER)(
   LPWABOBJECT     lpWABObject,
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE WABALLOCATEMORE)(
   LPWABOBJECT     lpWABObject,
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE WABFREEBUFFER)(
   LPWABOBJECT     lpWABObject,
	LPVOID			lpBuffer
);

typedef WABALLOCATEBUFFER FAR	*LPWABALLOCATEBUFFER;
typedef WABALLOCATEMORE FAR	*LPWABALLOCATEMORE;
typedef WABFREEBUFFER FAR 		*LPWABFREEBUFFER;
#endif  // WABMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\wabnot.h ===
/*
 *	WABNOT.H
 *
 * Defines Notification structures.  These are also defined in mapispi.h.
 *
 * Copyright 1986-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPISPI_H) && !defined(WABSPI_H)
#define WABSPI_H
/* Include common MAPI header files if they haven't been already. */


#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Notification key structure for the MAPI notification engine */

typedef struct
{
	ULONG		cb;				/* How big the key is */
	BYTE		ab[MAPI_DIM];	/* Key contents */
} NOTIFKEY, FAR * LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb)		(offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey)		(offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb, _name) \
	struct _NOTIFKEY_ ## _name \
{ \
	ULONG		cb; \
	BYTE		ab[_cb]; \
} _name


/* For Subscribe() */

#define NOTIFY_SYNC				((ULONG) 0x40000000)

/* For Notify() */

#define NOTIFY_CANCELED			((ULONG) 0x80000000)


/* From the Notification Callback function (well, this is really a ulResult) */

#define CALLBACK_DISCONTINUE	((ULONG) 0x80000000)

/* For Transport's SpoolerNotify() */

#define NOTIFY_NEWMAIL			((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND		((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED		((ULONG) 0x00000004)
#define NOTIFY_CRITSEC			((ULONG) 0x00001000)
#define NOTIFY_NONCRIT			((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE	((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR	((ULONG) 0x10000000)

/* For Message Store's SpoolerNotify() */

#define NOTIFY_NEWMAIL_RECEIVED	((ULONG) 0x20000000)

/* For ModifyStatusRow() */

#define	STATUSROW_UPDATE		((ULONG) 0x10000000)

/* For IStorageFromStream() */

#define STGSTRM_RESET			((ULONG) 0x00000000)
#define STGSTRM_CURRENT			((ULONG) 0x10000000)
#define STGSTRM_MODIFY			((ULONG) 0x00000002)
#define STGSTRM_CREATE			((ULONG) 0x00001000)

/* For GetOneOffTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/* For CreateOneOff() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO	((ULONG) 0x00010000) */

/* For ReadReceipt() */
#define MAPI_NON_READ			((ULONG) 0x00000001)

/* For DoConfigPropSheet() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#ifdef __cplusplus
}
#endif

#endif /* MAPISPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\unaligned.hpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//  File:       unaligned.hpp
//
//  Contents:   Templatized data types for access to unaligned scalar values.
//
//----------------------------------------------------------------------------

// Implementation of UNALIGNED data values.  This works for simple scalar values.
// This file is heavily macro-based.  The intent is to do this work with arithmetic.
// The functionality may be expressed much more consisely with memcpy, but I need an
// implementation faster than that.

// To create an UNALIGNED type, use the MAKE_UNALIGNED_TYPE macro.  For example, if
// you need an int_UNALIGNED, say
//
//        MAKE_UNALIGNED_TYPE( int, 4 );
//
// Note that you need to specifiy the size of the base type.  This is because the
// amount of work to be done needs to be known by the preprocessor, where sizeof()
// doesn't work.

// To use: The intent is that replace occurances of "type UNALIGNED" in your code
// with "type_UNALIGNED".  It's simply a lexical change.  You could automate this
// change in order to easily convert code.  More importantly, the reverse
// transformation may also be easily automated, making it easier to merge with code
// that doesn't use these types.

// UNALIGNED64: The unaligned 64 types are an optimization.  They should only be used
// for values over four bytes in size (e.g. __int64, double).  They assume that the
// pointers are aligned to 4-bytes, so that access may be done with two 32-bit
// references, instead of 8 8-bit references.

#ifndef __unaligned_h__
#define __unaligned_h__

#if defined (_MSC_VER) || defined(__APOGEE__)

#define MAKE_UNALIGNED_TYPE(base,size)    typedef base UNALIGNED   base##_UNALIGNED

//
// Use MAKE_UNALIGNED64_TYPE for QWORD data that may only be DWORD aligned on 64-bit
// machines.  Only 64-bit architectures pay the penalty for accessing such data.
//

#ifdef SPARC
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef base base##_UNALIGNED64
#else
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef base UNALIGNED base##_UNALIGNED64
#endif // SPARC

#define MAKE_UNALIGNEDPTR_TYPE(base)      typedef base UNALIGNED *base##_UNALIGNEDPTR

#else // defined (_MSC_VER) || defined(__APOGEE__)


#ifdef BIG_ENDIAN

#define SET2(val,data)                          \
    data[0] = (val) >> 8,                       \
    data[1] = (val)

#define GET2(data)                              \
    ( ( data[0] << 8 ) |                        \
      ( data[1] ) )

#define SET4(val,data)                          \
    data[0] = (val) >> 24,                      \
    data[1] = (val) >> 16,                      \
    data[2] = (val) >> 8,                       \
    data[3] = (val)

#define GET4(data)                              \
    ( ( data[0] << 24 ) |                       \
      ( data[1] << 16 ) |                       \
      ( data[2] << 8 ) |                        \
      ( data[3] ) )

#define SET8(val,data)                          \
    data[0] = (val) >> 56,                      \
    data[1] = (val) >> 48,                      \
    data[2] = (val) >> 40,                      \
    data[3] = (val) >> 32                       \
    data[4] = (val) >> 24,                      \
    data[5] = (val) >> 16,                      \
    data[6] = (val) >> 8,                       \
    data[7] = (val)

#define GET8(data)                              \
    ( ( data[0] << 56 ) |                       \
      ( data[1] << 48 ) |                       \
      ( data[2] << 40 ) |                       \
      ( data[3] << 32 ) |                       \
      ( data[4] << 24 ) |                       \
      ( data[5] << 16 ) |                       \
      ( data[6] << 8 ) |                        \
      ( data[7] ) )

#define SET648(val,data)                        \
    data[0] = (val) >> 32,                      \
    data[1] = (val)

#define GET648(data)                            \
    ( ( data[0] << 32 ) |                       \
      ( data[1] ) )

#else

#define SET2(val,data)                          \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET2(data)                              \
    ( ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET4(val,data)                          \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET4(data)                              \
    ( ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET8(val,data)                          \
    data[7] = (val) >> 56,                      \
    data[6] = (val) >> 48,                      \
    data[5] = (val) >> 40,                      \
    data[4] = (val) >> 32,                      \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET8(data)                              \
    ( ( data[7] << 56 ) |                       \
      ( data[6] << 48 ) |                       \
      ( data[5] << 40 ) |                       \
      ( data[4] << 32 ) |                       \
      ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET648(val,data)                        \
    data[1] = (val) >> 32,                      \
    data[0] = (val)

#define GET648(data)                            \
    ( ( data[1] << 32 ) |                       \
      ( data[0] ) )

#endif

#define GROUP(type,size,get,set,sfx)                                    \
    Unaligned##sfx##size( type v ) { set##size( v, data ); }            \
    type operator = ( type v )     { set##size( v, data ); return v; }  \
    operator type()           { return get##size( data ); }             \
    type operator += (const type v) { set##size( get##size(data) + v, data); return *this; } \
    type operator -= (const type v) { set##size( get##size(data) - v, data); return *this; } \
    type operator <<= (const type v) { set##size( get##size(data) << v, data); return *this; } \
    type operator *= (const type v) { set##size( get##size(data) * v, data); return *this; } \
    type operator /= (const type v) { set##size( get##size(data) / v, data); return *this; } \
    type operator %= (const type v) { set##size( get##size(data) % v, data); return *this; } \
    type operator >>= (const type v) { set##size( get##size(data) >> v, data); return *this; } \
    type operator ^= (const type v) { set##size( get##size(data) ^ v, data); return *this; } \
    type operator &= (const type v) { set##size( get##size(data) & v, data); return *this; } \
    type operator |= (const type v) { set##size( get##size(data) | v, data); return *this; } \


#define MAKE_TEMPLATE(size,type,sfx)                            \
template<class BASE>                                            \
class Unaligned##sfx##size<BASE>                                \
{                                                               \
  protected:                                                    \
    type data[ size / sizeof(type) ];                           \
                                                                \
  public:                                                       \
                                                                \
    GROUP( signed char,      size, GET##sfx, SET##sfx, sfx )    \
    GROUP( short,            size, GET##sfx, SET##sfx, sfx )    \
    GROUP( int,              size, GET##sfx, SET##sfx, sfx )    \
    GROUP( wchar_t,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( long,             size, GET##sfx, SET##sfx, sfx )    \
    GROUP( __int64,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned char,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned short,   size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned int,     size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned long,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned __int64, size, GET##sfx, SET##sfx, sfx )    \
}

MAKE_TEMPLATE( 2, unsigned char, );
MAKE_TEMPLATE( 4, unsigned char, );
MAKE_TEMPLATE( 8, unsigned char, );
MAKE_TEMPLATE( 8, unsigned int, 64 );

template<class BASE>
class UnalignedPtr<BASE> : Unaligned4<BASE> {
public:
	UnalignedPtr<BASE>(const void * v) : Unaligned4<BASE>((int)v) { }
	void *operator = (void * v)        { SET4((int)v,data); return v; }
	const void *operator = (const void * v)        { SET4((int)v,data); return v; }
	operator BASE()              { return (BASE)GET4(data); }
};

#undef SET2
#undef SET4
#undef SET8
#undef SET648
#undef GROUP
#undef MAKE_TEMPLATE

#define MAKE_UNALIGNED_TYPE(base,size)    typedef Unaligned##size<base>   base##_UNALIGNED
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef Unaligned64##size<base> base##_UNALIGNED64
#define MAKE_UNALIGNEDPTR_TYPE(base)      typedef UnalignedPtr<base> *    base##_UNALIGNEDPTR

#endif  // _MSC_VER

// Predefine some of the basic types.

MAKE_UNALIGNED_TYPE( short, 2 );
MAKE_UNALIGNED_TYPE( int, 4 );
MAKE_UNALIGNED_TYPE( long, 4 );
MAKE_UNALIGNED_TYPE( WORD, 2 );
MAKE_UNALIGNED_TYPE( DWORD, 4 );
MAKE_UNALIGNED_TYPE( USHORT, 4 );
MAKE_UNALIGNED_TYPE( SHORT, 4 );
MAKE_UNALIGNED_TYPE( __int64, 8 );
MAKE_UNALIGNED64_TYPE( __int64, 8 );

#endif __unaligned_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\wabapi.h ===
#ifndef _WABAPI_H_
#define _WABAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN16
#ifdef GetLastError
#undef GetLastError
#endif // GetLastError
#endif // WIN16

typedef struct _WABACTIONITEM * LPWABACTIONITEM;

/* IWABObject Interface ---------------------------------------------------- */

#define CBIWABOBJECT sizeof(IWABOBJECT)


#define WAB_IWABOBJECT_METHODS(IPURE)                       \
        MAPIMETHOD(GetLastError)                            \
            (THIS_  HRESULT hResult,                        \
                    ULONG   ulFlags,                        \
                    LPMAPIERROR FAR * lppMAPIError) IPURE;  \
        MAPIMETHOD(AllocateBuffer)                          \
            (THIS_  ULONG   cbSize,                         \
                    LPVOID FAR *    lppBuffer) IPURE;       \
        MAPIMETHOD(AllocateMore)                            \
            (THIS_  ULONG   cbSize,                         \
                    LPVOID  lpObject,                       \
                    LPVOID  FAR *   lppBuffer) IPURE;       \
        MAPIMETHOD(FreeBuffer)                              \
            (THIS_  LPVOID  lpBuffer) IPURE;                \
        MAPIMETHOD(Backup)                                  \
            (THIS_  LPSTR  lpFileName) IPURE;              \
        MAPIMETHOD(Import)                                  \
            (THIS_  LPSTR lpImportParam) IPURE;           \
        MAPIMETHOD(Find)                                    \
            (THIS_  LPADRBOOK lpIAB,                        \
                    HWND    hWnd) IPURE;                    \
        MAPIMETHOD(VCardDisplay)                            \
            (THIS_  LPADRBOOK lpIAB,                        \
                    HWND    hWnd,                           \
                    LPSTR  lpszFileName) IPURE;            \
        MAPIMETHOD(LDAPUrl)                                 \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    HWND        hWnd,                       \
                    ULONG       ulFlags,                    \
                    LPSTR       lpszURL,                    \
                    LPMAILUSER *lppMailUser) IPURE;         \
        MAPIMETHOD(VCardCreate)                             \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    LPSTR       lpszVCard,                  \
                    LPMAILUSER  lpMailUser) IPURE;          \
        MAPIMETHOD(VCardRetrieve)                           \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    LPSTR       lpszVCard,                  \
                    LPMAILUSER *lppMailUser) IPURE;         \
        MAPIMETHOD(GetMe)                                   \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    DWORD *     lpdwAction,                 \
                    SBinary *   lpsbEID,                    \
                    ULONG       ulParam) IPURE;          \
        MAPIMETHOD(SetMe)                                   \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    SBinary     sbEID,                      \
                    ULONG       ulParam) IPURE;          \



#undef           INTERFACE
#define          INTERFACE      IWABObject
DECLARE_MAPI_INTERFACE_(IWABObject, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IWABOBJECT_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IWABObject, LPWABOBJECT);


#undef  INTERFACE
#define INTERFACE       struct _IWABOBJECT

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWABOBJECT_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWABOBJECT_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWABOBJECT_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWABOBJECT_)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(IMPL)
   WAB_IWABOBJECT_METHODS(IMPL)
};


/*** WABObject_LDAPUrl flags ***/

// If this flag is specified and the LDAPUrl returns a single
// query result, instructs the WAB to return the result in the
// form of a MailUser object instead of displaying Details on it
// If there are multiple results to the query, fail ..
#define WABOBJECT_LDAPURL_RETURN_MAILUSER   0x00000001

// WAB 5.0x and higher:
// If your application supports Unicode and wants to pass ina Unicode
//  URL to the WAB, you can cast the Unicode URL to an LPSTR and pass it
// to the LDAPUrl API, *also* setting ulFlags to MAPI_UNICODE to mark the URL
// as such. Casting is prefered to converting the string because 
// (a) Converting the string may result in loss of data (b) since this is an
// already published interface we can't modify the interface.
//      MAPI_UNICODE                        0x80000000



/*** WABObject_GetMe returned parameter ***/
// If the GetMe call results in the creation of a new 'Me' contact,
// the lpdwAction returned parameter will contain this value
// indicating to the caller that the object is freshly created and
// does not have any properties in it
#define WABOBJECT_ME_NEW                    0x00000001



/*** WABObject_GetMe flags ***/
// WABObject_GetMe will create a new ME object by default, if 
// none already exists. To force the call to not-create an object, if
// one doesn't already exist, specify the WABOBJECT_ME_NOCREATE flag.
// If no me is found, the call fails with MAPI_E_NOT_FOUND.
// Other flag for WABObject_GetMe is AB_NO_DIALOG defined in wabdefs.h
#define WABOBJECT_ME_NOCREATE               0x00000002



/*** IWABObject_VCard Create/Retrieve ***/
// Flags the WAB whether the lpszVCard parameter is a filename or if
// it is a NULL terminated string containing the compelte VCard contents
//
#define WAB_VCARD_FILE                      0x00000000
#define WAB_VCARD_STREAM                    0x00000001





#ifdef WIN16
BOOL WINAPI WABInitThread();
#endif


//
// Input information to pass to WABOpen
//
typedef struct _tagWAB_PARAM
{
    ULONG   cbSize;         // sizeof(WAB_PARAM).
    HWND    hwnd;           // hWnd of calling client Application. Can be NULL
    LPSTR   szFileName;     // WAB File name to open. if NULL, opens default.
    ULONG   ulFlags;        // See below
    GUID    guidPSExt;      // A GUID that identifies the calling application's Property Sheet extensions
                            // The GUID can be used to determine whether the extension prop sheets are displayed or not.
} WAB_PARAM, * LPWAB_PARAM;

//flags for WAB_PARAM
#define WAB_USE_OE_SENDMAIL     0x00000001  // Tells WAB to use Outlook Express for e-mail before checking for a 
                                            // default Simple MAPI client. Default behaviour is to check for the 
                                            // Simple MAPI client first

#define WAB_ENABLE_PROFILES     0x00400000  // Invokes WAB in a Identity-aware session using Identity-Manager 
                                            // based profiles


//
// Root public entry points for WAB API
//
STDMETHODIMP WABOpen(LPADRBOOK FAR * lppAdrBook, LPWABOBJECT FAR * lppWABObject,
  LPWAB_PARAM lpWP, DWORD Reserved2);

typedef HRESULT (STDMETHODCALLTYPE WABOPEN)(
    LPADRBOOK FAR * lppAdrBook,
    LPWABOBJECT FAR * lppWABObject,
    LPWAB_PARAM lpWP,
    DWORD Reserved2
);
typedef WABOPEN FAR * LPWABOPEN;


STDMETHODIMP WABOpenEx(LPADRBOOK FAR * lppAdrBook,
  LPWABOBJECT FAR * lppWABObject,
  LPWAB_PARAM lpWP,
  DWORD Reserved,
  ALLOCATEBUFFER * fnAllocateBuffer,
  ALLOCATEMORE * fnAllocateMore,
  FREEBUFFER * fnFreeBuffer);

typedef HRESULT (STDMETHODCALLTYPE WABOPENEX)(
    LPADRBOOK FAR * lppAdrBook,
    LPWABOBJECT FAR * lppWABObject,
    LPWAB_PARAM lpWP,
    DWORD Reserved,
    ALLOCATEBUFFER * fnAllocateBuffer,
    ALLOCATEMORE * fnAllocateMore,
    FREEBUFFER * fnFreeBuffer
);
typedef WABOPENEX FAR * LPWABOPENEX;

/* --------------------- */
typedef struct _WABIMPORTPARAM
{
    ULONG cbSize;       // sizeof(WABIMPORTPARAM)
    LPADRBOOK lpAdrBook;// ptr to the IAdrBook object (required)
    HWND hWnd;          // Parent HWND for any dialogs
    ULONG ulFlags;      // 0 or MAPI_DIALOG to show progress dialog and messages
    LPSTR lpszFileName; // FileName to import or NULL .. if NULL will show FileOpen dialog 
} WABIMPORTPARAM, FAR * LPWABIMPORTPARAM;



/* ---- WABEXTDISPLAY ----------------- */
/* WABEXTDISPLAY Structure used in extending the WAB Details Property Dialogs 
    and for doing WAB Context Menu verb extensions.
   The structure is passed into the IWABExtInit::Initialize method
    of the implementor */

// Flags
#define WAB_DISPLAY_LDAPURL 0x00000001  // The object being displayed is an LDAP URL
                                        // The URL can be found in the lpsz struct member

#define WAB_CONTEXT_ADRLIST 0x00000002  // THe lpv parameter contains a pointer to an
                                        // AdrList structure corresponding to selected items
                                        // on which to display a context menu

#define WAB_DISPLAY_ISNTDS  0x00000004  // Identifies that the entry being displayed originated
                                        // on the NT Directory Service, for clients that use ADSI and
                                        // retrieve additional information from the service.

//      MAPI_UNICODE        0x80000000  // Indicates that the WED.lpsz string is actually a UNICODE
                                        //  string and should be cast to a (LPWSTR) before using it
                                        // If this flag is not present then the WED.lpsz is a DBCS string
                                        //  and should be cast to an LPSTR before using.

// Struct
typedef struct _WABEXTDISPLAY
{
    ULONG cbSize;
    LPWABOBJECT lpWABObject;    // pointer to IWABObject
    LPADRBOOK lpAdrBook;        // pointer to IAdrBook object
    LPMAPIPROP lpPropObj;       // Object being displayed
    BOOL fReadOnly;             // Indicates if this is a ReadOnly mode
    BOOL fDataChanged;          // Set by extension sheet to signal data change
    ULONG ulFlags;              // See above
    LPVOID lpv;                 // Used for passing in specific data
    LPTSTR lpsz;               // Used for passing in specific data
} WABEXTDISPLAY, FAR * LPWABEXTDISPLAY;

/* --------------------- */

#define WAB_IWABEXTINIT_METHODS(IPURE)                          \
        MAPIMETHOD(Initialize)                                  \
            (THIS_  LPWABEXTDISPLAY lpWABExtDisplay)    IPURE;  \

#undef           INTERFACE
#define          INTERFACE      IWABExtInit
DECLARE_MAPI_INTERFACE_(IWABExtInit, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IWABEXTINIT_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IWABExtInit, LPWABEXTINIT);

DEFINE_GUID(IID_IWABExtInit, 
0xea22ebf0, 0x87a4, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);


/* --------------------- */

#ifndef WIN16
#define WAB_DLL_NAME TEXT("WAB32.DLL")
#else
#define WAB_DLL_NAME "WAB16.DLL"
#endif

#define WAB_DLL_PATH_KEY TEXT("Software\\Microsoft\\WAB\\DLLPath")

#ifdef __cplusplus
}
#endif

#endif /* _WABAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\wabcode.h ===
/*
 *  WABCODE.H
 *
 *  Status Codes returned by WAB routines
 *
 *  Copyright 1993-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPICODE_H) && !defined(WABCODE_H)
#define WABCODE_H

/* Define S_OK and ITF_* */

#ifdef WIN32
#include <objerror.h>
#endif

/*
 *  WAB Status codes follow the style of OLE 2.0 sCodes as defined in the
 *  OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *  or objerror.h (Windows NT 3.5 and Windows 95).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *          0x0 - FACILITY_NULL     generally useful errors ([SE]_*)
 *          0x1 - FACILITY_RPC      remote procedure call errors (RPC_E_*)
 *          0x2 - FACILITY_DISPATCH late binding dispatch errors
 *          0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *          0x4 - FACILITY_ITF      interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *
 *   where
 *
 *      S - Severity - indicates success/fail
 *
 *          0 - Success
 *          1 - Fail (COERROR)
 *
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *
 *      Code - is the facility's status code
 *
 */




/*
 *  We can't use OLE 2.0 macros to build sCodes because the definition has
 *  changed and we wish to conform to the new definition.
 */
#define MAKE_MAPI_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_MAPI_E( err )  (MAKE_MAPI_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_MAPI_S( warn ) (MAKE_MAPI_SCODE( 0, FACILITY_ITF, warn ))

#ifdef  SUCCESS_SUCCESS
#undef  SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS     0L

/* General errors (used by more than one WAB object) */

#define MAPI_E_CALL_FAILED                              E_FAIL
#define MAPI_E_NOT_ENOUGH_MEMORY                        E_OUTOFMEMORY
#define MAPI_E_INVALID_PARAMETER                        E_INVALIDARG
#define MAPI_E_INTERFACE_NOT_SUPPORTED                  E_NOINTERFACE
#define MAPI_E_NO_ACCESS                                E_ACCESSDENIED

#define MAPI_E_NO_SUPPORT                               MAKE_MAPI_E( 0x102 )
#define MAPI_E_BAD_CHARWIDTH                            MAKE_MAPI_E( 0x103 )
#define MAPI_E_STRING_TOO_LONG                          MAKE_MAPI_E( 0x105 )
#define MAPI_E_UNKNOWN_FLAGS                            MAKE_MAPI_E( 0x106 )
#define MAPI_E_INVALID_ENTRYID                          MAKE_MAPI_E( 0x107 )
#define MAPI_E_INVALID_OBJECT                           MAKE_MAPI_E( 0x108 )
#define MAPI_E_OBJECT_CHANGED                           MAKE_MAPI_E( 0x109 )
#define MAPI_E_OBJECT_DELETED                           MAKE_MAPI_E( 0x10A )
#define MAPI_E_BUSY                                     MAKE_MAPI_E( 0x10B )
#define MAPI_E_NOT_ENOUGH_DISK                          MAKE_MAPI_E( 0x10D )
#define MAPI_E_NOT_ENOUGH_RESOURCES                     MAKE_MAPI_E( 0x10E )
#define MAPI_E_NOT_FOUND                                MAKE_MAPI_E( 0x10F )
#define MAPI_E_VERSION                                  MAKE_MAPI_E( 0x110 )
#define MAPI_E_LOGON_FAILED                             MAKE_MAPI_E( 0x111 )
#define MAPI_E_SESSION_LIMIT                            MAKE_MAPI_E( 0x112 )
#define MAPI_E_USER_CANCEL                              MAKE_MAPI_E( 0x113 )
#define MAPI_E_UNABLE_TO_ABORT                          MAKE_MAPI_E( 0x114 )
#define MAPI_E_NETWORK_ERROR                            MAKE_MAPI_E( 0x115 )
#define MAPI_E_DISK_ERROR                               MAKE_MAPI_E( 0x116 )
#define MAPI_E_TOO_COMPLEX                              MAKE_MAPI_E( 0x117 )
#define MAPI_E_BAD_COLUMN                               MAKE_MAPI_E( 0x118 )
#define MAPI_E_EXTENDED_ERROR                           MAKE_MAPI_E( 0x119 )
#define MAPI_E_COMPUTED                                 MAKE_MAPI_E( 0x11A )
#define MAPI_E_CORRUPT_DATA                             MAKE_MAPI_E( 0x11B )
#define MAPI_E_UNCONFIGURED                             MAKE_MAPI_E( 0x11C )
#define MAPI_E_FAILONEPROVIDER                          MAKE_MAPI_E( 0x11D )

/* WAB base function and status object specific errors and warnings */

#define MAPI_E_END_OF_SESSION                           MAKE_MAPI_E( 0x200 )
#define MAPI_E_UNKNOWN_ENTRYID                          MAKE_MAPI_E( 0x201 )
#define MAPI_E_MISSING_REQUIRED_COLUMN                  MAKE_MAPI_E( 0x202 )
#define MAPI_W_NO_SERVICE                               MAKE_MAPI_S( 0x203 )

/* Property specific errors and warnings */

#define MAPI_E_BAD_VALUE                                MAKE_MAPI_E( 0x301 )
#define MAPI_E_INVALID_TYPE                             MAKE_MAPI_E( 0x302 )
#define MAPI_E_TYPE_NO_SUPPORT                          MAKE_MAPI_E( 0x303 )
#define MAPI_E_UNEXPECTED_TYPE                          MAKE_MAPI_E( 0x304 )
#define MAPI_E_TOO_BIG                                  MAKE_MAPI_E( 0x305 )
#define MAPI_E_DECLINE_COPY                             MAKE_MAPI_E( 0x306 )
#define MAPI_E_UNEXPECTED_ID                            MAKE_MAPI_E( 0x307 )

#define MAPI_W_ERRORS_RETURNED                          MAKE_MAPI_S( 0x380 )

/* Table specific errors and warnings */

#define MAPI_E_UNABLE_TO_COMPLETE                       MAKE_MAPI_E( 0x400 )
#define MAPI_E_TIMEOUT                                  MAKE_MAPI_E( 0x401 )
#define MAPI_E_TABLE_EMPTY                              MAKE_MAPI_E( 0x402 )
#define MAPI_E_TABLE_TOO_BIG                            MAKE_MAPI_E( 0x403 )

#define MAPI_E_INVALID_BOOKMARK                         MAKE_MAPI_E( 0x405 )

#define MAPI_W_POSITION_CHANGED                         MAKE_MAPI_S( 0x481 )
#define MAPI_W_APPROX_COUNT                             MAKE_MAPI_S( 0x482 )

#define MAPI_W_PARTIAL_COMPLETION						 MAKE_MAPI_S( 0x680 )

/* Address Book specific errors and warnings */

#define MAPI_E_AMBIGUOUS_RECIP                          MAKE_MAPI_E( 0x700 )


/* Miscellaneous errors */
#define MAPI_E_COLLISION                                MAKE_MAPI_E( 0x604 )
#define MAPI_E_NOT_INITIALIZED                          MAKE_MAPI_E( 0x605 )
#define MAPI_E_FOLDER_CYCLE                             MAKE_MAPI_E( 0x60B )

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#define MakeResult(_s)  ResultFromScode(_s)
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef HR_SUCCEEDED
#define HR_SUCCEEDED(_hr) SUCCEEDED((SCODE)(_hr))
#define HR_FAILED(_hr) FAILED((SCODE)(_hr))
#endif

#endif  /* WABCODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\wabiab.h ===
/* IAddrBook Interface ----------------------------------------------------- */

/*  CreateOneOff */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000) */

/*  RecipOptions */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  QueryDefaultRecipOpt */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  GetSearchPath */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */


#ifndef WABIAB_H
#define WABIAB_H

// These are WAB only flags for IAdrBook::ResolveName
//      MAPI_UNICODE                        ((ULONG) 0x80000000)
#define WAB_RESOLVE_LOCAL_ONLY              ((ULONG) 0x80000000) 
#define WAB_RESOLVE_ALL_EMAILS              ((ULONG) 0x40000000)
#define WAB_RESOLVE_NO_ONE_OFFS             ((ULONG) 0x20000000)
#define WAB_RESOLVE_NEED_CERT               ((ULONG) 0x10000000)
#define WAB_RESOLVE_NO_NOT_FOUND_UI         ((ULONG) 0x08000000)
#define WAB_RESOLVE_USE_CURRENT_PROFILE     ((ULONG) 0x04000000)
#define WAB_RESOLVE_FIRST_MATCH             ((ULONG) 0x02000000)
#define WAB_RESOLVE_UNICODE                 ((ULONG) 0x01000000)
//      MAPI_DIALOG                         ((ULONG) 0x00000008)

#ifndef MAPIX_H

#define MAPI_IADDRBOOK_METHODS(IPURE)									\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;	\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CreateOneOff)											\
		(THIS_	LPTSTR						lpszName,					\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszAddress,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(NewEntry)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cbEIDContainer,				\
				LPENTRYID					lpEIDContainer,				\
				ULONG						cbEIDNewEntryTpl,			\
				LPENTRYID					lpEIDNewEntryTpl,			\
				ULONG FAR *					lpcbEIDNewEntry,			\
				LPENTRYID FAR *				lppEIDNewEntry) IPURE;		\
	MAPIMETHOD(ResolveName)												\
		(THIS_	ULONG_PTR						ulUIParam,					\
				ULONG						ulFlags,					\
				LPTSTR						lpszNewEntryTitle,			\
				LPADRLIST					lpAdrList) IPURE;			\
	MAPIMETHOD(Address)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPADRPARM					lpAdrParms,					\
				LPADRLIST FAR *				lppAdrList) IPURE;			\
	MAPIMETHOD(Details)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPFNDISMISS					lpfnDismiss,				\
				LPVOID						lpvDismissContext,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPFNBUTTON					lpfButtonCallback,			\
				LPVOID						lpvButtonContext,			\
				LPTSTR						lpszButtonText,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RecipOptions)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				LPADRENTRY					lpRecip) IPURE;				\
	MAPIMETHOD(QueryDefaultRecipOpt)									\
		(THIS_	LPTSTR						lpszAdrType,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(GetPAB)													\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetPAB)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetDefaultDir)											\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetDefaultDir)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet FAR *				lppSearchPath) IPURE;		\
	MAPIMETHOD(SetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSearchPath) IPURE;		\
	MAPIMETHOD(PrepareRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropTagArray,				\
				LPADRLIST					lpRecipList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook, IMAPIProp)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook, LPADRBOOK);
#endif  // MAPIX_H
#endif  // WABIAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\wabdefs.h ===
/*
 *  WABDEFS.H
 *
 *  Definitions used by WAB clients
 *
 *  Copyright 1993-1998 Microsoft Corporation. All Rights Reserved.
 */

#ifdef WIN16
#ifdef GetLastError
#undef GetLastError
#endif // GetLastError
#endif // WIN16

#if !defined(MAPIDEFS_H) && !defined(WABDEFS_H)
#define WABDEFS_H
#if defined (WIN32)

#if defined (NT) && !defined (_WINNT)
#pragma message ("\nWARNING!!\n NT defined but not _WINNT.\n    You must define _WINNT to ensure "\
    "successful compile of Windows NT code\n")
#define _WINNT
#endif /* defined NT and not defined _WINNT */
#endif /* WIN32 */

#if defined (WIN32) && !defined (MAC)   /* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#define _INC_OLE /* Windows 95 will include OLE1 without this */
#include <windows.h>
#endif

#ifndef _OLEERROR_H_
#include <objerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16) || defined (MAC)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM    1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (WIN32)
#define STDMAPIINITCALLTYPE     __cdecl
#else
#define STDMAPIINITCALLTYPE     STDMETHODCALLTYPE
#endif
#define STDINITMETHODIMP        HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type) type STDMAPIINITCALLTYPE
#endif

#ifdef  __cplusplus
extern "C" {
#endif

/* Simple data types */


#if !defined(UNIX) && !defined(WIN16)
typedef WORD                WCHAR;
#endif

#ifdef UNICODE
typedef WCHAR               TCHAR;
#else
typedef char                TCHAR;
#endif

typedef WCHAR FAR *         LPWSTR;
typedef const WCHAR FAR *   LPCWSTR;
typedef TCHAR FAR *         LPTSTR;
typedef const TCHAR FAR *   LPCTSTR;
typedef BYTE FAR *          LPBYTE;
typedef ULONG FAR *         LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef unsigned long   LHANDLE, FAR * LPLHANDLE;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *  This flag is used in many different MAPI calls to signify that
 *  the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY             ((ULONG) 0x00000001)

/*
 *  The following flags are used to indicate to the client what access
 *  level is permissible in the object. They appear in PR_ACCESS in
 *  message and folder objects as well as in contents and associated
 *  contents tables
 */

#define MAPI_ACCESS_MODIFY                  ((ULONG) 0x00000001)
#define MAPI_ACCESS_READ                    ((ULONG) 0x00000002)
#define MAPI_ACCESS_DELETE                  ((ULONG) 0x00000004)
#define MAPI_ACCESS_CREATE_HIERARCHY        ((ULONG) 0x00000008)
#define MAPI_ACCESS_CREATE_CONTENTS         ((ULONG) 0x00000010)
#define MAPI_ACCESS_CREATE_ASSOCIATED       ((ULONG) 0x00000020)

/*
 *  The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *  that strings passed through the interface are in Unicode (a 16-bit
 *  character set). The default is an 8-bit character set.
 *
 *  The value fMapiUnicode can be used as the 'normal' value for
 *  that bit, given the application's default character set.
 */

#define MAPI_UNICODE            ((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode            MAPI_UNICODE
#else
#define fMapiUnicode            0
#endif

/* successful HRESULT */
#define hrSuccess               0



/* Recipient types */
#ifndef MAPI_ORIG               /* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1     0x10000000  /* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4        recipient is a CMC authorizing user      */
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM          0x80
#define MAPI_NOTRECIP           0x40
#define MAPI_THISSESSION        0x20
#define MAPI_NOW                0x10
#define MAPI_NOTRESERVED        0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND           0x80

/* ENTRYID */
typedef struct
{
    BYTE    abFlags[4];
    BYTE    ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)       (offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)          (offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
    struct _ENTRYID_ ## _name \
{ \
    BYTE    abFlags[4]; \
    BYTE    ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
    BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)  (!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))


/* Object type */

#define MAPI_STORE      ((ULONG) 0x00000001)    /* Message Store */
#define MAPI_ADDRBOOK   ((ULONG) 0x00000002)    /* Address Book */
#define MAPI_FOLDER     ((ULONG) 0x00000003)    /* Folder */
#define MAPI_ABCONT     ((ULONG) 0x00000004)    /* Address Book Container */
#define MAPI_MESSAGE    ((ULONG) 0x00000005)    /* Message */
#define MAPI_MAILUSER   ((ULONG) 0x00000006)    /* Individual Recipient */
#define MAPI_ATTACH     ((ULONG) 0x00000007)    /* Attachment */
#define MAPI_DISTLIST   ((ULONG) 0x00000008)    /* Distribution List Recipient */
#define MAPI_PROFSECT   ((ULONG) 0x00000009)    /* Profile Section */
#define MAPI_STATUS     ((ULONG) 0x0000000A)    /* Status Object */
#define MAPI_SESSION    ((ULONG) 0x0000000B)    /* Session */
#define MAPI_FORMINFO   ((ULONG) 0x0000000C)    /* Form Information */


/*
 *  Maximum length of profile names and passwords, not including
 *  the null termination character.
 */
#ifndef cchProfileNameMax
#define cchProfileNameMax   64
#define cchProfilePassMax   64
#endif


/* Property Types */

#define MV_FLAG         0x1000          /* Multi-value flag */

#define PT_UNSPECIFIED  ((ULONG)  0)    /* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL         ((ULONG)  1)    /* NULL property value */
#define PT_I2           ((ULONG)  2)    /* Signed 16-bit value */
#define PT_LONG         ((ULONG)  3)    /* Signed 32-bit value */
#define PT_R4           ((ULONG)  4)    /* 4-byte floating point */
#define PT_DOUBLE       ((ULONG)  5)    /* Floating point double */
#define PT_CURRENCY     ((ULONG)  6)    /* Signed 64-bit int (decimal w/    4 digits right of decimal pt) */
#define PT_APPTIME      ((ULONG)  7)    /* Application time */
#define PT_ERROR        ((ULONG) 10)    /* 32-bit error value */
#define PT_BOOLEAN      ((ULONG) 11)    /* 16-bit boolean (non-zero true) */
#define PT_OBJECT       ((ULONG) 13)    /* Embedded object in a property */
#define PT_I8           ((ULONG) 20)    /* 8-byte signed integer */
#define PT_STRING8      ((ULONG) 30)    /* Null terminated 8-bit character string */
#define PT_UNICODE      ((ULONG) 31)    /* Null terminated Unicode string */
#define PT_SYSTIME      ((ULONG) 64)    /* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define PT_CLSID        ((ULONG) 72)    /* OLE GUID */
#define PT_BINARY       ((ULONG) 258)   /* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define PT_SHORT    PT_I2
#define PT_I4       PT_LONG
#define PT_FLOAT    PT_R4
#define PT_R8       PT_DOUBLE
#define PT_LONGLONG PT_I8

/*
 *  The type of a MAPI-defined string property is indirected, so
 *  that it defaults to Unicode string on a Unicode platform and to
 *  String8 on an ANSI or DBCS platform.
 *
 *  Macros are defined here both for the property type, and for the
 *  field of the property value structure which should be
 *  dereferenced to obtain the string pointer.
 */

#ifdef  UNICODE
#define PT_TSTRING          PT_UNICODE
#define PT_MV_TSTRING       (MV_FLAG|PT_UNICODE)
#define LPSZ                lpszW
#define LPPSZ               lppszW
#define MVSZ                MVszW
#else
#define PT_TSTRING          PT_STRING8
#define PT_MV_TSTRING       (MV_FLAG|PT_STRING8)
#define LPSZ                lpszA
#define LPPSZ               lppszA
#define MVSZ                MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK          ((ULONG)0x0000FFFF) /* Mask for Property type */
#define PROP_TYPE(ulPropTag)    (((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)      (((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)   ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL            0
#define PROP_ID_INVALID         0xFFFF
#define PR_NULL                 PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType) \
                        (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define PT_MV_I2        (MV_FLAG|PT_I2)
#define PT_MV_LONG      (MV_FLAG|PT_LONG)
#define PT_MV_R4        (MV_FLAG|PT_R4)
#define PT_MV_DOUBLE    (MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY  (MV_FLAG|PT_CURRENCY)
#define PT_MV_APPTIME   (MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME   (MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8   (MV_FLAG|PT_STRING8)
#define PT_MV_BINARY    (MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE   (MV_FLAG|PT_UNICODE)
#define PT_MV_CLSID     (MV_FLAG|PT_CLSID)
#define PT_MV_I8        (MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define PT_MV_SHORT     PT_MV_I2
#define PT_MV_I4        PT_MV_LONG
#define PT_MV_FLOAT     PT_MV_R4
#define PT_MV_R8        PT_MV_DOUBLE
#define PT_MV_LONGLONG  PT_MV_I8

/*
 *  Property type reserved bits
 *
 *  MV_INSTANCE is used as a flag in table operations to request
 *  that a multi-valued property be presented as a single-valued
 *  property appearing in multiple rows.
 */

#define MV_INSTANCE     0x2000
#define MVI_FLAG        (MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)   ((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
    ULONG   cValues;
    ULONG   aulPropTag[MAPI_DIM];
} SPropTagArray, FAR * LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
    (offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
    (offsetof(SPropTagArray,aulPropTag) + \
    (UINT)((_lparray)->cValues)*sizeof(ULONG))
/*  SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue  SPropValue;


/* 32-bit CURRENCY definition stolen from oaidl.h */
/* 16-bit CURRENCY definition stolen from variant.h */

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if (defined (WIN16) || defined (DOS)) && !defined (_VARIANT_H_)
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
} CY;
#elif defined (WIN32)
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 16-bit vs 32-bit definition */
#endif
            /* size is 8 */
typedef CY CURRENCY;

typedef struct _SBinary
{
    ULONG       cb;
    LPBYTE      lpb;
} SBinary, FAR *LPSBinary;

typedef struct _SShortArray
{
    ULONG       cValues;
    short int   FAR *lpi;
} SShortArray;

typedef struct _SGuidArray
{
    ULONG       cValues;
    GUID        FAR *lpguid;
} SGuidArray;

typedef struct _SRealArray
{
    ULONG       cValues;
    float       FAR *lpflt;
} SRealArray;

typedef struct _SLongArray
{
    ULONG       cValues;
    LONG        FAR *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
    ULONG       cValues;
    LARGE_INTEGER   FAR *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
    ULONG       cValues;
    FILETIME    FAR *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
    ULONG       cValues;
    double      FAR *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
    ULONG       cValues;
    CURRENCY    FAR *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
    ULONG       cValues;
    SBinary     FAR *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
    ULONG       cValues;
    double      FAR *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
    ULONG       cValues;
    LPWSTR      FAR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
    ULONG       cValues;
    LPSTR       FAR *lppszA;
} SLPSTRArray;

typedef union _PV
{
    short int           i;          /* case PT_I2 */
    LONG                l;          /* case PT_LONG */
    ULONG               ul;         /* alias for PT_LONG */
    float               flt;        /* case PT_R4 */
    double              dbl;        /* case PT_DOUBLE */
    unsigned short int  b;          /* case PT_BOOLEAN */
    CURRENCY            cur;        /* case PT_CURRENCY */
    double              at;         /* case PT_APPTIME */
    FILETIME            ft;         /* case PT_SYSTIME */
    LPSTR               lpszA;      /* case PT_STRING8 */
    SBinary             bin;        /* case PT_BINARY */
    LPWSTR              lpszW;      /* case PT_UNICODE */
    LPGUID              lpguid;     /* case PT_CLSID */
    LARGE_INTEGER       li;         /* case PT_I8 */
    SShortArray         MVi;        /* case PT_MV_I2 */
    SLongArray          MVl;        /* case PT_MV_LONG */
    SRealArray          MVflt;      /* case PT_MV_R4 */
    SDoubleArray        MVdbl;      /* case PT_MV_DOUBLE */
    SCurrencyArray      MVcur;      /* case PT_MV_CURRENCY */
    SAppTimeArray       MVat;       /* case PT_MV_APPTIME */
    SDateTimeArray      MVft;       /* case PT_MV_SYSTIME */
    SBinaryArray        MVbin;      /* case PT_MV_BINARY */
    SLPSTRArray         MVszA;      /* case PT_MV_STRING8 */
    SWStringArray       MVszW;      /* case PT_MV_UNICODE */
    SGuidArray          MVguid;     /* case PT_MV_CLSID */
    SLargeIntegerArray  MVli;       /* case PT_MV_I8 */
    SCODE               err;        /* case PT_ERROR */
    LONG                x;          /* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
    ULONG       ulPropTag;
    ULONG       dwAlignPad;
    union _PV   Value;
} SPropValue, FAR * LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
    ULONG   ulIndex;
    ULONG   ulPropTag;
    SCODE   scode;
} SPropProblem, FAR * LPSPropProblem;

typedef struct _SPropProblemArray
{
    ULONG           cProblem;
    SPropProblem    aProblem[MAPI_DIM];
} SPropProblemArray, FAR * LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
    (offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
    (offsetof(SPropProblemArray,aProblem) + \
    (UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
    ULONG           cProblem; \
    SPropProblem    aProblem[_cprob]; \
} _name

/*
 *  ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *  FLATENTRYLIST
 *  MTSID
 *  FLATMTSIDLIST
 */

typedef struct {
    ULONG cb;
    BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
    ULONG       cEntries;
    ULONG       cbEntries;
    BYTE        abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
    ULONG       cb;
    BYTE        ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
    ULONG       cMTSIDs;
    ULONG       cbMTSIDs;
    BYTE        abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)     (offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)   (offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb) (offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)         (offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)       (offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
    ULONG           ulReserved1;    /* Never used */
    ULONG           cValues;
    LPSPropValue    rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
    ULONG           cEntries;
    ADRENTRY        aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
    (offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
    (offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
    ULONG           cEntries; \
    ADRENTRY        aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
    ULONG           ulAdrEntryPad;  /* Pad so SRow's can map to ADRENTRY's */
    ULONG           cValues;        /* Count of property values */
    LPSPropValue    lpProps;        /* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
    ULONG           cRows;          /* Count of rows */
    SRow            aRow[MAPI_DIM]; /* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define CbNewSRowSet(_crow)     (offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)    (offsetof(SRowSet,aRow) + \
                                    (UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
    ULONG           cRows; \
    SRow            aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
    ULONG           cbSize,
    LPVOID FAR *    lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
    ULONG           cbSize,
    LPVOID          lpObject,
    LPVOID FAR *    lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
    LPVOID          lpBuffer
);

typedef ALLOCATEBUFFER FAR *LPALLOCATEBUFFER;
typedef ALLOCATEMORE FAR *  LPALLOCATEMORE;
typedef FREEBUFFER FAR *    LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface;            \
        struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)              MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
        STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
        typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)                                    \
    MAPIMETHOD(QueryInterface)                                          \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;                 \
    MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;                            \
    MAPIMETHOD_(ULONG,Release) (THIS) IPURE;                            \

#undef  IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,       LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,     LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,        LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,         LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,       LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,    LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,       LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,       LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,     LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,      LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,       LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,       LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,  LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,   LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,  LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
    ULONG   ulVersion;
    LPTSTR  lpszError;
    LPTSTR  lpszComponent;
    ULONG   ulLowLevelError;
    ULONG   ulContext;

} MAPIERROR, FAR * LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *  Notification event types. The event types can be combined in a bitmask
 *  for filtering. Each one has a parameter structure associated with it:
 *
 *      fnevCriticalError       ERROR_NOTIFICATION
 *      fnevNewMail             NEWMAIL_NOTIFICATION
 *      fnevObjectCreated       OBJECT_NOTIFICATION
 *      fnevObjectDeleted       OBJECT_NOTIFICATION
 *      fnevObjectModified      OBJECT_NOTIFICATION
 *      fnevObjectCopied        OBJECT_NOTIFICATION
 *      fnevSearchComplete      OBJECT_NOTIFICATION
 *      fnevTableModified       TABLE_NOTIFICATION
 *      fnevStatusObjectModified OBJECT_NOTIFICATION
 *
 *      fnevExtended            EXTENDED_NOTIFICATION
 */

#define fnevCriticalError           ((ULONG) 0x00000001)
#define fnevNewMail                 ((ULONG) 0x00000002)
#define fnevObjectCreated           ((ULONG) 0x00000004)
#define fnevObjectDeleted           ((ULONG) 0x00000008)
#define fnevObjectModified          ((ULONG) 0x00000010)
#define fnevObjectMoved             ((ULONG) 0x00000020)
#define fnevObjectCopied            ((ULONG) 0x00000040)
#define fnevSearchComplete          ((ULONG) 0x00000080)
#define fnevTableModified           ((ULONG) 0x00000100)
#define fnevStatusObjectModified    ((ULONG) 0x00000200)
#define fnevReservedForMapi         ((ULONG) 0x40000000)
#define fnevExtended                ((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED       1
#define TABLE_ERROR         2
#define TABLE_ROW_ADDED     3
#define TABLE_ROW_DELETED   4
#define TABLE_ROW_MODIFIED  5
#define TABLE_SORT_DONE     6
#define TABLE_RESTRICT_DONE 7
#define TABLE_SETCOL_DONE   8
#define TABLE_RELOAD        9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;
    SCODE       scode;
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPMAPIERROR lpMAPIError;        /* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;          /* identifies the new message */
    ULONG       cbParentID;
    LPENTRYID   lpParentID;         /* identifies the folder it lives in */
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPTSTR      lpszMessageClass;   /* message class (UNICODE or string8) */
    ULONG       ulMessageFlags;     /* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
    ULONG               cbEntryID;
    LPENTRYID           lpEntryID;      /* EntryID of object */
    ULONG               ulObjType;      /* Type of object */
    ULONG               cbParentID;
    LPENTRYID           lpParentID;     /* EntryID of parent object */
    ULONG               cbOldID;
    LPENTRYID           lpOldID;        /* EntryID of old object */
    ULONG               cbOldParentID;
    LPENTRYID           lpOldParentID;  /* EntryID of old parent */
    LPSPropTagArray     lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
    ULONG               ulTableEvent;   /* Identifies WHICH table event */
    HRESULT             hResult;        /* Value for TABLE_ERROR */
    SPropValue          propIndex;      /* This row's "index property" */
    SPropValue          propPrior;      /* Preceding row's "index property" */
    SRow                row;            /* New data of added/modified row */
    ULONG               ulPad;          /* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
    ULONG       ulEvent;                    /* extended event code */
    ULONG       cb;                         /* size of event parameters */
    LPBYTE      pbEventParameters;          /* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
    ULONG           cbEntryID;
    LPENTRYID       lpEntryID;
    ULONG           cValues;
    LPSPropValue    lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
    ULONG   ulEventType;        /* notification type, i.e. fnevSomething */
    ULONG   ulAlignPad;         /* Force to 8-byte boundary */
    union
    {
        ERROR_NOTIFICATION          err;
        NEWMAIL_NOTIFICATION        newmail;
        OBJECT_NOTIFICATION         obj;
        TABLE_NOTIFICATION          tab;
        EXTENDED_NOTIFICATION       ext;
        STATUS_OBJECT_NOTIFICATION  statobj;
    } info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)                             \
    MAPIMETHOD_(ULONG, OnNotify)                                        \
        (THIS_  ULONG                       cNotif,                     \
                LPNOTIFICATION              lpNotifications) IPURE;     \

#undef       INTERFACE
#define      INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
    LPVOID          lpvContext,
    ULONG           cNotification,
    LPNOTIFICATION  lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *  Message name for the 16-bit MAPI notififcation engine.
 *  This can be used in 16-bit applications to force processing
 *  of notification callbacks.
 */

#define szMAPINotificationMsg "MAPI Notify window message"


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL      ((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)                               \
    MAPIMETHOD(Progress)                                                \
        (THIS_  ULONG                       ulValue,                    \
                ULONG                       ulCount,                    \
                ULONG                       ulTotal) IPURE;             \
    MAPIMETHOD(GetFlags)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(GetMax)                                                  \
        (THIS_  ULONG FAR *                 lpulMax) IPURE;             \
    MAPIMETHOD(GetMin)                                                  \
        (THIS_  ULONG FAR *                 lpulMin) IPURE;             \
    MAPIMETHOD(SetLimits)                                               \
        (THIS_  LPULONG                     lpulMin,                    \
                LPULONG                     lpulMax,                    \
                LPULONG                     lpulFlags) IPURE;           \

#undef      INTERFACE
#define     INTERFACE   IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION      0x00000000L

/* GetPropList */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY      ((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE     ((ULONG) 0x00000002)
#define FORCE_SAVE              ((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
#define MAPI_CREATE             ((ULONG) 0x00000002)
#define STREAM_APPEND           ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE               ((ULONG) 0x00000001)
#define MAPI_NOREPLACE          ((ULONG) 0x00000002)
#define MAPI_DECLINE_OK         ((ULONG) 0x00000004)

#ifndef MAPI_DIALOG             /* also defined in mapi.h */
#define MAPI_DIALOG             ((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT        /* also defined in mapi.h */
#define MAPI_USE_DEFAULT        0x00000040  /* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/****** MAPI_CREATE             ((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS         ((ULONG) 0x00000001)
#define MAPI_NO_IDS             ((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID                 0
#define MNID_STRING             1
typedef struct _MAPINAMEID
{
    LPGUID lpguid;
    ULONG ulKind;
    union {
        LONG lID;
        LPWSTR lpwstrName;
    } Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)                                   \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(SaveChanges)                                             \
        (THIS_ ULONG                        ulFlags) IPURE;             \
    MAPIMETHOD(GetProps)                                                \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppPropArray) IPURE;        \
    MAPIMETHOD(GetPropList)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTagArray) IPURE;     \
    MAPIMETHOD(OpenProperty)                                            \
        (THIS_  ULONG                       ulPropTag,                  \
                LPCIID                      lpiid,                      \
                ULONG                       ulInterfaceOptions,         \
                ULONG                       ulFlags,                    \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetProps)                                                \
        (THIS_  ULONG                       cValues,                    \
                LPSPropValue                lpPropArray,                \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DeleteProps)                                             \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyTo)                                                  \
        (THIS_  ULONG                       ciidExclude,                \
                LPCIID                      rgiidExclude,               \
                LPSPropTagArray             lpExcludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyProps)                                               \
        (THIS_  LPSPropTagArray             lpIncludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(GetNamesFromIDs)                                         \
        (THIS_  LPSPropTagArray FAR *       lppPropTags,                \
                LPGUID                      lpPropSetGuid,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcPropNames,               \
                LPMAPINAMEID FAR * FAR *    lpppPropNames) IPURE;       \
    MAPIMETHOD(GetIDsFromNames)                                         \
        (THIS_  ULONG                       cPropNames,                 \
                LPMAPINAMEID FAR *          lppPropNames,               \
                ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTags) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE            ((ULONG) 0)
#define TBLSTAT_QCHANGED            ((ULONG) 7)
#define TBLSTAT_SORTING             ((ULONG) 9)
#define TBLSTAT_SORT_ERROR          ((ULONG) 10)
#define TBLSTAT_SETTING_COLS        ((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR        ((ULONG) 13)
#define TBLSTAT_RESTRICTING         ((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR      ((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT            ((ULONG) 0)
#define TBLTYPE_KEYSET              ((ULONG) 1)
#define TBLTYPE_DYNAMIC             ((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND       ((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND      ((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE      ((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
    ULONG   ulPropTag;          /* Column to sort on */
    ULONG   ulOrder;            /* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
    ULONG           cSorts;     /* Number of sort columns in aSort below*/
    ULONG           cCategories;    /* 0 for non-categorized, up to cSorts */
    ULONG           cExpanded;      /* 0 if no categories start expanded, */
                                    /*      up to cExpanded */
    SSortOrder      aSort[MAPI_DIM];    /* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
    (offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
    (offsetof(SSortOrderSet,aSort) + \
    (UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
    ULONG           cSorts;         \
    ULONG           cCategories;    \
    ULONG           cExpanded;      \
    SSortOrder      aSort[_csort];  \
} _name

typedef ULONG       BOOKMARK;

#define BOOKMARK_BEGINNING  ((BOOKMARK) 0)      /* Before first row */
#define BOOKMARK_CURRENT    ((BOOKMARK) 1)      /* Before current row */
#define BOOKMARK_END        ((BOOKMARK) 2)      /* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING       ((ULONG) 0x00000000)
#define FL_SUBSTRING        ((ULONG) 0x00000001)
#define FL_PREFIX           ((ULONG) 0x00000002)

#define FL_IGNORECASE       ((ULONG) 0x00010000)
#define FL_IGNORENONSPACE   ((ULONG) 0x00020000)
#define FL_LOOSE            ((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction    FAR * LPSRestriction;

/* Restriction types */

#define RES_AND             ((ULONG) 0x00000000)
#define RES_OR              ((ULONG) 0x00000001)
#define RES_NOT             ((ULONG) 0x00000002)
#define RES_CONTENT         ((ULONG) 0x00000003)
#define RES_PROPERTY        ((ULONG) 0x00000004)
#define RES_COMPAREPROPS    ((ULONG) 0x00000005)
#define RES_BITMASK         ((ULONG) 0x00000006)
#define RES_SIZE            ((ULONG) 0x00000007)
#define RES_EXIST           ((ULONG) 0x00000008)
#define RES_SUBRESTRICTION  ((ULONG) 0x00000009)
#define RES_COMMENT         ((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT        ((ULONG) 0)     /* <  */
#define RELOP_LE        ((ULONG) 1)     /* <= */
#define RELOP_GT        ((ULONG) 2)     /* >  */
#define RELOP_GE        ((ULONG) 3)     /* >= */
#define RELOP_EQ        ((ULONG) 4)     /* == */
#define RELOP_NE        ((ULONG) 5)     /* != */
#define RELOP_RE        ((ULONG) 6)     /* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ     ((ULONG) 0)     /* ==0 */
#define BMR_NEZ     ((ULONG) 1)     /* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
    ULONG           ulReserved;
    LPSRestriction  lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
    ULONG           ulFuzzyLevel;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
    ULONG           relBMR;
    ULONG           ulPropTag;
    ULONG           ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
    ULONG           relop;
    ULONG           ulPropTag1;
    ULONG           ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    ULONG           cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
    ULONG           ulReserved1;
    ULONG           ulPropTag;
    ULONG           ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
    ULONG           ulSubObject;
    LPSRestriction  lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
    ULONG           cValues; /* # of properties in lpProp */
    LPSRestriction  lpRes;
    LPSPropValue    lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
    ULONG   rt;         /* Restriction type */
    union
    {
        SComparePropsRestriction    resCompareProps;    /* first */
        SAndRestriction             resAnd;
        SOrRestriction              resOr;
        SNotRestriction             resNot;
        SContentRestriction         resContent;
        SPropertyRestriction        resProperty;
        SBitMaskRestriction         resBitMask;
        SSizeRestriction            resSize;
        SExistRestriction           resExist;
        SSubRestriction             resSub;
        SCommentRestriction         resComment;
    } res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS     ((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW            ((ULONG) 1)
#define TBL_EMPTY_CATEGORY      ((ULONG) 2)
#define TBL_EXPANDED_CATEGORY   ((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY  ((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT          ((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC           ((ULONG) 0x00000001)
#define TBL_BATCH           ((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD        ((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE       ((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)                                  \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(GetStatus)                                               \
        (THIS_  ULONG FAR *                 lpulTableStatus,            \
                ULONG FAR *                 lpulTableType) IPURE;       \
    MAPIMETHOD(SetColumns)                                              \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QueryColumns)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lpPropTagArray) IPURE;      \
    MAPIMETHOD(GetRowCount)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulCount) IPURE;           \
    MAPIMETHOD(SeekRow)                                                 \
        (THIS_  BOOKMARK                    bkOrigin,                   \
                LONG                        lRowCount,                  \
                LONG FAR *                  lplRowsSought) IPURE;       \
    MAPIMETHOD(SeekRowApprox)                                           \
        (THIS_  ULONG                       ulNumerator,                \
                ULONG                       ulDenominator) IPURE;       \
    MAPIMETHOD(QueryPosition)                                           \
        (THIS_  ULONG FAR *                 lpulRow,                    \
                ULONG FAR *                 lpulNumerator,              \
                ULONG FAR *                 lpulDenominator) IPURE;     \
    MAPIMETHOD(FindRow)                                                 \
        (THIS_  LPSRestriction              lpRestriction,              \
                BOOKMARK                    bkOrigin,                   \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(Restrict)                                                \
        (THIS_  LPSRestriction              lpRestriction,              \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateBookmark)                                          \
        (THIS_  BOOKMARK FAR *              lpbkPosition) IPURE;        \
    MAPIMETHOD(FreeBookmark)                                            \
        (THIS_  BOOKMARK                    bkPosition) IPURE;          \
    MAPIMETHOD(SortTable)                                               \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QuerySortOrder)                                          \
        (THIS_  LPSSortOrderSet FAR *       lppSortCriteria) IPURE;     \
    MAPIMETHOD(QueryRows)                                               \
        (THIS_  LONG                        lRowCount,                  \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows) IPURE;             \
    MAPIMETHOD(Abort) (THIS) IPURE;                                     \
    MAPIMETHOD(ExpandRow)                                               \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulRowCount,                 \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows,                    \
                ULONG FAR *                 lpulMoreRows) IPURE;        \
    MAPIMETHOD(CollapseRow)                                             \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulRowCount) IPURE;        \
    MAPIMETHOD(WaitForCompletion)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulTimeout,                  \
                ULONG FAR *                 lpulTableStatus) IPURE;     \
    MAPIMETHOD(GetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbInstanceKey,              \
                LPBYTE                      lpbInstanceKey,             \
                ULONG FAR *                 lpcbCollapseState,          \
                LPBYTE FAR *                lppbCollapseState) IPURE;   \
    MAPIMETHOD(SetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbCollapseState,            \
                LPBYTE                      pbCollapseState,            \
                BOOKMARK FAR *              lpbkLocation) IPURE;        \

#undef       INTERFACE
#define      INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{   0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
    0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER     ((ULONG) 33)    /* Message Store */
#define MAPI_AB                 ((ULONG) 34)    /* Address Book */
#define MAPI_AB_PROVIDER        ((ULONG) 35)    /* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER ((ULONG) 36)    /* Transport Provider */
#define MAPI_SPOOLER            ((ULONG) 37)    /* Message Spooler */
#define MAPI_PROFILE_PROVIDER   ((ULONG) 38)    /* Profile Provider */
#define MAPI_SUBSYSTEM          ((ULONG) 39)    /* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER      ((ULONG) 40)    /* Spooler Hook */

#define STATUS_VALIDATE_STATE   ((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG  ((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD  ((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES     ((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND ((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE    ((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY ((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE     ((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST   ((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE ((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION     ((ULONG) 0x00000080)
#define STATUS_OWN_STORE        ((ULONG) 0x00000100)
/****** HOOK_INBOUND            ((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND           ((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE    ((ULONG) 0x00000800)
#define STATUS_PRIMARY_STORE    ((ULONG) 0x00001000)
#define STATUS_SECONDARY_STORE  ((ULONG) 0x00002000)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define STATUS_AVAILABLE        ((ULONG) 0x00000001)
#define STATUS_OFFLINE          ((ULONG) 0x00000002)
#define STATUS_FAILURE          ((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED  ((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE   ((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH    ((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED ((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE  ((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH   ((ULONG) 0x00400000)
#define STATUS_REMOTE_ACCESS    ((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI                 ((ULONG) 0x00000001)
#define REFRESH_XP_HEADER_CACHE     ((ULONG) 0x00010000)
#define PROCESS_XP_HEADER_CACHE     ((ULONG) 0x00020000)
#define FORCE_XP_CONNECT            ((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT         ((ULONG) 0x00080000)
#define CONFIG_CHANGED              ((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION   ((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI          ((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY     ((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD        ((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD      ((ULONG) 0x00000004)
#define FLUSH_FORCE         ((ULONG) 0x00000008)
#define FLUSH_NO_UI         ((ULONG) 0x00000010)
#define FLUSH_ASYNC_OK      ((ULONG) 0x00000020)

#define MAPI_IMAPISTATUS_METHODS(IPURE)                                 \
    MAPIMETHOD(ValidateState)                                           \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SettingsDialog)                                          \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ChangePassword)                                          \
        (THIS_  LPTSTR                      lpOldPass,                  \
                LPTSTR                      lpNewPass,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(FlushQueues)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbTargetTransport,          \
                LPENTRYID                   lpTargetTransport,          \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPISTATUS_METHODS(PURE)
};

/* IMAPIContainer Interface ------------------------------------------------ */

/* Flags for OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
#define MAPI_BEST_ACCESS        ((ULONG) 0x00000010)

/* GetContentsTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */
#define WAB_LOCAL_CONTAINERS    0x00100000
#define WAB_PROFILE_CONTENTS    0x00200000

/* GetHierarchyTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define CONVENIENT_DEPTH        ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* GetSearchCriteria */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define SEARCH_RUNNING          ((ULONG) 0x00000001)
#define SEARCH_REBUILD          ((ULONG) 0x00000002)
#define SEARCH_RECURSIVE        ((ULONG) 0x00000004)
#define SEARCH_FOREGROUND       ((ULONG) 0x00000008)

/* SetSearchCriteria */
#define STOP_SEARCH             ((ULONG) 0x00000001)
#define RESTART_SEARCH          ((ULONG) 0x00000002)
#define RECURSIVE_SEARCH        ((ULONG) 0x00000004)
#define SHALLOW_SEARCH          ((ULONG) 0x00000008)
#define FOREGROUND_SEARCH       ((ULONG) 0x00000010)
#define BACKGROUND_SEARCH       ((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE)                              \
    MAPIMETHOD(GetContentsTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(GetHierarchyTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetSearchCriteria)                                       \
        (THIS_  LPSRestriction              lpRestriction,              \
                LPENTRYLIST                 lpContainerList,            \
                ULONG                       ulSearchFlags) IPURE;       \
    MAPIMETHOD(GetSearchCriteria)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRestriction FAR *        lppRestriction,             \
                LPENTRYLIST FAR *           lppContainerList,           \
                ULONG FAR *                 lpulSearchState)IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMAPIContainer
DECLARE_MAPI_INTERFACE_(IMAPIContainer, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
};

/* IABContainer Interface -------------------------------------------------- */

/*
 *  IABContainer PR_CONTAINER_FLAGS values
 *  If AB_UNMODIFIABLE and AB_MODIFIABLE are both set, it means the container
 *  doesn't know if it's modifiable or not, and the client should
 *  try to modify the contents but we won't expect it to work.
 *  If the AB_RECIPIENTS flag is set and neither AB_MODIFIABLE or AB_UNMODIFIABLE
 *  bits are set, it is an error.
 */

typedef struct _flaglist
{
    ULONG cFlags;
    ULONG ulFlag[MAPI_DIM];
} FlagList, FAR * LPFlagList;


/*
 *  Container flags
 */
#define AB_RECIPIENTS           ((ULONG) 0x00000001)
#define AB_SUBCONTAINERS        ((ULONG) 0x00000002)
#define AB_MODIFIABLE           ((ULONG) 0x00000004)
#define AB_UNMODIFIABLE         ((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN         ((ULONG) 0x00000010)
#define AB_NOT_DEFAULT          ((ULONG) 0x00000020)

/* CreateEntry() */

#define CREATE_CHECK_DUP_STRICT ((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE  ((ULONG) 0x00000002)
#define CREATE_REPLACE          ((ULONG) 0x00000004)
#define CREATE_MERGE            ((ULONG) 0x00000008)

/* ResolveNames() - ulFlags */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define WAB_IGNORE_PROFILES     0x00800000

/* ResolveNames() - rgulFlags */
#define MAPI_UNRESOLVED         ((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS          ((ULONG) 0x00000001)
#define MAPI_RESOLVED           ((ULONG) 0x00000002)


#define MAPI_IABCONTAINER_METHODS(IPURE)                                \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABContainer
DECLARE_MAPI_INTERFACE_(IABContainer, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IABCONTAINER_METHODS(PURE)
};

/* IMailUser Interface ----------------------------------------------------- */

/*  Any call which can create a one-off entryID (i.e. MAPISupport::CreateOneOff
    or IAddrBook::CreateOneOff) can encode the value for PR_SEND_RICH_INFO by
    passing in the following flag in the ulFlags parameter.  Setting this flag
    indicates that PR_SEND_RICH_INFO will be FALSE.
*/
#define MAPI_SEND_NO_RICH_INFO      ((ULONG) 0x00010000)




/* Values of PR_NDR_DIAG_CODE */

#define MAPI_DIAG(_code)    ((LONG) _code)

#define MAPI_DIAG_NO_DIAGNOSTIC                     MAPI_DIAG( -1 )
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED              MAPI_DIAG( 0 )
#define MAPI_DIAG_OR_NAME_AMBIGUOUS                 MAPI_DIAG( 1 )
#define MAPI_DIAG_MTS_CONGESTED                     MAPI_DIAG( 2 )
#define MAPI_DIAG_LOOP_DETECTED                     MAPI_DIAG( 3 )
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE             MAPI_DIAG( 4 )
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED              MAPI_DIAG( 5 )
#define MAPI_DIAG_EITS_UNSUPPORTED                  MAPI_DIAG( 6 )
#define MAPI_DIAG_CONTENT_TOO_LONG                  MAPI_DIAG( 7 )
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT            MAPI_DIAG( 8 )
#define MAPI_DIAG_PROHIBITED_TO_CONVERT             MAPI_DIAG( 9 )
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED           MAPI_DIAG( 10 )
#define MAPI_DIAG_PARAMETERS_INVALID                MAPI_DIAG( 11 )
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR           MAPI_DIAG( 12 )
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD         MAPI_DIAG( 13 )
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD         MAPI_DIAG( 14 )
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED          MAPI_DIAG( 15 )
#define MAPI_DIAG_TOO_MANY_RECIPIENTS               MAPI_DIAG( 16 )
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT            MAPI_DIAG( 17 )
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED         MAPI_DIAG( 18 )
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB            MAPI_DIAG( 19 )
#define MAPI_DIAG_LINE_TOO_LONG                     MAPI_DIAG( 20 )
#define MAPI_DIAG_PAGE_TOO_LONG                     MAPI_DIAG( 21 )
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST             MAPI_DIAG( 22 )
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST           MAPI_DIAG( 23 )
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST         MAPI_DIAG( 24 )
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES              MAPI_DIAG( 25 )
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED           MAPI_DIAG( 26 )
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED         MAPI_DIAG( 27 )
#define MAPI_DIAG_EXPANSION_PROHIBITED              MAPI_DIAG( 28 )
#define MAPI_DIAG_SUBMISSION_PROHIBITED             MAPI_DIAG( 29 )
#define MAPI_DIAG_EXPANSION_FAILED                  MAPI_DIAG( 30 )
#define MAPI_DIAG_RENDITION_UNSUPPORTED             MAPI_DIAG( 31 )
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT            MAPI_DIAG( 32 )
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD         MAPI_DIAG( 33 )
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE           MAPI_DIAG( 34 )
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN            MAPI_DIAG( 35 )
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED           MAPI_DIAG( 36 )
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED         MAPI_DIAG( 37 )
#define MAPI_DIAG_MAIL_REFUSED                      MAPI_DIAG( 38 )
#define MAPI_DIAG_MAIL_UNCLAIMED                    MAPI_DIAG( 39 )
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED              MAPI_DIAG( 40 )
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING         MAPI_DIAG( 41 )
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED           MAPI_DIAG( 42 )
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN          MAPI_DIAG( 43 )
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED          MAPI_DIAG( 44 )
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB            MAPI_DIAG( 45 )
#define MAPI_DIAG_SECURE_MESSAGING_ERROR            MAPI_DIAG( 46 )
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE            MAPI_DIAG( 47 )


#define MAPI_IMAILUSER_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IMailUser
DECLARE_MAPI_INTERFACE_(IMailUser, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAILUSER_METHODS(PURE)
};

/* IDistList Interface ----------------------------------------------------- */

#define MAPI_IDISTLIST_METHODS(IPURE)                                   \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IDistList
DECLARE_MAPI_INTERFACE_(IDistList, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IDISTLIST_METHODS(PURE)
};

/* IMAPIFolder Interface --------------------------------------------------- */

/* IMAPIFolder folder type (enum) */

#define FOLDER_ROOT             ((ULONG) 0x00000000)
#define FOLDER_GENERIC          ((ULONG) 0x00000001)
#define FOLDER_SEARCH           ((ULONG) 0x00000002)

/* CreateMessage */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */

/* CopyMessages */

#define MESSAGE_MOVE            ((ULONG) 0x00000001)
#define MESSAGE_DIALOG          ((ULONG) 0x00000002)
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */

/* CreateFolder */

#define OPEN_IF_EXISTS          ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* DeleteFolder */

#define DEL_MESSAGES            ((ULONG) 0x00000001)
#define FOLDER_DIALOG           ((ULONG) 0x00000002)
#define DEL_FOLDERS             ((ULONG) 0x00000004)

/* EmptyFolder */
#define DEL_ASSOCIATED          ((ULONG) 0x00000008)

/* CopyFolder */

#define FOLDER_MOVE             ((ULONG) 0x00000001)
/****** FOLDER_DIALOG           ((ULONG) 0x00000002) above */
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */
#define COPY_SUBFOLDERS         ((ULONG) 0x00000010)
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */


/* SetReadFlags */

/****** SUPPRESS_RECEIPT        ((ULONG) 0x00000001) below */
/****** MESSAGE_DIALOG          ((ULONG) 0x00000002) above */
/****** CLEAR_READ_FLAG         ((ULONG) 0x00000004) below */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
#define GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010)


/* GetMessageStatus */

#define MSGSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED        ((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED     ((ULONG) 0x00000008)

/* Bits for remote message status */

#define MSGSTATUS_REMOTE_DOWNLOAD   ((ULONG) 0x00001000)
#define MSGSTATUS_REMOTE_DELETE     ((ULONG) 0x00002000)

/* SaveContentsSort */

#define RECURSIVE_SORT          ((ULONG) 0x00000002)

/* PR_STATUS property */

#define FLDSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED        ((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED     ((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE)                                 \
    MAPIMETHOD(CreateMessage)                                           \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMESSAGE FAR *             lppMessage) IPURE;          \
    MAPIMETHOD(CopyMessages)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteMessages)                                          \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateFolder)                                            \
        (THIS_  ULONG                       ulFolderType,               \
                LPTSTR                      lpszFolderName,             \
                LPTSTR                      lpszFolderComment,          \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMAPIFOLDER FAR *          lppFolder) IPURE;           \
    MAPIMETHOD(CopyFolder)                                              \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                LPTSTR                      lpszNewFolderName,          \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteFolder)                                            \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlags)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulMessageStatus) IPURE;   \
    MAPIMETHOD(SetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulNewStatus,                \
                ULONG                       ulNewStatusMask,            \
                ULONG FAR *                 lpulOldStatus) IPURE;       \
    MAPIMETHOD(SaveContentsSort)                                        \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(EmptyFolder)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIFolder
DECLARE_MAPI_INTERFACE_(IMAPIFolder, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IMAPIFOLDER_METHODS(PURE)
};

/* IMsgStore Interface ----------------------------------------------------- */

/*  PR_STORE_SUPPORT_MASK bits */
#define STORE_ENTRYID_UNIQUE    ((ULONG) 0x00000001)
#define STORE_READONLY          ((ULONG) 0x00000002)
#define STORE_SEARCH_OK         ((ULONG) 0x00000004)
#define STORE_MODIFY_OK         ((ULONG) 0x00000008)
#define STORE_CREATE_OK         ((ULONG) 0x00000010)
#define STORE_ATTACH_OK         ((ULONG) 0x00000020)
#define STORE_OLE_OK            ((ULONG) 0x00000040)
#define STORE_SUBMIT_OK         ((ULONG) 0x00000080)
#define STORE_NOTIFY_OK         ((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK       ((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK     ((ULONG) 0x00000400)
#define STORE_RTF_OK            ((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK    ((ULONG) 0x00001000)
#define STORE_SORT_OK           ((ULONG) 0x00002000)

/* PR_STORE_STATE bits, try not to collide with PR_STORE_SUPPORT_MASK */

#define STORE_HAS_SEARCHES      ((ULONG) 0x01000000)


/* OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */

/* SetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolderTable() */

/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* StoreLogoff() */

#define LOGOFF_NO_WAIT          ((ULONG) 0x00000001)
#define LOGOFF_ORDERLY          ((ULONG) 0x00000002)
#define LOGOFF_PURGE            ((ULONG) 0x00000004)
#define LOGOFF_ABORT            ((ULONG) 0x00000008)
#define LOGOFF_QUIET            ((ULONG) 0x00000010)

#define LOGOFF_COMPLETE         ((ULONG) 0x00010000)
#define LOGOFF_INBOUND          ((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND         ((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE   ((ULONG) 0x00080000)

/* SetLockState() */

#define MSG_LOCKED              ((ULONG) 0x00000001)
#define MSG_UNLOCKED            ((ULONG) 0x00000000)

/* Flag bits for PR_VALID_FOLDER_MASK */

#define FOLDER_IPM_SUBTREE_VALID        ((ULONG) 0x00000001)
#define FOLDER_IPM_INBOX_VALID          ((ULONG) 0x00000002)
#define FOLDER_IPM_OUTBOX_VALID         ((ULONG) 0x00000004)
#define FOLDER_IPM_WASTEBASKET_VALID    ((ULONG) 0x00000008)
#define FOLDER_IPM_SENTMAIL_VALID       ((ULONG) 0x00000010)
#define FOLDER_VIEWS_VALID              ((ULONG) 0x00000020)
#define FOLDER_COMMON_VIEWS_VALID       ((ULONG) 0x00000040)
#define FOLDER_FINDER_VALID             ((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE)                                   \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID,                 \
                LPTSTR FAR *                lppszExplicitClass) IPURE;  \
    MAPIMETHOD(GetReceiveFolderTable)                                   \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(StoreLogoff)                                             \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(AbortSubmit)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetOutgoingQueue)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(SetLockState)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG                       ulLockState) IPURE;         \
    MAPIMETHOD(FinishedMsg)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(NotifyNewMail)                                           \
        (THIS_  LPNOTIFICATION              lpNotification) IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMsgStore
DECLARE_MAPI_INTERFACE_(IMsgStore, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMSGSTORE_METHODS(PURE)
};

/* IMessage Interface ------------------------------------------------------ */

/* SubmitMessage */

#define FORCE_SUBMIT                ((ULONG) 0x00000001)

/* Flags defined in PR_MESSAGE_FLAGS */

#define MSGFLAG_READ            ((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED      ((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT          ((ULONG) 0x00000004)
#define MSGFLAG_UNSENT          ((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH       ((ULONG) 0x00000010)
#define MSGFLAG_FROMME          ((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED      ((ULONG) 0x00000040)
#define MSGFLAG_RESEND          ((ULONG) 0x00000080)
#define MSGFLAG_RN_PENDING		((ULONG) 0x00000100)
#define MSGFLAG_NRN_PENDING		((ULONG) 0x00000200)

/* Flags defined in PR_SUBMIT_FLAGS */

#define SUBMITFLAG_LOCKED       ((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS   ((ULONG) 0x00000002)

/* GetAttachmentTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetRecipientTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* ModifyRecipients */

/* ((ULONG) 0x00000001 is not a valid flag on ModifyRecipients. */
#define MODRECIP_ADD            ((ULONG) 0x00000002)
#define MODRECIP_MODIFY         ((ULONG) 0x00000004)
#define MODRECIP_REMOVE         ((ULONG) 0x00000008)

/* SetReadFlag */

#define SUPPRESS_RECEIPT        ((ULONG) 0x00000001)
#define CLEAR_READ_FLAG         ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010) above */
#define GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010)
#define CLEAR_RN_PENDING		((ULONG) 0x00000020)
#define CLEAR_NRN_PENDING		((ULONG) 0x00000040)

/* DeleteAttach */

#define ATTACH_DIALOG           ((ULONG) 0x00000001)

/* PR_SECURITY values */
#define SECURITY_SIGNED         ((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED      ((ULONG) 0x00000002)

/* PR_PRIORITY values */
#define PRIO_URGENT             ((long)  1)
#define PRIO_NORMAL             ((long)  0)
#define PRIO_NONURGENT          ((long) -1)

/* PR_SENSITIVITY values */
#define SENSITIVITY_NONE                    ((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL                ((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE                 ((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL    ((ULONG) 0x00000003)

/* PR_IMPORTANCE values */
#define IMPORTANCE_LOW          ((long) 0)
#define IMPORTANCE_NORMAL       ((long) 1)
#define IMPORTANCE_HIGH         ((long) 2)

#define MAPI_IMESSAGE_METHODS(IPURE)                                    \
    MAPIMETHOD(GetAttachmentTable)                                      \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenAttach)                                              \
        (THIS_  ULONG                       ulAttachmentNum,            \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(CreateAttach)                                            \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulAttachmentNum,          \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(DeleteAttach)                                            \
        (THIS_  ULONG                       ulAttachmentNum,            \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetRecipientTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(ModifyRecipients)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPADRLIST                   lpMods) IPURE;              \
    MAPIMETHOD(SubmitMessage)                                           \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlag)                                             \
        (THIS_  ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMessage
DECLARE_MAPI_INTERFACE_(IMessage, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMESSAGE_METHODS(PURE)
};

/* IAttach Interface ------------------------------------------------------- */

/* IAttach attachment methods: PR_ATTACH_METHOD values */

#define NO_ATTACHMENT           ((ULONG) 0x00000000)
#define ATTACH_BY_VALUE         ((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE     ((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE   ((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY      ((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG     ((ULONG) 0x00000005)
#define ATTACH_OLE              ((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IAttach
DECLARE_MAPI_INTERFACE_(IAttach, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IATTACH_METHODS(PURE)
};

/* --------------------------------- */
/* Address Book interface definition */

/* ADRPARM ulFlags - top 4 bits used for versioning */

#define GET_ADRPARM_VERSION(ulFlags)  (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags, ulVersion)  (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

/*  Current versions of ADRPARM  */
#define ADRPARM_HELP_CTX        ((ULONG) 0x00000000)


/*  ulFlags   - bit fields */
#define DIALOG_MODAL            ((ULONG) 0x00000001)
#define DIALOG_SDI              ((ULONG) 0x00000002)
#define DIALOG_OPTIONS          ((ULONG) 0x00000004)
#define ADDRESS_ONE             ((ULONG) 0x00000008)
#define AB_SELECTONLY           ((ULONG) 0x00000010)
#define AB_RESOLVE              ((ULONG) 0x00000020)

/* --------------------------------- */
/*  PR_DISPLAY_TYPEs                 */
/*
 *  These standard display types are
 *  by default handled by MAPI.
 *  They have default icons associated
 *  with them.
 */

/*  For address book contents tables */
#define DT_MAILUSER         ((ULONG) 0x00000000)
#define DT_DISTLIST         ((ULONG) 0x00000001)
#define DT_FORUM            ((ULONG) 0x00000002)
#define DT_AGENT            ((ULONG) 0x00000003)
#define DT_ORGANIZATION     ((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST ((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER  ((ULONG) 0x00000006)

/*  For address book hierarchy tables */
#define DT_MODIFIABLE       ((ULONG) 0x00010000)
#define DT_GLOBAL           ((ULONG) 0x00020000)
#define DT_LOCAL            ((ULONG) 0x00030000)
#define DT_WAN              ((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC     ((ULONG) 0x00050000)

/*  For folder hierarchy tables */
#define DT_FOLDER           ((ULONG) 0x01000000)
#define DT_FOLDER_LINK      ((ULONG) 0x02000000)

/*  Accelerator callback for DIALOG_SDI form of AB UI */
typedef BOOL (STDMETHODCALLTYPE ACCELERATEABSDI)(ULONG ulUIParam,
                                                LPVOID lpvmsg);
typedef ACCELERATEABSDI FAR * LPFNABSDI;

/*  Callback to application telling it that the DIALOG_SDI form of the */
/*  AB UI has been dismissed.  This is so that the above LPFNABSDI     */
/*  function doesn't keep being called.                                */
typedef void (STDMETHODCALLTYPE DISMISSMODELESS)(ULONG ulUIParam,
                                                LPVOID lpvContext);
typedef DISMISSMODELESS FAR * LPFNDISMISS;

/*
 * Prototype for the client function hooked to an optional button on
 * the address book dialog
 */

typedef SCODE (STDMETHODCALLTYPE FAR * LPFNBUTTON)(
    ULONG               ulUIParam,
    LPVOID              lpvContext,
    ULONG               cbEntryID,
    LPENTRYID           lpSelection,
    ULONG               ulFlags
);


/* Parameters for the address book dialog */
typedef struct _ADRPARM
{
    ULONG           cbABContEntryID;
    LPENTRYID       lpABContEntryID;
    ULONG           ulFlags;

    LPVOID          lpReserved;
    ULONG           ulHelpContext;
    LPTSTR          lpszHelpFileName;

    LPFNABSDI       lpfnABSDI;
    LPFNDISMISS     lpfnDismiss;
    LPVOID          lpvDismissContext;
    LPTSTR          lpszCaption;
    LPTSTR          lpszNewEntryTitle;
    LPTSTR          lpszDestWellsTitle;
    ULONG           cDestFields;
    ULONG           nDestFieldFocus;
    LPTSTR FAR *    lppszDestTitles;
    ULONG FAR *     lpulDestComps;
    LPSRestriction  lpContRestriction;
    LPSRestriction  lpHierRestriction;
} ADRPARM, FAR * LPADRPARM;


/* ------------ */
/* Random flags */

/* Flag set in MAPI one off entryids */
#define MAPI_ONE_OFF_NO_RICH_INFO	0x0001

/* Flag for deferred error */
#define MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008)

/* Flag for creating and using Folder Associated Information Messages */
#define MAPI_ASSOCIATED         ((ULONG) 0x00000040)

/* Flags for OpenMessageStore() */

#define MDB_NO_DIALOG           ((ULONG) 0x00000001)
#define MDB_WRITE               ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) above */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */
#define MDB_TEMPORARY           ((ULONG) 0x00000020)
#define MDB_NO_MAIL             ((ULONG) 0x00000080)

/* Flags for OpenAddressBook */

#define AB_NO_DIALOG            ((ULONG) 0x00000001)

/* IMAPIControl Interface -------------------------------------------------- */

/* Interface used in controls (particularly the button) defined by */
/* Display Tables. */

/*  Flags for GetState */

#define  MAPI_ENABLED       ((ULONG) 0x00000000)
#define  MAPI_DISABLED      ((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE)                                \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Activate)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulUIParam) IPURE;           \
    MAPIMETHOD(GetState)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulState) IPURE;           \

#undef       INTERFACE
#define      INTERFACE  IMAPIControl
DECLARE_MAPI_INTERFACE_(IMAPIControl, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPICONTROL_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIControl, LPMAPICONTROL);

/* Display Tables ---------------------------------------------------------- */

/* Flags used in display tables - that is, PR_CONTROL_FLAGS */

#define DT_MULTILINE        ((ULONG) 0x00000001)
#define DT_EDITABLE         ((ULONG) 0x00000002)
#define DT_REQUIRED         ((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE    ((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT    ((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS      ((ULONG) 0x00000020)
#define DT_SET_SELECTION    ((ULONG) 0x00000040)

/* Display Table structures */

#define DTCT_LABEL          ((ULONG) 0x00000000)
#define DTCT_EDIT           ((ULONG) 0x00000001)
#define DTCT_LBX            ((ULONG) 0x00000002)
#define DTCT_COMBOBOX       ((ULONG) 0x00000003)
#define DTCT_DDLBX          ((ULONG) 0x00000004)
#define DTCT_CHECKBOX       ((ULONG) 0x00000005)
#define DTCT_GROUPBOX       ((ULONG) 0x00000006)
#define DTCT_BUTTON         ((ULONG) 0x00000007)
#define DTCT_PAGE           ((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON    ((ULONG) 0x00000009)
#define DTCT_MVLISTBOX      ((ULONG) 0x0000000B)
#define DTCT_MVDDLBX        ((ULONG) 0x0000000C)

/* Labels */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLLABEL
{
    ULONG ulbLpszLabelName;
    ULONG ulFlags;
} DTBLLABEL, FAR * LPDTBLLABEL;
#define SizedDtblLabel(n,u) \
struct _DTBLLABEL_ ## u \
{ \
    DTBLLABEL   dtbllabel; \
    TCHAR       lpszLabelName[n]; \
} u


/*  Simple Text Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLEDIT
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPropTag;
} DTBLEDIT, FAR * LPDTBLEDIT;
#define SizedDtblEdit(n,u) \
struct _DTBLEDIT_ ## u \
{ \
    DTBLEDIT    dtbledit; \
    TCHAR       lpszCharsAllowed[n]; \
} u

/*  List Box  */
/* Valid ulFlags:
 */
#define MAPI_NO_HBAR        ((ULONG) 0x00000001)
#define MAPI_NO_VBAR        ((ULONG) 0x00000002)

typedef struct _DTBLLBX
{
    ULONG ulFlags;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLLBX, FAR * LPDTBLLBX;


/*  Combo Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCOMBOBOX
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPRPropertyName;
    ULONG ulPRTableName;
} DTBLCOMBOBOX, FAR * LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) \
struct _DTBLCOMBOBOX_ ## u \
{ \
    DTBLCOMBOBOX    dtblcombobox; \
    TCHAR           lpszCharsAllowed[n]; \
} u


/*  Drop Down   */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLDDLBX
{
    ULONG ulFlags;
    ULONG ulPRDisplayProperty;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLDDLBX, FAR * LPDTBLDDLBX;


/*  Check Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCHECKBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRPropertyName;
} DTBLCHECKBOX, FAR * LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) \
struct _DTBLCHECKBOX_ ## u \
{ \
    DTBLCHECKBOX    dtblcheckbox; \
    TCHAR       lpszLabel[n]; \
} u



/*  Group Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLGROUPBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
} DTBLGROUPBOX, FAR * LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) \
struct _DTBLGROUPBOX_ ## u \
{ \
    DTBLGROUPBOX    dtblgroupbox; \
    TCHAR           lpszLabel[n]; \
} u

/*  Button control   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRControl;
} DTBLBUTTON, FAR * LPDTBLBUTTON;
#define SizedDtblButton(n,u) \
struct _DTBLBUTTON_ ## u \
{ \
    DTBLBUTTON  dtblbutton; \
    TCHAR       lpszLabel[n]; \
} u

/*  Pages   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLPAGE
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulbLpszComponent;
    ULONG ulContext;
} DTBLPAGE, FAR * LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) \
struct _DTBLPAGE_ ## u \
{ \
    DTBLPAGE    dtblpage; \
    TCHAR       lpszLabel[n]; \
    TCHAR       lpszComponent[n1]; \
} u

/*  Radio button   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLRADIOBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulcButtons;
    ULONG ulPropTag;
    long lReturnValue;
} DTBLRADIOBUTTON, FAR * LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) \
struct _DTBLRADIOBUTTON_ ## u \
{ \
    DTBLRADIOBUTTON dtblradiobutton; \
    TCHAR           lpszLabel[n]; \
} u


/*  MultiValued listbox */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVLISTBOX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVLISTBOX, FAR * LPDTBLMVLISTBOX;


/*  MultiValued dropdown */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVDDLBX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVDDLBX, FAR * LPDTBLMVDDLBX;





/* IProviderAdmin Interface ---------------------------------------------- */

/* Flags for ConfigureMsgService */

#define UI_SERVICE                  0x00000002
#define SERVICE_UI_ALWAYS           0x00000002      /* Duplicate UI_SERVICE for consistency and compatibility */
#define SERVICE_UI_ALLOWED          0x00000010
#define UI_CURRENT_PROVIDER_FIRST   0x00000004
/* MSG_SERVICE_UI_READ_ONLY         0x00000008 - in MAPISPI.H */

/* GetProviderTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define MAPI_IPROVIDERADMIN_METHODS(IPURE)                              \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetProviderTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateProvider)                                          \
        (THIS_  LPTSTR                      lpszProvider,               \
                ULONG                       cValues,                    \
                LPSPropValue                lpProps,                    \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                MAPIUID FAR *               lpUID) IPURE;               \
    MAPIMETHOD(DeleteProvider)                                          \
        (THIS_  LPMAPIUID                   lpUID) IPURE;               \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \


#undef       INTERFACE
#define      INTERFACE  IProviderAdmin
DECLARE_MAPI_INTERFACE_(IProviderAdmin, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IPROVIDERADMIN_METHODS(PURE)
};

#ifndef WIN16

typedef HANDLE  HANDLE_16;
typedef WPARAM  WPARAM_16;

#define EXTERN_C_16
#define WINAPI_16
#define CALLBACK_16
#define EXPORT_16
#define LOADDS_16
#define HUGEP_16
#define APIENTRY_16    APIENTRY

#else   // ndef WIN16

typedef LPVOID HANDLE_16;
typedef DWORD  WPARAM_16;

#define EXTERN_C_16    EXTERN_C
#define WINAPI_16      WINAPI
#define CALLBACK_16    CALLBACK
#define EXPORT_16      __export
#define LOADDS_16      __loadds
#define HUGEP_16       HUGEP
#define APIENTRY_16    CALLBACK

#endif  // ndef WIN16

#ifndef WIN16

#define IF_WIN16(x)
#define IF_NOT_WIN16(x)     x
#define IF_WIN32(x)         x

#else   // ndef WIN16

#define IF_WIN16(x)         x
#define IF_NOT_WIN16(x) 
#define IF_WIN32(x)

#endif  // ndef WIN16

#ifdef  __cplusplus
}       /*  extern "C" */
#endif

#endif /* WABDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\wabutil.h ===
/*
 *	WABUTIL.H
 *
 *  Definitions and prototypes for utility functions provided by MAPI
 *  in MAPI[xx].DLL.
 *
 *  Copyright 1986-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(_MAPIUTIL_H) && !defined(_WABUTIL_H)
#define _WABUTIL_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/* IMAPITable in memory */

/* ITableData Interface ---------------------------------------------------- */

DECLARE_MAPI_INTERFACE_PTR(ITableData, LPTABLEDATA);

typedef void (STDAPICALLTYPE CALLERRELEASE)(
	ULONG		ulCallerData,
	LPTABLEDATA	lpTblData,
	LPMAPITABLE	lpVue
);

#define MAPI_ITABLEDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrGetView)												\
		(THIS_	LPSSortOrderSet				lpSSortOrderSet,			\
				CALLERRELEASE FAR *			lpfCallerRelease,			\
				ULONG						ulCallerData,				\
				LPMAPITABLE FAR *			lppMAPITable) IPURE;		\
	MAPIMETHOD(HrModifyRow)												\
		(THIS_	LPSRow) IPURE;											\
	MAPIMETHOD(HrDeleteRow)												\
		(THIS_	LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrQueryRow)												\
		(THIS_	LPSPropValue				lpsPropValue,				\
				LPSRow FAR *				lppSRow,					\
				ULONG FAR *					lpuliRow) IPURE;			\
	MAPIMETHOD(HrEnumRow)												\
		(THIS_	ULONG						ulRowNumber,				\
				LPSRow FAR *				lppSRow) IPURE;				\
	MAPIMETHOD(HrNotify)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cValues,					\
				LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrInsertRow)												\
		(THIS_	ULONG						uliRow,						\
				LPSRow						lpSRow) IPURE;				\
	MAPIMETHOD(HrModifyRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSRowSet) IPURE;			\
	MAPIMETHOD(HrDeleteRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lprowsetToDelete,			\
				ULONG FAR *					cRowsDeleted) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE	ITableData
DECLARE_MAPI_INTERFACE_(ITableData, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_ITABLEDATA_METHODS(PURE)
};


/* Entry Point for in memory ITable */


/*	CreateTable()
 *		Creates the internal memory structures and object handle
 *		to bring a new table into existence.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPITableData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lpvReserved
 *		Reserved.  Should be NULL.
 *	ulTableType
 *		TBLTYPE_DYNAMIC, etc.  Visible to the calling application
 *		as part of the GetStatus return data on its views
 *	ulPropTagIndexColumn
 *		Index column for use when changing the data
 *	lpSPropTagArrayColumns
 *		Column proptags for the minimum set of columns in the table
 *	lppTableData
 *		Address of the pointer which will receive the TableData object
 */

STDAPI_(SCODE)
CreateTable( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 ULONG					ulTableType,
			 ULONG					ulPropTagIndexColumn,
			 LPSPropTagArray		lpSPropTagArrayColumns,
			 LPTABLEDATA FAR *		lppTableData );


/*	HrGetView()
 *		This function obtains a new view on the underlying data
 *		which supports the IMAPITable interface.  All rows and columns
 *		of the underlying table data are initially visible
 *	lpSSortOrderSet
 *		if specified, results in the view being sorted
 *	lpfCallerRelease
 *		pointer to a routine to be called when the view is released, or
 *		NULL.
 *	ulCallerData
 *		arbitrary data the caller wants saved with this view and returned in
 *		the Release callback.
 */

/*	HrModifyRows()
 *		Add or modify a set of rows in the table data
 *	ulFlags
 *		Must be zero
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrModifyRow()
 *		Add or modify one row in the table
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrDeleteRows()
 *		Delete a row in the table.
 *	ulFlags
 *		TAD_ALL_ROWS - Causes all rows in the table to be deleted
 *					   lpSRowSet is ignored in this case.
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		deleted.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */
#define	TAD_ALL_ROWS	1

/*	HrDeleteRow()
 *		Delete a row in the table.
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 */

/*	HrQueryRow()
 *		Returns the values of a specified row in the table
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 *	lppSRow
 *		Address of where to return a pointer to an SRow
 *	lpuliRow
 *	  Address of where to return the row number. This can be NULL
 *	  if the row number is not required.
 *
 */

/*	HrEnumRow()
 *		Returns the values of a specific (numbered) row in the table
 *	ulRowNumber
 *		Indicates row number 0 to n-1
 *	lppSRow
 *		Address of where to return a pointer to a SRow
 */

/*	HrInsertRow()
 *		Inserts a row into the table.
 *	uliRow
 *		The row number before which this row will be inserted into the table.
 *		Row numbers can be from 0 to n where o to n-1 result in row insertion
 *	  a row number of n results in the row being appended to the table.
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */


/* IMAPIProp in memory */

/* IPropData Interface ---------------------------------------------------- */


#define MAPI_IPROPDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrSetObjAccess)											\
		(THIS_	ULONG						ulAccess) IPURE;			\
	MAPIMETHOD(HrSetPropAccess)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG FAR *					rgulAccess) IPURE;			\
	MAPIMETHOD(HrGetPropAccess)											\
		(THIS_	LPSPropTagArray FAR *		lppPropTagArray,			\
				ULONG FAR * FAR *			lprgulAccess) IPURE;		\
	MAPIMETHOD(HrAddObjProps)											\
		(THIS_	LPSPropTagArray				lppPropTagArray,			\
				LPSPropProblemArray FAR *	lprgulAccess) IPURE;


#undef		 INTERFACE
#define		 INTERFACE	IPropData
DECLARE_MAPI_INTERFACE_(IPropData, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IPROPDATA_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPropData, LPPROPDATA);


/* Entry Point for in memory IMAPIProp */


/*	CreateIProp()
 *		Creates the internal memory structures and object handle
 *		to bring a new property interface into existance.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPIPropData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lppPropData
 *		Address of the pointer which will receive the IPropData object
 *	lpvReserved
 *		Reserved.  Should be NULL.
 */

// If MAPI isn't included, use WABCreateIProp instead
#ifndef CreateIProp
STDAPI_(SCODE)
CreateIProp( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 LPPROPDATA FAR *		lppPropData );
#endif

STDAPI_(SCODE)
WABCreateIProp( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 LPPROPDATA FAR *		lppPropData );

/*
 *	Defines for prop/obj access
 */
#define IPROP_READONLY		((ULONG) 0x00000001)
#define IPROP_READWRITE		((ULONG) 0x00000002)
#define IPROP_CLEAN			((ULONG) 0x00010000)
#define IPROP_DIRTY			((ULONG) 0x00020000)

/*
 -	HrSetPropAccess
 -
 *	Sets access right attributes on a per-property basis.  By default,
 *	all properties are read/write.
 *
 */

/*
 -	HrSetObjAccess
 -
 *	Sets access rights for the object itself.  By default, the object has
 *	read/write access.
 *
 */

#ifndef NOIDLEENGINE

/* Idle time scheduler */

/*
 *	PRI
 *
 *	Priority of an idle task.
 *	The idle engine sorts tasks by priority, and the one with the higher
 *	value runs first. Within a priority level, the functions are called
 *	round-robin.
 */

#define PRILOWEST	-32768
#define PRIHIGHEST	32767
#define PRIUSER		0

/*
 *	IRO
 *
 *	Idle routine options.  This is a combined bit mask consisting of
 *	individual firo's.	Listed below are the possible bit flags.
 *
 *		FIROWAIT and FIROINTERVAL are mutually exclusive.
 *		If neither of the flags are specified, the default action
 *		is to ignore the time parameter of the idle function and
 *		call it as often as possible if firoPerBlock is not set;
 *		otherwise call it one time only during the idle block
 *		once the time constraint has been set. FIROINTERVAL
 *		is also incompatible with FIROPERBLOCK.
 *
 *		FIROWAIT		- time given is minimum idle time before calling
 *						  for the first time in the block of idle time,
 *						  afterwhich call as often as possible.
 *		FIROINTERVAL	- time given is minimum interval between each
 *						  successive call
 *		FIROPERBLOCK	- called only once per contiguous block of idle
 *						  time
 *		FIRODISABLED	- initially disabled when registered, the
 *						  default is to enable the function when registered.
 *		FIROONCEONLY	- called only one time by the scheduler and then
 *						  deregistered automatically.
 */

#define IRONULL			((USHORT) 0x0000)
#define FIROWAIT		((USHORT) 0x0001)
#define FIROINTERVAL	((USHORT) 0x0002)
#define FIROPERBLOCK	((USHORT) 0x0004)
#define FIRODISABLED	((USHORT) 0x0020)
#define FIROONCEONLY	((USHORT) 0x0040)

/*
 *	IRC
 *
 *	Idle routine change options. This is a combined bit mask consisting
 *	of individual firc's; each one identifies an aspect of the idle task
 *	that can be changed.
 *
 */

#define IRCNULL			((USHORT) 0x0000)
#define FIRCPFN			((USHORT) 0x0001)	/* change function pointer */
#define FIRCPV			((USHORT) 0x0002)	/* change parameter block  */
#define FIRCPRI			((USHORT) 0x0004)	/* change priority		   */
#define FIRCCSEC		((USHORT) 0x0008)	/* change time			   */
#define FIRCIRO			((USHORT) 0x0010)	/* change routine options  */

/*
 *	Type definition for idle functions.	 An idle function takes one
 *	parameter, an PV, and returns a BOOL value.
 */

typedef BOOL (STDAPICALLTYPE FNIDLE) (LPVOID);
typedef FNIDLE FAR *PFNIDLE;

/*
 *	FTG
 *
 *	Function Tag.  Used to identify a registered idle function.
 *
 */

typedef void FAR *FTG;
typedef FTG  FAR *PFTG;
#define FTGNULL			((FTG) NULL)

/*
 -	MAPIInitIdle/MAPIDeinitIdle
 -
 *	Purpose:
 *		Initialises the idle engine
 *		If the initialisation succeded, returns 0, else returns -1
 *
 *	Arguments:
 *		lpvReserved		Reserved, must be NULL.
 */

STDAPI_(LONG)
MAPIInitIdle (LPVOID lpvReserved);

STDAPI_(VOID)
MAPIDeinitIdle (VOID);


/*
 *	FtgRegisterIdleRoutine
 *
 *		Registers the function pfn of type PFNIDLE, i.e., (BOOL (*)(LPVOID))
 *		as an idle function.
 *
 *		The idle function will be called with the parameter pv by the
 *		idle engine. The function has initial priority priIdle,
 *		associated time csecIdle, and options iroIdle.
 */

STDAPI_(FTG)
FtgRegisterIdleRoutine (PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle);

/*
 *	DeregisterIdleRoutine
 *
 *		Removes the given routine from the list of idle routines.
 *		The routine will not be called again.  It is the responsibility
 *		of the caller to clean up any data structures pointed to by the
 *		pvIdleParam parameter; this routine does not free the block.
 */

STDAPI_(void)
DeregisterIdleRoutine (FTG ftg);

/*
 *	EnableIdleRoutine
 *
 *		Enables or disables an idle routine.
 */

STDAPI_(void)
EnableIdleRoutine (FTG ftg, BOOL fEnable);

/*
 *	ChangeIdleRoutine
 *
 *		Changes some or all of the characteristics of the given idle
 *		function. The changes to make are indicated with flags in the
 *		ircIdle parameter.
 */

STDAPI_(void)
ChangeIdleRoutine (FTG ftg, PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle, USHORT ircIdle);


#endif	/* ! NOIDLEENGINE */


/* IMalloc Utilities */

STDAPI_(LPMALLOC) MAPIGetDefaultMalloc(VOID);


/* StreamOnFile (SOF) */

/*
 *	Methods and #define's for implementing an OLE 2.0 storage stream
 *	(as defined in the OLE 2.0 specs) on top of a system file.
 */

#define SOF_UNIQUEFILENAME	((ULONG) 0x80000000)

STDMETHODIMP OpenStreamOnFile(
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	LPTSTR				lpszFileName,
	LPTSTR				lpszPrefix,
	LPSTREAM FAR *		lppStream);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENSTREAMONFILE) (
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	LPTSTR				lpszFileName,
	LPTSTR				lpszPrefix,
	LPSTREAM FAR *		lppStream);

#ifdef	_WIN32
#define OPENSTREAMONFILE "OpenStreamOnFile"
#endif
#ifdef	WIN16
#define OPENSTREAMONFILE "_OPENSTREAMONFILE"
#endif


/* Property interface utilities */

/*
 *	Copies a single SPropValue from Src to Dest.  Handles all the various
 *	types of properties and will link its allocations given the master
 *	allocation object and an allocate more function.
 */
STDAPI_(SCODE)
PropCopyMore( LPSPropValue		lpSPropValueDest,
			  LPSPropValue		lpSPropValueSrc,
			  ALLOCATEMORE *	lpfAllocMore,
			  LPVOID			lpvObject );

/*
 *	Returns the size in bytes of structure at lpSPropValue, including the
 *	Value.
 */
STDAPI_(ULONG)
UlPropSize(	LPSPropValue	lpSPropValue );


STDAPI_(BOOL)
FEqualNames( LPMAPINAMEID lpName1, LPMAPINAMEID lpName2 );

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

STDAPI_(void)
GetInstance(LPSPropValue lpPropMv, LPSPropValue lpPropSv, ULONG uliInst);

extern unsigned char rgchCsds[];
extern unsigned char rgchCids[];
extern unsigned char rgchCsdi[];
extern unsigned char rgchCidi[];

STDAPI_(BOOL)
FPropContainsProp( LPSPropValue	lpSPropValueDst,
				   LPSPropValue	lpSPropValueSrc,
				   ULONG		ulFuzzyLevel );

STDAPI_(BOOL)
FPropCompareProp( LPSPropValue	lpSPropValue1,
				  ULONG			ulRelOp,
				  LPSPropValue	lpSPropValue2 );

STDAPI_(LONG)
LPropCompareProp( LPSPropValue	lpSPropValueA,
				  LPSPropValue	lpSPropValueB );

STDAPI_(HRESULT)
HrAddColumns(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer);

STDAPI_(HRESULT)
HrAddColumnsEx(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer,
				void				(FAR *lpfnFilterColumns)(LPSPropTagArray ptaga));


/* Notification utilities */

/*
 *	Function that creates an advise sink object given a notification
 *	callback function and context.
 */

STDAPI
HrAllocAdviseSink( LPNOTIFCALLBACK lpfnCallback,
				   LPVOID lpvContext,
				   LPMAPIADVISESINK FAR *lppAdviseSink );


/*
 *	Wraps an existing advise sink with another one which guarantees
 *	that the original advise sink will be called in the thread on
 *	which it was created.
 */

STDAPI
HrThisThreadAdviseSink( LPMAPIADVISESINK lpAdviseSink,
						LPMAPIADVISESINK FAR *lppAdviseSink);



/*
 *	Allows a client and/or provider to force notifications
 *	which are currently queued in the MAPI notification engine
 *	to be dispatched without doing a message dispatch.
 */

STDAPI HrDispatchNotifications (ULONG ulFlags);


/* Service Provider Utilities */

/*
 *	Structures and utility function for building a display table
 *	from resources.
 */

typedef struct {
	ULONG			ulCtlType;			/* DTCT_LABEL, etc. */
	ULONG			ulCtlFlags;			/* DT_REQUIRED, etc. */
	LPBYTE			lpbNotif;			/*	pointer to notification data */
	ULONG			cbNotif;			/* count of bytes of notification data */
	LPTSTR			lpszFilter;			/* character filter for edit/combobox */
	ULONG			ulItemID;			/* to validate parallel dlg template entry */
	union {								/* ulCtlType discriminates */
		LPVOID			lpv;			/* Initialize this to avoid warnings */
		LPDTBLLABEL		lplabel;
		LPDTBLEDIT		lpedit;
		LPDTBLLBX		lplbx;
		LPDTBLCOMBOBOX	lpcombobox;
		LPDTBLDDLBX		lpddlbx;
		LPDTBLCHECKBOX	lpcheckbox;
		LPDTBLGROUPBOX	lpgroupbox;
		LPDTBLBUTTON	lpbutton;
		LPDTBLRADIOBUTTON lpradiobutton;
		LPDTBLMVLISTBOX	lpmvlbx;
		LPDTBLMVDDLBX	lpmvddlbx;
		LPDTBLPAGE		lppage;
	} ctl;
} DTCTL, FAR *LPDTCTL;

typedef struct {
	ULONG			cctl;
	LPTSTR			lpszResourceName;	/* as usual, may be an integer ID */
	union {								/* as usual, may be an integer ID */
		LPTSTR			lpszComponent;
		ULONG			ulItemID;
	};
	LPDTCTL			lpctl;
} DTPAGE, FAR *LPDTPAGE;



STDAPI
BuildDisplayTable(	LPALLOCATEBUFFER	lpAllocateBuffer,
					LPALLOCATEMORE		lpAllocateMore,
					LPFREEBUFFER		lpFreeBuffer,
					LPMALLOC			lpMalloc,
					HINSTANCE			hInstance,
					UINT				cPages,
					LPDTPAGE			lpPage,
					ULONG				ulFlags,
					LPMAPITABLE *		lppTable,
					LPTABLEDATA	*		lppTblData );


/* MAPI structure validation/copy utilities */

/*
 *	Validate, copy, and adjust pointers in MAPI structures:
 *		notification
 *		property value array
 *		option data
 */

STDAPI_(SCODE)
ScCountNotifications(int cNotifications, LPNOTIFICATION lpNotifications,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);


STDAPI_(SCODE)
ScCountProps(int cValues, LPSPropValue lpPropArray, ULONG FAR *lpcb);

STDAPI_(LPSPropValue)
LpValFindProp(ULONG ulPropTag, ULONG cValues, LPSPropValue lpPropArray);

STDAPI_(SCODE)
ScCopyProps(int cValues, LPSPropValue lpPropArray, LPVOID lpvDst,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocProps(int cValues, LPSPropValue lpPropArray,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScDupPropset(int cValues, LPSPropValue lpPropArray,
		LPALLOCATEBUFFER lpAllocateBuffer, LPSPropValue FAR *lppPropArray);


/* General utility functions */

/* Related to the OLE Component object model */

STDAPI_(ULONG)			UlAddRef(LPVOID lpunk);
STDAPI_(ULONG)			UlRelease(LPVOID lpunk);

/* Related to the MAPI interface */

STDAPI					HrGetOneProp(LPMAPIPROP lpMapiProp, ULONG ulPropTag,
						LPSPropValue FAR *lppProp);
STDAPI					HrSetOneProp(LPMAPIPROP lpMapiProp,
						LPSPropValue lpProp);
STDAPI_(BOOL)			FPropExists(LPMAPIPROP lpMapiProp, ULONG ulPropTag);
STDAPI_(LPSPropValue)	PpropFindProp(LPSPropValue lpPropArray, ULONG cValues,
						ULONG ulPropTag);
STDAPI_(void)			FreePadrlist(LPADRLIST lpAdrlist);
STDAPI_(void)			FreeProws(LPSRowSet lpRows);
STDAPI					HrQueryAllRows(LPMAPITABLE lpTable,
						LPSPropTagArray lpPropTags,
						LPSRestriction lpRestriction,
						LPSSortOrderSet lpSortOrderSet,
						LONG crowsMax,
						LPSRowSet FAR *lppRows);




/* C runtime substitutes */


STDAPI_(LPTSTR)			SzFindCh(LPCTSTR lpsz, USHORT ch);		/* strchr */
STDAPI_(LPTSTR)			SzFindLastCh(LPCTSTR lpsz, USHORT ch);	/* strrchr */
STDAPI_(LPTSTR)			SzFindSz(LPCTSTR lpsz, LPCTSTR lpszKey); /*strstr */
STDAPI_(unsigned int)	UFromSz(LPCTSTR lpsz);					/* atoi */

STDAPI_(SCODE)			ScUNCFromLocalPath(LPSTR lpszLocal, LPSTR lpszUNC,
						UINT cchUNC);
STDAPI_(SCODE)			ScLocalPathFromUNC(LPSTR lpszUNC, LPSTR lpszLocal,
						UINT cchLocal);

/* 64-bit arithmetic with times */

STDAPI_(FILETIME)		FtAddFt(FILETIME ftAddend1, FILETIME ftAddend2);
STDAPI_(FILETIME)		FtMulDwDw(DWORD ftMultiplicand, DWORD ftMultiplier);
STDAPI_(FILETIME)		FtMulDw(DWORD ftMultiplier, FILETIME ftMultiplicand);
STDAPI_(FILETIME)		FtSubFt(FILETIME ftMinuend, FILETIME ftSubtrahend);
STDAPI_(FILETIME)		FtNegFt(FILETIME ft);

/* Message composition */

STDAPI_(SCODE)			ScCreateConversationIndex (ULONG cbParent,
							LPBYTE lpbParent,
							ULONG FAR *	lpcbConvIndex,
							LPBYTE FAR * lppbConvIndex);

/* Store support */

STDAPI WrapStoreEntryID (ULONG ulFlags, LPTSTR lpszDLLName, ULONG cbOrigEntry,
	LPENTRYID lpOrigEntry, ULONG *lpcbWrappedEntry, LPENTRYID *lppWrappedEntry);

/* RTF Sync Utilities */

#define RTF_SYNC_RTF_CHANGED	((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED	((ULONG) 0x00000002)

STDAPI_(HRESULT)
RTFSync (LPMESSAGE lpMessage, ULONG ulFlags, BOOL FAR * lpfMessageUpdated);


/* Flags for WrapCompressedRTFStream() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) mapidefs.h */
/****** STORE_UNCOMPRESSED_RTF	((ULONG) 0x00008000) mapidefs.h */

STDAPI_(HRESULT)
WrapCompressedRTFStream (LPSTREAM lpCompressedRTFStream,
		ULONG ulFlags, LPSTREAM FAR * lpUncompressedRTFStream);

/* Storage on Stream */

#if defined(_WIN32) || defined(WIN16)
STDAPI_(HRESULT)
HrIStorageFromStream (LPUNKNOWN lpUnkIn,
	LPCIID lpInterface, ULONG ulFlags, LPSTORAGE FAR * lppStorageOut);
#endif


/*
 * Setup and cleanup.
 *
 * Providers never need to make these calls.
 *
 * Test applications and the like which do not call MAPIInitialize
 * may want to call them, so that the few utility functions which
 * need MAPI allocators (and do not ask for them explicitly)
 * will work.
 */

/* All flags are reserved for ScInitMapiUtil. */

STDAPI_(SCODE)			ScInitMapiUtil(ULONG ulFlags);
STDAPI_(VOID)			DeinitMapiUtil(VOID);


/*
 *	Entry point names.
 *	
 *	These are for new entry points defined since MAPI first shipped
 *	in Windows 95. Using these names in a GetProcAddress call makes
 *	it easier to write code which uses them optionally.
 */

#if defined (WIN16)
#define szHrDispatchNotifications "HrDispatchNotifications"
#elif defined (_WIN32) && defined (_X86_)
#define szHrDispatchNotifications "_HrDispatchNotifications@4"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_)
#define szHrDispatchNotifications "HrDispatchNotifications"
#endif

typedef HRESULT (STDAPICALLTYPE DISPATCHNOTIFICATIONS)(ULONG ulFlags);
typedef DISPATCHNOTIFICATIONS FAR * LPDISPATCHNOTIFICATIONS;

#if defined (WIN16)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#elif defined (_WIN32) && defined (_X86_)
#define szScCreateConversationIndex "_ScCreateConversationIndex@16"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#endif

typedef SCODE (STDAPICALLTYPE CREATECONVERSATIONINDEX)(ULONG cbParent,
	LPBYTE lpbParent, ULONG FAR *lpcbConvIndex, LPBYTE FAR *lppbConvIndex);
typedef CREATECONVERSATIONINDEX FAR *LPCREATECONVERSATIONINDEX;

#ifdef __cplusplus
}
#endif

#endif /* _WABUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\wabtags.h ===
/*
 *  WABTAGS.H
 *
 *  Property tag definitions for standard properties of WAB
 *  objects.
 *
 *  The following ranges should be used for all property IDs. Note that
 *  property IDs for objects other than messages and recipients should
 *  all fall in the range 0x3000 to 0x3FFF:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  0001    0BFF    MAPI_defined envelope property
 *  0C00    0DFF    MAPI_defined per-recipient property
 *  0E00    0FFF    MAPI_defined non-transmittable property
 *  1000    2FFF    MAPI_defined message content property
 *
 *  3000    3FFF    MAPI_defined property (usually not message or recipient)
 *
 *  4000    57FF    Transport-defined envelope property
 *  5800    5FFF    Transport-defined per-recipient property
 *  6000    65FF    User-defined non-transmittable property
 *  6600    67FF    Provider-defined internal non-transmittable property
 *  6800    7BFF    Message class-defined content property
 *  7C00    7FFF    Message class-defined non-transmittable
 *                  property
 *
 *  8000    FFFE    User-defined Name-to-id mapped property
 *
 *  The 3000-3FFF range is further subdivided as follows:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    33FF    Common property such as display name, entry ID
 *  3400    35FF    Message store object
 *  3600    36FF    Folder or AB container
 *  3700    38FF    Attachment
 *  3900    39FF    Address book object
 *  3A00    3BFF    Mail user
 *  3C00    3CFF    Distribution list
 *  3D00    3DFF    Profile section
 *  3E00    3FFF    Status object
 *
 *  Copyright 1993-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPITAGS_H) && !defined(WABTAGS_H)
#define WABTAGS_H

/* Determine if a property is transmittable. */

#define FIsTransmittable(ulPropTag) \
    ((PROP_ID (ulPropTag) <  (ULONG)0x0E00) || \
    (PROP_ID (ulPropTag)  >= (ULONG)0x8000) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x1000) && (PROP_ID (ulPropTag) < (ULONG)0x6000)) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x6800) && (PROP_ID (ulPropTag) < (ULONG)0x7C00)))


/*
 * The range of non-message and non-recipient property IDs (0x3000 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    32FF    MAPI_defined common property
 *  3200    33FF    MAPI_defined form property
 *  3400    35FF    MAPI_defined message store property
 *  3600    36FF    MAPI_defined Folder or AB Container property
 *  3700    38FF    MAPI_defined attachment property
 *  3900    39FF    MAPI_defined address book property
 *  3A00    3BFF    MAPI_defined mailuser property
 *  3C00    3CFF    MAPI_defined DistList property
 *  3D00    3DFF    MAPI_defined Profile Section property
 *  3E00    3EFF    MAPI_defined Status property
 *  3F00    3FFF    MAPI_defined display table property
 */

/*
 *  Properties common to numerous MAPI objects.
 *
 *  Those properties that can appear on messages are in the
 *  non-transmittable range for messages. They start at the high
 *  end of that range and work down.
 *
 *  Properties that never appear on messages are defined in the common
 *  property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 * -- these ids are in the non-transmittable range
 */

#define PR_ENTRYID                                  PROP_TAG( PT_BINARY,    0x0FFF)
#define PR_OBJECT_TYPE                              PROP_TAG( PT_LONG,      0x0FFE)
#define PR_ICON                                     PROP_TAG( PT_BINARY,    0x0FFD)
#define PR_MINI_ICON                                PROP_TAG( PT_BINARY,    0x0FFC)
#define PR_STORE_ENTRYID                            PROP_TAG( PT_BINARY,    0x0FFB)
#define PR_STORE_RECORD_KEY                         PROP_TAG( PT_BINARY,    0x0FFA)
#define PR_RECORD_KEY                               PROP_TAG( PT_BINARY,    0x0FF9)
#define PR_MAPPING_SIGNATURE                        PROP_TAG( PT_BINARY,    0x0FF8)
#define PR_ACCESS_LEVEL                             PROP_TAG( PT_LONG,      0x0FF7)
#define PR_INSTANCE_KEY                             PROP_TAG( PT_BINARY,    0x0FF6)
#define PR_ROW_TYPE                                 PROP_TAG( PT_LONG,      0x0FF5)
#define PR_ACCESS                                   PROP_TAG( PT_LONG,      0x0FF4)

/*
 * properties that are common to multiple objects (usually not including message objects)
 * -- these ids are in the transmittable range
 */

#define PR_ROWID                                    PROP_TAG( PT_LONG,      0x3000)
#define PR_DISPLAY_NAME                             PROP_TAG( PT_TSTRING,   0x3001)
#define PR_DISPLAY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3001)
#define PR_DISPLAY_NAME_A                           PROP_TAG( PT_STRING8,   0x3001)
#define PR_ADDRTYPE                                 PROP_TAG( PT_TSTRING,   0x3002)
#define PR_ADDRTYPE_W                               PROP_TAG( PT_UNICODE,   0x3002)
#define PR_ADDRTYPE_A                               PROP_TAG( PT_STRING8,   0x3002)
#define PR_EMAIL_ADDRESS                            PROP_TAG( PT_TSTRING,   0x3003)
#define PR_EMAIL_ADDRESS_W                          PROP_TAG( PT_UNICODE,   0x3003)
#define PR_EMAIL_ADDRESS_A                          PROP_TAG( PT_STRING8,   0x3003)
#define PR_COMMENT                                  PROP_TAG( PT_TSTRING,   0x3004)
#define PR_COMMENT_W                                PROP_TAG( PT_UNICODE,   0x3004)
#define PR_COMMENT_A                                PROP_TAG( PT_STRING8,   0x3004)
#define PR_DEPTH                                    PROP_TAG( PT_LONG,      0x3005)
#define PR_PROVIDER_DISPLAY                         PROP_TAG( PT_TSTRING,   0x3006)
#define PR_PROVIDER_DISPLAY_W                       PROP_TAG( PT_UNICODE,   0x3006)
#define PR_PROVIDER_DISPLAY_A                       PROP_TAG( PT_STRING8,   0x3006)
#define PR_CREATION_TIME                            PROP_TAG( PT_SYSTIME,   0x3007)
#define PR_LAST_MODIFICATION_TIME                   PROP_TAG( PT_SYSTIME,   0x3008)
#define PR_RESOURCE_FLAGS                           PROP_TAG( PT_LONG,      0x3009)
#define PR_PROVIDER_DLL_NAME                        PROP_TAG( PT_TSTRING,   0x300A)
#define PR_PROVIDER_DLL_NAME_W                      PROP_TAG( PT_UNICODE,   0x300A)
#define PR_PROVIDER_DLL_NAME_A                      PROP_TAG( PT_STRING8,   0x300A)
#define PR_SEARCH_KEY                               PROP_TAG( PT_BINARY,    0x300B)
#define PR_PROVIDER_UID                             PROP_TAG( PT_BINARY,    0x300C)
#define PR_PROVIDER_ORDINAL                         PROP_TAG( PT_LONG,      0x300D)


/* Proptags 35E8-35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *  Folder and AB Container properties
 */

#define PR_CONTAINER_FLAGS                          PROP_TAG( PT_LONG,      0x3600)
#define PR_FOLDER_TYPE                              PROP_TAG( PT_LONG,      0x3601)
#define PR_CONTENT_COUNT                            PROP_TAG( PT_LONG,      0x3602)
#define PR_CONTENT_UNREAD                           PROP_TAG( PT_LONG,      0x3603)
#define PR_CREATE_TEMPLATES                         PROP_TAG( PT_OBJECT,    0x3604)
#define PR_DETAILS_TABLE                            PROP_TAG( PT_OBJECT,    0x3605)
#define PR_SEARCH                                   PROP_TAG( PT_OBJECT,    0x3607)
#define PR_SELECTABLE                               PROP_TAG( PT_BOOLEAN,   0x3609)
#define PR_SUBFOLDERS                               PROP_TAG( PT_BOOLEAN,   0x360a)
#define PR_STATUS                                   PROP_TAG( PT_LONG,      0x360b)
#define PR_ANR                                      PROP_TAG( PT_TSTRING,   0x360c)
#define PR_ANR_W                                    PROP_TAG( PT_UNICODE,   0x360c)
#define PR_ANR_A                                    PROP_TAG( PT_STRING8,   0x360c)
#define PR_CONTENTS_SORT_ORDER                      PROP_TAG( PT_MV_LONG,   0x360d)
#define PR_CONTAINER_HIERARCHY                      PROP_TAG( PT_OBJECT,    0x360e)
#define PR_CONTAINER_CONTENTS                       PROP_TAG( PT_OBJECT,    0x360f)
#define PR_FOLDER_ASSOCIATED_CONTENTS               PROP_TAG( PT_OBJECT,    0x3610)
#define PR_DEF_CREATE_DL                            PROP_TAG( PT_BINARY,    0x3611)
#define PR_DEF_CREATE_MAILUSER                      PROP_TAG( PT_BINARY,    0x3612)
#define PR_CONTAINER_CLASS                          PROP_TAG( PT_TSTRING,   0x3613)
#define PR_CONTAINER_CLASS_W                        PROP_TAG( PT_UNICODE,   0x3613)
#define PR_CONTAINER_CLASS_A                        PROP_TAG( PT_STRING8,   0x3613)
#define PR_CONTAINER_MODIFY_VERSION                 PROP_TAG( PT_I8,        0x3614)
#define PR_AB_PROVIDER_ID                           PROP_TAG( PT_BINARY,    0x3615)
#define PR_DEFAULT_VIEW_ENTRYID                     PROP_TAG( PT_BINARY,    0x3616)
#define PR_ASSOC_CONTENT_COUNT                      PROP_TAG( PT_LONG,      0x3617)
/* Don't use 36FE and 36FF */


/*
 *  AB Object properties
 */

#define PR_DISPLAY_TYPE                             PROP_TAG( PT_LONG,      0x3900)
#define PR_TEMPLATEID                               PROP_TAG( PT_BINARY,    0x3902)
#define PR_PRIMARY_CAPABILITY                       PROP_TAG( PT_BINARY,    0x3904)
#define PR_7BIT_DISPLAY_NAME                        PROP_TAG( PT_STRING8,   0x39FF)

/*
 *  Mail user properties
 */

#define PR_ACCOUNT                                  PROP_TAG( PT_TSTRING,   0x3A00)
#define PR_ACCOUNT_W                                PROP_TAG( PT_UNICODE,   0x3A00)
#define PR_ACCOUNT_A                                PROP_TAG( PT_STRING8,   0x3A00)
#define PR_ALTERNATE_RECIPIENT                      PROP_TAG( PT_BINARY,    0x3A01)
#define PR_CALLBACK_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A02)
#define PR_CONVERSION_PROHIBITED                    PROP_TAG( PT_BOOLEAN,   0x3A03)
#define PR_DISCLOSE_RECIPIENTS                      PROP_TAG( PT_BOOLEAN,   0x3A04)
#define PR_GENERATION                               PROP_TAG( PT_TSTRING,   0x3A05)
#define PR_GENERATION_W                             PROP_TAG( PT_UNICODE,   0x3A05)
#define PR_GENERATION_A                             PROP_TAG( PT_STRING8,   0x3A05)
#define PR_GIVEN_NAME                               PROP_TAG( PT_TSTRING,   0x3A06)
#define PR_GIVEN_NAME_W                             PROP_TAG( PT_UNICODE,   0x3A06)
#define PR_GIVEN_NAME_A                             PROP_TAG( PT_STRING8,   0x3A06)
#define PR_GOVERNMENT_ID_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A07)
#define PR_BUSINESS_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A08)
#define PR_OFFICE_TELEPHONE_NUMBER                  PR_BUSINESS_TELEPHONE_NUMBER
#define PR_OFFICE_TELEPHONE_NUMBER_W                PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OFFICE_TELEPHONE_NUMBER_A                PR_BUSINESS_TELEPHONE_NUMBER_A
#define PR_HOME_TELEPHONE_NUMBER                    PROP_TAG( PT_TSTRING,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_W                  PROP_TAG( PT_UNICODE,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_A                  PROP_TAG( PT_STRING8,   0x3A09)
#define PR_INITIALS                                 PROP_TAG( PT_TSTRING,   0x3A0A)
#define PR_INITIALS_W                               PROP_TAG( PT_UNICODE,   0x3A0A)
#define PR_INITIALS_A                               PROP_TAG( PT_STRING8,   0x3A0A)
#define PR_KEYWORD                                  PROP_TAG( PT_TSTRING,   0x3A0B)
#define PR_KEYWORD_W                                PROP_TAG( PT_UNICODE,   0x3A0B)
#define PR_KEYWORD_A                                PROP_TAG( PT_STRING8,   0x3A0B)
#define PR_LANGUAGE                                 PROP_TAG( PT_TSTRING,   0x3A0C)
#define PR_LANGUAGE_W                               PROP_TAG( PT_UNICODE,   0x3A0C)
#define PR_LANGUAGE_A                               PROP_TAG( PT_STRING8,   0x3A0C)
#define PR_LOCATION                                 PROP_TAG( PT_TSTRING,   0x3A0D)
#define PR_LOCATION_W                               PROP_TAG( PT_UNICODE,   0x3A0D)
#define PR_LOCATION_A                               PROP_TAG( PT_STRING8,   0x3A0D)
#define PR_MAIL_PERMISSION                          PROP_TAG( PT_BOOLEAN,   0x3A0E)
#define PR_MHS_COMMON_NAME                          PROP_TAG( PT_TSTRING,   0x3A0F)
#define PR_MHS_COMMON_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A0F)
#define PR_MHS_COMMON_NAME_A                        PROP_TAG( PT_STRING8,   0x3A0F)
#define PR_ORGANIZATIONAL_ID_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A10)
#define PR_SURNAME                                  PROP_TAG( PT_TSTRING,   0x3A11)
#define PR_SURNAME_W                                PROP_TAG( PT_UNICODE,   0x3A11)
#define PR_SURNAME_A                                PROP_TAG( PT_STRING8,   0x3A11)
#define PR_ORIGINAL_ENTRYID                         PROP_TAG( PT_BINARY,    0x3A12)
#define PR_ORIGINAL_DISPLAY_NAME                    PROP_TAG( PT_TSTRING,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_W                  PROP_TAG( PT_UNICODE,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_A                  PROP_TAG( PT_STRING8,   0x3A13)
#define PR_ORIGINAL_SEARCH_KEY                      PROP_TAG( PT_BINARY,    0x3A14)
#define PR_POSTAL_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A15)
#define PR_POSTAL_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A15)
#define PR_POSTAL_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A15)
#define PR_COMPANY_NAME                             PROP_TAG( PT_TSTRING,   0x3A16)
#define PR_COMPANY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3A16)
#define PR_COMPANY_NAME_A                           PROP_TAG( PT_STRING8,   0x3A16)
#define PR_TITLE                                    PROP_TAG( PT_TSTRING,   0x3A17)
#define PR_TITLE_W                                  PROP_TAG( PT_UNICODE,   0x3A17)
#define PR_TITLE_A                                  PROP_TAG( PT_STRING8,   0x3A17)
#define PR_DEPARTMENT_NAME                          PROP_TAG( PT_TSTRING,   0x3A18)
#define PR_DEPARTMENT_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A18)
#define PR_DEPARTMENT_NAME_A                        PROP_TAG( PT_STRING8,   0x3A18)
#define PR_OFFICE_LOCATION                          PROP_TAG( PT_TSTRING,   0x3A19)
#define PR_OFFICE_LOCATION_W                        PROP_TAG( PT_UNICODE,   0x3A19)
#define PR_OFFICE_LOCATION_A                        PROP_TAG( PT_STRING8,   0x3A19)
#define PR_PRIMARY_TELEPHONE_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A1A)
#define PR_BUSINESS2_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A1B)
#define PR_OFFICE2_TELEPHONE_NUMBER                 PR_BUSINESS2_TELEPHONE_NUMBER
#define PR_OFFICE2_TELEPHONE_NUMBER_W               PR_BUSINESS2_TELEPHONE_NUMBER_W
#define PR_OFFICE2_TELEPHONE_NUMBER_A               PR_BUSINESS2_TELEPHONE_NUMBER_A
#define PR_MOBILE_TELEPHONE_NUMBER                  PROP_TAG( PT_TSTRING,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_W                PROP_TAG( PT_UNICODE,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_A                PROP_TAG( PT_STRING8,   0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER                PR_MOBILE_TELEPHONE_NUMBER
#define PR_CELLULAR_TELEPHONE_NUMBER_W              PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_CELLULAR_TELEPHONE_NUMBER_A              PR_MOBILE_TELEPHONE_NUMBER_A
#define PR_RADIO_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1D)
#define PR_CAR_TELEPHONE_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A1E)
#define PR_OTHER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1F)
#define PR_TRANSMITABLE_DISPLAY_NAME                PROP_TAG( PT_TSTRING,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_W              PROP_TAG( PT_UNICODE,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_A              PROP_TAG( PT_STRING8,   0x3A20)
#define PR_PAGER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A21)
#define PR_BEEPER_TELEPHONE_NUMBER                  PR_PAGER_TELEPHONE_NUMBER
#define PR_BEEPER_TELEPHONE_NUMBER_W                PR_PAGER_TELEPHONE_NUMBER_W
#define PR_BEEPER_TELEPHONE_NUMBER_A                PR_PAGER_TELEPHONE_NUMBER_A
#define PR_USER_CERTIFICATE                         PROP_TAG( PT_BINARY,    0x3A22)
#define PR_PRIMARY_FAX_NUMBER                       PROP_TAG( PT_TSTRING,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_W                     PROP_TAG( PT_UNICODE,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_A                     PROP_TAG( PT_STRING8,   0x3A23)
#define PR_BUSINESS_FAX_NUMBER                      PROP_TAG( PT_TSTRING,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_W                    PROP_TAG( PT_UNICODE,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_A                    PROP_TAG( PT_STRING8,   0x3A24)
#define PR_HOME_FAX_NUMBER                          PROP_TAG( PT_TSTRING,   0x3A25)
#define PR_HOME_FAX_NUMBER_W                        PROP_TAG( PT_UNICODE,   0x3A25)
#define PR_HOME_FAX_NUMBER_A                        PROP_TAG( PT_STRING8,   0x3A25)
#define PR_COUNTRY                                  PROP_TAG( PT_TSTRING,   0x3A26)
#define PR_COUNTRY_W                                PROP_TAG( PT_UNICODE,   0x3A26)
#define PR_COUNTRY_A                                PROP_TAG( PT_STRING8,   0x3A26)
#define PR_LOCALITY                                 PROP_TAG( PT_TSTRING,   0x3A27)
#define PR_LOCALITY_W                               PROP_TAG( PT_UNICODE,   0x3A27)
#define PR_LOCALITY_A                               PROP_TAG( PT_STRING8,   0x3A27)
#define PR_STATE_OR_PROVINCE                        PROP_TAG( PT_TSTRING,   0x3A28)
#define PR_STATE_OR_PROVINCE_W                      PROP_TAG( PT_UNICODE,   0x3A28)
#define PR_STATE_OR_PROVINCE_A                      PROP_TAG( PT_STRING8,   0x3A28)
#define PR_STREET_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A29)
#define PR_STREET_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A29)
#define PR_STREET_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A29)
#define PR_POSTAL_CODE                              PROP_TAG( PT_TSTRING,   0x3A2A)
#define PR_POSTAL_CODE_W                            PROP_TAG( PT_UNICODE,   0x3A2A)
#define PR_POSTAL_CODE_A                            PROP_TAG( PT_STRING8,   0x3A2A)
#define PR_POST_OFFICE_BOX                          PROP_TAG( PT_TSTRING,   0x3A2B)
#define PR_POST_OFFICE_BOX_W                        PROP_TAG( PT_UNICODE,   0x3A2B)
#define PR_POST_OFFICE_BOX_A                        PROP_TAG( PT_STRING8,   0x3A2B)
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX         PR_POST_OFFICE_BOX
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_W       PR_POST_OFFICE_BOX_W
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_A       PR_POST_OFFICE_BOX_A
#define PR_TELEX_NUMBER                             PROP_TAG( PT_TSTRING,   0x3A2C)
#define PR_TELEX_NUMBER_W                           PROP_TAG( PT_UNICODE,   0x3A2C)
#define PR_TELEX_NUMBER_A                           PROP_TAG( PT_STRING8,   0x3A2C)
#define PR_ISDN_NUMBER                              PROP_TAG( PT_TSTRING,   0x3A2D)
#define PR_ISDN_NUMBER_W                            PROP_TAG( PT_UNICODE,   0x3A2D)
#define PR_ISDN_NUMBER_A                            PROP_TAG( PT_STRING8,   0x3A2D)
#define PR_ASSISTANT_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A2E)
#define PR_HOME2_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A2F)
#define PR_ASSISTANT                                PROP_TAG( PT_TSTRING,   0x3A30)
#define PR_ASSISTANT_W                              PROP_TAG( PT_UNICODE,   0x3A30)
#define PR_ASSISTANT_A                              PROP_TAG( PT_STRING8,   0x3A30)
#define PR_SEND_RICH_INFO                           PROP_TAG( PT_BOOLEAN,   0x3A40)
#define PR_WEDDING_ANNIVERSARY                      PROP_TAG( PT_SYSTIME,   0x3A41)
#define PR_BIRTHDAY                                 PROP_TAG( PT_SYSTIME,   0x3A42)
#define PR_HOBBIES                                  PROP_TAG( PT_TSTRING,   0x3A43)
#define PR_HOBBIES_W                                PROP_TAG( PT_UNICODE,   0x3A43)
#define PR_HOBBIES_A                                PROP_TAG( PT_STRING8,   0x3A43)
#define PR_MIDDLE_NAME                              PROP_TAG( PT_TSTRING,   0x3A44)
#define PR_MIDDLE_NAME_W                            PROP_TAG( PT_UNICODE,   0x3A44)
#define PR_MIDDLE_NAME_A                            PROP_TAG( PT_STRING8,   0x3A44)
#define PR_DISPLAY_NAME_PREFIX                      PROP_TAG( PT_TSTRING,   0x3A45)
#define PR_DISPLAY_NAME_PREFIX_W                    PROP_TAG( PT_UNICODE,   0x3A45)
#define PR_DISPLAY_NAME_PREFIX_A                    PROP_TAG( PT_STRING8,   0x3A45)
#define PR_PROFESSION                               PROP_TAG( PT_TSTRING,   0x3A46)
#define PR_PROFESSION_W                             PROP_TAG( PT_UNICODE,   0x3A46)
#define PR_PROFESSION_A                             PROP_TAG( PT_STRING8,   0x3A46)
#define PR_PREFERRED_BY_NAME                        PROP_TAG( PT_TSTRING,   0x3A47)
#define PR_PREFERRED_BY_NAME_W                      PROP_TAG( PT_UNICODE,   0x3A47)
#define PR_PREFERRED_BY_NAME_A                      PROP_TAG( PT_STRING8,   0x3A47)
#define PR_SPOUSE_NAME                              PROP_TAG( PT_TSTRING,   0x3A48)
#define PR_SPOUSE_NAME_W                            PROP_TAG( PT_UNICODE,   0x3A48)
#define PR_SPOUSE_NAME_A                            PROP_TAG( PT_STRING8,   0x3A48)
#define PR_COMPUTER_NETWORK_NAME                    PROP_TAG( PT_TSTRING,   0x3A49)
#define PR_COMPUTER_NETWORK_NAME_W                  PROP_TAG( PT_UNICODE,   0x3A49)
#define PR_COMPUTER_NETWORK_NAME_A                  PROP_TAG( PT_STRING8,   0x3A49)
#define PR_CUSTOMER_ID                              PROP_TAG( PT_TSTRING,   0x3A4A)
#define PR_CUSTOMER_ID_W                            PROP_TAG( PT_UNICODE,   0x3A4A)
#define PR_CUSTOMER_ID_A                            PROP_TAG( PT_STRING8,   0x3A4A)
#define PR_TTYTDD_PHONE_NUMBER                      PROP_TAG( PT_TSTRING,   0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_W                    PROP_TAG( PT_UNICODE,   0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_A                    PROP_TAG( PT_STRING8,   0x3A4B)
#define PR_FTP_SITE                                 PROP_TAG( PT_TSTRING,   0x3A4C)
#define PR_FTP_SITE_W                               PROP_TAG( PT_UNICODE,   0x3A4C)
#define PR_FTP_SITE_A                               PROP_TAG( PT_STRING8,   0x3A4C)
#define PR_GENDER                                   PROP_TAG( PT_SHORT,     0x3A4D)
#define PR_MANAGER_NAME                             PROP_TAG( PT_TSTRING,   0x3A4E)
#define PR_MANAGER_NAME_W                           PROP_TAG( PT_UNICODE,   0x3A4E)
#define PR_MANAGER_NAME_A                           PROP_TAG( PT_STRING8,   0x3A4E)
#define PR_NICKNAME                                 PROP_TAG( PT_TSTRING,   0x3A4F)
#define PR_NICKNAME_W                               PROP_TAG( PT_UNICODE,   0x3A4F)
#define PR_NICKNAME_A                               PROP_TAG( PT_STRING8,   0x3A4F)
#define PR_PERSONAL_HOME_PAGE                       PROP_TAG( PT_TSTRING,   0x3A50)
#define PR_PERSONAL_HOME_PAGE_W                     PROP_TAG( PT_UNICODE,   0x3A50)
#define PR_PERSONAL_HOME_PAGE_A                     PROP_TAG( PT_STRING8,   0x3A50)
#define PR_BUSINESS_HOME_PAGE                       PROP_TAG( PT_TSTRING,   0x3A51)
#define PR_BUSINESS_HOME_PAGE_W                     PROP_TAG( PT_UNICODE,   0x3A51)
#define PR_BUSINESS_HOME_PAGE_A                     PROP_TAG( PT_STRING8,   0x3A51)
#define PR_CONTACT_VERSION                          PROP_TAG( PT_CLSID,     0x3A52)
#define PR_CONTACT_ENTRYIDS                         PROP_TAG( PT_MV_BINARY, 0x3A53)
#define PR_CONTACT_ADDRTYPES                        PROP_TAG( PT_MV_TSTRING, 0x3A54)
#define PR_CONTACT_ADDRTYPES_W                      PROP_TAG( PT_MV_UNICODE, 0x3A54)
#define PR_CONTACT_ADDRTYPES_A                      PROP_TAG( PT_MV_STRING8, 0x3A54)
#define PR_CONTACT_DEFAULT_ADDRESS_INDEX            PROP_TAG( PT_LONG,      0x3A55)
#define PR_CONTACT_EMAIL_ADDRESSES                  PROP_TAG( PT_MV_TSTRING, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_W                PROP_TAG( PT_MV_UNICODE, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_A                PROP_TAG( PT_MV_STRING8, 0x3A56)
#define PR_COMPANY_MAIN_PHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A57)
#define PR_CHILDRENS_NAMES                          PROP_TAG( PT_MV_TSTRING, 0x3A58)
#define PR_CHILDRENS_NAMES_W                        PROP_TAG( PT_MV_UNICODE, 0x3A58)
#define PR_CHILDRENS_NAMES_A                        PROP_TAG( PT_MV_STRING8, 0x3A58)
#define PR_HOME_ADDRESS_CITY                        PROP_TAG( PT_TSTRING,   0x3A59)
#define PR_HOME_ADDRESS_CITY_W                      PROP_TAG( PT_UNICODE,   0x3A59)
#define PR_HOME_ADDRESS_CITY_A                      PROP_TAG( PT_STRING8,   0x3A59)
#define PR_HOME_ADDRESS_COUNTRY                     PROP_TAG( PT_TSTRING,   0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_W                   PROP_TAG( PT_UNICODE,   0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_A                   PROP_TAG( PT_STRING8,   0x3A5A)
#define PR_HOME_ADDRESS_POSTAL_CODE                 PROP_TAG( PT_TSTRING,   0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_W               PROP_TAG( PT_UNICODE,   0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_A               PROP_TAG( PT_STRING8,   0x3A5B)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE           PROP_TAG( PT_TSTRING,   0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_W         PROP_TAG( PT_UNICODE,   0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_A         PROP_TAG( PT_STRING8,   0x3A5C)
#define PR_HOME_ADDRESS_STREET                      PROP_TAG( PT_TSTRING,   0x3A5D)
#define PR_HOME_ADDRESS_STREET_W                    PROP_TAG( PT_UNICODE,   0x3A5D)
#define PR_HOME_ADDRESS_STREET_A                    PROP_TAG( PT_STRING8,   0x3A5D)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX             PROP_TAG( PT_TSTRING,   0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_W           PROP_TAG( PT_UNICODE,   0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_A           PROP_TAG( PT_STRING8,   0x3A5E)
#define PR_OTHER_ADDRESS_CITY                       PROP_TAG( PT_TSTRING,   0x3A5F)
#define PR_OTHER_ADDRESS_CITY_W                     PROP_TAG( PT_UNICODE,   0x3A5F)
#define PR_OTHER_ADDRESS_CITY_A                     PROP_TAG( PT_STRING8,   0x3A5F)
#define PR_OTHER_ADDRESS_COUNTRY                    PROP_TAG( PT_TSTRING,   0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_W                  PROP_TAG( PT_UNICODE,   0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_A                  PROP_TAG( PT_STRING8,   0x3A60)
#define PR_OTHER_ADDRESS_POSTAL_CODE                PROP_TAG( PT_TSTRING,   0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_W              PROP_TAG( PT_UNICODE,   0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_A              PROP_TAG( PT_STRING8,   0x3A61)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE          PROP_TAG( PT_TSTRING,   0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_W        PROP_TAG( PT_UNICODE,   0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_A        PROP_TAG( PT_STRING8,   0x3A62)
#define PR_OTHER_ADDRESS_STREET                     PROP_TAG( PT_TSTRING,   0x3A63)
#define PR_OTHER_ADDRESS_STREET_W                   PROP_TAG( PT_UNICODE,   0x3A63)
#define PR_OTHER_ADDRESS_STREET_A                   PROP_TAG( PT_STRING8,   0x3A63)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX            PROP_TAG( PT_TSTRING,   0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_W          PROP_TAG( PT_UNICODE,   0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_A          PROP_TAG( PT_STRING8,   0x3A64)
#define PR_USER_X509_CERTIFICATE                    PROP_TAG( PT_MV_BINARY, 0x3A70)
#define PR_SEND_INTERNET_ENCODING                   PROP_TAG( PT_LONG,      0x3A71)



#define PR_BUSINESS_ADDRESS_CITY                    PR_LOCALITY
#define PR_BUSINESS_ADDRESS_COUNTRY                 PR_COUNTRY
#define PR_BUSINESS_ADDRESS_POSTAL_CODE             PR_POSTAL_CODE
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE       PR_STATE_OR_PROVINCE
#define PR_BUSINESS_ADDRESS_STREET                  PR_STREET_ADDRESS


/*
 *	Message recipient properties
 */

#define PR_RECIPIENT_TYPE                           PROP_TAG( PT_LONG,      0x0C15)

/*
 * Secure property id range
 */

#define PROP_ID_SECURE_MIN                          0x67F0
#define PROP_ID_SECURE_MAX                          0x67FF


/* These are the bits that show up in PR_SEND_INTERNET_ENCODING */

/* whether or not an encoding preference is specified
 1 - pay attention to the rest of the bits for the encoding preferences
 0 - let the mail system choose what's best for it
*/
#define ENCODING_PREFERENCE                     ((ULONG) 0x00020000)

/*
 1 - message in MIME;
 0 - plain text/uuencode attachments
*/
#define ENCODING_TEXT                           ((ULONG) 0x00000000)
#define ENCODING_MIME                           ((ULONG) 0x00040000)


/* Specifies how the body of the message is encoded.
 00 - Body encoded as text
 01 - body encoded as HTML (only valid if message in MIME)
 10 - (actualy 1X) Text and HTML as multipart alternative (only valid if message in MIME)
*/
#define BODY_ENCODING_MASK                      ((ULONG) 0x00180000)
#define BODY_ENCODING_TEXT                      ((ULONG) 0x00000000) /* for completeness */
#define BODY_ENCODING_HTML                      ((ULONG) 0x00080000)
#define BODY_ENCODING_TEXT_AND_HTML             ((ULONG) 0x00100000)

/* Specifies how to handle Mac attachments
 00 - BinHex
 01 - UUENCODED (not valid if message in MIME - will be ignored, BinHex used instead)
 10 - Apple Single (only valid if message in MIME)
 11 - Apple Double (only valid if message in MIME)
*/
#define MAC_ATTACH_ENCODING_MASK                ((ULONG) 0x00600000)
#define MAC_ATTACH_ENCODING_BINHEX              ((ULONG) 0x00000000)
#define MAC_ATTACH_ENCODING_UUENCODE            ((ULONG) 0x00200000)
#define MAC_ATTACH_ENCODING_APPLESINGLE         ((ULONG) 0x00400000)
#define MAC_ATTACH_ENCODING_APPLEDOUBLE         ((ULONG) 0x00600000)


// Values for PR_GENDER property
enum Gender {
	genderUnspecified = 0,
	genderFemale,
	genderMale
};

#endif  /* WABTAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\xmldsodid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDSODID_H__
#define __XMLDSODID_H__
//;end_internal

#define DISPID_XOBJ_MIN                 0x00010000
#define DISPID_XOBJ_MAX                 0x0001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN

#define  DISPID_XMLDSO                       DISPID_XOBJ_BASE
#define  DISPID_XMLDSO_DOCUMENT              DISPID_XMLDSO  +  1
#define  DISPID_XMLDSO_JAVADSOCOMPATIBLE     DISPID_XMLDSO_DOCUMENT  +  1

//;begin_internal
#endif // __XMLDSODID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\uuid\ieguids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       guids.c
//
//  Contents:   ActiveX releated guids
//
//  Classes:
//
//  Functions:
//
//  History:    6-12-96   JohannP (Johann Posch)   Created
//                        Combined serveral files with guids into this file
//                        and removed duplicated definitions
//
//----------------------------------------------------------------------------

#define INITGUID
#include <guiddef.h>

DEFINE_GUID( CLSID_StdURLMoniker,           0x79eac9e0,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_StdURLProtocol,          0x79eac9e1,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_HttpProtocol,            0x79eac9e2,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_FtpProtocol,             0x79eac9e3,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_GopherProtocol,          0x79eac9e4,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_HttpSProtocol,           0x79eac9e5,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_MkProtocol,              0x79eac9e6,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_FileProtocol,            0x79eac9e7,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_PSUrlMonProxy,           0x79eac9f1,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_UrlMkBindCtx,            0x79eac9f2,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_ResProtocol,             0x3050f3bc,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( CLSID_AboutProtocol,           0x3050f406,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( IID_IAsyncMoniker,             0x79eac9d3,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IBindStatusCallbackHolder, 0x79eac9cc,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IAsyncBindCtx,             0x79eac9d4,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IBindStatusCallbackMsg,    0x79eac9d5,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);

// debug and trace interface ids
DEFINE_GUID( IID_IDebugRegister,            0xc733e4f0,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_IDebugOut,                 0xc733e4f1,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

//
// clsid for the Notification/Scheduler Module
//
DEFINE_GUID( CLSID_StdNotificationMgr,      0xc733e4af,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_WebCheckDefaultProcess,  0xc733e4b0,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

DEFINE_GUID( IID_IEnumPropertyMap,          0xc733e4a1,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_IPropertyMap,              0xc733e4a2,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotification,             0xc733e4a3,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationMgr,          0xc733e4a4,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationSink,         0xc733e4a5,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_IScheduleGroup,            0xc733e4a6,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationReport,       0xc733e4a7,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_IEnumNotification,         0xc733e4a8,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_IEnumScheduleGroup,        0xc733e4a9,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
// private interfaces
DEFINE_GUID( IID_IEnumNotificationSinkItem, 0xc733e4aa,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationHelper,       0xc733e4ab,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationPing,         0xc733e4ac,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationRunning,      0xc733e4ad,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( IID_INotificationProcessMgr0,  0xc733e4ae,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

//
// old guids; will be removed
//
DEFINE_GUID( IID_IOInet,                    0x79eac9e0,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetBindInfo,            0x79eac9e1,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetBindClient,          0x79eac9e2,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetProtocolRoot,        0x79eac9e3,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetProtocol,            0x79eac9e4,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetProtocolSink,        0x79eac9e5,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetSession,             0x79eac967,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetThreadSwitch,        0x79eac968,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetCache,               0x79eac9ea,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetPriority,            0x79eac9eb,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( IID_IOInetProtocolInfo,        0x79eac9ec,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);

// broadcasting a notification
DEFINE_GUID( CLSID_GLOBAL_BROADCAST,        0xd34f1810,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_PROCESS_BROADCAST,       0xd34f1811,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_THREAD_BROADCAST,        0xd34f1812,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_1,                       0xd34f1813,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_2,                       0xd34f1814,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_3,                       0xd34f1815,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_4,                       0xd34f1816,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_5,                       0xd34f1817,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_6,                       0xd34f1818,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_7,                       0xd34f1819,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_8,                       0xd34f181a,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_9,                       0xd34f181b,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_a,                       0xd34f181c,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_b,                       0xd34f181d,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_c,                       0xd34f181e,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_d,                       0xd34f181f,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

//
// notificationstyps used by the notification mgr
//
DEFINE_GUID( NOTIFICATIONTYPE_ITEM_START,   0xd34f1880,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_ITEM_RESTART, 0xd34f1881,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_ITEM_DONE,    0xd34f1882,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_GROUP_START,  0xd34f1883,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_GROUP_RESTART,0xd34f1884,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_GROUP_DONE,   0xd34f1885,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_i6,           0xd34f1886,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_i7,           0xd34f1887,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_i8,           0xd34f1888,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_i9,           0xd34f1889,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iA,           0xd34f188A,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iB,           0xd34f188B,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iC,           0xd34f188C,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iD,           0xd34f188D,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iE,           0xd34f188E,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_iF,           0xd34f188F,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

//
// predefined scheduled groups
//
DEFINE_GUID( NOTFCOOKIE_SCHEDULE_GROUP_DAILY,   0xd34f18b0,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY,  0xd34f18b1,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTFCOOKIE_SCHEDULE_GROUP_MONTHLY, 0xd34f18b2,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTFCOOKIE_SCHEDULE_GROUP_MANUAL,  0xd34f18b3,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);


// NotificationTypes used and reserved
DEFINE_GUID( NOTIFICATIONTYPE_NULL,            0xd34f17e0,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_ANOUNCMENT,      0xd34f17e1,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASK,            0xd34f17e2,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_ALERT,           0xd34f17e3,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_INET_IDLE,       0xd34f17e4,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_INET_OFFLINE,    0xd34f17e5,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_INET_ONLINE,     0xd34f17e6,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_SUSPEND,   0xd34f17e7,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_RESUME,    0xd34f17e8,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_ABORT,     0xd34f17e9,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_COMPLETED, 0xd34f17ea,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_PROGRESS,  0xd34f17eb,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_AGENT_START,     0xd34f17ec,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_BEGIN_REPORT,    0xd34f17ee,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_END_REPORT,      0xd34f17ef,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_AGENT_INIT,      0x1e4a7390,0xc70b,0x11d0,0x95,0xf8,0x00,0xa0,0xc9,0x03,0x48,0xec);
DEFINE_GUID( NOTIFICATIONTYPE_CONNECT_TO_INTERNET,      0xd34f17f0,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_DISCONNECT_FROM_INTERNET, 0xd34f17f1,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_CONFIG_CHANGED,  0xd34f17f2,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_PROGRESS_REPORT, 0xd34f17f3,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_USER_IDLE_BEGIN, 0xd34f17f4,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_USER_IDLE_END,   0xd34f17f5,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_STARTED,   0xd34f17f6,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_TASKS_ERROR,  0xd34f17f7,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_d,            0xd34f17f8,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_e,            0xd34f17f9,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_f,            0xd34f17fa,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_11,           0xd34f17fb,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_12,           0xd34f17fc,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_13,           0xd34f17fd,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_14,           0xd34f17fe,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_15,           0xd34f17ff,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

DEFINE_GUID( NOTIFICATIONTYPE_START_0,      0xd34f1800,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_1,      0xd34f1801,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_2,      0xd34f1802,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_3,      0xd34f1803,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_4,      0xd34f1804,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_5,      0xd34f1805,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_6,      0xd34f1806,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_7,      0xd34f1807,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_8,      0xd34f1808,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_9,      0xd34f1809,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_A,      0xd34f180a,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_B,      0xd34f180b,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_C,      0xd34f180c,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_D,      0xd34f180d,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_E,      0xd34f180e,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( NOTIFICATIONTYPE_START_F,      0xd34f180f,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

// clsid for testing
DEFINE_GUID( CLSID_NotificaitonTest1,       0xc733e501,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_NotificaitonTest2,       0xc733e502,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_NotificaitonTest3,       0xc733e503,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);
DEFINE_GUID( CLSID_NotificaitonTest4,       0xc733e504,0x576e,0x11d0,0xb2,0x8c,0x00,0xc0,0x4f,0xd7,0xcd,0x22);

//
// end cls ids for notification/scheduler module
//

//
// clsid for the EAPP Module
//

DEFINE_GUID( CLSID_StdEncodingFilterFac,    0x54c37cd0,0xd944,0x11d0,0xa9,0xf4,0x00,0x60,0x97,0x94,0x23,0x11);

DEFINE_GUID( CLSID_DeCompMimeFilter,        0x8f6b0360,0xb80d,0x11d0,0xa9,0xb3,0x00,0x60,0x97,0x94,0x23,0x11);

DEFINE_GUID( CLSID_CdlProtocol,             0x3dd53d40,0x7b8b,0x11d0,0xb0,0x13,0x00,0xaa,0x00,0x59,0xce,0x02);

DEFINE_GUID( CLSID_ClassInstallFilter,      0x32b533bb,0xedae,0x11d0,0xbd,0x5a,0x00,0xaa,0x00,0xb9,0x2a,0xf1);

//
// end cls ids for EAPP module
//


//
DEFINE_GUID( LIBID_Accessibility,           0x1ea4dbf0,0x3c3b,0x11cf,0x81,0x0c,0x00,0xaa,0x00,0x38,0x9b,0x71);
DEFINE_GUID( IID_IAccessible,               0x618736e0,0x3c3d,0x11cf,0x81,0x0c,0x00,0xaa,0x00,0x38,0x9b,0x71);



// From docobj.lib (SriniK)
DEFINE_GUID( SID_SContainerDispatch,        0xb722be00,0x4e68,0x101b,0xa2,0xbc,0x00,0xaa,0x00,0x40,0x47,0x70);

DEFINE_GUID( SID_SDataPathBrowser,          0xFC4801A5,0x2BA9,0x11CF,0xA2,0x29,0x00,0xAA,0x00,0x3D,0x73,0x52);
DEFINE_GUID( GUID_PathProperty,             0x0002DE80,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( GUID_HasPathProperties,        0x0002DE81,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

DEFINE_GUID( CLSID_StdHlink,                0x79eac9d0,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);
DEFINE_GUID( CLSID_StdHlinkBrowseContext,   0x79eac9d1,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);

//
// datapath guids
//
DEFINE_GUID( OLE_DATAPATH_BMP,              0x0002DE01,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_DIB,              0x0002DE02,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_WMF,              0x0002DE03,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_ENHMF,            0x0002DE04,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_GIF,              0x0002DE05,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_JPEG,             0x0002DE06,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_TIFF,             0x0002DE07,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_XBM,              0x0002DE08,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_PCX,              0x0002DE09,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_PICT,             0x0002DE0A,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_CGM,              0x0002DE0B,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_EPS,              0x0002DE0C,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_COMMONIMAGE,      0x0002DE0D,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_ALLIMAGE,         0x0002DE0E,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_AVI,              0x0002DE0F,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_MPEG,             0x0002DE10,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_QUICKTIME,        0x0002DE11,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_BASICAUDIO,       0x0002DE12,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_MIDI,             0x0002DE13,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_WAV,              0x0002DE14,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_RIFF,             0x0002DE15,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_SOUND,            0x0002DE16,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_VIDEO,            0x0002DE17,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_ALLMM,            0x0002DE18,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_ANSITEXT,         0x0002DE19,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_UNICODE,          0x0002DE1A,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_RTF,              0x0002DE1B,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_HTML,             0x0002DE1C,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_POSTSCRIPT,       0x0002DE1D,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_ALLTEXT,          0x0002DE1E,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_DIF,              0x0002DE1F,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_SYLK,             0x0002DE20,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_BIFF,             0x0002DE21,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_PALETTE,          0x0002DE22,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID( OLE_DATAPATH_PENDATA,          0x0002DE23,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

DEFINE_GUID( FLAGID_Internet,               0x96300DA0,0x2BAB,0x11CF,0xA2,0x29,0x00,0xAA,0x00,0x3D,0x73,0x52);
DEFINE_GUID( ARRAYID_PathProperties,        0x7ecbba04,0x2d97,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);

//
// Component category guids
//

DEFINE_GUID( CLSID_StdComponentCategoriesMgr,0x0002E005,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

DEFINE_GUID( CATID_Insertable,              0x40FC6ED3,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_Control,                 0x40FC6ED4,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_Programmable,            0x40FC6ED5,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_IsShortcut,              0x40FC6ED6,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_NeverShowExt,            0x40FC6ED7,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_DocObject,               0x40FC6ED8,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_Printable,               0x40FC6ED9,0x2438,0x11cf,0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02);
DEFINE_GUID( CATID_RequiresDataPathHost,    0x0de86a50,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToMoniker,       0x0de86a51,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToStorage,       0x0de86a52,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToStreamInit,    0x0de86a53,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToStream,        0x0de86a54,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToMemory,        0x0de86a55,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToFile,          0x0de86a56,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_PersistsToPropertyBag,   0x0de86a57,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_InternetAware,           0x0de86a58,0x2baa,0x11cf,0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52);
DEFINE_GUID( CATID_SafeForScripting,        0x7dd95801,0x9882,0x11cf,0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4);
DEFINE_GUID( CATID_SafeForInitializing,     0x7dd95802,0x9882,0x11cf,0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4);
DEFINE_GUID( CATID_DesignTimeUIActivatableControl, 0xf2bb56d1,0xdb07,0x11d1,0xaa,0x6b,0x00,0x60,0x97,0xdb,0x95,0x39);

//
// Image component GUIDs
//

DEFINE_GUID( CLSID_IImgCtx,                 0x3050f3d6,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( IID_IImgCtx,                   0x3050f3d7,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);

DEFINE_GUID( CLSID_IImageDecodeFilter,      0x607fd4e8,0x0a03,0x11d1,0xab,0x1d,0x00,0xc0,0x4f,0xc9,0xb3,0x04);

//
// Trident GUIDs
//

DEFINE_GUID( CGID_MSHTML,                   0xde4ba900,0x59ca,0x11cf, 0x95,0x92,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID( CLSID_MHTMLDocument,           0x3050f3d9,0x98b5,0x11cf, 0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( CLSID_HTADocument,             0x3050F5C8,0x98B5,0x11CF, 0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( CLSID_HTMLApplication,         0x3050f4d8,0x98B5,0x11CF, 0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID( CLSID_HTMLPluginDocument,      0x25336921,0x03F9,0x11cf, 0x8F,0xD0,0x00,0xAA,0x00,0x68,0x6F,0x13);
DEFINE_GUID( CGID_DocHostCommandHandler,    0xf38bc242,0xb950,0x11d1, 0x89,0x18,0x00,0xc0,0x4f,0xc2,0xc8,0x36);
DEFINE_GUID( SID_SHTMLEditServices,         0x3050f7f9,0x98b5,0x11cf, 0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);

// OC Multimedia GUIDs

// Bitmap Surface format IDs:
// These are the same guids as used in the equivalent MEDIASUBTYPE_RGB* guids defined by DirectX.
DEFINE_GUID(  BFID_MONOCHROME,              0xe436eb78,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_4,                   0xe436eb79,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_8,                   0xe436eb7a,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_555,                 0xe436eb7c,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_565,                 0xe436eb7b,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_24,                  0xe436eb7d,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGB_32,                  0xe436eb7e,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
DEFINE_GUID(  BFID_RGBA_32,                 0x773c9ac0,0x3274,0x11d0,0xb7,0x24,0x00,0xaa,0x00,0x6c,0x1a,0x01);
DEFINE_GUID(  BFID_GRAY_8,                  0xd93de910,0x449c,0x11d0,0x91,0x8c,0x00,0xaa,0x00,0x6c,0x1a,0x01);
DEFINE_GUID(  BFID_GRAY_16,                 0xf9d6bc00,0x449c,0x11d0,0x91,0x8c,0x00,0xaa,0x00,0x6c,0x1a,0x01);

// Access to MSHTML's ditherer

DEFINE_GUID( CLSID_IntDitherer,             0x05f6fe1a,0xecef,0x11d0,0xaa,0xe7,0x00,0xc0,0x4f,0xc9,0xb3,0x04);
DEFINE_GUID( IID_IIntDitherer,              0x06670ca0,0xecef,0x11d0,0xaa,0xe7,0x00,0xc0,0x4f,0xc9,0xb3,0x04);

// Named Timer used by Trident
DEFINE_GUID(  NAMEDTIMER_DRAW,              0x3050f362,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);

// Channel: Code Download: SoftDist GUIDS
DEFINE_GUID( CLSID_SoftDistExt,             0xb15b8dc0,0xc7e1,0x11d0,0x86,0x80,0x00,0xaa,0x00,0xbd,0xcb,0x71);

// ActiveXSafety
DEFINE_GUID( CLSID_IActiveXSafetyProvider,  0xaaf8c6ce,0xf972,0x11d0,0x97,0xeb,0x00,0xaa,0x00,0x61,0x53,0x33);

// Security Manager.
DEFINE_GUID( CLSID_InternetSecurityManager, 0x7b8a2d94,0x0ac9,0x11d1,0x89,0x6c,0x00,0xc0,0x4f,0xb6,0xbf,0xc4);

DEFINE_GUID( CLSID_InternetZoneManager,     0x7b8a2d95,0x0ac9,0x11d1,0x89,0x6c,0x00,0xc0,0x4f,0xb6,0xbf,0xc4);

// HTMLLoadOptions
DEFINE_GUID( CLSID_HTMLLoadOptions,         0x18845040,0x0fa5,0x11d1,0xba,0x19,0x00,0xc0,0x4f,0xd9,0x12,0xd0);

// Webcheck guids
DEFINE_GUID( CLSID_SubscriptionThrottler,   0x1e9b00e5,0x9846,0x11d1,0xa1,0xee,0x00,0xc0,0x4f,0xc2,0xfb,0xe1);

// Download status guids
DEFINE_GUID( CGID_DownloadHost,             0xe0608728,0xae4c,0x11d1,0xba,0x40,0x00,0xc0,0x4f,0xb9,0x2d,0x79);

// IE host exec guids
DEFINE_GUID( CGID_InternetExplorer,         0xeb7eed00,0xf74d,0x11d2,0xbb,0x7f,0x00,0x10,0x4b,0x35,0xe7,0xf9);

// IVersionHost guids
DEFINE_GUID( SID_SVersionHost,              0x371ea634,0xdc5c,0x11d1,0xba,0x57,0x00,0xc0,0x4f,0xc2,0x04,0x0e);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\uuid\makefile.inc ===
$(O)\activaut_i.c : ..\inc\$(O)\activaut_i.c
    copy $** $@

$(O)\activdbg_i.c : ..\inc\$(O)\activdbg_i.c
    copy $** $@

$(O)\activscp_i.c : ..\inc\$(O)\activscp_i.c
    copy $** $@

$(O)\AutoDiscovery_i.c : ..\inc\$(O)\AutoDiscovery_i.c
    copy $** $@

$(O)\chanmgr_i.c : ..\inc\$(O)\chanmgr_i.c
    copy $** $@

$(O)\comcat_i.c : ..\inc\$(O)\comcat_i.c
    copy $** $@

$(O)\dbgprop_i.c : ..\inc\$(O)\dbgprop_i.c
    copy $** $@

$(O)\dimm_i.c : ..\inc\$(O)\dimm_i.c
    copy $** $@

$(O)\dispex_i.c : ..\inc\$(O)\dispex_i.c
    copy $** $@

$(O)\dlmgridl_i.c : ..\inc\$(O)\dlmgridl_i.c
    copy $** $@

$(O)\docobj_i.c : ..\inc\$(O)\docobj_i.c
    copy $** $@

$(O)\dxtmsft_i.c : ..\inc\$(O)\dxtmsft_i.c
    copy $** $@

$(O)\dxtrans_i.c : ..\inc\$(O)\dxtrans_i.c
    copy $** $@

$(O)\dxtransp_i.c : ..\inc\$(O)\dxtransp_i.c
    copy $** $@

$(O)\dwnnot_i.c : ..\inc\$(O)\dwnnot_i.c
    copy $** $@

$(O)\emptyvc_i.c : ..\inc\$(O)\emptyvc_i.c
    copy $** $@

$(O)\exdisp_i.c : ..\inc\$(O)\exdisp_i.c
    copy $** $@

$(O)\hlink_i.c : ..\inc\$(O)\hlink_i.c
    copy $** $@

$(O)\htiface_i.c : ..\inc\$(O)\htiface_i.c
    copy $** $@

$(O)\htiframe_i.c : ..\inc\$(O)\htiframe_i.c
    copy $** $@

$(O)\htmlfilter_i.c : ..\inc\$(O)\htmlfilter_i.c
    copy $** $@

$(O)\iedial_i.c : ..\inc\$(O)\iedial_i.c
    copy $** $@

$(O)\iextag_i.c : ..\inc\$(O)\iextag_i.c
    copy $** $@

$(O)\imgutil_i.c : ..\inc\$(O)\imgutil_i.c
    copy $** $@

$(O)\interned_i.c : ..\inc\$(O)\interned_i.c
    copy $** $@

$(O)\mimeinfo_i.c : ..\inc\$(O)\mimeinfo_i.c
    copy $** $@

$(O)\mlang_i.c : ..\inc\$(O)\mlang_i.c
    copy $** $@

$(O)\mobsync_i.c : ..\inc\$(O)\mobsync_i.c
    copy $** $@

$(O)\mobsyncp_i.c : ..\inc\$(O)\mobsyncp_i.c
    copy $** $@

$(O)\mshtmhst_i.c : ..\inc\$(O)\mshtmhst_i.c
    copy $** $@

$(O)\mstime_i.c : ..\inc\$(O)\mstime_i.c
    copy $** $@

$(O)\mshtml_i.c : ..\inc\$(O)\mshtml_i.c
    copy $** $@

$(O)\msident_i.c : ..\inc\$(O)\msident_i.c
    copy $** $@

$(O)\msieftp_i.c : ..\inc\$(O)\msieftp_i.c
    copy $** $@

$(O)\msxml_i.c : ..\inc\$(O)\msxml_i.c
    copy $** $@

$(O)\objsafe_i.c : ..\inc\$(O)\objsafe_i.c
    copy $** $@

$(O)\ocmm_i.c : ..\inc\$(O)\ocmm_i.c
    copy $** $@

$(O)\opsprof_i.c : ..\inc\$(O)\opsprof_i.c
    copy $** $@

$(O)\optary_i.c : ..\inc\$(O)\optary_i.c
    copy $** $@

$(O)\perhist_i.c : ..\inc\$(O)\perhist_i.c
    copy $** $@

$(O)\prgsnk_i.c : ..\inc\$(O)\prgsnk_i.c
    copy $** $@

$(O)\procdm_i.c : ..\inc\$(O)\procdm_i.c
    copy $** $@

$(O)\ratingsp_i.c : ..\inc\$(O)\ratingsp_i.c
    copy $** $@

$(O)\recalc_i.c : ..\inc\$(O)\recalc_i.c
    copy $** $@

$(O)\safeocx_i.c : ..\inc\$(O)\safeocx_i.c
    copy $** $@

$(O)\sensevts_i.c : ..\inc\$(O)\sensevts_i.c
    copy $** $@

$(O)\servprov_i.c : ..\inc\$(O)\servprov_i.c
    copy $** $@

$(O)\subsmgr_i.c : ..\inc\$(O)\subsmgr_i.c
    copy $** $@

$(O)\urlhist_i.c : ..\inc\$(O)\urlhist_i.c
    copy $** $@

$(O)\urlmon_i.c : ..\inc\$(O)\urlmon_i.c
    copy $** $@

$(O)\urltrack_i.c : ..\inc\$(O)\urltrack_i.c
    copy $** $@

$(O)\vervec_i.c : ..\inc\$(O)\vervec_i.c
    copy $** $@

$(O)\vrsscan_i.c : ..\inc\$(O)\vrsscan_i.c
    copy $** $@

$(O)\webcheck_i.c : ..\inc\$(O)\webcheck_i.c
    copy $** $@

$(O)\xmlparser_i.c : ..\inc\$(O)\xmlparser_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\inc\xmldomdid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDOMDID_H__
#define __XMLDOMDID_H__
//;end_internal

// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_COLLECTION_BASE	1000000
#define DISPID_DOM_COLLECTION_MAX	2999999

#define DISPID_DOM_NODE                             (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME                    (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE                   (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE                    (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM                (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE                  (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES                  (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD                  (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD                   (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING             (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING                 (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES                  (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE                (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD                (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD                 (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD                 (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES               (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC                    (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE                   (DISPID_DOM_NODE + 18)
#define DISPID_XMLDOM_NODE                          (DISPID_DOM_NODE + 19)
#define DISPID_XMLDOM_NODE_STRINGTYPE               (DISPID_XMLDOM_NODE + 1)
#define DISPID_XMLDOM_NODE_SPECIFIED                (DISPID_XMLDOM_NODE + 2)
#define DISPID_XMLDOM_NODE_DEFINITION               (DISPID_XMLDOM_NODE + 3)
#define DISPID_XMLDOM_NODE_TEXT                     (DISPID_XMLDOM_NODE + 4)
#define DISPID_XMLDOM_NODE_NODETYPEDVALUE           (DISPID_XMLDOM_NODE + 5)
#define DISPID_XMLDOM_NODE_DATATYPE                 (DISPID_XMLDOM_NODE + 6)
#define DISPID_XMLDOM_NODE_XML                      (DISPID_XMLDOM_NODE + 7)
#define DISPID_XMLDOM_NODE_TRANSFORMNODE            (DISPID_XMLDOM_NODE + 8)
#define DISPID_XMLDOM_NODE_SELECTNODES              (DISPID_XMLDOM_NODE + 9)
#define DISPID_XMLDOM_NODE_SELECTSINGLENODE         (DISPID_XMLDOM_NODE + 10)
#define DISPID_XMLDOM_NODE_PARSED                   (DISPID_XMLDOM_NODE + 11)
#define DISPID_XMLDOM_NODE_NAMESPACE                (DISPID_XMLDOM_NODE + 12)
#define DISPID_XMLDOM_NODE_PREFIX                   (DISPID_XMLDOM_NODE + 13)
#define DISPID_XMLDOM_NODE_BASENAME                 (DISPID_XMLDOM_NODE + 14)
#define DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT    (DISPID_XMLDOM_NODE + 15)
#define DISPID_XMLDOM_NODE__TOP                     (DISPID_XMLDOM_NODE + 16)

#define DISPID_DOM_DOCUMENT                        (DISPID_XMLDOM_NODE__TOP + 1)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT                     (DISPID_DOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE        (DISPID_XMLDOM_DOCUMENT + 1)
#define DISPID_XMLDOM_DOCUMENT_CREATENODE          (DISPID_XMLDOM_DOCUMENT + 2)
#define DISPID_XMLDOM_DOCUMENT_CREATENODEEX        (DISPID_XMLDOM_DOCUMENT + 3)
#define DISPID_XMLDOM_DOCUMENT_NODEFROMID          (DISPID_XMLDOM_DOCUMENT + 4)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES  (DISPID_XMLDOM_DOCUMENT + 5)
#define DISPID_XMLDOM_DOCUMENT_LOAD                (DISPID_XMLDOM_DOCUMENT + 6)
#define DISPID_XMLDOM_DOCUMENT_PARSEERROR          (DISPID_XMLDOM_DOCUMENT + 7)
#define DISPID_XMLDOM_DOCUMENT_URL                 (DISPID_XMLDOM_DOCUMENT + 8)
#define DISPID_XMLDOM_DOCUMENT_ASYNC               (DISPID_XMLDOM_DOCUMENT + 9)
#define DISPID_XMLDOM_DOCUMENT_ABORT               (DISPID_XMLDOM_DOCUMENT + 10)
#define DISPID_XMLDOM_DOCUMENT_LOADXML             (DISPID_XMLDOM_DOCUMENT + 11)
#define DISPID_XMLDOM_DOCUMENT_SAVE                (DISPID_XMLDOM_DOCUMENT + 12)
#define DISPID_XMLDOM_DOCUMENT_VALIDATE            (DISPID_XMLDOM_DOCUMENT + 13)
#define DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE    (DISPID_XMLDOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE  (DISPID_XMLDOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE  (DISPID_XMLDOM_DOCUMENT + 16)
#define DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE     (DISPID_XMLDOM_DOCUMENT + 17)
#define DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE     (DISPID_XMLDOM_DOCUMENT + 18)
#define DISPID_XMLDOM_DOCUMENT__TOP                (DISPID_XMLDOM_DOCUMENT + 19)

#define DISPID_DOM_NODELIST             (DISPID_XMLDOM_DOCUMENT__TOP + 1)
#define DISPID_DOM_NODELIST_ITEM        (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH      (DISPID_DOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST          (DISPID_DOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST_NEXTNODE (DISPID_XMLDOM_NODELIST + 1)
#define DISPID_XMLDOM_NODELIST_RESET    (DISPID_XMLDOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST_NEWENUM  (DISPID_XMLDOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST__TOP     (DISPID_XMLDOM_NODELIST + 4)


#define DISPID_DOM_NAMEDNODEMAP                         (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM         (DISPID_DOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP                      (DISPID_DOM_NAMEDNODEMAP + 6)
#define DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM     (DISPID_XMLDOM_NAMEDNODEMAP + 1)
#define DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM  (DISPID_XMLDOM_NAMEDNODEMAP + 2)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE             (DISPID_XMLDOM_NAMEDNODEMAP + 3)
#define DISPID_XMLDOM_NAMEDNODEMAP_RESET                (DISPID_XMLDOM_NAMEDNODEMAP + 4)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM              (DISPID_XMLDOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP__TOP                 (DISPID_XMLDOM_NAMEDNODEMAP + 6)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_XMLDOM_NAMEDNODEMAP__TOP + 1)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS + 1)
#define DISPID_DOM_DOCUMENTFRAGMENT__TOP       (DISPID_DOM_DOCUMENTFRAGMENT + 1)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENTFRAGMENT__TOP + 1)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT__TOP                    (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT__TOP + 1)
#define DISPID_DOM_DATA_DATA                   (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 7)
#define DISPID_DOM_DATA__TOP                   (DISPID_DOM_DATA + 8)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA__TOP + 1)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_VALUE             (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE__TOP              (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE__TOP + 1)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT__TOP           (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT__TOP + 1)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI__TOP      (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI__TOP + 1)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE__TOP       (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE__TOP + 1)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION__TOP           (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION__TOP + 1)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY__TOP             (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY__TOP)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_W3CWRAPPERS_TOP + 1)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)
#define DISPID_DOM_IMPLEMENTATION__TOP         (DISPID_DOM_IMPLEMENTATION + 2)

#define DISPID_DOM__TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)


#define  DISPID_DOM_ERROR                      (DISPID_DOM__TOP  + 1)
#define  DISPID_DOM_ERROR_ERRORCODE            (DISPID_DOM_ERROR  +  1)
#define  DISPID_DOM_ERROR_URL                  (DISPID_DOM_ERROR  +  2)
#define  DISPID_DOM_ERROR_REASON               (DISPID_DOM_ERROR  +  3)
#define  DISPID_DOM_ERROR_SRCTEXT              (DISPID_DOM_ERROR  +  4)
#define  DISPID_DOM_ERROR_LINE                 (DISPID_DOM_ERROR  +  5)
#define  DISPID_DOM_ERROR_LINEPOS              (DISPID_DOM_ERROR  +  6)
#define  DISPID_DOM_ERROR_FILEPOS              (DISPID_DOM_ERROR  +  7)
#define  DISPID_DOM_ERROR__TOP                 (DISPID_DOM_ERROR  +  8)

#define  DISPID_XTLRUNTIME                         (DISPID_DOM_ERROR__TOP + 1)
#define  DISPID_XTLRUNTIME_UNIQUEID                (DISPID_XTLRUNTIME + 1)
#define  DISPID_XTLRUNTIME_DEPTH                   (DISPID_XTLRUNTIME + 2)
#define  DISPID_XTLRUNTIME_CHILDNUMBER             (DISPID_XTLRUNTIME + 3)
#define  DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER     (DISPID_XTLRUNTIME + 4)
#define  DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER     (DISPID_XTLRUNTIME + 5)
#define  DISPID_XTLRUNTIME_FORMATINDEX             (DISPID_XTLRUNTIME + 6)
#define  DISPID_XTLRUNTIME_FORMATNUMBER            (DISPID_XTLRUNTIME + 7)
#define  DISPID_XTLRUNTIME_FORMATDATE              (DISPID_XTLRUNTIME + 8)
#define  DISPID_XTLRUNTIME_FORMATTIME              (DISPID_XTLRUNTIME + 9)
#define  DISPID_XTLRUNTIME__TOP                    (DISPID_XTLRUNTIME + 10)

#define  DISPID_XMLDOMEVENT                        (DISPID_XTLRUNTIME__TOP + 1)
#define  DISPID_XMLDOMEVENT_ONREADYSTATECHANGE     (DISPID_READYSTATECHANGE)
#define  DISPID_XMLDOMEVENT_ONDATAAVAILABLE        (DISPID_XMLDOMEVENT + 1)
#define  DISPID_XMLDOMEVENT__TOP                   (DISPID_XMLDOMEVENT + 2)

//;begin_internal
#endif // __XMLDOMDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\uuid\unixguids.cxx ===
#define INITGUID

#include "mwversion.h"
#include <compobj.h>
#include <initguid.h>
#include <msstkppg.h>

#include <shlguid.h>

#undef INITGUID
#include "unix/guids.h"

// Must be after "unix/guids.h" to expand the GUIDs for olectl.h.
#define INITGUID

// DllMain needed due to this being a shared library

extern "C" BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\uuid\unix\obguid.h ===
/* processed by mwprepro */
/***
*obguid.h
*
*  Copyright (C) 1992, Microsoft Corporation.  All Rights Reserved.
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose:
*  Definitions of private OB owned GUIDs.
*
* [00]	26-Jan-93 gustavj: Created.
*
*Implementation Notes:
*  OLE has given OB a range of GUIDs to use for its classes.  This range
*  consists of 256 possible GUIDs.  The GUIDs for public classes
*  (such as ItypeInfo) take GUIDs starting at the low end of the range,
*  private classes(such as GEN_DTINFO), take GUIDs starting at the high
*  end.  New GUIDs that are added should maintain this convention.
*
*  GUIDs for OB public classes are defined in switches.hxx.
*
*****************************************************************************/

#ifndef obguid_HXX_INCLUDED
#define obguid_HXX_INCLUDED

#define DEFINE_OBOLEGUID(name, b) DEFINE_OLEGUID(name,(0x00020400+b), 0, 0);

DEFINE_OBOLEGUID(CLSID_GenericTypeLibOLE, 0xff)

DEFINE_OBOLEGUID(IID_TYPEINFO	      , 0xfc)
DEFINE_OBOLEGUID(IID_DYNTYPEINFO      , 0xfb)

DEFINE_OBOLEGUID(IID_CDefnTypeComp    , 0xf5)

DEFINE_OBOLEGUID(IID_TYPELIB_GEN_DTINFO  , 0xf2)

// {DD23B040-296F-101B-99A1-08002B2BD119}
DEFINE_GUID(CLSID_TypeLibCF,
    0xDD23B040L,0x296F,0x101B,0x99,0xA1,0x08,0x00,0x2B,0x2B,0xD1,0x19);
//{F5AA2660-BA14-1069-8AEE-00DD010F7D13}
DEFINE_GUID(IID_IGenericTypeLibOLE,
    0xF5AA2660L,0xBA14,0x1069,0x8A,0xEE,0x00,0xDD,0x01,0x0F,0x7D,0x13);


#endif  // !obguid_HXX_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\active.inc ===
C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=100           \
              -D_NT1X_=100          \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -DNASHVILLE

# Do this to assure we run on NT 4.0/Win95, even with
# NT5/Memphis headers.
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400

SDSUTILS_PATH=..\..\sdslib

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1
# USE_MSVCRT=1
USE_NOLIBS = 1

MSC_WARNING_LEVEL=/W3 /WX

USE_MAPSYM=1


#              -DUNICODE             \
#              -D_UNICODE            \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\uuid\unix\clsid.h ===
/*** 
*clsid.h
*
*  Copyright (C) 1992, Microsoft Corporation.  All Rights Reserved.
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose:
*  This file defines the CLSIDs
*
*Implementation Notes:
*
*****************************************************************************/

#if defined(WIN32) && 0
DEFINE_OLEGUID(CLSID_PSDispatch, 	0x00020400, 0, 0);
DEFINE_OLEGUID(CLSID_PSEnumVARIANT,	0x00020404, 0, 0);
DEFINE_OLEGUID(CLSID_PSTypeInfo,	0x00020401, 0, 0);
DEFINE_OLEGUID(CLSID_PSTypeLib,		0x00020402, 0, 0);
#else
DEFINE_OLEGUID(CLSID_PSDispatch, 	0x00020420, 0, 0);
DEFINE_OLEGUID(CLSID_PSEnumVARIANT,	0x00020421, 0, 0);
DEFINE_OLEGUID(CLSID_PSTypeInfo,	0x00020422, 0, 0);
DEFINE_OLEGUID(CLSID_PSTypeLib,		0x00020423, 0, 0);
#endif

DEFINE_OLEGUID(CLSID_PSAutomation,	0x00020424, 0, 0);
DEFINE_OLEGUID(CLSID_PSTypeComp,	0x00020425, 0, 0);

DEFINE_OLEGUID(CLSID_InProcFreeMarshaler, 0x0000001c, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\asctlpch.cpp ===
#include "asctlpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\published\uuid\unix\guids.h ===
/*** 
*guids.h
*
*Purpose:
*  This file defines all GUIDS the Unix project could not find defined 
*  elsewhere.  If you know where the proper place for some of these 
*  GUID definitions are, remove these and use the other ones.
*
*  Actually, most of these if not all are in comdefs.h
*  Unfortunately they use __declspec(uuid), though.  We might want to 
*  run a script past those and generate this file...  (davidd)
*
*Implementation Notes:
*
*****************************************************************************/

#include <obguid.h>
#include <clsid.h>
#include <urlmon.h>
#include <oleguid.h>
#include <coguid.h>
#include <olectl.h>


DEFINE_OLEGUID(CLSID_DfMarshal,		0x0000030b, 0, 0);

DEFINE_OLEGUID(IID_IDispatch,		0x00020400L, 0, 0);
DEFINE_OLEGUID(IID_IEnumVARIANT,	0x00020404L, 0, 0);
DEFINE_OLEGUID(IID_ITypeInfo,		0x00020401L, 0, 0);
DEFINE_OLEGUID(IID_ITypeLib,		0x00020402L, 0, 0);
DEFINE_OLEGUID(IID_ITypeComp,		0x00020403L, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeInfo,	0x00020405L, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeLib,	0x00020406L, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeInfo2,    0x0002040eL, 0, 0);
DEFINE_OLEGUID(IID_ITypeInfo2,          0x00020412L, 0, 0);

DEFINE_OLEGUID(IID_StdOle,		0x00020430L, 0, 0);

DEFINE_OLEGUID(CLSID_PSRemoteTypeInfo, 	0x00020424, 0, 0);

/* Because we don't have oledb_i.c, we need this IID defined here */
/* // Begin oledb_i.c */

DEFINE_GUID(IID_IRowsetChapterMember,
  0x0c733aa8L, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77,0x3d);

/* // End oledb_i.c */


/* // {3E42C004-6BFD-17E2-B4CC-0800208359F5} */
DEFINE_GUID(IID_IWindowStatus,
  0x3E42C004L, 0x6BFD, 0x17E2, 0xB4, 0xCC, 0x08, 0x00, 0x20, 0x83, 0x59, 0xF5);

/* // {1CF2B120-547D-101B-8E65-08002B2BD119} */
DEFINE_GUID(IID_IErrorInfo,
  0x1CF2B120L, 0x547D, 0x101B, 0x8E, 0x65, 0x08, 0x00, 0x2B, 0x2B, 0xD1, 0x19);

/* // {22F03340-547D-101B-8E65-08002B2BD119} */
DEFINE_GUID(IID_ICreateErrorInfo,
  0x22F03340L, 0x547D, 0x101B, 0x8E, 0x65, 0x08, 0x00, 0x2B, 0x2B, 0xD1, 0x19);

/* // {DF0B3D60-548F-101B-8E65-08002B2BD119} */
DEFINE_GUID(IID_ISupportErrorInfo,
  0xDF0B3D60L, 0x548F, 0x101B, 0x8E, 0x65, 0x08, 0x00, 0x2B, 0x2B, 0xD1, 0x19);

/* // {0000001d-0000-0000-c000-000000000046} */
DEFINE_GUID(IID_IMallocSpy,
  0x0000001DL, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

// For IE
DEFINE_GUID(CLSID_URLMoniker,
  0x79eac9e0,0xbaf9,0x11ce,0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b);

DEFINE_GUID(CLSID_MsgBand,
  0x07B8F010,0x9E21,0x11d1,0xA8,0x2E,0x08,0x00,0x09,0xDC,0x53,0x35);

// following are added for MFC4.2
DEFINE_GUID(IID_IBoundObject,
	0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
	0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

/* {DB526CC0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_INotifyDBEvents,
0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {9F6AA700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursor,
0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {ACFF0690-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorMove,
0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {D14216A0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorUpdateARow,
0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* Xiao-Yu ???? I couldn't find definition for the following IIDs even on
 * the lasted 4.2 enterprise edition CD.  So just defined some dummy values 
 * here to get MFC lib linked.  All the IIDs here need to be defined
 * once we find Microsoft's definition for them.
 */
DEFINE_GUID(IID_IDefViewBrowser,
0xaddf68db, 0xca3c, 0x11cf, 0x9e, 0x84, 0x00, 0x00, 0x00, 0xf8, 0x80, 0xbf); 

// A bunch of IID's formerly in olectlid.h.
DEFINE_GUID(IID_IEnumConnections,0xB196B287,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IConnectionPoint,0xB196B286,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IEnumConnectionPoints,0xB196B285,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IConnectionPointContainer,0xB196B284,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IClassFactory2,0xB196B28F,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IProvideClassInfo,0xB196B283,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IProvideClassInfo2,0xA6BC3AC0,0xDBAA,0x11CE,0x9D,0xE3,0x00,0xAA,0x00,0x4B,0xB8,0x51);
DEFINE_GUID(IID_IOleControl,0xB196B288,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IOleControlSite,0xB196B289,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IPropertyPage,0xB196B28D,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IPropertyPage2,0x01E44665,0x24AC,0x101B,0x84,0xED,0x08,0x00,0x2B,0x2E,0xC7,0x13);
DEFINE_GUID(IID_IPropertyPageSite,0xB196B28C,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IPropertyNotifySink,0x9BFBBC02,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_ISpecifyPropertyPages,0xB196B28B,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IPersistMemory,0xBD1AE5E0,0xA6AE,0x11CE,0xBD,0x37,0x50,0x42,0x00,0xC1,0x00,0x00);
DEFINE_GUID(IID_IPersistStreamInit,0x7FD52380,0x4E07,0x101B,0xAE,0x2D,0x08,0x00,0x2B,0x2E,0xC7,0x13);
DEFINE_GUID(IID_IPersistPropertyBag,0x37D84F60,0x42CB,0x11CE,0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51);
DEFINE_GUID(IID_ISimpleFrameSite,0x742B0E01,0x14E6,0x101B,0x91,0x4E,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(IID_IFont,0xBEF6E002,0xA874,0x101A,0x8B,0xBA,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(IID_IPicture,0x7BF80980,0xBF32,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(IID_IFontDisp,0xBEF6E003,0xA874,0x101A,0x8B,0xBA,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(IID_IPictureDisp,0x7BF80981,0xBF32,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(IID_IAdviseSinkEx,0x3AF24290,0x0C96,0x11CE,0xA0,0xCF,0x00,0xAA,0x00,0x60,0x0A,0xB8);
DEFINE_GUID(IID_IOleInPlaceObjectWindowless,0x1C2056CC,0x5EF4,0x101B,0x8B,0xC8,0x00,0xAA,0x00,0x3E,0x3B,0x29);
DEFINE_GUID(IID_IOleInPlaceSiteEx,0x9C2CAD80,0x3424,0x11CF,0xB6,0x70,0x00,0xAA,0x00,0x4C,0xD6,0xD8);
DEFINE_GUID(IID_IOleInPlaceSiteWindowless,0x922EADA0,0x3424,0x11CF,0xB6,0x70,0x00,0xAA,0x00,0x4C,0xD6,0xD8);
DEFINE_GUID(IID_IViewObjectEx,0x3AF24292,0x0C96,0x11CE,0xA0,0xCF,0x00,0xAA,0x00,0x60,0x0A,0xB8);
DEFINE_GUID(IID_IOleUndoUnit,0x894AD3B0,0xEF97,0x11CE,0x9B,0xC9,0x00,0xAA,0x00,0x60,0x8E,0x01);
DEFINE_GUID(IID_IOleParentUndoUnit,0xA1FAF330,0xEF97,0x11CE,0x9B,0xC9,0x00,0xAA,0x00,0x60,0x8E,0x01);
DEFINE_GUID(IID_IEnumOleUndoUnits,0xB3E7C340,0xEF97,0x11CE,0x9B,0xC9,0x00,0xAA,0x00,0x60,0x8E,0x01);
DEFINE_GUID(IID_IOleUndoManager,0xD001F200,0xEF97,0x11CE,0x9B,0xC9,0x00,0xAA,0x00,0x60,0x8E,0x01);
DEFINE_GUID(IID_IQuickActivate,0xCF51ED10,0x62FE,0x11CF,0xBF,0x86,0x00,0xA0,0xC9,0x03,0x48,0x36);
DEFINE_GUID(IID_IPointerInactive,0x55980BA0,0x35AA,0x11CF,0xB6,0x71,0x00,0xAA,0x00,0x4C,0xD6,0xD8);
DEFINE_GUID(IID_IObjectWithSite,0xFC4801A3,0x2BA9,0x11CF,0xA2,0x29,0x00,0xAA,0x00,0x3D,0x73,0x52);
DEFINE_GUID(IID_IErrorLog,0x3127CA40,0x446E,0x11CE,0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51);
DEFINE_GUID(IID_IPropertyBag,0x55272A00,0x42CB,0x11CE,0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51);
DEFINE_GUID(IID_IPerPropertyBrowsing,0x376BD3AA,0x3845,0x101B,0x84,0xED,0x08,0x00,0x2B,0x2E,0xC7,0x13);
DEFINE_GUID(IID_IClientSecurity,     0x0000013d,0x0000,0x0000,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID(IID_IRichEditOleCallback,0x00020d03,0x0000,0x0000,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

// Stuff from java/common/inc/pdlgguid.h (in permdlg.lib)
DEFINE_GUID(IID_IJavaZonePermissionEditor, 0x85347F8A,0xC8B7,0x11d0,0x88,0x23,0x00,0xC0,0x4F,0xB6,0x7C,0x84);
DEFINE_GUID(CLSID_JavaRuntimeConfiguration, 0x004CE610,0xCCD1,0x11d0,0xA9,0xBA,0x00,0xA0,0xC9,0x08,0xDB,0x5E);

// Stuff for old trident 4.0


DEFINE_GUID(DIID_DispIHTMLLinkElement, 0x3050f524,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFormElement, 0x3050f510,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLControlElement, 0x3050f53f,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTextElement, 0x3050f537,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTextContainer, 0x3050f53e,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLImgElement, 0x3050f51c,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBodyElement, 0x3050f507,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFontElement, 0x3050f512,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLAnchorElement, 0x3050f502,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLLabelElement, 0x3050f522,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLListElement, 0x3050f525,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLUListElement, 0x3050f538,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLOListElement, 0x3050f52a,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLLIElement, 0x3050f523,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBlockElement, 0x3050f506,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLDivElement, 0x3050f50c,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLDDElement, 0x3050f50b,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLDTElement, 0x3050f50d,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBRElement, 0x3050f53a,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLDListElement, 0x3050f53b,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLHRElement, 0x3050f53d,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLParaElement, 0x3050f52c,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLHeaderElement, 0x3050f515,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLSelectElement, 0x3050f531,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLOptionElement, 0x3050f52b,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTextAreaElement, 0x3050f521,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLButtonElement, 0x3050f51f,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLMarqueeElement, 0x3050f527,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTitleElement, 0x3050f516,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLMetaElement, 0x3050f517,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBaseElement, 0x3050f518,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLIsIndexElement, 0x3050f519,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLNextIdElement, 0x3050f51a,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBaseFontElement, 0x3050f504,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLUnknownElement, 0x3050f539,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLEmbedElement, 0x3050f52e,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLMapElement, 0x3050f526,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLAreaElement, 0x3050f503,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTableCaption, 0x3050f508,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLCommentElement, 0x3050f50a,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLPhraseElement, 0x3050f52d,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLSpanElement, 0x3050f548,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTable, 0x3050f532,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTableCol, 0x3050f533,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTableSection, 0x3050f534,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTableRow, 0x3050f535,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLTableCell, 0x3050f536,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLScriptElement, 0x3050f530,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLNoShowElement, 0x3050f528,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLObjectElement, 0x3050f529,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFrameBase, 0x3050f541,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFrameElement, 0x3050f513,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLIFrameElement, 0x3050f51b,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLDivPosition, 0x3050f50f,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFieldSetElement, 0x3050f545,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLLegendElement, 0x3050f546,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLSpanFlow, 0x3050f544,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLFrameSetElement, 0x3050f514,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLBGsound, 0x3050f53c,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(DIID_DispIHTMLStyleElement, 0x3050f511,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);

DEFINE_GUID(CLSID_OfflineTrayAgent,
    0xE8BB6DC0,0x6B4E,0x11d0,0x92,0xDB,0x00,0xA0,0xC9,0x0C,0x2B,0xD7);
DEFINE_GUID(CLSID_ConnectionAgent,
    0xE6CC6978,0x6B6E,0x11D0,0xBE,0xCA,0x00,0xC0,0x4F,0xD9,0x40,0xBE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\asctlpch.h ===
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <olectl.h>
#include <shlobj.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\asctrls.cpp ===
//=--------------------------------------------------------------------------=
// astextmn.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// various globals which the framewrk requires
//
//

#include "asctlpch.h"

#define INITOBJECTS                // define the descriptions for our objects

#include "ipserver.h"
#include "localsrv.h"

#include "ctrlobj.h"
#include "globals.h"
#include "util.h"
#include "asinsctl.h"


/// for safe scripting
#include "cathelp.h"


const IID IID_ICatRegister = {0x0002E012,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const CATID CATID_SafeForScripting              = {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing   = {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// our Libid.  This should be the LIBID from the Type library, or NULL if you
// don't have one.
//
const CLSID *g_pLibid = &LIBID_ASControls;


//=--------------------------------------------------------------------------=
// Localization Information
//
// We need the following two pieces of information:
//    a. whether or not this DLL uses satellite DLLs for localization.  if
//       not, then the lcidLocale is ignored, and we just always get resources
//       from the server module file.
//    b. the ambient LocaleID for this in-proc server.  Controls calling
//       GetResourceHandle() will set this up automatically, but anybody
//       else will need to be sure that it's set up properly.
//
const VARIANT_BOOL g_fSatelliteLocalization =  FALSE;

LCID  g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);


//=--------------------------------------------------------------------------=
// your license key and where under HKEY_CLASSES_ROOT_LICENSES it's sitting
//
const WCHAR g_wszLicenseKey [] = L"";
const WCHAR g_wszLicenseLocation [] = L"";


WNDPROC g_ParkingWindowProc = NULL;

//=--------------------------------------------------------------------------=
// This Table describes all the automatible objects in your automation server.
// See AutomationObject.H for a description of what goes in this structure
// and what it's used for.
//
OBJECTINFO g_ObjectInfo[] = {
    CONTROLOBJECT(InstallEngineCtl),
    EMPTYOBJECT
};

const char g_szLibName[] = "ASControls";

//=--------------------------------------------------------------------------=
// IntializeLibrary
//=--------------------------------------------------------------------------=
// called from DllMain:DLL_PROCESS_ATTACH.  allows the user to do any sort of
// initialization they want to.
//
// Notes:
//
void InitializeLibrary(void)
{
    // TODO: initialization here.  control window class should be set up in
    // RegisterClassData.
}

//=--------------------------------------------------------------------------=
// UninitializeLibrary
//=--------------------------------------------------------------------------=
// called from DllMain:DLL_PROCESS_DETACH.  allows the user to clean up anything
// they want.
//
// Notes:
//
void UninitializeLibrary(void)
{
    // TODO: uninitialization here.  control window class will be unregistered
    // for you, but anything else needs to be cleaned up manually.
    // Please Note that the Window 95 DLL_PROCESS_DETACH isn't quite as stable
    // as NT's, and you might crash doing certain things here ...
}


//=--------------------------------------------------------------------------=
// CheckForLicense
//=--------------------------------------------------------------------------=
// users can implement this if they wish to support Licensing.  otherwise,
// they can just return TRUE all the time.
//
// Parameters:
//    none
//
// Output:
//    BOOL            - TRUE means the license exists, and we can proceed
//                      FALSE means we're not licensed and cannot proceed
//
// Notes:
//    - implementers should use g_wszLicenseKey and g_wszLicenseLocation
//      from the top of this file to define their licensing [the former
//      is necessary, the latter is recommended]
//
BOOL CheckForLicense(void)
{
    // TODO: decide whether or not your server is licensed in this function.
    // people who don't want to bother with licensing should just return
    // true here always.  g_wszLicenseKey and g_wszLicenseLocation are
    // used by IClassFactory2 to do some of the licensing work.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// RegisterData
//=--------------------------------------------------------------------------=
// lets the inproc server writer register any data in addition to that in
// any other objects.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL RegisterData(void)
{
   //=--------------------------------------------------------------------------=
// RegisterData
//=--------------------------------------------------------------------------=
// lets the inproc server writer register any data in addition to that in
// any other objects.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//    
   /// For safe scripting
   HRESULT hr;
   hr = CreateComponentCategory(CATID_SafeForScripting, L"Controls that are safely scriptable");
   if(SUCCEEDED(hr))
      hr = CreateComponentCategory(CATID_SafeForInitializing, L"Controls safely initializable from persistent data");
 
   if(SUCCEEDED(hr))
      hr = RegisterCLSIDInCategory(CLSID_InstallEngineCtl, CATID_SafeForScripting);
   if(SUCCEEDED(hr))
      hr = RegisterCLSIDInCategory(CLSID_InstallEngineCtl, CATID_SafeForInitializing);
 

   if(FAILED(hr))
   {
      DllUnregisterServer();
   }
   
   return (SUCCEEDED(hr) ? TRUE : FALSE);
}

//=--------------------------------------------------------------------------=
// UnregisterData
//=--------------------------------------------------------------------------=
// inproc server writers should unregister anything they registered in
// RegisterData() here.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL UnregisterData(void)
{
           /// For safe scripting
   HRESULT hr;
   hr = UnRegisterCLSIDInCategory(CLSID_InstallEngineCtl, CATID_SafeForScripting);
   hr = UnRegisterCLSIDInCategory(CLSID_InstallEngineCtl, CATID_SafeForInitializing);
   return TRUE;
}

BOOL CheckLicenseKey(LPWSTR wszCheckme)
{
	return TRUE;
}

BSTR GetLicenseKey(void)
{
	return SysAllocString(L"");
}



LPSTR MakeAnsiStrFromAnsi(LPSTR psz)
{
   LPSTR pszTmp;
   
   if(psz == NULL)
      return NULL;

   pszTmp = (LPSTR) CoTaskMemAlloc(lstrlenA(psz) + 1);
   if(pszTmp)
      lstrcpyA(pszTmp, psz);

   return pszTmp;
}


LPSTR CopyAnsiStr(LPSTR psz)
{
   LPSTR pszTmp;
   
   if(psz == NULL)
      return NULL;

   pszTmp = (LPSTR) new char[lstrlenA(psz) + 1];
   if(pszTmp)
      lstrcpyA(pszTmp, psz);

   return pszTmp;
}

//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to pull in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
extern "C" int _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
  FAIL("Pure virtual function called.");
  return 0;
}

#ifndef _X86_
extern "C" void _fpmath() {}
#endif



void * _cdecl malloc(size_t n)
{
#ifdef _MALLOC_ZEROINIT
        void* p = HeapAlloc(g_hHeap, 0, n);
        if (p != NULL)
                memset(p, 0, n);
        return p;
#else
        return HeapAlloc(g_hHeap, 0, n);
#endif
}

void * _cdecl calloc(size_t n, size_t s)
{
#ifdef _MALLOC_ZEROINIT
        return malloc(n * s);
#else
        void* p = malloc(n * s);
        if (p != NULL)
                memset(p, 0, n * s);
        return p;
#endif
}

void* _cdecl realloc(void* p, size_t n)
{
        if (p == NULL)
                return malloc(n);

        return HeapReAlloc(g_hHeap, 0, p, n);
}

void _cdecl free(void* p)
{
        if (p == NULL)
                return;

        HeapFree(g_hHeap, 0, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\iguids.cpp ===
//=--------------------------------------------------------------------------=
// iguids.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// contains the guids we will define 
//


#include "asctlpch.h"

#define INITGUID
#include <initguid.h>
#include <extobj.h>
#include "inseng.h"
#include "iasctrls.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\progdlg.h ===
class CInstallEngineCtl;

class CProgressDlg
{
   private:
      HWND hDlg;
      HWND hProgText;
      HWND hBigProg;
      HWND hLittleProg;

      DWORD dwLittleGoal;
      DWORD dwLittleFactor;

      DWORD dwBigGoal;
      DWORD dwBigFactor;

      DWORD dwOldBytes;
      DWORD dwOldMinutesLeft;

      void UpdateLittleTime(DWORD dwSecsLeft);


  public:
      CProgressDlg(HINSTANCE hInst, HWND hParent, HWND hGrandParent, CInstallEngineCtl *pctl);
      void DisplayWindow(BOOL fShow);
      ~CProgressDlg();
      void SetInsProgGoal(DWORD dwKBytes);
      void SetDownloadProgGoal(DWORD dwKBytes);
      void SetDownloadProgress(DWORD dwKBytes);
      void SetProgText(LPCSTR psz);
      void SetInsProgress(DWORD dwKBytes);
      HWND GetHWND() { return hDlg; }
      CInstallEngineCtl *pinsengctl;
      IInstallEngineTiming *ptimer;
};

INT_PTR CALLBACK ProgressDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\dispids.h ===
// dispids for the listctl

#define DISPID_CIFFILE                  5000
#define DISPID_VALIDATEOPTION           5001
#define DISPID_SETACTION                5002 
#define DISPID_PROCESSCOMPONENTS        5003
#define DISPID_ISCOMPONENTINSTALLED     5004
#define DISPID_SIZE                     5005
#define DISPID_EXEFILE                  5006
#define DISPID_ABORT                    5007
#define DISPID_BASEURL                  5008
#define DISPID_TOTALSIZE                5009
#define DISPID_DEPENDENCYSIZE           5010
#define DISPID_FINALIZEINSTALL          5011
#define DISPID_ENGINESTATUS             5012
#define DISPID_ENGINESTATUSCHANGE       5013
#define DISPID_EXTRACOMMAND             5014
#define DISPID_DOWNLOADDIR              5015
#define DISPID_HANDLEENGINEPROBLEM      5016
#define DISPID_CHECKFREESPACE           5017
#define DISPID_NAME                     5018
#define DISPID_SETLOCALCIF              5019
#define DISPID_SETSITESFILE             5020


#define DISPID_ONSTARTINSTALL           5100
#define DISPID_ONSTARTCOMPONENT         5101
#define DISPID_ONSTOPCOMPONENT          5102
#define DISPID_ONSTOPINSTALL            5103
#define DISPID_ONENGINEPROBLEM          5104
#define DISPID_ONCHECKFREESPACE         5105
#define DISPID_ONCOMPONENTPROGRESS      5106
#define DISPID_ONSTARTINSTALLEX         5107
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\cathelp.cpp ===
#include "asctlpch.h"
#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

   hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
   wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\asinsctl.h ===
#ifndef _ASINSCTL_H
#define _ASINSCTL_H

#include "ipserver.h"
#include "ctrlobj.h"
#include "internet.h"
#include "iasctrls.h"
#include "inseng.h"
#include "progdlg.h"


#define RESID_TOOLBOX_BITMAP 1

#define FINALIZE_DOREBOOT         0x00000001
#define FINALIZE_NOREBOOTPROMPT   0x00000002

#define PROCESSCOMPONENT_DELAYREBOOT  0x00000001
#define PROCESSCOMPONENT_NOPROGRESSUI 0x00000002
#define PROCESSCOMPONENT_NOSUMMARYUI  0x00000004

#define PROCESSCOMPONENT_NOINSTALLUI  0x00000080

#define MAX_URLS 5
#define ERROR_STRING_SIZE       2048
#define ERROR_STRING_INCREMENT  2048

//---------------------------------------------
// AUTORUN SETTINGS FOR WIN
//---------------------------------------------
#define WINDOWS_DEFAULT_AUTOPLAY_VALUE  0x095
#define WINDOWS_AUTOPLAY_OFF            0x0FF

typedef struct
{
   DWORD dwSize;
   DWORD dwStatus;
   DWORD dwSubstatus;
   DWORD dwPhase;
   DWORD dwResult;
   BSTR  strID;
   BSTR  strName;
   BSTR  strString;
   BSTR  chWin;
   BSTR  chInstall;
   BSTR  chDL;
   DWORD dwWin;
   DWORD dwInstall;
   DWORD dwDL;
} CALLBACK_PARAMS;


// Global needed in CInstallEngine for suppressing CD Auto Splash.
extern UINT          g_uCDAutorunMsg;
extern unsigned long g_ulOldAutorunSetting;
unsigned long SetAutorunSetting(unsigned long ulNewSettting);

//=--------------------------------------------------------------------------=
// CInstallEngine
//=--------------------------------------------------------------------------=
// our control.
//
class CInstallEngineCtl : public COleControl, public IInstallEngineCtl, public IInstallEngineCallback, public ISupportErrorInfo
{

   friend class CProgressDlg;
   friend INT_PTR CALLBACK ProgressDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
   friend DWORD WINAPI DoInstall(LPVOID pv);
   friend INT_PTR CALLBACK LocationDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
   friend INT_PTR CALLBACK DiskSpaceDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

   public:
      // IUnknown methods
      //
      DECLARE_STANDARD_UNKNOWN();

      // IDispatch methods
      //
      DECLARE_STANDARD_DISPATCH();

      // ISupportErrorInfo methods
      //
      DECLARE_STANDARD_SUPPORTERRORINFO();

      // IInstallEngine methods
      //
      STDMETHOD(get_ReadyState)(THIS_ long FAR* thestate);
      STDMETHOD(SetCifFile)(THIS_ BSTR strCabName, BSTR strCifName);
      STDMETHOD(put_BaseUrl)(THIS_ BSTR strBaseUrl);
      STDMETHOD(put_DownloadDir)(THIS_ BSTR strDownloadDir);
      STDMETHOD(SetAction)(THIS_ BSTR ComponentID, long action, long *lResult);
      STDMETHOD(IsComponentInstalled)(THIS_ BSTR ComponentID, long *lResult);
      STDMETHOD(ProcessComponents)(THIS_ long lFlag);
      STDMETHOD(get_Size)(THIS_ BSTR ComponentID, long FAR* thestate);
      STDMETHOD(get_DisplayName)(THIS_ BSTR ComponentID, BSTR *name);
      STDMETHOD(Abort)(THIS_ long lFlags);
      STDMETHOD(get_TotalDownloadSize)(THIS_ long FAR* totalsize);
      STDMETHOD(get_TotalDependencySize)(THIS_ long FAR* totaldepsize);
      STDMETHOD(FinalizeInstall)(THIS_ long lFlag);
      STDMETHOD(get_EngineStatus)(THIS_ long FAR* theenginestatus);
      STDMETHOD(HandleEngineProblem)(THIS_ long lFlag);
      STDMETHOD(CheckFreeSpace)(THIS_ long lPad, long FAR* lEnough);
      STDMETHOD(SetLocalCif)(THIS_ BSTR strCif, long FAR* lResult);
      STDMETHOD(SetSitesFile)(THIS_ BSTR strUrl, BSTR strRegion, BSTR strLocale, long FAR* lResult);




      //	Install engine callbacks
      STDMETHOD(OnStartInstall)(DWORD dwDLSize, DWORD dwInstallSize);
	   STDMETHOD(OnStartComponent)(LPCSTR pszID, DWORD dwDLSize, DWORD dwInstallSize, LPCSTR pszName);
	   STDMETHOD(OnComponentProgress)(LPCSTR pszID, DWORD dwPhase, LPCSTR pszName, LPCSTR pszMsgString, ULONG progress, ULONG dwMax );
      STDMETHOD(OnStopComponent)(LPCSTR pszID, HRESULT hrError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus);
      STDMETHOD(OnStopInstall)(HRESULT hrError, LPCSTR szError, DWORD dwStatus);
      STDMETHOD(OnEngineStatusChange)(DWORD dwStatus, DWORD substatus);
      STDMETHOD(OnEngineProblem)(DWORD dwProblem, LPDWORD pdwAction);

      // OLE Control stuff follows:
      //
      CInstallEngineCtl(IUnknown *pUnkOuter, BOOL *pbSuccess);
      virtual ~CInstallEngineCtl();
      // static creation function.  all controls must have one of these!
      //
      static IUnknown *Create(IUnknown *);

      // Helper functions to fire our events
      void _FireOnStartInstallEvent(DWORD dwTotalSize);
      void _FireOnStartComponentEvent(LPCSTR pszID, DWORD dwTotalSize, LPCSTR pszName);
      void _FireOnStopComponentEvent(LPCSTR pszID, HRESULT hrError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus);
      void _FireOnStopInstallEvent(HRESULT hrError, LPCSTR szError, DWORD dwStatus);
      void _FireEngineStatusChange(DWORD dwEngineStatus, DWORD substatus);
      void _FireOnEngineProblem(DWORD dwProblem);
      void _FireOnComponentProgressEvent(LPCSTR pszID, DWORD dwPhase, LPCSTR pszString, LPCSTR pszMsgString, ULONG progress, ULONG themax);
      void _FireOnComponentProgress(DWORD lPhase, DWORD lSoFar, DWORD lTotal);
      void _FireOnStartInstallExEvent(DWORD dwDLSize, DWORD dwInsSize);

   private:
      // overridables that the control must implement.
      //
      STDMETHOD(LoadBinaryState)(IStream *pStream);
      STDMETHOD(SaveBinaryState)(IStream *pStream);
      STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
      STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault);
      STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize);

      STDMETHOD(FreezeEvents)(BOOL bFreeze);

      // Window stuff
      virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam);
      virtual BOOL RegisterClassData(void);

      // internal QI
      virtual HRESULT InternalQueryInterface(REFIID, void **);

      // before and after window is created
      virtual void BeforeCreateWindow(void);
	   virtual BOOL AfterCreateWindow(void);


      void       _InitProgressDialog();
      void       _DoInstall();
      HRESULT    _CheckInstallPath(BOOL *pfNeedDownload);
      BOOL       _PathIsIEInstallPoint(LPCSTR pszPath);
      HRESULT    _PickWebSites(LPCSTR pszSites, LPCSTR pszLocale, LPCSTR pszRegion, BOOL bKeepExisting);
      BOOL       _IsEnoughSpace(LPSTR szSpace1, DWORD dwSize1, LPSTR szSpace2, DWORD dwSize2,
                                       LPSTR szSpace3, DWORD dwSize3);
      HRESULT    _CheckForDiskSpace();
      HRESULT    _ShowDiskSpaceDialog();
      void       _FireCancel(DWORD dwCancel);
      LONG       _OpenJITKey(HKEY *hKey, REGSAM samAttr);
      void       _DeleteURLList();
      void       _WriteURLList();
      void       _WriteRegionToReg(LPSTR szRegion);
      void       _PickRegionAndFirstSite(IDownloadSite **ppISite, UINT uNumSites, LPSTR pszRegion, UINT *puFirstSite);
      void       _PickRandomSites(IDownloadSite **ppISite, BYTE *pPicks, UINT uNumSites, UINT uNumToPick, LPSTR pszRegion);
      void       MarkJITInstall();

      BOOL             _fInOnEngineProblem:1;
      BOOL             _fEventToFire:1;
      BOOL             _fNeedReboot:1;
      BOOL             _fLocalCifSet:1;
      BOOL             _fReconcileCif:1;
      BOOL             _fDoingIEInstall:1;
      BOOL             _fInstalling:1;
      BOOL             _fJITInstall:1;


      DWORD            _dwOldStatus;
      DWORD            _dwAction;
      DWORD            _dwInstallStatus;
      UINT             _uInstallMode;
      UINT             _uInstallPad;

      HRESULT          _hResult;

      DWORD            _dwSavedEngineStatus;
      DWORD            _dwSavedSubStatus;
      DWORD            _dwFreezeEvents;
      DWORD            _uAllowGrovel;


      BSTR             _strCurrentID;
      BSTR             _strCurrentName;
      BSTR             _strCurrentString;
      DWORD            m_readyState;
      LPSTR            _pszErrorString;
      int              _iErrorStringSize;
      DWORD            _dwProcessComponentsFlags;
      HICON            _hIcon;
      DWORD            _dwLastPhase;
      CProgressDlg    *_pProgDlg;
      IInstallEngine2 *_pinseng;
      DWORD            _dwMSTrustKey;
      HANDLE           _hDone;
      UINT             _uCurrentUrl;
      LPSTR            _rpszUrlList[MAX_URLS];
      char             _szCifCab[MAX_PATH];
      char             _szCifFile[MAX_PATH];
      char             _szDownloadDir[MAX_PATH];
      BOOL             _bCancelPending;
      BOOL             _bDeleteURLList;
      BOOL             _bNewWebSites;
};

DWORD WINAPI DoInstall(LPVOID pv);

DEFINE_CONTROLOBJECT(InstallEngineCtl,     // Name of object
    &CLSID_InstallEngineCtl,               // CLSID of object
    "InstallEngineCtl",                    // ProgID
    CInstallEngineCtl::Create,             // Static create function
    1,                            // Version
    &IID_IInstallEngineCtl,                // Primary dispatch
    NULL,                         // name of help file
    &DIID_DInstallEngineCtlEvents,         // event interface
    OLEMISC_SETCLIENTSITEFIRST|OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_RECOMPOSEONRESIZE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT,
    0,                            // Activation policy
    RESID_TOOLBOX_BITMAP,         // toolbox id
    "InstallEngineCtlWndClass",            // Window class
    0,                            // number of pages
    NULL,                         // array of property pages
    0,                            // Number of verbs
    NULL);                        // Array of verbs

#define OBJECT_INSTALLENGINECTL 0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\progdlg.cpp ===
#include "asctlpch.h"
#include "asinsctl.h"
#include "resource.h"
#include "util2.h"


#define WM_LAUNCHCOMPLETE  WM_USER+121

CProgressDlg::CProgressDlg(HINSTANCE hInst, HWND hParent, HWND hGrandParent, CInstallEngineCtl *ctl)
{
   RECT r;
   dwBigGoal = 0;
   dwLittleGoal = 0;
   dwOldMinutesLeft = 0xffffffff;
   hProgText = NULL;
   hBigProg  = NULL;
   hLittleProg = NULL;
   dwOldBytes = 0;
   LPSTR pszTitle = NULL;

   hDlg = CreateDialog(hInst, MAKEINTRESOURCE(IDD_PROGRESS), hGrandParent, ProgressDlgProc);
      // Get the Display title from inseng
   ctl->_pinseng->GetDisplayName(NULL, &pszTitle);
   ctl->_pinseng->SetHWND(hDlg);
   if(pszTitle)
   {
      SetWindowText(hDlg, pszTitle);
      CoTaskMemFree(pszTitle);
   }
   SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) this);
   if(hGrandParent)
   {
      GetWindowRect(hGrandParent, &r);
      SetWindowPos(hDlg, 0, r.left, r.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
   }

   pinsengctl = ctl;
   pinsengctl->_pinseng->QueryInterface(IID_IInstallEngineTiming, (void **) &ptimer);
}

CProgressDlg::~CProgressDlg()
{
   if(ptimer)
      ptimer->Release();

   pinsengctl->_pinseng->SetHWND(GetParent(hDlg));

   DestroyWindow(hDlg);
}

void CProgressDlg::DisplayWindow(BOOL fShow)
{
   if(fShow)
      ShowWindow(hDlg, SW_SHOWNORMAL);
   else
      ShowWindow(hDlg, SW_HIDE);
}


INT_PTR CALLBACK ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
       case WM_INITDIALOG:
          // Do some init stuff
          SetFontForControl(hwnd, IDC_PROG_TEXT);
          Animate_Open( GetDlgItem( hwnd, IDC_ANIM ), MAKEINTRESOURCE(IDA_FILECOPY) );
          Animate_Play( GetDlgItem( hwnd, IDC_ANIM ), 0, -1, -1 );
          return FALSE;

       case WM_COMMAND:
          switch (wParam)
          {
             case IDCANCEL:
                {
                   char szBuf[256];
                   char szTitle[128];
                   HRESULT hr = S_FALSE;
                   int id;

                   CProgressDlg *p = (CProgressDlg *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

                   LoadSz(IDS_TITLE, szTitle, sizeof(szTitle));

                   if(p->pinsengctl)
                      hr = p->pinsengctl->_pinseng->Suspend();

                   if(hr == S_FALSE)
                      id = IDS_CONFIRMCANCEL_UNSAFE;
                   else
                      id = IDS_CONFIRMCANCEL;

                   LoadSz(id, szBuf, sizeof(szBuf));

                   if(MessageBox(hwnd, szBuf, szTitle, MB_YESNO | MB_ICONQUESTION) == IDYES)
                   {
                      if(p->pinsengctl)
                         p->pinsengctl->_FireCancel(ABORTINSTALL_NORMAL);
                      EnableWindow(GetDlgItem(hwnd, IDCANCEL), FALSE);
                   }
                   if(p->pinsengctl)
                      p->pinsengctl->_pinseng->Resume();
                }
                break;

             default:
                return FALSE;
          }
          break;

       default:
          return(FALSE);
    }
    return TRUE;
}

void CProgressDlg::SetInsProgGoal(DWORD dwKBytes)
{
   dwBigFactor = dwKBytes / 65000 + 1;
   dwBigGoal = dwKBytes;

   if(dwBigGoal == 0)
      dwBigGoal = 1;

   if(hBigProg == NULL)
      hBigProg = GetDlgItem(hDlg, IDC_PROG_BIG);

   SendMessage(hBigProg, PBM_SETRANGE, 0, MAKELPARAM(0, dwKBytes/dwBigFactor));
}


void CProgressDlg::SetDownloadProgGoal(DWORD dwKBytes)
{
   dwLittleFactor = dwKBytes / 65000 + 1;
   dwLittleGoal = dwKBytes;

   if(dwLittleGoal == 0)
      dwLittleGoal = 1;

   if(hLittleProg == NULL)
      hLittleProg = GetDlgItem(hDlg, IDC_PROG_LITTLE);

   SendMessage(hLittleProg,PBM_SETRANGE,0,MAKELPARAM(0,dwKBytes/dwLittleFactor));
   SetDlgItemText(hDlg, IDC_LITTLETIMELEFT, "");
   dwOldMinutesLeft = 0xffffffff;
}

void CProgressDlg::SetInsProgress(DWORD dwKBytes)
{
   INSTALLPROGRESS pinsprog;
   DWORD progress;
   DWORD bytessofar;
   char szRes[256];
   char szBuf[256];
   DWORD remaining;

   if( (dwOldBytes == 0) && (dwKBytes != 0) )
   {
      ShowWindow(GetDlgItem(hDlg, IDC_BYTESLEFT), SW_HIDE);
      ShowWindow(GetDlgItem(hDlg, IDC_LITTLETIMELEFT), SW_HIDE);
   }

   ptimer->GetInstallProgress(&pinsprog);

   remaining = pinsprog.dwInstallKBRemaining;

   progress = (dwBigGoal - remaining)/dwBigFactor;

   // write out bytes remiaining

   if(dwBigGoal >= remaining)
      bytessofar = dwBigGoal - remaining;
   else
      bytessofar = 0;

   if(dwOldBytes != bytessofar)
   {
      LoadSz(IDS_PERCENT, szRes, sizeof(szRes));
      wsprintf(szBuf, szRes, 100*bytessofar/dwBigGoal);

      SetDlgItemText(hDlg, IDC_PERCENT, szBuf);
      dwOldBytes = bytessofar;
   }



   if(hBigProg == NULL)
      hBigProg = GetDlgItem(hDlg, IDC_PROG_BIG);

   SendMessage(hBigProg, PBM_SETPOS, progress, 0);
}

void CProgressDlg::SetDownloadProgress(DWORD dwKBytes)
{
   char szBuf[128];
   char szRes[128];
   INSTALLPROGRESS pinsprog;
   DWORD remaining;
   DWORD progress;
   DWORD bytessofar;

   ptimer->GetInstallProgress(&pinsprog);
   remaining = pinsprog.dwDownloadKBRemaining;

   progress = (dwLittleGoal - remaining)/dwLittleFactor;

   // write out bytes remiaining

   if(dwLittleGoal >= remaining)
      bytessofar = dwLittleGoal - remaining;
   else
      bytessofar = 0;

   if(dwOldBytes != bytessofar)
   {
      LoadSz(IDS_KBYTES , szRes, sizeof(szRes));
      wsprintf(szBuf, szRes, bytessofar, dwLittleGoal);

      SetDlgItemText(hDlg, IDC_BYTESLEFT, szBuf);
      dwOldBytes = bytessofar;
   }

   SendMessage(hLittleProg, PBM_SETPOS, progress, 0);

   remaining = pinsprog.dwDownloadSecsRemaining;

   if(remaining != 0xffffffff)
      UpdateLittleTime(remaining);
}

void CProgressDlg::SetProgText(LPCSTR psz)
{
   if(hProgText == NULL)
      hProgText = GetDlgItem(hDlg, IDC_PROG_TEXT);

   SetWindowText(hProgText, psz);
}


void CProgressDlg::UpdateLittleTime(DWORD dwSecsLeft)
{
   char szBuf[128];
   char szRes[128];
   szBuf[0] = 0;
   UINT id;
   UINT numParams = 2;

   DWORD dwHoursLeft = dwSecsLeft / 3600;
   DWORD dwMinutesLeft = (dwSecsLeft % 3600) / 60;
   if(dwMinutesLeft == 59)
   {
      dwHoursLeft++;
      dwMinutesLeft = 0;
   }

   // no need to update ui
   if(dwOldMinutesLeft == dwMinutesLeft)
      return;

   if(dwHoursLeft > 0)
   {
      if(dwHoursLeft > 1)
      {
         if(dwMinutesLeft == 0)
         {
            id = IDS_HOURSLEFT;
            numParams = 1;
         }
         else if(dwMinutesLeft == 1)
         {
            id = IDS_HOURSMINUTELEFT;
         }
         else
            id = IDS_HOURSMINUTESLEFT;
      }
      else
      {
         if(dwMinutesLeft == 0)
         {
            id = IDS_HOURLEFT;
            numParams = 1;
         }
         else if(dwMinutesLeft == 1)
         {
            id = IDS_HOURMINUTELEFT;
         }
         else
            id = IDS_HOURMINUTESLEFT;
      }
      LoadSz(id, szRes, sizeof(szRes));
      if(numParams == 1)
         wsprintf(szBuf, szRes, dwHoursLeft);
      else
         wsprintf(szBuf, szRes, dwHoursLeft, dwMinutesLeft);
   }
   else if(dwMinutesLeft > 0)
   {
      LoadSz(IDS_MINUTESLEFT , szRes, sizeof(szRes));
      wsprintf(szBuf, szRes, dwMinutesLeft + 1);
   }
   else
      LoadSz(IDS_SECONDSLEFT, szBuf, sizeof(szBuf));

   dwOldMinutesLeft = dwMinutesLeft;

   SetDlgItemText(hDlg, IDC_LITTLETIMELEFT, szBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\resource.h ===
// our one lonely icon

#define IDI_INSTALLENGINE               101
#define IDI_CD                          102


// the progress dialog

#define IDD_PROGRESS                    101
#define IDC_PROG_LITTLE                 1000
#define IDC_PROG_BIG                    1001
#define IDC_PROG_TEXT                   1002
#define IDC_ANIM                        1004
#define IDC_BIGTIMELEFT                 1005
#define IDC_LITTLETIMELEFT              1006
#define IDC_LITTLESTATIC                1007
#define IDC_BYTESLEFT                   1008
#define IDC_PERCENT                     1009

//
#define IDD_LOCATE                      102
#define IDC_TEXT1                       1000
#define IDC_TEXT2                       1001
#define IDC_LOCATIONLIST                1002
#define IDC_BROWSE                      1003
#define IDC_INTERNET                    1004

#define IDD_DISKSPACE                   103
#define IDC_SPACE1                      1000
#define IDC_SPACE2                      1001
#define IDC_SPACE3                      1002

// site dlg
#define IDD_SITELIST                    104
#define IDC_REGIONS                     1000
#define IDC_SITES                       1001


#define IDC_STATIC                      -1

// misc. ids

#define IDA_FILECOPY                    1003


// String ids

#define IDS_DOWNLOADING                 3

#define IDS_INSTALLING                  5

#define IDS_TITLE                       7
#define IDS_INSTALLCANCELLED            8
#define IDS_ERRDOINGINSTALL             10
#define IDS_CONFIRMCANCEL               11
#define IDS_REBOOT                      13
#define IDS_PREPARE                     14
#define IDS_NOPHASE                     15
#define IDS_EXTRACTING                  16
#define IDS_DISPLAYNAME                 17
#define IDS_ERRGENERAL                  18
#define IDS_ERRPREPARE                  19
#define IDS_ERRDOWNLOAD                 20
#define IDS_ERREXTRACTING               21
#define IDS_ERRINSTALLING               22
#define IDS_ERRUNKNOWN                  23
#define IDS_ERRNOTTRUSTED               24
#define IDS_SUMMARYHEADING              25
#define IDS_DEPENDNAME                  26
#define IDS_ERRDEPENDENCY               27
#define IDS_CHECKTRUST                  28
#define IDS_SUCCEEDED                   29
#define IDS_TIMEUNKNOWN                 33
#define IDS_MINUTESLEFT                 34
#define IDS_SECONDSLEFT                 35
#define IDS_HOURSMINUTESLEFT            36
#define IDS_HOURSMINUTELEFT             37
#define IDS_HOURSLEFT                   38
#define IDS_HOURMINUTESLEFT             39
#define IDS_HOURMINUTELEFT              40
#define IDS_HOURLEFT                    41
#define IDS_KBYTES                      42
#define IDS_PHASE_COPYING               43
#define IDS_DOWNLOADTITLE               44
#define IDS_BYTESRECEIVED               45
#define IDS_PHASE_RETRYING              46
#define IDS_PERCENT                     47
#define IDS_GROVELMESSAGE               48
#define IDS_CONFIRMCANCEL_UNSAFE        49
#define IDS_FINISH_TITLE                50
#define IDS_CDNOTFOUND                  51
#define IDS_CDPLEASEINSERT              52
#define IDS_NETWORKNOTFOUND             53
#define IDS_NETWORKPLEASEFIND           54
#define IDS_INTERNET                    55
#define IDS_NOTVALIDLOCATION            56
#define IDS_NOTVALIDLOCATIONTITLE       57
#define IDS_DISKSPACE                   58
#define IDS_FINDFOLDER                  59
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\asinsctl.cpp ===
//=--------------------------------------------------------------------------=
// inseng.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
//
#include "asctlpch.h"

#include "ipserver.h"
#include <wininet.h>
#include "util.h"
#include "globals.h"
#include "asinsctl.h"
#include "dispids.h"
#include "resource.h"
#include "util2.h"
#include <mshtml.h>

// for ASSERT and FAIL
//
SZTHISFILE

WCHAR wszInsFile [] = L"InstallList";
WCHAR wszBaseUrl [] = L"BaseUrl";
WCHAR wszCabName [] = L"CabName";

#define EVENT_ONSTARTINSTALL    0
#define EVENT_ONSTARTCOMPONENT  1
#define EVENT_ONSTOPCOMPONENT   2
#define EVENT_ONSTOPINSTALL     3
#define EVENT_ONENGINESTATUSCHANGE  4
#define EVENT_ONENGINEPROBLEM  5
#define EVENT_ONCHECKFREESPACE 6
#define EVENT_ONCOMPONENTPROGRESS 7
#define EVENT_ONSTARTINSTALLEX     8

#define EVENT_CANCEL  10

static VARTYPE rgI4[] = { VT_I4 };
static VARTYPE rgI4_2[] = { VT_I4, VT_I4 };
static VARTYPE rgStartComponent[] = { VT_BSTR, VT_I4, VT_BSTR };
static VARTYPE rgStopComponent[] = { VT_BSTR, VT_I4, VT_I4, VT_BSTR, VT_I4 };
static VARTYPE rgStopInstall[] = { VT_I4, VT_BSTR, VT_I4 };
static VARTYPE rgEngineProblem[] = { VT_I4 };
static VARTYPE rgCheckFreeSpace[] = { VT_BSTR, VT_I4, VT_BSTR, VT_I4, VT_BSTR, VT_I4 };
static VARTYPE rgComponentProgress[] = { VT_BSTR, VT_I4, VT_BSTR, VT_BSTR, VT_I4, VT_I4 };


#define WM_INSENGCALLBACK  WM_USER+34

static EVENTINFO rgEvents [] = {
    { DISPID_ONSTARTINSTALL, 1, rgI4 },           // (long percentDone)
    { DISPID_ONSTARTCOMPONENT, 3, rgStartComponent },
    { DISPID_ONSTOPCOMPONENT, 5, rgStopComponent },
    { DISPID_ONSTOPINSTALL, 3, rgStopInstall },
    { DISPID_ENGINESTATUSCHANGE, 2, rgI4_2 },
    { DISPID_ONENGINEPROBLEM, 1, rgEngineProblem },
    { DISPID_ONCHECKFREESPACE, 6, rgCheckFreeSpace },
    { DISPID_ONCOMPONENTPROGRESS, 6, rgComponentProgress },
    { DISPID_ONSTARTINSTALLEX, 2, rgI4_2 },
};

UINT          g_uCDAutorunMsg;
unsigned long g_ulOldAutorunSetting;

const char g_cszIEJITInfo[] = "Software\\Microsoft\\Active Setup\\JITInfo";
const char g_cszPolicyExplorer[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer";
const char g_cszAutorunSetting[] = "NoDriveTypeAutoRun";

//=---------------------------------------------
// SetAutorunSetting
//=---------------------------------------------
unsigned long SetAutorunSetting(unsigned long ulValue)
{
    HKEY          hKey;
    unsigned long ulOldSetting;
    unsigned long ulNewSetting = ulValue;
    DWORD         dwSize = sizeof(unsigned long);

    if( RegOpenKeyEx(HKEY_CURRENT_USER, g_cszPolicyExplorer , 0, KEY_READ|KEY_WRITE, &hKey ) == ERROR_SUCCESS )
    {
        if( RegQueryValueEx(hKey, g_cszAutorunSetting, 0, NULL, (unsigned char*)&ulOldSetting,  &dwSize ) == ERROR_SUCCESS )
        {
            RegSetValueEx(hKey, g_cszAutorunSetting, 0, REG_BINARY, (const unsigned char*)&ulNewSetting, 4);
        }
        else
            ulOldSetting = WINDOWS_DEFAULT_AUTOPLAY_VALUE;

        RegFlushKey( hKey );
        RegCloseKey( hKey );
    }

    return ulOldSetting;
}


//=--------------------------------------------------------------------------=
// CInstallEngineCtl::Create
//=--------------------------------------------------------------------------=
// global static function that creates an instance of the control an returns
// an IUnknown pointer for it.
//
// Parameters:
//    IUnknown *        - [in] controlling unknown for aggregation
//
// Output:
//    IUnknown *        - new object.
//
// Notes:
//

IUnknown *CInstallEngineCtl::Create(IUnknown *pUnkOuter)
{
    // make sure we return the private unknown so that we support aggegation
    // correctly!
    //
    BOOL bSuccess;

    CInstallEngineCtl *pNew = new CInstallEngineCtl(pUnkOuter, &bSuccess);
    if(bSuccess)
       return pNew->PrivateUnknown();
    else
    {
       delete pNew;
       return NULL;
    }
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::CInstallEngineCtl
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *        - [in]
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor, safe here
CInstallEngineCtl::CInstallEngineCtl(IUnknown *pUnkOuter, BOOL *pbSuccess)
  : COleControl(pUnkOuter, OBJECT_INSTALLENGINECTL, (IDispatch *)this)
{
   HRESULT hr;
   DWORD   dwVersion = 0;

   *pbSuccess = TRUE;
   _hIcon = NULL;

   // null out all base urls
   ZeroMemory( _rpszUrlList, sizeof(LPSTR) * MAX_URLS);
   _uCurrentUrl = 0;

   _pProgDlg = NULL;
   _pinseng = NULL;
   _pszErrorString = NULL;
   _hDone = NULL;
   _hResult = NOERROR;
   m_readyState = READYSTATE_COMPLETE;
   _uAllowGrovel = 0xffffffff;
   _fNeedReboot = FALSE;
   _szDownloadDir[0] = 0;
   _fEventToFire = FALSE;
   _dwSavedEngineStatus = 0;
   _dwSavedSubStatus = 0;
   _dwFreezeEvents = 0;
   _dwProcessComponentsFlags = 0;
   _dwMSTrustKey = (DWORD)-1;
   _uCurrentUrl = 0xffffffff;
   _fReconcileCif = FALSE;
   _fLocalCifSet = FALSE;
   _fDoingIEInstall = FALSE;
   _uInstallMode = 0;
   _uInstallPad  = 0;
   _strCurrentID = NULL;
   _strCurrentName = NULL;
   _strCurrentString = NULL;
   _fInstalling = FALSE;
   _bCancelPending = FALSE;
   _bDeleteURLList = FALSE;
   _bNewWebSites = FALSE;
   _fJITInstall = FALSE;

   // Register for the special CD Autorun message.
   g_uCDAutorunMsg = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));


   hr = CoCreateInstance(CLSID_InstallEngine, NULL, CLSCTX_INPROC_SERVER,
                         IID_IInstallEngine2,(void **) &_pinseng);

   if(_pinseng)
   {
      _pinseng->SetDownloadDir(NULL);
      _pinseng->SetInstallOptions(INSTALLOPTIONS_DOWNLOAD |
                                  INSTALLOPTIONS_INSTALL |
                                  INSTALLOPTIONS_DONTALLOWXPLATFORM);
      _pinseng->SetHWND(GetActiveWindow());
      _pinseng->RegisterInstallEngineCallback((IInstallEngineCallback *)this);
   }
   else
      *pbSuccess = FALSE;

   _dwLastPhase = 0xffffffff;

   // set up our initial size ... + 6 so we can have raised edge
   m_Size.cx = 6 + GetSystemMetrics(SM_CXICON);
   m_Size.cy = 6 + GetSystemMetrics(SM_CYICON);
#ifdef TESTCERT
   UpdateTrustState();
#endif
   SetControlFont();
}
#pragma warning(default:4355)  // using 'this' in constructor

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::~CInstallEngineCtl
//=--------------------------------------------------------------------------=
//
// Notes:
//
CInstallEngineCtl::~CInstallEngineCtl()
{
   if(_pinseng)
   {
      _pinseng->SetHWND(NULL);
      _pinseng->UnregisterInstallEngineCallback();
      _pinseng->Release();
   }

   for(int i = 0; i < MAX_URLS; i++)
      if(_rpszUrlList[i])
         delete _rpszUrlList[i];

   // Is all this needed? Only in case where OnStopInstall is never called...
   if(_pProgDlg)
      delete _pProgDlg;

   if(_pszErrorString)
      free(_pszErrorString);

   if (_dwMSTrustKey != (DWORD)-1)
      WriteMSTrustKey(FALSE, _dwMSTrustKey);
#ifdef TESTCERT
   ResetTestrootCertInTrustState();
#endif

   // delete ActiveSetup value from IE4\Options
   WriteActiveSetupValue(FALSE);
   if (g_hFont)
   {
       DeleteObject(g_hFont);
       g_hFont = NULL;
   }
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl:RegisterClassData
//=--------------------------------------------------------------------------=
// register the window class information for your control here.
// this information will automatically get cleaned up for you on DLL shutdown.
//
// Output:
//    BOOL            - FALSE means fatal error.
//
// Notes:
//
BOOL CInstallEngineCtl::RegisterClassData()
{
    WNDCLASS wndclass;

    // TODO: register any additional information you find interesting here.
    //       this method is only called once for each type of control
    //
    memset(&wndclass, 0, sizeof(WNDCLASS));
    wndclass.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
    wndclass.lpfnWndProc    = COleControl::ControlWindowProc;
    wndclass.hInstance      = g_hInstance;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH)(COLOR_WINDOW);
    wndclass.lpszClassName  = WNDCLASSNAMEOFCONTROL(OBJECT_INSTALLENGINECTL);

    return RegisterClass(&wndclass);
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::BeforeCreateWindow
//=--------------------------------------------------------------------------=
// called just before the window is created.  Great place to set up the
// window title, etc, so that they're passed in to the call to CreateWindowEx.
// speeds things up slightly.
//
// Notes:
//
void CInstallEngineCtl::BeforeCreateWindow()
{

}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

BOOL CInstallEngineCtl::AfterCreateWindow()
{
   MarkJITInstall();
   return TRUE;
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::InternalQueryInterface
//=--------------------------------------------------------------------------=
// qi for things only we support.
//
// Parameters:
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CInstallEngineCtl::InternalQueryInterface(REFIID  riid, void  **ppvObjOut)
{
    IUnknown *pUnk;

    *ppvObjOut = NULL;

    // TODO: if you want to support any additional interrfaces, then you should
    // indicate that here.  never forget to call COleControl's version in the
    // case where you don't support the given interface.
    //
    if (DO_GUIDS_MATCH(riid, IID_IInstallEngine)) {
        pUnk = (IUnknown *)(IInstallEngine *)this;
    } else{
        return COleControl::InternalQueryInterface(riid, ppvObjOut);
    }

    pUnk->AddRef();
    *ppvObjOut = (void *)pUnk;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::LoadTextState
//=--------------------------------------------------------------------------=
// load in our text state for this control.
//
// Parameters:
//    IPropertyBag *        - [in] property bag to read from
//    IErrorLog *           - [in] errorlog object to use with proeprty bag
//
// Output:
//    HRESULT
//
// Notes:
//    - NOTE: if you have a binary object, then you should pass an unknown
//      pointer to the property bag, and it will QI it for IPersistStream, and
//      get said object to do a Load()
//
STDMETHODIMP CInstallEngineCtl::LoadTextState(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog)
{
   VARIANT v;
   VARIANT v2;
   HRESULT hr;

	VariantInit(&v);

   v.vt = VT_BSTR;
   v.bstrVal = NULL;

	VariantInit(&v2);

   v2.vt = VT_BSTR;
   v2.bstrVal = NULL;
	// try to load in the property.  if we can't get it, then leave
   // things at their default.
   //

   v.vt = VT_BSTR;
   v.bstrVal = NULL;

   hr = pPropertyBag->Read(::wszBaseUrl, &v, pErrorLog);
   if(SUCCEEDED(hr))
      hr = put_BaseUrl(v.bstrVal);

   VariantClear(&v);

   //
   // IMPORTANT: Trident no longer defaults to VT_BSTR if no variant type is specified
   //
   v.vt = VT_BSTR;
   v.bstrVal = NULL;

   hr = pPropertyBag->Read(::wszCabName, &v, pErrorLog);
   if(SUCCEEDED(hr))
      hr = pPropertyBag->Read(::wszInsFile, &v2, pErrorLog);
   if(SUCCEEDED(hr))
   {
      hr = SetCifFile(v.bstrVal, v2.bstrVal);
   }
   VariantClear(&v);
   VariantClear(&v2);

   return S_OK;
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::LoadBinaryState
//=--------------------------------------------------------------------------=
// loads in our binary state using streams.
//
// Parameters:
//    IStream *            - [in] stream to write to.
//
// Output:
//    HRESULT
//
// Notes:
//
const DWORD STREAMHDR_MAGIC = 12345678L;

STDMETHODIMP CInstallEngineCtl::LoadBinaryState(IStream *pStream)
{
	DWORD		sh;
   HRESULT		hr;

   // first read in the streamhdr, and make sure we like what we're getting
   //
   hr = pStream->Read(&sh, sizeof(sh), NULL);
   RETURN_ON_FAILURE(hr);

   // sanity check
   //
   if (sh != STREAMHDR_MAGIC )
      return E_UNEXPECTED;

	return(S_OK);
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::SaveTextState
//=--------------------------------------------------------------------------=
// saves out the text state for this control using a property bag.
//
// Parameters:
//    IPropertyBag *        - [in] the property bag with which to work.
//    BOOL                  - [in] if TRUE, then write out ALL properties, even
//                            if they're their the default value ...
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CInstallEngineCtl::SaveTextState(IPropertyBag *pPropertyBag, BOOL fWriteDefaults)
{
   return S_OK;
}

//=--------------------------------------------------------------------------=
// CInstallEngineCtl::SaveBinaryState
//=--------------------------------------------------------------------------=
// save out the binary state for this control, using the given IStream object.
//
// Parameters:
//    IStream  *             - [in] save to which you should save.
//
// Output:
//    HRESULT
//
// Notes:
//    - it is important that you seek to the end of where you saved your
//      properties when you're done with the IStream.
//
STDMETHODIMP CInstallEngineCtl::SaveBinaryState(IStream *pStream)
{
   DWORD sh = STREAMHDR_MAGIC;
   HRESULT hr;

   // write out the stream hdr.
   //
   hr = pStream->Write(&sh, sizeof(sh), NULL);
   RETURN_ON_FAILURE(hr);

   // write out he control state information
   //
   return hr;
}



//=--------------------------------------------------------------------------=
// CInstallEngineCtl::OnDraw
//=--------------------------------------------------------------------------=
//
// Parameters:
//    DWORD              - [in]  drawing aspect
//    HDC                - [in]  HDC to draw to
//    LPCRECTL           - [in]  rect we're drawing to
//    LPCRECTL           - [in]  window extent and origin for meta-files
//    HDC                - [in]  HIC for target device
//    BOOL               - [in]  can we optimize dc handling?
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CInstallEngineCtl::OnDraw(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds,
                         LPCRECTL prcWBounds, HDC hicTargetDevice, BOOL fOptimize)
{
   // To provide visual appearence in DESIGN MODE only
   if(DesignMode())
   {
      if(!_hIcon)
         _hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_INSTALLENGINE));
      DrawEdge(hdcDraw, (LPRECT)(LPCRECT)prcBounds, EDGE_RAISED, BF_RECT | BF_MIDDLE);
      if(_hIcon)
         DrawIcon(hdcDraw, prcBounds->left + 3, prcBounds->top + 3, _hIcon);
   }

   return S_OK;
}




//=--------------------------------------------------------------------------=
// CInstallEngineCtl::WindowProc
//=--------------------------------------------------------------------------=
// window procedure for this control.  nothing terribly exciting.
//
// Parameters:
//     see win32sdk on window procs.
//
// Notes:
//

typedef HRESULT (WINAPI *CHECKFORVERSIONCONFLICT) ();

LRESULT CInstallEngineCtl::WindowProc(UINT msg, WPARAM wParam, LPARAM lParam)
{
    // TODO: handle any messages here, like in a normal window
    // proc.  note that for special keys, you'll want to override and
    // implement OnSpecialKey.
    //
   LRESULT lres;
   CALLBACK_PARAMS *pcbp;

   switch (msg)
   {
      case WM_ERASEBKGND:
         if (KeepTransparent(m_hwnd, msg, wParam, lParam, &lres))
            return lres;
         break;

      case WM_ACTIVATE:
      case WM_ACTIVATEAPP:
         {
            DWORD fActive = LOWORD(wParam);
            if(fActive == WA_ACTIVE || fActive == WA_CLICKACTIVE ||
                 fActive == TRUE)
            {
               CHECKFORVERSIONCONFLICT pVerCon;
               HINSTANCE hInseng= LoadLibrary("inseng.dll");
               if(hInseng)
               {
                  pVerCon = (CHECKFORVERSIONCONFLICT)
                                GetProcAddress(hInseng, "CheckForVersionConflict");
                  if(pVerCon)
                     pVerCon();
                  FreeLibrary(hInseng);

               }
            }

         }
         return TRUE;

      case WM_INSENGCALLBACK:
         pcbp = (CALLBACK_PARAMS *) lParam;
         switch(wParam)
         {
            case EVENT_ONENGINESTATUSCHANGE:
               FireEvent( &::rgEvents[EVENT_ONENGINESTATUSCHANGE],
                   pcbp->dwStatus, pcbp->dwSubstatus );
               break;

            case EVENT_ONSTARTINSTALL:
               FireEvent(&::rgEvents[EVENT_ONSTARTINSTALL], (long) pcbp->dwSize);
               break;

            case EVENT_ONSTARTCOMPONENT:
               FireEvent(&::rgEvents[EVENT_ONSTARTCOMPONENT],
                           pcbp->strID, (long) pcbp->dwSize, pcbp->strName);
               break;

            case EVENT_ONSTOPCOMPONENT:
               FireEvent(&::rgEvents[EVENT_ONSTOPCOMPONENT], pcbp->strID, (long) pcbp->dwResult,
                            (long) pcbp->dwPhase, pcbp->strName, (long) pcbp->dwStatus);
               break;

            case EVENT_ONSTOPINSTALL:
               FireEvent(&::rgEvents[EVENT_ONSTOPINSTALL], (long) pcbp->dwResult,
                              pcbp->strString, (long) pcbp->dwStatus);
               break;

            case EVENT_ONENGINEPROBLEM:
               FireEvent(&::rgEvents[EVENT_ONENGINEPROBLEM], (long) pcbp->dwStatus);
               break;

            case EVENT_ONCHECKFREESPACE:
               FireEvent(&::rgEvents[EVENT_ONCHECKFREESPACE], pcbp->chWin,
                           (long) pcbp->dwWin, pcbp->chInstall,
                     (long) pcbp->dwInstall, pcbp->chDL, (long) pcbp->dwDL);
               break;

            case EVENT_ONCOMPONENTPROGRESS:
               FireEvent(&::rgEvents[EVENT_ONCOMPONENTPROGRESS], pcbp->strID,
                         (long) pcbp->dwPhase, pcbp->strName, pcbp->strString,
                         (long)pcbp->dwDL, (long) pcbp->dwSize);
               break;

            case EVENT_CANCEL:
               Abort(0);
               break;

            case EVENT_ONSTARTINSTALLEX:
               FireEvent(&::rgEvents[EVENT_ONSTARTINSTALLEX], (long) pcbp->dwDL, (long) pcbp->dwSize);
               break;


            default:
               break;
         }
         break;

      default:
         break;
   }
   return OcxDefWindowProc(msg, wParam, lParam);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:

STDMETHODIMP CInstallEngineCtl::FreezeEvents(BOOL bFreeze)
{
   if(bFreeze)
      _dwFreezeEvents++;
   else
   {
      if(_dwFreezeEvents)
      {
         _dwFreezeEvents--;
         // if we go to zero, fire our EngineStatus change event if we have one
         if(_dwFreezeEvents == 0 && _fEventToFire)
         {
            _FireEngineStatusChange(_dwSavedEngineStatus, _dwSavedSubStatus);
            _fEventToFire = FALSE;
         }
      }
   }
   return S_OK;
}



//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::get_EngineStatus(long * theenginestatus)
{
   if(!_pinseng)
      return E_UNEXPECTED;

   return _pinseng->GetEngineStatus((DWORD *)theenginestatus);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::get_ReadyState(long * thestate)
{
   CHECK_POINTER(thestate);
  *thestate = m_readyState;
   return(NOERROR);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::Abort(long lFlag)
{
   if(!_pinseng)
   {
      _bCancelPending = TRUE;
      return E_UNEXPECTED;
   }

   if ( _pinseng->Abort(lFlag) != NOERROR )
      _bCancelPending = TRUE;

   return NOERROR;
}

void CInstallEngineCtl::_FireCancel(DWORD dwStatus)
{
   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_CANCEL, NULL);

}


STDMETHODIMP CInstallEngineCtl::SetLocalCif(BSTR strCif, long FAR* lResult)
{
   *lResult = E_FAIL;

   //Allow SetLocalCif only for local cif file. See windows# 541710 and winseraid #24036
   
   if (strCif[1] == L'\\')
      return E_ACCESSDENIED;

   if(!_pinseng)
      return E_UNEXPECTED;

   MAKE_ANSIPTR_FROMWIDE(pszCif, strCif);

   *lResult = _pinseng->SetLocalCif(pszCif);

   if(SUCCEEDED(*lResult))
      _fLocalCifSet = TRUE;



   return NOERROR;

}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::SetCifFile(BSTR strCabName, BSTR strCifName)
{
   HRESULT hr;

   if(!_pinseng)
      return E_UNEXPECTED;

   MAKE_ANSIPTR_FROMWIDE(pszCabName, strCabName);
   MAKE_ANSIPTR_FROMWIDE(pszCifName, strCifName);


   if(_fLocalCifSet)
   {
      // if we are using a local cif, we won't get the new cif right away
      _fReconcileCif = TRUE;
      lstrcpyn(_szCifCab, pszCabName, sizeof(_szCifCab));
      lstrcpyn(_szCifFile, pszCifName, sizeof(_szCifFile));
      hr = S_OK;
   }
   else
   {
      // If we did not check yet, do it.
      if (_dwMSTrustKey == (DWORD)-1)
      {
         _dwMSTrustKey = MsTrustKeyCheck();
         // If MS is not a trusted provider.
         // Make it for the duration of the install
         if (_dwMSTrustKey != 0)
            WriteMSTrustKey(TRUE, _dwMSTrustKey);
      }
      hr = _pinseng->SetCifFile(pszCabName, pszCifName);
   }

   return hr;
}

#define IE_KEY        "Software\\Microsoft\\Internet Explorer"
#define VERSION_KEY         "Version"


LONG CInstallEngineCtl::_OpenJITKey(HKEY *phKey, REGSAM samAttr)
{
   char szTemp[MAX_PATH];
   WORD rdwVer[4] = { 0 };

   HKEY hIE;

   DWORD dwDumb;
   DWORD dwVer;
   if(RegOpenKeyExA(HKEY_LOCAL_MACHINE, IE_KEY, 0, KEY_READ, &hIE) == ERROR_SUCCESS)
   {
      dwDumb = sizeof(szTemp);
      if(RegQueryValueEx(hIE, VERSION_KEY, 0, NULL, (LPBYTE)szTemp, &dwDumb) == ERROR_SUCCESS)
      {
          ConvertVersionString(szTemp, rdwVer, '.');
      }
      RegCloseKey(hIE);
   }
   dwVer = rdwVer[0];

   wsprintf(szTemp, "%s\\%d", g_cszIEJITInfo, dwVer);
   return(RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTemp, 0, samAttr, phKey));
}

void CInstallEngineCtl::_DeleteURLList()
{
    HKEY    hJITKey;

    if ( _OpenJITKey(&hJITKey, KEY_READ) == ERROR_SUCCESS )
    {
        RegDeleteKey(hJITKey, "URLList");

        RegCloseKey(hJITKey);
    }
}

void CInstallEngineCtl::_WriteURLList()
{
    HKEY    hJITKey;
    HKEY    hUrlKey;
    char    cNull = '\0';

    if ( _OpenJITKey(&hJITKey, KEY_READ) == ERROR_SUCCESS )
    {
        if (RegCreateKeyEx(hJITKey, "URLList", 0, NULL, REG_OPTION_NON_VOLATILE,
                           KEY_WRITE, NULL, &hUrlKey, NULL) == ERROR_SUCCESS)
        {
            for(UINT i=0; i < MAX_URLS; i++)
            {
                if ( _rpszUrlList[i] )
                {
                    RegSetValueEx(hUrlKey, _rpszUrlList[i], 0, REG_SZ, (const unsigned char *) &cNull, sizeof(cNull));
                }
            }
            RegCloseKey(hUrlKey);
        }
        RegCloseKey(hJITKey);
    }
}

void CInstallEngineCtl::_WriteRegionToReg(LPSTR szRegion)
{
    HKEY    hJITKey;

    if (_OpenJITKey(&hJITKey, KEY_WRITE) == ERROR_SUCCESS)
    {
        RegSetValueEx(hJITKey, "DownloadSiteRegion", 0, REG_SZ, (const unsigned char *) szRegion, strlen(szRegion)+1);
        RegCloseKey(hJITKey);
    }
}

STDMETHODIMP CInstallEngineCtl::SetSitesFile(BSTR strUrl, BSTR strRegion, BSTR strLocale, long FAR* lResult)
{
   char szBuf[INTERNET_MAX_URL_LENGTH];
   DWORD dwSize;
   HKEY hKey;
   HKEY hUrlKey;
   UINT uUrlNum = 0;

   HRESULT hr = E_FAIL;

   MAKE_ANSIPTR_FROMWIDE(pszUrl, strUrl);
   MAKE_ANSIPTR_FROMWIDE(pszRegion, strRegion);
   MAKE_ANSIPTR_FROMWIDE(pszLocale, strLocale);

   // first check to see if we should use local stuff
   if(pszUrl[0] == 0)
   {
      _fDoingIEInstall = TRUE;
      // find the ie major version, add it to JIT key

      if(_OpenJITKey(&hKey, KEY_READ) == ERROR_SUCCESS)
      {
         dwSize = sizeof(_uInstallMode);
         RegQueryValueEx(hKey, "InstallType", NULL, NULL, (BYTE *) &_uInstallMode, &dwSize);
/*
         if(_uInstallMode == WEBINSTALL)
         {
            if(RegOpenKeyEx(hKey, "URLList", 0, KEY_READ, &hUrlKey) == ERROR_SUCCESS)
            {
               // need to read out urls and put them in rpszUrlList
               for(int i = 0; uUrlNum < MAX_URLS; i++)
               {
                  dwSize = sizeof(szBuf);
                  if(RegEnumValue(hUrlKey, i, szBuf, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                  {
                     _rpszUrlList[uUrlNum] = new char[dwSize + 1];
                     if(_rpszUrlList[uUrlNum])
                     {
                        lstrcpy(_rpszUrlList[uUrlNum], szBuf);
                        // we found at least one url so "NOERROR"
                        uUrlNum++;

                     }
                  }
                  else
                     break;

               }
			   RegCloseKey(hUrlKey);
            }
            if (uUrlNum > 0)
            {
                // We got atleast one URL from the registry.
                // Check if the URLs are still valid.
                hr = _PickWebSites(NULL, NULL, NULL, TRUE, TRUE);
            }
         }
         else */if(_uInstallMode == WEBINSTALL_DIFFERENTMACHINE)
         {
            hr = NOERROR;
         }

         _szDownloadDir[0] = 0;
         dwSize = sizeof(_szDownloadDir);
         if(RegQueryValueEx(hKey, "UNCDownloadDir", NULL, NULL, (BYTE *) (_szDownloadDir), &dwSize) == ERROR_SUCCESS)
         {
            // if its a web install, set download dir to UNCDownloadDir
            if(_uInstallMode == WEBINSTALL || _uInstallMode == WEBINSTALL_DIFFERENTMACHINE)
            {
               if(GetFileAttributes(_szDownloadDir) != 0xffffffff)
                  _pinseng->SetDownloadDir(_szDownloadDir);
            }
            else if(_uInstallMode == CDINSTALL ||
                    _uInstallMode == NETWORKINSTALL ||
                    _uInstallMode == LOCALINSTALL)
            {
               // setup szBuf with file:// at beginning
               lstrcpy(szBuf, "file://");
               lstrcat(szBuf, _szDownloadDir);

               _rpszUrlList[uUrlNum] = new char[lstrlen(szBuf) + 1];
               if(_rpszUrlList[uUrlNum])
               {
                  lstrcpy(_rpszUrlList[uUrlNum], szBuf);
                  // we found at least one url so "NOERROR"
                  uUrlNum++;
                  hr = NOERROR;
               }
            }
         }
         RegCloseKey(hKey);
      }
   }

   if (hr != NOERROR)
   {
      hr = _PickWebSites(pszUrl, pszRegion, pszLocale, FALSE);
   }

   if(SUCCEEDED(hr) && _rpszUrlList[0])
   {
      _uCurrentUrl = 0;
      _pinseng->SetBaseUrl(_rpszUrlList[_uCurrentUrl]);
   }
   *lResult = hr;
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::put_BaseUrl(BSTR strBaseUrl)
{
   if(!_pinseng)
      return E_UNEXPECTED;

   MAKE_ANSIPTR_FROMWIDE(pszBaseUrl, strBaseUrl);
   return _pinseng->SetBaseUrl(pszBaseUrl);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::put_DownloadDir(BSTR strDownloadDir)
{
   // Due to security issues, this method is effectively being disabled.
   return S_OK;

   if(!_pinseng)
      return E_UNEXPECTED;

   MAKE_ANSIPTR_FROMWIDE(pszDownloadDir, strDownloadDir);
   return _pinseng->SetDownloadDir(pszDownloadDir);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::IsComponentInstalled(BSTR strComponentID, long *lResult)
{
   if(!_pinseng)
      return E_UNEXPECTED;

   // Ask about grovelling for installed apps here

    //
    // add code to automatically enable grovel if the specified event is signalled
    //
	const TCHAR szEnableGrovelEventName[] = TEXT("WindowsUpdateCriticalUpdateGrovelEnable");
    if(_uAllowGrovel == 0xffffffff)
    {
       HANDLE evAllowGrovel = OpenEvent(
									EVENT_ALL_ACCESS,
									FALSE,
									szEnableGrovelEventName
									);
	   if (evAllowGrovel != NULL)
   	   {
	     if (WaitForSingleObject(evAllowGrovel, 0) == WAIT_OBJECT_0)
		 {
			//
			// if the event is signaled, we reset the event, and set _uAllowGrovel=1 which
			// means we've already agreed on groveling
			//
			_uAllowGrovel = 1;
		 }
		 CloseHandle(evAllowGrovel);
	   }
   }


   if (_uAllowGrovel == 0xffffffff)
   {
      LPSTR pszTitle;
      char szMess[512];

      _pinseng->GetDisplayName(NULL, &pszTitle);
      LoadSz(IDS_GROVELMESSAGE, szMess, sizeof(szMess));
      ModalDialog(TRUE);
      if(MessageBox(m_hwnd, szMess, pszTitle, MB_YESNO | MB_ICONQUESTION) == IDNO)
         _uAllowGrovel = 0;
      else
         _uAllowGrovel = 1;
      ModalDialog(FALSE);

      if(pszTitle)
         CoTaskMemFree(pszTitle);
   }

   if (_uAllowGrovel != 1)
   {
      *lResult = ICI_UNKNOWN;
      return NOERROR;
   }
   else
   {

    MAKE_ANSIPTR_FROMWIDE(pszComponentID, strComponentID);
	return _pinseng->IsComponentInstalled(pszComponentID, (DWORD *)lResult);
   }
}

STDMETHODIMP CInstallEngineCtl::get_DisplayName(BSTR ComponentID, BSTR *name)
{
   LPSTR psz;

   MAKE_ANSIPTR_FROMWIDE(pszID, ComponentID);
   _pinseng->GetDisplayName(pszID, &psz);

   if(psz)
   {
      *name = BSTRFROMANSI(psz);
      CoTaskMemFree(psz);
   }

   return NOERROR;
}



//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::get_Size(BSTR strComponentID, long *lResult)
{
   HRESULT hr;
   COMPONENT_SIZES cs;

   if(!_pinseng)
      return E_UNEXPECTED;

   cs.cbSize = sizeof(COMPONENT_SIZES);

   MAKE_ANSIPTR_FROMWIDE(pszComponentID, strComponentID);
   hr = _pinseng->GetSizes(pszComponentID, &cs);
   *lResult = cs.dwDownloadSize;
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::get_TotalDownloadSize(long *totalsize)
{
   HRESULT hr;
   COMPONENT_SIZES cs;

   if(!_pinseng)
      return E_UNEXPECTED;

   cs.cbSize = sizeof(COMPONENT_SIZES);

   hr = _pinseng->GetSizes(NULL, &cs);
   *totalsize = cs.dwDownloadSize;
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::get_TotalDependencySize(long *totaldepsize)
{
   HRESULT hr;
   COMPONENT_SIZES cs;

   if(!_pinseng)
      return E_UNEXPECTED;

   cs.cbSize = sizeof(COMPONENT_SIZES);

   hr = _pinseng->GetSizes(NULL, &cs);
   *totaldepsize = cs.dwDependancySize;
   return hr;
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::SetAction(BSTR strComponentID, long action, long *lResult)
{
   if(!_pinseng)
      return E_UNEXPECTED;

   MAKE_ANSIPTR_FROMWIDE(pszComponentID, strComponentID);
   *lResult = 0;
   HRESULT hr = _pinseng->SetAction(pszComponentID, action, 0xffffffff);
   if(hr == E_PENDING)
   {
      char szTitle[128];
      char szErrBuf[256];

      LoadSz(IDS_TITLE, szTitle, sizeof(szTitle));
      LoadSz(IDS_ERRDOINGINSTALL, szErrBuf, sizeof(szErrBuf));
      MsgBox(szTitle, szErrBuf);
   }
   if(hr == S_FALSE)
      *lResult = 1;

   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::ProcessComponents(long lFlags)
{
   DWORD status;
   HANDLE hThread;

   if(!_pinseng)
      return E_UNEXPECTED;

   if(!_fInstalling)
   {
      _fInstalling = TRUE;
      // make sure engine is ready
      _pinseng->GetEngineStatus(&status);
      if(status == ENGINESTATUS_READY)
      {
         // spawn thread to do install
         _dwProcessComponentsFlags = lFlags;
         // only allow certain options thru script
         _dwProcessComponentsFlags &= 0xffffffef;
         if ((hThread = CreateThread(NULL, 0, DoInstall, (LPVOID) this, 0, &status)) != NULL)
            CloseHandle(hThread);
      }
   }

   return NOERROR;
}


void CInstallEngineCtl::_DoInstall()
{
   HRESULT hr = NOERROR;
   char szBuf[512];
   char szTitle[128];
   BOOL fNeedWebSites = FALSE;
   DWORD dwMSTrustKey = (DWORD)-1;

   AddRef();
   _hDone = CreateEvent(NULL, FALSE, FALSE, NULL);
   _dwInstallStatus = 0;

   if(!_hDone)
      hr = E_FAIL;

   // If we did not check yet, do it.
   if (dwMSTrustKey == (DWORD)-1)
   {
      dwMSTrustKey = MsTrustKeyCheck();
      // If MS is not a trusted provider. Make it for the duration of the install
      if (dwMSTrustKey != 0)
         WriteMSTrustKey(TRUE, dwMSTrustKey, _fJITInstall);
   }

   // Add reg value so that if IE4 base is installed, it would think that it
   // is being run from Active Setup.  This would prevent softboot from being
   // kicked off by IE4 base.
   WriteActiveSetupValue(TRUE);

   if(_fDoingIEInstall)
   {
      // figure out whether we need to hit the web or not
      // for beta1 we assume we never do for CD/NETWORK
      COMPONENT_SIZES Sizes;
      if(_uInstallMode == WEBINSTALL || _uInstallMode == WEBINSTALL_DIFFERENTMACHINE)
      {
         ZeroMemory(&Sizes, sizeof(COMPONENT_SIZES));
         Sizes.cbSize = sizeof(COMPONENT_SIZES);

         if(SUCCEEDED(_pinseng->GetSizes(NULL, &Sizes)))
         {
            if(Sizes.dwDownloadSize == 0)
            {
               // in webdownload case, with everything local, no need to reoncile cif
               _fReconcileCif = FALSE;
            }
            else
            {
               // if we don't have any web sites then we need them
               if(!_rpszUrlList[0])
                  fNeedWebSites = TRUE;
            }
         }
      }
      else
      {
         // for CD, NETWORK, LOCALINSTALL, here we check for path
         hr = _CheckInstallPath(&fNeedWebSites);
         // no need to reconcile the cif - it won't even be there!
         _fReconcileCif = FALSE;
      }
   }

   if(SUCCEEDED(hr))
   {
      _dwInstallStatus = 0;
      if(!(_dwProcessComponentsFlags & PROCESSCOMPONENT_NOPROGRESSUI))
      {
         _pProgDlg = new CProgressDlg(g_hInstance, m_hwnd, m_hwndParent, this);
         if(_pProgDlg)
            _pProgDlg->DisplayWindow(TRUE);
      }
   }

   if(SUCCEEDED(hr) && fNeedWebSites)
   {
       // member boolean to track whether whether websites need to
       // be written back to the URLList.
       _bNewWebSites = TRUE;

      hr = _PickWebSites(NULL, NULL, NULL, FALSE);
      if(SUCCEEDED(hr))
      {
         _pinseng->SetBaseUrl(_rpszUrlList[0]);
         _uCurrentUrl = 0;
      }
   }

   if ( SUCCEEDED(hr) && _bCancelPending )
   {
      hr = E_ABORT;
      _bCancelPending = FALSE;
   }


   if(SUCCEEDED(hr) && _fReconcileCif)
   {
      hr = _pinseng->SetCifFile(_szCifCab, _szCifFile);
      if(SUCCEEDED(hr))
      {
         WaitForEvent(_hDone, NULL);
         hr = _hResult;
         _fReconcileCif = FALSE;
      }
   }

   if ( SUCCEEDED(hr) && _bCancelPending )
   {
      hr = E_ABORT;
      _bCancelPending = FALSE;
   }

   if(SUCCEEDED(hr))
   {
      hr = _CheckForDiskSpace();
   }

   if(SUCCEEDED(hr))
   {
      COMPONENT_SIZES cs;
      cs.cbSize = sizeof(COMPONENT_SIZES);

      if(SUCCEEDED(_pinseng->GetSizes(NULL, &cs)))
      {
         _FireOnStartInstallExEvent(cs.dwDownloadSize, cs.dwInstallSize + cs.dwWinDriveSize);
      }

      if ( SUCCEEDED(hr) && _bCancelPending )
      {
          hr = E_ABORT;
          _bCancelPending = FALSE;
      }

      if ( SUCCEEDED(hr) )
      {
          hr = _pinseng->DownloadComponents(_dwProcessComponentsFlags);
          if(SUCCEEDED(hr))
          {
             WaitForEvent(_hDone, NULL);
             hr = _hResult;
          }
      }
   }

   if(SUCCEEDED(hr))
   {
      // Prepare the install
      // Create the error string
      _pszErrorString = (char *) malloc(ERROR_STRING_SIZE);
      _iErrorStringSize = ERROR_STRING_SIZE;

      if(_pszErrorString)
         LoadSz(IDS_SUMMARYHEADING, _pszErrorString, 2048);
      else
         hr = E_OUTOFMEMORY;
   }

   if(SUCCEEDED(hr))
   {
      if(_pProgDlg && (_dwProcessComponentsFlags & PROCESSCOMPONENT_NOINSTALLUI))
         _pProgDlg->DisplayWindow(FALSE);
      hr = _pinseng->InstallComponents(EXECUTEJOB_IGNORETRUST);
      if(SUCCEEDED(hr))
      {
         WaitForEvent(_hDone, NULL);
         hr = _hResult;
      }
   }

   if (dwMSTrustKey != (DWORD)-1)
   {
      WriteMSTrustKey(FALSE, dwMSTrustKey);
   }
   dwMSTrustKey = (DWORD)-1;

   // delete ActiveSetup value from IE4\Options
   WriteActiveSetupValue(FALSE);

   if(_pProgDlg)
   {
      delete _pProgDlg;
      _pProgDlg = NULL;
   }

   LoadSz(IDS_FINISH_TITLE, szTitle, sizeof(szTitle));

   // show appropriate summary ui
   if( !(_dwProcessComponentsFlags & PROCESSCOMPONENT_NOSUMMARYUI))
   {
      if(SUCCEEDED(hr))
      {
         if(_pszErrorString)
            MsgBox(szTitle, _pszErrorString);
      }
      else if(hr == E_ABORT)
      {
         LoadSz(IDS_INSTALLCANCELLED, szBuf, sizeof(szBuf));
         MsgBox(szTitle, szBuf);
      }
      else if( _pszErrorString )
      {
         MsgBox(szTitle, _pszErrorString);
      }
      else
      {
         LoadSz(IDS_ERRGENERAL, szBuf, sizeof(szBuf));
         MsgBox(szTitle, szBuf);
      }
   }

   if(SUCCEEDED(hr))
   {
      if(_dwInstallStatus & STOPINSTALL_REBOOTNEEDED)
      {
         if(!(_dwProcessComponentsFlags & PROCESSCOMPONENT_DELAYREBOOT))
         {
            if( !MyRestartDialog(m_hwnd, TRUE) )
               _dwInstallStatus |= STOPINSTALL_REBOOTREFUSED;
         }
         else
            _fNeedReboot = TRUE;
      }
   }

   _FireOnStopInstallEvent(hr, NULL, _dwInstallStatus);

   _dwProcessComponentsFlags = 0;

   if(_pszErrorString)
   {
      free(_pszErrorString);
      _pszErrorString = NULL;
   }

   if(_hDone)
   {
      CloseHandle(_hDone);
      _hDone = NULL;
   }
   _fInstalling = FALSE;
   Release();
}

HRESULT CInstallEngineCtl::_PickWebSites(LPCSTR pszSites, LPCSTR pszLocale, LPCSTR pszRegion, BOOL bKeepExisting)
{
   UINT uCurrentUrl;
   char szUrl[INTERNET_MAX_URL_LENGTH];
   char szRegion[MAX_DISPLAYNAME_LENGTH];
   char szLocale[3];
   HRESULT hr = NOERROR;
   HKEY hKey;
   DWORD dwSize;

   szRegion[0] = 0;
   szUrl[0] = 0;
   szLocale[0] = 0;

   if(!bKeepExisting)
   {
      for(uCurrentUrl = 0; uCurrentUrl < MAX_URLS; uCurrentUrl++)
      {
         if(_rpszUrlList[uCurrentUrl])
         {
            delete _rpszUrlList[uCurrentUrl];
            _rpszUrlList[uCurrentUrl] = 0;
         }
      }
   }

   // find the first empty url
   for(uCurrentUrl = 0; uCurrentUrl < MAX_URLS && _rpszUrlList[uCurrentUrl]; uCurrentUrl++);

   // fill out all our fields
   if(!pszSites || (*pszSites == '\0'))
   {
      // read info out of JIT key
      if(_OpenJITKey(&hKey, KEY_READ) == ERROR_SUCCESS)
      {
         dwSize = sizeof(szUrl);
         RegQueryValueEx(hKey, "DownloadSiteURL", NULL, NULL, (BYTE *) szUrl, &dwSize);

         if(!pszLocale ||(*pszLocale == '\0'))
         {
            dwSize = sizeof(szLocale);
            RegQueryValueEx(hKey, "Local", NULL, NULL, (BYTE *) szLocale, &dwSize);
         }
         else
            lstrcpyn(szLocale, pszLocale, sizeof(szLocale));

         if(!pszRegion||(*pszRegion == '\0'))
         {
            dwSize = sizeof(szRegion);
            RegQueryValueEx(hKey, "DownloadSiteRegion", NULL, NULL, (BYTE *) szRegion, &dwSize);
         }
         else
            lstrcpyn(szRegion, pszRegion, sizeof(szRegion));

         RegCloseKey(hKey);
      }
   }
   else
   {
      lstrcpyn(szUrl, pszSites, INTERNET_MAX_URL_LENGTH);

      if(pszLocale)
         lstrcpyn(szLocale, pszLocale, sizeof(szLocale));

      if(pszRegion)
         lstrcpyn(szRegion, pszRegion, sizeof(szRegion));
   }

   if(szUrl[0])
   {
      SITEQUERYPARAMS  SiteParam;
      IDownloadSiteMgr *pISitemgr;
      IDownloadSite    **ppISite = NULL;
      IDownloadSite    *pISite;
      DOWNLOADSITE     *psite;
      BYTE             *pPicks = NULL;
      UINT             uNumToPick;
      UINT             uFirstSite = 0xffffffff;
      UINT             j;
      UINT             uNumSites = 0;

      ZeroMemory(&SiteParam, sizeof(SITEQUERYPARAMS));
      SiteParam.cbSize = sizeof(SITEQUERYPARAMS);

      // if we have a locale, use it
      if(szLocale[0])
         SiteParam.pszLang = szLocale;

      hr = CoCreateInstance(CLSID_DownloadSiteMgr, NULL,
                            CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER,
                            IID_IDownloadSiteMgr, (LPVOID *)&pISitemgr);
      if (SUCCEEDED(hr))
      {
         hr = pISitemgr->Initialize(szUrl, &SiteParam);
         if (SUCCEEDED(hr))
         {

            // assume we fail. if we add at least one url, set to OK
            hr = E_FAIL;

            while (SUCCEEDED(pISitemgr->EnumSites(uNumSites, &pISite)))
            {
               pISite->Release();
               uNumSites++;
            }
            ppISite = new IDownloadSite *[uNumSites];

            for(j=0; j < uNumSites;j++)
			{
               pISitemgr->EnumSites(j, &(ppISite[j]));
			}

            // if we don't have a region, show ui
            // NOTE: szRegion better be valid and
            // better have atleast MAX_DISPLAYNAME_LENGTH buffer size
            if(!szRegion[0])
            {
               _PickRegionAndFirstSite(ppISite, uNumSites, szRegion, &uFirstSite);
            }
            pPicks = new BYTE[uNumSites];

            // zero out picks array
            for(j=0; j < uNumSites; j++)
               pPicks[j] = 0;

            // find out number of urls we will add
            uNumToPick = MAX_URLS - uCurrentUrl;
            if(uNumToPick > uNumSites)
               uNumToPick = uNumSites;

            if(uNumToPick > 0)
            {
               if(uFirstSite != 0xffffffff)
               {
                  pPicks[uFirstSite] = 1;
                  uNumToPick--;
               }

               _PickRandomSites(ppISite, pPicks, uNumSites, uNumToPick, szRegion);
            }

            // now all sites we want are marked with one in pPicks
            for(j = 0; j < uNumSites; j++)
            {
               if(pPicks[j])
               {
                  if(SUCCEEDED(ppISite[j]->GetData(&psite)))
                  {
                     _rpszUrlList[uCurrentUrl] = new char[lstrlen(psite->pszUrl) + 1];
                     if(_rpszUrlList[uCurrentUrl])
                     {
                        lstrcpy(_rpszUrlList[uCurrentUrl], psite->pszUrl);
                        uCurrentUrl++;
                        hr = NOERROR;
                     }
                  }
               }
            }

         }
         for(j = 0; j < uNumSites; j++)
            ppISite[j]->Release();

         if(ppISite)
            delete ppISite;
         if(pPicks)
            delete pPicks;

         pISitemgr->Release();
      }
   }
   else
      hr = E_FAIL;

   return hr;
}

void CInstallEngineCtl::_PickRandomSites(IDownloadSite **ppISite, BYTE *pPicks, UINT uNumSites, UINT uNumToPick, LPSTR pszRegion)
{
   UINT uStart, uIncrement, uFirst;

   uStart = GetTickCount() % uNumSites;
   if(uNumSites > 1)
      uIncrement = GetTickCount() % (uNumSites - 1);

   while(uNumToPick)
   {
      // if already picked or not in correct region, find next
      uFirst = uStart;
      while(pPicks[uStart] || !IsSiteInRegion(ppISite[uStart], pszRegion))
      {
         uStart++;
         if(uStart >= uNumSites)
            uStart -= uNumSites;
         if(uStart == uFirst)
            break;
      }
      if(!pPicks[uStart])
      {
         pPicks[uStart] = 1;
         uStart += uIncrement;
         if(uStart >= uNumSites)
            uStart -= uNumSites;
         uNumToPick--;
      }
	   else
		   break;
   }
}

typedef struct
{
   IDownloadSite **ppISite;
   UINT            uNumSites;
   LPSTR           pszRegion;
   UINT            uFirstSite;
} SITEDLGPARAMS;

void FillRegionList(SITEDLGPARAMS *psiteparams, HWND hDlg)
{
   DOWNLOADSITE *pSite;
   HWND hRegion = GetDlgItem(hDlg, IDC_REGIONS);
   for(UINT i = 0; i < psiteparams->uNumSites; i++)
   {
      psiteparams->ppISite[i]->GetData(&pSite);
      if(ComboBox_FindStringExact(hRegion, 0, pSite->pszRegion) == CB_ERR)
         ComboBox_AddString(hRegion, pSite->pszRegion);
   }
   ComboBox_SetCurSel(hRegion, 0);
}

void FillSiteList(SITEDLGPARAMS *psiteparams, HWND hDlg)
{
    char szRegion[MAX_DISPLAYNAME_LENGTH];
   int uPos;
   DOWNLOADSITE *pSite;
   HWND hSite = GetDlgItem(hDlg, IDC_SITES);

   ListBox_ResetContent(hSite);

   ComboBox_GetText(GetDlgItem(hDlg, IDC_REGIONS), szRegion, MAX_DISPLAYNAME_LENGTH);

   // copy the new Region name into the psiteparams struct.
   if ( psiteparams->pszRegion)
       lstrcpyn(psiteparams->pszRegion, szRegion, MAX_DISPLAYNAME_LENGTH);

   for(UINT i = 0; i < psiteparams->uNumSites; i++)
   {
      if(IsSiteInRegion(psiteparams->ppISite[i], szRegion))
      {
         psiteparams->ppISite[i]->GetData(&pSite);
         uPos = ListBox_AddString(hSite, pSite->pszFriendlyName);
         if(uPos != LB_ERR)
            ListBox_SetItemData(hSite, uPos, i);
      }
   }
   ListBox_SetCurSel(hSite, 0);
}



INT_PTR CALLBACK SiteListDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   SITEDLGPARAMS *psiteparam;
   switch (uMsg)
    {
       case WM_INITDIALOG:
          // Do some init stuff
          SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) lParam);
          psiteparam = (SITEDLGPARAMS *) lParam;
          FillRegionList(psiteparam, hwnd);
          FillSiteList(psiteparam, hwnd);
          return FALSE;

       case WM_COMMAND:
          psiteparam = (SITEDLGPARAMS *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
          switch (LOWORD(wParam))
          {
             case IDOK:
                // get the region
                ComboBox_GetText(GetDlgItem(hwnd, IDC_REGIONS), psiteparam->pszRegion, MAX_PATH);
                psiteparam->uFirstSite = (UINT)ListBox_GetItemData(GetDlgItem(hwnd, IDC_SITES),
                                   ListBox_GetCurSel(GetDlgItem(hwnd, IDC_SITES)));
                EndDialog(hwnd, IDOK);
                break;

             case IDC_REGIONS:
                if (HIWORD(wParam) == CBN_SELCHANGE)
                {
                   FillSiteList(psiteparam, hwnd);
                }
                break;

             default:
                return FALSE;
          }
          break;

       default:
          return(FALSE);
    }
    return TRUE;
}



void CInstallEngineCtl::_PickRegionAndFirstSite(IDownloadSite **ppISite, UINT uNumSites, LPSTR szRegion, UINT *puFirstSite)
{
   SITEDLGPARAMS siteparam;

   siteparam.ppISite = ppISite;
   siteparam.uNumSites = uNumSites;
   siteparam.pszRegion = szRegion;

   DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SITELIST), _pProgDlg ? _pProgDlg->GetHWND() : m_hwnd,
                   SiteListDlgProc, (LPARAM)&siteparam);

   *puFirstSite = siteparam.uFirstSite;
   _WriteRegionToReg(siteparam.pszRegion);
}

HRESULT CInstallEngineCtl::_CheckInstallPath(BOOL *pfNeedWebSites)
{
   // MAX_PATH and enough to hold "file://" (if needed)
   char szBuf[MAX_PATH + 10];
   HKEY hKey = NULL;
   DWORD dwSize;
   *pfNeedWebSites = FALSE;
   HRESULT hr = NOERROR;

   if(!_PathIsIEInstallPoint(_szDownloadDir))
   {

      // If Win9x, turn-off the AutoRun thing before showing the Dlg.
      if (g_fSysWin95)
         g_ulOldAutorunSetting = SetAutorunSetting((unsigned long)WINDOWS_AUTOPLAY_OFF);

      // create and show the dialog
      INT_PTR ret = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_LOCATE), m_hwnd,
                          LocationDlgProc, (LPARAM)this);

      // Now reset the AutoRun settings for Win9x
      if (g_fSysWin95)
         SetAutorunSetting(g_ulOldAutorunSetting);

      if(ret == IDCANCEL)
      {
         hr = E_ABORT;
      }
      else if(ret == IDC_INTERNET)
      {
         *pfNeedWebSites = TRUE;
      }
      else
      {
         // mike wants to copy new _szDownloadDir back into the registry...
         // take what we have and replace the current baseurl with it
         if(_rpszUrlList[0])
         {
            delete _rpszUrlList[0];
            _rpszUrlList[0] = 0;
         }

         lstrcpy(szBuf, "file://");
         lstrcat(szBuf, _szDownloadDir);

         _rpszUrlList[0] = new char[lstrlen(szBuf) + 1];
         if(_rpszUrlList[0])
         {
            lstrcpy(_rpszUrlList[0], szBuf);
		    _pinseng->SetBaseUrl(_rpszUrlList[0]);
         }
         else
            hr = E_OUTOFMEMORY;
      }
   }

   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:  For the CD AutoSplash suppression code, the values for iHandledAutoCD are
//              iHandledAutoCD == -1  ===> no need to suppress AutoCD.
//              iHandledAutoCD == 0   ===> need to suppress but not suppressed yet
//              iHandledAutoCD == 1   ===> finished suppressing AutoCD.
//=--------------------------------------------------------------------------=

#define AUTOCD_WAIT     30
#define AUTOCD_SLEEP    500

INT_PTR CALLBACK LocationDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   // Code to suppress the AutoRun when the CD is inserted.
   static HCURSOR  hCurOld = NULL;
   static int      iHandledAutoCD = -1;  // -1 ==> do not need to suppress AutoCD
   static int      iCount = 0;

   CInstallEngineCtl *pctl = (CInstallEngineCtl *) GetWindowLongPtr(hDlg, DWLP_USER);

   // Special case handling for the Autorun message.
   // When this dialog receives the AutoRun message, suppres it.
   if ( uMsg == g_uCDAutorunMsg)
   {
       SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR)1);
       iHandledAutoCD = 1;  // 1 ==> finished suppressing the AutoCD Splash
       return TRUE;
   }

   switch(uMsg)
   {
      case WM_INITDIALOG:
         {
            char szBuf[MAX_PATH];
            char szBuf2[MAX_PATH];

            UINT drvType;
            HWND hwndCb = GetDlgItem(hDlg, IDC_LOCATIONLIST);
            int defSelect = 0;
            int pos;
            LPSTR psz = NULL;

            // Setup the default behaviour for AutoCD suppression
            iHandledAutoCD = -1;  // -1 ==> do not need to suppress AutoCD

            pctl = (CInstallEngineCtl *) lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pctl);

            pctl->_pinseng->GetDisplayName(NULL, &psz);
            SetWindowText(hDlg, psz);
            szBuf2[0] = 0;

            if(pctl->_uInstallMode == CDINSTALL)
            {
               // Only if this dialog involves CD insertion, do we need to bother about
               // CDINSTALL - need to handle AutoRun suppression.
               // This method is needed only if we are running on NT.
               if ( g_fSysWinNT )
                   iHandledAutoCD = 0;  // 0 ==> we need to suppress, but not suppressed yet.

               LoadSz(IDS_CDNOTFOUND, szBuf, sizeof(szBuf));
               SetDlgItemText(hDlg, IDC_TEXT1, szBuf);

               if(LoadSz(IDS_CDPLEASEINSERT, szBuf, sizeof(szBuf)))
                  wsprintf(szBuf2, szBuf, psz);
               SetDlgItemText(hDlg, IDC_TEXT2, szBuf2);

               lstrcpy(szBuf, "x:\\");
               for(char chDir = 'A'; chDir <= 'Z'; chDir++)
               {
                  szBuf[0] = chDir;
                  drvType = GetDriveType(szBuf);
                  if(drvType != DRIVE_UNKNOWN && drvType != DRIVE_NO_ROOT_DIR)
                  {
                     pos = ComboBox_AddString(hwndCb, szBuf);
                     if(ANSIStrStrI(pctl->_szDownloadDir, szBuf))
                        defSelect = pos;
                  }
               }
            }
            else
            {
               LoadSz(IDS_NETWORKNOTFOUND, szBuf, sizeof(szBuf));
               SetDlgItemText(hDlg, IDC_TEXT1, szBuf);

               if(LoadSz(IDS_NETWORKPLEASEFIND, szBuf, sizeof(szBuf)))
                  wsprintf(szBuf2, szBuf, psz);
               SetDlgItemText(hDlg, IDC_TEXT2, szBuf2);

               ComboBox_AddString(hwndCb, pctl->_szDownloadDir);
               defSelect = 0;
            }
            // add internet to list
            // it is important that the internet is last; we depend on it later
            LoadSz(IDS_INTERNET, szBuf, sizeof(szBuf));
            ComboBox_AddString(hwndCb, szBuf);

            ComboBox_SetCurSel(hwndCb, defSelect);

            if(psz)
               CoTaskMemFree(psz);
         }
         return TRUE;

      case WM_COMMAND:
         switch (LOWORD(wParam))
         {
            case IDC_BROWSE:
               {
                  char szBuf[MAX_PATH];
                  char szBuf2[MAX_PATH];

                  HWND hwndCb = GetDlgItem(hDlg, IDC_LOCATIONLIST);
                  LPSTR psz;

                  szBuf2[0] = 0;
                  pctl->_pinseng->GetDisplayName(NULL, &psz);
                  if(LoadSz(IDS_FINDFOLDER, szBuf, sizeof(szBuf)))
                     wsprintf(szBuf2, szBuf, psz);

                  szBuf[0] = 0;
                  ComboBox_GetText(hwndCb, szBuf, sizeof(szBuf));

                  if(BrowseForDir(hDlg, szBuf, szBuf2))
                  {
                     ComboBox_SetText(hwndCb, szBuf);
                  }
                  if(psz)
                     CoTaskMemFree(psz);
               }
               break;

            case IDOK:
               {
                  HWND hwndCb = GetDlgItem(hDlg, IDC_LOCATIONLIST);
                  char szBuf[MAX_PATH];
                  char szBuf2[MAX_PATH];

                  // If User selected INTERNET, go on irresepective of CD or not.
                  // I am counting on the fact that the last item I added was internet!
                  int iSel = ComboBox_GetCurSel(hwndCb);
                  if(iSel == ComboBox_GetCount(hwndCb) - 1)
                  {
                     EndDialog(hDlg, IDC_INTERNET);
                  }
                  else
                  {
                     // If Splash suppression needs to be done, wait for it before continuing.
                     if ( iHandledAutoCD == 0 ) // i.e. need to suppress, but NOT suppressed yet.
                     {
                        // Change cursor to WAIT for the very first time only.
                        if (hCurOld == NULL)
                            hCurOld = SetCursor(LoadCursor(NULL,(IDC_WAIT)));

                        // Wait for the DlgBox to suppress the AutoCD (if possible)
                        if ( iHandledAutoCD != 1
                             && iCount < AUTOCD_WAIT )
                        {
                            Sleep(AUTOCD_SLEEP);
                            PostMessage(hDlg, uMsg, wParam, lParam);
                            iCount ++;
                        }
                        else
                        {
                            // Enough of waiting, pretend supressed and move on.
                            iHandledAutoCD = 1;
                            PostMessage(hDlg,uMsg,wParam,lParam);
                        }
                     }
                     else
                     {
                         if ( hCurOld )
                         {
                             // Now that we have finished waiting for suppression, restore cursor.
                             SetCursor(hCurOld);
                             hCurOld = NULL;
                         }

                         ComboBox_GetText(hwndCb, szBuf, sizeof(szBuf));
                         if(pctl->_uInstallMode == CDINSTALL)
                         {
                            if(lstrlen(szBuf) == 3)
                            {
                               // this is just drive letter. add dir to it
                               lstrcpy(szBuf + 3, pctl->_szDownloadDir + 3);
                            }
                         }

                         if(pctl->_PathIsIEInstallPoint(szBuf))
                         {
                            lstrcpy(pctl->_szDownloadDir, szBuf);
                            EndDialog(hDlg, IDOK);
                         }
                         else
                         {
                            // NOT VALID: Need to start again on this dialog.
                            LPSTR psz;
                            pctl->_pinseng->GetDisplayName(NULL, &psz);
                            LoadSz(IDS_NOTVALIDLOCATION, szBuf, sizeof(szBuf));
                            wsprintf(szBuf2, szBuf, psz);
                            MessageBox(hDlg, szBuf2, psz, MB_OK | MB_ICONSTOP);

                            // If there was a need for AutoSplash suppression on our way here, we need to
                            // re-initialize our need to AutoSplash suppression for the next round.
                            if ( iHandledAutoCD != -1)    // -1 ==> No suppression required.
                            {
                                iHandledAutoCD = 0;
                                hCurOld = NULL;
                                iCount = 0;
                            }

                         }
                     }
                  }
               }
               break;

            case IDCANCEL:
               EndDialog(hDlg, IDCANCEL);
               break;

            default:
               return FALSE;
         }
         break;

      default:
         return FALSE;
   }
   return TRUE;
}

BOOL CInstallEngineCtl::_PathIsIEInstallPoint(LPCSTR pszPath)
{
   // in the future this can actually check the path for the files we need
   return(GetFileAttributes(pszPath) != 0xffffffff);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::FinalizeInstall(long lFlags)
{
   if(lFlags & FINALIZE_DOREBOOT)
   {
      if(_fNeedReboot)
      {
         MyRestartDialog(m_hwnd, !(lFlags & FINALIZE_NOREBOOTPROMPT));
      }
   }
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::HandleEngineProblem(long lAction)
{
   _dwAction = (DWORD) lAction;
   return NOERROR;
}


STDMETHODIMP CInstallEngineCtl::CheckFreeSpace(long lPad, long FAR* lEnough)
{
   *lEnough = 1;
   _uInstallPad = lPad;
   return NOERROR;
}


BOOL CInstallEngineCtl::_IsEnoughSpace(LPSTR szSpace1, DWORD dwSize1, LPSTR szSpace2, DWORD dwSize2,
                                       LPSTR szSpace3, DWORD dwSize3)
{
   COMPONENT_SIZES cs;
   char szRoot[5] = "?:\\";
   BOOL fEnough = TRUE;
   char szBuf[MAX_DISPLAYNAME_LENGTH];

   UINT pArgs[2];

   cs.cbSize = sizeof(COMPONENT_SIZES);

   // clear out strings
   szSpace1[0] = 0;
   szSpace2[0] = 0;
   szSpace3[0] = 0;


   if(SUCCEEDED(_pinseng->GetSizes(NULL, &cs)))
   {
      if(cs.chWinDrive)
      {
         szRoot[0] = cs.chWinDrive;
         if(GetSpace(szRoot) < (DWORD) (_uInstallPad + (long) cs.dwWinDriveReq))
         {
            LoadSz(IDS_DISKSPACE, szBuf, sizeof(szBuf));
            pArgs[0] = (UINT) cs.dwWinDriveReq + _uInstallPad;
            pArgs[1] = (UINT) szRoot[0];
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    (LPCVOID) szBuf, 0, 0, szSpace1, dwSize1, (va_list *) pArgs);
            fEnough = FALSE;
         }
      }
      if(cs.chInstallDrive)
      {
         szRoot[0] = cs.chInstallDrive;
         if(GetSpace(szRoot) < cs.dwInstallDriveReq)
         {
            LoadSz(IDS_DISKSPACE, szBuf, sizeof(szBuf));
            pArgs[0] = (UINT) cs.dwInstallDriveReq;
            pArgs[1] = (UINT) szRoot[0];
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    (LPCVOID) szBuf, 0, 0, szSpace2, dwSize2, (va_list *) pArgs);
            fEnough = FALSE;
         }
      }
      if(cs.chDownloadDrive)
      {
         szRoot[0] = cs.chDownloadDrive;
         if(GetSpace(szRoot) < cs.dwDownloadDriveReq)
         {
            LoadSz(IDS_DISKSPACE, szBuf, sizeof(szBuf));
            pArgs[0] = (UINT) cs.dwDownloadDriveReq;
            pArgs[1] = (UINT) szRoot[0];
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    (LPCVOID) szBuf, 0, 0, szSpace3, dwSize3, (va_list *) pArgs);
            fEnough = FALSE;
         }
      }
   }
   else
      fEnough = FALSE;

   return fEnough;
}

HRESULT CInstallEngineCtl::_CheckForDiskSpace()
{
   HRESULT hr = NOERROR;
   char szBuf1[MAX_DISPLAYNAME_LENGTH];
   char szBuf2[MAX_DISPLAYNAME_LENGTH];
   char szBuf3[MAX_DISPLAYNAME_LENGTH];


   if(!_IsEnoughSpace(szBuf1, sizeof(szBuf1),szBuf2, sizeof(szBuf2), szBuf3, sizeof(szBuf3) ))
      hr = _ShowDiskSpaceDialog();

   return hr;
}

HRESULT CInstallEngineCtl::_ShowDiskSpaceDialog()
{
   HWND hwnd;

   if(_pProgDlg)
      hwnd = _pProgDlg->GetHWND();
   else
      hwnd = m_hwnd;

   // create and show the dialog
    INT_PTR ret = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_DISKSPACE), hwnd,
                          DiskSpaceDlgProc, (LPARAM) this);
    if(ret == IDOK)
       return NOERROR;
    else
       return E_ABORT;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:


INT_PTR CALLBACK DiskSpaceDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   CInstallEngineCtl *pctl = (CInstallEngineCtl *) GetWindowLongPtr(hDlg, DWLP_USER);

   switch(uMsg)
   {
      case WM_INITDIALOG:
         {
            char szBuf1[MAX_DISPLAYNAME_LENGTH];
            char szBuf2[MAX_DISPLAYNAME_LENGTH];
            char szBuf3[MAX_DISPLAYNAME_LENGTH];

            pctl = (CInstallEngineCtl *) lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pctl);

            pctl->_IsEnoughSpace(szBuf1, sizeof(szBuf1), szBuf2, sizeof(szBuf2), szBuf3, sizeof(szBuf3));
            SetDlgItemText(hDlg, IDC_SPACE1, szBuf1);
            SetDlgItemText(hDlg, IDC_SPACE2, szBuf2);
            SetDlgItemText(hDlg, IDC_SPACE3, szBuf3);

         }
         return TRUE;

      case WM_COMMAND:
         switch (LOWORD(wParam))
         {

            case IDOK:
               {
                  char szBuf1[MAX_DISPLAYNAME_LENGTH];
                  char szBuf2[MAX_DISPLAYNAME_LENGTH];
                  char szBuf3[MAX_DISPLAYNAME_LENGTH];

                  if(!pctl->_IsEnoughSpace(szBuf1, sizeof(szBuf1), szBuf2, sizeof(szBuf2), szBuf3, sizeof(szBuf3)))
                  {
                     SetDlgItemText(hDlg, IDC_SPACE1, szBuf1);
                     SetDlgItemText(hDlg, IDC_SPACE2, szBuf2);
                     SetDlgItemText(hDlg, IDC_SPACE3, szBuf3);
                  }
                  else
                     EndDialog(hDlg, IDOK);
               }
               break;
            case IDCANCEL:
               EndDialog(hDlg, IDCANCEL);
               break;

            default:
               return FALSE;
         }
         break;

      default:
         return FALSE;
   }
   return TRUE;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


STDMETHODIMP CInstallEngineCtl::OnEngineStatusChange(DWORD dwEngineStatus, DWORD sub)
{
   BOOL fSetEvent = FALSE;


   if((_dwOldStatus == ENGINESTATUS_LOADING)&&(_dwOldStatus != dwEngineStatus))
   {
      if (_dwMSTrustKey != (DWORD)-1)
      {
         WriteMSTrustKey(FALSE, _dwMSTrustKey);
      }
      _dwMSTrustKey = (DWORD)-1;
   }

   if((_dwOldStatus == ENGINESTATUS_LOADING) && (_dwOldStatus != dwEngineStatus) && _hDone)
   {
      _hResult = sub;
      fSetEvent = TRUE;
   }
   else
   {
      if(_dwFreezeEvents)
      {
         _fEventToFire = TRUE;
         _dwSavedEngineStatus = dwEngineStatus;
         _dwSavedSubStatus = sub;
      }
      else
      {
         _FireEngineStatusChange(dwEngineStatus, sub);
      }
   }
   _dwOldStatus = dwEngineStatus;

   if(fSetEvent)
      SetEvent(_hDone);

   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireEngineStatusChange(DWORD dwEngineStatus, DWORD sub)
{
   CALLBACK_PARAMS cbp = { 0 };

   cbp.dwStatus = dwEngineStatus;
   cbp.dwSubstatus = sub;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONENGINESTATUSCHANGE, (LPARAM) &cbp);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::OnStartInstall(DWORD dwDLSize, DWORD dwTotalSize)
{
   if(_pszErrorString)
   {
      // if we get OnStartInstall and we are installing,
      // We intentionally swallow this onStartInstall
      if(_pProgDlg)
         _pProgDlg->SetInsProgGoal(dwTotalSize);
   }
   else
   {
      // this is OnStartInstall for download
      if(_pProgDlg)
         _pProgDlg->SetDownloadProgGoal(dwDLSize);


      _FireOnStartInstallEvent(dwDLSize);

   }

   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireOnStartInstallEvent(DWORD dwTotalSize)
{
   CALLBACK_PARAMS cbp = { 0 };

   cbp.dwSize = dwTotalSize;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONSTARTINSTALL, (LPARAM) &cbp);
}

void CInstallEngineCtl::_FireOnStartInstallExEvent(DWORD dwDLSize, DWORD dwInsSize)
{
   CALLBACK_PARAMS cbp = { 0 };

   cbp.dwSize = dwInsSize;
   cbp.dwDL = dwDLSize;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONSTARTINSTALLEX, (LPARAM) &cbp);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


STDMETHODIMP CInstallEngineCtl::OnStartComponent(LPCSTR pszID, DWORD dwDLSize,
                                            DWORD dwInstallSize, LPCSTR pszName)
{
   _strCurrentID = BSTRFROMANSI(pszID);
   _strCurrentName = BSTRFROMANSI(pszName);
   _strCurrentString = BSTRFROMANSI("");

   _FireOnStartComponentEvent(pszID, dwDLSize, pszName);
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


STDMETHODIMP CInstallEngineCtl::OnEngineProblem(DWORD dwProblem, LPDWORD pdwAction)
{
   HRESULT hr = S_FALSE;

   if((dwProblem == ENGINEPROBLEM_DOWNLOADFAIL) && _rpszUrlList[0])
   {
      // if we have at least one url in list, do switching ourselves
      if( ((_uCurrentUrl + 1) < MAX_URLS) && _rpszUrlList[_uCurrentUrl + 1])
      {
         _uCurrentUrl++;
         _pinseng->SetBaseUrl(_rpszUrlList[_uCurrentUrl]);
         *pdwAction = DOWNLOADFAIL_RETRY;
         hr = S_OK;
      }
   }
   else
   {
      _dwAction = 0;
      _FireOnEngineProblem(dwProblem);
      *pdwAction = _dwAction;
      if(*pdwAction != 0)
         hr = S_OK;
   }
   return hr;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireOnEngineProblem(DWORD dwProblem)
{

   CALLBACK_PARAMS cbp = { 0 };

   cbp.dwStatus = dwProblem;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONENGINEPROBLEM, (LPARAM) &cbp);
}


//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireOnStartComponentEvent(LPCSTR pszID, DWORD dwTotalSize, LPCSTR pszName)
{

   CALLBACK_PARAMS cbp = { 0 };


   cbp.strID = BSTRFROMANSI(pszID);
   cbp.strName = BSTRFROMANSI(pszName);

   cbp.dwSize = dwTotalSize;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONSTARTCOMPONENT, (LPARAM) &cbp);

   SysFreeString(cbp.strID);
   SysFreeString(cbp.strName);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//


STDMETHODIMP CInstallEngineCtl::OnComponentProgress(LPCSTR pszID, DWORD dwPhase, LPCSTR pszString, LPCSTR pszMsgString, ULONG ulSofar, ULONG ulMax)
{
   char szBuf[512];
   char szRes[512];

   // _FireOnComponentProgress(dwPhase, ulSofar, ulMax);

   if(!_pProgDlg)
      return NOERROR;

   if(dwPhase != _dwLastPhase)
   {

      _dwLastPhase = dwPhase;

      // Set up progress for this phase

      UINT id;

      switch(dwPhase)
      {
         case INSTALLSTATUS_INITIALIZING :
            id = IDS_PREPARE;
            break;
         case INSTALLSTATUS_DOWNLOADING :
            id = IDS_DOWNLOADING;
            break;
         case INSTALLSTATUS_EXTRACTING :
            id = IDS_EXTRACTING;
            break;
         case INSTALLSTATUS_CHECKINGTRUST :
            id = IDS_CHECKTRUST;
            break;

         case INSTALLSTATUS_RUNNING :
            id = IDS_INSTALLING;
            break;
         default :
            id = IDS_NOPHASE;
      }
      LoadSz(id, szRes, sizeof(szRes));
      wsprintf(szBuf, szRes, pszString);
      // Setup text for this phase
      _pProgDlg->SetProgText(szBuf);
   }

   if(dwPhase == INSTALLSTATUS_DOWNLOADING)
      _pProgDlg->SetDownloadProgress(ulSofar);
   else if(dwPhase == INSTALLSTATUS_RUNNING)
      _pProgDlg->SetInsProgress(ulSofar);


   return NOERROR;
}

void CInstallEngineCtl::_FireOnComponentProgress(DWORD dwPhase, DWORD dwSoFar, DWORD dwTotal)
{

   CALLBACK_PARAMS cbp = { 0 };


   cbp.strID = _strCurrentID;
   cbp.strName = _strCurrentName;
   cbp.strString = _strCurrentString;

   cbp.dwPhase = dwPhase;
   cbp.dwSize = dwTotal;
   cbp.dwDL = dwSoFar;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONCOMPONENTPROGRESS, (LPARAM) &cbp);
}




//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::OnStopComponent(LPCSTR pszID, HRESULT hrError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus)
{
   char szBuf[512];
   char szRes[512];
   void *pTemp;


   if(_strCurrentID)
   {
      SysFreeString(_strCurrentID);
      _strCurrentID = NULL;
   }

   if(_strCurrentName)
   {
      SysFreeString(_strCurrentName);
      _strCurrentName = NULL;
   }

   if(_strCurrentString)
   {
      SysFreeString(_strCurrentString);
      _strCurrentString = NULL;
   }

   if(_pszErrorString)
   {
      if(FAILED(hrError))
      {
         // failed AND installing
         UINT id;

         switch(dwPhase)
         {
            case INSTALLSTATUS_INITIALIZING :
               id = IDS_ERRPREPARE;
               break;
            case INSTALLSTATUS_DOWNLOADING :
            case INSTALLSTATUS_COPYING :
               id = IDS_ERRDOWNLOAD;
               break;
            case INSTALLSTATUS_DEPENDENCY :
               id = IDS_ERRDEPENDENCY;
               break;
            case INSTALLSTATUS_EXTRACTING :
               id = IDS_ERREXTRACTING;
               break;
            case INSTALLSTATUS_RUNNING :
               id = IDS_ERRINSTALLING;
               break;
            case INSTALLSTATUS_CHECKINGTRUST :
               id = IDS_ERRNOTTRUSTED;
               break;

            default :
               id = IDS_NOPHASE;
         }
         LoadSz(id, szRes, sizeof(szRes));
      }
      else
      {
         LoadSz(IDS_SUCCEEDED, szRes, sizeof(szRes));
      }

      // After loading the appropriate message into szRes, now tag it to _pszErrorString.
      // Make sure that _pszErrorString is big enough for the new data being appended
      wsprintf(szBuf, szRes, pszString);

      // This is assuming only ANSI characters. None of the  strings in this control must be UNICODE!!
      if ( lstrlen(szBuf) >= (_iErrorStringSize - lstrlen(_pszErrorString)) )
      {
          // Realloc _pszErrorString by ERROR_STRING_INCREMENT
          pTemp = realloc(_pszErrorString, _iErrorStringSize + ERROR_STRING_INCREMENT);
          if ( pTemp != NULL )
          {   // realloc succeeded. Update the string pointer and sizes.
              _pszErrorString = (char *) pTemp;
              _iErrorStringSize += ERROR_STRING_INCREMENT;
          }
          else
          {   // No memory. Abandon summary logging.
              free(_pszErrorString);
              _pszErrorString = NULL;
          }
      }

      if (_pszErrorString)
        lstrcat(_pszErrorString, szBuf);
   }

   if ( FAILED(hrError) && hrError != E_ABORT &&
        (dwPhase == INSTALLSTATUS_DOWNLOADING || dwPhase == INSTALLSTATUS_CHECKINGTRUST) )
   {
       _bDeleteURLList = TRUE;
   }

   _FireOnStopComponentEvent(pszID, hrError, dwPhase, pszString, dwStatus);

   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireOnStopComponentEvent(LPCSTR pszID, HRESULT hrError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus)
{

   CALLBACK_PARAMS cbp = { 0 };


   cbp.strID = BSTRFROMANSI(pszID);
   cbp.strName = BSTRFROMANSI(pszString);
   cbp.dwResult = (DWORD) hrError;
   cbp.dwPhase = dwPhase;
   cbp.dwStatus = dwStatus;

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONSTOPCOMPONENT, (LPARAM) &cbp);


   SysFreeString(cbp.strID);
   SysFreeString(cbp.strName);
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

STDMETHODIMP CInstallEngineCtl::OnStopInstall(HRESULT hrError, LPCSTR szError, DWORD dwStatus)
{

   _hResult = hrError;
   _dwInstallStatus = dwStatus;

   if ( _bDeleteURLList )
       _DeleteURLList();
   else
       if ( _bNewWebSites )
           _WriteURLList();

   SetEvent(_hDone);
   return NOERROR;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//
// Returns:
//
// Notes:
//

void CInstallEngineCtl::_FireOnStopInstallEvent(HRESULT hrError, LPCSTR szError, DWORD dwStatus)
{
   CALLBACK_PARAMS cbp = { 0 };

   cbp.dwResult = (DWORD) hrError;
   cbp.dwStatus = dwStatus;
   cbp.strString = BSTRFROMANSI( szError ? szError : "");

   SendMessage(m_hwnd, WM_INSENGCALLBACK, (WPARAM) EVENT_ONSTOPINSTALL, (LPARAM) &cbp);


   SysFreeString(cbp.strString);
}


void CInstallEngineCtl::MarkJITInstall()
{
    HRESULT hr = S_OK;
    IOleClientSite *pClientSite = NULL;
    IHTMLDocument2 *pDoc = NULL;
    BSTR bstrURL = NULL;
    IOleContainer *pContainer = NULL;

    hr = GetClientSite(&pClientSite);

    if (SUCCEEDED(hr))
    {
        hr = pClientSite->GetContainer(&pContainer);
        if (SUCCEEDED(hr))
        {
            hr = pContainer->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc);
            if (SUCCEEDED(hr))
            {
                hr = pDoc->get_URL(&bstrURL);
                if (SUCCEEDED(hr) && bstrURL)
                {
                    HKEY hKeyActiveSetup;
                    char szJITPage[INTERNET_MAX_URL_LENGTH] = "";
                    DWORD dwSize = INTERNET_MAX_URL_LENGTH;
                    DWORD dwType;
                    BSTR bstrJITPage = NULL;

                    if (ERROR_SUCCESS == RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\Active Setup"),
                            0,
                            KEY_READ,
                            &hKeyActiveSetup))
                    {
                        if (ERROR_SUCCESS == RegQueryValueEx(
                            hKeyActiveSetup,
                            TEXT("JITSetupPage"),
                            NULL,
                            &dwType,
                            (LPBYTE) szJITPage,
                            &dwSize
                            ))
                        {
                            bstrJITPage = BSTRFROMANSI(szJITPage);
                            if (bstrJITPage)
                            {
                                if (0 == lstrcmpiW(bstrJITPage, bstrURL))
                                {
                                    // If the URL points to an internal resource,
                                    // it's probably safe to assume this is a JIT install.
                                    _fJITInstall = TRUE;
                                }
                                SysFreeString(bstrJITPage);
                            }
                        }
                        RegCloseKey(hKeyActiveSetup);
                    }
                    SysFreeString(bstrURL);
                }
                pDoc->Release();
            }
            pContainer->Release();
        }
        pClientSite->Release();
    }
}


DWORD WINAPI DoInstall(LPVOID pv)
{
   CInstallEngineCtl *p = (CInstallEngineCtl *) pv;
   HRESULT hr = CoInitialize(NULL);
   p->_DoInstall();
   if(SUCCEEDED(hr))
      CoUninitialize();

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:   JordanF   07-11-96

!ENDIF

!include  ..\..\active.inc

TARGETTYPE=   DYNLINK
TARGETEXT=    ocx
TARGETPATH=   obj

DLLDEF=       ..\asctrls.def

DLLENTRY=     DllMain
USE_NOLIBS=1

DLLBASE=      @..\..\actbase.txt,asctrls

INCLUDES= ..\..\inc;.;..;..\..\..\sdslib;$(ADMIN_INC_PATH);


PASS0_HEADERDIR   = $(O)
PASS0_SOURCEDIR   = $(O)
MIDL_TLBDIR       = $(O)
MIDL_UUIDDIR      = $(O)

SOURCES= \
    ..\asctrls.cpp       \
    ..\iguids.cpp         \
    ..\cathelp.cpp         \
    ..\asinsctl.cpp         \
    ..\progdlg.cpp         \
    ..\utils2.cpp         \
    ..\asctrls.rc \
    ..\asctrls.odl

UMTYPE=       windows

MKTYPLIB_FLAGS=$(MKTYPLIB_FLAGS) -h $(O)\iasctrls.h

USE_MIDL_FOR_MKTYPLIB=1

LINKLIBS=   ..\..\basectl\$(O)\basectl.lib                          \

TARGETLIBS = \
              ..\..\..\sdslib\$(O)\sdsutils.lib     \
              $(SDK_LIB_PATH)\oleaut32.lib          \
              $(SDK_LIB_PATH)\ole32.lib             \
              $(SDK_LIB_PATH)\rpcrt4.lib            \
              $(SDK_LIB_PATH)\comdlg32.lib          \
              $(SDK_LIB_PATH)\uuid.lib              \
              $(SDK_LIB_PATH)\urlmon.lib            \
              $(SDK_LIB_PATH)\user32.lib            \
              $(SDK_LIB_PATH)\gdi32.lib             \
              $(SDK_LIB_PATH)\advapi32.lib          \
              $(SDK_LIB_PATH)\kernel32.lib          \
              $(SDK_LIB_PATH)\version.lib           \
              $(SDK_LIB_PATH)\libc.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE= ..\asctlpch.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\util2.h ===
#include "sdsutils.h"
#include "inseng.h"


#define MsgBox(title, msg)  ModalDialog(TRUE);\
                            MessageBeep(0xffffffff);\
                            MessageBox(m_hwnd, msg, title, MB_OK | MB_TASKMODAL | MB_SETFOREGROUND);\
                            ModalDialog(FALSE)

// MS trust key defines, this are bit fields to determine which one to add/delete
#define MSTRUSTKEY1     0x1
#define MSTRUSTKEY2     0x2
#define MSTRUSTKEY3     0x4
#define MSTRUSTKEY4     0x8
#define MSTRUSTKEY5     0x10
#define MSTRUSTKEY6     0x20
#define MSTRUSTKEY7     0x40
#define MSTRUSTKEY8     0x80
#define MSTRUSTKEY9     0x100
#define MSTRUSTKEY10    0x200
#define MSTRUSTKEY11    0x400

#define MSTRUST_ALL     MSTRUSTKEY1 | MSTRUSTKEY2 | MSTRUSTKEY3 | MSTRUSTKEY4 | MSTRUSTKEY5 | MSTRUSTKEY6 | MSTRUSTKEY7 | MSTRUSTKEY8 | MSTRUSTKEY9 | MSTRUSTKEY10 | MSTRUSTKEY11

extern HFONT g_hFont;

 
BOOL MyRestartDialog(HWND, BOOL);
int ErrMsgBox(LPSTR	pszText, LPCSTR	pszTitle, UINT	mbFlags);
int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize);
BOOL KeepTransparent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *lres);
void WriteMSTrustKey(BOOL bSet, DWORD dwSetMSTrustKey, BOOL bForceMSTrust = FALSE);
DWORD MsTrustKeyCheck();
BOOL IsSiteInRegion(IDownloadSite *pISite, LPSTR pszRegion);

#ifdef TESTCERT
void UpdateTrustState();
void ResetTestrootCertInTrustState();
#endif
void WriteActiveSetupValue(BOOL bSet);
BOOL BrowseForDir( HWND hwndParent, LPSTR pszFolder, LPSTR pszTitle);

#define EVENTWAIT_QUIT  0
#define EVENTWAIT_DONE  1

DWORD WaitForEvent(HANDLE hEvent, HWND hwnd);

void SetControlFont();
void SetFontForControl(HWND hwnd, UINT uiID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\asctrlex\makefile.inc ===
# rules to generate the tlb and h file


iasctrls.h $(O)\asctrls.tlb: ..\asctrls.odl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\asctrl\makefile.inc ===
# rules to generate the tlb and h file


iasctrls.h $(O)\asctrls.tlb: ..\asctrls.odl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\asctrls\makefile.inc ===
# rules to generate the tlb and h file


iasctrls.h $(O)\asctrls.tlb: ..\asctrls.odl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\classf.cpp ===
//=--------------------------------------------------------------------------=
// ClassF.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the implementation of the ClassFactory object. we support 
// IClassFactory and IClassFactory2
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "ClassF.H"
#include "Globals.H"
#include "Unknown.H"                    // for CREATEFNOFOBJECT

//=--------------------------------------------------------------------------=
// private module level data
//=--------------------------------------------------------------------------=
//

// ASSERT and FAIL require this
//
SZTHISFILE

// private routines for this file
//
HRESULT   CreateOleObjectFromIndex(IUnknown *, int Index, void **, REFIID);

//=--------------------------------------------------------------------------=
// CClassFactory::CClassFactory
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    int            - [in] index into our global table of objects for this guy
//
// Notes:
//
CClassFactory::CClassFactory
(
    int iIndex
)
: m_iIndex(iIndex)
{
    m_cRefs = 1;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CClassFactory
//=--------------------------------------------------------------------------=
// "Life levels all men.  Death reveals the eminent."
// - George Bernard Shaw (1856 - 1950)
//
// Notes:
//
CClassFactory::~CClassFactory ()
{
    ASSERT(m_cRefs == 0, "Object being deleted with refs!");
    return;
}

//=--------------------------------------------------------------------------=
// CClassFactory::QueryInterface
//=--------------------------------------------------------------------------=
// the user wants another interface.  we won't give 'em. very many.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CClassFactory::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    void *pv;

    CHECK_POINTER(ppvObjOut);

    // we support IUnknown, and the two CF interfaces
    //
    if (DO_GUIDS_MATCH(riid, IID_IClassFactory)) {
        pv = (void *)(IClassFactory *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IClassFactory2)) {
        pv = (void *)(IClassFactory2 *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        pv = (void *)(IUnknown *)this;
    } else {
        *ppvObjOut = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)pv)->AddRef();
    *ppvObjOut = pv;
    return S_OK;
}




//=--------------------------------------------------------------------------=
// CClassFactory::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CClassFactory::AddRef
(
    void
)
{
    return ++m_cRefs;
}

//=--------------------------------------------------------------------------=
// CClassFactory::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CClassFactory::Release
(
    void
)
{
    ASSERT(m_cRefs, "No Refs, and we're being released!");
    if(--m_cRefs)
        return m_cRefs;

    delete this;
    return 0;
}

//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstance
//=--------------------------------------------------------------------------=
// create an instance of some sort of object.
//
// Parameters:
//    IUnknown *        - [in]  controlling IUknonwn for aggregation
//    REFIID            - [in]  interface id for new object
//    void **           - [out] pointer to new interface object.
//
// Output:
//    HRESULT           - S_OK, E_NOINTERFACE, E_UNEXPECTED,
//                        E_OUTOFMEMORY, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstance
(
    IUnknown *pUnkOuter,
    REFIID    riid,
    void    **ppvObjOut
)
{
    // check args
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // check to see if we've done our licensing work.  we do this as late
    // as possible that people calling CreateInstanceLic don't suffer from
    // a performance hit here.
    //
    // crit sect this for apartment threading, since it's global
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LeaveCriticalSection(&g_CriticalSection);

    // check to see if they have the appropriate license to create this stuff
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    // try to create one of the objects that we support
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CClassFactory::LockServer
//=--------------------------------------------------------------------------=
// lock the server so we can't unload
//
// Parameters:
//    BOOL        - [in] TRUE means addref, false means release lock count.
//
// Output:
//    HRESULT     - S_OK, E_FAIL, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP CClassFactory::LockServer
(
    BOOL fLock
)
{
    // update the lock count.  crit sect these in case of another thread.
    //
    if (fLock)  
        InterlockedIncrement(&g_cLocks);
    else {
        ASSERT(g_cLocks, "D'oh! Lock Counting Problem");
        InterlockedDecrement(&g_cLocks);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CClassFactory::GetLicInfo
//=--------------------------------------------------------------------------=
// IClassFactory2 GetLicInfo
//
// Parameters:
//    LICINFO *          - unclear
//
// Output:
//    HRESULT            - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::GetLicInfo
(
    LICINFO *pLicInfo
)
{
    CHECK_POINTER(pLicInfo);

    pLicInfo->cbLicInfo = sizeof(LICINFO);

    // This says whether RequestLicKey will work
    //
    pLicInfo->fRuntimeKeyAvail = g_fMachineHasLicense;

    // This says whether the standard CreateInstance will work
    //
    pLicInfo->fLicVerified = g_fMachineHasLicense;

    return S_OK;
}


//=--------------------------------------------------------------------------=
// CClassFactory::RequestLicKey
//=--------------------------------------------------------------------------=
// IClassFactory2 RequestLicKey
//
// Parameters:
//    DWORD             - [in]  reserved
//    BSTR *            - [out] unclear
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::RequestLicKey
(
    DWORD  dwReserved,
    BSTR  *pbstr
)
{
    // if the machine isn't licensed, then we're not about to give this to them !
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    *pbstr = GetLicenseKey();
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstanceLic
//=--------------------------------------------------------------------------=
// create a new instance given a licensing key, etc ...
//
// Parameters:
//    IUnknown *        - [in]  controlling IUnknown for aggregation
//    IUnknown *        - [in]  reserved, must be NULL
//    REFIID            - [in]  IID We're looking for.
//    BSTR              - [in]  license key
//    void **           - [out] where to put the new object.
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstanceLic
(
    IUnknown *pUnkOuter,
    IUnknown *pUnkReserved,
    REFIID    riid,
    BSTR      bstrKey,
    void    **ppvObjOut
)
{
    *ppvObjOut = NULL;

    // go and see if the key they gave us matches.
    //
    if (!CheckLicenseKey(bstrKey))
        return CLASS_E_NOTLICENSED;

    // if it does, then go and create the object.
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CreateOleObjectFromIndex
//=--------------------------------------------------------------------------=
// given an index in our object table, create an object from it.
//
// Parameters:
//    IUnknown *       - [in]  Controlling Unknown, if any, for aggregation
//    int              - [in]  index into our global table
//    void **          - [out] where to put resulting object.
//    REFIID           - [in]  the interface they want resulting object to be.
//
// Output:
//    HRESULT          - S_OK, E_OUTOFMEMORY, E_NOINTERFACE
//
// Notes:
//
HRESULT CreateOleObjectFromIndex
(
    IUnknown *pUnkOuter,
    int       iIndex,
    void    **ppvObjOut,
    REFIID    riid
)
{
    IUnknown *pUnk = NULL;
    HRESULT   hr;

    // go and create the object
    //
    ASSERT(CREATEFNOFOBJECT(iIndex), "All creatable objects must have creation fn!");
    pUnk = CREATEFNOFOBJECT(iIndex)(pUnkOuter);

    // sanity check and make sure the object actually got allocated.
    //
    RETURN_ON_NULLALLOC(pUnk);

    // make sure we support aggregation here properly -- if they gave us
    // a controlling unknown, then they -must- ask for IUnknown, and we'll
    // give them the private unknown the object gave us.
    //
    if (pUnkOuter) {
        if (!DO_GUIDS_MATCH(riid, IID_IUnknown)) {
            pUnk->Release();
            return E_INVALIDARG;
        }

        *ppvObjOut = (void *)pUnk;
        hr = S_OK;
    } else {

        // QI for whatever the user wants.
        //
        hr = pUnk->QueryInterface(riid, ppvObjOut);
        pUnk->Release();
        RETURN_ON_FAILURE(hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\asctrls\utils2.cpp ===
#include "asctlpch.h"
#include "globals.h"
#include "resource.h"
#include "util.h"
#include "util2.h"
#include "sdsutils.h"

#ifdef TESTCERT
#define TESTCERTVALUE 0xA0
#endif

const char c_gszMSTrustRegKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0";
const char c_gszMSTrust[]      = "bhhphijojgfcdocagmhjgjbhmieinfap jpjmcfmhckkdfknkfemjikfiodeelkbd";
const char c_gszMSTrust2[]     = "bhhphijojgfcdocagmhjgjbhmieinfap immbkmbpjfdkajbkncahcedfmndgehba";
const char c_gszMSTrust3[]     = "bhhphijojgfcdocagmhjgjbhmieinfap doamnolbnlpmdlpnkcnpckgfimpaaicl";   // New MS Europe
const char c_gszMSTrust4[]     = "bhhphijojgfcdocagmhjgjbhmieinfap hbgflemajngobcablgnalaidgojggghj";
const char c_gszMSTrust5[]     = "bhhphijojgfcdocagmhjgjbhmieinfap kefdggbdmbmgbogjdcnmkoodcknmmghc";   // New MS Europe effective from 4/16/99
const char c_gszMSTrust6[]     = "bhhphijojgfcdocagmhjgjbhmieinfap debgjcefniaahdamnhbggedppfiianff";   // new MS effective from 4/16/99
const char c_gszMSTrust7[]     = "bhhphijojgfcdocagmhjgjbhmieinfap fmgfeljfbejhfcbbgnokplkipiiopchf";   // new MS effective from 4/16/2000
const char c_gszMSTrust8[]     = "bhhphijojgfcdocagmhjgjbhmieinfap jcphiillknjhbelgeadhnbgpjajjkhdh";   // New MS Europe effective from 4/16/2000
const char c_gszMSTrust9[]     = "klhfnkecpinogjmfaoamiabmhafnjldh adaaaaaaaaaahihcddgb";               // New MS effective 12/22/2000
const char c_gszMSTrust10[]    = "klhfnkecpinogjmfaoamiabmhafnjldh alaaaaaaaaaainckaggb";                  // New MS effective 3/29/2001
const char c_gszMSTrust11[]    = "klhfnkecpinogjmfaoamiabmhafnjldh aeaaaaaaaaaafpnldegb";                  // New MS Europe effective from 12/22/2000

const char c_gszMSTrustValue[] = "Microsoft Corporation";
const char c_gszMSTrustValue3[] = "Microsoft Corporation (Europe)";
#ifdef TESTCERT
const char c_gszTrustStateRegKey[]  = "Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing";
const char c_gszState[]             = "State";
#endif

typedef struct _TRUSTEDPROVIDER
{
    DWORD    dwFlag;
    LPCSTR   pValue;        // Value part in the registeru
    LPCSTR   pData;         // Data part in the registry
} TRUSTEDPROVIDER;

TRUSTEDPROVIDER pTrustedProvider[] = { {MSTRUSTKEY1, c_gszMSTrust, c_gszMSTrustValue},      // MS US
                                       {MSTRUSTKEY2, c_gszMSTrust2, c_gszMSTrustValue},     // MS US
                                       {MSTRUSTKEY3, c_gszMSTrust3, c_gszMSTrustValue3},    // MS Europa
                                       {MSTRUSTKEY4, c_gszMSTrust4, c_gszMSTrustValue},     // MS US
                                       {MSTRUSTKEY5, c_gszMSTrust5, c_gszMSTrustValue3},    // New MS Europe effective from 4/16/99
                                       {MSTRUSTKEY6, c_gszMSTrust6, c_gszMSTrustValue},     // new MS effective from 4/16/99
                                       {MSTRUSTKEY7, c_gszMSTrust7, c_gszMSTrustValue},     // new MS effective from 4/16/2000
                                       {MSTRUSTKEY8, c_gszMSTrust8, c_gszMSTrustValue3},    // New MS Europe effective from 4/16/2000
                                       {MSTRUSTKEY9, c_gszMSTrust9, c_gszMSTrustValue3},    // New MS Europe effective from 4/16/2000
                                       {MSTRUSTKEY10, c_gszMSTrust10, c_gszMSTrustValue3},    // New MS Europe effective from 4/16/2000
                                       {MSTRUSTKEY11, c_gszMSTrust11, c_gszMSTrustValue3},     // New MS Europe effective from 12/22/2000
                                       {0,NULL, NULL} };                                    // Terminates the array.


HFONT g_hFont = NULL;

#define ACTIVESETUP_KEY "Software\\Microsoft\\Active Setup"
#define TRUSTKEYREG  "AllowMSTrustKey"

// NT reboot
//


BOOL MyNTReboot()
{                                                      
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;

    // get a token from this process
    if ( !OpenProcessToken( GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
    {
         return FALSE;
    }

    // get the LUID for the shutdown privilege
    LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //get the shutdown privilege for this proces
    if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0))
    {
        return FALSE;
    }

    // shutdown the system and force all applications to close
    if (!ExitWindowsEx( EWX_REBOOT, 0 ) )
    {
        return FALSE;
    }

    return TRUE;
}
//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//

HRESULT LaunchProcess(LPCSTR pszCmd, HANDLE *phProc, LPCSTR pszDir, UINT uShow)
{
   STARTUPINFO startInfo;
   PROCESS_INFORMATION processInfo;
   HRESULT hr = S_OK;
   BOOL fRet;
   
   if(phProc)
      *phProc = NULL;

   // Create process on pszCmd
   ZeroMemory(&startInfo, sizeof(startInfo));
   startInfo.cb = sizeof(startInfo);
   startInfo.dwFlags |= STARTF_USESHOWWINDOW;
   startInfo.wShowWindow = (WORD)uShow;
   fRet = CreateProcess(NULL, (LPSTR)  pszCmd, NULL, NULL, FALSE, 
              NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
   if(!fRet)
      return E_FAIL;

   if(phProc)
      *phProc = processInfo.hProcess;
   else
      CloseHandle(processInfo.hProcess);

   CloseHandle(processInfo.hThread);
   
   return S_OK;
}

#define SOFTBOOT_CMDLINE   "softboot.exe /s:,60"


// Display a dialog asking the user to restart Windows, with a button that
// will do it for them if possible.
//
BOOL MyRestartDialog(HWND hParent, BOOL bShowPrompt)
{
    char szBuf[256];
    char szTitle[256];
    UINT    id = IDYES;

    if(bShowPrompt)
    {
       LoadSz(IDS_TITLE, szTitle, sizeof(szTitle));
       LoadSz(IDS_REBOOT, szBuf, sizeof(szBuf));
       id = MessageBox(hParent, szBuf, szTitle, MB_ICONQUESTION | MB_YESNO | MB_TASKMODAL | MB_SETFOREGROUND);
    }
    
    if ( id == IDYES )
    {
       // path to softboot plus a little slop for the command line
       char szBuf[MAX_PATH + 10];
       szBuf[0] = 0;

       GetSystemDirectory(szBuf, sizeof(szBuf));
       AddPath(szBuf, SOFTBOOT_CMDLINE);
       if(FAILED(LaunchProcess(szBuf, NULL, NULL, SW_SHOWNORMAL)))
       {
          if(g_fSysWin95)
          {
             ExitWindowsEx( EWX_REBOOT , 0 );
          }
          else
          {
             MyNTReboot();
          }
       }
       
    }
    return (id == IDYES);
}


int ErrMsgBox(LPSTR	pszText, LPCSTR	pszTitle, UINT	mbFlags)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags | MB_ICONERROR | MB_TASKMODAL);

    return id;
}

int LoadSz(UINT id, LPSTR pszBuf, UINT cMaxSize)
{
   if(cMaxSize == 0)
      return 0;

   pszBuf[0] = 0;

   return LoadString(g_hInstance, id, pszBuf, cMaxSize);
}



void WriteMSTrustKey(BOOL bSet, DWORD dwSetMSTrustKey, BOOL bForceMSTrust /*= FALSE*/)
{
    char szTmp[512];
    HKEY  hKey;
    int i = 0;
    static BOOL fAllowMSTrustKey = 42;

    if(fAllowMSTrustKey == 42)
    {
       fAllowMSTrustKey = FALSE;

       if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACTIVESETUP_KEY,0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
       {
          DWORD dwSize = sizeof(DWORD);
          DWORD dwValue = 1;
          if(RegQueryValueEx(hKey, TRUSTKEYREG, NULL, NULL, (LPBYTE) &dwValue, &dwSize) == ERROR_SUCCESS)
          {
              fAllowMSTrustKey = (dwValue ? TRUE : FALSE);
          }
          RegCloseKey(hKey);
       }
    }

    if(!fAllowMSTrustKey && !bForceMSTrust && bSet)
        return;

    lstrcpy(szTmp, ".Default\\");
    lstrcat(szTmp, c_gszMSTrustRegKey);     // build the key for HKEY_USERS
    if (RegCreateKeyEx(HKEY_USERS, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, 
                    KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        if (bSet)
        {
			while (pTrustedProvider[i].dwFlag > 0)
			{
				if (dwSetMSTrustKey & pTrustedProvider[i].dwFlag)
					RegSetValueEx( hKey, pTrustedProvider[i].pValue, 0, REG_SZ, (LPBYTE)pTrustedProvider[i].pData, lstrlen(pTrustedProvider[i].pData) + 1 );
				i++;
			}            
        }
        else
        {
			while (pTrustedProvider[i].dwFlag > 0)
			{
				if (dwSetMSTrustKey & pTrustedProvider[i].dwFlag)
					RegDeleteValue(hKey, pTrustedProvider[i].pValue);
				i++;
			}
        }
        RegCloseKey(hKey);
    }

    i = 0;
    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_gszMSTrustRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, 
                    KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        if (bSet)
        {
			while (pTrustedProvider[i].dwFlag > 0)
			{
				if (dwSetMSTrustKey & pTrustedProvider[i].dwFlag)
				{
					RegSetValueEx( hKey, pTrustedProvider[i].pValue, 0, REG_SZ, (LPBYTE)pTrustedProvider[i].pData, lstrlen(pTrustedProvider[i].pData) + 1 );
				}
				i++;
			}            
        }
        else
        {
			while (pTrustedProvider[i].dwFlag > 0)
			{
				if (dwSetMSTrustKey & pTrustedProvider[i].dwFlag)
					RegDeleteValue(hKey, pTrustedProvider[i].pValue);
				i++;
			}
        }
        RegCloseKey(hKey);
    }

}

DWORD MsTrustKeyCheck()
{
    DWORD dwTmp;
    DWORD dwValue;
    HKEY  hKey;
    DWORD dwMSTrustKeyToSet = 0;
    int   i = 0;

    // Check MS Vendor trust key and set 
    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_gszMSTrustRegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
		while (pTrustedProvider[i].dwFlag > 0)
		{
			if (RegQueryValueEx( hKey, pTrustedProvider[i].pValue, 0, NULL, NULL, &dwTmp ) != ERROR_SUCCESS)
				dwMSTrustKeyToSet |= pTrustedProvider[i].dwFlag;
			i++;
		}
        RegCloseKey(hKey);
    }
    else
        dwMSTrustKeyToSet = MSTRUST_ALL;

    return dwMSTrustKeyToSet;
}

BOOL KeepTransparent(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *lres)
{
   *lres = 0;
   HWND hwndParent;
   hwndParent = GetParent(hwnd);
   if (hwndParent)
   {
      POINT pt = {0,0};
      MapWindowPoints(hwnd, hwndParent, &pt, 1);
      OffsetWindowOrgEx((HDC)wParam, pt.x, pt.y, &pt);
      *lres = SendMessage(hwndParent, msg, wParam, lParam);
      SetWindowOrgEx((HDC)wParam, pt.x, pt.y, NULL);
      if (*lres)
         return TRUE; // we handled it!
   }
   return FALSE;
}

#ifdef TESTCERT
void UpdateTrustState()
{
    HKEY    hKey;
    DWORD   dwState;
    DWORD   dwType;
    DWORD   dwSize = sizeof(dwState);

    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_gszTrustStateRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, 
                    KEY_READ | KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, c_gszState, 0, &dwType, (LPBYTE)&dwState, &dwSize) == ERROR_SUCCESS)
        {
            dwState |= TESTCERTVALUE;
        }
        else
            dwState = TESTCERTVALUE;

        RegSetValueEx( hKey, c_gszState, 0, REG_DWORD, (LPBYTE)&dwState, sizeof(dwState));
        RegCloseKey(hKey);
    }
}

void ResetTestrootCertInTrustState()
{
    HKEY    hKey;
    DWORD   dwState;
    DWORD   dwType;
    DWORD   dwSize = sizeof(dwState);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_gszTrustStateRegKey, 0, 
                    KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, c_gszState, 0, &dwType, (LPBYTE)&dwState, &dwSize) == ERROR_SUCCESS)
        {
            // Clear the bits for trusting test root certs
            dwState &= (DWORD)~TESTCERTVALUE;
            RegSetValueEx( hKey, c_gszState, 0, REG_DWORD, (LPBYTE)&dwState, sizeof(dwState));
        }
        RegCloseKey(hKey);
    }
}
#endif

void WriteActiveSetupValue(BOOL bSet)
// If bSet is TRUE, add a reg value so that if IE4 base is installed, it would think that it is
// being run from Active Setup.  This would prevent softboot from being kicked off by IE4 base.
// If bSet is FALSE, delete the reg value.
{
   static const char c_szIE4Options[] = "Software\\Microsoft\\IE Setup\\Options";
   static const char c_szActiveSetup[] = "ActiveSetup";
   HKEY hk;
   LONG lErr;

   lErr = bSet ?
          RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szIE4Options, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hk, NULL) :
          RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szIE4Options, 0, KEY_WRITE, &hk);

   if (lErr == ERROR_SUCCESS)
   {
      if (bSet)
      {
         DWORD dwData = 1;

         RegSetValueEx(hk, c_szActiveSetup, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData));
      }
      else
         RegDeleteValue(hk, c_szActiveSetup);

      RegCloseKey(hk);
   }
}

DWORD WaitForEvent(HANDLE hEvent, HWND hwnd)
{
   BOOL fQuit = FALSE;
   BOOL fDone = FALSE;
   DWORD dwRet;
   while(!fQuit && !fDone)
   {
      dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, 
                                        INFINITE, QS_ALLINPUT);
      // Give abort the highest priority
      if(dwRet == WAIT_OBJECT_0)
      {
         fDone = TRUE;
      }
      else
      {
         MSG msg;
         // read all of the messages in this next loop 
         // removing each message as we read it 
         while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
         { 
            if(!hwnd || !IsDialogMessage(hwnd, &msg))
            {
              // if it's a quit message we're out of here 
              if (msg.message == WM_QUIT)
                fQuit = TRUE; 
              else
              {
                 // otherwise dispatch it 
                TranslateMessage(&msg);
                DispatchMessage(&msg); 
              }
            } // end of PeekMessage while loop 
         }
      }
   }
   return (fQuit ? EVENTWAIT_QUIT : EVENTWAIT_DONE);  
}

#define SHFREE_ORDINAL    195           // Required for BrowseForDir

const char achSHBrowseForFolder[]          = "SHBrowseForFolder";
const char achSHGetPathFromIDList[]        = "SHGetPathFromIDList";
const char achShell32Lib[]                 = "Shell32.dll";

//***************************************************************************
//***************************************************************************
// Required for BrowseForDir()
int CALLBACK BrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch(uMsg) 
    {
      case BFFM_INITIALIZED:
        // lpData is the path string
        SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
        break;
    }
    return 0;
}

typedef WINSHELLAPI LPITEMIDLIST (WINAPI *SHBROWSEFORFOLDER)(LPBROWSEINFO);
typedef WINSHELLAPI void (WINAPI *SHFREE)(LPVOID);
typedef WINSHELLAPI BOOL (WINAPI *SHGETPATHFROMIDLIST)( LPCITEMIDLIST, LPTSTR );
//***************************************************************************
//*                                                                         *
//* NAME:       BrowseForDir                                                *
//*                                                                         *
//* SYNOPSIS:   Let user browse for a directory on their system or network. *
//*                                                                         *
//* REQUIRES:   hwndParent:                                                 *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//* NOTES:      It would be really cool to set the status line of the       *
//*             browse window to display "Yes, there's enough space", or    *
//*             "no there is not".                                          *
//*                                                                         *
//***************************************************************************
BOOL BrowseForDir( HWND hwndParent, LPSTR pszFolder, LPSTR pszTitle)
{
    BROWSEINFO   bi;
    LPITEMIDLIST pidl;
    HINSTANCE    hShell32Lib;
    SHFREE       pfSHFree;
    SHGETPATHFROMIDLIST        pfSHGetPathFromIDList;
    SHBROWSEFORFOLDER          pfSHBrowseForFolder;
    BOOL        fChange = FALSE;

    // Load the Shell 32 Library to get the SHBrowseForFolder() features

    if ( ( hShell32Lib = LoadLibrary( achShell32Lib ) ) != NULL )  
    {

       if ( ( !( pfSHBrowseForFolder = (SHBROWSEFORFOLDER)
                      GetProcAddress( hShell32Lib, achSHBrowseForFolder ) ) )
             || ( ! ( pfSHFree = (SHFREE) GetProcAddress( hShell32Lib,
                      MAKEINTRESOURCE(SHFREE_ORDINAL) ) ) )
             || ( ! ( pfSHGetPathFromIDList = (SHGETPATHFROMIDLIST)
                      GetProcAddress( hShell32Lib, achSHGetPathFromIDList ) ) ) )
        {
            FreeLibrary( hShell32Lib );
            return FALSE;
        }
    } 
    else  
    {
        return FALSE;
    }
 
    bi.hwndOwner      = hwndParent;
    bi.pidlRoot       = NULL;
    bi.pszDisplayName = NULL;
    bi.lpszTitle      = pszTitle;
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;
    bi.lpfn           = BrowseCallback;
    bi.lParam         = (LPARAM)pszFolder;
   
    pidl              = pfSHBrowseForFolder( &bi );


    if ( pidl )  
    {
       pfSHGetPathFromIDList( pidl, pszFolder );
       pfSHFree( pidl );
       fChange = TRUE;
    }

    FreeLibrary( hShell32Lib );
    return fChange;
}

BOOL IsSiteInRegion(IDownloadSite *pISite, LPSTR pszRegion)
{
   BOOL bInRegion = FALSE;
   DOWNLOADSITE *psite;

   if(SUCCEEDED(pISite->GetData(&psite)))
   {
      if(lstrcmpi(psite->pszRegion, pszRegion) == 0)
         bInRegion = TRUE;
   }

   return bInRegion;
}

void SetControlFont()
{
   LOGFONT lFont;

   if (GetSystemMetrics(SM_DBCSENABLED) &&
       (GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof (lFont), &lFont) > 0))
   {
       g_hFont = CreateFontIndirect((LPLOGFONT)&lFont);
   }
}

void SetFontForControl(HWND hwnd, UINT uiID)
{
   if (g_hFont)
   {
      SendDlgItemMessage(hwnd, uiID, WM_SETFONT, (WPARAM)g_hFont ,0L);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\autoobj.cpp ===
//=--------------------------------------------------------------------------=
// AutoObj.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown, dispatch and
// error info implementations for them.
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "Globals.H"
#include "Util.H"


// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// CAutomationObject::CAutomationObject
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    IUnknown *      - [in] controlling Unknown
//    int             - [in] the object type that we are
//    void *          - [in] the VTable of of the object we really are.
//
// Notes:
//
CAutomationObject::CAutomationObject 
(
    IUnknown *pUnkOuter,
    int   ObjType,
    void *pVTable,
	BOOL fExpandoEnabled
)
: CUnknownObject(pUnkOuter, pVTable), m_ObjectType (ObjType)
{
    m_fLoadedTypeInfo = FALSE;
	m_fExpandoEnabled = (BYTE)fExpandoEnabled;
	m_pexpando = NULL;
}


//=--------------------------------------------------------------------------=
// CAutomationObject::~CAutomationObject
//=--------------------------------------------------------------------------=
// "I have a rendezvous with Death, At some disputed barricade"
// - Alan Seeger (1888-1916)
//
// Notes:
//
CAutomationObject::~CAutomationObject ()
{
    // if we loaded up a type info, release our count on the globally stashed
    // type infos, and release if it becomes zero.
    //
    if (m_fLoadedTypeInfo) {

        // we have to crit sect this since it's possible to have more than
        // one thread partying with this object.
        //
        EnterCriticalSection(&g_CriticalSection);
        ASSERT(CTYPEINFOOFOBJECT(m_ObjectType), "Bogus ref counting on the Type Infos");
        CTYPEINFOOFOBJECT(m_ObjectType)--;

        // if we're the last one, free it!
        //
        if (!CTYPEINFOOFOBJECT(m_ObjectType)) {
            PTYPEINFOOFOBJECT(m_ObjectType)->Release();
            PTYPEINFOOFOBJECT(m_ObjectType) = NULL;
        }
        LeaveCriticalSection(&g_CriticalSection);
    }

	if (m_pexpando)
	{
		delete m_pexpando;
	}
    return;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// the controlling unknown will call this for us in the case where they're
// looking for a specific interface.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CAutomationObject::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    ASSERT(ppvObjOut, "controlling Unknown should be checking this!");

    // start looking for the guids we support, namely IDispatch, and 
    // IDispatchEx

    if (DO_GUIDS_MATCH(riid, IID_IDispatch)) {
		// If expando functionality is enabled, attempt to allocate an
		// expando object and return that for the IDispatch interface.
		// If the allocation fails, we will fall back on using the regular
		// IDispatch from m_pvInterface;
		if (m_fExpandoEnabled)
		{
			if (!m_pexpando)
				m_pexpando = new CExpandoObject(m_pUnkOuter, (IDispatch*) m_pvInterface);  

			if (m_pexpando)
			{
				*ppvObjOut = (void*)(IDispatch*) m_pexpando;
				((IUnknown *)(*ppvObjOut))->AddRef();
				return S_OK;
			}
		}

        *ppvObjOut = (void*) (IDispatch*) m_pvInterface;
        ((IUnknown *)(*ppvObjOut))->AddRef();
        return S_OK;
    }
    else if (DO_GUIDS_MATCH(riid, IID_IDispatchEx) && m_fExpandoEnabled) {
		// Allocate the expando object if it hasn't been allocated already
		if (!m_pexpando)
			m_pexpando = new CExpandoObject(m_pUnkOuter, (IDispatch*) m_pvInterface);  

		// If the allocation succeeded, return the IDispatchEx interface from
		// the expando.  Otherwise fall through to CUnknownObject::InternalQueryInterface,
		// (which will most likely fail)
		if (m_pexpando)
		{
			 *ppvObjOut = (void *)(IDispatchEx *) m_pexpando;
			((IUnknown *)(*ppvObjOut))->AddRef();
			return S_OK;
		}
    }

    // just get our parent class to process it from here on out.
    //
    return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfoCount
//=--------------------------------------------------------------------------=
// returns the number of type information interfaces that the object provides
//
// Parameters:
//    UINT *            - [out] the number of interfaces supported.
//
// Output:
//    HRESULT           - S_OK, E_NOTIMPL, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfoCount
(
    UINT *pctinfo
)
{
    // arg checking
    //
    if (!pctinfo)
        return E_INVALIDARG;

    // we support GetTypeInfo, so we need to return the count here.
    //
    *pctinfo = 1;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfo
//=--------------------------------------------------------------------------=
// Retrieves a type information object, which can be used to get the type
// information for an interface.
//
// Parameters:
//    UINT              - [in]  the type information they'll want returned
//    LCID              - [in]  the LCID of the type info we want
//    ITypeInfo **      - [out] the new type info object.
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, etc.
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfo
(
    UINT        itinfo,
    LCID        lcid,
    ITypeInfo **ppTypeInfoOut
)
{
    DWORD       dwPathLen;
    char        szDllPath[MAX_PATH];
    HRESULT     hr;
    ITypeLib   *pTypeLib;
    ITypeInfo **ppTypeInfo =NULL;

    // arg checking
    //
    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (!ppTypeInfoOut)
        return E_POINTER;

    *ppTypeInfoOut = NULL;

    // ppTypeInfo will point to our global holder for this particular
    // type info.  if it's null, then we have to load it up. if it's not
    // NULL, then it's already loaded, and we're happy.
    // crit sect this entire nightmare so we're okay with multiple
    // threads trying to use this object.
    //
    EnterCriticalSection(&g_CriticalSection);
    ppTypeInfo = PPTYPEINFOOFOBJECT(m_ObjectType);

    if (*ppTypeInfo == NULL) {

        ITypeInfo *pTypeInfoTmp;
        HREFTYPE   hrefType;

        // we don't have the type info around, so go load it.
        //
        hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0,
                            LANG_NEUTRAL, &pTypeLib);

        // if, for some reason, we failed to load the type library this
        // way, we're going to try and load the type library directly out of
        // our resources.  this has the advantage of going and re-setting all
        // the registry information again for us.
        //
        if (FAILED(hr)) {

            dwPathLen = GetModuleFileName(g_hInstance, szDllPath, MAX_PATH);
            if (!dwPathLen) {
                hr = E_FAIL;
                goto CleanUp;
            }

            MAKE_WIDEPTR_FROMANSI(pwsz, szDllPath);
            hr = LoadTypeLib(pwsz, &pTypeLib);
            CLEANUP_ON_FAILURE(hr);
        }

        // we've got the Type Library now, so get the type info for the interface
        // we're interested in.
        //
        hr = pTypeLib->GetTypeInfoOfGuid((REFIID)INTERFACEOFOBJECT(m_ObjectType), &pTypeInfoTmp);
        pTypeLib->Release();
        CLEANUP_ON_FAILURE(hr);

        // the following couple of lines of code are to dereference the dual
        // interface stuff and take us right to the dispatch portion of the
        // interfaces.
        //
        hr = pTypeInfoTmp->GetRefTypeOfImplType(0xffffffff, &hrefType);
        if (FAILED(hr)) {
            pTypeInfoTmp->Release();
            goto CleanUp;
        }

        hr = pTypeInfoTmp->GetRefTypeInfo(hrefType, ppTypeInfo);
        pTypeInfoTmp->Release();
        CLEANUP_ON_FAILURE(hr);

        // add an extra reference to this object.  if it ever becomes zero, then
        // we need to release it ourselves.  crit sect this since more than
        // one thread can party on this object.
        //
        CTYPEINFOOFOBJECT(m_ObjectType)++;
        m_fLoadedTypeInfo = TRUE;
    }


    // we still have to go and addref the Type info object, however, so that
    // the people using it can release it.
    //
    (*ppTypeInfo)->AddRef();
    *ppTypeInfoOut = *ppTypeInfo;
    hr = S_OK;

  CleanUp:
    LeaveCriticalSection(&g_CriticalSection);
    return hr;
}



//=--------------------------------------------------------------------------=
// CAutomationObject::GetIDsOfNames
//=--------------------------------------------------------------------------=
// Maps a single member and an optional set of argument names to a
// corresponding set of integer DISPIDs
//
// Parameters:
//    REFIID            - [in]  must be IID_NULL
//    OLECHAR **        - [in]  array of names to map.
//    UINT              - [in]  count of names in the array.
//    LCID              - [in]  LCID on which to operate
//    DISPID *          - [in]  place to put the corresponding DISPIDs.
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY, DISP_E_UNKNOWNNAME,
//                        DISP_E_UNKNOWNLCID
//
// Notes:
//    - we're just going to use DispGetIDsOfNames to save us a lot of hassle,
//      and to let this superclass handle it.
//
STDMETHODIMP CAutomationObject::GetIDsOfNames
(
    REFIID    riid,
    OLECHAR **rgszNames,
    UINT      cNames,
    LCID      lcid,
    DISPID   *rgdispid
)
{
    HRESULT     hr;
    ITypeInfo  *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get the type info for this dude!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // use the standard provided routines to do all the work for us.
    //
    hr = pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    pTypeInfo->Release();

    return hr;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::Invoke
//=--------------------------------------------------------------------------=
// provides access to the properties and methods on this object.
//
// Parameters:
//    DISPID            - [in]  identifies the member we're working with.
//    REFIID            - [in]  must be IID_NULL.
//    LCID              - [in]  language we're working under
//    USHORT            - [in]  flags, propput, get, method, etc ...
//    DISPPARAMS *      - [in]  array of arguments.
//    VARIANT *         - [out] where to put result, or NULL if they don't care.
//    EXCEPINFO *       - [out] filled in in case of exception
//    UINT *            - [out] where the first argument with an error is.
//
// Output:
//    HRESULT           - tonnes of them.
//
// Notes:
//    
STDMETHODIMP CAutomationObject::Invoke
(
    DISPID      dispid,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS *pdispparams,
    VARIANT    *pvarResult,
    EXCEPINFO  *pexcepinfo,
    UINT       *puArgErr
)
{
    HRESULT    hr;
    ITypeInfo *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get our typeinfo first!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // Clear exceptions
    //
    SetErrorInfo(0L, NULL);

    // This is exactly what DispInvoke does--so skip the overhead.
    //
    hr = pTypeInfo->Invoke(m_pvInterface, dispid, wFlags,
                           pdispparams, pvarResult,
                           pexcepinfo, puArgErr);
    pTypeInfo->Release();

	return hr;

}

//=--------------------------------------------------------------------------=
// CAutomationObject::Exception
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// Parameters:
//    HRESULT          - [in] the SCODE that should be associated with this err
//    WORD             - [in] the RESOURCE ID of the error message.
//    DWORD            - [in] helpcontextid for the error
//
// Output:
//    HRESULT          - the HRESULT that was passed in.
//
// Notes:
//
HRESULT CAutomationObject::Exception
(
    HRESULT hrExcep,
    WORD    idException,
    DWORD   dwHelpContextID
)
{
    ICreateErrorInfo *pCreateErrorInfo;
    IErrorInfo *pErrorInfo;
    WCHAR   wszTmp[256];
    char    szTmp[256];
    HRESULT hr;


    // first get the createerrorinfo object.
    //
    hr = CreateErrorInfo(&pCreateErrorInfo);
    if (FAILED(hr)) return hrExcep;

    MAKE_WIDEPTR_FROMANSI(wszHelpFile, HELPFILEOFOBJECT(m_ObjectType));

    // set up some default information on it.
    //
    pCreateErrorInfo->SetGUID((REFIID)INTERFACEOFOBJECT(m_ObjectType));
    pCreateErrorInfo->SetHelpFile(wszHelpFile);
    pCreateErrorInfo->SetHelpContext(dwHelpContextID);

    // load in the actual error string value.  max of 256.
    //
    LoadString(GetResourceHandle(), idException, szTmp, 256);
    MultiByteToWideChar(CP_ACP, 0, szTmp, -1, wszTmp, 256);
    pCreateErrorInfo->SetDescription(wszTmp);

    // load in the source
    //
    MultiByteToWideChar(CP_ACP, 0, NAMEOFOBJECT(m_ObjectType), -1, wszTmp, 256);
    pCreateErrorInfo->SetSource(wszTmp);

    // now set the Error info up with the system
    //
    hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pErrorInfo);
    CLEANUP_ON_FAILURE(hr);

    SetErrorInfo(0, pErrorInfo);
    pErrorInfo->Release();

  CleanUp:
    pCreateErrorInfo->Release();
    return hrExcep;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
// indicates whether or not the given interface supports rich error information
//
// Parameters:
//    REFIID        - [in] the interface we want the answer for.
//
// Output:
//    HRESULT       - S_OK = Yes, S_FALSE = No.
//
// Notes:
//
HRESULT CAutomationObject::InterfaceSupportsErrorInfo
(
    REFIID riid
)
{
    // see if it's the interface for the type of object that we are.
    //
    if (riid == (REFIID)INTERFACEOFOBJECT(m_ObjectType))
        return S_OK;

    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetResourceHandle    [helper]
//=--------------------------------------------------------------------------=
// virtual routine to get the resource handle.  virtual, so that inheriting
// objects, such as COleControl can use theirs instead, which goes and gets
// the Host's version ...
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CAutomationObject::GetResourceHandle
(
    void
)
{
    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\classf.h ===
//=--------------------------------------------------------------------------=
// ClassF.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// header for the ClassFactory Object.  we support IClassFactory and 
// IClassFactory2
//
#ifndef _CLASSF_H_

#include "olectl.h"

class CClassFactory : public IClassFactory2 {

  public:
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IClassFactory methods
    //
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppbObjOut);
    STDMETHOD(LockServer)(BOOL fLock);

    // IClassFactory2 methods
    //
    STDMETHOD(GetLicInfo)(LICINFO *pLicInfo);
    STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR *pbstrKey);
    STDMETHOD(CreateInstanceLic)(IUnknown *pUnkOuter, IUnknown *pUnkReserved, REFIID riid, BSTR bstrKey, void **ppvObjOut);

    CClassFactory(int iIndex);
    ~CClassFactory();

  private:
    ULONG m_cRefs;
    int   m_iIndex;
};


// global variable for Locks on our DLL
//
extern LONG g_cLocks;

#define _CLASSF_H_
#endif // _CLASSF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\ctlembed.cpp ===
//=--------------------------------------------------------------------------=
// CtlEmbed.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the interfaces required for inplace activation for
// COleControl
//

#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Globals.H"
#include "StdEnum.H"
#include "Util.H"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// all controls support the following in-place verbs at an absolute minimum.
//
#define CINPLACEVERBS 4

const VERBINFO rgInPlaceVerbs [] = {
    { OLEIVERB_SHOW,            0, 0, 0},
    { OLEIVERB_HIDE,            0, 0, 0},
    { OLEIVERB_INPLACEACTIVATE, 0, 0, 0},
    { OLEIVERB_PRIMARY,         0, 0, 0}
};

// NOTE: Resource ID for Properties string must be 1000
//
const VERBINFO ovProperties =
    { CTLIVERB_PROPERTIES, 1000, 0, OLEVERBATTRIB_ONCONTAINERMENU };

const VERBINFO ovUIActivate =
    { OLEIVERB_UIACTIVATE, 0, 0, 0};


//=--------------------------------------------------------------------------=
// COleControl::GetControlInfo    (IOleControl)
//=--------------------------------------------------------------------------=
// returns some information on a control, such as an accelerator table, and
// flags.  really used for keyboard handling and mnemonics
//
// Parameters:
//    CONTROLINFO *        - [in]  where to put said information
//
// Output:
//    HRESULT              - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetControlInfo
(
    CONTROLINFO *pControlInfo
)
{
    CHECK_POINTER(pControlInfo);

    // certain hosts have a bug in which it doesn't initialize the cb in the
    // CONTROLINFO structure, so we can only assert on that here.
    //
    ASSERT(pControlInfo->cb == sizeof(CONTROLINFO), "Host doesn't initialize CONTROLINFO structure");

    // NOTE: control writers should override this routine if they want to
    // return accelerator information in their control.
    //
    pControlInfo->hAccel = NULL;
    pControlInfo->cAccel = NULL;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnMnemonic    [IOleControl]
//=--------------------------------------------------------------------------=
// the container has decided to pass on a key that the end-user has pressed to
// us.  default implementation will be to just activate the control.  people
// looking for more functionality should override this method.
//
// Parameters:
//    LPMSG                - [in] message for this mnemonic
//
// Output:
//    HRESULT              - S_OK, E_POINTER
//
// Notes:
//
STDMETHODIMP COleControl::OnMnemonic
(
    LPMSG pMsg
)
{
    // OVERRIDE: default implementation is to just activate our control.  
    // user can override if they want more interesting behaviour.
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl:OnAmbientPropertyChange    [IOleControl]
//=--------------------------------------------------------------------------=
// a container calls this whenever it changes an ambient property.
//
// Parameters:
//    DISPID            - [in] dispid of the property that changed.
//
// Output:
//    HRESULT           - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnAmbientPropertyChange
(
    DISPID dispid
)
{
    // if we're being told about a change in mode [design/run] then
    // remember that so our stashing of mode will update itself
    // correctly
    //
    if (dispid == DISPID_AMBIENT_USERMODE || dispid == DISPID_UNKNOWN)
        m_fModeFlagValid = FALSE;

    // just pass this on to the derived control and see if they want
    // to do anything with it.
    //
    AmbientPropertyChanged(dispid);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControL::FreezeEvents    [IOleControl]
//=--------------------------------------------------------------------------=
// allows a container to freeze all of a controls events.  when events are
// frozen, a control will not fire any of them.
//
// Parameters:
//    BOOL            - [in] TRUE means FREEZE, FALSE means THAW
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//    - we maintain an internal count of freezes versus thaws.
//
STDMETHODIMP COleControl::FreezeEvents
(
    BOOL fFreeze
)
{
    // OVERRIDE: by default, we don't care.  user can override if they want to.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// informs the embedded object [control] of it's client site [display
// location] within it's container
//
// Parameters:
//    IOleClientSite *        - [in] pointer to client site.
//
// Output:
//    HRESULT                 - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetClientSite
(
    IOleClientSite *pClientSite
)
{
    RELEASE_OBJECT(m_pClientSite);
    RELEASE_OBJECT(m_pControlSite);
    RELEASE_OBJECT(m_pSimpleFrameSite);

    // store away the new client site
    //
    m_pClientSite = pClientSite;

    // if we've actually got one, then get some other interfaces we want to keep
    // around, and keep a handle on it
    //
    if (m_pClientSite) {
        m_pClientSite->AddRef();
        m_pClientSite->QueryInterface(IID_IOleControlSite, (void **)&m_pControlSite);

        if (OLEMISCFLAGSOFCONTROL(m_ObjectType) & OLEMISC_SIMPLEFRAME)
            m_pClientSite->QueryInterface(IID_ISimpleFrameSite, (void **)&m_pSimpleFrameSite);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// obtains a pointer to the controls client site.
//
// Parameters:
//    IOleClientSite **        - [out]
//
// Output:
//    HRESULT                  - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetClientSite
(
    IOleClientSite **ppClientSite
)
{
    CHECK_POINTER(ppClientSite);

    *ppClientSite = m_pClientSite;
    ADDREF_OBJECT(*ppClientSite);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetHostNames    [IOleObject]
//=--------------------------------------------------------------------------=
// Provides the control with the name of its container application and the
// compound document in which it is embedded
//
// Parameters:
//    LPCOLESTR        - [in] name of container application
//    LPCOLESTR        - [in] name of container document
//
// Output:
//    HRESULT          - S_OK
//
// Notes:
//    - we don't care about this
//
STDMETHODIMP COleControl::SetHostNames
(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObject
)
{
    // we don't care about these
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Close    [IOleObject]
//=--------------------------------------------------------------------------=
// Changes the control from the running to the loaded state
//
// Parameters:
//    DWORD             - [in] indicates whether to save the object before closing
//
// Output:
//    HRESULT           - S_OK, OLE_E_PROMPTSAVECANCELLED
//
// Notes:
//
STDMETHODIMP COleControl::Close
(
    DWORD dwSaveOption
)
{
    HRESULT hr;

    if (m_fInPlaceActive) {
        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
    }

    // handle the save flag.
    //
    if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY || dwSaveOption == OLECLOSE_PROMPTSAVE) && m_fDirty) {
        if (m_pClientSite) m_pClientSite->SaveObject();
        if (m_pOleAdviseHolder) m_pOleAdviseHolder->SendOnSave();
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Notifies an object of its container's moniker, the object's own moniker
// relative to the container, or the object's full moniker
//
// Parameters:
//    DWORD                - [in] which moniker is being set
//    IMoniker *           - [in] the moniker
//
// Output:
//    HRESULT              - S_OK, E_FAIL
//
// Notes:
//    - we don't support monikers.
//
STDMETHODIMP COleControl::SetMoniker
(
    DWORD     dwWhichMoniker,
    IMoniker *pMoniker
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a embedded object's moniker, which the caller can use to link to
// the object
//
// Parameters:
//    DWORD            - [in]  how it's assigned
//    DWORD            - [in]  which moniker
//    IMoniker **      - [out] duh.
//
// Output:
//    HRESULT          - E_NOTIMPL
//
// Notes:
//    - we don't support monikers
//
STDMETHODIMP COleControl::GetMoniker
(
    DWORD      dwAssign,
    DWORD      dwWhichMoniker,
    IMoniker **ppMonikerOut
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InitFromData    [IOleObject]
//=--------------------------------------------------------------------------=
// Initializes a newly created object with data from a specified data object,
// which can reside either in the same container or on the Clipboard
//
// Parameters:
//    IDataObject*    - [in] data object with the data
//    BOOL            - [in] how object is created
//    DWORD           - reserved
//
// Output:
//    HRESULT         - S_OK, S_FALSE, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't have data object support
//
STDMETHODIMP COleControl::InitFromData
(
    IDataObject *pDataObject,
    BOOL         fCreation,
    DWORD        dwReserved
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClipboardData    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves a data object containing the current contents of the control.
// Using the pointer to this data object, it is possible to create a new control
// with the same data as the original
//
// Parameters:
//    DWORD          - reserved
//    IDataObject ** - [out] data object for this control
//
// Output:
//    HREUSLT        - S_OK, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::GetClipboardData
(
    DWORD         dwReserved,
    IDataObject **ppDataObject
)
{
    *ppDataObject = NULL;        // be a good neighbour
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::DoVerb    [IOleObject]
//=--------------------------------------------------------------------------=
// Requests an object to perform an action in response to an end-user's
// action.
//
// Parameters:
//    LONG             - [in]  verb to be performed
//    LPMSG            - [in]  event that invoked the verb
//    IOleClientSite * - [in]  the controls active client site
//    LONG             - [in]  reserved
//    HWND             - [in]  handle of window containing the object.
//    LPCRECT          - [in]  pointer to objects's display rectangle
//
// Output:
//    HRESULT          - S_OK, OLE_E_NOTINPLACEACTIVE, OLE_E_CANT_BINDTOSOURCE,
//                       DV_E_LINK, OLEOBJ_S_CANNOT_DOVERB_NOW, OLEOBJ_S_INVALIDHWND,
//                       OLEOBJ_E_NOVERBS, OLEOBJ_S_INVALIDVERB, MK_E_CONNECT,
//                       OLE_CLASSDIFF, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::DoVerb
(
    LONG            lVerb,
    LPMSG           pMsg,
    IOleClientSite *pActiveSite,
    LONG            lIndex,
    HWND            hwndParent,
    LPCRECT         prcPosRect
)
{
    HRESULT hr;

    switch (lVerb) {
      case OLEIVERB_SHOW:
      case OLEIVERB_INPLACEACTIVATE:
      case OLEIVERB_UIACTIVATE:
        hr = InPlaceActivate(lVerb);
        OnVerb(lVerb);
        return (hr);

      case OLEIVERB_HIDE:
        UIDeactivate();
        if (m_fInPlaceVisible) SetInPlaceVisible(FALSE);
        OnVerb(lVerb);
        return S_OK;

      // we used to have OLEIVERB_PRIMARY InPlaceActivate Ourselves, but it
      // turns out that the CDK and certain hosts expect this to show the
      // properties instead.  Users can change what this verb does at will.
      //
      case OLEIVERB_PRIMARY:
      case CTLIVERB_PROPERTIES:
      case OLEIVERB_PROPERTIES:
        {
        // show the frame ourselves if the hose can't.
        //
        if (m_pControlSite) {
            hr = m_pControlSite->ShowPropertyFrame();
            if (hr != E_NOTIMPL)
                return hr;
        }
        IUnknown *pUnk = (IUnknown *)(IOleObject *)this;
        MAKE_WIDEPTR_FROMANSI(pwsz, NAMEOFOBJECT(m_ObjectType));

        ModalDialog(TRUE);
        hr = OleCreatePropertyFrame(GetActiveWindow(),
                            GetSystemMetrics(SM_CXSCREEN) / 2,
                            GetSystemMetrics(SM_CYSCREEN) / 2,
                            pwsz,
                            1,
                            &pUnk,
                            CPROPPAGESOFCONTROL(m_ObjectType),
                            (LPCLSID)*(PPROPPAGESOFCONTROL(m_ObjectType)),
                            g_lcidLocale,
                            NULL, NULL);
        ModalDialog(FALSE);
        return hr;
        }

      default:
        // if it's a derived-control defined verb, pass it on to them
        //
        if (lVerb > 0) {
            hr = DoCustomVerb(lVerb);

            if (hr == OLEOBJ_S_INVALIDVERB) {
                // unrecognised verb -- just do the primary verb and
                // activate it.
                //
                hr = InPlaceActivate(OLEIVERB_PRIMARY);
                return (FAILED(hr)) ? hr : OLEOBJ_S_INVALIDVERB;
            } else
                return hr;
        } else {
            FAIL("Unrecognized Negative verb in DoVerb().  bad.");
            return E_NOTIMPL;
        }
        break;
    }

    // dead code
    FAIL("this should be dead code!");
}

//=--------------------------------------------------------------------------=
// COleControl::EnumVerbs    [IOleObject]
//=--------------------------------------------------------------------------=
// create an enumerator object for the verbs this object supports.
//
// Parameters:
//    IEnumOleVERB **    - [out] new enumerator.
//
// Output:
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::EnumVerbs
(
    IEnumOLEVERB **ppEnumVerbs
)
{
    int cVerbs;
    OLEVERB *rgVerbs, *pVerb;

    DWORD dw = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    BOOL fCanInPlace = !(dw & OLEMISC_INVISIBLEATRUNTIME) || (dw & OLEMISC_ACTIVATEWHENVISIBLE);
    BOOL fCanUIActivate = !(dw & OLEMISC_NOUIACTIVATE);
    BOOL fHasProperties = (CPROPPAGESOFCONTROL(m_ObjectType) != 0);

    int cVerbExtra = CCUSTOMVERBSOFCONTROL(m_ObjectType);

    // count up all the verbs
    //
    cVerbs = (fCanInPlace ? CINPLACEVERBS : 0) + (fCanUIActivate ? 1 : 0)
             + (fHasProperties ? 1 : 0) + cVerbExtra;

    // if there aren't any, this suddenly gets really easy !
    //
    if (cVerbs == 0)
        return OLEOBJ_E_NOVERBS;

    // HeapAlloc some storage for these dudes so that we can pass them on to
    // the standard enumerator!
    //
    if (! (rgVerbs = (OLEVERB *)HeapAlloc(g_hHeap, 0, cVerbs * sizeof(OLEVERB))))
        return E_OUTOFMEMORY;
  
    // start copying over verbs.  first, the in-place guys
    //
    pVerb = rgVerbs;
    if (fCanInPlace) {
        memcpy(pVerb, rgInPlaceVerbs, CINPLACEVERBS * sizeof(OLEVERB));
        pVerb += CINPLACEVERBS;
      }

    if (fCanUIActivate)
        memcpy(pVerb++, &ovUIActivate, sizeof(OLEVERB));

    // if their control has properties, copy that over now.
    //
    if (fHasProperties) {
        memcpy(pVerb, &ovProperties, sizeof(OLEVERB));
        pVerb++;
    }

    // finally, any custom verbs!
    //
    if (cVerbExtra) {
        memcpy(pVerb, CUSTOMVERBSOFCONTROL(m_ObjectType), sizeof(OLEVERB) * cVerbExtra);
    }

    *ppEnumVerbs = (IEnumOLEVERB *) (IEnumGeneric *) new CStandardEnum(IID_IEnumOLEVERB,
                                     cVerbs, sizeof(OLEVERB), rgVerbs, CopyOleVerb);
    if (!*ppEnumVerbs)
        return E_OUTOFMEMORY;

    // this forces us to go and look for the Localized DLLs.  This is necessary here
    // because the CopyOleVerb will get information from localized resources, but
    // will only use the global GetResourceHandle, which only uses the global value
    // for the LCID.  This turns out to not be a big performance hit, since this
    // function is typically only called in design mode, and we stash this value.
    //
    GetResourceHandle();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Update    [IOleObject]
//=--------------------------------------------------------------------------=
// Updates an object handler's or link object's data or view caches.
//
// Output:
//    HRESULT            - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::Update
(
    void
)
{
    // nothing to do!!!
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::IsUpToDate    [IOleObject]
//=--------------------------------------------------------------------------=
// Checks recursively whether or not an object is up to date.
//
// Output:
//    HRESULT        - S_OK, S_FALSE, OLE_E_UNVAILABLE
//
// Notes:
//
STDMETHODIMP COleControl::IsUpToDate
(
    void
)
{
    // we're always up to date
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserClassID    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns the controls class identifier, the CLSID corresponding to the
// string identifying the object to an end user.
//
// Parameters:
//    CLSID *      - [in] where to put the CLSID
//
// Output:
//    HRESULT      - S_OK, E_FAIL
//
// Notes:
//
STDMETHODIMP COleControl::GetUserClassID
(
    CLSID *pclsid
)
{
    // this is the same as IPersist::GetClassID
    //
    return GetClassID(pclsid);
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserType    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the user-type name of the control for display in user-interface
// elements such as menus, list boxes, and dialog boxes.
//
// Parameters:
//    DWORD        - [in]  specifies the form of the type name.
//    LPOLESTR *   - [out] where to put user type
//
// Output:
//    HRESULT      - S_OK, OLE_S_USEREG, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::GetUserType
(
    DWORD     dwFormOfType,
    LPOLESTR *ppszUserType
)
{
    *ppszUserType = OLESTRFROMANSI(NAMEOFOBJECT(m_ObjectType));
    return (*ppszUserType) ? S_OK : E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// COleControl::SetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Informs the control of how much display space its container has assigned it.
//
// Parameters:
//    DWORD            - [in] which form or 'aspect'  is to be displayed.
//    SIZEL *          - [in] size limit for the control.
//
// Output:
//    HRESULT          - S_OK, E_FAIL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::SetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *psizel
)
{
    SIZEL sl;
    RECT  rect;
    BOOL  f;

    if (dwDrawAspect & DVASPECT_CONTENT) {

        // change the units to pixels, and resize the control.
        //
        HiMetricToPixel(psizel, &sl);

        // first call the user version.  if they return FALSE, they want
        // to keep their current size
        //
        f = OnSetExtent(&sl);
        if (f)
            HiMetricToPixel(psizel, &m_Size);

        // set things up with our HWND if we've got one.
        //
        if (!m_pInPlaceSiteWndless) {
            if (m_fInPlaceActive) {
    
                // theoretically, one should not need to call OnPosRectChange
                // here, but there appear to be a few host related issues that
                // will make us keep it here.  we won't, however, both with
                // windowless ole controls, since they are all new hosts who
                // should know better
                //
                GetWindowRect(m_hwnd, &rect);
                MapWindowPoints(NULL, m_hwndParent, (LPPOINT)&rect, 2);
                rect.right = rect.left + m_Size.cx;
                rect.bottom = rect.top + m_Size.cy;
                m_pInPlaceSite->OnPosRectChange(&rect);
    
                if (m_hwnd) {
                    // just go and resize
                    //
                    if (m_hwndReflect)
                        SetWindowPos(m_hwndReflect, 0, 0, 0, m_Size.cx, m_Size.cy,
                                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
                    SetWindowPos(m_hwnd, 0, 0, 0, m_Size.cx, m_Size.cy,
                                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
                }
            } else if (m_hwnd) {
                SetWindowPos(m_hwnd, NULL, 0, 0, m_Size.cx, m_Size.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            } else {
                ViewChanged();
            }
        } else
            if (m_pInPlaceSite) m_pInPlaceSite->OnPosRectChange(&rect);

        // return code depending on whether or not user accepted given
        // size
        //
        return (f) ? S_OK : E_FAIL;

    } else {
        // we don't support any other aspects.
        //
        return DV_E_DVASPECT;
    }

    // dead code
    FAIL("This should be dead code");
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the control's current display size.
//
// Parameters:
//    DWORD            - [in] aspect
//    SIZEL *          - [in] where to put results
//
// Output:
//    S_OK, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *pSizeLOut
)
{

    if (dwDrawAspect & DVASPECT_CONTENT) {
        PixelToHiMetric((const SIZEL *)&m_Size, pSizeLOut);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::Advise    [IOleObject]
//=--------------------------------------------------------------------------=
// establishes and advisory connection between the control and the container,
// in which the control will notify the container of certain events.
//
// Parameters:
//    IAdviseSink *     - [in]  advise sink of calling object
//    DWORD             - [out] cookie
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::Advise
(
    IAdviseSink *pAdviseSink,
    DWORD       *pdwConnection
)
{
    HRESULT hr;

    // if we haven't yet created a standard advise holder object, do so
    // now
    //
    if (!m_pOleAdviseHolder) {
        hr = CreateOleAdviseHolder(&m_pOleAdviseHolder);
        RETURN_ON_FAILURE(hr);
    }

    // just get it to do the work for us!
    //
    return m_pOleAdviseHolder->Advise(pAdviseSink, pdwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::Unadvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Deletes a previously established advisory connection.
//
// Parameters:
//    DWORD         - [in] connection cookie
//
// Output:
//    HRESULT       - S_OK, E_FAIL, OLE_E_NOCONNECTION
//
// Notes:
//
STDMETHODIMP COleControl::Unadvise
(
    DWORD dwConnection
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody called Unadvise on IOleObject without calling Advise!");
        CONNECT_E_NOCONNECTION;
    }

    return m_pOleAdviseHolder->Unadvise(dwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::EnumAdvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Enumerates the advisory connections registered for an object, so a container
// can know what to release prior to closing down.
//
// Parameters:
//    IEnumSTATDATA **    - [out] where to put enumerator
//
// Output:
//    HRESULT             - S_OK, E_FAIL, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::EnumAdvise
(
    IEnumSTATDATA **ppEnumOut
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody Called EnumAdvise without setting up any connections");
        *ppEnumOut = NULL;
        return E_FAIL;
    }

    return m_pOleAdviseHolder->EnumAdvise(ppEnumOut);
}

//=--------------------------------------------------------------------------=
// COleControl::GetMiscStatus    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a value indicating the status of an object at creation and loading.
//
// Parameters:
//    DWORD         - [in]  aspect desired
//    DWORD *       - [out] where to put the bits.
//
// Output:
//    HRESULT       - S_OK, OLE_S_USEREG, CO_E_CLASSNOTREG, CO_E_READREGDB
//
// Notes:
//
STDMETHODIMP COleControl::GetMiscStatus
(
    DWORD  dwAspect,
    DWORD *pdwStatus
)
{
    CHECK_POINTER(pdwStatus);

    if (dwAspect == DVASPECT_CONTENT) {
        *pdwStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::SetColorScheme    [IOleObject]
//=--------------------------------------------------------------------------=
// Specifies the color palette that the object application should use when it
// edits the specified object.
//
// Parameters:
//    LOGPALETTE *     - [in] new palette
//
// Output:
//    HRESULT          - S_OK, E_NOTIMPL, OLE_E_PALETTE, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't care.
//
STDMETHODIMP COleControl::SetColorScheme
(
    LOGPALETTE *pLogpal
)
{
    // OVERRIDE: control writers can use this if they want to
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetWindow    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Returns the window handle to one of the windows participating in in-place
// activation (frame, document, parent, or in-place object window).
//
// Parameters:
//    HWND *        - [out] where to return window handle.
//
// Output:
//    HRESULT       - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL
//
// Notes:
//    - this routine has slightly different semantics for windowless controls
//
STDMETHODIMP COleControl::GetWindow
(
    HWND *phwnd
)
{
    // if we're windowles, then we want to return E_FAIL for this so hosts
    // know we're windowless
    //
    if (m_pInPlaceSiteWndless)
        return E_FAIL;

    // otherwise, just return our outer window.
    //
    *phwnd = GetOuterWindow();

    return (*phwnd) ? S_OK : E_UNEXPECTED;
}

//=--------------------------------------------------------------------------=
// COleControl::ContextSensitiveHelp    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Determines whether context-sensitive help mode should be entered during an
// in-place activation session.
//
// Parameters:
//    BOOL            - [in] whether or not to enter help mode.
//
// Output:
//    HRESULT         - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::ContextSensitiveHelp
(
    BOOL fEnterMode
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceActivate
//=--------------------------------------------------------------------------=
// activates the control, and depending on the verb, optionally ui activates
// it as well.
//
// Parameters:
//    LONG         - [in] the verb that caused us to activate
//
// Output:
//    HRESULT
//
// Notes:
//    - this is spaghetti code at it's worst.  effectively, we have to
//      be able to handle three types of site pointers -- IOleInPlaceSIte,
//      IOleInPlaceSiteEx, and IOleInPlaceSiteWindowless.  not terribly
//      pretty.
//
HRESULT COleControl::InPlaceActivate
(
    LONG lVerb
)
{
    BOOL f;
    SIZEL sizel;
    IOleInPlaceSiteEx *pIPSEx = NULL;
    HRESULT hr;
    BOOL    fNoRedraw = FALSE;

    // if we don't have a client site, then there's not much to do.
    //
    if (!m_pClientSite)
        return S_OK;

    // get an InPlace site pointer.
    //
    if (!GetInPlaceSite()) {

        // if they want windowless support, then we want IOleInPlaceSiteWindowless
        //
        if (FCONTROLISWINDOWLESS(m_ObjectType))
            m_pClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_pInPlaceSiteWndless);

        // if we're not able to do windowless siting, then we'll just get an
        // IOleInPlaceSite pointer.
        //
        if (!m_pInPlaceSiteWndless) {
            hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
            RETURN_ON_FAILURE(hr);
        }
    }

    // now, we want an IOleInPlaceSiteEx pointer for windowless and flicker free
    // activation.  if we're windowless, we've already got it, else we need to
    // try and get it
    //
    if (m_pInPlaceSiteWndless) {
        pIPSEx = (IOleInPlaceSiteEx *)m_pInPlaceSiteWndless;
        pIPSEx->AddRef();
    } else
        m_pClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&pIPSEx);

    // if we're not already active, go and do it.
    //
    if (!m_fInPlaceActive) {
        OLEINPLACEFRAMEINFO InPlaceFrameInfo;
        RECT rcPos, rcClip;

        // if we have a windowless site, see if we can go in-place windowless
        // active
        //
        hr = S_FALSE;
        if (m_pInPlaceSiteWndless) {
            hr = m_pInPlaceSiteWndless->CanWindowlessActivate();
            CLEANUP_ON_FAILURE(hr);

            // if they refused windowless, we'll try windowed
            //
            if (S_OK != hr) {
                RELEASE_OBJECT(m_pInPlaceSiteWndless);
                hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
                CLEANUP_ON_FAILURE(hr);
            }
        }

        // just try regular windowed in-place activation
        //
        if (hr != S_OK) {
            hr = m_pInPlaceSite->CanInPlaceActivate();
            if (hr != S_OK) {
                hr = (FAILED(hr)) ? E_FAIL : hr;
                goto CleanUp;
            }
        }

        // if we are here, then we have permission to go in-place active.
        // now, announce our intentions to actually go ahead and do this.
        //
        hr = (pIPSEx) ? pIPSEx->OnInPlaceActivateEx(&fNoRedraw, (m_pInPlaceSiteWndless) ? ACTIVATE_WINDOWLESS : 0)
                       : m_pInPlaceSite->OnInPlaceActivate();
        CLEANUP_ON_FAILURE(hr);

        // if we're here, we're ready to go in-place active.  we just need
        // to set up some flags, and then create the window [if we have
        // one]
        //
        m_fInPlaceActive = TRUE;

        // we need to get some information about our location in the parent
        // window, as well as some information about the parent
        //
        InPlaceFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
        hr = GetInPlaceSite()->GetWindow(&m_hwndParent);
        if (SUCCEEDED(hr))
            hr = GetInPlaceSite()->GetWindowContext(&m_pInPlaceFrame, &m_pInPlaceUIWindow, &rcPos, &rcClip, &InPlaceFrameInfo);
        CLEANUP_ON_FAILURE(hr);

        // make sure we'll display ourselves in the correct location with the correct size
        //
        sizel.cx = rcPos.right - rcPos.left;
        sizel.cy = rcPos.bottom - rcPos.top;
        f = OnSetExtent(&sizel);
        if (f) m_Size = sizel;
        SetObjectRects(&rcPos, &rcClip);

        // finally, create our window if we have to!
        //
        if (!m_pInPlaceSiteWndless) {
    
            SetInPlaceParent(m_hwndParent);

            // create the window, and display it.  die horribly if we couldnt'
            //
            if (!CreateInPlaceWindow(rcPos.left, rcPos.top, fNoRedraw)) {
                hr = E_FAIL;
                goto CleanUp;
            }
        }
    }

    // don't need this any more
    //
    RELEASE_OBJECT(pIPSEx);

    // if we're not inplace visible yet, do so now.
    //
    if (!m_fInPlaceVisible)
        SetInPlaceVisible(TRUE);

    // if we weren't asked to UIActivate, then we're done.
    //
    if (lVerb != OLEIVERB_PRIMARY && lVerb != OLEIVERB_UIACTIVATE)
        return S_OK;

    // if we're not already UI active, do sow now.
    //
    if (!m_fUIActive) {
        m_fUIActive = TRUE;

        // inform the container of our intent
        //
        GetInPlaceSite()->OnUIActivate();

        // take the focus  [which is what UI Activation is all about !]
        //
        SetFocus(TRUE);

        // set ourselves up in the host.
        //
        m_pInPlaceFrame->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);

        // we have to explicitly say we don't wany any border space.
        //
        m_pInPlaceFrame->SetBorderSpace(NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetBorderSpace(NULL);
    }

    // be-de-be-de-be-de that's all folks!
    //
    return S_OK;

  CleanUp:
    // something catastrophic happened [or, at least something bad].
    // die a horrible fiery mangled painful death.
    //
    QUICK_RELEASE(pIPSEx);
    m_fInPlaceActive = FALSE;
    return hr;

}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Deactivates an active in-place object and discards the object's undo state.
//
// Output:
//    HRESULT        - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::InPlaceDeactivate
(
    void
)
{
    // if we're not in-place active yet, then this is easy.
    //
    if (!m_fInPlaceActive)
        return S_OK;

    // transition from UIActive back to active
    //
    if (m_fUIActive)
        UIDeactivate();

    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;

    // if we have a window, tell it to go away.
    //
    if (m_hwnd) {
        ASSERT(!m_pInPlaceSiteWndless, "internal state really messed up");

        // so our window proc doesn't crash.
        //
        BeforeDestroyWindow();
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;

        if (m_hwndReflect) {
            SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, 0);
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }
    }

    RELEASE_OBJECT(m_pInPlaceFrame);
    RELEASE_OBJECT(m_pInPlaceUIWindow);
    GetInPlaceSite()->OnInPlaceDeactivate();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::UIDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// transitions us from UI Active to merely being active [visible]  for
// a control, this doesn't mean all that much.
//
// Output:
//    HRESULT         - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::UIDeactivate
(
    void
)
{
    // if we're not UIActive, not much to do.
    //
    if (!m_fUIActive)
        return S_OK;

    m_fUIActive = FALSE;

    // notify frame windows, if appropriate, that we're no longer ui-active.
    //
    if (m_pInPlaceUIWindow) m_pInPlaceUIWindow->SetActiveObject(NULL, NULL);
    m_pInPlaceFrame->SetActiveObject(NULL, NULL);

    // we don't need to explicitly release the focus here since somebody
    // else grabbing the focus is what is likely to cause us to get lose it
    //
    GetInPlaceSite()->OnUIDeactivate(FALSE);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetObjectRects    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Indicates how much of the control is visible.
//
// Parameters:
//    LPCRECT        - [in] position of the control.
//    LPCRECT        - [in] clipping rectangle for the control.
//
// Output:
//    HRESULT        - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetObjectRects
(
    LPCRECT prcPos,
    LPCRECT prcClip
)
{
    BOOL fRemoveWindowRgn;

    // move our window to the new location and handle clipping. not applicable
    // for windowless controls, since the container will be responsible for all
    // clipping.
    //
    if (m_hwnd) {
        fRemoveWindowRgn = m_fUsingWindowRgn;
        if (prcClip) {
            // the container wants us to clip, so figure out if we really
            // need to
            //
            RECT rcIXect;
            if ( IntersectRect(&rcIXect, prcPos, prcClip) ) {
                if (!EqualRect(&rcIXect, prcPos)) {
                    OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));

                    HRGN tempRgn = CreateRectRgnIndirect(&rcIXect);
                    SetWindowRgn(GetOuterWindow(), tempRgn, TRUE);

                    if (m_hRgn != NULL)
                       DeleteObject(m_hRgn);
                    m_hRgn = tempRgn;

                    m_fUsingWindowRgn = TRUE;
                    fRemoveWindowRgn  = FALSE;
                }
            }
        }

        if (fRemoveWindowRgn) {
            SetWindowRgn(GetOuterWindow(), NULL, TRUE);
            if (m_hRgn != NULL)
            {
               DeleteObject(m_hRgn);
               m_hRgn = NULL;
            }
            m_fUsingWindowRgn = FALSE;
        }

        // set our control's location, but don't change it's size at all
        // [people for whom zooming is important should set that up here]
        //
        DWORD dwFlag;
        OnSetObjectRectsChangingWindowPos(&dwFlag);

        int cx, cy;
        cx = prcPos->right - prcPos->left;
        cy = prcPos->bottom - prcPos->top;
        SetWindowPos(GetOuterWindow(), NULL, prcPos->left, prcPos->top, cx, cy, dwFlag | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    // save out our current location.  windowless controls want this more
    // that windowed ones do, but everybody can have it just in case
    //
    m_rcLocation = *prcPos;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ReactivateAndUndo    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Reactivates a previously deactivated object, undoing the last state of the object.
//
// Output:
//    HRESULT        - S_OK, E_NOTUNDOABLE
//
// Notes:
//
STDMETHODIMP COleControl::ReactivateAndUndo
(
    void
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnWindowMessage    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method lets the container dispatch a message to a windowless OLE
// object.
//
// Parameters:
//    UINT                - [in]  the message
//    WPARAM              - [in]  the messages wparam
//    LPARAM              - [in]  duh.
//    LRESULT *           - [out] the output value
//
// Output:
//    HRESULT             - S_OK
//
// Notes:
//    - people should call m_pInPlaceSiteWndless->OnDefWindowMessage [control
//      writers should just call OcxDefWindowProc(msg, wparam, lparam)];
//
STDMETHODIMP COleControl::OnWindowMessage
(
    UINT     msg,
    WPARAM   wParam,
    LPARAM   lParam,
    LRESULT *plResult
)
{
    // little bit of pre-processing -- we need to handle some cases here
    // before passing the messages on
    //
    switch (msg) {
        // make sure our UI Activation correctly matches the focus
        //
        case WM_KILLFOCUS:
        case WM_SETFOCUS:
            // give the control site focus notification
            //
            if (m_fInPlaceActive && m_pControlSite)
                m_pControlSite->OnFocus(msg == WM_SETFOCUS);
            break;
    }

    // just pass it to the control's window proc.
    //
    *plResult = WindowProc(msg, wParam, lParam);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetDropTarget    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method returns a pointer to the objects IDropTarget interface.  since
// they do not have a window, windowless objects cannot register an IDropTarget
// interface.
//
// Parameters:
//    IDropTarget **        - [out]
//
// Output:
//    HRESULT               - S_OK, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::GetDropTarget
(
    IDropTarget **ppDropTarget
)
{
    // OVERRIDE: if you want to do drag and drop and you're windowless,
    // override me.
    //
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::TranslateAccelerator    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Processes menu accelerator-key messages from the container's message queue.
//
// Parameters:
//    LPMSG            - [in] the message that has the special key in it.
//
// Output:
//    HRESULT          - S_OK, S_FALSE, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::TranslateAccelerator
(
    LPMSG    pmsg
)
{
    // see if we want it or not.
    //
    if (OnSpecialKey(pmsg))
        return S_OK;

    // if not, then we want to forward it back to the site for further processing
    //
    if (m_pControlSite)
        return m_pControlSite->TranslateAccelerator(pmsg, _SpecialKeyState());

    // we didn't want it.
    //
    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnFrameWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the control when the container's top-level frame window is
// activated or deactivated.
//
// Parameters:
//    BOOL        - [in] state of containers top level window.
//
// Output:
//    HRESULT     - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnFrameWindowActivate
(
    BOOL fActivate
)
{
    // we're supposed to go UI active in this case
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl::OnDocWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the active control when the container's document window is
// activated or deactivated.
//
// Parameters:
//    BOOL            - state of mdi child window.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnDocWindowActivate
(
    BOOL fActivate
)
{
    // we're supposed to go UI active in this case
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl::ResizeBorder    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Alerts the control that it needs to resize its border space.
//
// Parameters:
//    LPCRECT               - [in] new outer rectangle for border space
//    IOleInPlaceUIWindow * - [in] the document or frame who's border has changed
//    BOOL                  - [in] true if it was the fram window taht called.
//
// Output:
//    HRESULT               - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::ResizeBorder
(
    LPCRECT              prcBorder,
    IOleInPlaceUIWindow *pInPlaceUIWindow,
    BOOL                 fFrame
)
{
    // this is largely uninteresting to us, since we have no border.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnableModeless    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Enables or disables modeless dialog boxes when the container creates or
// destroys a modal dialog box.
//
// Parameters:
//    BOOL            - [in] enable or disable modeless dialogs.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::EnableModeless
(
    BOOL fEnable
)
{
    // phenomenally uninteresting
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassInfo    [IProvideClassInfo]
//=--------------------------------------------------------------------------=
// returns the TypeInfo for the control's coclass.
//
// Parameters:
//    ITypeInfo **        - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassInfo
(
    ITypeInfo **ppTypeInfo
)
{
    ITypeLib *pTypeLib;
    HRESULT hr;

    CHECK_POINTER(ppTypeInfo);
    *ppTypeInfo = NULL;

    // go and get our type library.
    // CONSIDER: - go to the same sorta scheme that we use for TypeInfo caching.
    // CONSIDER: - consider trying to register our typelib if this fails.
    //
    hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0,
                        LANGIDFROMLCID(g_lcidLocale), &pTypeLib);
    RETURN_ON_FAILURE(hr);

    // got the typelib.  get typeinfo for our coclass.
    //
    hr = pTypeLib->GetTypeInfoOfGuid((REFIID)CLSIDOFOBJECT(m_ObjectType), ppTypeInfo);
    pTypeLib->Release();
    RETURN_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ViewChange    [callable]
//=--------------------------------------------------------------------------=
// called whenever the view of the object has changed.
//
// Notes:
//
void COleControl::ViewChanged
(
    void
)
{
    // send the view change notification to anybody listening.
    //
    if (m_pViewAdviseSink) {
        m_pViewAdviseSink->OnViewChange(DVASPECT_CONTENT, -1);

        // if they only asked to be advised once, kill the connection
        //
        if (m_fViewAdviseOnlyOnce)
            SetAdvise(DVASPECT_CONTENT, 0, NULL);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceVisible    [helper]
//=--------------------------------------------------------------------------=
// controls the visibility of the control window.
//
// Parameters:
//    BOOL        - TRUE shows FALSE hides.
//
// Notes:
//
void COleControl::SetInPlaceVisible
(
    BOOL fShow
)
{
    BOOL fVisible;

    m_fInPlaceVisible = fShow;

    // don't do anything if we don't have a window.  otherwise, set it
    //
    if (m_hwnd) {
        fVisible = ((GetWindowLong(GetOuterWindow(), GWL_STYLE) & WS_VISIBLE) != 0);

        if (fVisible && !fShow)
            ShowWindow(GetOuterWindow(), SW_HIDE);
        else if (!fVisible && fShow)
            ShowWindow(GetOuterWindow(), SW_SHOWNA);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::AmbientPropertyChanged    [overridable]
//=--------------------------------------------------------------------------=
// a method that derived controls can override to do whatever they want.
// we don't particularily care about this event.
//
// Parameters:
//    DISPID            - [in] dispid of prop that changed.
//
// Notes:
//
void COleControl::AmbientPropertyChanged
(
    DISPID dispid
)
{
    // do nothing
}

//=--------------------------------------------------------------------------=
// COleControl::DoCustomVerb    [overridable]
//=--------------------------------------------------------------------------=
// we were asked to execute a verb we don't know about right away.  see if
// it's a verb that the dervied-control defined.
//
// Parameters:
//    LONG            - [in] the verb.
//
// Output:
//    HRESULT         - S_OK, OLEOBJ_S_INVALIDVERB
//
// Notes:
//
HRESULT COleControl::DoCustomVerb
(
    LONG    lVerb
)
{
    return OLEOBJ_S_INVALIDVERB;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetExtent    [overridable]
//=--------------------------------------------------------------------------=
// let the user do something in the resize, if they care.
//
// Parameters:
//    SIZEL *        - [in] new values.
//
// Output:
//    BOOL           - FALSE means keep current size
//
// Notes:
//
BOOL COleControl::OnSetExtent
(
    const SIZEL *pSizeL
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSpecialKey    [overridable]
//=--------------------------------------------------------------------------=
// allows controls to handle special keys such as arrows, CTRL+, etc ...
//
// Parameters:
//    LPMSG        - [in] the special key msg.
//
// Output:
//    BOOL         - TRUE we processed it, FALSE we didn't.
//
// Notes:
//
BOOL COleControl::OnSpecialKey
(
    LPMSG pmsg
)
{
    // do nothing.
    //
    return FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::ModalDialog    [callable, utility]
//=--------------------------------------------------------------------------=
// should be called when the control is about to show and hide a modal dialog.
//
// Parameters:
//    BOOL        - [in] true means showing a modal dialog, false means done
//
// Notes:
//
void COleControl::ModalDialog
(
    BOOL fShow
)
{
    // notify the container of our intention to show a modal dialog...
    //
    if (m_pInPlaceFrame)
        m_pInPlaceFrame->EnableModeless(!fShow);
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeDestroyWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we destroy a window.  gives the user the opportunity to
// save information out, especially if they're a subclassed control, and this
// is an interesting thing to do.
//
// Notes:
//
void COleControl::BeforeDestroyWindow
(
    void
)
{
    // fweeee
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetObjectRectsChangingWIndowPos    [overridable]
//=--------------------------------------------------------------------------=
// called just before we perform a SetWindowPos in the SetObjectRects
// function. gives a control the opportunity to change the flags.
//
// Notes:
//
void COleControl::OnSetObjectRectsChangingWindowPos(DWORD *dwFlag)
{
    *dwFlag = 0;
}

void COleControl::OnVerb(LONG lVerb)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\ctlpch.cpp ===
#include "ipserver.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\ctlhelp.h ===
//=--------------------------------------------------------------------------=
// CtlHelp.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// routines to help out our implementation of COleControl.
//

#ifndef _CTLHELP_H_

//=--------------------------------------------------------------------------=
// these two tables are used to get information on sizes about data types
// the first is used mostly in persistence, while the second is used for
// events
//
extern const BYTE g_rgcbDataTypeSize [];
extern const BYTE g_rgcbPromotedDataTypeSize [];



//=--------------------------------------------------------------------------=
// misc functions
//
short       _SpecialKeyState(void);
void WINAPI CopyAndAddRefObject(void *, const void *, DWORD);
void WINAPI CopyOleVerb(void *, const void *, DWORD);

HWND        CreateReflectWindow(BOOL fVisible, HWND hwndParent, int, int, SIZEL *);
void        CleanupReflection();

//=--------------------------------------------------------------------------=
// little private guid we'll use to help identify our objects
// {00D97180-FCF7-11ce-A09E-00AA0062BE57}
//
#define Data1_IControlPrv	0xd97180

DEFINE_GUID(IID_IControlPrv, 0xd97180, 0xfcf7, 0x11ce, 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

#define _CTLHELP_H_
#endif // _CTLHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\ctlhelp.cpp ===
//=--------------------------------------------------------------------------=
// CtlHelp.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// helper routines for our COleControl implementation
//

#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Util.H"
#include <windows.h>

// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// this is used by the window reflection code.
//
extern BYTE g_fRegisteredReflect;
extern char g_szReflectClassName [];


// define this here, since it's the only guid we really need to define in the
// framework -- the user control defines all other interesting guids.
//
static const GUID IID_IControlPrv =
{ 0xd97180, 0xfcf7, 0x11ce, { 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57 } };


// this table is used for copying data around, and persisting properties.
// basically, it contains the size of a given data type
//
const BYTE g_rgcbDataTypeSize[] = {
    0,                      // VT_EMPTY= 0,
    0,                      // VT_NULL= 1,
    sizeof(short),          // VT_I2= 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(float),          // VT_R4  = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH    = 9,
    sizeof(SCODE),          // VT_ERROR    = 10,
    sizeof(VARIANT_BOOL),   // VT_BOOL    = 11,
    sizeof(VARIANT),        // VT_VARIANT= 12,
    sizeof(IUnknown *),     // VT_UNKNOWN= 13,
};

const BYTE g_rgcbPromotedDataTypeSize[] = {
    0,                      // VT_EMPTY= 0,
    0,                      // VT_NULL= 1,
    sizeof(int ),           // VT_I2= 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(double),         // VT_R4  = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH    = 9,
    sizeof(SCODE),          // VT_ERROR    = 10,
    sizeof(int),            // VT_BOOL    = 11,
    sizeof(VARIANT),        // VT_VARIANT= 12,
    sizeof(IUnknown *),     // VT_UNKNOWN= 13,
};

//=--------------------------------------------------------------------------=
// _SpecialKeyState
//=--------------------------------------------------------------------------=
// returns a short with some information on which of the SHIFT, ALT, and CTRL
// keys are set.
//
// Output:
//    short        - bit 0 is shift, bit 1 is ctrl, bit 2 is ALT.
//
// Notes:
//
short _SpecialKeyState()
{
    // don't appear to be able to reduce number of calls to GetKeyState
    //
    BOOL bShift = (GetKeyState(VK_SHIFT) < 0);
    BOOL bCtrl  = (GetKeyState(VK_CONTROL) < 0);
    BOOL bAlt   = (GetKeyState(VK_MENU) < 0);

    return (short)(bShift + (bCtrl << 1) + (bAlt << 2));
}


//=--------------------------------------------------------------------------=
// CopyAndAddRefObject
//=--------------------------------------------------------------------------=
// copies an object pointer, and then addref's the object.
//
// Parameters:
//    void *        - [in] dest.
//    const void *  - [in] src
//    DWORD         - [in] size, ignored, since it's always 4
//
// Notes:
//
void WINAPI CopyAndAddRefObject
(
    void       *pDest,
    const void *pSource,
    DWORD       dwSize
)
{
    ASSERT(pDest && pSource, "Bogus Pointer(s) passed into CopyAndAddRefObject!!!!");

    *((IUnknown **)pDest) = *((IUnknown **)pSource);
    ADDREF_OBJECT(*((IUnknown **)pDest));

    return;
}

//=--------------------------------------------------------------------------=
// CopyOleVerb    [helper]
//=--------------------------------------------------------------------------=
// copies an OLEVERB structure.  used in CStandardEnum
//
// Parameters:
//    void *        - [out] where to copy to
//    const void *  - [in]  where to copy from
//    DWORD         - [in]  bytes to copy
//
// Notes:
//
void WINAPI CopyOleVerb
(
    void       *pvDest,
    const void *pvSrc,
    DWORD       cbCopy
)
{
    VERBINFO * pVerbDest = (VERBINFO *) pvDest;
    const VERBINFO * pVerbSrc = (const VERBINFO *) pvSrc;

    *pVerbDest = *pVerbSrc;
    ((OLEVERB *)pVerbDest)->lpszVerbName = OLESTRFROMRESID((WORD)((VERBINFO *)pvSrc)->idVerbName);
}

//=--------------------------------------------------------------------------=
// ControlFromUnknown    [helper, callable]
//=--------------------------------------------------------------------------=
// given an unknown, get the COleControl pointer for it.
//
// Parameters:
//    IUnknown *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
COleControl *ControlFromUnknown
(
    IUnknown *pUnk
)
{
    COleControl *pCtl = NULL;

    if (!pUnk) return NULL;
    pUnk->QueryInterface(IID_IControlPrv, (void **)&pCtl);

    return pCtl;
}

//=--------------------------------------------------------------------------=
// CreateReflectWindow    [blech]
//=--------------------------------------------------------------------------=
// unfortunately, in certain cases, we have to create two windows, one of
// which exists strictly to reflect messages on to the control.
// Fortunately, the number of hosts which require this is quite small.
//
// Parameters:
//    BOOL        - [in] should it be created visible?
//    HWND        - [in] parent window
//    int         - [in] x pos
//    int         - [in] y pos
//    SIZEL *     - [in] size
//
// Output:
//    HWND        - reflecting hwnd or NULL if it failed.
//
// Notes:
//
HWND CreateReflectWindow
(
    BOOL   fVisible,
    HWND   hwndParent,
    int    x,
    int    y,
    SIZEL *pSize
)
{
    WNDCLASS wndclass;

    // first thing to do is register the window class.  crit sect this
    // so we don't have to move it into the control
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fRegisteredReflect) {

        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.lpfnWndProc = COleControl::ReflectWindowProc;
        wndclass.hInstance   = g_hInstance;
        wndclass.lpszClassName = g_szReflectClassName;

        if (!RegisterClass(&wndclass)) {
            FAIL("Couldn't Register Parking Window Class!");
            LeaveCriticalSection(&g_CriticalSection);
            return NULL;
        }
        g_fRegisteredReflect = TRUE;
    }

    LeaveCriticalSection(&g_CriticalSection);

    // go and create the window.
    //
    return CreateWindowEx(0, g_szReflectClassName, NULL,
                          WS_CHILD | WS_CLIPSIBLINGS |((fVisible) ? WS_VISIBLE : 0),
                          x, y, pSize->cx, pSize->cy,
                          hwndParent,
                          NULL, g_hInstance, NULL);
}

//=--------------------------------------------------------------------------=
// in case the user doesn't want our default window proc, we support
// letting them specify one themselves. this is defined in their main ipserver
// file.
//
extern WNDPROC g_ParkingWindowProc;

//=--------------------------------------------------------------------------=
// GetParkingWindow
//=--------------------------------------------------------------------------=
// creates the global parking window that we'll use to parent things, or
// returns the already existing one
//
// Output:
//    HWND                - our parking window
//
// Notes:
//
HWND GetParkingWindow
(
    void
)
{
    WNDCLASS wndclass;

    // crit sect this creation for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    if (g_hwndParking)
        goto CleanUp;

    ZeroMemory(&wndclass, sizeof(wndclass));
    wndclass.lpfnWndProc = (g_ParkingWindowProc) ? g_ParkingWindowProc : DefWindowProc;
    wndclass.hInstance   = g_hInstance;
    wndclass.lpszClassName = "CtlFrameWork_Parking";

    if (!RegisterClass(&wndclass)) {
        FAIL("Couldn't Register Parking Window Class!");
        goto CleanUp;
    }

    g_hwndParking = CreateWindow("CtlFrameWork_Parking", NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInstance, NULL);
    if (g_hwndParking != NULL)
       ++g_cLocks;

    ASSERT(g_hwndParking, "Couldn't Create Global parking window!!");


  CleanUp:
    LeaveCriticalSection(&g_CriticalSection);
    return g_hwndParking;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\ctlmisc.cpp ===
//=--------------------------------------------------------------------------=
// CtlMisc.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// things that aren't elsewhere, such as property pages, and connection
// points.

#include "IPServer.H"
#include "CtrlObj.H"
#include "CtlHelp.H"
#include "Globals.H"
#include "StdEnum.H"
#include "Util.H"

#include <stdarg.h>

// for ASSERT and FAIL
//
SZTHISFILE

// this is used in our window proc so that we can find out who was last created
//
static COleControl *s_pLastControlCreated;

//=--------------------------------------------------------------------------=
// COleControl::COleControl
//=--------------------------------------------------------------------------=
// constructor
//
// Parameters:
//    IUnknown *          - [in] controlling Unknown
//    int                 - [in] type of primary dispatch interface OBJECT_TYPE_*
//    void *              - [in] pointer to entire object
//	  BOOL                - [in] whether to enable IDispatchEx functionality
//							to allow dynamic adding of properties
// Notes:
//
COleControl::COleControl
(
    IUnknown *pUnkOuter,
    int       iPrimaryDispatch,
    void     *pMainInterface,
	BOOL     fExpandoEnabled
)
: CAutomationObject(pUnkOuter, iPrimaryDispatch, pMainInterface, fExpandoEnabled),
  m_cpEvents(SINK_TYPE_EVENT),
  m_cpPropNotify(SINK_TYPE_PROPNOTIFY)
{
    // initialize all our variables -- we decided against using a memory-zeroing
    // memory allocator, so we sort of have to do this work now ...
    //
    m_nFreezeEvents = 0;

    m_pClientSite = NULL;
    m_pControlSite = NULL;
    m_pInPlaceSite = NULL;
    m_pInPlaceFrame = NULL;
    m_pInPlaceUIWindow = NULL;


    m_pInPlaceSiteWndless = NULL;

    // certain hosts don't like 0,0 as your initial size, so we're going to set
    // our initial size to 100,50 [so it's at least sort of visible on the screen]
    //
    m_Size.cx = 0;
    m_Size.cy = 0;
    memset(&m_rcLocation, 0, sizeof(m_rcLocation));

    m_hRgn = NULL;
    m_hwnd = NULL;
    m_hwndParent = NULL;
    m_hwndReflect = NULL;
    m_fHostReflects = TRUE;
    m_fCheckedReflecting = FALSE;

    m_nFreezeEvents = 0;
    m_pSimpleFrameSite = NULL;
    m_pOleAdviseHolder = NULL;
    m_pViewAdviseSink = NULL;
    m_pDispAmbient = NULL;

    m_fDirty = FALSE;
    m_fModeFlagValid = FALSE;
    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;
    m_fUIActive = FALSE;
    m_fSaveSucceeded = FALSE;
    m_fViewAdvisePrimeFirst = FALSE;
    m_fViewAdviseOnlyOnce = FALSE;
    m_fRunMode = FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::~COleControl
//=--------------------------------------------------------------------------=
// "We are all of us resigned to death; it's life we aren't resigned to."
//    - Graham Greene (1904-91)
//
// Notes:
//
COleControl::~COleControl()
{
    // if we've still got a window, go and kill it now.
    //
    if (m_hwnd) {
        // so our window proc doesn't crash.
        //
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
        DestroyWindow(m_hwnd);
    }

    if (m_hwndReflect) {
        SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, 0);
        DestroyWindow(m_hwndReflect);
    }

    if (m_hRgn != NULL)
    {
       DeleteObject(m_hRgn);
       m_hRgn = NULL;
    }

    // clean up all the pointers we're holding around.
    //
    QUICK_RELEASE(m_pClientSite);
    QUICK_RELEASE(m_pControlSite);
    QUICK_RELEASE(m_pInPlaceSite);
    QUICK_RELEASE(m_pInPlaceFrame);
    QUICK_RELEASE(m_pInPlaceUIWindow);
    QUICK_RELEASE(m_pSimpleFrameSite);
    QUICK_RELEASE(m_pOleAdviseHolder);
    QUICK_RELEASE(m_pViewAdviseSink);
    QUICK_RELEASE(m_pDispAmbient);

    QUICK_RELEASE(m_pInPlaceSiteWndless);
}

#ifndef DEBUG
#pragma optimize("t", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::InternalQueryInterface
//=--------------------------------------------------------------------------=
// derived-controls should delegate back to this when they decide to support
// additional interfaces
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//    - NOTE: this function is speed critical!!!!
//
HRESULT COleControl::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    switch (riid.Data1) {
        // private interface for prop page support
        case Data1_IControlPrv:
          if(DO_GUIDS_MATCH(riid, IID_IControlPrv)) {
            *ppvObjOut = (void *)this;
            ExternalAddRef();
            return S_OK;
          }
          goto NoInterface;
        QI_INHERITS(this, IOleControl);
        QI_INHERITS(this, IPointerInactive);
        QI_INHERITS(this, IQuickActivate);
        QI_INHERITS(this, IOleObject);
        QI_INHERITS((IPersistStorage *)this, IPersist);
        QI_INHERITS(this, IPersistStreamInit);
        QI_INHERITS(this, IOleInPlaceObject);
        QI_INHERITS(this, IOleInPlaceObjectWindowless);
        QI_INHERITS((IOleInPlaceActiveObject *)this, IOleWindow);
        QI_INHERITS(this, IOleInPlaceActiveObject);
        QI_INHERITS(this, IViewObject);
        QI_INHERITS(this, IViewObject2);
        QI_INHERITS(this, IViewObjectEx);
        QI_INHERITS(this, IConnectionPointContainer);
        QI_INHERITS(this, ISpecifyPropertyPages);
        QI_INHERITS(this, IPersistStorage);
        QI_INHERITS(this, IPersistPropertyBag);
        QI_INHERITS(this, IProvideClassInfo);
        default:
            goto NoInterface;
    }

    // we like the interface, so addref and return
    //
    ((IUnknown *)(*ppvObjOut))->AddRef();
    return S_OK;

  NoInterface:
    // delegate to super-class for automation interfaces, etc ...
    //
    return CAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

#ifndef DEBUG
#pragma optimize("s", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::FindConnectionPoint    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// given an IID, find a connection point sink for it.
//
// Parameters:
//    REFIID              - [in]  interfaces they want
//    IConnectionPoint ** - [out] where the cp should go
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::FindConnectionPoint
(
    REFIID             riid,
    IConnectionPoint **ppConnectionPoint
)
{
    CHECK_POINTER(ppConnectionPoint);

    // we support the event interface, and IDispatch for it, and we also
    // support IPropertyNotifySink.
    //
    if (DO_GUIDS_MATCH(riid, EVENTIIDOFCONTROL(m_ObjectType)) || DO_GUIDS_MATCH(riid, IID_IDispatch))
        *ppConnectionPoint = &m_cpEvents;
    else if (DO_GUIDS_MATCH(riid, IID_IPropertyNotifySink))
        *ppConnectionPoint = &m_cpPropNotify;
    else
        return E_NOINTERFACE;

    // generic post-processing.
    //
    (*ppConnectionPoint)->AddRef();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnumConnectionPoints    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// creates an enumerator for connection points.
//
// Parameters:
//    IEnumConnectionPoints **    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::EnumConnectionPoints
(
    IEnumConnectionPoints **ppEnumConnectionPoints
)
{
    IConnectionPoint **rgConnectionPoints;

    CHECK_POINTER(ppEnumConnectionPoints);

    // HeapAlloc an array of connection points [since our standard enum
    // assumes this and HeapFree's it later ]
    //
    rgConnectionPoints = (IConnectionPoint **)HeapAlloc(g_hHeap, 0, sizeof(IConnectionPoint *) * 2);
    RETURN_ON_NULLALLOC(rgConnectionPoints);

    // we support the event interface for this dude as well as IPropertyNotifySink
    //
    rgConnectionPoints[0] = &m_cpEvents;
    rgConnectionPoints[1] = &m_cpPropNotify;

    *ppEnumConnectionPoints = (IEnumConnectionPoints *)(IEnumGeneric *) new CStandardEnum(IID_IEnumConnectionPoints,
                                2, sizeof(IConnectionPoint *), (void *)rgConnectionPoints,
                                CopyAndAddRefObject);
    if (!*ppEnumConnectionPoints) {
        HeapFree(g_hHeap, 0, rgConnectionPoints);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetPages    [ISpecifyPropertyPages]
//=--------------------------------------------------------------------------=
// returns a counted array with the guids for our property pages.
//
// parameters:
//    CAUUID *    - [out] where to put the counted array.
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::GetPages
(
    CAUUID *pPages
)
{
    const GUID **pElems;
    void *pv;
    WORD  x;

    // if there are no property pages, this is actually pretty easy.
    //
    if (!CPROPPAGESOFCONTROL(m_ObjectType)) {
        pPages->cElems = 0;
        pPages->pElems = NULL;
        return S_OK;
    }

    // fill out the Counted array, using IMalloc'd memory.
    //
    pPages->cElems = CPROPPAGESOFCONTROL(m_ObjectType);
    pv = CoTaskMemAlloc(sizeof(GUID) * (pPages->cElems));
    RETURN_ON_NULLALLOC(pv);
    pPages->pElems = (GUID *)pv;

    // loop through our array of pages and get 'em.
    //
    pElems = PPROPPAGESOFCONTROL(m_ObjectType);
    for (x = 0; x < pPages->cElems; x++)
        pPages->pElems[x] = *(pElems[x]);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::m_pOleControl
//=--------------------------------------------------------------------------=
// returns a pointer to the control in which we are nested.
//
// Output:
//    COleControl *
//
// Notes:
//
inline COleControl *COleControl::CConnectionPoint::m_pOleControl
(
    void
)
{
    return (COleControl *)((BYTE *)this - ((m_bType == SINK_TYPE_EVENT)
                                          ? offsetof(COleControl, m_cpEvents)
                                          : offsetof(COleControl, m_cpPropNotify)));
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::QueryInterface
//=--------------------------------------------------------------------------=
// standard qi
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, IID_IConnectionPoint) || DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        *ppvObjOut = (IConnectionPoint *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::AddRef
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG COleControl::CConnectionPoint::AddRef
(
    void
)
{
    return m_pOleControl()->ExternalAddRef();
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::Release
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG COleControl::CConnectionPoint::Release
(
    void
)
{
    return m_pOleControl()->ExternalRelease();
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::GetConnectionInterface
//=--------------------------------------------------------------------------=
// returns the interface we support connections on.
//
// Parameters:
//    IID *        - [out] interface we support.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::GetConnectionInterface
(
    IID *piid
)
{
    if (m_bType == SINK_TYPE_EVENT)
        *piid = EVENTIIDOFCONTROL(m_pOleControl()->m_ObjectType);
    else
        *piid = IID_IPropertyNotifySink;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::GetConnectionPointContainer
//=--------------------------------------------------------------------------=
// returns the connection point container
//
// Parameters:
//    IConnectionPointContainer **ppCPC
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::GetConnectionPointContainer
(
    IConnectionPointContainer **ppCPC
)
{
    return m_pOleControl()->ExternalQueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}


//=--------------------------------------------------------------------------=
// COleControl::CConnectiontPoint::Advise
//=--------------------------------------------------------------------------=
// someboyd wants to be advised when something happens.
//
// Parameters:
//    IUnknown *        - [in]  guy who wants to be advised.
//    DWORD *           - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::Advise
(
    IUnknown *pUnk,
    DWORD    *pdwCookie
)
{
    HRESULT    hr;
    void      *pv;

    CHECK_POINTER(pdwCookie);

    // first, make sure everybody's got what they thinks they got
    //
    if (m_bType == SINK_TYPE_EVENT) {

        // CONSIDER: 12.95 -- this theoretically is broken -- if they do a find
        // connection point on IDispatch, and they just happened to also support
        // the Event IID, we'd advise on that.  this is not awesome, but will
        // prove entirely acceptable short term.
        //
        hr = pUnk->QueryInterface(EVENTIIDOFCONTROL(m_pOleControl()->m_ObjectType), &pv);
        if (FAILED(hr))
            hr = pUnk->QueryInterface(IID_IDispatch, &pv);
    }
    else
        hr = pUnk->QueryInterface(IID_IPropertyNotifySink, &pv);
    RETURN_ON_FAILURE(hr);

    // finally, add the sink.  it's now been cast to the correct type and has
    // been AddRef'd.
    //
    return AddSink(pv, pdwCookie);
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::AddSink
//=--------------------------------------------------------------------------=
// in some cases, we'll already have done the QI, and won't need to do the
// work that is done in the Advise routine above.  thus, these people can
// just call this instead. [this stems really from IQuickActivate]
//
// Parameters:
//    void *        - [in]  the sink to add. it's already been addref'd
//    DWORD *       - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::CConnectionPoint::AddSink
(
    void  *pv,
    DWORD *pdwCookie
)
{
    IUnknown **rgUnkNew;
    int        i;

    // we optimize the case where there is only one sink to not allocate
    // any storage.  turns out very rarely is there more than one.
    //

    if (!m_cSinks) {
        m_SingleSink = (IUnknown *) pv;
        *pdwCookie = (DWORD) 1;
        m_cSinks = 1;
        return S_OK;
    }

    // Allocated the array yet?
    if (!m_rgSinks) {
        rgUnkNew = (IUnknown **)HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, 8 * sizeof(IUnknown *));
        RETURN_ON_NULLALLOC(rgUnkNew);
        m_cAllocatedSinks = 8;
        m_rgSinks = rgUnkNew;
        m_rgSinks[0] = m_SingleSink;
        m_rgSinks[1] = (IUnknown *)pv;
        m_SingleSink = NULL;
        m_cSinks = 2;
        *pdwCookie = 2;
        return S_OK;
    }

    // Find an empty slot.
    for (i = 0; i < m_cAllocatedSinks; i++) {
        if (!m_rgSinks[i]) {
            m_rgSinks[i] = (IUnknown *)pv;
            i++;
            *pdwCookie = i;
            m_cSinks++;
            return S_OK;
        }
    }

    // Didn't find one, grow the array.
    rgUnkNew = (IUnknown **)HeapReAlloc(g_hHeap, HEAP_ZERO_MEMORY, m_rgSinks, (m_cAllocatedSinks + 8) * sizeof(IUnknown *));
    RETURN_ON_NULLALLOC(rgUnkNew);
    m_rgSinks = rgUnkNew;
    m_rgSinks[m_cAllocatedSinks] = (IUnknown *)pv;
    i = m_cAllocatedSinks+1;
    m_cAllocatedSinks += 8;

    *pdwCookie = i;
    m_cSinks++;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::Unadvise
//=--------------------------------------------------------------------------=
// they don't want to be told any more.
//
// Parameters:
//    DWORD        - [in]  the cookie we gave 'em.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::Unadvise
(
    DWORD dwCookie
)
{
    IUnknown *pUnk;

    if (!dwCookie)
        return S_OK;

    if (dwCookie == (DWORD) 1) {
		// If more than one Sinks added, m_SingleSink pointer has been shifted
		// to m_rgSinks[0].
        pUnk = (m_rgSinks) ? m_rgSinks[0] : m_SingleSink;
        m_SingleSink = NULL;
        if (m_rgSinks) {
            m_rgSinks[0] = NULL;
        }
    } else {
        if (dwCookie <= (DWORD)m_cAllocatedSinks) {
	    if (m_rgSinks) {
            	pUnk = m_rgSinks[dwCookie-1];
            	m_rgSinks[dwCookie-1] = NULL;
	    } else {
            	return CONNECT_E_NOCONNECTION;
	    }
        } else {
            return CONNECT_E_NOCONNECTION;
        }
    }

    m_cSinks--;

    if (!m_cSinks && m_rgSinks) {
        HeapFree(g_hHeap, 0, m_rgSinks);
        m_cAllocatedSinks = 0;
        m_rgSinks = NULL;
    }

    if (pUnk) {
        pUnk->Release();
        return S_OK;
    } else {
        return CONNECT_E_NOCONNECTION;
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::EnumConnections
//=--------------------------------------------------------------------------=
// enumerates all current connections
//
// Paramters:
//    IEnumConnections ** - [out] new enumerator object
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::CConnectionPoint::EnumConnections
(
    IEnumConnections **ppEnumOut
)
{
    CONNECTDATA *rgConnectData = NULL;
    unsigned int i;

    if (m_cSinks) {
        // allocate some memory big enough to hold all of the sinks.
        //
        rgConnectData = (CONNECTDATA *)HeapAlloc(g_hHeap, 0, m_cSinks * sizeof(CONNECTDATA));
        RETURN_ON_NULLALLOC(rgConnectData);

        if ((m_cSinks == 1) && !m_rgSinks) {
            rgConnectData[0].pUnk = m_SingleSink;
            rgConnectData[0].dwCookie = (DWORD)1;
        } else {
            for (unsigned int x = 0, i=0; x < m_cAllocatedSinks; x++) {
                if (m_rgSinks[x]) {
                    rgConnectData[i].pUnk = m_rgSinks[x];
                    rgConnectData[i].dwCookie = x+1;
                    i++;
                }
            }
        }
    }

    // create yon enumerator object.
    //
    *ppEnumOut = (IEnumConnections *)(IEnumGeneric *)new CStandardEnum(IID_IEnumConnections,
                        m_cSinks, sizeof(CONNECTDATA), rgConnectData, CopyAndAddRefObject);
    if (!*ppEnumOut) {
        HeapFree(g_hHeap, 0, rgConnectData);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::~CConnectionPoint
//=--------------------------------------------------------------------------=
// cleans up
//
// Notes:
//
COleControl::CConnectionPoint::~CConnectionPoint ()
{
    int x;

    // clean up some memory stuff
    //
    if (!m_cSinks)
        return;
    else if (m_SingleSink)
        ((IUnknown *)m_SingleSink)->Release();
    else {
        for (x = 0; x < m_cAllocatedSinks; x++) {
	    if (m_rgSinks[x]) {
                QUICK_RELEASE(m_rgSinks[x]);
	    }
	}
        HeapFree(g_hHeap, 0, m_rgSinks);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPiont::DoInvoke
//=--------------------------------------------------------------------------=
// fires an event to all listening on our event interface.
//
// Parameters:
//    DISPID            - [in] event to fire.
//    DISPPARAMS        - [in]
//
// Notes:
//
void COleControl::CConnectionPoint::DoInvoke
(
    DISPID      dispid,
    DISPPARAMS *pdispparams
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.
    //
    if (m_cSinks == 0)
        return;
    else if (m_SingleSink) {
        ((IDispatch *)m_SingleSink)->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
	    if (m_rgSinks[iConnection]) {
                ((IDispatch *)m_rgSinks[iConnection])->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
	    }
	}
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::DoOnChanged
//=--------------------------------------------------------------------------=
// fires the OnChanged event for IPropertyNotifySink listeners.
//
// Parameters:
//    DISPID            - [in] dude that changed.
//
// Output:
//    none
//
// Notes:
//
void COleControl::CConnectionPoint::DoOnChanged
(
    DISPID dispid
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        return;
    else if (m_SingleSink) {
        ((IPropertyNotifySink *)m_SingleSink)->OnChanged(dispid);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
    	    if (m_rgSinks[iConnection]) {
                ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnChanged(dispid);
            }
	    }
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::DoOnRequestEdit
//=--------------------------------------------------------------------------=
// fires the OnRequestEdit for IPropertyNotifySinkListeners
//
// Parameters:
//    DISPID             - [in] dispid user wants to change.
//
// Output:
//    BOOL               - false means you cant
//
// Notes:
//
BOOL COleControl::CConnectionPoint::DoOnRequestEdit
(
    DISPID dispid
)
{
    HRESULT hr;
    int     iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        hr = S_OK;
    else if (m_SingleSink) {
        hr =((IPropertyNotifySink *)m_SingleSink)->OnRequestEdit(dispid);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
	    if (m_rgSinks[iConnection]) {
                hr = ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnRequestEdit(dispid);
                if (hr != S_OK)
		    break;
	    }
        }
    }

    return (hr == S_OK) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::CreateInPlaceWindow
//=--------------------------------------------------------------------------=
// creates the window with which we will be working.
// yay.
//
// Parameters:
//    int            - [in] left
//    int            - [in] top
//    BOOL           - [in] can we skip redrawing?
//
// Output:
//    HWND
//
// Notes:
//    - DANGER! DANGER!  this function is protected so that anybody can call it
//      from their control.  however, people should be extremely careful of when
//      and why they do this.  preferably, this function would only need to be
//      called by an end-control writer in design mode to take care of some
//      hosting/painting issues.  otherwise, the framework should be left to
//      call it when it wants.
//
HWND COleControl::CreateInPlaceWindow
(
    int  x,
    int  y,
    BOOL fNoRedraw
)
{
    BOOL    fVisible;
    HRESULT hr;
    DWORD   dwWindowStyle, dwExWindowStyle;
    char    szWindowTitle[128];

    // if we've already got a window, do nothing.
    //
    if (m_hwnd)
        return m_hwnd;

    // get the user to register the class if it's not already
    // been done.  we have to critical section this since more than one thread
    // can be trying to create this control
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!CTLWNDCLASSREGISTERED(m_ObjectType)) {
        if (!RegisterClassData()) {
            LeaveCriticalSection(&g_CriticalSection);
            return NULL;
        } else
            CTLWNDCLASSREGISTERED(m_ObjectType) = TRUE;
    }
    LeaveCriticalSection(&g_CriticalSection);

    // let the user set up things like the window title, the
    // style, and anything else they feel interested in fiddling
    // with.
    //
    dwWindowStyle = dwExWindowStyle = 0;
    szWindowTitle[0] = '\0';
    if (!BeforeCreateWindow(&dwWindowStyle, &dwExWindowStyle, szWindowTitle))
        return NULL;

    dwWindowStyle |= (WS_CHILD | WS_CLIPSIBLINGS);

    // create window visible if parent hidden (common case)
    // otherwise, create hidden, then shown.  this is a little subtle, but
    // it makes sense eventually.
    //
    if (!m_hwndParent)
        m_hwndParent = GetParkingWindow();

    fVisible = IsWindowVisible(m_hwndParent);

    // if a control is subclassed, and we're in
    // a host that doesn't support Message Reflecting, we have to create
    // the user window in another window which will do all the reflecting.
    // VERY blech. [don't however, bother in design mode]
    //
    if (SUBCLASSWNDPROCOFCONTROL(m_ObjectType) && (m_hwndParent != GetParkingWindow())) {
        // determine if the host supports message reflecting.
        //
        if (!m_fCheckedReflecting) {
            VARIANT_BOOL f;
            hr = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, VT_BOOL, &f);
            if (FAILED(hr) || !f)
                m_fHostReflects = FALSE;
            m_fCheckedReflecting = TRUE;
        }

        // if the host doesn't support reflecting, then we have to create
        // an extra window around the control window, and then parent it
        // off that.
        //
        if (!m_fHostReflects) {
            ASSERT(m_hwndReflect == NULL, "Where'd this come from?");
            m_hwndReflect = CreateReflectWindow(!fVisible, m_hwndParent, x, y, &m_Size);
            if (!m_hwndReflect)
                return NULL;
            SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, (LONG_PTR)this);
            dwWindowStyle |= WS_VISIBLE;
        }
    } else {
        if (!fVisible)
            dwWindowStyle |= WS_VISIBLE;
    }

    // we have to mutex the entire create window process since we need to use
    // the s_pLastControlCreated to pass in the object pointer.  nothing too
    // serious
    //
    EnterCriticalSection(&g_CriticalSection);
    s_pLastControlCreated = this;
    m_fCreatingWindow = TRUE;

    // finally, go create the window, parenting it as appropriate.
    //
    m_hwnd = CreateWindowEx(dwExWindowStyle,
                            WNDCLASSNAMEOFCONTROL(m_ObjectType),
                            szWindowTitle,
                            dwWindowStyle,
                            (m_hwndReflect) ? 0 : x,
                            (m_hwndReflect) ? 0 : y,
                            m_Size.cx, m_Size.cy,
                            (m_hwndReflect) ? m_hwndReflect : m_hwndParent,
                            NULL, g_hInstance, NULL);

    // clean up some variables, and leave the critical section
    //
    m_fCreatingWindow = FALSE;
    s_pLastControlCreated = NULL;
    LeaveCriticalSection(&g_CriticalSection);

    if (m_hwnd) {
        // let the derived-control do something if they so desire
        //
        if (!AfterCreateWindow()) {
            BeforeDestroyWindow();
            SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
            DestroyWindow(m_hwnd);
            m_hwnd = NULL;
            return m_hwnd;
        }

        // if we didn't create the window visible, show it now.
        //
		
        if (fVisible)
		{
			if (GetParent(m_hwnd) != m_hwndParent)
				// SetWindowPos fails if parent hwnd is passed in so keep
				// this behaviour in those cases without ripping.
				SetWindowPos(m_hwnd, m_hwndParent, 0, 0, 0, 0,
							 SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW | (fNoRedraw) ? SWP_NOREDRAW : 0);
		}
    }

    // finally, tell the host of this
    //
    if (m_pClientSite)
        m_pClientSite->ShowObject();

    return m_hwnd;
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceParent    [helper]
//=--------------------------------------------------------------------------=
// sets up the parent window for our control.
//
// Parameters:
//    HWND            - [in] new parent window
//
// Notes:
//
void COleControl::SetInPlaceParent
(
    HWND hwndParent
)
{
    ASSERT(!m_pInPlaceSiteWndless, "This routine should only get called for windowed OLE controls");

    if (m_hwndParent == hwndParent)
        return;

    m_hwndParent = hwndParent;
    if (m_hwnd)
        SetParent(GetOuterWindow(), hwndParent);
}

//=--------------------------------------------------------------------------=
// COleControl::ControlWindowProc
//=--------------------------------------------------------------------------=
// default window proc for an OLE Control.   controls will have their own
// window proc called from this one, after some processing is done.
//
// Parameters:
//    - see win32sdk docs.
//
// Notes:
//
LRESULT CALLBACK COleControl::ControlWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    COleControl *pCtl = ControlFromHwnd(hwnd);
    HRESULT hr;
    LRESULT lResult;
    DWORD   dwCookie;

    // if the value isn't a positive value, then it's in some special
    // state [creation or destruction]  this is safe because under win32,
    // the upper 2GB of an address space aren't available.
    //
    if (!pCtl) {
        pCtl = s_pLastControlCreated;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pCtl);
        pCtl->m_hwnd = hwnd;
    } else if ((LONG_PTR)pCtl == (LONG_PTR)0xffffffff) {
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    // message preprocessing
    //
    if (pCtl->m_pSimpleFrameSite) {
        hr = pCtl->m_pSimpleFrameSite->PreMessageFilter(hwnd, msg, wParam, lParam, &lResult, &dwCookie);
        if (hr == S_FALSE) return lResult;
    }

    // for certain messages, do not call the user window proc. instead,
    // we have something else we'd like to do.
    //
    switch (msg) {
      case WM_PAINT:
        {
        // call the user's OnDraw routine.
        //
        PAINTSTRUCT ps;
        RECT        rc;
        HDC         hdc;

        // if we're given an HDC, then use it
        //
        if (!wParam)
            hdc = BeginPaint(hwnd, &ps);
        else
            hdc = (HDC)wParam;

        GetClientRect(hwnd, &rc);
        pCtl->OnDraw(DVASPECT_CONTENT, hdc, (RECTL *)&rc, NULL, NULL, TRUE);

        if (!wParam)
            EndPaint(hwnd, &ps);
        }
        break;

      default:
        // call the derived-control's window proc
        //
        lResult = pCtl->WindowProc(msg, wParam, lParam);
        break;
    }

    // message postprocessing
    //
    switch (msg) {

      case WM_NCDESTROY:
        // after this point, the window doesn't exist any more
        //
        pCtl->m_hwnd = NULL;
        break;

      case WM_SETFOCUS:
        // give the control site focus notification
        //
        if (pCtl->m_fInPlaceActive && pCtl->m_pControlSite)
            pCtl->m_pControlSite->OnFocus(TRUE);

        pCtl->m_fUIActive = TRUE;
        break;

      case WM_KILLFOCUS:
        // give the control site focus notification
        //
        if (pCtl->m_fInPlaceActive && pCtl->m_pControlSite)
            pCtl->m_pControlSite->OnFocus(FALSE);

        pCtl->m_fUIActive = FALSE;
        break;

      case WM_SIZE:
        // a change in size is a change in view
        //
        if (!pCtl->m_fCreatingWindow)
            pCtl->ViewChanged();
        break;
    }

    // lastly, simple frame postmessage processing
    //
    if (pCtl->m_pSimpleFrameSite)
        pCtl->m_pSimpleFrameSite->PostMessageFilter(hwnd, msg, wParam, lParam, &lResult, dwCookie);

    return lResult;
}

//=--------------------------------------------------------------------------=
// COleControl::SetFocus
//=--------------------------------------------------------------------------=
// we have to override this routine to get UI Activation correct.
//
// Parameters:
//    BOOL              - [in] true means take, false release
//
// Output:
//    BOOL
//
// Notes:
//    - CONSIDER: this is pretty messy, and it's still not entirely clear
//      what the ole control/focus story is.
//
BOOL COleControl::SetFocus
(
    BOOL fGrab
)
{
    HRESULT hr;
    HWND    hwnd;

    // first thing to do is check out UI Activation state, and then set
    // focus [either with windows api, or via the host for windowless
    // controls]
    //
    if (m_pInPlaceSiteWndless) {
        if (!m_fUIActive && fGrab)
            if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE))) return FALSE;

        hr = m_pInPlaceSiteWndless->SetFocus(fGrab);
        return (hr == S_OK) ? TRUE : FALSE;
    } else {

        // we've got a window.
        //
        if (m_fInPlaceActive) {
            hwnd = (fGrab) ? m_hwnd : m_hwndParent;
            if (!m_fUIActive && fGrab)
                return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
            else
                return SetGUIFocus(hwnd);
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::SetGUIFocus
//=--------------------------------------------------------------------------=
// does the work of setting the Windows GUI focus to the specified window
//
// Parameters:
//    HWND              - [in] window that should get focus
//
// Output:
//    BOOL              - [out] whether setting focus succeeded
//
// Notes:
//    we do this because some controls host non-ole window hierarchies, like
// the Netscape plugin ocx.  in such cases, the control may need to be UIActive
// to function properly in the document, but cannot take the windows focus
// away from one of its child windows.  such controls may override this method
// and respond as appropriate.
//
BOOL COleControl::SetGUIFocus
(
    HWND hwndSet
)
{
    return (::SetFocus(hwndSet) == hwndSet);
}


//=--------------------------------------------------------------------------=
// COleControl::ReflectWindowProc
//=--------------------------------------------------------------------------=
// reflects window messages on to the child window.
//
// Parameters and Output:
//    - see win32 sdk docs
//
// Notes:
//
LRESULT CALLBACK COleControl::ReflectWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    COleControl *pCtl;

    switch (msg) {
        case WM_COMMAND:
        case WM_NOTIFY:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_DELETEITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_COMPAREITEM:
        case WM_HSCROLL:
        case WM_VSCROLL:
        case WM_PARENTNOTIFY:
        case WM_SETFOCUS:
        case WM_SIZE:
            pCtl = (COleControl *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (pCtl)
                return SendMessage(pCtl->m_hwnd, OCM__BASE + msg, wParam, lParam);
            break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientProperty    [callable]
//=--------------------------------------------------------------------------=
// returns the value of an ambient property
//
// Parameters:
//    DISPID        - [in]  property to get
//    VARTYPE       - [in]  type of desired data
//    void *        - [out] where to put the data
//
// Output:
//    BOOL          - FALSE means didn't work.
//
// Notes:
//
BOOL COleControl::GetAmbientProperty
(
    DISPID  dispid,
    VARTYPE vt,
    void   *pData
)
{
    DISPPARAMS dispparams;
    VARIANT v, v2;
    HRESULT hr;

    v.vt = VT_EMPTY;
    v.lVal = 0;
    v2.vt = VT_EMPTY;
    v2.lVal = 0;

    // get a pointer to the source of ambient properties.
    //
    if (!m_pDispAmbient) {
        if (m_pClientSite)
            m_pClientSite->QueryInterface(IID_IDispatch, (void **)&m_pDispAmbient);

        if (!m_pDispAmbient)
            return FALSE;
    }

    // now go and get the property into a variant.
    //
    memset(&dispparams, 0, sizeof(DISPPARAMS));
    hr = m_pDispAmbient->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dispparams,
                                &v, NULL, NULL);
    if (FAILED(hr)) return FALSE;

    // we've got the variant, so now go an coerce it to the type that the user
    // wants.  if the types are the same, then this will copy the stuff to
    // do appropriate ref counting ...
    //
    hr = VariantChangeType(&v2, &v, 0, vt);
    if (FAILED(hr)) {
        VariantClear(&v);
        return FALSE;
    }

    // copy the data to where the user wants it
    //
    CopyMemory(pData, &(v2.lVal), g_rgcbDataTypeSize[vt]);
    VariantClear(&v);
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientFont    [callable]
//=--------------------------------------------------------------------------=
// gets the current font for the user.
//
// Parameters:
//    IFont **         - [out] where to put the font.
//
// Output:
//    BOOL             - FALSE means couldn't get it.
//
// Notes:
//
BOOL COleControl::GetAmbientFont
(
    IFont **ppFont
)
{
    IDispatch *pFontDisp;

    // we don't have to do much here except get the ambient property and QI
    // it for the user.
    //
    *ppFont = NULL;
    if (!GetAmbientProperty(DISPID_AMBIENT_FONT, VT_DISPATCH, &pFontDisp))
        return FALSE;

    pFontDisp->QueryInterface(IID_IFont, (void **)ppFont);
    pFontDisp->Release();
    return (*ppFont) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::DesignMode
//=--------------------------------------------------------------------------=
// returns TRUE if we're in Design mode.
//
// Output:
//    BOOL            - true is design mode, false is run mode
//
// Notes:
//
BOOL COleControl::DesignMode
(
    void
)
{
    VARIANT_BOOL f;

    // if we don't already know our run mode, go and get it.  we'll assume
    // it's true unless told otherwise [or if the operation fails ...]
    //
    if (!m_fModeFlagValid) {
        f = TRUE;
        m_fModeFlagValid = TRUE;
        GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &f);
        m_fRunMode = f;
    }

    return !m_fRunMode;
}


//=--------------------------------------------------------------------------=
// COleControl::FireEvent
//=--------------------------------------------------------------------------=
// fires an event.  handles arbitrary number of arguments.
//
// Parameters:
//    EVENTINFO *        - [in] struct that describes the event.
//    ...                - arguments to the event
//
// Output:
//    none
//
// Notes:
//    - use stdarg's va_* macros.
//
void __cdecl COleControl::FireEvent
(
    EVENTINFO *pEventInfo,
    ...
)
{
    va_list    valist;
    DISPPARAMS dispparams;
    VARIANT    rgvParameters[MAX_ARGS];
    VARIANT   *pv;
    VARTYPE    vt;
    int        iParameter;
    int        cbSize;

    ASSERT(pEventInfo->cParameters <= MAX_ARGS, "Don't support more than MAX_ARGS params.  sorry.");

    va_start(valist, pEventInfo);

    // copy the Parameters into the rgvParameters array.  make sure we reverse
    // them for automation
    //
    pv = &(rgvParameters[pEventInfo->cParameters - 1]);
    for (iParameter = 0; iParameter < pEventInfo->cParameters; iParameter++) {

        vt = pEventInfo->rgTypes[iParameter];

        // if it's a by value variant, then just copy the whole
        // dang thing
        //
        if (vt == VT_VARIANT)
            *pv = va_arg(valist, VARIANT);
        else {
            // copy the vt and the data value.
            //
            pv->vt = vt;
            if (vt & VT_BYREF)
                cbSize = sizeof(void *);
            else
                cbSize = g_rgcbDataTypeSize[vt];

            // small optimization -- we can copy 2/4 bytes over quite
            // quickly.
            //
            if (cbSize == sizeof(short))
                V_I2(pv) = va_arg(valist, short);
            else if (cbSize == 4)
                V_I4(pv) = va_arg(valist, long);
            else {
                // copy over 8 bytes
                //
                ASSERT(cbSize == 8, "don't recognize the type!!");
                V_CY(pv) = va_arg(valist, CURRENCY);
            }
        }

        pv--;
    }

    // fire the event
    //
    dispparams.rgvarg = rgvParameters;
    dispparams.cArgs = pEventInfo->cParameters;
    dispparams.rgdispidNamedArgs = NULL;
    dispparams.cNamedArgs = 0;

    m_cpEvents.DoInvoke(pEventInfo->dispid, &dispparams);

    va_end(valist);
}

//=--------------------------------------------------------------------------=
// COleControl::AfterCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// something the user can pay attention to
//
// Output:
//    BOOL             - false means fatal error, can't continue
// Notes:
//
BOOL COleControl::AfterCreateWindow
(
    void
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we create a window.  the user should register their
// window class here, and set up any other things, such as the title of
// the window, and/or sytle bits, etc ...
//
// Parameters:
//    DWORD *            - [out] dwWindowFlags
//    DWORD *            - [out] dwExWindowFlags
//    LPSTR              - [out] name of window to create
//
// Output:
//    BOOL               - false means fatal error, can't continue
//
// Notes:
//
BOOL COleControl::BeforeCreateWindow
(
    DWORD *pdwWindowStyle,
    DWORD *pdwExWindowStyle,
    LPSTR  pszWindowTitle
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::InvalidateControl    [callable]
//=--------------------------------------------------------------------------=
void COleControl::InvalidateControl
(
    LPCRECT lpRect
)
{
    if (m_fInPlaceActive)
        InvalidateRect(m_hwnd, lpRect, TRUE);
    else
        ViewChanged();

    // CONSIDER: one might want to call pOleAdviseHolder->OnDataChanged() here
    // if there was support for IDataObject
}

//=--------------------------------------------------------------------------=
// COleControl::SetControlSize    [callable]
//=--------------------------------------------------------------------------=
// sets the control size. they'll give us the size in pixels.  we've got to
// convert them back to HIMETRIC before passing them on!
//
// Parameters:
//    SIZEL *        - [in] new size
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::SetControlSize
(
    SIZEL *pSize
)
{
    HRESULT hr;
    SIZEL slHiMetric;

    PixelToHiMetric(pSize, &slHiMetric);
    hr = SetExtent(DVASPECT_CONTENT, &slHiMetric);
    return (FAILED(hr)) ? FALSE : TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::RecreateControlWindow    [callable]
//=--------------------------------------------------------------------------=
// called by a [subclassed, typically] control to recreate it's control
// window.
//
// Parameters:
//    none
//
// Output:
//    HRESULT
//
// Notes:
//    - NOTE: USE ME EXTREMELY SPARINGLY! THIS IS AN EXTREMELY EXPENSIVE
//      OPERATION!
//
HRESULT COleControl::RecreateControlWindow
(
    void
)
{
    HRESULT hr;
    HWND    hwndPrev;

    // we need to correctly preserve the control's position within the
    // z-order here.
    //
    if (m_hwnd)
        hwndPrev = ::GetWindow(m_hwnd, GW_HWNDPREV);

    // if we're in place active, then we have to deactivate, and reactivate
    // ourselves with the new window ...
    //
    if (m_fInPlaceActive) {

        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
        hr = InPlaceActivate((m_fUIActive) ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE);
        RETURN_ON_FAILURE(hr);

    } else if (m_hwnd) {
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
        if (m_hwndReflect) {
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }

        CreateInPlaceWindow(0, 0, FALSE);
    }

    // restore z-order position
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, hwndPrev, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    return m_hwnd ? S_OK : E_FAIL;
}

// from Globals.C. don't need to mutex it here since we only read it.
//
extern HINSTANCE g_hInstResources;

//=--------------------------------------------------------------------------=
// COleControl::GetResourceHandle    [callable]
//=--------------------------------------------------------------------------=
// gets the HINSTANCE of the DLL where the control should get resources
// from.  implemented in such a way to support satellite DLLs.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE COleControl::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // crit sect this for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fHaveLocale)
        // if we can't get the ambient locale id, then we'll just continue
        // with the globally set up value.
        //
        if (!GetAmbientProperty(DISPID_AMBIENT_LOCALEID, VT_I4, &g_lcidLocale))
            goto Done;

    g_fHaveLocale = TRUE;

  Done:
    LeaveCriticalSection(&g_CriticalSection);
    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\ctlocx96.cpp ===
//=--------------------------------------------------------------------------=
// CtlOcx96.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the OCX 96 interfaces that don't quite fit in to the
// categories covered by embedding, persistence, and ctlmisc.cpp
//
//
#include "IPServer.H"

#include "CtrlObj.H"
#include "Globals.H"


//=--------------------------------------------------------------------------=
// COleControl::GetActivationPolicy    [IPointerInactive]
//=--------------------------------------------------------------------------=
// returns the present activation policy for this object.  for non-subclassed
// windows controls, this means we can put off in-place activation for quite
// a while.
//
// Parameters:
//    DWORD *        - [out] activation policy
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetActivationPolicy
(
    DWORD *pdwPolicy
)
{
    CHECK_POINTER(pdwPolicy);

    // just get the policy in the global structure describing this control.
    //
    *pdwPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnInactiveMouseMove    [IPointerInactive]
//=--------------------------------------------------------------------------=
// indicates to an inactive oobject that the mouse pointer has moved over the
// object.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveMouseMove
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg
)
{
    // OVERRIDE: end control writers should just override this if they want
    // to have a control that is never in-place active.
    //
    return S_OK;
}
    
//=--------------------------------------------------------------------------=
// COleControl::OnInactiveSetCursor    [IPointerInactive]
//=--------------------------------------------------------------------------=
// called by the container for the inactive object under the mouse pointer on
// recept of a WM_SETCURSOR message.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//    BOOL               - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveSetCursor
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg,
    BOOL    fSetAlways
)
{
    // OVERRIDE:  just get the user to override this if they want to never
    // be activated
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QuickActivate    [IQuickActivate]
//=--------------------------------------------------------------------------=
// allows the container to activate the control.
//
// Parameters:
//    QACONTAINER *        - [in]  info about the container
//    QACONTROL *          - [out] info about the control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QuickActivate
(
    QACONTAINER *pContainer,
    QACONTROL *pControl
)
{
    HRESULT hr;
    DWORD   dw;

    // we need these guys.
    //
    if (!pContainer) return E_UNEXPECTED;
    if (!pControl) return E_UNEXPECTED;

    // start grabbing things from the QACONTAINER structure and apply them
    // as relevant
    //
    // if (pContainer->cbSize < sizeof(QACONTAINER)) return E_UNEXPECTED;
    // if (pControl->cbSize < sizeof(QACONTROL)) return E_UNEXPECTED;

    // save out the client site, of course.
    //
    if (pContainer->pClientSite) {
        hr = SetClientSite(pContainer->pClientSite);
        RETURN_ON_FAILURE(hr);
    }

    // if the lcid is not LANG_NEUTRAL, score!
    //
    if (pContainer->lcid) {
        g_lcidLocale = pContainer->lcid;
        g_fHaveLocale = TRUE;
    }

    // pay attention to some ambients
    //
    if (pContainer->dwAmbientFlags & QACONTAINER_MESSAGEREFLECT) {
        m_fHostReflects = TRUE;
        m_fCheckedReflecting = TRUE;
    }

    // hook up some notifications.  first property notifications.
    //
    if (pContainer->pPropertyNotifySink) {
        pContainer->pPropertyNotifySink->AddRef();
        hr = m_cpPropNotify.AddSink((void *)pContainer->pPropertyNotifySink, &pControl->dwPropNotifyCookie);
        if (FAILED(hr)) {
            pContainer->pPropertyNotifySink->Release();
            return hr;
        }
    }

    // then the event sink.
    //
    if (pContainer->pUnkEventSink) {
        hr = m_cpEvents.Advise(pContainer->pUnkEventSink, &pControl->dwEventCookie);
        if (FAILED(hr)) {
            pContainer->pUnkEventSink->Release();
            return hr;
        }
    }

    // finally, the advise sink.
    //
    if (pContainer->pAdviseSink) {
        // don't need to pass the cookie back since there can only be one
        // person advising at a time.
        //
        hr = Advise(pContainer->pAdviseSink, &dw);
        RETURN_ON_FAILURE(hr);
    }

    // set up a few things in the QACONTROL structure.  we're opaque by default
    //
    pControl->dwMiscStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    pControl->dwViewStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    pControl->dwPointerActivationPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);

    // that's pretty much all we're interested in.  we will, however, pass on the
    // rest of the things to the end control writer and see if they want to do
    // anything with them. they shouldn't touch any of the above except for the
    // ambients.
    //
    return OnQuickActivate(pContainer, &(pControl->dwViewStatus));
}

//=--------------------------------------------------------------------------=
// COleControl::SetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to set the content extent of the control.
//
// Parameters:
//    LPSIZEL            - [in] the size of the content extent
//
// Output:
//    HRESULT            - S_OK, or E_FAIL for fixed size control
//
// Notes:
//
STDMETHODIMP COleControl::SetContentExtent
(
    LPSIZEL pSize
)
{
    return SetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::GetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to get the content extent of the control
//
// Parameters:
//    LPSIZEL        - [out] returns current size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetContentExtent
(
    LPSIZEL pSize
)
{
    return GetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::OnQuickActivate    [overridable]
//=--------------------------------------------------------------------------=
// not all the of the members of the QACONTAINER need to be consumed by the
// framework, but are, at least, extremely interesting.  thus, we will pass
// on the struture to the end control writer, and let them consume these.
//
// Parameters:
//    QACONTAINER *            - [in]  contains additional information
//    DWORD *                  - [out] put ViewStatus flags here.
//
// Output:
//    HRESULT
//
// Notes:
//    - control writers should only look at/consume:
//        a. dwAmbientFlags
//        b. colorFore/colorBack
//        c. pFont
//        d. pUndoMgr
//        e. dwAppearance
//        f. hpal
//
//    - all the others are set up the for the user by the framework.
//    - control writers should set up the pdwViewStatus with flags as per
//      IViewObjectEx::GetViewStatus.  if you don't know what this is or don't
//      care, then don't touch.
//
HRESULT COleControl::OnQuickActivate
(
    QACONTAINER *pContainer,
    DWORD       *pdwViewStatus
)
{
    // by default, nuthin much to do!
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\ctlpsst.cpp ===
//=--------------------------------------------------------------------------=
// CtlPsst.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of persistence interfaces for COleControl.
//
#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Util.H"

// this is the name of the stream we'll save our ole controls to.
//
const WCHAR wszCtlSaveStream [] = L"CONTROLSAVESTREAM";

// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// to help with out stream save implementation ...
//
#define STREAMHDR_SIGNATURE 0x12344321  // Signature to identify our format (avoid crashes!)
#define IPROP_END 0xFF                  // Marker at end of property list
#define MAXAUTOBUF 3800                 // Best if < 1 page.

typedef struct tagSTREAMHDR {

    DWORD  dwSignature;     // Signature.
    size_t cbWritten;       // Number of bytes written

} STREAMHDR;

//=--------------------------------------------------------------------------=
// COleControl persistence interfaces
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// IPersistPropertyBag.  we've got a property bag, so let's load our properties
// from it.
//
// Parameters:
//    IPropertyBag *      - [in] pbag from which to read props.
//    IErrorLog *         - [in] error log to write to
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    HRESULT hr;

    // load in our standard state first.  nothing serious here ... currently,
    // we've just got two properties, for cx and cy.
    //
    hr = LoadStandardState(pPropertyBag, pErrorLog);
    RETURN_ON_FAILURE(hr);

    // now call the user text load function, and get them to load in whatever
    // they're interested in.
    //
    hr = LoadTextState(pPropertyBag, pErrorLog);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// given a property bag, save out all the relevant state information.
//
// Parameters:
//    IPropertyBag *        - [in] property to write to
//    BOOL                  - [in] do we clear the dirty bit?
//    BOOL                  - [in] do we write out default values anyhoo?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IPropertyBag *pPropertyBag,
    BOOL          fClearDirty,
    BOOL          fWriteDefault
)
{
    HRESULT hr;

    // save out standard state information
    //
    hr = SaveStandardState(pPropertyBag);
    RETURN_ON_FAILURE(hr);

    // now call the user function and get them to save out
    // all of their properties.
    //
    hr = SaveTextState(pPropertyBag, fWriteDefault);
    RETURN_ON_FAILURE(hr);

    // now clear the dirty flag and send out notification that we're
    // done.
    //
    if (fClearDirty)
        m_fDirty = FALSE;

    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassID    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// returns the classid of this mamma
//
// Parameters:
//    CLSID *         - [out] where to put the clsid
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassID
(
    CLSID *pclsid
)
{
    CHECK_POINTER(pclsid);

    // copy the thing over
    //
    *pclsid = CLSIDOFOBJECT(m_ObjectType);
    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::IsDirty    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// asks if we're dirty or not.  duh.
//
// Output:
//    HRESULT        - S_OK: dirty, S_FALSE: not dirty
//
// Notes:
//
STDMETHODIMP COleControl::IsDirty
(
    void
)
{
    return (m_fDirty) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// causes the control to intialize itself with a new bunch of state information
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    void
)
{
    BOOL f;

    // call the overridable function to do this work
    //
    f = InitializeNewState();
    return (f) ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetSizeMax    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ULARGE_INTEGER *    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetSizeMax
(
    ULARGE_INTEGER *pulMaxSize
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// load from an IStream
//
// Parameters:
//    IStream *    - [in] stream from which to load
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IStream *pStream
)
{
    HRESULT hr;

    // first thing to do is read in standard properties the user don't
    // persist themselves.
    //
    hr = LoadStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // load in the user properties.  this method is one they -have- to implement
    // themselves.
    //
    hr = LoadBinaryState(pStream);
    
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// saves out our state using streams
//
// Parameters:
//    IStream *        - [in]
//    BOOL             - [in] clear dirty bit?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStream *pStream,
    BOOL     fClearDirty
)
{
    HRESULT hr;

    // use our helper routine that we share with the IStorage persistence
    // code.
    //
    hr = m_SaveToStream(pStream);
    RETURN_ON_FAILURE(hr);

    // clear out dirty flag [if appropriate] and notify that we're done
    // with save.
    //
    if (fClearDirty)
        m_fDirty = FALSE;
    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStorage]
//=--------------------------------------------------------------------------=
// ipersiststorage version of this.  fweee
//
// Parameters:
//    IStorage *    - [in] we don't use this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    IStorage *pStorage
)
{
    // we already have an implementation of this [for IPersistStreamInit]
    //
    return InitNew();
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStorage]
//=--------------------------------------------------------------------------=
// Ipersiststorage version of this
//
// Parameters:
//    IStorage *    - [in] DUH.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load(IStorage *pStorage)
{
    IStream *pStream;
    HRESULT  hr;

    // we're going to use IPersistStream::Load from the CONTENTS stream.
    //
    hr = pStorage->OpenStream(wszCtlSaveStream, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // IPersistStreamInit::Load
    //
    hr = Load(pStream);
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStorage]
//=--------------------------------------------------------------------------=
// save into the contents stream of the given storage object.
//
// Parameters:
//    IStorage *        - [in] 10 points if you figure it out
//    BOOL              - [in] is the storage the same as the load storage?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStorage *pStorage,
    BOOL      fSameAsLoad
)
{
    IStream *pStream;
    HRESULT  hr;

    // we're just going to save out to the CONTENTES stream.
    //
    hr = pStorage->CreateStream(wszCtlSaveStream, STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                0, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // use our helper routine.
    //
    hr = m_SaveToStream(pStream);
    m_fSaveSucceeded = (FAILED(hr)) ? FALSE : TRUE;
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveCompleted    [IPersistStorage]
//=--------------------------------------------------------------------------=
// lets us clear out our flags.
//
// Parameters:
//    IStorage *    - ignored
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SaveCompleted
(
    IStorage *pStorageNew
)
{
    // if our save succeeded, then we can do our post save work.
    //
    if (m_fSaveSucceeded) {
        m_fDirty = FALSE;
        if (m_pOleAdviseHolder)
            m_pOleAdviseHolder->SendOnSave();
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::HandsOffStorage    [IPersistStorage]
//=--------------------------------------------------------------------------=
// not interesting
//
// Output:
//    S_OK
//
// Notes:
//
STDMETHODIMP COleControl::HandsOffStorage
(
    void
)
{
    // we don't ever hold on to  a storage pointer, so this is remarkably
    // uninteresting to us.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::m_SaveToStream    [helper: IPersistStreamInit/IPersistStorage]
//=--------------------------------------------------------------------------=
// save ourselves to a stream
//
// Parameters:
//    IStream *        - figure it out
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::m_SaveToStream
(
    IStream *pStream
)
{
    HRESULT hr;

    // save out standard state information that the user has no control
    // over
    //
    hr = SaveStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // save out user-specific satte information.  they MUST implement this
    // function
    //
    hr = SaveBinaryState(pStream);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// text persistence APIs.  there is another version for streams.
//
// Parameters:
//    IPropertyBag *    - [in]
//    IErrorLog *       - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    VARIANT v;
    HRESULT hr;
    SIZEL   slHiMetric = { 100, 50 };

    // currently, our only standard properties are related to size.
    // if we can't find them, then we'll just use some defaults.
    //
    v.vt = VT_I4;
    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentX", &v, pErrorLog);
    if (SUCCEEDED(hr)) slHiMetric.cx = v.lVal;

    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentY", &v, pErrorLog);
    if (SUCCEEDED(hr)) slHiMetric.cy = v.lVal;

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// stream persistence APIs.  there is another version for text.
//
// Parameters:
//    IStream *         - [in] 
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IStream *pStream
)
{
    STREAMHDR stmhdr;
    HRESULT hr;
    SIZEL   slHiMetric;

    // look for our header structure, so we can verify stream validity.
    //
    hr = pStream->Read(&stmhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    if (stmhdr.dwSignature != STREAMHDR_SIGNATURE)
        return E_UNEXPECTED;

    // currently, the only standard state we're writing out is
    // a SIZEL structure describing the control's size.
    //
    if (stmhdr.cbWritten != sizeof(m_Size))
        return E_UNEXPECTED;

    // we like the stream.  let's go load in our two properties.
    //
    hr = pStream->Read(&slHiMetric, sizeof(slHiMetric), NULL);
    RETURN_ON_FAILURE(hr);

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using text
// persistence APIs.  there is another version for stream persistence.
//
// Parameters:
//    IPropertyBag *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IPropertyBag *pPropertyBag
)
{
    HRESULT hr;
    VARIANT v;
    SIZEL   slHiMetric;

    // currently, the only standard proprerties we persist are Size related
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    v.vt = VT_I4;
    v.lVal = slHiMetric.cx;

    hr = pPropertyBag->Write(L"_ExtentX", &v);
    RETURN_ON_FAILURE(hr);

    v.lVal = slHiMetric.cy;

    hr = pPropertyBag->Write(L"_ExtentY", &v);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using stream
// persistence APIs.  there is another version for text persistence.
//
// Parameters:
//    IStream *            - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IStream *pStream
)
{
    STREAMHDR streamhdr = { STREAMHDR_SIGNATURE, sizeof(SIZEL) };
    HRESULT hr;
    SIZEL   slHiMetric;


    // first thing to do is write out our stream hdr structure.
    //
    hr = pStream->Write(&streamhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    // the only properties we're currently persisting here are the size
    // properties for this control.  make sure we do that in HiMetric
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    hr = pStream->Write(&slHiMetric, sizeof(slHiMetric), NULL);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::InitializeNewState    [overridable]
//=--------------------------------------------------------------------------=
// the user can override this to initialize variables
//
// Output:
//    BOOL        - FALSE means couldn't do it.
//
// Notes:
//
BOOL COleControl::InitializeNewState
(
    void
)
{
    // we find this largely uninteresting
    //
    return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\ctlview.cpp ===
//=--------------------------------------------------------------------------=
// CtlView.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the IViewObjectEx interface, which is a moderately
// non-trivial bunch of code.
//
#include "IPServer.H"

#include "CtrlObj.H"
#include "Globals.H"
#include "Util.H"

// for ASSERT and FAIL
//
SZTHISFILE

// local functions we're going to find useful
//
HDC _CreateOleDC(DVTARGETDEVICE *ptd);

//=--------------------------------------------------------------------------=
// COleControl::Draw    [IViewObject2]
//=--------------------------------------------------------------------------=
// Draws a representation of an object onto the specified device context. 
//
// Parameters:
//    DWORD                - [in] draw aspect
//    LONG                 - [in] part of object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in] specifies the target device
//    HDC                  - [in] information context for target device
//    HDC                  - [in] target device context
//    LPCRECTL             - [in] rectangle in which the object is drawn
//    LPCRECTL             - [in] window extent and origin for metafiles
//    BOOL (*)(DWORD)      - [in] callback for continuing or cancelling drawing
//    DWORD                - [in] parameter to pass to callback.
//
// Output:
//    HRESULT
//
// Notes:
//    - we support the following OCX 96 extensions
//        a. flicker free drawing [multi-pass drawing]
//        b. pvAspect != NULL for optimized DC handling
//        c. prcBounds == NULL for windowless inplace active objects
//
STDMETHODIMP COleControl::Draw
(
    DWORD            dwDrawAspect,
    LONG             lIndex,
    void            *pvAspect,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    HDC              hdcDraw,
    LPCRECTL         prcBounds,
    LPCRECTL         prcWBounds,
    BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue),
    ULONG_PTR        dwContinue
)
{
    HRESULT hr;
    RECTL rc;
    POINT pVp, pW;
    BOOL  fOptimize = FALSE;
    int iMode;
    BYTE fMetafile = FALSE;
    BYTE fDeleteDC = FALSE;

    // support the aspects required for multi-pass drawing
    //
    switch (dwDrawAspect) {
        case DVASPECT_CONTENT:
        case DVASPECT_OPAQUE:
        case DVASPECT_TRANSPARENT:
            break;
        default:
            return DV_E_DVASPECT;
    }

    // first, have to do a little bit to support printing.
    //
    if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE) {

        // We are dealing with a metafile.
        //
        fMetafile = TRUE;

        // If attributes DC is NULL, create one, based on ptd.
        //
        if (!hicTargetDevice) {

            // Does _CreateOleDC have to return an hDC
            // or can it be flagged to return an hIC 
            // for this particular case?
            //
            hicTargetDevice = _CreateOleDC(ptd);
            fDeleteDC = TRUE;
        }
    }

    // check to see if we have any flags passed in the pvAspect parameter.
    //
    if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb == sizeof(DVASPECTINFO))
        fOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE) ? TRUE : FALSE;

    // if we are windowless, then we just pass this on to the end control code.
    //
    if (m_fInPlaceActive) {

        // give them a rectangle with which to draw
        //
        //ASSERT(!m_fInPlaceActive || !prcBounds, "Inplace active and somebody passed in prcBounds!!!");
        if (prcBounds)
		memcpy(&rc, prcBounds, sizeof(rc));
	else
		memcpy(&rc, &m_rcLocation, sizeof(rc));
    } else {

        // first -- convert the DC back to MM_TEXT mapping mode so that the
        // window proc and OnDraw can share the same painting code.  save
        // some information on it, so we can restore it later [without using
        // a SaveDC/RestoreDC]
        //
        rc = *prcBounds;

        // Don't do anything to hdcDraw if it's a metafile.
        // The control's Draw method must make the appropriate
        // accomodations for drawing to a metafile
        //
        if (!fMetafile) {
            LPtoDP(hdcDraw, (POINT *)&rc, 2);
            SetViewportOrgEx(hdcDraw, 0, 0, &pVp);
            SetWindowOrgEx(hdcDraw, 0, 0, &pW);
            iMode = SetMapMode(hdcDraw, MM_TEXT);
        }
    }

    // prcWBounds is NULL and not used if we are not dealing with a metafile.
    // For metafiles, we pass on rc as *prcBounds, we should also include
    // prcWBounds
    //
    hr = OnDraw(dwDrawAspect, hdcDraw, &rc, prcWBounds, hicTargetDevice, fOptimize);

    // clean up the DC when we're done with it, if appropriate.
    //
    if (!m_fInPlaceActive) {
        SetViewportOrgEx(hdcDraw, pVp.x, pVp.y, NULL);
        SetWindowOrgEx(hdcDraw, pW.x, pW.y, NULL);
        SetMapMode(hdcDraw, iMode);
    }

    // if we created a dc, blow it away now
    //
    if (fDeleteDC) DeleteDC(hicTargetDevice);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::DoSuperClassPaint
//=--------------------------------------------------------------------------=
// design time painting of a subclassed control.
//
// Parameters:
//    HDC                - [in]  dc to work with
//    LPCRECTL           - [in]  rectangle to paint to.  should be in pixels
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::DoSuperClassPaint
(
    HDC      hdc,
    LPCRECTL prcBounds
)
{
    HWND hwnd;
    RECT rcClient;
    int  iMapMode;
    POINT ptWOrg, ptVOrg;
    SIZE  sWOrg, sVOrg;

    // make sure we have a window.
    //
    hwnd = CreateInPlaceWindow(0,0, FALSE);
    if (!hwnd)
        return E_FAIL;

    GetClientRect(hwnd, &rcClient);

    // set up the DC for painting.  this code largely taken from the MFC CDK
    // DoSuperClassPaint() fn.  doesn't always get things like command
    // buttons quite right ...
    //
    // NOTE: there is a windows 95 problem in which the font instance manager
    // will leak a bunch of bytes in the global GDI pool whenever you 
    // change your extents and have an active font.  this code gets around
    // this for on-screen cases, but not for printing [which shouldn't be
    // too serious, because you're not often changing your control size and
    // printing rapidly in succession]
    //
    if ((rcClient.right - rcClient.left != prcBounds->right - prcBounds->left)
        && (rcClient.bottom - rcClient.top != prcBounds->bottom - prcBounds->top)) {

        iMapMode = SetMapMode(hdc, MM_ANISOTROPIC);
        SetWindowExtEx(hdc, rcClient.right, rcClient.bottom, &sWOrg);
        SetViewportExtEx(hdc, prcBounds->right - prcBounds->left, prcBounds->bottom - prcBounds->top, &sVOrg);
    }

    SetWindowOrgEx(hdc, 0, 0, &ptWOrg);
    SetViewportOrgEx(hdc, prcBounds->left, prcBounds->top, &ptVOrg);

#if STRICT
    CallWindowProc((WNDPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#else
    CallWindowProc((FARPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#endif // STRICT

    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::GetColorSet    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the logical palette that the control will use for drawing in its
// IViewObject::Draw method with the corresponding parameters.
//
// Parameters:
//    DWORD                - [in]  how the object is to be represented
//    LONG                 - [in]  part of the object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in]  specifies the target device
//    HDC                  - [in]  information context for the target device
//    LOGPALETTE **        - [out] where to put palette
//
// Output:
//    S_OK                 - Control has a palette, and returned it through the out param.
//    S_FALSE              - Control does not currently have a palette.
//    E_NOTIMPL            - Control will never have a palette so optimize handling of this control.
//
// Notes:
//
STDMETHODIMP COleControl::GetColorSet
(
    DWORD            dwDrawAspect,
    LONG             lindex,
    void            *IgnoreMe,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    LOGPALETTE     **ppColorSet
)
{
    if (dwDrawAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *ppColorSet = NULL;
    return (OnGetPalette(hicTargetDevice, ppColorSet)) ? ((*ppColorSet) ? S_OK : S_FALSE) : E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Freeze    [IViewObject2]
//=--------------------------------------------------------------------------=
// Freezes a certain aspect of the object's presentation so that it does not
// change until the IViewObject::Unfreeze method is called.
//
// Parameters:
//    DWORD            - [in] aspect
//    LONG             - [in] part of object to draw
//    void *           - NULL
//    DWORD *          - [out] for Unfreeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Freeze
(
    DWORD   dwDrawAspect,
    LONG    lIndex,
    void   *IgnoreMe,
    DWORD  *pdwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Unfreeze    [IVewObject2]
//=--------------------------------------------------------------------------=
// Releases a previously frozen drawing. The most common use of this method
// is for banded printing.
//
// Parameters:
//    DWORD        - [in] cookie from freeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Unfreeze
(
    DWORD dwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::SetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Sets up a connection between the control and an advise sink so that the
// advise sink can be notified about changes in the control's view.
//
// Parameters:
//    DWORD            - [in] aspect
//    DWORD            - [in] info about the sink
//    IAdviseSink *    - [in] the sink
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SetAdvise
(
    DWORD        dwAspects,
    DWORD        dwAdviseFlags,
    IAdviseSink *pAdviseSink
)
{
    // if it's not a content aspect, we don't support it.
    //
    if (!(dwAspects & DVASPECT_CONTENT)) {
        return DV_E_DVASPECT;
    }

    // set up some flags  [we gotta stash for GetAdvise ...]
    //
    m_fViewAdvisePrimeFirst = (dwAdviseFlags & ADVF_PRIMEFIRST) ? TRUE : FALSE;
    m_fViewAdviseOnlyOnce = (dwAdviseFlags & ADVF_ONLYONCE) ? TRUE : FALSE;

    RELEASE_OBJECT(m_pViewAdviseSink);
    m_pViewAdviseSink = pAdviseSink;
    ADDREF_OBJECT(m_pViewAdviseSink);

    // prime them if they want it [we need to store this so they can get flags later]
    //
    if (m_fViewAdvisePrimeFirst)
        ViewChanged();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Retrieves the existing advisory connection on the control if there is one.
// This method simply returns the parameters used in the most recent call to
// the IViewObject::SetAdvise method.
//
// Parameters:
//    DWORD *            - [out]  aspects
//    DWORD *            - [out]  advise flags
//    IAdviseSink **     - [out]  the sink
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP COleControl::GetAdvise
(
    DWORD        *pdwAspects,
    DWORD        *pdwAdviseFlags,
    IAdviseSink **ppAdviseSink
)
{
    // if they want it, give it to them
    //
    if (pdwAspects)
        *pdwAspects = DVASPECT_CONTENT;

    if (pdwAdviseFlags) {
        *pdwAdviseFlags = 0;
        if (m_fViewAdviseOnlyOnce) *pdwAdviseFlags |= ADVF_ONLYONCE;
        if (m_fViewAdvisePrimeFirst) *pdwAdviseFlags |= ADVF_PRIMEFIRST;
    }

    if (ppAdviseSink) {
        *ppAdviseSink = m_pViewAdviseSink;
        ADDREF_OBJECT(*ppAdviseSink);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the size that the control will be drawn on the
// specified target device.
//
// Parameters:
//    DWORD            - [in] draw aspect
//    LONG             - [in] part of object to draw
//    DVTARGETDEVICE * - [in] information about target device
//    LPSIZEL          - [out] where to put the size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD           dwDrawAspect,
    LONG            lindex,
    DVTARGETDEVICE *ptd,
    LPSIZEL         psizel
)
{
    // we already have an implementation of this [from IOleObject]
    //
    return GetExtent(dwDrawAspect, psizel);
}


//=--------------------------------------------------------------------------=
// COleControl::OnGetPalette    [overridable]
//=--------------------------------------------------------------------------=
// called when the host wants palette information.  ideally, people should use
// this sparingly and carefully.
//
// Parameters:
//    HDC            - [in]  HIC for the target device
//    LOGPALETTE **  - [out] where to put the palette
//
// Output:
//    BOOL           - TRUE means we processed it, false means nope.
//
// Notes:
//
BOOL COleControl::OnGetPalette
(
    HDC          hicTargetDevice,
    LOGPALETTE **ppColorSet
)
{
    return FALSE;
}


//=--------------------------------------------------------------------------=
// COleControl::GetRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns a rectnagle describing a given drawing aspect
//
// Parameters:
//    DWORD             - [in]  aspect
//    LPRECTL           - [out] region rectangle
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetRect
(
    DWORD    dvAspect,
    LPRECTL  prcRect
)
{
    RECTL rc;
    BOOL  f;

    // call the user routine and let them return the size
    //
    f = OnGetRect(dvAspect, &rc);
    if (!f) return DV_E_DVASPECT;

    // transform these dudes.
    //
    PixelToHiMetric((LPSIZEL)&rc, (LPSIZEL)prcRect);
    PixelToHiMetric((LPSIZEL)((LPBYTE)&rc + sizeof(SIZEL)), (LPSIZEL)((LPBYTE)prcRect + sizeof(SIZEL)));

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetViewStatus    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns information about the opactiy of the object and what drawing
// aspects are supported
//
// Parameters:
//    DWORD *            - [out] the status
//
/// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetViewStatus
(
    DWORD *pdwStatus
)
{
    // depending on the flag in the CONTROLOBJECTINFO structure, indicate our
    // transparency vs opacity.
    // OVERRIDE:  controls that wish to support multi-pass drawing should
    // override this routine and return, in addition to the flags indication
    // opacity, flags indicating what sort of drawing aspects they support.
    //
    *pdwStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitPoint    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates whether a point is within a given aspect of an object.
//
// Parameters:
//    DWORD                - [in]  aspect
//    LPCRECT              - [in]  Bounds rectangle
//    POINT                - [in]  hit location client coordinates
//    LONG                 - [in]  what the container considers close
//    DWORD *              - [out] info about the hit
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitPoint
(
    DWORD    dvAspect,
    LPCRECT  prcBounds,
    POINT    ptLocation,
    LONG     lCloseHint,
    DWORD   *pdwHitResult
)
{
    // OVERRIDE: override me if you want to provide additional [non-opaque]
    // functionality
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = PtInRect(prcBounds, ptLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates wheter any point in a rectangle is within a given drawing aspect
// of an object.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LPCRECT          - [in]  bounds
//    LPCRECT          - [in]  location
//    LONG             - [in]  what host considers close
//    DWORD *          - [out] hit result
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitRect
(
    DWORD     dvAspect,
    LPCRECT   prcBounds,
    LPCRECT   prcLocation,
    LONG      lCloseHint,
    DWORD    *pdwHitResult
)
{
    RECT rc;

    // OVERRIDE: override this for additional behaviour
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = IntersectRect(&rc, prcBounds, prcLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetNaturalExtent    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// supports two types of control sizing, content and integral.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LONG             - [in]  index
//    DVTARGETDEVICE * - [in]  target device information
//    HDC              - [in]  HIC
//    DVEXTENTINFO *   - [in]  sizing data
//    LPSIZEL          - [out] sizing data retunred by control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetNaturalExtent
(
    DWORD           dvAspect,
    LONG            lIndex,
    DVTARGETDEVICE *ptd,
    HDC             hicTargetDevice,
    DVEXTENTINFO   *pExtentInfo,
    LPSIZEL         pSizel
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnGetRect    [overridable
//=--------------------------------------------------------------------------=
// returns our rectangle
//
// Parameters:
//    DWORD              - [in]  aspect they want the rect for
//    RECTL *            - [out] the rectangle that matches this aspect
//
// Output:
//    BOOL               - false means we don't like the aspect
//
// Notes:
//
BOOL COleControl::OnGetRect
(
    DWORD   dvAspect,
    RECTL  *pRect
)
{
    // by default, we only support content drawing.
    //
    if (dvAspect != DVASPECT_CONTENT)
        return FALSE;

    // just give them our bounding rectangle
    //
    *((LPRECT)pRect) = m_rcLocation;
    return TRUE;
}

//=--------------------------------------------------------------------------=
// _CreateOleDC
//=--------------------------------------------------------------------------=
// creates an HDC given a DVTARGETDEVICE structure.
//
// Parameters:
//    DVTARGETDEVICE *              - [in] duh.
//
// Output:
//    HDC
//
// Notes:
//
HDC _CreateOleDC
(
    DVTARGETDEVICE *ptd
)
{
    LPDEVMODEW   pDevModeW;
    DEVMODEA     DevModeA, *pDevModeA;
    LPOLESTR     lpwszDriverName;
    LPOLESTR     lpwszDeviceName;
    LPOLESTR     lpwszPortName;
    HDC          hdc;

    // return screen DC for NULL target device
    //
    if (!ptd)
        return CreateDC("DISPLAY", NULL, NULL, NULL);

    if (ptd->tdExtDevmodeOffset == 0)
        pDevModeW = NULL;
    else
        pDevModeW = (LPDEVMODEW)((LPSTR)ptd + ptd->tdExtDevmodeOffset);

    lpwszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
    lpwszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
    lpwszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

    MAKE_ANSIPTR_FROMWIDE(pszDriverName, lpwszDriverName);
    MAKE_ANSIPTR_FROMWIDE(pszDeviceName, lpwszDeviceName);
    MAKE_ANSIPTR_FROMWIDE(pszPortName,   lpwszPortName);



    if (pDevModeW) {
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmDeviceName, -1, (LPSTR)DevModeA.dmDeviceName, CCHDEVICENAME, NULL, NULL);
	memcpy(&DevModeA.dmSpecVersion, &pDevModeW->dmSpecVersion,
		offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmFormName, -1, (LPSTR)DevModeA.dmFormName, CCHFORMNAME, NULL, NULL);
	memcpy(&DevModeA.dmLogPixels, &pDevModeW->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
        if (pDevModeW->dmDriverExtra) {
            pDevModeA = (DEVMODEA *)HeapAlloc(g_hHeap, 0, sizeof(DEVMODEA) + pDevModeW->dmDriverExtra);
            if (!pDevModeA) return NULL;
            memcpy(pDevModeA, &DevModeA, sizeof(DEVMODEA));
            memcpy(pDevModeA + 1, pDevModeW + 1, pDevModeW->dmDriverExtra);
        } else
            pDevModeA = &DevModeA;

	DevModeA.dmSize = sizeof(DEVMODEA);
    } else
        pDevModeA = NULL;

    hdc = CreateDC(pszDriverName, pszDeviceName, pszPortName, pDevModeA);
    if (pDevModeA != &DevModeA) HeapFree(g_hHeap, 0, pDevModeA);
    return hdc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\dwinvers.h ===
#define vszMakeDate	"April 10, 1996\0"
#define vszMakeVers	"Version 2810 - DEBUG - ntfs-f\0\0"
#define vszVersNum	"2810\0"
#define vszVersNumAll	"5.00.2810\0"
#define vusVersNuml2	10
#define vusVersNumf2	28
#define vszCopyright	"Copyright  1987-1996 Microsoft Corp.\0\0"
#define VBA_VERHI	0x50000
#define VBA_VERLO	0x183C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\globals.cpp ===
//=--------------------------------------------------------------------------=
// Globals.C
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains global variables and strings and the like that just don't fit
// anywhere else.
//
#include "IPServer.H"

//=--------------------------------------------------------------------------=
// support for licensing
//
BOOL g_fMachineHasLicense;
BOOL g_fCheckedForLicense;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
BOOL g_fServerHasTypeLibrary = TRUE;

//=--------------------------------------------------------------------------=
// our instance handles
//
HINSTANCE    g_hInstance;
HINSTANCE    g_hInstResources;
VARIANT_BOOL g_fHaveLocale;

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
CRITICAL_SECTION    g_CriticalSection;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
BOOL    g_fSysWin95;                    // we're under Win95 system, not just NT SUR
BOOL    g_fSysWinNT;                    // we're under some form of Windows NT
BOOL    g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\debug.cpp ===
//=--------------------------------------------------------------------------=
// Debug.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains various methods that will only really see any use in DEBUG builds
//


#include "IPServer.H"
#include <stdlib.h>

#ifdef DEBUG

//=--------------------------------------------------------------------------=
// Private Constants
//---------------------------------------------------------------------------=
//
static const char szFormat[]  = "%s\nFile %s, Line %d";
static const char szFormat2[] = "%s\n%s\nFile %s, Line %d";

#define _SERVERNAME_ "ActiveX Framework"

static const char szTitle[]  = _SERVERNAME_ " Assertion  (Abort = UAE, Retry = INT 3, Ignore = Continue)";


//=--------------------------------------------------------------------------=
// Local functions
//=--------------------------------------------------------------------------=
int NEAR _IdMsgBox(LPSTR pszText, LPCSTR pszTitle, UINT mbFlags);

//=--------------------------------------------------------------------------=
// DisplayAssert
//=--------------------------------------------------------------------------=
// Display an assert message box with the given pszMsg, pszAssert, source
// file name, and line number. The resulting message box has Abort, Retry,
// Ignore buttons with Abort as the default.  Abort does a FatalAppExit;
// Retry does an int 3 then returns; Ignore just returns.
//
VOID DisplayAssert
(
    LPSTR	 pszMsg,
    LPSTR	 pszAssert,
    LPSTR	 pszFile,
    UINT	 line
)
{
    char	szMsg[250];
    LPSTR	lpszText;

    lpszText = pszMsg;		// Assume no file & line # info

    // If C file assert, where you've got a file name and a line #
    //
    if (pszFile) {

        // Then format the assert nicely
        //
        wsprintf(szMsg, szFormat, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, pszFile, line);
        lpszText = szMsg;
    }

    // Put up a dialog box
    //
    switch (_IdMsgBox(lpszText, szTitle, MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SYSTEMMODAL)) {
        case IDABORT:
            FatalAppExit(0, lpszText);
            return;

        case IDRETRY:
            // call the win32 api to break us.
            //
            DebugBreak();
            return;
    }

    return;
}


//=---------------------------------------------------------------------------=
// Beefed-up version of WinMessageBox.
//=---------------------------------------------------------------------------=
//
int NEAR _IdMsgBox
(
    LPSTR	pszText,
    LPCSTR	pszTitle,
    UINT	mbFlags
)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);

    return id;
}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\ctlwrap.cpp ===
//=--------------------------------------------------------------------------=
// CtlWrap.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// wrappers for various routines that have slightly different implementations
// for windowed and windowless controls.
//
#include "IPServer.H"

#include "CtrlObj.H"


// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// COleControl::OcxGetFocus    [wrapper]
//=--------------------------------------------------------------------------=
// indicates whether or not we have the focus.
//
// Parameters:
//    none
//
// Output:
//    TRUE if we have focus, else false
//
// Notes:
//
BOOL COleControl::OcxGetFocus
(
    void
)
{
    // if we're windowless, the site provides this functionality
    //
    if (m_pInPlaceSiteWndless) {
        return (m_pInPlaceSiteWndless->GetFocus() == S_OK);
    } else {

        // we've got a window.  just let the APIs do our work
        //
        if (m_fInPlaceActive)
            return (GetFocus() == m_hwnd);
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetWindowRect    [wrapper]
//=--------------------------------------------------------------------------=
// returns the current rectangle for this control, and correctly handles
// windowless vs windowed.
//
// Parameters:
//    LPRECT                - [out]  duh.
//
// Output:
//    BOOL                  - false means unexpected.
//
// Notes:
//
BOOL COleControl::OcxGetWindowRect
(
    LPRECT prc
)
{
    // if we're windowless, then we have this information already!
    //
    if (Windowless()) {
        *prc = m_rcLocation;
        return TRUE;
    } else
        return GetWindowRect(m_hwnd, prc);

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxDefWindowProc    [wrapper]
//=--------------------------------------------------------------------------=
// default window processing
//
// Parameters:
//    UINT           - [in] duh.
//    WPARAM         - [in] duh.
//    LPARAM         - [in] DUH.
//
// Output:
//    LRESULT
//
// Notes:
//
LRESULT COleControl::OcxDefWindowProc
(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    LRESULT l;

    // if we're windowless, this is a site provided pointer
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->OnDefWindowMessage(msg, wParam, lParam, &l);
    else
        // we've got a window -- just pass it along
        //
        l = DefWindowProc(m_hwnd, msg, wParam, lParam);

    return l;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetDC    [wrapper]
//=--------------------------------------------------------------------------=
// wraps the functionality of GetDC, and correctly handles windowless controls
//
// Parameters:
//    none
//
// Output:
//    HDC            - null means we couldn't get one
//
// Notes:
//    - we don't bother with a bunch of the IOleInPlaceSiteWindowless::GetDc
//      parameters, since the windows GetDC doesn't expose these either. users
//      wanting that sort of fine tuned control can call said routine
//      explicitly
//
HDC COleControl::OcxGetDC
(
    void
)
{
    HDC hdc = NULL;

    // if we're windowless, the site provides this functionality.
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->GetDC(NULL, 0, &hdc);
    else
        hdc = GetDC(m_hwnd);

    return hdc;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxReleaseDC    [wrapper]
//=--------------------------------------------------------------------------=
// releases a DC returned by OcxGetDC
//
// Parameters:
//    HDC             - [in] release me
//
// Output:
//    none
//
// Notes:
//
void COleControl::OcxReleaseDC
(
    HDC hdc
)
{
    // if we're windowless, the site does this for us
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->ReleaseDC(hdc);
    else
        ReleaseDC(m_hwnd, hdc);
}

//=--------------------------------------------------------------------------=
// COleControl::OcxSetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// provides a means for the control to get or release capture.
//
// Parameters:
//    BOOL            - [in] true means take, false release
//
// Output:
//    BOOL            - true means it's yours, false nuh-uh
//
// Notes:
//
BOOL COleControl::OcxSetCapture
(
    BOOL fGrab
)
{
    HRESULT hr;

    // the host does this for us if we're windowless [i'm getting really bored
    // of typing that]
    //
    if (m_pInPlaceSiteWndless) {
        hr = m_pInPlaceSiteWndless->SetCapture(fGrab);
        return (hr == S_OK);
    } else {
        // people shouldn't call this when they're not in-place active, but
        // just in case...
        //
        if (m_fInPlaceActive) {
            SetCapture(m_hwnd);
            return TRUE;
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// tells you whether or not you have the capture.
//
// Parameters:
//    none
//
// Output:
//    BOOL         - true it's yours, false it's not
//
// Notes:
//
BOOL COleControl::OcxGetCapture
(
    void
)
{
    // host does this for windowless dudes
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->GetCapture() == S_OK;
    else {
        // people shouldn't call this when they're not in-place active, but
        // just in case.
        //
        if (m_fInPlaceActive)
            return GetCapture() == m_hwnd;
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxInvalidateRect    [wrapper]
//=--------------------------------------------------------------------------=
// invalidates the control's rectangle
//
// Parameters:
//    LPCRECT            - [in] rectangle to invalidate
//    BOOL               - [in] do we erase background first?
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxInvalidateRect
(
    LPCRECT prcInvalidate,
    BOOL    fErase
)
{
    // if we're windowless, then we need to get the site to do all this for
    // us
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->InvalidateRect(prcInvalidate, fErase) == S_OK;
    else {
        // otherwise do something different depending on whether or not we're
        // in place active or not
        //
        if (m_fInPlaceActive)
            return InvalidateRect(m_hwnd, prcInvalidate, TRUE);
        else
            ViewChanged();
    }

    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxScrollRect    [wrapper]
//=--------------------------------------------------------------------------=
// does some window scrolling for the control
//
// Parameters:
//    LPCRECT             - [in] region to scroll
//    LPCRECT             - [in] region to clip
//    int                 - [in] dx to scroll
//    int                 - [in] dy to scroll
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxScrollRect
(
    LPCRECT  prcBounds,
    LPCRECT  prcClip,
    int      dx,
    int      dy
)
{
    // if we're windowless, the site provides this functionality, otherwise
    // APIs do the job
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->ScrollRect(dx, dy, prcBounds, prcClip) == S_OK;
    else {
        if (m_fInPlaceActive) 
            ScrollWindowEx(m_hwnd, dx, dy, prcBounds, prcClip, NULL, NULL, SW_INVALIDATE);
        else
            return FALSE;
    }

    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\extobj.cpp ===
////
//
// CExpandoObject
//
// Notes:
// 1) If the LCID passed to this object changes from call to call we are in trouble. This is hard to
// create an ASSERT for because it would require memoizing the LCID at some point.
// 2) There is a maximum on the number of slots allowed (this is currently 2048)
// 3) This is not a thread safe structure.
// 4) I'm currently using malloc -- this is probably wrong for IE.
//

// for ASSERT and FAIL
//

#include "IPServer.H"
#include "LocalSrv.H"
#include "Globals.H"
#include "extobj.h"
#include "Util.H"
#define GTR_MALLOC(size)  CoTaskMemAlloc(size)
#define GTR_FREE(pv) CoTaskMemFree(pv)

SZTHISFILE
////
//
// Private Utility Functions
//
////

////
//
// Get the ID of a Name
//

HRESULT CExpandoObject::GetIDOfName(LPOLESTR name, LCID lcid, BOOL caseSensitive, DISPID* id)
{
	HRESULT hr = NOERROR;
	ULONG hash = LHashValOfName(lcid, name);
	UINT hashIndex = hash % kSlotHashTableSize;
	CExpandoObjectSlot* slot;

	for (slot=GetHashTableHead(hashIndex); slot!=NULL; slot=slot->Next(m_slots))
	{
		if (slot->CompareName(name, hash, caseSensitive))
		{
			*id = slot->DispId();
			goto Exit;
		}
	}

	// not found
	hr = DISP_E_UNKNOWNNAME;
	*id = DISPID_UNKNOWN;

Exit:
	return hr;
}

////
//
// Add a new slot to the object
//

HRESULT CExpandoObject::AddSlot(LPOLESTR name, LCID lcid, BOOL caseSensitive, VARIANT* initialValue, DISPID* id)
{
	HRESULT hr = NOERROR;
	ULONG hash = LHashValOfName(lcid, name);
	UINT hashIndex = hash % kSlotHashTableSize;
	CExpandoObjectSlot* slot;
	DISPID	dispId;

	// first check if the slot exists
	for (slot=GetHashTableHead(hashIndex); slot!=NULL; slot=slot->Next(m_slots))
	{
		// bail if the name matches
		if (slot->CompareName(name, hash, caseSensitive))
		{
			hr = E_INVALIDARG;
			goto Exit;
		}
	}

	// allocate a slot
	dispId = (DISPID) m_totalSlots;
	slot = AllocSlot();
	if (slot == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Initialize it
	// BUGBUG robwell 8May96 If this fails and the initialValue is not VT_EMTPY or VT_NULL
	// there in no cleanup code.
	hr = slot->Init(name, lcid, dispId + m_dispIdBase, initialValue);
	if (FAILED(hr))
	{
		// free the slot and dispId
		m_totalSlots -= 1;
		goto Exit;
	}

	// intern the slot into the proper hash table
	slot->Insert(m_slots, m_hashTable[hashIndex]);

	// set the DISPID return value
	*id = slot->DispId();

Exit:
	return hr;
}

////
//
// Slot allocation
//
// Because slots are never freed there is no free method
//

CExpandoObjectSlot* CExpandoObject::AllocSlot()
{
	// limit on the number of slots
	if (m_totalSlots >= kMaxTotalSlots)
		return NULL;

	// do we need to realloc the array?
	if (m_totalSlots == m_slotTableSize)
	{
		UINT i;
		UINT newSize;
		CExpandoObjectSlot* newSlots;

		// allocate twice as many slots unless first time around
		if (m_slotTableSize == 0)
			newSize = kInitialSlotTableSize;
		else
			newSize = m_slotTableSize * 2;

		// allocate the space for the slots
		newSlots = (CExpandoObjectSlot*) GTR_MALLOC(sizeof(CExpandoObjectSlot)*newSize);
		if (newSlots == NULL)
			return NULL;

		// copy the old values if the old m_slots is not NULL
		if (m_slots)
		{
			// copy the slots
			memcpy(newSlots, m_slots, sizeof(CExpandoObjectSlot)*m_totalSlots);
			// free the old values
			GTR_FREE(m_slots);
		}

		// construct all of the unused slots
		for (i=m_totalSlots; i<newSize; ++i)
			newSlots[i].Construct();

		// make the new array the new table and fix the total size
		m_slots = newSlots;
		m_slotTableSize = newSize;
	}

	// return a pointer to the slot and bump the totalSlots count
	return &m_slots[m_totalSlots++];
}

////
//
// Free all of the slots
//

void CExpandoObject::FreeAllSlots()
{
	UINT i;
	UINT initedSlotCount;
	CExpandoObjectSlot* slots;

	// first clear the hash table
	ClearHashTable();

	// detach the slots
	slots = m_slots;
	initedSlotCount = m_totalSlots;

	// clear the object info
	m_totalSlots = 0;
	m_slotTableSize = 0;
	m_slots = NULL;

	// only need to destruct those slots in use
	for (i=0; i<initedSlotCount; ++i)
		slots[i].Destruct();

	// free the storage
	if (slots)
		GTR_FREE(slots);
}



////
//
// IDispatch Methods
//
////

HRESULT CExpandoObject::GetTypeInfoCount(UINT *pctinfo)
{
	*pctinfo = 0;
	return NOERROR;
}

HRESULT CExpandoObject::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
	*pptinfo = NULL;
	return E_NOTIMPL;
}

HRESULT CExpandoObject::GetIDsOfNames(
	REFIID riid,
	LPOLESTR *prgpsz,
	UINT cpsz,
	LCID lcid,
	DISPID *prgdispid
)
{
	HRESULT hr;

	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	// First see if the outer object knows about the name
	if (m_pdisp)
	{
		hr = m_pdisp->GetIDsOfNames(
			riid,
			prgpsz,
			cpsz,
			lcid,
			prgdispid);

		// if so, just return
		if (SUCCEEDED(hr))
			return hr;
	}

	// Otherwise look on our expanded properties

	if (cpsz == 0)
		return NOERROR;

	// get the ids for the name
	hr = GetIDOfName(prgpsz[0], lcid, FALSE, &prgdispid[0]);

	// clear the rest of the array
	for (unsigned int i = 1; i < cpsz; i++)
	{
		if (SUCCEEDED(hr))
			hr = DISP_E_UNKNOWNNAME;
		prgdispid[i] = DISPID_UNKNOWN;
	}

	return hr;
}

HRESULT CExpandoObject::Invoke(
	DISPID dispID,
	REFIID riid,
	LCID lcid,
	WORD wFlags,
	DISPPARAMS *pdispparams,
	VARIANT *pvarRes,
	EXCEPINFO *pexcepinfo,
	UINT *puArgErr
)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr;

	// First try the outer object's invoke
	if (m_pdisp)
	{
		hr = m_pdisp->Invoke(
				dispID,
				riid,
				lcid,
				wFlags,
				pdispparams,
				pvarRes,
				pexcepinfo,
				puArgErr
		);

		// If that succeeded, we're done
		if (SUCCEEDED(hr))
			return hr;
	}
	
	// Otherwise, try the expando object's invoke	
	if (NULL != puArgErr)
		*puArgErr = 0;

	if (wFlags & DISPATCH_PROPERTYGET)
	{
		if (NULL == pvarRes)
			return NOERROR;

		if (NULL != pdispparams && 0 != pdispparams->cArgs)
			return E_INVALIDARG;

		// clear the result slot
		pvarRes->vt = VT_EMPTY;
		return GetSlot(dispID, pvarRes);
	}

	if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
	{
		if (NULL == pdispparams
		|| 1 != pdispparams->cArgs
		|| 1 != pdispparams->cNamedArgs
		|| DISPID_PROPERTYPUT != pdispparams->rgdispidNamedArgs[0]
		)
			return DISP_E_PARAMNOTOPTIONAL;

		return SetSlot(dispID, &pdispparams->rgvarg[0]);
	}

	return DISP_E_MEMBERNOTFOUND;
}

////
//
// IDispatchEx methods
//
////

// Get dispID for names, with options
HRESULT STDMETHODCALLTYPE CExpandoObject::GetIDsOfNamesEx(
	REFIID riid,
	LPOLESTR *prgpsz,
	UINT cpsz,
	LCID lcid,
	DISPID *prgid,
	DWORD grfdex
)
{
	HRESULT hr;
	BOOL caseSensitive = ((grfdex & fdexCaseSensitive) != 0);


	// First see if the outer object knows about the name
	if (m_pdisp)
	{
		hr = m_pdisp->GetIDsOfNames(
			riid,
			prgpsz,
			cpsz,
			lcid,
			prgid);

		// if so, just return
		if (SUCCEEDED(hr))
			return hr;
	}


	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	if (cpsz == 0)
		return NOERROR;

	// check the array arguments
	if (prgpsz == NULL || prgid == NULL)
		return E_INVALIDARG;

	// get the id from the name
	hr = GetIDOfName(prgpsz[0], lcid, caseSensitive, &prgid[0]);

	// create the slot?
	if (hr == DISP_E_UNKNOWNNAME && (grfdex & fdexDontCreate) == 0)
	{
		VARIANT initialValue;

		if (grfdex & fdexInitNull)
			initialValue.vt = VT_NULL;
		else
			initialValue.vt = VT_EMPTY;

		hr = AddSlot(prgpsz[0], lcid, caseSensitive, &initialValue, &prgid[0]);
	}

	// clear the rest of the array
	for (unsigned int i = 1; i < cpsz; i++)
	{
		hr = DISP_E_UNKNOWNNAME;
		prgid[i] = DISPID_UNKNOWN;
	}

	return hr;
}

// Enumerate dispIDs and their associated "names".
// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
// error code if the call fails.
HRESULT STDMETHODCALLTYPE CExpandoObject::GetNextDispID(
	DISPID id,
	DISPID *pid,
	BSTR *pbstrName
)
{
	HRESULT hr;
	CExpandoObjectSlot* slot;

	// check the outgoing parameters
	if (pid == NULL || pbstrName == NULL)
		return E_INVALIDARG;

	// set to the default failure case
	*pid = DISPID_UNKNOWN;
	*pbstrName = NULL;

	// get the next slot
	hr = Next(id, slot);
	if (hr == NOERROR)
	{
		BSTR name;

		// allocate the result string
		name = SysAllocString(slot->Name());
		if (name == NULL)
			return E_OUTOFMEMORY;

		// fill in the outgoing parameters
		*pid = slot->DispId();
		*pbstrName = name;
	}

	return hr;
}

// Copy all of the expando-object properties from obj
HRESULT
CExpandoObject::CloneProperties(CExpandoObject& obj)
{
    // BUGBUG  PhilBo
    // The initialization code below is copied from the default constructor.
    // This should be factored out into a shared method.

	// Copy each of the properties from the original object
    HRESULT hr = S_OK;
    DISPID dispid = 0;
    BSTR bstrName = NULL;

    while (obj.GetNextDispID(dispid, &dispid, &bstrName) == S_OK)
    {
        // Get the value of the property from the original object
        VARIANT varResult;
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        VariantInit(&varResult);

        hr = obj.Invoke(
		        dispid,
		        IID_NULL,
		        LOCALE_SYSTEM_DEFAULT,
		        DISPATCH_PROPERTYGET,
		        &dispparamsNoArgs, &varResult, NULL, NULL);

        ASSERT(SUCCEEDED(hr), "");
        if (FAILED(hr))
            continue;

        // Set the property on the new object
        DISPID dispidNew = 0;
	    hr = GetIDsOfNamesEx(IID_NULL, &bstrName, 1, LOCALE_SYSTEM_DEFAULT,
		    &dispidNew, 0);

        ASSERT(SUCCEEDED(hr), "");
        if (FAILED(hr))
            continue;

        DISPPARAMS dispparams;
        dispparams.rgvarg = &varResult;

        DISPID rgdispid[] = {DISPID_PROPERTYPUT};
        dispparams.rgdispidNamedArgs = rgdispid;
        dispparams.cArgs = 1;
        dispparams.cNamedArgs = 1;

        hr = Invoke(
		    dispidNew,
		    IID_NULL,
		    LOCALE_SYSTEM_DEFAULT,
		    DISPATCH_PROPERTYPUT,
		    &dispparams, NULL, NULL, NULL);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\ipserver.cpp ===
//=--------------------------------------------------------------------------=
// IPServer.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implements all exported DLL functions for the program, as well as a few
// others that will be used by same
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "ClassF.H"
#include "CtrlObj.H"
#include "Globals.H"
#include "Unknown.H"
#include "Util.H"

//=--------------------------------------------------------------------------=
// Private module level data
//
// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// These are used for reflection in OLE Controls.  Not that big of a hit that
// we mind defining them for all servers, including automation or generic
// COM.
//
char g_szReflectClassName [] = "CtlFrameWork_ReflectWindow";
BYTE g_fRegisteredReflect = FALSE;


//=--------------------------------------------------------------------------=
// allow controls to register for DLL_THREAD_ATTACH and DLL_THREAD_DETACH 
//
THRDNFYPROC g_pfnThreadProc = NULL;

extern "C" void SetLibraryThreadProc(THRDNFYPROC pfnThreadNotify)
{
    if ((g_pfnThreadProc = pfnThreadNotify) == NULL)
        DisableThreadLibraryCalls((HMODULE)g_hInstance);
}


// ref count for LockServer
//
LONG  g_cLocks;


// private routines for this file.
//
int       IndexOfOleObject(REFCLSID);
HRESULT   RegisterAllObjects(void);
HRESULT   UnregisterAllObjects(void);

//=--------------------------------------------------------------------------=
// DllMain
//=--------------------------------------------------------------------------=
// yon standard LibMain.
//
// Parameters and Output:
//    - see SDK Docs on DllMain
//
// Notes:
//
BOOL WINAPI DllMain
(
    HANDLE hInstance,
    DWORD  dwReason,
    void  *pvReserved
)
{
    int i;

    switch (dwReason) {
      // set up some global variables, and get some OS/Version information
      // set up.
      //
      case DLL_PROCESS_ATTACH:
        {
        DWORD dwVer = GetVersion();
        DWORD dwWinVer;

        //  swap the two lowest bytes of dwVer so that the major and minor version
        //  numbers are in a usable order.
        //  for dwWinVer: high byte = major version, low byte = minor version
        //     OS               Sys_WinVersion  (as of 5/2/95)
        //     =-------------=  =-------------=
        //     Win95            0x035F   (3.95)
        //     WinNT ProgMan    0x0333   (3.51)
        //     WinNT Win95 UI   0x0400   (4.00)
        //
        dwWinVer = (UINT)(((dwVer & 0xFF) << 8) | ((dwVer >> 8) & 0xFF));
        g_fSysWinNT = FALSE;
        g_fSysWin95 = FALSE;
        g_fSysWin95Shell = FALSE;

        if (dwVer < 0x80000000) {
            g_fSysWinNT = TRUE;
            g_fSysWin95Shell = (dwWinVer >= 0x0334);
        } else  {
            g_fSysWin95 = TRUE;
            g_fSysWin95Shell = TRUE;
        }

        // initialize a critical seciton for our apartment threading support
        //
        InitializeCriticalSection(&g_CriticalSection);

        // create an initial heap for everybody to use.
        // currently, we're going to let the system make things thread-safe,
        // which will make them a little slower, but hopefully not enough
        // to notice
        //
        g_hHeap = GetProcessHeap();
        if (!g_hHeap) {
            FAIL("Couldn't get Process Heap.  Not good!");
            return FALSE;
        }

        g_hInstance = (HINSTANCE)hInstance;

        // give the user a chance to initialize whatever
        //
        InitializeLibrary();

        // if they didn't ask for thread notifications then optimize by turning
        // them off for our DLL.
        //
        if (!g_pfnThreadProc)
            DisableThreadLibraryCalls((HMODULE)hInstance);
        }
        break;

      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
        if (g_pfnThreadProc)
            g_pfnThreadProc(hInstance, dwReason, pvReserved);
        break;

      // do  a little cleaning up!
      //
      case DLL_PROCESS_DETACH:

        // clean up our critical seciton
        //
        DeleteCriticalSection(&g_CriticalSection);

        // unregister all the registered window classes.
        //
        i = 0;

        while (!ISEMPTYOBJECT(i)) {
            if (g_ObjectInfo[i].usType == OI_CONTROL) {
                if (CTLWNDCLASSREGISTERED(i))
                    UnregisterClass(WNDCLASSNAMEOFCONTROL(i), g_hInstance);
            }
            i++;
        }

        // clean up our parking window.
        //
        if (g_hwndParking) {
            DestroyWindow(g_hwndParking);
            UnregisterClass("CtlFrameWork_Parking", g_hInstance);
            --g_cLocks;
        }

        // clean up after reflection, if appropriate.
        //
        if (g_fRegisteredReflect)
            UnregisterClass(g_szReflectClassName, g_hInstance);

        // give the user a chance to do some cleaning up
        //
        UninitializeLibrary();
        break;
    }

    return TRUE;
}



//=--------------------------------------------------------------------------=
// DllRegisterServer
//=--------------------------------------------------------------------------=
// registers the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllRegisterServer
(
    void
)
{
    HRESULT hr;

    hr = RegisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user registration function.
    //
    return (RegisterData())? S_OK : E_FAIL;
}



//=--------------------------------------------------------------------------=
// DllUnregisterServer
//=--------------------------------------------------------------------------=
// unregister's the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllUnregisterServer
(
    void
)
{
    HRESULT hr;

    hr = UnregisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user unregistration function
    //
    return (UnregisterData()) ? S_OK : E_FAIL;
}


//=--------------------------------------------------------------------------=
// DllCanUnloadNow
//=--------------------------------------------------------------------------=
// we are being asked whether or not it's okay to unload the DLL.  just check
// the lock counts on remaining objects ...
//
// Output:
//    HRESULT        - S_OK, can unload now, S_FALSE, can't.
//
// Notes:
//
STDAPI DllCanUnloadNow
(
    void
)
{
    // if there are any objects lying around, then we can't unload.  The
    // controlling CUnknownObject class that people should be inheriting from
    // takes care of this
    //
    return (g_cLocks) ? S_FALSE : S_OK;
}


//=--------------------------------------------------------------------------=
// DllGetClassObject
//=--------------------------------------------------------------------------=
// creates a ClassFactory object, and returns it.
//
// Parameters:
//    REFCLSID        - CLSID for the class object
//    REFIID          - interface we want class object to be.
//    void **         - pointer to where we should ptr to new object.
//
// Output:
//    HRESULT         - S_OK, CLASS_E_CLASSNOTAVAILABLE, E_OUTOFMEMORY,
//                      E_INVALIDARG, E_UNEXPECTED
//
// Notes:
//
STDAPI DllGetClassObject
(
    REFCLSID rclsid,
    REFIID   riid,
    void   **ppvObjOut
)
{
    HRESULT hr;
    void   *pv;
    int     iIndex;

    // arg checking
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // first of all, make sure they're asking for something we work with.
    //
    iIndex = IndexOfOleObject(rclsid);
    if (iIndex == -1)
        return CLASS_E_CLASSNOTAVAILABLE;

    // create the blank object.
    //
    pv = (void *)new CClassFactory(iIndex);
    if (!pv)
        return E_OUTOFMEMORY;

    // QI for whatever the user has asked for.
    //
    hr = ((IUnknown *)pv)->QueryInterface(riid, ppvObjOut);
    ((IUnknown *)pv)->Release();

    return hr;
}
//=--------------------------------------------------------------------------=
// IndexOfOleObject
//=--------------------------------------------------------------------------=
// returns the index in our global table of objects of the given CLSID.  if
// it's not a supported object, then we return -1
//
// Parameters:
//    REFCLSID     - [in] duh.
//
// Output:
//    int          - >= 0 is index into global table, -1 means not supported
//
// Notes:
//
int IndexOfOleObject
(
    REFCLSID rclsid
)
{
    int x = 0;

    // an object is creatable if it's CLSID is in the table of all allowable object
    // types.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (OBJECTISCREATABLE(x)) {
            if (rclsid == CLSIDOFOBJECT(x))
                return x;
        }
        x++;
    }

    return -1;
}

//=--------------------------------------------------------------------------=
// RegisterAllObjects
//=--------------------------------------------------------------------------=
// registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HERSULT        - S_OK, E_FAIL
//
// Notes:
//
HRESULT RegisterAllObjects
(
    void
)
{
    ITypeLib *pTypeLib;
    HRESULT hr;
    DWORD   dwPathLen;
    char    szTmp[MAX_PATH];
    int     x = 0;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        // depending on the object type, register different pieces of information
        //
        switch (g_ObjectInfo[x].usType) {

          // for both simple co-creatable objects and proeprty pages, do the same
          // thing
          //
          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            RegisterUnknownObject(NAMEOFOBJECT(x), CLSIDOFOBJECT(x));
            break;

          case OI_AUTOMATION:
            RegisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                     *g_pLibid, CLSIDOFOBJECT(x));
            break;

          case OI_CONTROL:
            RegisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x),
                                  *g_pLibid, CLSIDOFOBJECT(x), OLEMISCFLAGSOFCONTROL(x),
                                  BITMAPIDOFCONTROL(x));
            break;

        }
        x++;
    }

    // Load and register our type library.
    //
    if (g_fServerHasTypeLibrary) {
        dwPathLen = GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
        MAKE_WIDEPTR_FROMANSI(pwsz, szTmp);
        hr = LoadTypeLib(pwsz, &pTypeLib);
        RETURN_ON_FAILURE(hr);
        hr = RegisterTypeLib(pTypeLib, pwsz, NULL);
        pTypeLib->Release();
        RETURN_ON_FAILURE(hr);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// UnregisterAllObjects
//=--------------------------------------------------------------------------=
// un-registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
HRESULT UnregisterAllObjects
(
    void
)
{
    int x = 0;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        switch (g_ObjectInfo[x].usType) {

          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            UnregisterUnknownObject(CLSIDOFOBJECT(x));
            break;

          case OI_CONTROL:
            UnregisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                    CLSIDOFOBJECT(x));
    
          case OI_AUTOMATION:
            UnregisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                       CLSIDOFOBJECT(x));
            break;

        }
        x++;
    }

    // if we've got one, unregister our type library [this isn't an API function
    // -- we've implemented this ourselves]
    //
    if (g_pLibid)
        UnregisterTypeLibrary(*g_pLibid);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\internet.cpp ===
//=--------------------------------------------------------------------------=
// Internet.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains internet helper classes CDownloadSink and CInternetControl
//
#include "IPServer.H"
#include "Internet.H"
#include "Util.H"

// ZZ BUGBUG: BUILD-ISSUE: added following #define.
#include "idispids.h"

static VARTYPE rgI4[] = { VT_I4 };

typedef enum {
    InternetEvent_Progress = 0,
    InternetEvent_ReadyStateChange = 1
} INTERNETEVENTS;

static EVENTINFO rgEvents [] = {
    { DISPID_PROGRESS, 1, rgI4 },           // (long percentDone)
    { DISPID_READYSTATECHANGE, 1, rgI4 },       // (OLE_READYSTATE newState)
};


// local class for doing async monitoring. It's not really all that
// general purpose, but it does the job...


class CDownloadSink : public IBindStatusCallback
{
public:
    CDownloadSink(IUnknown *punkOuter,CInternetControl *,DISPID );
    ~CDownloadSink();

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

        STDMETHOD(OnStartBinding)(
            /* [in] */ DWORD grfBSCOption,
            /* [in] */ IBinding *pib);

        STDMETHOD(GetPriority)(
            /* [out] */ LONG *pnPriority);

        STDMETHOD(OnLowResource)(
            /* [in] */ DWORD reserved);

        STDMETHOD(OnProgress)(
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);

        STDMETHOD(OnStopBinding)(
            /* [in] */ HRESULT hresult,
            /* [in] */ LPCWSTR szError);

        STDMETHOD(GetBindInfo)(
            /* [out] */ DWORD *grfBINDINFOF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);

        STDMETHOD(OnDataAvailable)(
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);

        STDMETHOD(OnObjectAvailable)(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);



        CDownloadSink * Next()                  { return(m_next); }
        void            Next(CDownloadSink *n)  { m_next = n; }

        DISPID          DispId()  { return(m_propId); }
        IBinding *      Binding() { return(m_binding); }

private:

        CDownloadSink *         m_next;
        CInternetControl *      m_control;
        DISPID                  m_propId;
        IBinding *              m_binding;
        DWORD                   m_ref;
                IStream *                               m_stream;

};


CDownloadSink::CDownloadSink
(
        IUnknown *              punkOuter,
        CInternetControl *      control,
        DISPID                  propId
)
{
//      CHECK_POINTER(control);

        m_control = control;
        m_control->AddRef();

        m_propId  = propId;
        m_next    = 0;
        m_binding = 0;
        m_ref     = 0;
        m_stream  = 0;
}

CDownloadSink::~CDownloadSink()
{
        if( m_control )
                m_control->Release();
        if( m_binding )
                m_binding->Release();
        if( m_stream )
                m_stream->Release();
}

STDMETHODIMP
CDownloadSink::QueryInterface(const GUID &iid,void **ppv )
{
        if( IsEqualGUID(iid,IID_IUnknown) || IsEqualGUID(iid,IID_IBindStatusCallback) )
        {
                *ppv = this;
                AddRef();
                return(NOERROR);
        }
        return( E_NOINTERFACE );
}

STDMETHODIMP_(ULONG)
CDownloadSink::AddRef()
{
        return(++m_ref);
}

STDMETHODIMP_(ULONG)
CDownloadSink::Release()
{
        if(!--m_ref)
        {
                delete this;
                return(0);
        }
        return( m_ref );
}


STDMETHODIMP
CDownloadSink::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo)
{
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_GETNEWESTVERSION;
        return(NOERROR);
}


STDMETHODIMP
CDownloadSink::OnStartBinding(DWORD /*grfBSCOption*/,IBinding *pib)
{
        // BUGBUG: should check to see options are what we think they are
        m_binding = pib;
        pib->AddRef();
        return(NOERROR);
}


STDMETHODIMP
CDownloadSink::GetPriority( LONG *pnPriority)
{
        return(E_NOTIMPL);
}

STDMETHODIMP
CDownloadSink::OnProgress
(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText
)
{
        return(m_control->OnProgress(m_propId,ulProgress,
                                                        ulProgressMax,ulStatusCode,pwzStatusText) );
}

STDMETHODIMP
CDownloadSink::OnDataAvailable
(
     DWORD                      grfBSCF,
     DWORD                      dwSize,
     FORMATETC *        pFmtetc,
         STGMEDIUM *    pstgmed
)
{
#ifdef DEBUG
        char msg[200];
        wsprintf(msg,"::OnDataAvailable(%0xd,%d,%s,%s)\n",grfBSCF,dwSize,
                pFmtetc ? "pFmtetc" : "NULL", pstgmed ? "pstgmed" : "NULL" );
        OutputDebugString(msg);
#endif

    if( !m_stream )
                m_stream = pstgmed->pstm;

        return(m_control->OnData(       m_propId,
                                                                grfBSCF,
                                                                m_stream,
                                                                dwSize ));
}

STDMETHODIMP
CDownloadSink::OnObjectAvailable
(
        REFIID riid,
    IUnknown *punk
)
{
        return(E_NOTIMPL);
}


STDMETHODIMP
CDownloadSink::OnLowResource( DWORD reserved)
{
        // BUGBUG: really should have this kind of harsh policy on this ...
        m_binding->Abort();
        return(S_OK);
}

STDMETHODIMP
CDownloadSink::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
        m_binding->Release();
        m_binding = 0;
        m_control->Release();
        m_control = 0;

        return(NOERROR);
}



//------------------------------------------------------
//
// class CInternetControl
//
//
CInternetControl::CInternetControl
(
        IUnknown *      pUnkOuter,
        int                     iPrimaryDispatch,
        void *          pMainInterface
)
        : COleControl(pUnkOuter,iPrimaryDispatch,pMainInterface)
{
        m_host = 0;
        m_readyState = READYSTATE_LOADING;
}

CInternetControl::~CInternetControl()
{
        if( m_host )
                m_host->Release();
}


HRESULT CInternetControl::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    *ppvObjOut = NULL;
     return COleControl::InternalQueryInterface(riid, ppvObjOut);
}



HRESULT
CInternetControl::GetBindHost()
{

        if( m_host )
                return(NOERROR);

    // Try service provider first...

        IServiceProvider * serviceProvider = 0;

        HRESULT hr = m_pClientSite->QueryInterface
                                                                        (
                                                                                IID_IServiceProvider,
                                                                                (void**)&serviceProvider
                                                                        );

        if( SUCCEEDED(hr) )
    {
                hr = serviceProvider->QueryService
                                    (
                                        SID_IBindHost,
                                        IID_IBindHost,
                                        (void**)&m_host
                                    );
                serviceProvider->Release();
    }

    if( FAILED(hr) )
    {
        // Some containers put IBindHost directly on the client site

        hr = m_pClientSite->QueryInterface
                                                                        (
                                        IID_IBindHost,
                                        (void**)&m_host
                                                                        );


    }

        return(hr);

}


HRESULT CInternetControl::GetAMoniker( LPOLESTR url, IMoniker ** ppmkr )
{
        HRESULT hr = GetBindHost();

        if( SUCCEEDED(hr) )
                hr = m_host->CreateMoniker(url,NULL, ppmkr,0);

        if( FAILED(hr) )
    {
           // FUTURE: This really should be a call to MkParseDisplayNameEx!!!
       hr = ::CreateURLMoniker(0,url,ppmkr);
       // hr = ::MkParseDisplayNameEx(0, url, 0, ppmkr);
    }

        return( hr );
}


HRESULT CInternetControl::SetupDownload( LPOLESTR url, DISPID propId )
{
        CHECK_POINTER(url);

        IMoniker * pmkr;

        HRESULT hr = GetAMoniker( url, &pmkr );

        IBindCtx * pBindCtx = 0;

        if( SUCCEEDED(hr) )
    {
        hr = ::CreateBindCtx(0,&pBindCtx);
    }

        CDownloadSink * sink = 0;

        if( SUCCEEDED(hr) )
        {
                sink = new CDownloadSink(0,this,propId);
                if( sink )
                        sink->AddRef();
        }

        if( SUCCEEDED(hr) && !sink )
                hr = E_OUTOFMEMORY;

        if( SUCCEEDED(hr) )
        {
                // BUGBUG: There should be a define for 0x77
                hr = ::RegisterBindStatusCallback(pBindCtx, sink,0, 0) ;
        }

        IStream * strm = 0;

        if( SUCCEEDED(hr) )
                hr = pmkr->BindToStorage( pBindCtx, 0, IID_IStream, (void**)&strm );

        if( strm )
                strm->Release();

        if( pBindCtx )
                pBindCtx->Release();

        if( FAILED(hr) && sink )
                sink->Release();

        return(hr);

}


HRESULT CInternetControl::OnData( DISPID, DWORD,IStream *, DWORD)
{
        return(NOERROR);
}

HRESULT CInternetControl::OnProgress( DISPID, ULONG progress, ULONG themax, ULONG, LPCWSTR)
{
        return(NOERROR);
}


HRESULT CInternetControl::FireReadyStateChange( long newState )
{
        FireEvent( &::rgEvents[InternetEvent_ReadyStateChange], m_readyState = newState );
        return(S_OK);
}

HRESULT CInternetControl::FireProgress( ULONG dwAmount )
{
        FireEvent( &::rgEvents[InternetEvent_Progress], dwAmount );
        return(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\proppage.cpp ===
//=--------------------------------------------------------------------------=
// PropPage.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of CPropertyPage object.
//
#include "IPServer.H"
#include "PropPage.H"
#include "Util.H"
#include "Globals.H"

// for ASSERT and FAIL
//
SZTHISFILE

// this variable is used to pass the pointer to the object to the hwnd.
//
static CPropertyPage *s_pLastPageCreated;

//=--------------------------------------------------------------------------=
// CPropertyPage::CPropertyPage
//=--------------------------------------------------------------------------=
// constructor.
//
// Parameters:
//    IUnknown *          - [in] controlling unknown
//    int                 - [in] object type.
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CPropertyPage::CPropertyPage
(
    IUnknown         *pUnkOuter,
    int               iObjectType
)
: CUnknownObject(pUnkOuter, this), m_ObjectType(iObjectType)
{
    // initialize various dudes.
    //
    m_pPropertyPageSite = NULL;
    m_hwnd = NULL;
    m_fDirty = FALSE;
    m_fActivated = FALSE;
    m_cObjects = 0;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CPropertyPage::~CPropertyPage
//=--------------------------------------------------------------------------=
// destructor.
//
// Notes:
//
CPropertyPage::~CPropertyPage()
{
    // clean up our window.
    //
    if (m_hwnd) {
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, -1);
        DestroyWindow(m_hwnd);
    }

    // release all the objects we're holding on to.
    //
    m_ReleaseAllObjects();

    // release the site
    //
    QUICK_RELEASE(m_pPropertyPageSite);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support IPP and IPP2.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CPropertyPage::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    IUnknown *pUnk;

    *ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(IID_IPropertyPage, riid)) {
        pUnk = (IUnknown *)this;
    } else if (DO_GUIDS_MATCH(IID_IPropertyPage2, riid)) {
        pUnk = (IUnknown *)this;
    } else {
        return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
    }

    pUnk->AddRef();
    *ppvObjOut = (void *)pUnk;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetPageSite    [IPropertyPage]
//=--------------------------------------------------------------------------=
// the initialization function for a property page through which the page
// receives an IPropertyPageSite pointer.
//
// Parameters:
//    IPropertyPageSite *        - [in] new site.
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP CPropertyPage::SetPageSite
(
    IPropertyPageSite *pPropertyPageSite
)
{
    RELEASE_OBJECT(m_pPropertyPageSite);
    m_pPropertyPageSite = pPropertyPageSite;
    ADDREF_OBJECT(pPropertyPageSite);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Activate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to create it's display window as a child of hwndparent
// and to position it according to prc.
//
// Parameters:
//    HWND                - [in]  parent window
//    LPCRECT             - [in]  where to position ourselves
//    BOOL                - [in]  whether we're modal or not.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Activate
(
    HWND    hwndParent,
    LPCRECT prcBounds,
    BOOL    fModal
)
{
    HRESULT hr;

    // first make sure the dialog window is loaded and created.
    //
    hr = m_EnsureLoaded();
    RETURN_ON_FAILURE(hr);

    // set our parent window if we haven't done so yet.
    //
    if (!m_fActivated) {
        SetParent(m_hwnd, hwndParent);
        m_fActivated = TRUE;
    }

    // now move ourselves to where we're told to be and show ourselves
    //
    Move(prcBounds);
    ShowWindow(m_hwnd, SW_SHOW);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Deactivate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to destroy the window created in activate
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Deactivate
(
    void
)
{
    // blow away yon window.
    //
    if (m_hwnd)
        DestroyWindow(m_hwnd);
    m_hwnd = NULL;
    m_fActivated = FALSE;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::GetPageInfo    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to fill a PROPPAGEINFO structure
//
// Parameters:
//    PROPPAGEINFO *    - [out] where to put info.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::GetPageInfo
(
    PROPPAGEINFO *pPropPageInfo
)
{
    RECT rect;

    CHECK_POINTER(pPropPageInfo);

    m_EnsureLoaded();

    // clear it out first.
    //
    memset(pPropPageInfo, 0, sizeof(PROPPAGEINFO));

    pPropPageInfo->pszTitle = OLESTRFROMRESID(TITLEIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszDocString = OLESTRFROMRESID(DOCSTRINGIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszHelpFile = OLESTRFROMANSI(HELPFILEOFPROPPAGE(m_ObjectType));
    pPropPageInfo->dwHelpContext = HELPCONTEXTOFPROPPAGE(m_ObjectType);

    if (!(pPropPageInfo->pszTitle && pPropPageInfo->pszDocString && pPropPageInfo->pszHelpFile))
        goto CleanUp;

    // if we've got a window yet, go and set up the size information they want.
    //
    if (m_hwnd) {
        GetWindowRect(m_hwnd, &rect);

        pPropPageInfo->size.cx = rect.right - rect.left;
        pPropPageInfo->size.cy = rect.bottom - rect.top;
    }

    return S_OK;

  CleanUp:
    if (pPropPageInfo->pszDocString) CoTaskMemFree(pPropPageInfo->pszDocString);
    if (pPropPageInfo->pszHelpFile) CoTaskMemFree(pPropPageInfo->pszHelpFile);
    if (pPropPageInfo->pszTitle) CoTaskMemFree(pPropPageInfo->pszTitle);

    return E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetObjects    [IPropertyPage]
//=--------------------------------------------------------------------------=
// provides the page with the objects being affected by the changes.
//
// Parameters:
//    ULONG            - [in] count of objects.
//    IUnknown **      - [in] objects.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::SetObjects
(
    ULONG      cObjects,
    IUnknown **ppUnkObjects
)
{
    HRESULT hr;
    ULONG   x;

    // free up all the old objects first.
    //
    m_ReleaseAllObjects();

    if (!cObjects)
        return S_OK;

    // now go and set up the new ones.
    //
    m_ppUnkObjects = (IUnknown **)HeapAlloc(g_hHeap, 0, cObjects * sizeof(IUnknown *));
    RETURN_ON_NULLALLOC(m_ppUnkObjects);

    // loop through and copy over all the objects.
    //
    for (x = 0; x < cObjects; x++) {
        m_ppUnkObjects[x] = ppUnkObjects[x];
        ADDREF_OBJECT(m_ppUnkObjects[x]);
    }

    // go and tell the object that there are new objects
    //
    hr = S_OK;
    m_cObjects = cObjects;
    // if we've got a window, go and notify it that we've got new objects.
    //
    if (m_hwnd)
        SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&hr);
    if (SUCCEEDED(hr)) m_fDirty = FALSE;

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Show    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to show or hide its window
//
// Parameters:
//    UINT             - [in] whether to show or hide
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Show
(
    UINT nCmdShow
)
{
    if (m_hwnd)
        ShowWindow(m_hwnd, nCmdShow);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Move    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to relocate and resize itself to a position other than what
// was specified through Activate
//
// Parameters:
//    LPCRECT        - [in] new position and size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Move
(
    LPCRECT prcBounds
)
{
    // do what they sez
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, NULL, prcBounds->left, prcBounds->top,
                     prcBounds->right - prcBounds->left,
                     prcBounds->bottom - prcBounds->top,
                     SWP_NOZORDER);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::IsPageDirty    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page whether it has changed its state
//
// Output
//    S_OK            - yep
//    S_FALSE         - nope
//
// Notes:
//
STDMETHODIMP CPropertyPage::IsPageDirty
(
    void
)
{
    return m_fDirty ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Apply    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to send its changes to all the objects passed through
// SetObjects()
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Apply
(
    void
)
{
    HRESULT hr = S_OK;

    if (m_hwnd) {
        SendMessage(m_hwnd, PPM_APPLY, 0, (LPARAM)&hr);
        RETURN_ON_FAILURE(hr);

        if (m_fDirty) {
            m_fDirty = FALSE;
            if (m_pPropertyPageSite)
                m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    } else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Help    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page that the help button was clicked.
//
// Parameters:
//    LPCOLESTR        - [in] help directory
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Help
(
    LPCOLESTR pszHelpDir
)
{
    BOOL f;

    ASSERT(m_hwnd, "How can somebody have clicked Help, but we don't have an hwnd?");

    // oblige them and show the help.
    //
    MAKE_ANSIPTR_FROMWIDE(psz, pszHelpDir);
    f = WinHelp(m_hwnd, psz, HELP_CONTEXT, HELPCONTEXTOFPROPPAGE(m_ObjectType));

    return f ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::TranslateAccelerator    [IPropertyPage]
//=--------------------------------------------------------------------------=
// informs the page of keyboard events, allowing it to implement it's own
// keyboard interface.
//
// Parameters:
//    LPMSG            - [in] message that triggered this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::TranslateAccelerator
(
    LPMSG pmsg
)
{
    ASSERT(m_hwnd, "How can we get a TranslateAccelerator call if we're not visible?");

    // just pass this message on to the dialog proc and see if they want it.
    //
    return IsDialogMessage(m_hwnd, pmsg) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::EditProperty    [IPropertyPage2]
//=--------------------------------------------------------------------------=
// instructs the page to set the focus to the property matching the dispid.
//
// Parameters:
//    DISPID            - [in] dispid of property to set focus to.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::EditProperty
(
    DISPID dispid
)
{
    HRESULT hr = E_NOTIMPL;

    // send the message on to the control, and see what they want to do with it.
    //
    SendMessage(m_hwnd, PPM_EDITPROPERTY, (WPARAM)dispid, (LPARAM)&hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::m_EnsureLoaded
//=--------------------------------------------------------------------------=
// makes sure the dialog is actually loaded
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CPropertyPage::m_EnsureLoaded
(
    void
)
{
    HRESULT hr = S_OK;

    // duh
    //
    if (m_hwnd)
        return S_OK;

    // set up the global variable so that when we're in the dialog proc, we can
    // stuff this in the hwnd
    //
    // crit sect this whole creation process for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    s_pLastPageCreated = this;

    // create the dialog window
    //
    CreateDialog(GetResourceHandle(), TEMPLATENAMEOFPROPPAGE(m_ObjectType), GetParkingWindow(),
                          (DLGPROC)CPropertyPage::PropPageDlgProc);
    ASSERT(m_hwnd, "Couldn't load Dialog Resource!!!");
    if (!m_hwnd) {
        LeaveCriticalSection(&g_CriticalSection);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // clean up variables and leave the critical section
    //
    s_pLastPageCreated = NULL;
    LeaveCriticalSection(&g_CriticalSection);

    // go and notify the window that it should pick up any objects that are
    // available
    //
    SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::m_ReleaseAllObjects
//=--------------------------------------------------------------------------=
// releases all the objects that we're working with
//
// Notes:
//
void CPropertyPage::m_ReleaseAllObjects
(
    void
)
{
    HRESULT hr;
    UINT x;

    if (!m_cObjects)
        return;

    // some people will want to stash pointers in the PPM_INITOBJECTS case, so
    // we want to tell them to release them now.
    //
    SendMessage(m_hwnd, PPM_FREEOBJECTS, 0, (LPARAM)&hr);

    // loop through and blow them all away.
    //
    for (x = 0; x < m_cObjects; x++)
        QUICK_RELEASE(m_ppUnkObjects[x]);

    HeapFree(g_hHeap, 0, m_ppUnkObjects);
    m_ppUnkObjects = NULL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::PropPageDlgProc
//=--------------------------------------------------------------------------=
// static global helper dialog proc that gets called before we pass the message
// on to anybody ..
//
// Parameters:
//    - see win32sdk docs on DialogProc
//
// Notes:
//
BOOL CALLBACK CPropertyPage::PropPageDlgProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    CPropertyPage *pPropertyPage;

    // get the window long, and see if it's been set to the object this hwnd
    // is operating against.  if not, go and set it now.
    //
    pPropertyPage = (CPropertyPage *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if ((ULONG_PTR)pPropertyPage == -1)
        return FALSE;
    if (!pPropertyPage) {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)s_pLastPageCreated);
        pPropertyPage = s_pLastPageCreated;
        pPropertyPage->m_hwnd = hwnd;
    }

    ASSERT(pPropertyPage, "Uh oh.  Got a window, but no CpropertyPage for it!");

    // just call the user dialog proc and see if they want to do anything.
    //
    return pPropertyPage->DialogProc(hwnd, msg, wParam, lParam);
}


//=--------------------------------------------------------------------------=
// CPropertyPage::FirstControl
//=--------------------------------------------------------------------------=
// returns the first controlish object that we are showing ourselves for.
// returns a cookie that must be passed in for Next ...
//
// Parameters:
//    DWORD *    - [out] cookie to be used for Next
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::FirstControl
(
    DWORD *pdwCookie
)
{
    // just use the implementation of NEXT.
    //
    *pdwCookie = 0;
    return NextControl(pdwCookie);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::NextControl
//=--------------------------------------------------------------------------=
// returns the next control in the chain of people to work with given a cookie
//
// Parameters:
//    DWORD *            - [in/out] cookie to get next from, and new cookie.
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::NextControl
(
    DWORD *pdwCookie
)
{
    UINT      i;

    // go looking through all the objects that we've got, and find the
    // first non-null one.
    //
    for (i = *pdwCookie; i < m_cObjects; i++) {
        if (!m_ppUnkObjects[i]) continue;

        *pdwCookie = i + 1;                // + 1 so we start at next item next time
        return m_ppUnkObjects[i];
    }

    // couldn't find it .
    //
    *pdwCookie = 0xffffffff;
    return NULL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::MakeDirty    [helper, callable]
//=--------------------------------------------------------------------------=
// marks a page as dirty.
//
// Notes:
//
void CPropertyPage::MakeDirty
(
    void
)
{
    m_fDirty = TRUE;
    if (m_pPropertyPageSite)
        m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY|PROPPAGESTATUS_VALIDATE);
}


// from Globals.C
//
extern HINSTANCE g_hInstResources;


//=--------------------------------------------------------------------------=
// CPropertyPage::GetResourceHandle    [helper, callable]
//=--------------------------------------------------------------------------=
// returns current resource handle, based on pagesites ambient LCID.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CPropertyPage::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // enter a critical section for g_lcidLocale and g_fHavelocale
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fHaveLocale) {
        if (m_pPropertyPageSite) {
            m_pPropertyPageSite->GetLocaleID(&g_lcidLocale);
            g_fHaveLocale = TRUE;
        }
    }
    LeaveCriticalSection(&g_CriticalSection);

    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\stdenum.cpp ===
//=--------------------------------------------------------------------------=
// StdEnum.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of a generic enumerator object.
//
#include "IPServer.H"
#include "StdEnum.H"
#include "Globals.H"

SZTHISFILE

//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    REFCLSID        - [in] type of enumerator that we are
//    int             - [in] number of elements in the enumeration
//    int             - [in] size of each element
//    void *          - [in] pointer to element data
//    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
//                    - [in] copying function
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum
(
    REFCLSID rclsid,
    int      cElements,
    int      cbElementSize,
    void    *rgElements,
    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
)
: CUnknownObject(NULL, (IEnumGeneric *)this),
  m_iid(rclsid),
  m_cElements(cElements),
  m_cbElementSize(cbElementSize),
  m_iCurrent(0),
  m_rgElements(rgElements),
  m_pfnCopyElement(pfnCopyElement)
{
    m_pEnumClonedFrom = NULL;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// "it is not death, but dying, which is terrible."
//    - Henry Fielding (1707-54)
//
// Notes:
//
CStandardEnum::~CStandardEnum ()
{
    // if we're a cloned object, then just release our parent object and
    // we're done. otherwise, free up the allocated memory we were given
    //
    if (m_pEnumClonedFrom)
        m_pEnumClonedFrom->Release();
    else {
        if (m_rgElements) HeapFree(g_hHeap, 0, m_rgElements);
    }
}

//=--------------------------------------------------------------------------=
// CStandardEnum::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support our internal iid, and that's all
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CStandardEnum::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, m_iid)) {
        ExternalAddRef();
        *ppvObjOut = (IEnumGeneric *)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Next
//=--------------------------------------------------------------------------=
// returns the next dude in our iteration
//
// Parameters:
//    unsigned long     - [in]  count of elements requested
//    void    *         - [out] array of slots to put values in.
//    unsigned long *   - [out] actual number fetched
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Next
(
    unsigned long  cElm,
    void          *rgDest,
    unsigned long *pcElmOut
)
{
    unsigned long cElementsFetched = 0;
    void         *pElementDest = rgDest;
    const void   *pElementSrc = (const BYTE *)m_rgElements + (m_cbElementSize * m_iCurrent);

    while (cElementsFetched < cElm) {

        // if we hit EOF, break out
        //
        if (m_iCurrent >= m_cElements)
            break;

        // copy the element out for them
        //
        m_pfnCopyElement(pElementDest, pElementSrc, m_cbElementSize);

        // increase the counters
        //
        pElementDest = (LPBYTE)pElementDest + m_cbElementSize;
        pElementSrc  = (const BYTE *)pElementSrc + m_cbElementSize;
        m_iCurrent++;
        cElementsFetched++;
    }

    if (pcElmOut)
        *pcElmOut = cElementsFetched;

    return (cElementsFetched < cElm)? S_FALSE : S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Skip
//=--------------------------------------------------------------------------=
// skips the requested number of rows.
//
// Parameters:
//    unsigned long     - [in] number to skip
//
// Output:
//    HRESULT           - S_OK, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Skip
(
    unsigned long cSkip
)
{
    // handle running off the end
    //
    if (m_iCurrent + (int)cSkip > m_cElements) {
        m_iCurrent = m_cElements;
        return S_FALSE;
    }

    m_iCurrent += cSkip;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Reset
//=--------------------------------------------------------------------------=
// reset the counter.
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
STDMETHODIMP CStandardEnum::Reset
(
    void
)
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Clone
//=--------------------------------------------------------------------------=
// clones the object and gives the new one the same position
//
// Parameters:
//    IEnumVARIANT **    - [out] where to put the new object.
//
// Output;
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStandardEnum::Clone
(
    IEnumGeneric **ppEnumClone
)
{
    CStandardEnum *pNewEnum;

    pNewEnum = new CStandardEnum(m_iid, m_cElements, m_cbElementSize, m_rgElements, m_pfnCopyElement);
    RETURN_ON_NULLALLOC(pNewEnum);

    // hold on to who we were cloned from so m_rgElements stays alive, and we don't
    // have to copy it.
    //
    pNewEnum->m_pEnumClonedFrom = this;

    // AddRef() ourselves on their behalf.
    //
    AddRef();
    *ppEnumClone = (IEnumGeneric *)pNewEnum;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\util.cpp ===
//=--------------------------------------------------------------------------=
// Util.C
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains routines that we will find useful.
//
#include "IPServer.H"

#include "Globals.H"
#include "Util.H"

void * _cdecl operator new(size_t size);
void  _cdecl operator delete(void *ptr);


// for ASSERT and FAIL
//
SZTHISFILE


//=---------------------------------------------------------------------------=
// overloaded new
//=---------------------------------------------------------------------------=
// for the retail case, we'll just use the win32 Local* heap management
// routines for speed and size
//
// Parameters:
//    size_t         - [in] what size do we alloc
//
// Output:
//    VOID *         - new memoery.
//
// Notes:
//
void * _cdecl operator new
(
    size_t    size
)
{
    return HeapAlloc(g_hHeap, 0, size);
}

//=---------------------------------------------------------------------------=
// overloaded delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
void _cdecl operator delete ( void *ptr)
{
    HeapFree(g_hHeap, 0, ptr);
}

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        FAIL("Bogus String Type.");
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    int i;

    char szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(GetResourceHandle(), wId, szTmp, 512);
    if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR));
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR));
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA
(
    REFIID   riid,
    LPSTR    pszBuf
)
{
    return wsprintf((char *)pszBuf, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", riid.Data1,
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2],
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}

//=--------------------------------------------------------------------------=
// RegisterUnknownObject
//=--------------------------------------------------------------------------=
// registers a simple CoCreatable object.  nothing terribly serious.
// we add the following information to the registry:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    LPCSTR       - [in] Object Name
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't register it all
//
// Notes:
//
BOOL RegisterUnknownObject
(
    LPCSTR   pszObjectName,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    char  szScratch[MAX_PATH];
    long  l;

    // clean out any garbage
    //
    UnregisterUnknownObject(riidObject);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "InprocServer32", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    dwPathLen = GetModuleFileName(g_hInstance, szScratch, sizeof(szScratch));
    if (!dwPathLen) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, dwPathLen + 1);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, "ThreadingModel", 0, REG_SZ, (BYTE *)"Apartment", sizeof("Apartment"));
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    return TRUE;

    // we are not very happy!
    //
  CleanUp:
    if (hk) RegCloseKey(hk);
    if (hkSub) RegCloseKey(hkSub);
    return FALSE;

}

//=--------------------------------------------------------------------------=
// RegisterAutomationObject
//=--------------------------------------------------------------------------=
// given a little bit of information about an automation object, go and put it
// in the registry.
// we add the following information in addition to that set up in
// RegisterUnknownObject:
//
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//
BOOL RegisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidLibrary,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    char  szScratch[MAX_PATH];
    long  l;
    DWORD dwDummy;

    // first register the simple Unknown stuff.
    //
    if (!RegisterUnknownObject(pszObjectName, riidObject)) return FALSE;

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
    //
    lstrcpy(szScratch, pszLibName);
    lstrcat(szScratch, ".");
    lstrcat(szScratch, pszObjectName);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0L, "",
                       REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0L, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch)+1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0L, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!StringFromGuidA(riidObject, szGuidStr))
        goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0L, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "CurVer", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
    //
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ|KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "VersionIndependentProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    l = RegCreateKeyEx(hk, "ProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "TypeLib", 0, "", REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkSub, &dwDummy);

    if (!StringFromGuidA(riidLibrary, szGuidStr)) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);
    return TRUE;

  CleanUp:
    if (hk) RegCloseKey(hkSub);
    if (hk) RegCloseKey(hk);
    return FALSE;
}

//=--------------------------------------------------------------------------=
// RegisterControlObject.
//=--------------------------------------------------------------------------=
// in addition to writing out automation object information, this function
// writes out some values specific to a control.
//
// What we add here:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Control
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\MiscStatus\1 = <MISCSTATUSBITS>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ToolboxBitmap32 = <PATH TO BMP>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version = <VERSION>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//    DWORD        - [in] misc status flags for ctl
//    WORD         - [in] toolbox id for control
//
// Output:
//    BOOL
//
// Notes:
//    - not the most terribly efficient routine.
//
BOOL RegisterControlObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidLibrary,
    REFCLSID riidObject,
    DWORD    dwMiscStatus,
    WORD     wToolboxBitmapId
)
{
    HKEY    hk, hkSub = NULL, hkSub2 = NULL;
    char    szTmp[MAX_PATH];
    char    szGuidStr[GUID_STR_LEN];
    DWORD   dwDummy;
    LONG    l;

    // first register all the automation information for this.
    //
    if (!RegisterAutomationObject(pszLibName, pszObjectName, lVersion, riidLibrary, riidObject)) return FALSE;

    // then go and register the control specific stuff.
    //
    StringFromGuidA(riidObject, szGuidStr);
    wsprintf(szTmp, "CLSID\\%s", szGuidStr);
    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_WRITE, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // create the control flag.
    //
    l = RegCreateKeyEx(hk, "Control", 0, "", REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    // now set up the MiscStatus Bits...
    //
    RegCloseKey(hkSub);
    hkSub = NULL;
    l = RegCreateKeyEx(hk, "MiscStatus", 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    szTmp[0] = '0';
    szTmp[1] = '\0';
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, 2);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hkSub, "1", 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSub2, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%d", dwMiscStatus);
    l = RegSetValueEx(hkSub2, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
    RegCloseKey(hkSub2);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    // now set up the toolbox bitmap
    //
    GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
    wsprintf(szGuidStr, ", %d", wToolboxBitmapId);
    lstrcat(szTmp, szGuidStr);

    l = RegCreateKeyEx(hk, "ToolboxBitmap32", 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
    CLEANUP_ON_ERROR(l);

    // now set up the version information
    //
    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "Version", 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%ld.0", lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);

  CleanUp:
    if (hk)
        RegCloseKey(hk);
    if (hkSub)
        RegCloseKey(hkSub);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// UnregisterUnknownObject
//=--------------------------------------------------------------------------=
// cleans up all the stuff that RegisterUnknownObject puts in the
// registry.
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//    - WARNING: this routine will blow away all other keys under the CLSID
//      for this object.  mildly anti-social, but likely not a problem.
//
BOOL UnregisterUnknownObject
(
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    HKEY hk;
    BOOL f;
    long l;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
    //
    if (!StringFromGuidA(riidObject, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_READ | KEY_WRITE, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);

    return f;
}

//=--------------------------------------------------------------------------=
// UnregisterAutomationObject
//=--------------------------------------------------------------------------=
// unregisters an automation object, including all of it's unknown object
// information.
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't get it all unregistered.
//
// Notes:
//
BOOL UnregisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    BOOL f;

    // first thing -- unregister Unknown information
    //
    f = UnregisterUnknownObject(riidObject);
    if (!f) return FALSE;

    // delete everybody of the form:
    //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> [\] *
    //
    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
    if (!f) return FALSE;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> [\] *
    //
    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
    if (!f) return FALSE;

    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
BOOL UnregisterTypeLibrary
(
    REFCLSID riidLibrary
)
{
    HKEY hk;
    char szScratch[GUID_STR_LEN];
    long l;
    BOOL f;

    // convert the libid into a string.
    //
    if (!StringFromGuidA(riidLibrary, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_READ | KEY_WRITE, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);
    return f;
}

//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// delete's a key and all of it's subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPSTR               - [in] i'm the descendant specified
//
// Output:
//    BOOL                - TRUE OK, FALSE baaaad.
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
//      work with sub-keys under windows 95.
//
BOOL DeleteKeyAndSubKeys
(
    HKEY    hkIn,
    LPSTR   pszSubKey
)
{
    HKEY  hk;
    char  szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_READ | KEY_WRITE, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}


//=--------------------------------------------------------------------------=
// Conversion Routines
//=--------------------------------------------------------------------------=
// the following stuff is stuff used for the various conversion routines.
//
#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

static  int     s_iXppli;            // Pixels per logical inch along width
static  int     s_iYppli;            // Pixels per logical inch along height
static  BYTE    s_fGotScreenMetrics; // Are above valid?

//=--------------------------------------------------------------------------=
// GetScreenMetrics
//=--------------------------------------------------------------------------=
// private function we call to set up various metrics the conversion routines
// will use.
//
// Notes:
//
static void GetScreenMetrics
(
    void
)
{
    HDC hDCScreen;

    // we have to critical section this in case two threads are converting
    // things at the same time
    //
    EnterCriticalSection(&g_CriticalSection);
    if (s_fGotScreenMetrics)
        goto Done;

    // we want the metrics for the screen
    //
    hDCScreen = GetDC(NULL);

    ASSERT(hDCScreen, "couldn't get a DC for the screen.");
    s_iXppli = GetDeviceCaps(hDCScreen, LOGPIXELSX);
    s_iYppli = GetDeviceCaps(hDCScreen, LOGPIXELSY);

    ReleaseDC(NULL, hDCScreen);
    s_fGotScreenMetrics = TRUE;

    // we're done with our critical seciton.  clean it up
    //
  Done:
    LeaveCriticalSection(&g_CriticalSection);
}

//=--------------------------------------------------------------------------=
// HiMetricToPixel
//=--------------------------------------------------------------------------=
// converts from himetric to Pixels.
//
// Parameters:
//    const SIZEL *        - [in]  dudes in himetric
//    SIZEL *              - [out] size in pixels.
//
// Notes:
//
void HiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
    GetScreenMetrics();

    // We got logical HIMETRIC along the display, convert them to pixel units
    //
    lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, s_iXppli);
    lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// PixelToHiMetric
//=--------------------------------------------------------------------------=
// converts from pixels to himetric.
//
// Parameters:
//    const SIZEL *        - [in]  size in pixels
//    SIZEL *              - [out] size in himetric
//
// Notes:
//
void PixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
    GetScreenMetrics();

    // We got pixel units, convert them to logical HIMETRIC along the display
    //
    lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, s_iXppli);
    lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// _MakePath
//=--------------------------------------------------------------------------=
// little helper routine for RegisterLocalizedTypeLibs and GetResourceHandle.
// not terrilby efficient or smart, but it's registration code, so we don't
// really care.
//
// Notes:
//
void _MakePath
(
    LPSTR pszFull,
    const char * pszName,
    LPSTR pszOut
)
{
    LPSTR psz;
    LPSTR pszLast;

    lstrcpy(pszOut, pszFull);
    psz = pszLast = pszOut;
    while (*psz) {
        if (*psz == '\\')
            pszLast = AnsiNext(psz);
        psz = AnsiNext(psz);
    }

    // got the last \ character, so just go and replace the name.
    //
    lstrcpy(pszLast, pszName);
}

// from Globals.C
//
extern HINSTANCE    g_hInstResources;

//=--------------------------------------------------------------------------=
// GetResourceHandle
//=--------------------------------------------------------------------------=
// returns the resource handle.  we use the host's ambient Locale ID to
// determine, from a table in the DLL, which satellite DLL to load for
// localized resources.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE GetResourceHandle
(
    void
)
{
    int i;
    char szExtension[5], szTmp[MAX_PATH];
    char szDllName[MAX_PATH], szFinalName[MAX_PATH];

    // crit sect this so that we don't mess anything up.
    //
    EnterCriticalSection(&g_CriticalSection);

    // don't do anything if we don't have to
    //
    if (g_hInstResources || !g_fSatelliteLocalization)
        goto CleanUp;

    // we're going to call GetLocaleInfo to get the abbreviated name for the
    // LCID we've got.
    //
    i = GetLocaleInfo(g_lcidLocale, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
    if (!i) goto CleanUp;

    // we've got the language extension.  go and load the DLL name from the
    // resources and then tack on the extension.
    // please note that all inproc sers -must- have the string resource 1001
    // defined to the base name of the server if they wish to support satellite
    // localization.
    //
    i = LoadString(g_hInstance, 1001, szTmp, sizeof(szTmp));
    ASSERT(i, "This server doesn't have IDS_SERVERBASENAME defined in their resources!");
    if (!i) goto CleanUp;

    // got the basename and the extention. go and combine them, and then add
    // on the .DLL for them.
    //
    wsprintf(szDllName, "%s%s.DLL", szTmp, szExtension);

    // try to load in the DLL
    //
    GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
    _MakePath(szTmp, szDllName, szFinalName);

    g_hInstResources = LoadLibrary(szFinalName);

    // if we couldn't find it with the entire LCID, try it with just the primary
    // langid
    //
    if (!g_hInstResources) {
        LPSTR psz;
        LCID lcid;
        lcid = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(g_lcidLocale)), SUBLANG_DEFAULT), SORT_DEFAULT);
        i = GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
        if (!i) goto CleanUp;

        // reconstruct the DLL name.  the -7 is the length of XXX.DLL. mildly
        // hacky, but it should be fine.  there are no DBCS lang identifiers.
        // finally, retry the load
        //
        psz = szFinalName + lstrlen(szFinalName);
        memcpy((LPBYTE)psz - 7, szExtension, 3);
        g_hInstResources = LoadLibrary(szFinalName);
    }

  CleanUp:
    // if we couldn't load the DLL for some reason, then just return the
    // current resource handle, which is good enough.
    //
    if (!g_hInstResources) g_hInstResources = g_hInstance;
    LeaveCriticalSection(&g_CriticalSection);

    return g_hInstResources;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\basectl\unknown.cpp ===
//=--------------------------------------------------------------------------=
// Unknown.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation for various things in the unknown object that supports
// aggregation.
//
#include "IPServer.H"
#include "Unknown.H"
#include <stddef.h>


//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CUnknownObject *CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
(
    void
)
{
    return (CUnknownObject *)((LPBYTE)this - offsetof(CUnknownObject, m_UnkPrivate));
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CUnknownObject::CPrivateUnknownObject::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    CHECK_POINTER(ppvObjOut);

    // if they're asking for IUnknown, then we have to pass them ourselves.
    // otherwise defer to the inheriting object's InternalQueryInterface
    //
    if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        m_cRef++;
        *ppvObjOut = (IUnknown *)this;
        return S_OK;
    } else
        return m_pMainUnknown()->InternalQueryInterface(riid, ppvObjOut);

    // dead code    
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::Release
(
    void
)
{
    ULONG cRef = --m_cRef;

    if (!m_cRef)
        delete m_pMainUnknown();

    return cRef;
}


//=--------------------------------------------------------------------------=
// CUnknownObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// objects that are aggregated use this to support additional interfaces.
// they should call this method on their parent so that any of it's interfaces
// are queried.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CUnknownObject::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    *ppvObjOut = NULL;

    return E_NOINTERFACE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ie40\html\ieverdef.h ===
#define VER_JAVAVM        "5,0,3802,0"
#define VER_JAVAVM_AXP    "5,0,3229,0"
#define VER_MPLAYER       "6,04,07,1119"
#define VER_MPLAYER_W2K   "6,04,09,1119"
#define VER_WMPCODEC      "6,04,07,1028"
#define VER_GSETUP        "5,0,0,1"
#define VER_AOLSUPP       "5,0,0,2"
#define VER_CORE          "TOK_BUILDNUM,TOK_CIFNUM"
#define VER_DOT_CORE      "TOK_PERIODNUM.TOK_CIFNUM"
#define VER_SHELL         "4,72,3612,1706"
#define VER_MAILNEWS	  "TOK_BUILDNUM,TOK_CIFNUM"
#define VER_ADDRESSBK 	  "TOK_BUILDNUM,TOK_CIFNUM"
#define VER_NETMEETING    "4,4,0,3388"
#define VER_IAMUSIC       "2,5,1,487"
#define VER_MINI_IAMUSIC  "2,5,1,488"
#define VER_DIRECTXMINI   "4,02,00,1054"
#define VER_DIRECTDRAWEX  "4,71,1113,0"
#define VER_DIRECTDR_AXP  "4,71,1112,0"
#define VER_TRIDATA       "5,5000,3130,0"
#define VER_TRIJAVA       "4,7,0,0320"
#define VER_DANIMATION    "6,01,09,727"
#define VER_DANIMATION_AXP "6,01,09,727"
#define VER_DAJAVA        "6,00,01,0223"
#define VER_FONTCORE      "1,00,0000,6"
#define VER_FONTSUP       "1,00,0000,6"
#define VER_MFC40         "4,0,0,0"
#define VER_128UPDATE     "4,87,1959,1877"
#define VER_MSTASK        "4,71,1968,1"
#define VER_HTMLHELP      "4,74,9273,0"
#define VER_MSNAUTH       "4,9,9,2"
#define VER_USP10         "1,400,2411,1"
#define VER_DCOM95        "4,71,2900,7"
#define VER_IELPKAD       "5,00,2000,5"
#define VER_IELPKJA       "5,00,2000,6"
#define VER_JAAIME        "5,1,3106,0"
#define VER_IELPKKO       "5,00,2000,6"
#define VER_KOAIME        "5,1,3106,0"
#define VER_IELPKPE       "5,00,2000,8"
#define VER_IELPKZHT      "5,00,2000,9"
#define VER_TCAIME        "5,1,3106,0"
#define VER_IELPKZHC      "5,00,2000,9"
#define VER_SCAIME        "5,1,3106,1"
#define VER_IELPKIW       "5,00,2000,9"
#define VER_IELPKVI       "5,00,2000,10"
#define VER_IELPKAR       "5,00,2000,8"
#define VER_IELPKTH       "5,00,2000,10"
#define VER_MSGOTHIC      "1,0,0,0"
#define VER_OEMINSTALL    "4,71,0,1105"
#define VER_MSVBSCRIPT    "5,6,0,6509"
#define VER_MSVML         "TOK_BUILDNUM,TOK_CIFNUM"
#define VER_KORSPELLPatch "1,22,2042,0"
#define VER_OAINST        "2,40,4518,0"
#define VER_FLASH         "5,0,42,0"
#define VER_DIRECTOR      "8,0,0,196"
#define VER_MDAC          "2,10,3711,9"
#define VER_SMARTTAGS     "1,0,86,7"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\active\ie4uinit\convert.cpp ===
/************************************************************\
    FILE: convert.c

    DATE: April 1, 1996

    AUTHOR(S):  Bryan Starbuck (bryanst)

    DESCRIPTION:
    This file contains functions that can be used to upgrade
    settings from the Microsoft Internet Explorer v2.0 to v3.0,
    and some features to import Netscape features into Internet
    Explorer.

    This file will handle the logic to convert Netscape
    bookmarks to Microsoft Internet Explorer favorites.  This
    will happen by finding the location of the Netscape bookmarks
    file and the Microsoft Internet Explorer favorites directory
    from the registry.  Then it will parse the bookmarks file to
    extract the URLs, which will finally be added to the favorites
    directory.

    USAGE:
    This code is designed to be called when the user may
    want Netscape bookmarks imported into system level Favorites
    usable by programs such as Internet Explorer.  External
    users should call ImportBookmarks().  If this is done during
    setup, it should be done after setup specifies the Favorites
    registry entry and directory.  If Netscape is not installed,
    then the ImportBookmarks() is just a big no-op.

  NOTE:
    If this file is being compiled into something other
    than infnist.exe, it will be necessary to include the
    following String Resource:

    #define     IDS_NS_BOOKMARKS_DIR    137
    STRINGTABLE DISCARDABLE
    BEGIN
    ...
    IDS_NS_BOOKMARKS_DIR    "\\Imported Bookmarks"
    END


  UPDATES:  I adopted this file to allow IE4.0 having the abilities
    to upgrade from NetScape's setting.  Two CustomActions will be added
    to call in functions in this file. (inateeg)

\************************************************************/
#include "priv.h"
#include "advpub.h"
#include "sdsutils.h"
#include "utils.h"
#include "convert.h"
#include <regstr.h>

//////////////////////////////////////////////////////////////////
//  TYPES:
//////////////////////////////////////////////////////////////////

//typedef enum MYENTRYTYPE MyEntryType;

extern HINSTANCE g_hinst;

//////////////////////////////////////////////////////////////////
//  Constants:
//////////////////////////////////////////////////////////////////
#define MAX_URL 2048
#define FILE_EXT 4          // For ".url" at the end of favorite filenames
#define REASONABLE_NAME_LEN     100

#define BEGIN_DIR_TOKEN         "<DT><H"
#define MID_DIR_TOKEN           "\">"
#define END_DIR_TOKEN           "</H"
#define BEGIN_EXITDIR_TOKEN     "</DL><p>"
#define BEGIN_URL_TOKEN         "<DT><A HREF=\""
#define END_URL_TOKEN           "\" A"
#define BEGIN_BOOKMARK_TOKEN    ">"
#define END_BOOKMARK_TOKEN      "</A>"

#define VALIDATION_STR "<!DOCTYPE NETSCAPE-Bookmark-file-"

//////////////////////////////////////////////////////////////////
//  GLOBALS:
//////////////////////////////////////////////////////////////////
char    * szNetscapeBMRegSub        = "SOFTWARE\\Netscape\\Netscape Navigator\\Bookmark List";
char    * szNetscapeBMRegKey        = "File Location";
char    * szIEFavoritesRegSub       = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
char    * szIEFavoritesRegKey       = "Favorites";
char    * szInvalidFolderCharacters = "\\/:*?\"<>|";

BOOL    gfValidNetscapeFile = FALSE;
BOOL    gfValidIEDirFile = FALSE;



#define _FAT_   1
#define _HPFS_  0
#define _NTFS_  0
#define _WILD_  0
#define _OFS_   0
#define _OLE_   0

#define AnsiMaxChar     128                 // The array below only indicates the lower 7 bits of the byte.

static UCHAR LocalLegalAnsiCharacterArray[AnsiMaxChar] = {

    0,                                                // 0x00 ^@
                          _OLE_,  // 0x01 ^A
                          _OLE_,  // 0x02 ^B
                          _OLE_,  // 0x03 ^C
                          _OLE_,  // 0x04 ^D
                          _OLE_,  // 0x05 ^E
                          _OLE_,  // 0x06 ^F
                          _OLE_,  // 0x07 ^G
                          _OLE_,  // 0x08 ^H
                          _OLE_,  // 0x09 ^I
                          _OLE_,  // 0x0A ^J
                          _OLE_,  // 0x0B ^K
                          _OLE_,  // 0x0C ^L
                          _OLE_,  // 0x0D ^M
                          _OLE_,  // 0x0E ^N
                          _OLE_,  // 0x0F ^O
                          _OLE_,  // 0x10 ^P
                          _OLE_,  // 0x11 ^Q
                          _OLE_,  // 0x12 ^R
                          _OLE_,  // 0x13 ^S
                          _OLE_,  // 0x14 ^T
                          _OLE_,  // 0x15 ^U
                          _OLE_,  // 0x16 ^V
                          _OLE_,  // 0x17 ^W
                          _OLE_,  // 0x18 ^X
                          _OLE_,  // 0x19 ^Y
                          _OLE_,  // 0x1A ^Z
                          _OLE_,  // 0x1B ESC
                          _OLE_,  // 0x1C FS
                          _OLE_,  // 0x1D GS
                          _OLE_,  // 0x1E RS
                          _OLE_,  // 0x1F US
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x20 space
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_,          // 0x21 !
                  _WILD_,                 // 0x22 "
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x23 #
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x24 $
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x25 %
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x26 &
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x27 '
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x28 (
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x29 )
                  _WILD_,                 // 0x2A *
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2B +
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2C ,
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2D -
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x2E .
    0,                                                // 0x2F /
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x30 0
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x31 1
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x32 2
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x33 3
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x34 4
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x35 5
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x36 6
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x37 7
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x38 8
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x39 9
             _NTFS_ |         _OFS_,          // 0x3A :
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x3B ;
                  _WILD_,                 // 0x3C <
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x3D =
                  _WILD_,                 // 0x3E >
                  _WILD_,                 // 0x3F ?
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x40 @
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x41 A
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x42 B
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x43 C
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x44 D
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x45 E
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x46 F
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x47 G
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x48 H
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x49 I
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4A J
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4B K
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4C L
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4D M
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4E N
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x4F O
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x50 P
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x51 Q
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x52 R
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x53 S
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x54 T
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x55 U
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x56 V
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x57 W
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x58 X
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x59 Y
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5A Z
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5B [
    0,                                                // 0x5C backslash
        _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5D ]
    _FAT_ | _HPFS_ | _NTFS_ |         _OFS_ | _OLE_,  // 0x5E ^
    _FAT_ | _HPFS_ | _NTFS_ |      