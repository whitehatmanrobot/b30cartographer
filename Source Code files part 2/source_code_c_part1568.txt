IpAddress = 0;
        SubnetMask = htonl(DhcpDefaultSubnetMask( IpAddress ));

        Lease = 0;
        LeaseObtainedTime = T1Time = T2Time = LeaseTerminatedTime = 0;
    }

    //
    // fill in the fields of the context
    //

    // DhcpContext->NicListEntry will be done at the end
    // DhcpContext->Haredware* already done in MakeNICEntry
    DhcpContext->IpAddress = IpAddress;
    DhcpContext->SubnetMask = SubnetMask;
    DhcpContext->DhcpServerAddress = DhcpServerAddress;
    if( ReadAllInfo ) DhcpContext->DesiredIpAddress = DesiredIpAddress;
    DhcpContext->IPAutoconfigurationContext = IPAutoconfigContext;
    // ClientID is filled in in MakeNICEntry
    if( ReadAllInfo ) {
        DhcpContext->Lease = Lease;
        DhcpContext->LeaseObtained = LeaseObtainedTime;
        DhcpContext->T1Time = T1Time;
        DhcpContext->T2Time = T2Time;
        DhcpContext->LeaseExpires = LeaseTerminatedTime;
    }
    // renewal list entry, run time, seconds since boot, renewal function
    // send list, recd list, option cache, renew handle, class id
    //  --- all the above are handled elsewhere

    DhcpContext->DontPingGatewayFlag = (DontPingGatewayFlag)?TRUE:FALSE;
    DhcpContext->UseInformFlag = (UseInformFlag)?TRUE:FALSE;
    DhcpContext->InformSeparationInterval = InformSeparationInterval;
    DhcpContext->ReleaseOnShutdown = ReleaseOnShutdown;
#ifdef BOOTPERF
    DhcpContext->fQuickBootEnabled = (fQuickBootEnabled ? TRUE : FALSE);
#endif BOOTPERF

    // AdapterInfoKey is set in MakeContext
    // RenewHandle is set in AddNICtoListEx
    // DhcpContext->MessageBuffer set in MakeNICEntry
    if( dwIPAutoconfigurationEnabled ) AUTONET_ENABLED(DhcpContext); else AUTONET_DISABLED(DhcpContext);
    if( ReadAllInfo ) {
        // DhcpContext->MessageBuffer set in MakeNICEntry
        if( EnableDhcp ) ADDRESS_UNPLUMBED(DhcpContext); else ADDRESS_PLUMBED(DhcpContext);
        SERVER_UNREACHED(DhcpContext);
        if( dwIPAutoconfigurationEnabled ) AUTONET_ENABLED(DhcpContext); else AUTONET_DISABLED(DhcpContext);
        CTXT_WAS_NOT_LOOKED(DhcpContext);
        if( EnableDhcp ) DHCP_ENABLED(DhcpContext); else DHCP_DISABLED(DhcpContext);
        if( ADDRESS_TYPE_AUTO != AddressType ) ACQUIRED_DHCP_ADDRESS(DhcpContext); else ACQUIRED_AUTO_ADDRESS(DhcpContext);
        if( IS_ADDRESS_AUTO(DhcpContext) ) {
            DhcpContext->IpAddress = 0;           // this is useless if it is an autonet address
        }
        MEDIA_CONNECTED(DhcpContext);
        // local info is setup in make context
    }

    return ERROR_SUCCESS;
}

DWORD                                             // win32 status
DhcpRegFillFallbackConfig(                        // get the fallback config for this adapter
    IN OUT PDHCP_CONTEXT           DhcpContext    // adapter context to fill in
)
{
    DWORD   Error;                  // returned error code
    HKEY    KeyHandle;              // registry key to the configurations location
    LPWSTR  FbConfigName = NULL;    // fallback configuration name
    DWORD   FbConfigNameLen;        // length of the fallback configuration name
    DWORD   FbConfigNameType;       // reg type of the configuration name

    // start assuming there is no fallback configuration set
    FALLBACK_DISABLED(DhcpContext);

    // get the list of active configurations for this adapter. 
    // For now we expect (and handle) only one, the fallback config.
    // For the future, the MULTI_SZ might contain several config names
    // that will be involved in autodetection.

    // query the registry for the configuration's name size
    // [HKLM\SYSTEM\CCS\Services\Tcpip\Parameters\Interfaces\{Intf_GUID}]
    // ActiveConfigurations = (REG_MULTI_SZ)
    Error = RegQueryValueEx(
        DhcpContext->AdapterInfoKey,
        DHCP_IPAUTOCONFIGURATION_CFG,
        NULL,
        &FbConfigNameType,
        NULL,
        &FbConfigNameLen);

    // if something went wrong or the value has not the
    // expected type, break out with an error
    if (Error != ERROR_SUCCESS ||
        FbConfigNameType != DHCP_IPAUTOCONFIGURATION_CFG_TYPE)
    {
        // if no error was signaled it means we found a key but
        // its type is different from the one expected. Convert
        // the success to an ERROR_BAD_FORMAT failure
        if (Error == ERROR_SUCCESS)
            Error = ERROR_BAD_FORMAT;

        // if we didn't find the pointer to the fallback config,
        // it means we don't have one, hence is pure autonet.
        // this is not a failure so return success
        if (Error == ERROR_FILE_NOT_FOUND)
            Error = ERROR_SUCCESS;

        return Error;
    }

    // allocate space for the registry path where the configuration is stored.
    // [HKLM\SYSTEM\CCS\Services\Dhcp\Configurations\{configuration_name}]
    FbConfigName = DhcpAllocateMemory(
                        sizeof(DHCP_CLIENT_CONFIGURATIONS_KEY) + 
                        sizeof(REGISTRY_CONNECT_STRING) + 
                        FbConfigNameLen);

    // if allocation failed, break out with error.
    if (FbConfigName == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // build up the prefix of the path: "SYSTEM\CCS\Services\Dhcp\Configurations\"
    wcscpy(FbConfigName, DHCP_CLIENT_CONFIGURATIONS_KEY REGISTRY_CONNECT_STRING);

    // now, since we know what to expect and we have the storage
    // for it, get the config name from the same location as above
    Error = RegQueryValueEx(
        DhcpContext->AdapterInfoKey,
        DHCP_IPAUTOCONFIGURATION_CFG,
        NULL,
        &FbConfigNameType,
        (LPBYTE)(FbConfigName + wcslen(FbConfigName)),
        &FbConfigNameLen);

    // the registry call above is expected to succeed and data
    // to have the right type - we tested this before.
    DhcpAssert(Error == ERROR_SUCCESS && 
               FbConfigNameType == DHCP_IPAUTOCONFIGURATION_CFG_TYPE);
    
    // open the registry key for this configuration
    // [HKLM\SYSTEM\CCS\Services\Dhcp\Configurations\{Config_Name}]
    Error = RegOpenKey(
            HKEY_LOCAL_MACHINE,
            FbConfigName,
            &KeyHandle);

    // in case of success...
    if (Error == ERROR_SUCCESS)
    {
        // ...build up the FbOptionsList from that registry location
        // from the "Options" value (REG_BINARY)
        Error = DhcpRegReadOptionCache(
            &DhcpContext->FbOptionsList,
            KeyHandle,
            DHCP_IPAUTOCONFIGURATION_CFGOPT,
            TRUE                // Add DhcpGlobalClassesList
            );

        if (Error == ERROR_SUCCESS)
        {
            // At this point we know for sure a fallback configuration
            // is available. Set its flag accordingly
            FALLBACK_ENABLED(DhcpContext);
        }
        // regardless success or failure, cleanup.
        RegCloseKey(KeyHandle);
    }

    // free up the memory previously allocated
    DhcpFreeMemory(FbConfigName);

    // return the error code
    return Error;
}

DWORD                                             // win32 status
DhcpAddNICtoListEx(                               // create a context and add it to renew list
    IN      LPWSTR                 AdapterName,   // adapter to create context for
    IN      DWORD                  IpInterfaceContext,
    OUT     PDHCP_CONTEXT         *pDhcpContext   // allocate a structure and fill this ptr
) {
    DWORD                          Error;
    HANDLE                         RenewHandle;
    PDHCP_CONTEXT                  DhcpContext;
    CHAR                           StateStringBuffer[200];
    PLOCAL_CONTEXT_INFO            LocalInfo;
    
    RenewHandle = CreateSemaphore(
        NULL,                                     // No security
        1,                                        // count = 1
        1,                                        // MaxCount = 1
        NULL                                      // No name
    );
    if( NULL == RenewHandle ) {
        Error = GetLastError();

        DhcpPrint((DEBUG_ERRORS, "CreateSemaphore: %ld\n", Error));
        return Error;
    }

    (*pDhcpContext) = NULL;
    Error = DhcpMakeContext(AdapterName, IpInterfaceContext, pDhcpContext);

    if( Error != ERROR_SUCCESS ) {
        CloseHandle(RenewHandle);
        return Error;
    }

    DhcpContext = (*pDhcpContext);                // initialize some simple params
    DhcpContext->RenewHandle = RenewHandle;
    DhcpContext->NumberOfWaitingThreads = 0;
    DhcpContext->CancelEvent = WSACreateEvent();
    if (DhcpContext->CancelEvent == WSA_INVALID_EVENT) {
        DhcpPrint((DEBUG_ERRORS, "WSAEvent 0x%lx could not be created: 0x%lx.\n", 
                   DhcpContext->CancelEvent,
                   WSAGetLastError()));
    }

    DhcpContext->RunTime = 0;
    DhcpContext->SecondsSinceBoot = 0;
    DhcpContext->RenewalFunction = NULL;
    InitializeListHead(&DhcpContext->RenewalListEntry);
    InitializeListHead(&DhcpContext->SendOptionsList);
    InitializeListHead(&DhcpContext->RecdOptionsList);
    InitializeListHead(&DhcpContext->FbOptionsList);

    Error = DhcpRegFillParams(                    // read all the registry parameters
        DhcpContext,
        TRUE                                      // and yes, fill em up in the context
    );

    // read the fallback configuration (if any)
    Error = DhcpRegFillFallbackConfig(
        DhcpContext
    );

    DhcpPrint((DEBUG_TRACK,"Fallback: Loading returned %d.\n", Error));

#ifdef BOOTPERF
    LocalInfo = (PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation;

    if( IS_DHCP_DISABLED(DhcpContext) ) {
        //
        // Don't care about interface down info.
        //
        LocalInfo->fInterfaceDown = 0;
        LocalInfo->OldIpAddress = 0;
        LocalInfo->OldIpMask = 0;
    } else {
        //
        // For DHCP enabled interfaces, if the interface is down,
        // then bring it up with zero ip address. The protocol will
        // take care of using the right IP address later on.
        //
        if( LocalInfo->fInterfaceDown ) {
            DhcpPrint((DEBUG_ERRORS, "Interface already down\n"));
            LocalInfo->OldIpAddress = 0;
            LocalInfo->OldIpMask = 0;
            LocalInfo->fInterfaceDown = 0;
            IPResetIPAddress(
                LocalInfo->IpInterfaceContext,
                DhcpDefaultSubnetMask(0)
                );
            Error = BringUpInterface(LocalInfo);
            if( ERROR_SUCCESS != Error ) {
                DhcpPrint((DEBUG_ERRORS, "Interface can't be brought up: 0x%lx\n", Error));
            }
        }
    }
#endif BOOTPERF
    
    LOCK_OPTIONS_LIST();
    DhcpRegReadClassId(DhcpContext);              // fill in the class id first
    Error = DhcpRegFillSendOptions(               // figure the default list of options to send
        &DhcpContext->SendOptionsList,
        AdapterName,
        DhcpContext->ClassId,
        DhcpContext->ClassIdLength
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpRegFillSendOptions(%ws):%ld\n", Error));
    }

    if( IS_DHCP_ENABLED( DhcpContext ) ) {
        // read in the list of options we had before?        
        Error = DhcpRegReadOptionCache(
            &DhcpContext->RecdOptionsList,
            DhcpGlobalParametersKey,
            AdapterName,
            TRUE                // Add DhcpGlobalClassesList
            );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DhcpRegReadOptionCache(%ws): %ld\n", AdapterName, Error));
        }
    } else {
        // 
        // ignore any option cache for static addresses because
        // of bug # 413319.  Instead for non-ndiswan stuff, clear
        // the option cache.
        //

        if( !NdisWanAdapter(DhcpContext) ) {
            DhcpRegSaveOptions(
                &DhcpContext->RecdOptionsList, AdapterName,
                DhcpContext->ClassId, DhcpContext->ClassIdLength
                );
        }
    }
    
    UNLOCK_OPTIONS_LIST();

    if (NdisWanAdapter(DhcpContext))
        InterlockedIncrement(&DhcpGlobalNdisWanAdaptersCount);

    LOCK_RENEW_LIST();                            // insert this into the renew list
    InsertTailList( &DhcpGlobalNICList, &DhcpContext->NicListEntry );
    UNLOCK_RENEW_LIST();

    DhcpPrint((DEBUG_INIT, "DhcpMakeAndInsertNICEntryEx: DhcpContext %lx, Flags %s\n",
               DhcpContext, ConvertStateToString(DhcpContext, StateStringBuffer)));

    return ERROR_SUCCESS;
}

#ifdef BOOTPERF
VOID
DhcpRegDeleteQuickBootValues(
    IN HKEY Key
    )
/*++

Routine Description:
    This routine deletes the values used for quickboot.
    (If the values are not presentt they are ignored).

    The values deleted are:
    "TempIpAddress", "TempMask" and "TempLeaseExpirationTime"

Arguments:
    Key -- key under which these values are deleted.

--*/
{
    //
    // ignore errors and silently delete values..
    //

    (void) RegDeleteValue(Key, DHCP_TEMP_IPADDRESS_VALUE );
    (void) RegDeleteValue(Key, DHCP_TEMP_MASK_VALUE );
    (void) RegDeleteValue(Key, DHCP_TEMP_LEASE_EXP_TIME_VALUE );

}

VOID
DhcpRegSaveQuickBootValues(
    IN HKEY Key,
    IN ULONG IpAddress,
    IN ULONG Mask,
    IN ULONGLONG LeaseExpirationTime
    )
/*++

Routine Description:
    This routine saves the values needed to the registry.
    Values saved are:
    "TempIpAddress", "TempMask", "TempLeaseExpirationTime"

Arguments:
    Key -- key to save under
    IpAddress -- non-zero Ip address value
    Mask -- non-zero mask value
    LeaseExpirationTime -- lease expiration value.

--*/
{
    ULONG Error;

    if( NULL == Key ) return;

    DhcpAssert( 0 != IpAddress || 0 != Mask );
    Error = RegSetIpAddress(
        Key, DHCP_TEMP_IPADDRESS_VALUE, REG_SZ, IpAddress
        );
    DhcpAssert( ERROR_SUCCESS == Error );

    Error = RegSetIpAddress(
        Key, DHCP_TEMP_MASK_VALUE, REG_SZ, Mask
        );
    DhcpAssert( ERROR_SUCCESS == Error );

    Error = RegSetValueEx(
        Key,
        DHCP_TEMP_LEASE_EXP_TIME_VALUE,
        0 /* Reserved */,
        REG_BINARY,
        (PVOID)&LeaseExpirationTime,
        sizeof(LeaseExpirationTime)
        );
    DhcpAssert(ERROR_SUCCESS == Error);
}

#endif BOOTPERF

DHCP_IP_ADDRESS                                   // the static ip address of the adapter
DhcpRegReadIpAddress(                             // get the first ip address
    LPWSTR    AdapterName,                        // the adaptor of interest
    LPWSTR    ValueName                           // the ip address value to read
) {
    DWORD     Error;
    LPWSTR    RegKey;
    HKEY      KeyHandle;
    DWORD     ValueType;
    DWORD     ValueSize;
    LPWSTR    IpAddressString;
    CHAR      OemIpAddressString[DOT_IP_ADDR_SIZE];
    DHCP_IP_ADDRESS RetVal;

    RetVal          = inet_addr("0.0.0.0");
    RegKey          = NULL;
    KeyHandle       = NULL;
    IpAddressString = NULL;

    Error = ERROR_NOT_ENOUGH_MEMORY;
    RegKey = DhcpAllocateMemory(
        (wcslen(DHCP_SERVICES_KEY) +
         wcslen(REGISTRY_CONNECT_STRING) +
         wcslen(AdapterName) +
         wcslen(DHCP_ADAPTER_PARAMETERS_KEY) + 1) *
        sizeof(WCHAR) ); // termination char.

    if( RegKey == NULL ) goto Cleanup;

    wcscpy( RegKey, DHCP_SERVICES_KEY );
    wcscat( RegKey, DHCP_ADAPTER_PARAMETERS_KEY );
    wcscat( RegKey, REGISTRY_CONNECT_STRING );
    wcscat( RegKey, AdapterName );

    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegKey,
        0, // Reserved field
        DHCP_CLIENT_KEY_ACCESS,
        &KeyHandle
    );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Error = GetRegistryString(
        KeyHandle,
        ValueName,
        &IpAddressString,
        NULL
    );

    if( ERROR_SUCCESS != Error ) goto Cleanup;

    DhcpPrint((DEBUG_MISC, "Static adapter <%ws> has ip address %ws\n",
               AdapterName, IpAddressString));

    DhcpAssert(NULL != IpAddressString);

    RetVal = inet_addr(DhcpUnicodeToOem(IpAddressString, OemIpAddressString));

  Cleanup:

    if( RegKey) DhcpFreeMemory(RegKey);
    if( KeyHandle ) DhcpFreeMemory(KeyHandle);
    if( IpAddressString ) DhcpFreeMemory(IpAddressString);

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpRegReadIpAddress: %ld\n", Error));
    }

    return RetVal;
}

BOOL                                              // obtained a static address?
DhcpRegDomainName(                                // get the static domain name if any
    IN      PDHCP_CONTEXT          DhcpContext,   // adapter to get static domain for..
    IN OUT  LPBYTE                 DomainNameBuf, // buffer to fill with static domain name
    IN      ULONG                  BufSize        // size of above buffer in bytes..
)
{
    WCHAR                          DomBuf[260];
    DWORD                          Result;
    DWORD                          ValueType;
    DWORD                          Size;

#if 0                                             // this is not really needed.
    if( NULL == DhcpGlobalTcpipParametersKey ) {  // maybe running in RAS context?
        return FALSE;                             // no domain name in this context..
    }

    Size = BufSize;
    Result = RegQueryValueExA(                    // first read the value from global
        DhcpGlobalTcpipParametersKey,             // Tcpip\Parameters\Domain key
        DHCP_STATIC_DOMAIN_VALUE_A,               // "Domain"
        0,
        &ValueType,
        DomainNameBuf,
        &BufSize
    );
    if( ERROR_SUCCESS == Result && REG_SZ == ValueType && BufSize > 1 ) {
        return TRUE;                              // got a domain name! aha
    }
    BufSize = Size;
#endif

    if( NULL == DhcpContext->AdapterInfoKey ) {   // uh? dont know what this means..
        return FALSE;                             // cant get global information in this case
    }

    Size = sizeof(DomBuf);
    Result = RegQueryValueExW(                    // now try to read the per-adapter stuff..
        DhcpContext->AdapterInfoKey,              // per-adapter key is already there for us
        DHCP_DOMAINNAME_VALUE,                    // same value.. "Domain"
        0,
        &ValueType,
        (LPBYTE)DomBuf,
        &Size
    );

    if( ERROR_SUCCESS == Result && REG_SZ == ValueType && Size > sizeof(WCHAR) ) {
        if( NULL == DhcpUnicodeToOem(DomBuf, DomainNameBuf) ) return FALSE;
        return TRUE;
    }

    return FALSE;                                 // did not find a static domain in either place..
}

STATIC
struct /* anonymous */ {
    DHCPKEY                       *GlobalKey;
    LPWSTR                         KeyLocation;
} GlobalKeyList[] = {                             // the list of keys that need to be opened
    &DhcpGlobalParametersKey,      DHCP_CLIENT_PARAMETER_KEY,
    &DhcpGlobalTcpipParametersKey, DHCP_TCPIP_PARAMETERS_KEY,
    &DhcpGlobalClientOptionKey,    DHCP_CLIENT_OPTION_KEY,
    &DhcpGlobalServicesKey,        DHCP_SERVICES_KEY,
    NULL,                          NULL,
};

ULONG DwordDisplayPopup;
STATIC
struct /* anonymous */ {
    DWORD                         *DwordValue;
    LPWSTR                         ValueName;
}   GlobalTcpipDwordParameters[] = {              // The global list of DWORDS
    &UseMHAsyncDns,                DHCP_USE_MHASYNCDNS_FLAG,
    &DhcpGlobalAutonetEnabled,     DHCP_IPAUTOCONFIGURATION_ENABLED,
    &AutonetRetriesSeconds,        DHCP_AUTONET_RETRIES_VALUE,
    &DhcpGlobalUseInformFlag,      DHCP_USE_INFORM_FLAG,
    &DhcpGlobalDontPingGatewayFlag,DHCP_DONT_PING_GATEWAY_FLAG,
#ifdef BOOTPERF
    &DhcpGlobalQuickBootEnabledFlag,DHCP_QUICK_BOOT_FLAG,
#endif BOOTPERF
    NULL,                          NULL,
},
    GlobalDhcpDwordParameters[] = {               // stored in Services\Dhcp\Params..
#if DBG
        &DhcpGlobalDebugFlag,      DHCP_DEBUG_FLAG_VALUE,
        &DhcpGlobalServerPort,     DHCP_SERVER_PORT_VALUE,
        &DhcpGlobalClientPort,     DHCP_CLIENT_PORT_VALUE,
#endif DBG
        &DwordDisplayPopup,        DHCP_DISPLAY_POPUPS_FLAG,
        NULL,                      NULL,
    };

DWORD                                             // Win32 status
DhcpInitRegistry(                                 // Initialize registry based globals
    VOID
) {
    DWORD                          Error;
    DWORD                          i;
    DWORD                          Type;
    DWORD                          Size;
    DWORD                          DwordValue;
    LPWSTR                         ValueName;

    DhcpGlobalAutonetEnabled = TRUE;

    i = 0;
    while( NULL != GlobalKeyList[i].GlobalKey ) {
        Error = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            GlobalKeyList[i].KeyLocation,
            0 /* Reserved */,
            DHCP_CLIENT_KEY_ACCESS,
            GlobalKeyList[i].GlobalKey
        );
        if( ERROR_SUCCESS != Error ) return Error;
        i ++;
    }

    i = 0;
    while( NULL != GlobalTcpipDwordParameters[i].DwordValue ) {
        ValueName =  GlobalTcpipDwordParameters[i++].ValueName;
        Size = sizeof(DwordValue);
        Error = RegQueryValueEx(
            DhcpGlobalTcpipParametersKey,
            ValueName,
            0 /* Reserved */,
            &Type,
            (LPBYTE)&DwordValue,
            &Size
        );

        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_INIT, "Did not find value %ws in the registry\n", ValueName));
            continue;
        }

        if( REG_DWORD != Type ) {
            DhcpPrint((DEBUG_ERRORS, "RegValue %ws is not DWORD type -- ignored\n", ValueName));
            continue;
        }

        DhcpAssert(sizeof(DWORD) == Size);
        *GlobalTcpipDwordParameters[i-1].DwordValue = DwordValue;

        DhcpPrint((DEBUG_TRACE, "RegValue %ws = %ld = 0x%X\n", ValueName, DwordValue, DwordValue));
    }

    DwordDisplayPopup = 0;
    i = 0;
    while( NULL != GlobalDhcpDwordParameters[i].DwordValue ) {
        ValueName =  GlobalDhcpDwordParameters[i++].ValueName;
        Size = sizeof(DwordValue);
        Error = RegQueryValueEx(
            DhcpGlobalParametersKey,
            ValueName,
            0 /* Reserved */,
            &Type,
            (LPBYTE)&DwordValue,
            &Size
        );

        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_INIT, "Did not find value %ws in the registry\n", ValueName));
            continue;
        }

        if( REG_DWORD != Type ) {
            DhcpPrint((DEBUG_ERRORS, "RegValue %ws is not DWORD type -- ignored\n", ValueName));
            continue;
        }

        DhcpAssert(sizeof(DWORD) == Size);
        *GlobalDhcpDwordParameters[i-1].DwordValue = DwordValue;

        DhcpPrint((DEBUG_TRACE, "RegValue %ws = %ld = 0x%X\n", ValueName, DwordValue, DwordValue));
    }

    if( DwordDisplayPopup ) DhcpGlobalDisplayPopup = TRUE ; else DhcpGlobalDisplayPopup = FALSE;
    return DhcpRegReadOptionDefList();
}

VOID
DhcpCleanupRegistry(                              // undo the effects of InitReg call
    VOID
) {
    DWORD                          i;

    i = 0;
    while( NULL != GlobalKeyList[i].GlobalKey ) {
        if( *GlobalKeyList[i].GlobalKey ) RegCloseKey(*GlobalKeyList[i].GlobalKey);
        (*GlobalKeyList[i].GlobalKey) = NULL;
        i ++ ;
    }
}
//--------------------------------------------------------------------------------
//  End of file
//--------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\makefile.inc ===
$(O)\dhcpcli.res: dhcpcli.rc

$(O)\mdhcptst.res: mdhcptst.rc

$(O)\rastest.res: rastest.rc

$(O)\optapi.res: optapi.rc

$(O)\tdhcpcapi.res: tdhcpcapi.rc

$(O)\dhcpc.res: dhcpc.rc

$(O)\dumpdhcp.res: dumpdhcp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\precomp.h ===
#include <dhcpcli.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\dumpdhcp.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Implements raw sockets stuff..

--*/

#include "precomp.h"

int show_all = 0;
int show_headers = 0;

void usage(void) {
    fprintf(stderr, "usage: dumpdhcp local_ip_address [all] [headers]\n"
            "    local_ip_address -- binds to this ip address\n"
            "    all -- shows all UDP packets, not just MADCAP\n"
            "    hdr -- shows headers only\n"
            );
    exit(1);
}
            
void convert_time(DWORD_PTR TimeVal, char *time_buf)
{

    struct tm* pTime;
    char timeBuf[500];

    strcpy(timeBuf, " <???>");
    if (pTime = localtime(&TimeVal)) {

        SYSTEMTIME systemTime;
        int n;

        systemTime.wYear = pTime->tm_year + 1900;
        systemTime.wMonth = pTime->tm_mon + 1;
        systemTime.wDayOfWeek = (WORD)pTime->tm_wday;
        systemTime.wDay = (WORD)pTime->tm_mday;
        systemTime.wHour = (WORD)pTime->tm_hour;
        systemTime.wMinute = (WORD)pTime->tm_min;
        systemTime.wSecond = (WORD)pTime->tm_sec;
        systemTime.wMilliseconds = 0;

        timeBuf[0] = ' ';
        n = GetDateFormatA(
            LOCALE_NEUTRAL,
            DATE_SHORTDATE,
            &systemTime,
            NULL,
            &timeBuf[1],
            sizeof(timeBuf)
            );
        timeBuf[n] = ' ';
        GetTimeFormatA(
            LOCALE_NEUTRAL, 0, &systemTime,
            NULL, &timeBuf[n+1], sizeof(timeBuf) - n - 2
            );

    }
    strcpy(time_buf, timeBuf);
}

void socket_error(char *str) {
    fprintf(stderr, "FATAL: %s [0x%lx]\n", str, WSAGetLastError());
    exit(1);
}

void DumpInt(
    char *s, unsigned long x
    )
{
    printf(s, x);
}

void DumpBytes(
    int tab_offset, int nbytes_per_line, int halfwaymark,
    unsigned char separation_character,
    unsigned char *buffer,
    unsigned long length
    )
{
    unsigned long dumped;
    
    dumped = 0;
    while( dumped < length ) {
        if( tab_offset && 0 == (dumped % nbytes_per_line) ) {
            int i;
            if( dumped ) putchar('\n');
            for( i = 0; i < tab_offset; i ++ ) putchar(' ');
        } else if( tab_offset && halfwaymark ) {
            if( 0 == (dumped % halfwaymark ) ) {
                putchar(separation_character);
            }
        }
        
        printf( (separation_character)?"%02X%c":"%02X",
                (unsigned long)(*buffer++), separation_character
                );
        dumped++;
    }
}
    
typedef struct {
    unsigned char HeaderLen:4;
    unsigned char Version:4;
    unsigned char TOS;
    unsigned short Length;
    unsigned char Id;
    unsigned short Offset;
    unsigned char TTL;
    unsigned char Proto;
    unsigned char Xsum;
    struct in_addr Source;
    struct in_addr Dest;
} IP_HEADER, *PIP_HEADER;

typedef struct
{
    unsigned short  SourcePort;
    unsigned short  DestPort;
    unsigned short  Length;
    unsigned short  Xsum;
} UDP_HEADER, *PUDP_HEADER;

#define MADCAP_SERVER_PORT 2535
#define DHCP_SERVER_PORT 67
#define DHCP_CLIENT_PORT 68

#define MADCAP_OPTION_END               0
#define MADCAP_OPTION_LEASE_TIME        1
#define MADCAP_OPTION_SERVER_ID         2
#define MADCAP_OPTION_CLIENT_ID         3
#define MADCAP_OPTION_MCAST_SCOPE       4
#define MADCAP_OPTION_REQUEST_LIST      5
#define MADCAP_OPTION_START_TIME        6
#define MADCAP_OPTION_ADDR_COUNT        7
#define MADCAP_OPTION_REQUESTED_LANG    8
#define MADCAP_OPTION_MCAST_SCOPE_LIST  9
#define MADCAP_OPTION_ADDR_LIST         10
#define MADCAP_OPTION_TIME              11
#define MADCAP_OPTION_FEATURE_LIST      12
#define MADCAP_OPTION_RETRY_TIME        13
#define MADCAP_OPTION_MIN_LEASE_TIME    14
#define MADCAP_OPTION_MAX_START_TIME    15

char *madcap_option_list[] = {
    "End", "LeaseTime", "ServerId", "ClientId",
    "Scope", "RequestList", "StartTime", "AddressCount",
    "RequestedLanguage", "ScopeList", "AddressList",
    "Time", "FeatureList", "RetryTime", "MinLeaseTime",
    "MaxStartTime",
};

char *madcap_message_types[] = {
    "Unknown", "Discover",
    "Offer", "Request", "Renew", "Ack", "Nack", "Release", "Inform"
};

char *
MadcapMessageType(
    unsigned long type
    )
{
    static char type_buf[30];
    
    if( type > sizeof(madcap_message_types)/sizeof(madcap_message_types[0])) {
        sprintf(type_buf, "Unknown Message Type %ld", type);
        return type_buf;
    }

    return madcap_message_types[type];
}

typedef struct {
    WORD Type, Length;
} MADCAP_OPTION_HEADER, *PMADCAP_OPTION_HEADER;

void DumpMadcapOption(
    unsigned long OptionType,
    unsigned long OptionLength,
    char *Buffer
    )
{
    int nOptions = sizeof(madcap_option_list)/sizeof(madcap_option_list[0]);
    DWORD Value;
    DWORD AddressFamily;
    struct in_addr ipaddr;
    int fprint_time = 0;
    char time_buf[500];

    time_buf[0] = ' ';
    time_buf[1] = '\0';
    
    do {
        if( OptionType > (unsigned long)nOptions ) break;

        if( 0 == OptionLength ) break;
        
        switch( OptionType ) {
        case MADCAP_OPTION_END :
        case MADCAP_OPTION_CLIENT_ID :
        case MADCAP_OPTION_REQUEST_LIST :
        case MADCAP_OPTION_REQUESTED_LANG :
        case MADCAP_OPTION_MCAST_SCOPE_LIST :
        case MADCAP_OPTION_ADDR_LIST :
        case MADCAP_OPTION_FEATURE_LIST :
            break;

        case MADCAP_OPTION_START_TIME :
        case MADCAP_OPTION_MAX_START_TIME :
        case MADCAP_OPTION_TIME :
        case MADCAP_OPTION_RETRY_TIME :
            fprint_time = TRUE;

        case MADCAP_OPTION_LEASE_TIME :
        case MADCAP_OPTION_MCAST_SCOPE :
        case MADCAP_OPTION_ADDR_COUNT :
        case MADCAP_OPTION_MIN_LEASE_TIME :
            
            //
            // print DWORD
            //
            if( sizeof(DWORD) != OptionLength ) break;
            Value = ntohl(*(DWORD UNALIGNED *)Buffer);

            if( fprint_time ) {
                convert_time(Value, time_buf);
            }
            
            printf(
                "    Option %-20s :%s%ld\n",
                madcap_option_list[OptionType], time_buf, Value
                );
            return;

        case MADCAP_OPTION_SERVER_ID :

            //
            // 
            //
            AddressFamily = (unsigned long)*Buffer;
            if( AF_INET != AddressFamily ) break;
            if( sizeof(ipaddr) + 1 != OptionLength ) break;
            Buffer ++;
            ipaddr = *((struct in_addr UNALIGNED *)Buffer);
            printf(
                "    Option %-20s : %s\n",
                madcap_option_list[OptionType], inet_ntoa(ipaddr)
                );
            return;

        }
            
    } while ( 0 );

    //
    // some error..
    //
    
    if( OptionType > (unsigned long)nOptions ) {
        printf("    Option %-20ld : ", OptionType );
    } else printf("    Option %-20s : ", madcap_option_list[OptionType]);
    
    DumpBytes(0, 32, 16,  ' ', Buffer, OptionLength); printf("\n");
}

void DumpMadcap(
    char *Buffer,
    unsigned long Size
    )
{
    PMADCAP_MESSAGE Message = (PMADCAP_MESSAGE) Buffer;
    MADCAP_OPTION_HEADER Header;
    unsigned long DumpedSize;

    DumpBytes(8, 32, 16, ' ', Buffer, Size); printf("\n\n");
    
    printf(
        "    %s Xid:0x%lx Version:0x%lx AddressFamily:0x%lx\n",
        MadcapMessageType(Message->MessageType),
        ntohl(Message->TransactionID), (DWORD)Message->Version, (DWORD)Message->MessageType,
        (DWORD)ntohs(Message->AddressFamily)
        );

    Buffer += sizeof(MADCAP_MESSAGE);
    DumpedSize = sizeof(MADCAP_MESSAGE);

    while( DumpedSize + sizeof(Header) <= Size ) {
        DumpedSize += sizeof(Header);
        Header = *(MADCAP_OPTION_HEADER UNALIGNED *)Buffer;
        Buffer += sizeof(Header);
        Header.Type = ntohs(Header.Type);
        Header.Length = ntohs(Header.Length);
        if( DumpedSize + Header.Length > Size ) {
            printf("    Type: 0x%lx, Length 0x%lx overrruns message end.\n",
                   Header.Type, Header.Length);
            break;
            
        } else {

            DumpMadcapOption(Header.Type, Header.Length, Buffer);
            Buffer += Header.Length;
            DumpedSize += Header.Length;

            if( Header.Type == MADCAP_OPTION_END ) break;
        }
    }

    if( DumpedSize < Size ) {
        printf("    Trailing bytes:\n");
        DumpBytes(4, 16, 8, ' ', Buffer, Size - DumpedSize );
        printf("\n");
    }

    printf("\n");
}

void DumpDhcp(
    char *Buffer,
    unsigned long Size
    )
{
    
}

void DumpBuffer(
    char *Buffer,
    unsigned long Size
    )
{
    PIP_HEADER Ip;
    PUDP_HEADER Udp;
    unsigned long IpLength, UdpLength;
    unsigned long SrcPort, DestPort;
    int IsDhcp, IsMadcap;
    char time_buf[100];
    char *proto;
    
    Ip = (PIP_HEADER)Buffer;
    
    if( Size < sizeof(IP_HEADER) ) {
        DumpInt("IP header too small 0x%lx\n", Size);
    } else if( (IpLength = 4*((unsigned long)Ip->HeaderLen)) < sizeof(IP_HEADER ) ) {
        DumpInt("IP header reports wrong length 0x%lx\n", IpLength);
    } else if( (UdpLength = ntohs(Ip->Length)) < IpLength ) {
        DumpInt("Data length incorrect: 0x%lx\n", UdpLength);
    } else if( Ip->Proto != IPPROTO_UDP ) {
        //
        // Not UDP so ignore it
        //
    } else if( (UdpLength -= IpLength) < sizeof(UDP_HEADER)) {
        DumpInt("UDP Header size too small: 0x%lx\n", UdpLength);
    } else do {
        Udp = (PUDP_HEADER)(Buffer + IpLength);

        UdpLength = ntohs(Udp->Length) - sizeof(UDP_HEADER);

        Buffer = (char *)(&Udp[1]);
        SrcPort = ntohs(Udp->SourcePort);
        DestPort = ntohs(Udp->DestPort);
        
        IsDhcp = (SrcPort == DHCP_SERVER_PORT || DestPort == DHCP_SERVER_PORT
                  || SrcPort == DHCP_CLIENT_PORT || DestPort == DHCP_CLIENT_PORT );
        IsMadcap = (DestPort == MADCAP_SERVER_PORT || SrcPort == MADCAP_SERVER_PORT);

        if( IsMadcap ) {
            proto = "MADCAP";
        } else if( IsDhcp ) {
            if( !show_headers && !show_all ) break;
            proto = "DHCP" ;
        } else {
            if( !show_all ) break;
            proto = "UDP" ;
        }
        
        _strtime(time_buf); printf("%s ", time_buf);
        printf("%s ", proto );
        printf("%s:%ld ---> ", inet_ntoa(Ip->Source), ntohs(Udp->SourcePort));
        printf("%s:%ld ", inet_ntoa(Ip->Dest), ntohs(Udp->DestPort));
        printf("%ld bytes\n", UdpLength);

        if( IsMadcap ) DumpMadcap(Buffer, UdpLength);
        // else if( IsDhcp ) DumpDhcp(Buffer, UdpLength);
        else {
            if( show_headers ) break;
        
            DumpBytes( 8, 32, 16, ' ', Buffer, UdpLength );
            printf("\n\n");
        }
        
    } while ( 0 );        
}

char Buffer[70000];
struct sockaddr_in SockAddr;

void _cdecl main (int argc, char *argv[])
{
    SOCKET s;
    int Error;
    DWORD RecvCount, Flags, dwEnable, dwDontCare;
    WSABUF WsaBufs[1];
    WSADATA WsaData;
    char *ipaddrstring = "0.0.0.0";

    if( argc > 1 ) {
        ipaddrstring = argv[1];
    }

    show_all = 0;
    show_headers = 0;
    
    if( argc > 2 ) {
        if( 0 == _stricmp(argv[2], "all" ) ) show_all = 1;
        else if( 0 == _stricmp(argv[2], "hdr") ) show_headers = 1;
        else usage();
    }

    if( argc > 3 ) {
        if( 0 == _stricmp(argv[3], "all" ) ) show_all = 1;
        else if( 0 == _stricmp(argv[3], "hdr") ) show_headers = 1;
        else usage();
    }
    
    Error = WSAStartup(MAKEWORD(2,0), &WsaData);
    if( 0 != Error ) {
        socket_error("WSAStartup");
    }
    
    s = WSASocket(
        AF_INET, SOCK_RAW, IPPROTO_IGMP, NULL, 0, 0
        );
    if( INVALID_SOCKET == s ) {
        socket_error("WSASocket");
    }

    SockAddr.sin_family = PF_INET;
    SockAddr.sin_addr.s_addr = inet_addr(ipaddrstring);
    
    Error = bind(s, (struct sockaddr *)&SockAddr, sizeof(SockAddr));
    if( 0 != Error ) {
        socket_error("bind");
    }

    dwEnable = 1;
    Error = WSAIoctl(
        s, SIO_RCVALL, (char *)&dwEnable, sizeof(dwEnable),
        NULL, 0, &dwDontCare, NULL, NULL
        );
    if( 0 != Error ) {
        socket_error("SIO_RCVALL");
    }
    
    while ( TRUE ) {
        WsaBufs[0].len = sizeof(Buffer);
        WsaBufs[0].buf = (char *)Buffer;
        Flags = 0;
        Error = WSARecv(
            s, WsaBufs, sizeof(WsaBufs)/sizeof(WsaBufs[0]),
            &RecvCount, &Flags, NULL, NULL
            );
        if( 0 != Error ) {
            socket_error("WSARecv");
        }
        DumpBuffer((char*)Buffer, RecvCount);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\nlanotif.h ===
#pragma once

//-------- exported variables --------
extern CRITICAL_SECTION gNLA_LPC_CS;
extern HANDLE ghNLA_LPC_Port;

//-------- exported functions --------
HANDLE NLAConnectLPC();
void NLANotifyDHCPChange();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\mdhcpcli.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mdhccapi.c

Abstract:

    This file contains the client side APIs for the Madcap.

Author:

    Munil Shah (munils)  02-Sept-97

Environment:

    User Mode - Win32

Revision History:


--*/
#include "precomp.h"
#include "dhcpglobal.h"
#include <dhcploc.h>
#include <dhcppro.h>
#define MADCAP_DATA_ALLOCATE
#include "mdhcpcli.h"
#include <rpc.h>

//
// constants
//
#define Madcap_ADAPTER_NAME L"Madcap Adapter"

#define MadcapMiscPrint( Msg ) DhcpPrint(( DEBUG_MISC, ( Msg ) ))

static
LONG        Initialized = 0;

WSADATA MadcapGlobalWsaData;

DWORD
MadcapInitGlobalData(
    VOID
)
/*++

Routine Description:

    This routine initializes data required for Multicast APIs to work
    correctly.  This has to be called exactly once (and this is ensured
    by calling it in DLL init in dhcp.c )

Return Value:

    This function returns a Win32 status.

--*/
{
    DWORD  Error;

    LOCK_MSCOPE_LIST();

    do {

        if( Initialized > 0 ) {
            Initialized ++;
            Error = NO_ERROR;
            break;
        }

        gMadcapScopeList = NULL;
        gMScopeQueryInProgress = FALSE;
        gMScopeQueryEvent =
            CreateEvent(
                NULL,       // no security.
                TRUE,       // manual reset.
                FALSE,      // initial state is not-signaled.
                NULL );     // no name.
        if( gMScopeQueryEvent == NULL ) {
            Error = GetLastError();
            break;
        }

        Error = WSAStartup( 0x0101, &MadcapGlobalWsaData );
        if( ERROR_SUCCESS != Error ) {
            CloseHandle(gMScopeQueryEvent);
            gMScopeQueryEvent = NULL;

            break;
        }

        Initialized ++;
        Error = NO_ERROR;
    } while ( 0 );
    UNLOCK_MSCOPE_LIST();

    return Error;
}

VOID
MadcapCleanupGlobalData(
    VOID
)
/*++

Routine Description:

    This routine cleans up any resources allocated in MadcapInitGlobalData.
    This can be called even if the InitData routine fails..

Return Value:

    Nothing
--*/
{
    LOCK_MSCOPE_LIST();

    do {
        DhcpAssert(Initialized >= 0);
        if( Initialized <= 0 ) break;

        Initialized --;
        if( 0 != Initialized ) break;

        gMadcapScopeList = NULL;
        gMScopeQueryInProgress = FALSE;
        if( NULL != gMScopeQueryEvent ) {
            CloseHandle(gMScopeQueryEvent);
            gMScopeQueryEvent = NULL;
        }

        WSACleanup();
    } while ( 0 );

    UNLOCK_MSCOPE_LIST();
}


BOOL
ShouldRequeryMScopeList()
/*++

Routine Description:

    This routine checks if the multicast scope list can be
    queried or not.
    * If there is already a query in progress, then this routine
      waits for that to complete and then returns FALSE.
    * If there is no query in progress, it returns TRUE.

Arguments:


Return Value:

    The status of the operation.

--*/
{
    LOCK_MSCOPE_LIST();
    if ( gMScopeQueryInProgress ) {
        DWORD   result;
        DhcpPrint((DEBUG_API, "MScopeQuery is in progress - waiting\n"));
        // make sure the event is not in signalled state from before.
        ResetEvent( gMScopeQueryEvent );
        UNLOCK_MSCOPE_LIST();
        switch( result = WaitForSingleObject( gMScopeQueryEvent, INFINITE ) ) {
        case WAIT_OBJECT_0:
            // it's signled now, no need to requery the list, just take the result from previous query.
            DhcpPrint((DEBUG_API, "MScopeQuery event signalled\n"));
            return FALSE;
        case WAIT_ABANDONED:
            DhcpPrint((DEBUG_ERRORS, "WaitForSingleObject - thread died before the wait completed\n"));
            return TRUE;
        case WAIT_FAILED:
            DhcpPrint((DEBUG_ERRORS, "WaitForSingleObject failed - %lx\n",GetLastError()));
            DhcpAssert(FALSE);
        default:
            DhcpPrint((DEBUG_ERRORS, "WaitForSingleObject returned unknown value - %lx\n", result));
            DhcpAssert(FALSE);
            return TRUE;
        }
    } else {
        gMScopeQueryInProgress = TRUE;
        UNLOCK_MSCOPE_LIST();
        return TRUE;
    }
}

DWORD
InitializeMadcapSocket(
    SOCKET *Socket,
    DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:

    This function initializes and binds a socket to the specified IP address.

Arguments:

    Socket - Returns a pointer to the initialized socket.

    IpAddress - The IP address to bind the socket to.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    DWORD closeError;
    DWORD value;
    struct sockaddr_in socketName;
    DWORD i;
    SOCKET sock;

    //
    // Sockets initialization
    //

    sock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( sock == INVALID_SOCKET ) {
        error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "socket failed, error = %ld\n", error ));
        return( error );
    }

    //
    // Make the socket share-able
    //

    value = 1;

    error = setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, (char FAR *)&value, sizeof(value) );
    if ( error != 0 ) {
        error = WSAGetLastError();
        DhcpPrint((DEBUG_ERRORS, "setsockopt failed, err = %ld\n", error ));

        closeError = closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint((DEBUG_ERRORS, "closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }


    socketName.sin_family = PF_INET;
    socketName.sin_port = 0; // let the winsock pick a port for us.
    socketName.sin_addr.s_addr = IpAddress;

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    //
    // Bind this socket to the DHCP server port
    //

    error = bind(
               sock,
               (struct sockaddr FAR *)&socketName,
               sizeof( socketName )
               );

    if ( error != 0 ) {
        error = WSAGetLastError();
        DhcpPrint((DEBUG_ERRORS, "bind failed, err = %ld\n", error ));
        closeError = closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint((DEBUG_ERRORS, "closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    // set the multicast IF to be the one on which we are doing Madcap
    if (INADDR_ANY != IpAddress) {
        value = IpAddress;

        DhcpPrint((DEBUG_ERRORS, "setsockopt: IP_MULTICAST_IF, if = %lx\n", IpAddress ));
        error = setsockopt( sock, IPPROTO_IP, IP_MULTICAST_IF,
                            (char FAR *)&value, sizeof(value) );
        if ( error != 0 ) {
            error = WSAGetLastError();
            DhcpPrint((DEBUG_ERRORS, "setsockopt failed, err = %ld\n", error ));

            closeError = closesocket( sock );
            if ( closeError != 0 ) {
                DhcpPrint((DEBUG_ERRORS, "closesocket failed, err = %d\n", closeError ));
            }
            return( error );
        }
    }

    *Socket = sock;
    return( NO_ERROR );
}

DWORD
ReInitializeMadcapSocket(
    SOCKET *Socket,
    DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:

    This function closes and reinitializes the socket to specified IP address.

Arguments:

    Socket - Returns a pointer to the initialized socket.

    IpAddress - The IP address to bind the socket to.

Return Value:

    The status of the operation.

--*/
{
    DWORD   Error;

    if (*Socket != INVALID_SOCKET) {
        Error = closesocket( *Socket );
        if ( Error != 0 ) {
            DhcpPrint((DEBUG_ERRORS, "closesocket failed, err = %d\n", Error ));
            return Error;
        }
    }
    return InitializeMadcapSocket( Socket, IpAddress );
}

DWORD
OpenMadcapSocket(
    PDHCP_CONTEXT DhcpContext
    )
{

    DWORD Error;
    PLOCAL_CONTEXT_INFO localInfo;
    struct sockaddr_in socketName;
    int sockAddrLen;

    localInfo = DhcpContext->LocalInformation;

    if ( INVALID_SOCKET == localInfo->Socket ) {
        Error =  InitializeMadcapSocket(&localInfo->Socket, DhcpContext->IpAddress);

        if( Error != ERROR_SUCCESS ) {
            localInfo->Socket = INVALID_SOCKET;
            DhcpPrint(( DEBUG_ERRORS, " Socket Open failed, %ld\n", Error ));
            return Error;
        }
    }


    // find out which port we are bound to.
    sockAddrLen = sizeof(struct sockaddr_in);
    Error = getsockname(
               localInfo->Socket ,
               (struct sockaddr FAR *)&socketName,
               &sockAddrLen
               );

    if ( Error != 0 ) {
        DWORD closeError;
        Error = WSAGetLastError();
        DhcpPrint((DEBUG_ERRORS, "bind failed, err = %ld\n", Error ));
        closeError = closesocket( localInfo->Socket );
        if ( closeError != 0 ) {
            DhcpPrint((DEBUG_ERRORS, "closesocket failed, err = %d\n", closeError ));
        }
        return( Error );
    }


    return(Error);
}

DWORD
CreateMadcapContext(
    IN OUT  PDHCP_CONTEXT  *ppContext,
    IN LPMCAST_CLIENT_UID    pRequestID,
    IN DHCP_IP_ADDRESS      IpAddress
    )
/*++

Routine Description:

    This routine creates a dummy context for doing Madcap operation
    on it.

Arguments:

    ppContext - pointer to where context pointer is to be stored.

    pRequestID - The client id to be used in the context.

    IpAddress - The ipaddress the context is initialized with.

Return Value:

    The status of the operation.

--*/
{
    DWORD Error;
    PDHCP_CONTEXT DhcpContext = NULL;
    ULONG DhcpContextSize;
    PLOCAL_CONTEXT_INFO LocalInfo = NULL;
    LPVOID Ptr;
    LPDHCP_LEASE_INFO LocalLeaseInfo = NULL;
    time_t LeaseObtained;
    DWORD T1, T2, Lease;
    DWORD   AdapterNameLen;


    //
    // prepare dhcp context structure.
    //

    DhcpContextSize =
        ROUND_UP_COUNT(sizeof(DHCP_CONTEXT), ALIGN_WORST) +
        ROUND_UP_COUNT(pRequestID->ClientUIDLength, ALIGN_WORST) +
        ROUND_UP_COUNT(sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST) +
        ROUND_UP_COUNT(DHCP_RECV_MESSAGE_SIZE, ALIGN_WORST);

    Ptr = DhcpAllocateMemory( DhcpContextSize );
    if ( Ptr == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    RtlZeroMemory( Ptr, DhcpContextSize );

    //
    // make sure the pointers are aligned.
    //

    DhcpContext = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(DHCP_CONTEXT), ALIGN_WORST);

    DhcpContext->ClientIdentifier.pbID = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + pRequestID->ClientUIDLength, ALIGN_WORST);

    DhcpContext->LocalInformation = Ptr;
    LocalInfo = Ptr;
    Ptr = ROUND_UP_POINTER( (LPBYTE)Ptr + sizeof(LOCAL_CONTEXT_INFO), ALIGN_WORST);

    DhcpContext->MadcapMessageBuffer = Ptr;


    //
    // initialize fields.
    //


    DhcpContext->ClientIdentifier.fSpecified = TRUE;
    DhcpContext->ClientIdentifier.bType = HARDWARE_TYPE_NONE;
    DhcpContext->ClientIdentifier.cbID = pRequestID->ClientUIDLength;
    RtlCopyMemory(
        DhcpContext->ClientIdentifier.pbID,
        pRequestID->ClientUID,
        pRequestID->ClientUIDLength
        );

    DhcpContext->IpAddress = IpAddress;
    DhcpContext->SubnetMask = DhcpDefaultSubnetMask(0);
    DhcpContext->DhcpServerAddress = MADCAP_SERVER_IP_ADDRESS;
    DhcpContext->DesiredIpAddress = 0;


    SET_MDHCP_STATE(DhcpContext);

    InitializeListHead(&DhcpContext->RenewalListEntry);
    InitializeListHead(&DhcpContext->SendOptionsList);
    InitializeListHead(&DhcpContext->RecdOptionsList);
    InitializeListHead(&DhcpContext->FbOptionsList);
    InitializeListHead(&DhcpContext->NicListEntry);

    DhcpContext->DontPingGatewayFlag = TRUE;

    //
    // copy local info.
    //

    //
    // unused portion of the local info.
    //

    LocalInfo->IpInterfaceContext = 0xFFFFFFFF;
    LocalInfo->IpInterfaceInstance = 0xFFFFFFFF;
    LocalInfo->AdapterName = NULL;
    LocalInfo->NetBTDeviceName= NULL;
    LocalInfo->RegistryKey= NULL;
    LocalInfo->Socket = INVALID_SOCKET;
    LocalInfo->DefaultGatewaysSet = FALSE;

    //
    // used portion of the local info.
    //

    LocalInfo->Socket = INVALID_SOCKET;

    //
    // open socket now. receive any.
    //

    Error = InitializeMadcapSocket(&LocalInfo->Socket,DhcpContext->IpAddress);

    if( Error != ERROR_SUCCESS ) {
        DhcpFreeMemory( DhcpContext );
        return Error;
    } else {
        *ppContext = DhcpContext;
        return Error;
    }

}

DWORD
SendMadcapMessage(
    PDHCP_CONTEXT DhcpContext,
    DWORD MessageLength,
    PDWORD TransactionId
    )
/*++

Routine Description:

    This function sends a UDP message to the DHCP server specified
    in the DhcpContext.

Arguments:

    DhcpContext - A pointer to a DHCP context block.

    MessageLength - The length of the message to send.

    TransactionID - The transaction ID for this message.  If 0, the
        function generates a random ID, and returns it.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    int i;
    struct sockaddr_in socketName;
    time_t TimeNow;
    BOOL   LockedInterface = FALSE;

    if ( *TransactionId == 0 ) {
        *TransactionId = (rand() << 16) + rand();
    }

    DhcpContext->MadcapMessageBuffer->TransactionID = *TransactionId;

    //
    // Initialize the outgoing address.
    //

    socketName.sin_family = PF_INET;
    socketName.sin_port = htons( MADCAP_SERVER_PORT);

    socketName.sin_addr.s_addr = DhcpContext->DhcpServerAddress;
    if ( CLASSD_NET_ADDR( DhcpContext->DhcpServerAddress ) ) {
        int   TTL = 16;
        //
        // Set TTL
        // MBUG: we need to read this from the registry.
        //
        if (setsockopt(
              ((PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation)->Socket,
              IPPROTO_IP,
              IP_MULTICAST_TTL,
              (char *)&TTL,
              sizeof((int)TTL)) == SOCKET_ERROR){

             error = WSAGetLastError();
             DhcpPrint((DEBUG_ERRORS,"could not set MCast TTL %ld\n",error ));
             return error;
        }

    }

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    error = sendto(
                ((PLOCAL_CONTEXT_INFO)
                    DhcpContext->LocalInformation)->Socket,
                (PCHAR)DhcpContext->MadcapMessageBuffer,
                MessageLength,
                0,
                (struct sockaddr *)&socketName,
                sizeof( struct sockaddr )
                );

    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Send failed, error = %ld\n", error ));
    } else {
        IF_DEBUG( PROTOCOL ) {
            DhcpPrint(( DEBUG_PROTOCOL, "Sent message to %s: \n", inet_ntoa( socketName.sin_addr )));
        }

        MadcapDumpMessage(
            DEBUG_PROTOCOL_DUMP,
            DhcpContext->MadcapMessageBuffer,
            DHCP_MESSAGE_SIZE
            );
        error = NO_ERROR;
    }

    return( error );
}

WIDE_OPTION UNALIGNED *                                           // ptr to add additional options
FormatMadcapCommonMessage(                                 // format the packet for an INFORM
    IN      PDHCP_CONTEXT          DhcpContext,    // format for this context
    IN      BYTE                  MessageType
) {

    DWORD                          size;
    DWORD                          Error;
    WIDE_OPTION UNALIGNED         *option;
    LPBYTE                         OptionEnd;
    PMADCAP_MESSAGE                  dhcpMessage;

    dhcpMessage = DhcpContext->MadcapMessageBuffer;
    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );

    dhcpMessage->Version = MADCAP_VERSION;
    dhcpMessage->MessageType = MessageType;
    dhcpMessage->AddressFamily = htons(MADCAP_ADDR_FAMILY_V4);

    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;



    option = AppendWideOption(        // ==> use this client id as option
        option,
        MADCAP_OPTION_LEASE_ID,
        DhcpContext->ClientIdentifier.pbID,
        (WORD)DhcpContext->ClientIdentifier.cbID,
        OptionEnd
    );

    return( option );
}


DWORD                                             // status
SendMadcapInform(                                   // send an inform packet after filling required options
    IN      PDHCP_CONTEXT          DhcpContext,   // sned out for this context
    IN OUT  DWORD                 *pdwXid         // use this Xid (if zero fill something and return it)
) {
    DWORD                          size;
    WIDE_OPTION  UNALIGNED *       option;
    LPBYTE                         OptionEnd;
    WORD    OptVal[] = { // for now we just need this one option.
        htons(MADCAP_OPTION_MCAST_SCOPE_LIST) // multicast scope list.
    };

    option = FormatMadcapCommonMessage(DhcpContext, MADCAP_INFORM_MESSAGE);
    OptionEnd = (LPBYTE)(DhcpContext->MadcapMessageBuffer) + DHCP_SEND_MESSAGE_SIZE;

    option = AppendWideOption(
        option,
        MADCAP_OPTION_REQUEST_LIST,
        OptVal,
        sizeof (OptVal),
        OptionEnd
    );

    option = AppendWideOption( option, MADCAP_OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MadcapMessageBuffer);

    return  SendMadcapMessage(                      // finally send the message and return
        DhcpContext,
        size,
        pdwXid
    );
}

DWORD                                             // status
SendMadcapDiscover(                                   // send an inform packet after filling required options
    IN     PDHCP_CONTEXT          DhcpContext,   // sned out for this context
    IN     PIPNG_ADDRESS          pScopeID,
    IN     PMCAST_LEASE_REQUEST   pAddrRequest,
    IN OUT  DWORD                 *pdwXid         // use this Xid (if zero fill something and return it)
) {
    DWORD                          size;
    WIDE_OPTION  UNALIGNED *       option;
    LPBYTE                         OptionEnd;

    option = FormatMadcapCommonMessage(DhcpContext, MADCAP_DISCOVER_MESSAGE);
    OptionEnd = (LPBYTE)(DhcpContext->MadcapMessageBuffer) + DHCP_SEND_MESSAGE_SIZE;

    DhcpAssert(pScopeID);
    option = AppendWideOption(
        option,
        MADCAP_OPTION_MCAST_SCOPE,
        (LPBYTE)&pScopeID->IpAddrV4,
        sizeof (pScopeID->IpAddrV4),
        OptionEnd
    );

    if (pAddrRequest->LeaseDuration) {
        DWORD   Lease = htonl(pAddrRequest->LeaseDuration);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_LEASE_TIME,
            (LPBYTE)&Lease,
            sizeof (Lease),
            OptionEnd
        );
    }

    if( pAddrRequest->MinLeaseDuration ) {
        DWORD MinLease = htonl(pAddrRequest->MinLeaseDuration);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_MIN_LEASE_TIME,
            (LPBYTE)&MinLease,
            sizeof(MinLease),
            OptionEnd
            );
    }

    if( pAddrRequest->MaxLeaseStartTime ) {
        DWORD   TimeNow = htonl((DWORD)time(NULL));
        DWORD   StartTime = htonl(pAddrRequest->MaxLeaseStartTime);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_MAX_START_TIME,
            (LPBYTE)&StartTime,
            sizeof (StartTime),
            OptionEnd
        );

        if( !(pAddrRequest->LeaseStartTime) ) {
            //
            // if lease start time specified, then current time
            // option will be added at a later point
            //
            option = AppendWideOption(
                option,
                MADCAP_OPTION_TIME,
                (LPBYTE)&TimeNow,
                sizeof (TimeNow),
                OptionEnd
            );
        }
    }

    if (pAddrRequest->LeaseStartTime) {
        DWORD   TimeNow = htonl((DWORD)time(NULL));
        DWORD   StartTime = htonl(pAddrRequest->LeaseStartTime);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_START_TIME,
            (LPBYTE)&StartTime,
            sizeof (StartTime),
            OptionEnd
        );

        option = AppendWideOption(
            option,
            MADCAP_OPTION_TIME,
            (LPBYTE)&TimeNow,
            sizeof (TimeNow),
            OptionEnd
        );

    }

    option = AppendWideOption( option, MADCAP_OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MadcapMessageBuffer);

    return  SendMadcapMessage(                      // finally send the message and return
        DhcpContext,
        size,
        pdwXid
    );
}

DWORD                                             // status
SendMadcapRequest(                                   //
    IN      PDHCP_CONTEXT        DhcpContext,   // sned out for this context
    IN      PIPNG_ADDRESS        pScopeID,
    IN      PMCAST_LEASE_REQUEST pAddrRequest,
    IN      DWORD                SelectedServer, // is there a prefernce for a server?
    IN OUT  DWORD                *pdwXid         // use this Xid (if zero fill something and return it)
) {
    DWORD                          size;
    WIDE_OPTION  UNALIGNED *       option;
    LPBYTE                         OptionEnd;
    BYTE                           ServerId[6];
    WORD                           AddrFamily = htons(MADCAP_ADDR_FAMILY_V4);


    option = FormatMadcapCommonMessage(DhcpContext, MADCAP_REQUEST_MESSAGE);
    OptionEnd = (LPBYTE)(DhcpContext->MadcapMessageBuffer) + DHCP_SEND_MESSAGE_SIZE;
    option = AppendMadcapAddressList(
        option,
        (DWORD UNALIGNED *)pAddrRequest->pAddrBuf,
        pAddrRequest->AddrCount,
        OptionEnd
    );

    option = AppendWideOption(
        option,
        MADCAP_OPTION_MCAST_SCOPE,
        (LPBYTE)&pScopeID->IpAddrV4,
        sizeof (pScopeID->IpAddrV4),
        OptionEnd
    );

    if (pAddrRequest->LeaseDuration) {
        DWORD   TimeNow = (DWORD)time(NULL);
        DWORD   Lease = htonl(pAddrRequest->LeaseDuration);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_LEASE_TIME,
            (LPBYTE)&Lease,
            sizeof (Lease),
            OptionEnd
        );
    }

    if( pAddrRequest->MinLeaseDuration ) {
        DWORD MinLease = htonl(pAddrRequest->MinLeaseDuration);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_MIN_LEASE_TIME,
            (LPBYTE)&MinLease,
            sizeof(MinLease),
            OptionEnd
            );
    }

    if( pAddrRequest->MaxLeaseStartTime ) {
        DWORD   TimeNow = htonl((DWORD)time(NULL));
        DWORD   StartTime = htonl(pAddrRequest->MaxLeaseStartTime);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_MAX_START_TIME,
            (LPBYTE)&StartTime,
            sizeof (StartTime),
            OptionEnd
        );

        if( !(pAddrRequest->LeaseStartTime) ) {
            //
            // if lease start time specified, then current time
            // option will be added at a later point
            //
            option = AppendWideOption(
                option,
                MADCAP_OPTION_TIME,
                (LPBYTE)&TimeNow,
                sizeof (TimeNow),
                OptionEnd
            );
        }
    }

    if (pAddrRequest->LeaseStartTime) {
        DWORD   TimeNow = htonl((DWORD)time(NULL));
        DWORD   StartTime = htonl(pAddrRequest->LeaseStartTime);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_START_TIME,
            (LPBYTE)&StartTime,
            sizeof (StartTime),
            OptionEnd
        );

        option = AppendWideOption(
            option,
            MADCAP_OPTION_TIME,
            (LPBYTE)&TimeNow,
            sizeof (TimeNow),
            OptionEnd
        );

    }

    memcpy(ServerId, &AddrFamily, 2);
    memcpy(ServerId + 2, &SelectedServer, 4);

    option = AppendWideOption(
        option,                               // append this option to talk to that server alone
        MADCAP_OPTION_SERVER_ID,
        (LPBYTE)&ServerId,
        sizeof( ServerId ),
        OptionEnd
    );

    option = AppendWideOption( option, MADCAP_OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MadcapMessageBuffer);

    return  SendMadcapMessage(                      // finally send the message and return
        DhcpContext,
        size,
        pdwXid
    );
}

DWORD                                             // status
SendMadcapRenew(                                   // send an inform packet after filling required options
    IN      PDHCP_CONTEXT          DhcpContext,   // sned out for this context
    IN      PMCAST_LEASE_REQUEST   pAddrRequest,
    IN OUT  DWORD                 *pdwXid         // use this Xid (if zero fill something and return it)
) {
    DWORD                          size;
    WIDE_OPTION  UNALIGNED *       option;
    LPBYTE                         OptionEnd;

    option = FormatMadcapCommonMessage(DhcpContext, MADCAP_RENEW_MESSAGE);
    OptionEnd = (LPBYTE)(DhcpContext->MadcapMessageBuffer) + DHCP_SEND_MESSAGE_SIZE;

    if (pAddrRequest->LeaseDuration) {
        DWORD   Lease = htonl(pAddrRequest->LeaseDuration);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_LEASE_TIME,
            (LPBYTE)&Lease,
            sizeof (Lease),
            OptionEnd
        );
    }

    if( pAddrRequest->MinLeaseDuration ) {
        DWORD MinLease = htonl(pAddrRequest->MinLeaseDuration);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_MIN_LEASE_TIME,
            (LPBYTE)&MinLease,
            sizeof(MinLease),
            OptionEnd
            );
    }

    if( pAddrRequest->MaxLeaseStartTime ) {
        DWORD   TimeNow = htonl((DWORD)time(NULL));
        DWORD   StartTime = htonl(pAddrRequest->MaxLeaseStartTime);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_MAX_START_TIME,
            (LPBYTE)&StartTime,
            sizeof (StartTime),
            OptionEnd
        );

        if( !(pAddrRequest->LeaseStartTime) ) {
            //
            // if lease start time specified, then current time
            // option will be added at a later point
            //
            option = AppendWideOption(
                option,
                MADCAP_OPTION_TIME,
                (LPBYTE)&TimeNow,
                sizeof (TimeNow),
                OptionEnd
            );
        }
    }

    if (pAddrRequest->LeaseStartTime) {
        DWORD   TimeNow = htonl((DWORD)time(NULL));
        DWORD   StartTime = htonl(pAddrRequest->LeaseStartTime);
        option = AppendWideOption(
            option,
            MADCAP_OPTION_START_TIME,
            (LPBYTE)&StartTime,
            sizeof (StartTime),
            OptionEnd
        );

        option = AppendWideOption(
            option,
            MADCAP_OPTION_TIME,
            (LPBYTE)&TimeNow,
            sizeof (TimeNow),
            OptionEnd
        );

    }

    option = AppendWideOption( option, MADCAP_OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MadcapMessageBuffer);

    return  SendMadcapMessage(                      // finally send the message and return
        DhcpContext,
        size,
        pdwXid
    );
}

DWORD                                             // status
SendMadcapRelease(                                   // send an inform packet after filling required options
    IN      PDHCP_CONTEXT          DhcpContext,   // sned out for this context
    IN OUT  DWORD                 *pdwXid         // use this Xid (if zero fill something and return it)
) {
    DWORD                          size;
    WIDE_OPTION  UNALIGNED *       option;
    LPBYTE                         OptionEnd;

    option = FormatMadcapCommonMessage(DhcpContext, MADCAP_RELEASE_MESSAGE);
    OptionEnd = (LPBYTE)(DhcpContext->MadcapMessageBuffer) + DHCP_SEND_MESSAGE_SIZE;
    option = AppendWideOption( option, MADCAP_OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MadcapMessageBuffer);

    return  SendMadcapMessage(                      // finally send the message and return
        DhcpContext,
        size,
        pdwXid
    );
}



#define RATIO 1
DWORD
GetSpecifiedMadcapMessage(
    PDHCP_CONTEXT DhcpContext,
    PDWORD BufferLength,
    DWORD TransactionId,
    DWORD TimeToWait
    )
/*++

Routine Description:

    This function waits TimeToWait seconds to receives the specified
    DHCP response.

Arguments:

    DhcpContext - A pointer to a DHCP context block.

    BufferLength - Returns the size of the input buffer.

    TransactionID - A filter.  Wait for a message with this TID.

    TimeToWait - Time, in milli seconds, to wait for the message.

Return Value:

    The status of the operation.  If the specified message has been
    been returned, the status is ERROR_TIMEOUT.

--*/
{
    struct sockaddr socketName;
    int socketNameSize = sizeof( socketName );
    struct timeval timeout;
    time_t startTime, now;
    DWORD error;
    time_t actualTimeToWait;
    SOCKET clientSocket;
    fd_set readSocketSet;
    PMADCAP_MESSAGE  MadcapMessage;

    startTime = time( NULL );
    actualTimeToWait = TimeToWait;

    //
    // Setup the file descriptor set for select.
    //

    clientSocket = ((PLOCAL_CONTEXT_INFO)DhcpContext->LocalInformation)->Socket;
    MadcapMessage = DhcpContext->MadcapMessageBuffer;

    FD_ZERO( &readSocketSet );
    FD_SET( clientSocket, &readSocketSet );

    while ( 1 ) {

        timeout.tv_sec  = (long)(actualTimeToWait / RATIO);
        timeout.tv_usec = (long)(actualTimeToWait % RATIO);
        DhcpPrint((DEBUG_TRACE, "Select: waiting for: %ld seconds\n", actualTimeToWait));
        error = select( 0, &readSocketSet, NULL, NULL, &timeout );

        if ( error == 0 ) {

            //
            // Timeout before read data is available.
            //

            DhcpPrint(( DEBUG_ERRORS, "Recv timed out\n", 0 ));
            error = ERROR_TIMEOUT;
            break;
        }

        error = recvfrom(
                    clientSocket,
                    (PCHAR)MadcapMessage,
                    *BufferLength,
                    0,
                    &socketName,
                    &socketNameSize
                    );

        if ( error == SOCKET_ERROR ) {
            error = WSAGetLastError();
            DhcpPrint(( DEBUG_ERRORS, "Recv failed, error = %ld\n", error ));

            if( WSAECONNRESET != error ) break;

            //
            // ignore connreset -- this could be caused by someone sending random ICMP port unreachable.
            //
        } else if (error <= MADCAP_MESSAGE_FIXED_PART_SIZE) {
            DhcpPrint(( DEBUG_PROTOCOL, "Received a too short madcap message, length = %lx\n",
                        error ));

        } else if (MadcapMessage->TransactionID == TransactionId ) {

            DhcpPrint(( DEBUG_PROTOCOL,
                            "Received Message, XID = %lx\n",
                            TransactionId));
            // just sanity check the remaining fields
            if ( MADCAP_VERSION == MadcapMessage->Version &&
                 MADCAP_ADDR_FAMILY_V4 == ntohs(MadcapMessage->AddressFamily)) {

                MadcapDumpMessage(
                    DEBUG_PROTOCOL_DUMP,
                    MadcapMessage,
                    DHCP_RECV_MESSAGE_SIZE
                    );

                *BufferLength = error;
                error = NO_ERROR;
                break;
            }

        } else {
            DhcpPrint(( DEBUG_PROTOCOL,
                "Received a buffer with unknown XID = %lx\n",
                    MadcapMessage->TransactionID ));
        }

        //
        // We received a message, but not the one we're interested in.
        // Reset the timeout to reflect elapsed time, and wait for
        // another message.
        //
        now = time( NULL );
        actualTimeToWait = TimeToWait - RATIO * (now - startTime);
        if ( (LONG)actualTimeToWait < 0 ) {
            error = ERROR_TIMEOUT;
            break;
        }
    }


    return( error );
}

//--------------------------------------------------------------------------------
//  This function decides if multicast offer is to be accepted or not.
//--------------------------------------------------------------------------------
BOOL
AcceptMadcapMsg(
    IN DWORD                    MessageType,         // message type to which this response came
    IN PDHCP_CONTEXT            DhcpContext,            // The context of the adapter..
    IN PMADCAP_OPTIONS          MadcapOptions,         // rcvd options.
    IN DHCP_IP_ADDRESS          SelectedServer,         // the server which we care about.
    OUT DWORD                   *Error                   // additional fatal error.
) {

    PMADCAP_MESSAGE MadcapMessage;


    *Error = ERROR_SUCCESS;
    MadcapMessage = DhcpContext->MadcapMessageBuffer;

    if ( !MadcapOptions->ServerIdentifier ){
        DhcpPrint((DEBUG_ERRORS, "Received no server identifier, dropping response\n"));
        return FALSE;
    }

    if ( !MadcapOptions->ClientGuid ){
        DhcpPrint((DEBUG_ERRORS, "Received no client identifier, dropping response\n"));
        return FALSE;
    }

    if (DhcpContext->ClientIdentifier.cbID != MadcapOptions->ClientGuidLength ||
        0 != memcmp(DhcpContext->ClientIdentifier.pbID,
                    MadcapOptions->ClientGuid,
                    MadcapOptions->ClientGuidLength) ) {
        return FALSE;
    }

    if (MadcapOptions->MCastLeaseStartTime && !MadcapOptions->Time) {
        DhcpPrint((DEBUG_ERRORS, "Received start time but no current time\n"));
        return FALSE;
    }
    switch( MessageType ) {
    case MADCAP_INFORM_MESSAGE:
        if (MADCAP_ACK_MESSAGE != MadcapMessage->MessageType) {
            return FALSE;
        }
        break;
    case MADCAP_DISCOVER_MESSAGE:
        if (MADCAP_OFFER_MESSAGE != MadcapMessage->MessageType) {
            return FALSE;
        }
        if (!MadcapOptions->AddrRangeList) {
            return FALSE;
        }
        if (!MadcapOptions->LeaseTime) {
            return FALSE;
        }
        if (!MadcapOptions->McastScope) {
            return FALSE;
        }
        break;
    case MADCAP_RENEW_MESSAGE:
    case MADCAP_REQUEST_MESSAGE:
        if (MADCAP_NACK_MESSAGE == MadcapMessage->MessageType &&
            SelectedServer == *MadcapOptions->ServerIdentifier) {
            DhcpPrint((DEBUG_ERRORS, "Received NACK\n"));
            *Error = ERROR_ACCESS_DENIED;
            return FALSE;
        }
        if (MADCAP_ACK_MESSAGE != MadcapMessage->MessageType) {
            return FALSE;
        }
        if (SelectedServer && SelectedServer != *MadcapOptions->ServerIdentifier) {
            return FALSE;
        }
        if (!MadcapOptions->LeaseTime) {
            return FALSE;
        }
        if (!MadcapOptions->AddrRangeList) {
            return FALSE;
        }
        if (!MadcapOptions->McastScope) {
            return FALSE;
        }
        break;
    case MADCAP_RELEASE_MESSAGE:
        if (MADCAP_ACK_MESSAGE != MadcapMessage->MessageType) {
            return FALSE;
        }

        break;
    default:
        DhcpAssert( FALSE );
        DhcpPrint(( DEBUG_PROTOCOL, "Received Unknown Message.\n"));
        return FALSE;

    }
    // Is this really necessary?
    if (MadcapOptions->Error) {
        return FALSE;
    }

    return TRUE; // accept this message.
}

VOID
MadcapExtractOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,   // input context
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    OUT     PMADCAP_OPTIONS        MadcapOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN      DWORD                  ServerId       // if !LiteOnly this specifies the server which gave this
) {
    WIDE_OPTION UNALIGNED*         NextOpt;
    BYTE        UNALIGNED*         EndOpt;
    WORD                           Size;
    DWORD                          OptionType;
    DWORD                          Error;
    WORD                           AddrFamily;


    EndOpt = OptStart + MessageSize;              // all options should be < EndOpt;
    RtlZeroMemory((LPBYTE)MadcapOptions, sizeof(*MadcapOptions));

    if( 0 == MessageSize ) goto DropPkt;          // nothing to do in this case

    NextOpt = (WIDE_OPTION UNALIGNED*)OptStart;
    while( NextOpt->OptionValue <= EndOpt &&
           MADCAP_OPTION_END != (OptionType = ntohs(NextOpt->OptionType)) ) {

        Size = ntohs(NextOpt->OptionLength);
        if ((NextOpt->OptionValue + Size) > EndOpt) {
            goto DropPkt;
        }

        switch( OptionType ) {
        case MADCAP_OPTION_LEASE_TIME:
            if( Size != sizeof(DWORD) ) goto DropPkt;
            MadcapOptions->LeaseTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_SERVER_ID:
            if (Size != 6) goto DropPkt;
            AddrFamily = ntohs(*(WORD UNALIGNED *)NextOpt->OptionValue);
            if ( MADCAP_ADDR_FAMILY_V4 != AddrFamily ) goto DropPkt;
            MadcapOptions->ServerIdentifier = (DHCP_IP_ADDRESS UNALIGNED *)(NextOpt->OptionValue+2);
            break;
        case MADCAP_OPTION_LEASE_ID:
            if( 0 == Size ) goto DropPkt;
            MadcapOptions->ClientGuidLength = Size;
            MadcapOptions->ClientGuid = NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_MCAST_SCOPE:
            if( Size != sizeof(DWORD) ) goto DropPkt;
            MadcapOptions->McastScope = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_START_TIME:
            if ( Size != sizeof(DATE_TIME) ) goto DropPkt;
            MadcapOptions->MCastLeaseStartTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_ADDR_LIST:
            if( Size % 6 ) goto DropPkt;
            MadcapOptions->AddrRangeList = NextOpt->OptionValue;
            MadcapOptions->AddrRangeListSize = Size;
            break;
        case MADCAP_OPTION_TIME:
            if( Size != sizeof(DWORD) ) goto DropPkt;
            MadcapOptions->Time = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_FEATURE_LIST:
            break;
        case MADCAP_OPTION_RETRY_TIME:
            if( Size != sizeof(DWORD) ) goto DropPkt;
            MadcapOptions->RetryTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_ERROR:
            if( Size != sizeof(DWORD) ) goto DropPkt;
            MadcapOptions->Error = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;


        default:
            // unknowm message, nothing to do.. especially dont log this
            break;
        }
        if (RecdOptions) {
            DhcpAssert(ServerId);
            Error = MadcapAddIncomingOption(        // Now add this option to the list
                RecdOptions,
                OptionType,
                ServerId,
                NextOpt->OptionValue,
                Size,
                (DWORD)INFINIT_TIME
            );
            if (ERROR_SUCCESS != Error) {
                goto DropPkt;
            }
        }
        NextOpt = (WIDE_OPTION UNALIGNED*)(NextOpt->OptionValue + Size);
    } // while NextOpt < EndOpt

    return;

  DropPkt:
    RtlZeroMemory(MadcapOptions, sizeof(MadcapOptions));
    if(RecdOptions) DhcpFreeAllOptions(RecdOptions);// ok undo the options that we just added
}

DWORD
MadcapDoInform(
    IN PDHCP_CONTEXT DhcpContext
)
/*++

Routine Description:

    This routine does the inform part by sending inform messages and
    collecting responses etc. on  given context.
    In case of no-response, no error is returned as a timeout is not
    considered an error.

Arguments:

    DhcpContext -- context to dhcp struct
    fBroadcast -- should the inform be broadcast or unicast?

Return Values:

    Win32 errors

--*/
{
    time_t                         StartTime;
    time_t                         TimeNow;
    time_t                         TimeToWait;
    DWORD                          Error;
    DWORD                          Xid;
    DWORD                          MessageSize;
    DWORD                          RoundNum;
    DWORD                          MessageCount;
    DWORD                          LeaseExpirationTime;
    MADCAP_OPTIONS                 MadcapOptions;
    BOOL                           GotAck;
#define MIN_ACKS_FOR_INFORM        MADCAP_QUERY_SCOPE_LIST_RETRIES
    DWORD                          MadcapServers[MIN_ACKS_FOR_INFORM];

    DhcpPrint((DEBUG_PROTOCOL, "MadcapDoInform entered\n"));


    Xid                           = 0;            // Will be generated by first SendDhcpPacket
    MessageCount                  = 0;            // total # of messages we have got

    TimeToWait = MADCAP_QUERY_SCOPE_LIST_TIME * 1000;
    TimeToWait += ((rand() * ((DWORD) 1000))/RAND_MAX);
    TimeToWait /= 1000;

    for( RoundNum = 0; RoundNum <= MADCAP_QUERY_SCOPE_LIST_RETRIES;  RoundNum ++ ) {

        if( RoundNum != MADCAP_QUERY_SCOPE_LIST_RETRIES ) {
            Error = SendMadcapInform(DhcpContext, &Xid);
            if( ERROR_SUCCESS != Error ) {
                DhcpPrint((DEBUG_ERRORS, "SendMadcapInform: %ld\n", Error));
                goto Cleanup;
            } else {
                DhcpPrint((DEBUG_PROTOCOL, "Sent DhcpInform\n"));
            }
        }

        StartTime  = time(NULL);
        while ( TRUE ) {                          // wiat for the specified wait time
            MessageSize =  DHCP_RECV_MESSAGE_SIZE;

            DhcpPrint((DEBUG_TRACE, "Waiting for ACK[Xid=%x]: %ld seconds\n",Xid, TimeToWait));
            Error = GetSpecifiedMadcapMessage(      // try to receive an ACK
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );
            if ( Error == ERROR_TIMEOUT ) break;
            if( Error != ERROR_SUCCESS ) {
                DhcpPrint((DEBUG_ERRORS, "GetSpecifiedMadcapMessage: %ld\n", Error));
                goto Cleanup;
            }

            MadcapExtractOptions(         // Need to see if this is an ACK
                DhcpContext,
                (LPBYTE)&DhcpContext->MadcapMessageBuffer->Option,
                MessageSize - MADCAP_MESSAGE_FIXED_PART_SIZE,
                &MadcapOptions,                 // check for only expected options
                NULL,                             // unused
                0                                 // unused
            );

            GotAck = AcceptMadcapMsg(       // check up and see if we find this offer kosher
                MADCAP_INFORM_MESSAGE,
                DhcpContext,
                &MadcapOptions,
                0,
                &Error
            );

            if (GotAck) {
                ULONG i;

                for( i = 0; i < MessageCount ; i ++ ) {
                    if( MadcapServers[i] == *MadcapOptions.ServerIdentifier ) {
                        break;
                    }
                }

                if( i == MessageCount && MessageCount < MIN_ACKS_FOR_INFORM ) {
                    MessageCount ++;
                    MadcapServers[i] = *MadcapOptions.ServerIdentifier;
                }

                DhcpPrint((DEBUG_TRACE, "Received %ld ACKS so far\n", MessageCount));
                MadcapExtractOptions(     // do FULL options..
                    DhcpContext,
                    (LPBYTE)&DhcpContext->MadcapMessageBuffer->Option,
                    MessageSize - MADCAP_MESSAGE_FIXED_PART_SIZE,
                    &MadcapOptions,
                    &(DhcpContext->RecdOptionsList),
                    *MadcapOptions.ServerIdentifier
                );
            }

            TimeNow     = time(NULL);             // Reset the time values to reflect new time
            if( TimeToWait < (TimeNow - StartTime) ) {
                break;                            // no more time left to wait..
            }
            TimeToWait -= (TimeNow - StartTime);  // recalculate time now
            StartTime   = TimeNow;                // reset start time also
        } // end of while ( TimeToWait > 0)


        if( MessageCount >= MIN_ACKS_FOR_INFORM ) goto Cleanup;
        if( RoundNum != 0 && MessageCount != 0 ) goto Cleanup;

        TimeToWait = MADCAP_QUERY_SCOPE_LIST_TIME ;
    } // for (RoundNum = 0; RoundNum < nInformsToSend ; RoundNum ++ )

  Cleanup:
    CloseDhcpSocket(DhcpContext);
    if( MessageCount ) Error = ERROR_SUCCESS;
    DhcpPrint((DEBUG_PROTOCOL, "MadcapDoInform: got %d ACKS (returning %ld)\n", MessageCount,Error));
    return Error;
}

DWORD
CopyMScopeList(
    IN OUT PMCAST_SCOPE_ENTRY       pScopeList,
    IN OUT PDWORD             pScopeLen,
    OUT    PDWORD             pScopeCount
    )
/*++

Routine Description:

    This routine obtains the multicast scope list from the Madcap
    server. It sends DHCPINFORM to Madcap multicast address and
    collects all the responses.

Arguments:


Return Value:

    The status of the operation.

--*/
{
    PMCAST_SCOPE_ENTRY pScopeSource;
    DWORD i;

    LOCK_MSCOPE_LIST();
    if ( *pScopeLen >= gMadcapScopeList->ScopeLen ) {
        RtlCopyMemory( pScopeList, gMadcapScopeList->pScopeBuf, gMadcapScopeList->ScopeLen );
        *pScopeLen = gMadcapScopeList->ScopeLen;
        *pScopeCount = gMadcapScopeList->ScopeCount;
        // remember the start pointer because we need to remap all the buffers into client space.
        pScopeSource = gMadcapScopeList->pScopeBuf;

        UNLOCK_MSCOPE_LIST();
        // now remap UNICODE_STRING scope desc to client address space.
        for (i=0;i<*pScopeCount;i++) {
            pScopeList[i].ScopeDesc.Buffer = (USHORT *) ((PBYTE)pScopeList +
                                              ((PBYTE)pScopeList[i].ScopeDesc.Buffer - (PBYTE)pScopeSource));
        }

        return ERROR_SUCCESS;
    } else {
        UNLOCK_MSCOPE_LIST();
        return ERROR_INSUFFICIENT_BUFFER;
    }

}


DWORD
StoreMScopeList(
    IN PDHCP_CONTEXT    pContext,
    IN BOOL             NewList
    )
/*++

Routine Description:

    This routine stores the scope list it retrieved from the inform requests
    into the global scope list..

        the scope option is of the following form.

        ---------------------------------
        | code (2 byte) | length (2byte)|
        ---------------------------------
        | count  ( 4 bytes )            |
        ---------------------------------
        | Scope list
        ---------------------------------

        where scope list is of the following form

        --------------------------------------------------------------------------
        | scope ID(4 byte) | Last Addr(4/16) |TTL(1) | Count (1) | Description...|
        --------------------------------------------------------------------------

        where scope description is of the following form


                    Language Tag
        --------------------------------------------------------------
        | Flags(1) | Tag Length(1) | Tag...| Name Length(1) | Name...|
        --------------------------------------------------------------
Arguments:

    pContext - pointer to the context to be used during inform

    NewList  - TRUE if a new list is to be created o/w prepend the
                current list.

Return Value:

    The status of the operation.

--*/
{
    PBYTE               pOptBuf;
    PBYTE               pOptBufEnd;
    PLIST_ENTRY         pOptionList;
    PDHCP_OPTION        pScopeOption, pFirstOption, pPrevOption;
    DWORD               TotalNewScopeDescLen;
    DWORD               TotalNewScopeCount;
    DWORD               TotalNewScopeListMem;
    PMCAST_SCOPE_LIST   pScopeList;
    PMCAST_SCOPE_ENTRY        pNextScope;
    LPWSTR              pNextUnicodeBuf;
    DWORD               TotalCurrScopeListMem;
    DWORD               TotalCurrScopeCount;
    DWORD               Error;
    DWORD               IpAddrLen;
    BOOL                WellFormed;

    // MBUG - make sure we collect options from all the servers when
    // we do dhcpinform.

    // initialize variables.
    TotalNewScopeCount = TotalCurrScopeCount = 0;
    TotalNewScopeDescLen = 0;
    pScopeList = NULL;
    Error = ERROR_SUCCESS;

    LOCK_MSCOPE_LIST();
    if (FALSE == NewList) {
        TotalCurrScopeListMem = gMadcapScopeList->ScopeLen;
        TotalCurrScopeCount = gMadcapScopeList->ScopeCount;
        DhcpPrint(( DEBUG_API, "StoreMScopeList: appending to CurrScopeLen %ld, ScopeCount %ld\n",
                    gMadcapScopeList->ScopeLen, gMadcapScopeList->ScopeCount ));
    }



    // First calculate the space required for the scope list.
    // pFirstOption is used to track that we traverse the list only once
    pOptionList = &pContext->RecdOptionsList;
    pFirstOption = NULL;
    WellFormed = TRUE;
    while ( ( pScopeOption = DhcpFindOption(
                                pOptionList,
                                MADCAP_OPTION_MCAST_SCOPE_LIST,
                                FALSE,
                                NULL,
                                0,
                                0                    //dont care about serverid
                                )) &&
            ( pScopeOption != pFirstOption ) ) {
        DWORD   ScopeCount;
        DWORD   i;

        // point to the next entry in the list.
        pOptionList = &pScopeOption->OptionList;

        // set the pFirstOption if it is not set already.
        if ( !pFirstOption ) {
            pFirstOption = pScopeOption;
            IpAddrLen = (pScopeOption->OptionVer.Proto == PROTO_MADCAP_V6 ? 16 : 4);
        }

        // if the last option was not well formatted from the list
        // then remove it from the list.
        if (!WellFormed) {
            DhcpDelOption(pPrevOption);

            //we may need to reset first option pointer.
            if (pPrevOption == pFirstOption) {
                pFirstOption = pScopeOption;
            }
        } else {

            WellFormed = FALSE;          // set it back to false for this iteration.
        }
        // save the prev option pointer
        pPrevOption = pScopeOption;

        pOptBuf = pScopeOption->Data;
        pOptBufEnd = pScopeOption->Data + pScopeOption->DataLen;

        ScopeCount = 0;

        // Read the scope count
        if ( pOptBuf  < pOptBufEnd ) {
            ScopeCount = *pOptBuf;
            pOptBuf ++;
        }
        else continue;

        for ( i=0;i<ScopeCount;i++ ) {
            DWORD   ScopeDescLen;
            DWORD   ScopeDescWLen;
            PBYTE   pScopeDesc;
            DWORD   NameCount, TagLen;
            // skip the scopeid, last addr and ttl
            pOptBuf += (2*IpAddrLen + 1);
            // read name count
            if (pOptBuf < pOptBufEnd) {
                NameCount = *pOptBuf;
                pOptBuf++;
            } else break;
            if (0 == NameCount) {
                break;
            }
            do {
                // Skip flags
                pOptBuf++;
                // read language tag len
                if (pOptBuf < pOptBufEnd) {
                    TagLen = *pOptBuf;
                    pOptBuf++;
                }else break;

                // skip the tag
                pOptBuf += TagLen;
                // Read the name length
                if (pOptBuf < pOptBufEnd) {
                    ScopeDescLen = *pOptBuf;
                    ScopeDescWLen = ConvertUTF8ToUnicode(pOptBuf+1, *pOptBuf, NULL, 0);
                    pOptBuf ++;
                } else break;

                // pick the scope name
                pScopeDesc = pOptBuf;
                pOptBuf += ScopeDescLen;
            }while(--NameCount);

            // if formatted correctly namecount should drop to 0
            if (0 != NameCount) {
                break;
            }
            // update total desc len count.
            if ( pOptBuf <= pOptBufEnd ) {
                if (pScopeDesc[ScopeDescLen-1]) { // if not NULL terminated.
                    ScopeDescWLen++;
                }
                TotalNewScopeDescLen += ScopeDescWLen * sizeof(WCHAR);
                TotalNewScopeCount++;
                // Set the wellformed to true so that this option stays
                WellFormed = TRUE;
            }
            else break;

        }

    }

    if ( !TotalNewScopeCount ) {
        DhcpPrint((DEBUG_ERRORS, "StoreMScopeList - no scopes found in the options, bad format..\n"));
        Error = ERROR_BAD_FORMAT;
        goto Cleanup;
    }

    DhcpPrint(( DEBUG_API, "TotalNewScopeCount %d, TotalNewScopeDescLen %d\n",TotalNewScopeCount,TotalNewScopeDescLen));

    // now allocate the memory.
    TotalNewScopeListMem = ROUND_UP_COUNT( sizeof(MCAST_SCOPE_LIST)  +  // scope list struct
                                        sizeof(MCAST_SCOPE_ENTRY) * (TotalNewScopeCount -1),
                                        ALIGN_WORST) + // scope buffers.
                        TotalNewScopeDescLen; // scope descriptors,

    if (FALSE == NewList) {
        TotalNewScopeListMem += TotalCurrScopeListMem;
        TotalNewScopeCount += TotalCurrScopeCount;
    }
    pScopeList = DhcpAllocateMemory( TotalNewScopeListMem );
    if ( !pScopeList ) {
        UNLOCK_MSCOPE_LIST();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( pScopeList, TotalNewScopeListMem );

    pScopeList->ScopeCount = 0; // we will fill this up as we go.
    pScopeList->ScopeLen = TotalNewScopeListMem - sizeof(MCAST_SCOPE_LIST) + sizeof(MCAST_SCOPE_ENTRY);

    // set the first scope pointer.
    pNextScope = pScopeList->pScopeBuf;

    // unicode strings starts after all the fixed sized scope structures.
    pNextUnicodeBuf = (LPWSTR)((PBYTE)pScopeList +
                               ROUND_UP_COUNT( sizeof(MCAST_SCOPE_LIST)  +  // scope list struct
                                               sizeof(MCAST_SCOPE_ENTRY) * (TotalNewScopeCount -1),
                                               ALIGN_WORST));  // scope buffers.

    DhcpPrint(( DEBUG_API, "ScopeList %lx TotalNewScopeListMem %d, ScopeDescBuff %lx\n",
                pScopeList, TotalNewScopeListMem,pNextUnicodeBuf));
    // now repeat the loop and fill up the scopelist.
    pOptionList = &pContext->RecdOptionsList;
    pFirstOption = NULL;

    while ( ( pScopeOption = DhcpFindOption(
                                pOptionList,
                                MADCAP_OPTION_MCAST_SCOPE_LIST,
                                FALSE,
                                NULL,
                                0,
                                0                    //dont care about serverid
                                )) &&
            ( pScopeOption != pFirstOption ) ) {
        DWORD   ScopeCount;
        DWORD   i;
        DHCP_IP_ADDRESS    ServerIpAddr;

        // point to the next entry in the list.
        pOptionList = &pScopeOption->OptionList;

        // set the pFirstOption if it is not set already.
        if ( !pFirstOption ) {
            pFirstOption = pScopeOption;
        }

        pOptBuf = pScopeOption->Data;
        DhcpPrint(( DEBUG_API, "MScopeOption - Data %lx\n", pOptBuf ));
        pOptBufEnd = pScopeOption->Data + pScopeOption->DataLen;


        // store ipaddr
        ServerIpAddr = pScopeOption->ServerId;
        DhcpPrint(( DEBUG_API, "MScopeOption - ServerIpAddr %lx\n", ServerIpAddr ));

        // read the scope count.
        ScopeCount = *pOptBuf; pOptBuf++;
        DhcpPrint(( DEBUG_API, "MScopeOption - ScopeCount %ld\n", ScopeCount ));

        for ( i=0;i<ScopeCount;i++ ) {
            BYTE    ScopeDescLen;
            PBYTE   pScopeDesc;
            IPNG_ADDRESS   ScopeID, LastAddr;
            DWORD   NameCount, TagLen;
            DWORD   TTL;

            // read the scopeid, last addr.
            RtlZeroMemory (&ScopeID, sizeof (ScopeID));
            RtlCopyMemory (&ScopeID, pOptBuf, IpAddrLen);
            pOptBuf += IpAddrLen;

            RtlZeroMemory (&LastAddr, sizeof (ScopeID));
            RtlCopyMemory (&LastAddr, pOptBuf, IpAddrLen);
            pOptBuf += IpAddrLen;

            DhcpPrint(( DEBUG_API, "MScopeOption - ScopeID %lx\n", ntohl(ScopeID.IpAddrV4) ));
            DhcpPrint(( DEBUG_API, "MScopeOption - LastAddr %lx\n", ntohl(LastAddr.IpAddrV4) ));

            TTL = *pOptBuf++;
            NameCount = *pOptBuf++;

            while (NameCount--) {
                // MBUG ignore the flags for now
                pOptBuf++;
                TagLen = *pOptBuf++;
                // MBUG ignore lang tag also
                pOptBuf += TagLen;
                ScopeDescLen = *pOptBuf++;
                pScopeDesc = pOptBuf;
                DhcpPrint(( DEBUG_API, "MScopeOption - ScopeDesc %lx ScopeDescLen %ld\n", pScopeDesc, ScopeDescLen ));

                pOptBuf += ScopeDescLen;
            }

            if ( ScopeDescLen ) {
                BYTE    ScopeDescWLen;
                WORD    MaximumLength;
/*                CHAR    DescAnsi[256];
                WORD    MaximumLength;
                RtlCopyMemory(DescAnsi, pScopeDesc, ScopeDescLen );
                // null terminate it if necessary.
                if ( pScopeDesc[ScopeDescLen - 1] ) {
                    DescAnsi[ScopeDescLen] = '\0';
                    MaximumLength = (ScopeDescLen + 1) * sizeof(WCHAR);
                } else {
                    MaximumLength = (ScopeDescLen) * sizeof(WCHAR);
                }
                pNextUnicodeBuf = DhcpOemToUnicode( DescAnsi, pNextUnicodeBuf ); */
                ScopeDescWLen = (BYTE)ConvertUTF8ToUnicode(pScopeDesc, ScopeDescLen, pNextUnicodeBuf, TotalNewScopeDescLen);
                if ( pNextUnicodeBuf[ScopeDescWLen - 1] ) {
                    pNextUnicodeBuf[ScopeDescWLen] = L'\0';
                    MaximumLength = (ScopeDescWLen + 1) * sizeof(WCHAR);
                } else {
                    MaximumLength = (ScopeDescWLen) * sizeof(WCHAR);
                }
                TotalNewScopeDescLen -= MaximumLength;
                DhcpPrint(( DEBUG_API, "MScopeOption - UnicodeScopeDesc %lx %ws\n",pNextUnicodeBuf, pNextUnicodeBuf));
                RtlInitUnicodeString(&pNextScope->ScopeDesc, pNextUnicodeBuf );
                pNextScope->ScopeDesc.MaximumLength = MaximumLength;
                pNextUnicodeBuf = (LPWSTR)((PBYTE)pNextUnicodeBuf + MaximumLength);
                DhcpAssert((PBYTE)pNextUnicodeBuf <= ((PBYTE)pScopeList + TotalNewScopeListMem));
            } else {
                // set the unicode descriptor string to NULL;
                pNextScope->ScopeDesc.Length = pNextScope->ScopeDesc.MaximumLength = 0;
                pNextScope->ScopeDesc.Buffer = NULL;
            }
            // everything looks good, now fill up the NextScope
            pNextScope->ScopeCtx.ScopeID = ScopeID;
            pNextScope->ScopeCtx.ServerID.IpAddrV4 = ServerIpAddr;
            pNextScope->ScopeCtx.Interface.IpAddrV4 = pContext->IpAddress;
            pNextScope->LastAddr = LastAddr;
            pNextScope->TTL = TTL;

            pNextScope++;
            pScopeList->ScopeCount++;

        }

    }

    DhcpAssert( pScopeList->ScopeCount == (TotalNewScopeCount - TotalCurrScopeCount) );

    // now append the previous scope list if exist.
    if (FALSE == NewList) {
        DWORD           CurrScopeCount;
        PMCAST_SCOPE_ENTRY    CurrScopeNextPtr;

        CurrScopeCount = gMadcapScopeList->ScopeCount;
        CurrScopeNextPtr = gMadcapScopeList->pScopeBuf;
        while(CurrScopeCount--) {
            *pNextScope = *CurrScopeNextPtr;
            // now copy the unicode strings also.
            RtlCopyMemory( pNextUnicodeBuf, CurrScopeNextPtr->ScopeDesc.Buffer, CurrScopeNextPtr->ScopeDesc.MaximumLength);
            pNextScope->ScopeDesc.Buffer = pNextUnicodeBuf ;

            pNextUnicodeBuf = (LPWSTR)((PBYTE)pNextUnicodeBuf + CurrScopeNextPtr->ScopeDesc.MaximumLength);
            pNextScope++; CurrScopeNextPtr++;
        }
        pScopeList->ScopeCount += gMadcapScopeList->ScopeCount;
        DhcpAssert( pScopeList->ScopeCount == TotalNewScopeCount);
    }
    // Finally copy this buffer to our global pointer.
    // first free the existing list.
    if (gMadcapScopeList) DhcpFreeMemory( gMadcapScopeList );
    gMadcapScopeList = pScopeList;



Cleanup:

    UNLOCK_MSCOPE_LIST();
    return Error;
}

DWORD
ObtainMScopeList(
    )
/*++

Routine Description:

    This routine obtains the multicast scope list from the Madcap
    server. It sends DHCPINFORM to Madcap multicast address and
    collects all the responses.

Arguments:


Return Value:

    The status of the operation.

--*/
{
    MCAST_CLIENT_UID             RequestID;
    BYTE                        IDBuf[MCAST_CLIENT_ID_LEN];
    PDHCP_CONTEXT              pContext;
    DWORD                       Error;
    PMIB_IPADDRTABLE            pIpAddrTable;
    PLOCAL_CONTEXT_INFO         localInfo;
    DWORD                       i;
    BOOL                        NewList;

    pContext = NULL;
    Error = ERROR_SUCCESS;
    pIpAddrTable = NULL;

    if ( !ShouldRequeryMScopeList() ) {
        return ERROR_SUCCESS;
    } else {
        RequestID.ClientUID = IDBuf;
        RequestID.ClientUIDLength = MCAST_CLIENT_ID_LEN;

        Error = GenMadcapClientUID( RequestID.ClientUID, &RequestID.ClientUIDLength );
        if ( ERROR_SUCCESS != Error)
            goto Exit;

        Error = CreateMadcapContext(&pContext, &RequestID, INADDR_ANY );
        if ( ERROR_SUCCESS != Error )
            goto Exit;
        APICTXT_ENABLED(pContext);  // mark the context as being created by the API

        localInfo = pContext->LocalInformation;

        // now get primary ipaddresses on each adapter.

        Error = GetIpPrimaryAddresses(&pIpAddrTable);
        if ( ERROR_SUCCESS != Error ) {
            goto Exit;
        }

        DhcpPrint((DEBUG_API, "ObtainMScopeList: ipaddress table has %d addrs\n",
                   pIpAddrTable->dwNumEntries));

        NewList = TRUE;
        Error = ERROR_TIMEOUT;
        for (i = 0; i < pIpAddrTable->dwNumEntries; i++) {
            DWORD           LocalError;
            PMIB_IPADDRROW  pAddrRow;

            pAddrRow = &pIpAddrTable->table[i];
            // if primary bit set this is a primary address.
            if (0 == (pAddrRow->wType & MIB_IPADDR_PRIMARY) ||
                0 == pAddrRow->dwAddr ||
                htonl(INADDR_LOOPBACK) == pAddrRow->dwAddr) {
                continue;
            }

            DhcpPrint((DEBUG_API, "ObtainMScopeList: DoInform on %s interface\n",
                       DhcpIpAddressToDottedString(ntohl(pAddrRow->dwAddr)) ));

            LocalError = ReInitializeMadcapSocket(&localInfo->Socket, pAddrRow->dwAddr);
            if (ERROR_SUCCESS != LocalError) {
                continue;
            }
            pContext->IpAddress = pAddrRow->dwAddr;
            // now do the inform and get scope list.
            LocalError = MadcapDoInform(pContext);
            if ( ERROR_SUCCESS == LocalError ) {
                // now copy the scope list.
                LocalError = StoreMScopeList(pContext, NewList);
                if (ERROR_SUCCESS == LocalError ) {
                    NewList = FALSE;
                    Error = ERROR_SUCCESS;
                }
            }

            LOCK_OPTIONS_LIST();
            DhcpDestroyOptionsList(&pContext->SendOptionsList, &DhcpGlobalClassesList);
            DhcpDestroyOptionsList(&pContext->RecdOptionsList, &DhcpGlobalClassesList);
            UNLOCK_OPTIONS_LIST();

        }

Exit:
        // signal the thread could be waiting on this.
        LOCK_MSCOPE_LIST();
        gMScopeQueryInProgress = FALSE;
        UNLOCK_MSCOPE_LIST();

        SetEvent( gMScopeQueryEvent );

        if ( pContext ) {
            DhcpDestroyContext( pContext );
        }

        if (pIpAddrTable) {
            DhcpFreeMemory( pIpAddrTable );
        }
        return Error;
    }


}

DWORD
GenMadcapClientUID(
    OUT    PBYTE    pRequestID,
    IN OUT PDWORD   pRequestIDLen
)
/*++

Routine Description:

    This routine generates a client UID.

Arguments:

    pRequestID - pointer where client UID is to be stored.

    pRequestIDLen - pointer where the length of request id is stored.

Return Value:


--*/

{
    PULONG     UID;
    RPC_STATUS Status;
    GUID       RequestGuid;

    DhcpAssert( pRequestID && pRequestIDLen );

    if (*pRequestIDLen < MCAST_CLIENT_ID_LEN) {
        DhcpPrint((DEBUG_ERRORS,"GenMadcapId - IDLen too small, %ld\n", *pRequestIDLen ));
        return ERROR_INVALID_PARAMETER;
    }
    Status = UuidCreate( &RequestGuid );
    if (Status != RPC_S_OK) {
        Status = ERROR_LUIDS_EXHAUSTED;
    }
    *pRequestID++ = 0;  // first octet is type and for guid the type is 0
    *((GUID UNALIGNED *)pRequestID) = RequestGuid;
    return Status;
}


DWORD
ObtainMadcapAddress(
    IN     PDHCP_CONTEXT DhcpContext,
    IN     PIPNG_ADDRESS           pScopeID,
    IN     PMCAST_LEASE_REQUEST    pAddrRequest,
    IN OUT PMCAST_LEASE_RESPONSE   pAddrResponse
    )
/*++

Routine Description:

    This routine attempts to obtains a new lease from a DHCP server.

Arguments:

    DhcpContext - Points to a DHCP context block for the NIC to initialize.

    MadcapOptions - Returns DHCP options returned by the DHCP server.

Return Value:


--*/
{
    MADCAP_OPTIONS                 MadcapOptions;
    DATE_TIME                      HostOrderLeaseTime;
    DWORD                          Error;
    time_t                         StartTime;
    time_t                         InitialStartTime;
    time_t                         TimeNow;
    time_t                         TimeToWait;
    DWORD                          Xid;
    DWORD                          RoundNum;
    DWORD                          MessageSize;
    DWORD                          SelectedServer;
    DWORD                          SelectedAddress;
    DWORD                          LeaseExpiryTime;
    BOOL                           GotOffer;
    PMCAST_LEASE_REQUEST           pRenewRequest;

    Xid                            = 0;           // generate xid on first send.  keep it same throughout
    SelectedServer                 = (DWORD)-1;
    SelectedAddress                = (DWORD)-1;
    GotOffer                       = FALSE;
    InitialStartTime               = time(NULL);
    Error                          = ERROR_SEM_TIMEOUT;

    // Make private copy of the request so that we don't modify original request.
    pRenewRequest = DhcpAllocateMemory(
                        sizeof(*pAddrRequest) +
                        sizeof(DWORD)*(pAddrRequest->AddrCount));
    if (NULL == pRenewRequest) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(pRenewRequest,pAddrRequest,sizeof(*pAddrRequest) );
    pRenewRequest->pAddrBuf = (PBYTE)pRenewRequest + sizeof(*pRenewRequest);
    if (pAddrRequest->pAddrBuf) {
        memcpy(pRenewRequest->pAddrBuf, pAddrRequest->pAddrBuf, sizeof(DWORD)*(pAddrRequest->AddrCount));
    }

    for (RoundNum = 0; RoundNum < MADCAP_MAX_RETRIES; RoundNum++ ) {
        Error = SendMadcapDiscover(                 // send a discover packet
            DhcpContext,
            pScopeID,
            pAddrRequest,
            &Xid
        );
        if ( Error != ERROR_SUCCESS ) {           // can't really fail here
            DhcpPrint((DEBUG_ERRORS, "Send Dhcp Discover failed, %ld.\n", Error));
            return Error ;
        }

        DhcpPrint((DEBUG_PROTOCOL, "Sent DhcpDiscover Message.\n"));

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        StartTime  = time(NULL);

        while ( TimeToWait > 0 ) {                // wait for specified time
            MessageSize = DHCP_RECV_MESSAGE_SIZE;

            DhcpPrint((DEBUG_TRACE, "Waiting for Offer: %ld seconds\n", TimeToWait));
            Error = GetSpecifiedMadcapMessage(      // try to receive an offer
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );

            if ( Error == ERROR_TIMEOUT ) {   // get out and try another discover
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp offer receive Timeout.\n" ));
                break;
            }

            if ( ERROR_SUCCESS != Error ) {       // unexpected error
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp Offer receive failed, %ld.\n", Error ));
                return Error ;
            }

            MadcapExtractOptions(         // now extract basic information
                DhcpContext,
                (LPBYTE)&DhcpContext->MadcapMessageBuffer->Option,
                MessageSize - MADCAP_MESSAGE_FIXED_PART_SIZE,
                &MadcapOptions,
                NULL,
                0
            );

            GotOffer = AcceptMadcapMsg(       // check up and see if we find this offer kosher
                MADCAP_DISCOVER_MESSAGE,
                DhcpContext,
                &MadcapOptions,
                0,
                &Error
            );
            DhcpAssert(ERROR_SUCCESS == Error);
            Error = ExpandMadcapAddressList(
                        MadcapOptions.AddrRangeList,
                        MadcapOptions.AddrRangeListSize,
                        (DWORD UNALIGNED *)pRenewRequest->pAddrBuf,
                        &pRenewRequest->AddrCount
                        );
            if (ERROR_SUCCESS != Error) {
                GotOffer = FALSE;
            }

            if (GotOffer) {
                break;
            }

            TimeNow     = time( NULL );           // calc the remaining wait time for this round
            TimeToWait -= ((TimeNow - StartTime));
            StartTime   = TimeNow;

        } // while (TimeToWait > 0 )

        if(GotOffer) {                            // if we got an offer, everything should be fine
            DhcpAssert(ERROR_SUCCESS == Error);
            break;
        }

    } // for n tries... send discover.

    if(!GotOffer ) { // did not get any valid offers
        DhcpPrint((DEBUG_ERRORS, "ObtainMadcapAddress timed out\n"));
        Error = ERROR_TIMEOUT ;
        goto Cleanup;
    }

    DhcpPrint((DEBUG_PROTOCOL, "Successfully received a DhcpOffer (%s) ",
                   inet_ntoa(*(struct in_addr *)pRenewRequest->pAddrBuf) ));

    DhcpPrint((DEBUG_PROTOCOL, "from %s.\n",
                   inet_ntoa(*(struct in_addr*)MadcapOptions.ServerIdentifier) ));
    SelectedServer = *MadcapOptions.ServerIdentifier;

    Error = RenewMadcapAddress(
                DhcpContext,
                pScopeID,
                pRenewRequest,
                pAddrResponse,
                SelectedServer
                );
Cleanup:
    if (pRenewRequest) {
        DhcpFreeMemory(pRenewRequest);
    }
    return Error;
}

DWORD
RenewMadcapAddress(
    IN     PDHCP_CONTEXT          DhcpContext,
    IN     PIPNG_ADDRESS          pScopeID,
    IN     PMCAST_LEASE_REQUEST   pAddrRequest,
    IN OUT PMCAST_LEASE_RESPONSE  pAddrResponse,
    IN     DHCP_IP_ADDRESS        SelectedServer
    )
/*++

Routine Description:

    This routine is called for two different purposes.
    1. To request an address for which we got offer.
    2. To renew an address.

Arguments:

    DhcpContext - Points to a DHCP context block for the NIC to initialize.

    pScopeID - ScopeId from which the address is to be renewed. for renewals
                this is passed as null.

    pAddrRequest - The lease info structure describing the request.

    pAddrResponse - The lease info structure which receives the response data.

    SelectedServer - If we are sending REQUEST message then this describes the server
                        from which we accepted the offer originally.
Return Value:

    The status of the operation.

--*/
{
    MADCAP_OPTIONS                 MadcapOptions;
    DWORD                          Error;
    DWORD                          Xid;
    DWORD                          RoundNum;
    size_t                         TimeToWait;
    DWORD                          MessageSize;
    DWORD                          LeaseTime;
    DWORD                          LeaseExpiryTime;
    time_t                         InitialStartTime;
    time_t                         StartTime;
    time_t                         TimeNow;
    BOOL                           GotAck;
    DATE_TIME                      HostOrderLeaseTime;
    BOOL                           Renew;

    Xid = 0;                                     // new Xid will be generated first time
    InitialStartTime = time(NULL);
    GotAck = FALSE;
    Error = ERROR_TIMEOUT;

    Renew = (0 == SelectedServer);
    for ( RoundNum = 0; RoundNum < MADCAP_MAX_RETRIES; RoundNum ++ ) {
        if (Renew) {
            Error = SendMadcapRenew(
                        DhcpContext,
                        pAddrRequest,
                        &Xid
                        );
        } else {
            Error = SendMadcapRequest(                 // send a request
                        DhcpContext,
                        pScopeID,
                        pAddrRequest,
                        SelectedServer,               //
                        &Xid
                        );
        }

        if ( Error != ERROR_SUCCESS ) {          // dont expect send to fail
            DhcpPrint(( DEBUG_ERRORS,"Send request failed, %ld.\n", Error));
            return Error ;
        }

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        StartTime  = time(NULL);
        while ( TimeToWait > 0 ) {               // try to recv message for this full period
            MessageSize = DHCP_RECV_MESSAGE_SIZE;
            Error = GetSpecifiedMadcapMessage(     // expect to recv an ACK
                DhcpContext,
                &MessageSize,
                Xid,
                TimeToWait
            );

            if ( Error == ERROR_TIMEOUT ) {  // No response, so resend DHCP REQUEST.
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp ACK receive Timeout.\n" ));
                break;
            }

            if ( ERROR_SUCCESS != Error ) {      // unexpected error
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp ACK receive failed, %ld.\n", Error ));
                return Error ;
            }

            MadcapExtractOptions(         // now extract basic information
                DhcpContext,
                (LPBYTE)&DhcpContext->MadcapMessageBuffer->Option,
                MessageSize - MADCAP_MESSAGE_FIXED_PART_SIZE,
                &MadcapOptions,
                NULL,
                0
            );

            GotAck = AcceptMadcapMsg(       // check up and see if we find this offer kosher
                Renew ? MADCAP_RENEW_MESSAGE : MADCAP_REQUEST_MESSAGE,
                DhcpContext,
                &MadcapOptions,
                SelectedServer,
                &Error
            );
            if (ERROR_SUCCESS != Error) {
                return Error;
            }
            // check that the ack came from the same server as the selected server.
            if ( SelectedServer && SelectedServer != *MadcapOptions.ServerIdentifier ) {
                GotAck = FALSE;
            }
            Error = ExpandMadcapAddressList(
                        MadcapOptions.AddrRangeList,
                        MadcapOptions.AddrRangeListSize,
                        (DWORD UNALIGNED *)pAddrResponse->pAddrBuf,
                        &pAddrResponse->AddrCount
                        );
            if (ERROR_SUCCESS != Error) {
                GotAck = FALSE;
            }

            if ( GotAck ) {
                break;
            }

            TimeNow     = time( NULL );
            TimeToWait -= (TimeNow - StartTime);
            StartTime   = TimeNow;

        } // while time to wait
        if(TRUE == GotAck) {                      // if we got an ack, everything must be good
            DhcpAssert(ERROR_SUCCESS == Error);   // cannot have any errors
            break;
        }
        DhcpContext->SecondsSinceBoot = (DWORD)(InitialStartTime - TimeNow);
    } // for RoundNum < MAX_RETRIES

    if(!GotAck) {
        DhcpPrint((DEBUG_ERRORS, "RenewMadcapAddress timed out\n"));
        return ERROR_TIMEOUT;
    }

    if (0 == SelectedServer ) SelectedServer = *MadcapOptions.ServerIdentifier;
    if( MadcapOptions.LeaseTime ) LeaseTime = ntohl(*MadcapOptions.LeaseTime);
    else LeaseTime = 0;

    pAddrResponse->ServerAddress.IpAddrV4 = SelectedServer;

    time( &TimeNow );
    pAddrResponse->LeaseStartTime = (LONG)TimeNow;
    pAddrResponse->LeaseEndTime = (LONG)(TimeNow+LeaseTime);


    DhcpPrint((DEBUG_PROTOCOL, "Accepted ACK (%s) ",
               inet_ntoa(*(struct in_addr *)pAddrResponse->pAddrBuf) ));
    DhcpPrint((DEBUG_PROTOCOL, "from %s.\n",
               inet_ntoa(*(struct in_addr *)&SelectedServer)));
    DhcpPrint((DEBUG_PROTOCOL, "Lease is %ld secs.\n", LeaseTime));

    return ERROR_SUCCESS;
}



DWORD
ReleaseMadcapAddress(
    PDHCP_CONTEXT DhcpContext
    )
/*++

Routine Description:

    This routine to releases a lease for an IP address.  Since the
    packet we send is not responded to, we assume that the release
    works.

Arguments:

    DhcpContext - Points to a DHCP context block for the NIC to initialize.

Return Value:

    None.

--*/
{
    DWORD                          Xid;
    MADCAP_OPTIONS                 MadcapOptions;
    DWORD                          Error;
    time_t                         StartTime;
    time_t                         InitialStartTime;
    time_t                         TimeNow;
    time_t                         TimeToWait;
    DWORD                          RoundNum;
    DWORD                          MessageSize;
    BOOL                           GotAck;


    Xid = 0;                                     // new Xid will be generated first time
    GotAck                         = FALSE;
    InitialStartTime               = time(NULL);
    Error                          = ERROR_TIMEOUT;

    for (RoundNum = 0; RoundNum < MADCAP_MAX_RETRIES; RoundNum++ ) {
        Error = SendMadcapRelease(                 // send a discover packet
            DhcpContext,
            &Xid
        );
        if ( Error != ERROR_SUCCESS ) {           // can't really fail here
            DhcpPrint((DEBUG_ERRORS, "Send Dhcp Release failed, %ld.\n", Error));
            return Error ;
        }

        DhcpPrint((DEBUG_PROTOCOL, "Sent DhcpRelease Message.\n"));

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        StartTime  = time(NULL);

        while ( TimeToWait > 0 ) {                // wait for specified time
            MessageSize = DHCP_RECV_MESSAGE_SIZE;

            DhcpPrint((DEBUG_TRACE, "Waiting for Ack: %ld seconds\n", TimeToWait));
            Error = GetSpecifiedMadcapMessage(      // try to receive an offer
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );

            if ( Error == ERROR_TIMEOUT ) {   // get out and try another discover
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp Ack receive Timeout.\n" ));
                break;
            }

            if ( ERROR_SUCCESS != Error ) {       // unexpected error
                DhcpPrint(( DEBUG_PROTOCOL, "Dhcp Ack receive failed, %ld.\n", Error ));
                return Error ;
            }

            MadcapExtractOptions(         // now extract basic information
                DhcpContext,
                (LPBYTE)&DhcpContext->MadcapMessageBuffer->Option,
                MessageSize - MADCAP_MESSAGE_FIXED_PART_SIZE,
                &MadcapOptions,
                NULL,
                0
            );

            GotAck = AcceptMadcapMsg(       // check up and see if we find this offer kosher
                MADCAP_RELEASE_MESSAGE,
                DhcpContext,
                &MadcapOptions,
                DhcpContext->DhcpServerAddress,
                &Error
            );
            DhcpAssert(ERROR_SUCCESS == Error);
            if (GotAck) {
                break;
            }

            TimeNow     = time( NULL );           // calc the remaining wait time for this round
            TimeToWait -= ((TimeNow - StartTime));
            StartTime   = TimeNow;

        } // while (TimeToWait > 0 )

        if(GotAck) {                            // if we got an offer, everything should be fine
            DhcpAssert(ERROR_SUCCESS == Error);
            break;
        }

    } // for n tries... send discover.

    if(!GotAck ) { // did not get any valid offers
        DhcpPrint((DEBUG_ERRORS, "MadcapReleaseAddress timed out\n"));
        Error = ERROR_TIMEOUT ;
    } else {
        DhcpPrint((DEBUG_PROTOCOL, "Successfully released the address\n" ));
        Error = ERROR_SUCCESS;
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\mdhccapi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mdhccapi.c

Abstract:

    This file contains the client side APIs for the MCAST.

Author:

    Munil Shah (munils)  02-Sept-97

Environment:

    User Mode - Win32

Revision History:


--*/
#include "precomp.h"
#include <dhcploc.h>
#include <dhcppro.h>
#include "mdhcpcli.h"

DWORD
MadcapInitGlobalData(
    VOID
    );

VOID
MadcapCleanupGlobalData(
    VOID
    );

DWORD
APIENTRY
McastApiStartup(
    IN  OUT PDWORD   pVersion
    )
/*++

Routine Description:

    This routine returns the current version of the apis and allocates any
    necessary resources.

Arguments:

    pVersion    - Version of the api clients. On return contains version of the
                    api implementation.

Return Value:

    ERROR_NOT_SUPPORTED if client version greater than impl version.
    (other Win32 errors)

--*/
{
    DWORD   Error;

    Error = ERROR_SUCCESS;
    if (!pVersion) {
        return ERROR_INVALID_PARAMETER;
    }
    // do we support this client version?
    if (*pVersion > MCAST_API_CURRENT_VERSION) {
        // not supported
        Error = ERROR_NOT_SUPPORTED;
    } else {
        // if client specified its version, use that
        // o/w assume version 1.0
        if (*pVersion) {
            gMadcapClientApplVersion = *pVersion;
        } else {
            gMadcapClientApplVersion = MCAST_API_VERSION_1;
        }
    }
    *pVersion = MCAST_API_CURRENT_VERSION;

    if( ERROR_SUCCESS == Error ) {
        Error = MadcapInitGlobalData();
        if (ERROR_SUCCESS != Error) {
            DhcpPrint((DEBUG_ERRORS, "McastApiStartup - Could not allocate resources %ld\n", Error));
            Error = ERROR_NO_SYSTEM_RESOURCES;
        }
    }

    return Error;
}

VOID
APIENTRY
McastApiCleanup(
    VOID
    )
/*++

Routine Description:

    This routine de-allocates resources allocated by the Startup routine.
    It must be called only AFTER a successful call to McastApiStartup.

--*/
{
    MadcapCleanupGlobalData();
}


DWORD
APIENTRY
McastEnumerateScopes(
    IN     IP_ADDR_FAMILY     AddrFamily,
    IN     BOOL               ReQuery,
    IN OUT PMCAST_SCOPE_ENTRY       pScopeList,
    IN OUT PDWORD             pScopeLen,
    OUT    PDWORD             pScopeCount
    )
/*++

Routine Description:

    This routine enumerates the multicast scopes available on the network.

Arguments:

    AddrFamily - AF_INET for IPv4 and AF_INET6 for IPv6

    ReQuery    - TRUE if the calls wants the list to be requried. FALSE o/w.

    pScopeList - pointer to the buffer where the scopelist is to be retrieved.
                 This parameter can be NULL if only the length of the buffer is
                 being retrieved.

                 When this buffer is NULL, the API will force the re-query of the
                 scope list from the MCAST servers.

    pScopeLen  - Pointer to a variable that specifies the size, in bytes, of the
                 buffer pointed to by the pScopeList parameter. When the function returns,
                 this variable contains the size of the data copied to pScopeList;

                 The pScopeLen parameter can not be NULL.

                 If the buffer specified by pScopeList parameter is not large enough
                 to hold the data, the function returns the value ERROR_MORE_DATA, and
                 stores the required buffer size, in bytes, into the variable pointed
                 to by pScopeLen.

                 If pScopeList is NULL, and pScopeLen is non-NULL, the function returns
                 ERROR_SUCCESS, and stores the size of the data, in bytes, in the variable
                 pointed to by pScopeLen. This lets an application determine the best
                 way to allocate a buffer for the scope list.

    pScopeCount - Pointer to a variable that will store total number of scopes returned
                 in the pScopeList buffer.

Return Value:

    The status of the operation.

--*/
{
    DWORD   Error;


    // First check the validity of the arguments.

    // has startup been called?
    if ( !gMadcapClientApplVersion ) {
        DhcpPrint((DEBUG_ERRORS, "McastEnumerateScopes - Not ready. Client Version %d\n",
                   gMadcapClientApplVersion));
        return ERROR_NOT_READY;
    }

    // Correct addr family?
    if (AF_INET != AddrFamily) {
        DhcpPrint((DEBUG_ERRORS, "McastEnumerateScopes - Invalid AddrFamily IPv%d\n", AddrFamily));
        return ERROR_INVALID_PARAMETER;
    }

    // pScopeLen can not be NULL.
    if ( !pScopeLen || IsBadWritePtr( pScopeLen, sizeof(DWORD) ) ) {
        DhcpPrint((DEBUG_ERRORS, "McastEnumerateScopes - Invalid ScopeLen param\n"));
        return ERROR_INVALID_PARAMETER;
    }
    // if pScopeList buffer is given, then pScopeCount can not be NULL.
    if ( pScopeList &&
         (!pScopeCount || IsBadWritePtr( pScopeCount, sizeof(DWORD)) ) ) {
        DhcpPrint((DEBUG_ERRORS, "McastEnumerateScopes - Invalid ScopeCount param\n"));
        return ERROR_INVALID_PARAMETER;
    }

    // if we are not requerying the list then pScopList can not be NULL.
    if (!ReQuery &&
        (!pScopeList || IsBadWritePtr( pScopeList, *pScopeLen ) ) ) {
        DhcpPrint((DEBUG_ERRORS, "McastEnumerateScopes - Invalid ScopeList & ReQuery param\n"));
        return ERROR_INVALID_PARAMETER;
    }

    // initialize the status.
    Error = STATUS_SUCCESS;

    // do we need to requery ?
    if ( ReQuery ) {
        // query the MCAST servers and get the new list of MScopes.
        Error = ObtainMScopeList();
        if ( ERROR_SUCCESS != Error ) {
            return Error;
        }
    } else {
        if( !gMadcapScopeList ) {
            return ERROR_NO_DATA;
        }
    }

    // Has the client specified the buffer?
    if ( pScopeList ) {
        // yes, copy the scopes.
        DhcpPrint((DEBUG_API, "McastEnumerateScopes - Copying existing mscope list\n"));
        return CopyMScopeList(
                    pScopeList,
                    pScopeLen,
                    pScopeCount );
    } else {
        // no, just return the length of the scope list and the scope count.
        LOCK_MSCOPE_LIST();
        if( gMadcapScopeList != NULL ) {
            *pScopeLen = gMadcapScopeList->ScopeLen;
            if ( pScopeCount ) *pScopeCount = gMadcapScopeList->ScopeCount;
            Error = ERROR_SUCCESS;
        } else {
            Error = ERROR_NO_DATA;
        }
        UNLOCK_MSCOPE_LIST();
    }

    return Error;
}


DWORD
APIENTRY
McastGenUID(
    IN     LPMCAST_CLIENT_UID   pRequestID
    )
/*++

Routine Description:

    This routine generates the unique identifier which client can use to later pass
    to request/renew addresses.

Arguments:

    pRequestID - Pointer to the UID struct where the identifier is to be stored. The
                buffer that holds the id should be at-least MCAST_CLIENT_ID_LEN long.

Return Value:

    The status of the operation.

--*/
{
    if (!pRequestID) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!pRequestID->ClientUID || IsBadWritePtr( pRequestID->ClientUID, pRequestID->ClientUIDLength) ) {
        return ERROR_INVALID_PARAMETER;
    }

    return GenMadcapClientUID( pRequestID->ClientUID, &pRequestID->ClientUIDLength );

}

DWORD
APIENTRY
McastRequestAddress(
    IN     IP_ADDR_FAMILY           AddrFamily,
    IN     LPMCAST_CLIENT_UID       pRequestID,
    IN     PMCAST_SCOPE_CTX         pScopeCtx,
    IN     PMCAST_LEASE_REQUEST     pAddrRequest,
    IN OUT PMCAST_LEASE_RESPONSE    pAddrResponse
    )
/*++

Routine Description:

    This routine request multicast address(es) from the MCAST server.

Arguments:

    AddrFamily - AF_INET for IPv4 and AF_INET6 for IPv6

    pRequestID - Unique identifier for this request. Client is responsible for
                 generating unique identifier for every request. One recommendation
                 is to use application specific context hashed by time.

    pRequestIDLen - Length of the pRequestID buffer.

    pScopeCtx  - Pointer to the context of the scope from which the address is to
                 be allocated. Scope context has to be retrieved via McastEnumerateScopes
                 call before calling this.

    pAddrRequest - Pointer to the block containing all the parameters pertaining
                 to multicast address request. The MCAST_API_VERSION_1 version of
                 implementation supports allocation of only one address at a time.
                 So the AddrCount  and MinAddrCount value must be 1.ServerAddress
                 field is ignored.

    pAddrResponse - Pointer to the block which contains the response paramters for
                 the multicast address request. The caller is responsible for allocating
                 the space for pAddrBuf for the requested number of addresses and
                 setting the pointer to that space.

Return Value:

    The status of the operation.

--*/
{
    PDHCP_CONTEXT  pContext = NULL;
    DWORD   Error;
    DWORD   ScopeId;
    time_t  TimeNow;
    time_t  LocalLeaseStartTime;
    time_t  LocalMaxLeaseStartTime;

    // do some param checking.

    // has startup been called?
    if ( !gMadcapClientApplVersion ) {
        DhcpPrint((DEBUG_ERRORS, "McastRequestAddress - Not ready. Client Version %d\n",
                   gMadcapClientApplVersion));
        return ERROR_NOT_READY;
    }

    if (AF_INET != AddrFamily) {
        DhcpPrint((DEBUG_ERRORS, "McastRequestAddress - Invalid AddrFamily IPv%d\n", AddrFamily));
        return ERROR_INVALID_PARAMETER;
    }

    if ( !pRequestID || !pRequestID->ClientUID || !pAddrRequest || !pAddrResponse ) {
        DhcpPrint((DEBUG_ERRORS,"McastRequestAddress - one of parameter is NULL\n"));
        return ERROR_INVALID_PARAMETER;
    }

    if ( pAddrRequest->AddrCount != 1 || pAddrResponse->AddrCount < pAddrRequest->AddrCount) {
        DhcpPrint((DEBUG_ERRORS,"McastRequestAddress - currently support one address - requested %ld\n",
                   pAddrRequest->AddrCount));
        return ERROR_INVALID_PARAMETER;
    }


    if ( pAddrRequest->pAddrBuf &&
         (*(DWORD UNALIGNED *)pAddrRequest->pAddrBuf) &&
         !CLASSD_NET_ADDR(*(DWORD UNALIGNED *)pAddrRequest->pAddrBuf)) {
        DhcpPrint((DEBUG_ERRORS,"McastRequestAddress - requested address not valid %s\n",
                   DhcpIpAddressToDottedString(*(DWORD UNALIGNED *)pAddrRequest->pAddrBuf)));
        return ERROR_INVALID_PARAMETER;
    }

    if ( !pAddrResponse->pAddrBuf ) {
        DhcpPrint((DEBUG_ERRORS,"McastRequestAddress - response buffer has null pAddrBuf\n"));
        return ERROR_INVALID_PARAMETER;
    }

    if (pRequestID->ClientUIDLength < MCAST_CLIENT_ID_LEN) {
        DhcpPrint((DEBUG_ERRORS,"McastRequestAddress - requestid length %d too small\n",
                   pRequestID->ClientUIDLength));
        return ERROR_INVALID_PARAMETER;
    }

    if ( !pScopeCtx ) {
        DhcpPrint((DEBUG_ERRORS, "McastRequestAddress - scope context not supplied\n"));
        return ERROR_INVALID_PARAMETER;
    }

    time(&TimeNow);
    LocalLeaseStartTime = LocalMaxLeaseStartTime = TimeNow;
    if ( pAddrRequest->LeaseStartTime > LocalLeaseStartTime ) {
        LocalLeaseStartTime = pAddrRequest->LeaseStartTime;
    }
    if ( pAddrRequest->MaxLeaseStartTime > LocalMaxLeaseStartTime ) {
        LocalMaxLeaseStartTime = pAddrRequest->MaxLeaseStartTime;
    }

    if ( LocalLeaseStartTime > LocalMaxLeaseStartTime ) {
        DhcpPrint((DEBUG_ERRORS,"McastRequestAddress - invalid start lease times\n"));
        return ERROR_INVALID_PARAMETER;
    }

    if ( pAddrRequest->LeaseDuration < pAddrRequest->MinLeaseDuration ) {
        DhcpPrint((DEBUG_ERRORS,"McastRequestAddress - invalid lease duration\n"));
        return ERROR_INVALID_PARAMETER;
    }

    Error = CreateMadcapContext(&pContext, pRequestID, pScopeCtx->Interface.IpAddrV4 );
    if ( ERROR_SUCCESS != Error ) goto Cleanup;
    APICTXT_ENABLED(pContext);                 // mark the context as being created by the API

    if (pAddrRequest->pAddrBuf && (*(DWORD UNALIGNED *)pAddrRequest->pAddrBuf) ) {
        pContext->DesiredIpAddress = *(DWORD UNALIGNED *)pAddrRequest->pAddrBuf;
    }
    //pContext->DhcpServerAddress = pScopeCtx->ServerID;

    Error = ObtainMadcapAddress(
                pContext,
                &pScopeCtx->ScopeID,
                pAddrRequest,
                pAddrResponse
                );

Cleanup:
    if ( pContext )
        DhcpDestroyContext( pContext );

    return Error;
}

DWORD
APIENTRY
McastRenewAddress(
    IN     IP_ADDR_FAMILY           AddrFamily,
    IN     LPMCAST_CLIENT_UID       pRequestID,
    IN     PMCAST_LEASE_REQUEST     pRenewRequest,
    IN OUT PMCAST_LEASE_RESPONSE    pRenewResponse
    )
/*++

Routine Description:

    This routine renews multicast address(es) from the MCAST server.

Arguments:

    AddrFamily - AF_INET for IPv4 and AF_INET6 for IPv6

    pRequestID - Unique identifier that was used when the address(es) were
                 obtained initially.

    RequestIDLen - Length of the pRequestID buffer.

    pRenewRequest - Pointer to the block containing all the parameters pertaining
                 to the renew request.

    pRenewResponse - Pointer to the block which contains the response paramters for
                 the renew request.The caller is responsible for allocating the
                 space for pAddrBuf for the requested number of addresses and
                 setting the pointer to that space.

Return Value:

    The status of the operation.

--*/
{

    PDHCP_CONTEXT  pContext = NULL;
    DWORD           Error;
    DHCP_IP_ADDRESS SelectedServer;
    DWORD           ScopeId;
    time_t  TimeNow;

    // do some param checking.

    // has startup been called?
    if ( !gMadcapClientApplVersion ) {
        DhcpPrint((DEBUG_ERRORS, "McastRenewAddress - Not ready. Client Version %d\n",
                   gMadcapClientApplVersion));
        return ERROR_NOT_READY;
    }

    if (AF_INET != AddrFamily) {
        DhcpPrint((DEBUG_ERRORS, "McastRenewAddress - Invalid AddrFamily IPv%d\n", AddrFamily));
        return ERROR_INVALID_PARAMETER;
    }

    if ( !pRequestID || !pRenewRequest || !pRenewResponse ) {
        DhcpPrint((DEBUG_ERRORS,"McastRenewAddress - one of parameter is NULL\n"));
        return ERROR_INVALID_PARAMETER;
    }

    if ( pRenewRequest->AddrCount != 1 ||
          pRenewResponse->AddrCount < pRenewRequest->AddrCount ||
         !pRenewResponse->pAddrBuf ||
         !pRenewRequest->pAddrBuf ||
         !CLASSD_NET_ADDR( *(DWORD UNALIGNED *)pRenewRequest->pAddrBuf) ) {
        DhcpPrint((DEBUG_ERRORS,"McastRenewAddress - address %s type V%d count %ld is invalid\n",
                   DhcpIpAddressToDottedString( *(DWORD UNALIGNED *)pRenewRequest->pAddrBuf),
                   pRenewRequest->AddrCount ));
        return ERROR_INVALID_PARAMETER;
    }

    if (!pRenewRequest->ServerAddress.IpAddrV4) {
        DhcpPrint((DEBUG_ERRORS,"McastRequestAddress - server address not specified \n"));
        return ERROR_INVALID_PARAMETER;
    }
    if (pRequestID->ClientUIDLength < MCAST_CLIENT_ID_LEN) {
        DhcpPrint((DEBUG_ERRORS,"McastRenewAddress - requestid length too small\n",
                   pRequestID->ClientUIDLength));
        return ERROR_INVALID_PARAMETER;
    }

    time(&TimeNow);
    if ( pRenewRequest->LeaseStartTime > pRenewRequest->MaxLeaseStartTime ||
         (pRenewRequest->LeaseDuration < pRenewRequest->MinLeaseDuration)) {
        DhcpPrint((DEBUG_ERRORS,"McastRenewAddress - invalid lease times\n"));
        return ERROR_INVALID_PARAMETER;
    }

    Error = CreateMadcapContext(&pContext, pRequestID, INADDR_ANY);
    if ( ERROR_SUCCESS != Error) return  Error;
    APICTXT_ENABLED(pContext);          // mark the context as being created by the API

    pContext->DesiredIpAddress = *(DWORD UNALIGNED *)pRenewRequest->pAddrBuf;
    pContext->DhcpServerAddress = pRenewRequest->ServerAddress.IpAddrV4;


    Error = RenewMadcapAddress(
                pContext,
                NULL,
                pRenewRequest,
                pRenewResponse,
                0
                );

Cleanup:

    if ( pContext ) DhcpDestroyContext( pContext );
    return Error;
}

DWORD
APIENTRY
McastReleaseAddress(
    IN     IP_ADDR_FAMILY          AddrFamily,
    IN     LPMCAST_CLIENT_UID      pRequestID,
    IN     PMCAST_LEASE_REQUEST    pReleaseRequest
    )
/*++

Routine Description:

    This routine releases multicast address(es) from the MCAST server.

Arguments:

    AddrFamily - AF_INET for IPv4 and AF_INET6 for IPv6

    pRequestID - Unique identifier that was used when the address(es) were
                 obtained initially.

    pReleaseRequest - Pointer to the block containing all the parameters pertaining
                 to the release request.

Return Value:

    The status of the operation.

--*/
{
    PDHCP_CONTEXT  pContext = NULL;
    DWORD           Error;
    DHCP_IP_ADDRESS SelectedServer;
    DWORD           ScopeId;

    // do some param checking.

    // has startup been called?
    if ( !gMadcapClientApplVersion ) {
        DhcpPrint((DEBUG_ERRORS, "McastReleaseAddress - Not ready. Client Version %d\n",
                   gMadcapClientApplVersion));
        return ERROR_NOT_READY;
    }

    if (AF_INET != AddrFamily) {
        DhcpPrint((DEBUG_ERRORS, "McastReleaseAddress - Invalid AddrFamily IPv%d\n", AddrFamily));
        return ERROR_INVALID_PARAMETER;
    }

    if ( !pRequestID || !pReleaseRequest ) {
        DhcpPrint((DEBUG_ERRORS,"McastReleaseAddress - one of parameter is NULL\n"));
        return ERROR_INVALID_PARAMETER;
    }

    if ( pReleaseRequest->AddrCount != 1 ||
         !pReleaseRequest->pAddrBuf ||
         !CLASSD_NET_ADDR( *(DWORD UNALIGNED *)pReleaseRequest->pAddrBuf) ) {
        DhcpPrint((DEBUG_ERRORS,"McastReleaseAddress - address %s count %ld is invalid\n",
                   DhcpIpAddressToDottedString( *(DWORD UNALIGNED *)pReleaseRequest->pAddrBuf), pReleaseRequest->AddrCount ));
        return ERROR_INVALID_PARAMETER;
    }

    if (!pReleaseRequest->ServerAddress.IpAddrV4) {
        DhcpPrint((DEBUG_ERRORS,"McastReleaseAddress - server address is invalid\n"));
        return ERROR_INVALID_PARAMETER;
    }

    if (pRequestID->ClientUIDLength < MCAST_CLIENT_ID_LEN) {
        DhcpPrint((DEBUG_ERRORS,"McastRequestAddress - requestid length too small\n",
                   pRequestID->ClientUIDLength));
        return ERROR_INVALID_PARAMETER;
    }

    Error = CreateMadcapContext(&pContext, pRequestID, INADDR_ANY );
    if ( ERROR_SUCCESS != Error) return  Error;
    APICTXT_ENABLED(pContext);                 // mark the context as being created by the API

    pContext->DhcpServerAddress = pReleaseRequest->ServerAddress.IpAddrV4;

    Error = ReleaseMadcapAddress(pContext);

Cleanup:

    if ( pContext ) DhcpDestroyContext( pContext );
    return Error;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\optapi.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    optapi.c

--*/
/*--------------------------------------------------------------------------------
  This program is used to test the api options part of the api.
  Date: April 15 1997
  Author: RameshV (VK)
  Description: This program is used to test the options api part of the client
  options.
--------------------------------------------------------------------------------*/

#include "precomp.h"
#include <dhcploc.h>
#include <dhcppro.h>

#include <lmcons.h>
#include <align.h>

#include <apiappl.h>
#include <dhcpcapi.h>

#include <string.h>
#include <winbase.h>
#include <iphlpapi.h>

//--------------------------------------------------------------------------------
//  Some variables.
//--------------------------------------------------------------------------------

#define OMAP_MAX_OPTIONS 256

// The options to request.
BYTE Request[OMAP_MAX_OPTIONS];
int  nOptionsRequested = 0;

// The return values
BYTE *pObtained = NULL;
int   nObtained = 0, opt_data_size = 0;
BYTE *options_data;

// USAGE
#define USAGE  "Usage: %s <cmd> <arguments>\n\t"       \
"The currently supported cmd's and arguments are:\n\t" \
"\t<cmd>                        <arguments>\n\t"       \
"\tGetOptions         RequestList_in_Hex // such as 010503a1\n\t" \
"\tTestEvents         RequestList_in_Hex // such as 010503a1\n\t" \
"\tRelease            AdapterName                    // ipconfig /release\n\t" \
"\tRenew              AdapterName                    // ipconfig /renew  \n\t" \
"\tEnumClasses        AdapterName                    // enumerate dhcpclasses\n\t"\
"\tSetClass           AdapterName ClassName          // set user class\n\t"\
"\n\n"

//--------------------------------------------------------------------------------
//  Parse a hex list of options. (such as 0105434421 )
//--------------------------------------------------------------------------------
int // nOptionsRequested;
GetOptionList(char *s, char *Request) {
    int nOptionsRequested = 0;

    while(s && *s & *(s+1)) {
        *s = (UCHAR) tolower(*s);
            if(!isdigit(*s) && ((*s) < 'a' || (*s) > 'f') ) {
                fprintf(stderr, "found obscene character <%c> when looking for hex!\n", *s);
                fprintf(stderr, "bye\n");
                exit(1);
            }
            if(isdigit(*s))
                Request[nOptionsRequested] = (*s) - '0';
            else Request[nOptionsRequested] = (*s) - 'a' + 10;

            Request[nOptionsRequested] *= 0x10;
            // Now do the same for the next digit.
            s ++;

            *s = (UCHAR) tolower(*s);
            if(!isdigit(*s) && (*s) < 'a' && (*s) > 'f' ) {
                fprintf(stderr, "found obscene character <%c> when looking for hex!\n", *s);
                fprintf(stderr, "bye\n");
                exit(1);
            }
            if(isdigit(*s))
                Request[nOptionsRequested] += (*s) - '0';
            else Request[nOptionsRequested] += (*s) - 'a' + 10;

            s ++;
            nOptionsRequested ++;
    }

    if(*s) {
        fprintf(stderr, "ignoring character <%c>\n", *s);
    }
    return nOptionsRequested;
}

//--------------------------------------------------------------------------------
//  Here is the function that does the GetOptions command.
//  It parses the adaptername and then converts it to LPWSTR and
//  it also parses the requestlist and then it calls DhcpRequestOptions.
//  It prints out the data it gets back.
//--------------------------------------------------------------------------------
void
OptApiGetOptions(int argc, char *argv[]) {
    WCHAR AdapterName[100];
    PIP_INTERFACE_INFO IfInfo;
    UCHAR Buffer[4000];
    ULONG BufLen = sizeof(Buffer);
    DWORD Error;

    // first check if we have the right command.
    if(_stricmp(argv[1], "GetOptions")) {
        fprintf(stderr, "Internal inconsistency in OptApiGetOptions\n");
        exit(1);
    }

    // Now check and see if there are the correct number of arguments.
    if(argc != 3 ) {
        fprintf(stderr, USAGE, argv[0]);
        exit(1);
    }

    // Now first get the list of options requested.
    {
        nOptionsRequested = GetOptionList(argv[2], Request);
        {
            int i;
            printf("Requesting %d options: ", nOptionsRequested);
            for( i = 0 ; i < nOptionsRequested; i ++)
                printf("%02x ", (int)Request[i]);
        }

    }

    //
    // get the adaptername
    //
    IfInfo = (PIP_INTERFACE_INFO)Buffer;
    Error = GetInterfaceInfo(IfInfo, &BufLen);
    if( NO_ERROR != Error ) {
        printf("GetInterfaceInfo: 0x%lx\n", Error);
        exit(1);
    }

    if( IfInfo->NumAdapters == 0 ) {
        printf("No adapters !!\n");
        exit(1);
    }

    if( wcslen(IfInfo->Adapter[0].Name) <= 14 ) {
        printf("Invalid adapter name? : %ws\n", IfInfo->Adapter[0].Name);
        exit(1);
    }

    wcscpy(AdapterName, &IfInfo->Adapter[0].Name[14]);

    // now call the function to get options.
    printf(" from adapter <%ws>\n", AdapterName);

    {
        DWORD result;

        result = DhcpRequestOptions(
            //L"El59x1",    RAMESHV-P200's adapter
            // L"IEEPRO1",  SUNBEAM, KISSES (or CltApi) machine's adapter
            //L"NdisWan4",    // SUNBEAM, KISSES's wan adapter: does not have ip address.
            AdapterName,
            Request, nOptionsRequested,
            &options_data, &opt_data_size,
            &pObtained, &nObtained
            );
        printf("Result is: %d; Obtained: %d\nList size is %d\n",
               result,
               nObtained,
               opt_data_size);

        if(result) {
            fprintf(stderr, "function call failed\n");
            return;
        }

        printf("Data: ");
        while(opt_data_size--)
            printf("%02x ", *options_data++);
        printf("\n");
    }

    // done
    printf("bye\n");
}
void
OptApiRelease(int argc, char *argv[]) {
    WCHAR AdapterName[256];

    // Check for the size and # of arguments.
    if( argc != 3 ) {
        fprintf(stderr, USAGE , argv[0]);
        exit(1);
    }

    // Now create a WSTR out of argv[2].
    if( strlen(argv[2]) != mbstowcs(AdapterName, argv[2], strlen(argv[2]))) {
        fprintf(stderr, "Could not convert %s to LPWSTR! sorry\n", argv[2]);
        exit(1);
    }
    AdapterName[strlen(argv[2])] = L'\0';

    printf("Return Value = %ld\n", DhcpReleaseParameters(AdapterName));
}

void
OptApiRenew(int argc, char *argv[]) {
    WCHAR AdapterName[256];

    // Check for the size and # of arguments.
    if( argc != 3 ) {
        fprintf(stderr, USAGE , argv[0]);
        exit(1);
    }

    // Now create a WSTR out of argv[2].
    if( strlen(argv[2]) != mbstowcs(AdapterName, argv[2], strlen(argv[2]))) {
        fprintf(stderr, "Could not convert %s to LPWSTR! sorry\n", argv[2]);
        exit(1);
    }
    AdapterName[strlen(argv[2])] = L'\0';

    printf("Return Value = %ld\n", DhcpAcquireParameters(AdapterName));
}

void
OptApiTestEvents(int argc, char *argv[]) {
    WCHAR AdapterName[100];

    // first check if we have the right command.
    if(_stricmp(argv[1], "TestEvents")) {
        fprintf(stderr, "Internal inconsistency in OptApiGetOptions\n");
        exit(1);
    }

    // Now check and see if there are the correct number of arguments.
    if(argc != 4 ) {
        fprintf(stderr, USAGE, argv[0]);
        exit(1);
    }

    // Now first get the list of options requested.
    {
        nOptionsRequested = GetOptionList(argv[3], Request);
        {
            int i;
            printf("Testing Events for %d options: ", nOptionsRequested);
            for( i = 0 ; i < nOptionsRequested; i ++)
                printf("%02x ", (int)Request[i]);
        }

    }

    // Now get the adapter.
    if(strlen(argv[2]) != mbstowcs(AdapterName, argv[2], strlen(argv[2]))) {
        fprintf(stderr, "Could not convert %s to LPWSTR! sorry\n", argv[2]);
        exit(1);
    }

    // null terminate the string.
    AdapterName[strlen(argv[2])] = L'\0' ;

    // now call the function to get options.
    printf(" from adapter <%s>\n", argv[2]);

    {
        DWORD result;
        HANDLE Handle;

        result = DhcpRegisterOptions(
            AdapterName,
            Request, nOptionsRequested, &Handle
            );

        printf("result is %d, Handle = 0x%p\n", result, Handle);

        if(result) {
            fprintf(stderr, "function call failed\n");
            return;
        }

        printf("Please use another window to do a ipconfig /renew and obtain\n");
        printf("one of the above options...\n");
        printf("WaitForSingleObject(Handle,INFINITE) = ");
        switch(WaitForSingleObject(Handle, INFINITE)) {
        case WAIT_ABANDONED: printf("WAIT_ABANDONED! Giving up\n"); return;
        case WAIT_OBJECT_0 : printf("WAIT_OBJECT_0 ! proceeding\n"); break;
        case WAIT_TIMEOUT  : printf("WAIT_TIMEOUT  ! Giving up\n"); return;
        case WAIT_FAILED   : printf("WAIT_FAILED (%d); giving up\n", GetLastError()); return;
        default: printf("XXXX; this should not happen at all!\n"); return;
        }

        // Okay the object was signalled. So, now we have to do a request on this.
        result = DhcpRequestOptions(
            AdapterName,
            Request, nOptionsRequested,
            &options_data, &opt_data_size,
            &pObtained, &nObtained
            );
        printf("Result is: %d; Obtained: %d\nList size is %d\n",
               result,
               nObtained,
               opt_data_size);

        if(result) {
            fprintf(stderr, "function call failed\n");
            return;
        }

        printf("Data: ");
        while(opt_data_size--)
            printf("%02x ", *options_data++);
        printf("\n");

        // Now deregister this object.
        result = DhcpDeRegisterOptions(Handle);
        printf("DeRegister(0x%p) = %ld\n", Handle, result);
    }

    // done
    printf("bye\n");
}

void
OptApiEnumClasses(int argc, char *argv[]) {
    WCHAR AdapterName[256];
    DHCP_CLASS_INFO *Classes;
    ULONG Size, RetVal;
    ULONG i;

    // Check for the size and # of arguments.
    if( argc != 3 ) {
        fprintf(stderr, USAGE , argv[0]);
        exit(1);
    }

    // Now create a WSTR out of argv[2].
    if( strlen(argv[2]) != mbstowcs(AdapterName, argv[2], strlen(argv[2]))) {
        fprintf(stderr, "Could not convert %s to LPWSTR! sorry\n", argv[2]);
        exit(1);
    }
    AdapterName[strlen(argv[2])] = L'\0';

    Size = 0;
    Classes = NULL;
    RetVal = DhcpEnumClasses( 0, AdapterName, &Size, Classes);
    if( ERROR_MORE_DATA != RetVal ) {
        printf("Return Value for first call = %ld\n", RetVal);
        return;
    }

    printf("Size required is %ld\n", Size);
    if( 0 == Size ) return ;

    Classes = LocalAlloc(LMEM_FIXED, Size);
    if( NULL == Classes ) {
        printf("Could not allocate memory: %ld\n", GetLastError());
        return;
    }

    RetVal = DhcpEnumClasses(0, AdapterName, &Size, Classes);
    if( ERROR_SUCCESS != RetVal ) {
        printf("Return value for second call = %ld\n", RetVal);
        return;
    }

    printf("Returned # of classes = %ld\n", Size);

    for( i = 0; i != Size ; i ++ ) {
        ULONG j;

        printf("Class [%ld] = <%ws, %ws> Data[%ld] : ", i, Classes[i].ClassName, Classes[i].ClassDescr, Classes[i].ClassDataLen);
        for( j = 0; j != Classes[i].ClassDataLen ; j ++ ) {
            printf("%02X ", Classes[i].ClassData[j]);
        }
        printf("\n");
    }
}

void
OptApiSetClass(int argc, char *argv[]) {
    WCHAR AdapterName[256];
    WCHAR UserClass[256];
    HKEY InterfacesKey, AdapterKey;
    DHCP_PNP_CHANGE Changes = {
        0,
        0,
        0,
        0,
        TRUE
    };
        
    ULONG Size, RetVal;
    ULONG i;

    // check for the size and # of arguments
    if( argc != 4 ) {
        fprintf(stderr, USAGE, argv[0]);
        exit(1);
    }

    // Now create a WSTR out of argv[2] and argv[3]
    if( strlen(argv[2]) != mbstowcs(AdapterName, argv[2], strlen(argv[2]))) {
        fprintf(stderr, "Could not convert %s to LPwSTR! sorry\n", argv[2]);
        exit(1);
    }

    UserClass[strlen(argv[3])] = L'\0';
    if( strlen(argv[3]) != mbstowcs(UserClass, argv[3], strlen(argv[3]))) {
        fprintf(stderr, "Could not convert %s to LPwSTR! sorry\n", argv[3]);
        exit(1);
    }
    UserClass[strlen(argv[3])] = L'\0';

    RetVal = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces",
        0,
        KEY_ALL_ACCESS,
        &InterfacesKey
        );
    if( ERROR_SUCCESS != RetVal ) {
        printf("Couldn't open Tcpip\\Interfaces key: %ld\n", RetVal);
        return;
    }

    RetVal = RegOpenKeyExW(
        InterfacesKey,
        AdapterName,
        0,
        KEY_ALL_ACCESS,
        &AdapterKey
        );
    if( ERROR_SUCCESS != RetVal ) {
        printf("Couldn't open Tcpip\\Interfaces\\%ws key : %ld\n", AdapterName, RetVal);
        return;
    }

    RetVal = RegSetValueExW(
        AdapterKey,
        L"DhcpClassId",
        0,
        REG_SZ,
        (LPBYTE)UserClass,
        (wcslen(UserClass)+1)*sizeof(WCHAR)
        );

    if( ERROR_SUCCESS != RetVal ) {
        printf("RegSetValueExW(DhcpClassId): %ld\n", RetVal);
        return;
    }

    RetVal = DhcpHandlePnPEvent(
        0,
        1,
        AdapterName,
        &Changes,
        NULL
        );
    printf("DhcpHandlePnPEvent: %ld\n", RetVal);
    
}

void __cdecl
main(int argc, char *argv[]) {
    if(argc < 2) {
        fprintf(stderr, USAGE, argv[0]);
        exit(1);
    }

    if(!_stricmp(argv[1], "GetOptions")) {
        OptApiGetOptions(argc, argv);
    } else if(!_stricmp(argv[1], "TestEvents")) {
        OptApiTestEvents(argc, argv);
    } else if(!_stricmp(argv[1], "Release") ) {
        OptApiRelease(argc, argv);
    } else if(!_stricmp(argv[1], "Renew") ) {
        OptApiRenew(argc, argv);
    } else if(!_stricmp(argv[1], "EnumClasses" ) ){
        OptApiEnumClasses(argc, argv);
    } else if(!_stricmp(argv[1], "SetClass" ) ) {
        OptApiSetClass(argc, argv);
    } else {
        // currently support for no other command.
        fprintf(stderr, USAGE, argv[0]);
        exit(1);
    }

    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\nlanotif.c ===
#include "precomp.h"
#include "nlasvc.h"
#include "nlanotif.h"

CRITICAL_SECTION gNLA_LPC_CS;
HANDLE ghNLA_LPC_Port = NULL;

HANDLE
NLAConnectLPC()
{
    // Connect via LPC to the Winsock Mobility system service.
    HANDLE h = NULL;
    SECURITY_QUALITY_OF_SERVICE DynamicQoS = 
        {
            sizeof(SECURITY_QUALITY_OF_SERVICE),
            SecurityAnonymous,
            SECURITY_DYNAMIC_TRACKING,
            FALSE
        };
    WSM_LPC_DATA        data;
    ULONG               dataLength = sizeof(data);
    UNICODE_STRING      portName;
    DWORD               retCode;

    DhcpPrint((DEBUG_TRACK, "Entering NLAConnectLPC.\n"));

    RtlZeroMemory(&data, sizeof(data));
    data.signature = WSM_SIGNATURE;
    data.connect.version.major = WSM_VERSION_MAJOR;
    data.connect.version.minor = WSM_VERSION_MINOR;

    RtlInitUnicodeString(&portName, WSM_PRIVATE_PORT_NAME);

    retCode = NtConnectPort(
                    &h,
                    &portName,
                    &DynamicQoS,
                    NULL,
                    NULL, 
                    NULL,
                    &data, &dataLength);

    if ( retCode != STATUS_SUCCESS)
    {
        DhcpPrint((DEBUG_TRACK, "NtConnectPort failed with errCode 0x%08x.\n", retCode));

        if (h != NULL)
        {
            CloseHandle(h);
            h = NULL;
        }
    }

    DhcpPrint((DEBUG_TRACK, "Exiting NLAConnectLPC.\n"));

    return (h);

} // NLAConnectLPC

void
NLANotifyDHCPChange() 
{
    WSM_LPC_MESSAGE message;
    DWORD           retCode;

    DhcpPrint((DEBUG_TRACK, "Entering NLANotifyDHCPChange.\n"));

    EnterCriticalSection(&gNLA_LPC_CS);

    // Connect to the NLA service if necessary.
    if (ghNLA_LPC_Port == NULL)
    {
        if ((ghNLA_LPC_Port = NLAConnectLPC()) == NULL)
        {
            LeaveCriticalSection(&gNLA_LPC_CS);

            DhcpPrint((DEBUG_TRACK, "Exiting NLANotifyDHCPChange as 1st call to NLAConnectLPC() failed.\n"));

	    return;
        }
    }

    // Send change notification to the NLA service.
    RtlZeroMemory(&message, sizeof(message));
    message.portMsg.u1.s1.TotalLength = sizeof(message);
    message.portMsg.u1.s1.DataLength = sizeof(message.data);
    message.data.signature = WSM_SIGNATURE;
    message.data.request.type = DHCP_NOTIFY_CHANGE; //WSM_LPC_REQUEST::DHCP_NOTIFY_CHANGE;

    retCode = NtRequestPort(ghNLA_LPC_Port, (PPORT_MESSAGE)&message);
    if (retCode != STATUS_SUCCESS) 
    {
        DhcpPrint((DEBUG_TRACK, "NLANotifyDHCPChange: NtRequestPort failed with errCode 0x%08x.\n", retCode));

	// It's possible the service was stopped and restarted.
	// Ditch the old LPC connection.
        CloseHandle(ghNLA_LPC_Port);
	
	// Create a new LPC connection.
	if ((ghNLA_LPC_Port = NLAConnectLPC()) == NULL) 
        {
            LeaveCriticalSection(&gNLA_LPC_CS);

            DhcpPrint((DEBUG_TRACK, "Exiting NLANotifyDHCPChange as 2nd call to NLAConnectLPC() failed.\n"));

	    return;
	}

	// Try the notification one last time.
        NtRequestPort(ghNLA_LPC_Port, (PPORT_MESSAGE)&message);
    }

    LeaveCriticalSection(&gNLA_LPC_CS);

    DhcpPrint((DEBUG_TRACK, "Exiting NLANotifyDHCPChange.\n"));

} // NLANotifyDHCPChange
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\mdhcptst.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    mdhcptst.c

--*/

#include "precomp.h"

// only when the api is defined!
#include <dhcploc.h>
#include <dhcppro.h>
#include <mdhcpcli.h>

#define CREATE_NEW_REQUEST_FROM_RESPONSE(pRequest, pResponse) {  \
    (pRequest)->LeaseStartTime = (pRequest)->MaxLeaseStartTime = 0; \
    (pRequest)->LeaseDuration = (pRequest)->MinLeaseDuration = 0; \
    (pRequest)->MinAddrCount = (pRequest)->AddrCount = (pResponse)->AddrCount;    \
    (pRequest)->ServerAddress = (pResponse)->ServerAddress; \
    memcpy((pRequest)->pAddrBuf, (pResponse)->pAddrBuf, sizeof (DWORD)*(pRequest)->AddrCount); \
}

typedef enum _cmd{
    EnumScope    = 1,
    RequestAddr  = 2,
    RenewAddr    = 3,
    ReleaseAddr  = 4,
    ExitLoop     = 99
} COMMAND;

PMCAST_SCOPE_ENTRY    gScopeList = NULL;
DWORD                 gScopeCount = 0;
LPMCAST_CLIENT_UID    gAddrRequestId = NULL;

typedef struct _LeaseEntry {
    IPNG_ADDRESS            ScopeID;
    PMCAST_LEASE_RESPONSE   pLeaseInfo;
    LPMCAST_CLIENT_UID      pRequestID;
    LIST_ENTRY              Linkage;
} LEASE_ENTRY, *PLEASE_ENTRY;

LIST_ENTRY gLeaseList;

void
InitializeGlobalData()
{
    InitializeListHead(&gLeaseList);
    return;
}

void
DisplayMenu()
{
    printf("MDHCP Test Menu\n");
    printf("===============\n");
    printf("[1] - Enumerate Scopes:\n");
    printf("[2] - Request Address:\n");
    printf("[3] - Renew Address:\n");
    printf("[4] - Release Address: \n");
    printf("[99] - Exit:\n");
}
int
GetCommand()
{
    DWORD   cmd;
    printf("Enter choice:");
    if(scanf("%d",&cmd)) return cmd;
    return 0;
}

DWORD
EnumScopes()
{
    DWORD Error;
    DWORD BufLen;

    if ( gScopeList ) {
        DhcpFreeMemory( gScopeList );
        gScopeList = NULL;
    }
    Error = McastEnumerateScopes(
                AF_INET,
                TRUE,
                NULL,
                &BufLen,
                &gScopeCount
                );
    if (ERROR_SUCCESS != Error) {
        printf("Could not get the scope buf length, %ld\n",Error );
        return Error;
    }

    gScopeList = DhcpAllocateMemory( BufLen );
    Error = McastEnumerateScopes(
                AF_INET,
                FALSE,
                gScopeList,
                &BufLen,
                &gScopeCount);
    if (ERROR_SUCCESS != Error) {
        printf("Could not get the scope list- 2nd call, %ld\n",Error );
        DhcpFreeMemory( gScopeList );
        gScopeList = NULL;
        return Error;
    }
    DhcpAssert( gScopeCount > 0 );
    return Error;
}


void
DisplayScopes()
{
    DWORD i;
    PMCAST_SCOPE_ENTRY pScope = gScopeList;

    for (i = 0;i<gScopeCount; i++,pScope++) {
        printf("[%d] - ScopeId %lx, LastAddr %lx, ttl %d, Name %ws\n",
               i+1,ntohl(pScope->ScopeCtx.ScopeID.IpAddrV4),
               ntohl(pScope->LastAddr.IpAddrV4), pScope->TTL,  pScope->ScopeDesc.Buffer);
    }
    return;
}


void
PrintLeaseInfo(PMCAST_LEASE_RESPONSE pLeaseInfo, BOOL Verbose )
{
    DHCP_IP_ADDRESS IpAddress = *(DWORD UNALIGNED *)pLeaseInfo->pAddrBuf;
    time_t tempTime;

    printf("Obtained IPAddress - %s\n",inet_ntoa(*(struct in_addr *)&IpAddress));
    if ( Verbose ) {
        tempTime = pLeaseInfo->LeaseEndTime;

        printf("Expires - %.19s", asctime(localtime(&tempTime)));
    }
}

VOID
DisplayCurrentLeases()
{
    PLEASE_ENTRY        pLeaseEntry;
    PLIST_ENTRY         p;
    DWORD               i;

    for (p = gLeaseList.Flink,i=1; p != &gLeaseList; p = p->Flink,i++ ) {
        pLeaseEntry = CONTAINING_RECORD(p, LEASE_ENTRY, Linkage);
        printf("[%d] ", i);PrintLeaseInfo( pLeaseEntry->pLeaseInfo, FALSE );
    }
    return;
}

PLEASE_ENTRY
SelectFromCurrentLease(COMMAND cmd)
{
    PLIST_ENTRY p;
    DWORD       index;
    DWORD       i;
    PLEASE_ENTRY    pLeaseEntry = NULL;
    if (cmd != RenewAddr && cmd != ReleaseAddr) {
        DhcpAssert( FALSE );
    }
    printf("CURRENT LEASE ASSIGNMENTS\n");
    printf("-------------------------\n");

    DisplayCurrentLeases();
    printf("Select the lease you want to %s\n", RenewAddr == cmd ? "Renew" : "Release" );
    index = GetCommand();
    if ( !index ) {
        printf("Lease index invalid\n");
        return NULL;
    }
    for (p = gLeaseList.Flink,i=0; p != &gLeaseList; p = p->Flink ) {
        if (++i == index) {
            pLeaseEntry = CONTAINING_RECORD(p, LEASE_ENTRY, Linkage);
            return pLeaseEntry;
        }
    }
    printf("Error:invalid selection, choose the index from the list of the leases above\n");
    return NULL;
}

DWORD
ReleaseAddress()
{
    PLEASE_ENTRY            pLeaseEntry;
    PMCAST_LEASE_REQUEST    AddrRequest;
    DWORD                   Error;
    DWORD                   i;


    pLeaseEntry = SelectFromCurrentLease(ReleaseAddr);

    if (!pLeaseEntry) {
        return ERROR_FILE_NOT_FOUND;
    }
    AddrRequest = DhcpAllocateMemory( sizeof( *AddrRequest ) + sizeof(DHCP_IP_ADDRESS));
    if (!AddrRequest) {
        printf("Failed to allocate lease info struct\n",AddrRequest);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(AddrRequest, sizeof(*AddrRequest) + sizeof(DHCP_IP_ADDRESS));
    AddrRequest->pAddrBuf = (PBYTE) AddrRequest + sizeof(*AddrRequest);

    CREATE_NEW_REQUEST_FROM_RESPONSE(AddrRequest, pLeaseEntry->pLeaseInfo);

    Error = McastReleaseAddress(
                AF_INET,
                pLeaseEntry->pRequestID,
                AddrRequest
                );

    if (ERROR_SUCCESS == Error ) {
        printf("Lease Released successfully\n");
        RemoveEntryList( &pLeaseEntry->Linkage );
        // free the old lease structure.
        DhcpFreeMemory( pLeaseEntry->pRequestID );
        DhcpFreeMemory( pLeaseEntry->pLeaseInfo );
    }
    DhcpFreeMemory(AddrRequest);
    return Error;
}

DWORD
RenewAddress()
{
    PLEASE_ENTRY pLeaseEntry;
    PMCAST_LEASE_REQUEST    AddrRequest;
    PMCAST_LEASE_RESPONSE  AddrResponse;
    PMCAST_LEASE_RESPONSE  pLeaseInfo;
    PMCAST_SCOPE_ENTRY        Scope;
    DWORD               Error;
    DWORD               i;

    pLeaseEntry = SelectFromCurrentLease(RenewAddr);
    if (!pLeaseEntry) {
        return ERROR_FILE_NOT_FOUND;
    }

    pLeaseInfo = pLeaseEntry->pLeaseInfo;
    // find the scope ctx for this scope id.
    if (pLeaseEntry->ScopeID.IpAddrV4) {
        for (i=0;i<gScopeCount;i++) {
            if (pLeaseEntry->ScopeID.IpAddrV4 == gScopeList[i].ScopeCtx.ScopeID.IpAddrV4) {
                Scope = &gScopeList[i];
                break;
            }
        }
        if (i >= gScopeCount) {
            printf("Could not find the scope ctx for the scope id %ld of this address\n",pLeaseEntry->ScopeID.IpAddrV4);
            return ERROR_FILE_NOT_FOUND;
        }
    } else {
        // default scope
        Scope = NULL;
    }

    AddrRequest = DhcpAllocateMemory( sizeof( *AddrRequest ) + sizeof(DHCP_IP_ADDRESS));
    if (!AddrRequest) {
        printf("Failed to allocate lease info struct\n",AddrRequest);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(AddrRequest, sizeof(*AddrRequest) + sizeof(DHCP_IP_ADDRESS));
    AddrRequest->pAddrBuf = (PBYTE) AddrRequest + sizeof(*AddrRequest);

    CREATE_NEW_REQUEST_FROM_RESPONSE(AddrRequest, pLeaseInfo);
    AddrResponse = DhcpAllocateMemory( sizeof( *AddrResponse ) + sizeof(DHCP_IP_ADDRESS));
    if (!AddrResponse) {
        printf("Failed to allocate lease info struct\n",AddrResponse);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(AddrResponse, sizeof(*AddrResponse) + sizeof(DHCP_IP_ADDRESS));
    AddrResponse->pAddrBuf = (PBYTE) AddrResponse + sizeof(*AddrResponse);
    AddrResponse->AddrCount = 1;
    Error = McastRenewAddress(
                AF_INET,
                pLeaseEntry->pRequestID,
                AddrRequest,
                AddrResponse
                );

    if (ERROR_SUCCESS == Error ) {
        printf("Lease Renew'd successfully\n");
        PrintLeaseInfo( AddrResponse, TRUE );
        pLeaseEntry->pLeaseInfo = AddrResponse;
        // free the old lease structure.
        DhcpFreeMemory( pLeaseInfo );
    } else {
        DhcpFreeMemory( AddrResponse );
    }

    DhcpFreeMemory( AddrRequest );
    return Error;
}

DWORD
RequestAddress()
{
    PMCAST_LEASE_REQUEST   AddrRequest;
    PMCAST_LEASE_RESPONSE AddrResponse;
    LPMCAST_CLIENT_UID   pRequestID;
    DWORD               index;
    DWORD               Error;
    PLEASE_ENTRY         pLeaseEntry;

    DisplayScopes();
    printf("Select the scope entry(0 for default scope)\n");
    index = GetCommand();
    if ( index > gScopeCount ) {
        printf("Scope index out of range\n");
        return ERROR_INVALID_PARAMETER;
    }


    AddrResponse = DhcpAllocateMemory( sizeof( *AddrResponse ) + sizeof(DHCP_IP_ADDRESS));
    if (!AddrResponse) {
        printf("Failed to allocate lease info struct\n",AddrResponse);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(AddrResponse, sizeof(*AddrResponse)+ sizeof(DHCP_IP_ADDRESS));
    AddrResponse->pAddrBuf = (PBYTE) AddrResponse + sizeof(*AddrResponse);

    AddrRequest = DhcpAllocateMemory( sizeof( *AddrRequest ));
    if (!AddrRequest) {
        printf("Failed to allocate lease info struct\n",AddrRequest);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory(AddrRequest, sizeof(*AddrRequest));

    AddrRequest->AddrCount = AddrResponse->AddrCount = 1;


    pRequestID = DhcpAllocateMemory(sizeof(*pRequestID) + MCAST_CLIENT_ID_LEN);
    if (!pRequestID) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pRequestID->ClientUID = (char *)pRequestID + sizeof(*pRequestID);
    pRequestID->ClientUIDLength = MCAST_CLIENT_ID_LEN;

    Error = McastGenUID( pRequestID );
    DhcpAssert( ERROR_SUCCESS == Error );

    Error = McastRequestAddress(
                AF_INET,
                pRequestID,
                index ? &gScopeList[index-1].ScopeCtx : NULL,
                AddrRequest,
                AddrResponse
                );

    if (ERROR_SUCCESS == Error ) {
        printf("Lease obtained successfully\n");
        PrintLeaseInfo( AddrResponse, TRUE );

        // now copy this lease into our global structure.
        pLeaseEntry = DhcpAllocateMemory( sizeof(LEASE_ENTRY) );
        if (!pLeaseEntry) {
            printf("Failed to allocate lease entry item\n");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        pLeaseEntry->pLeaseInfo = AddrResponse;
        pLeaseEntry->ScopeID.IpAddrV4    = index ? gScopeList[index-1].ScopeCtx.ScopeID.IpAddrV4 : 0;
        pLeaseEntry->pRequestID = pRequestID;

        InsertTailList(&gLeaseList, &pLeaseEntry->Linkage);

    } else {
        DhcpFreeMemory( pRequestID );
        DhcpFreeMemory( AddrResponse );
    }
    DhcpFreeMemory( AddrRequest );
    return Error;

}
int
__cdecl
main( int argc, char *argv[])
{
    DWORD   cmd;
    DWORD   Error;
    DWORD   Version;

    InitializeGlobalData();

    Version = MCAST_API_CURRENT_VERSION;
    if (ERROR_SUCCESS != McastApiStartup(&Version)) {
        printf("Current version %d not supported, Api Impl version %d\n",
               MCAST_API_CURRENT_VERSION, Version);
        return 0;
    }
    DisplayMenu();
    while(cmd = GetCommand() ){
        switch (cmd) {
        case EnumScope:
             Error = EnumScopes();
             if (ERROR_SUCCESS != Error ) {
                 printf("Enumerate Scope returned failures, %ld\n",Error);
             } else {
                 DisplayScopes();
             }
             break;
        case RequestAddr:
            Error = RequestAddress();
            if (ERROR_SUCCESS != Error ) {
                printf("RequestAddress returned failures, %ld\n",Error);
            }
            break;
        case RenewAddr:
            Error = RenewAddress();
            if (ERROR_SUCCESS != Error ) {
                printf("RenewAddress returned failures, %ld\n",Error);
            }
            break;
        case ReleaseAddr:
            Error = ReleaseAddress();
            if (ERROR_SUCCESS != Error ) {
                printf("ReleaseAddress returned failures, %ld\n",Error);
            }
            break;
        case ExitLoop:
            printf("Exiting\n");
            return 0;
        default:
            printf("invalid choice\n");
            break;
        }
        DisplayMenu();
    }
    return 0;
}

#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\tdhcpcapi.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: Tests the dhcp api as exported in dhcpsdk.h
//================================================================================
#include "precomp.h"
#include <dhcpcsdk.h>
#include <wchar.h>

HANDLE      tGlobalHandle = INVALID_HANDLE_VALUE;

#define     fatal(str, err) do{  printf("%s: %ld (0x%lx)\n", (#str), (err), (err)); exit(1); }while(0)
#define     error(str, err) do{ printf("%s: %ld (0x%lx)\n", (#str), (err), (err)); }while(0)

ULONG
MakeDword(
    IN      LPWSTR                 Arg
)
{
    LPWSTR                         ArgEnd;
    ULONG                          Ret;

    Ret = wcstoul(Arg, &ArgEnd, 0);
    if( *ArgEnd ) {
        printf("[%ws] is not a valid number, assumed 0 instead\n", Arg);
        return 0;
    }

    return Ret;
}

LPWSTR
MakeLpwstr(
    IN      LPWSTR                 Arg
)
{
    if( 0 == _wcsicmp(Arg, L"NULL") ) {
        return NULL;
    }

    return Arg;
}

VOID
MakeHexBytes(
    IN OUT  LPBYTE                *HexBytes,
    IN OUT  DWORD                 *nHexBytes,
    IN OUT  LPWSTR                 HexStr
)
{
    CHAR                           Low, High;
    LPBYTE                         HexByteString;

    if( wcslen(HexStr) % 2 ) {
        fatal(MakeHexBytes expects a even number of hex bytes!!!, ERROR_INVALID_DATA);
    }

    *nHexBytes = 0;
    *HexBytes = HexByteString = (LPBYTE)HexStr;

    while(*HexStr) {
        Low = (CHAR)*HexStr++;
        High = (CHAR)*HexStr++;

        if( Low >= '0' && Low <= '9' ) Low -= '0';
        else if( Low >= 'A' && Low <= 'F' ) Low = Low - 'A' + 10;
        else if( Low >= 'a' && Low <= 'f' ) Low = Low - 'a' + 10;
        else fatal(MakeHexBytes expects number in range 0 to 9 and A to F only, 0);

        if( High >= '0' && High <= '9' ) High -= '0';
        else if( High >= 'A' && Low <= 'F' ) High = High - 'A' + 10;
        else if( High >= 'a' && Low <= 'f' ) High = High - 'a' + 10;
        else fatal(MakeHexBytes expects number in range 0 to 9 and A to F only, 0);

        *HexByteString ++ = (BYTE)((Low<<4)|High);
        (*nHexBytes) ++;
    }
    if( 0 == *nHexBytes ) *HexBytes = NULL;
}

VOID
MakeParams(
    IN OUT  PDHCPCAPI_PARAMS_ARRAY Params,
    IN      LPWSTR                 Str
)
{
    ULONG                          i, Count, Mod;
    LPWSTR                         Start, First, Second,Third;

    if( L'\0' == *Str ) {
        Params->nParams = 0;
        Params->Params = NULL;
        return ;
    }

    Count = 1; Mod = 0;
    Start = Str;
    while(*Str) {
        if(L',' == *Str) {
            Mod ++;
            if( Mod == 3 ) {
                Mod = 0;
                Count ++;
            }
            *Str = L'\0';
        }
        Str ++;
    }

    if( 2 != Mod ) {
        printf("Invalid DHCPCAPI_PARAMS_ARRAY data! Ignored\n");
        Params->nParams = 0;
        Params->Params = NULL;
        return ;
    }

    Params->nParams = Count;
    Params->Params = LocalAlloc(LMEM_FIXED, sizeof(DHCPCAPI_PARAMS)*Count);
    if( NULL == Params->Params ) {
        fatal(MakeParams-not enough memory, ERROR_NOT_ENOUGH_MEMORY);
    }

    Str = Start;
    for( i = 0; i < Count ; i ++ ) {
        First = Str;
        Second = wcslen(Str)+Str+1; Str = Second;
        Third = wcslen(Str)+Str+1; Str = Third + wcslen(Third) + 1;

        Params->Params[i].Flags = MakeDword(First);
        if( 'v' == *Second || 'V' == *Second ) {
            Params->Params[i].IsVendor = TRUE;
            Second ++;
        } else {
            Params->Params[i].IsVendor = FALSE;
        }
        Params->Params[i].OptionId = MakeDword(Second);
        MakeHexBytes(&Params->Params[i].Data, &Params->Params[i].nBytesData, Third);
    }
}

VOID
UnMakeParams(
    IN      PDHCPCAPI_PARAMS_ARRAY Params
)
{
    if( NULL != Params->Params ) {
        LocalFree(Params->Params);
    }
}

VOID
PrintHex(
    IN      ULONG                  Count,
    IN      LPBYTE                 Data
)
{
    BYTE                           cData;

    while(Count --) {
        cData = *Data++;
        if( (cData>>4) < 10 ) printf("%c", '0' + (cData>>4));
        else printf("%c", 'A' + (cData>>4) - 10 );
        if( (cData& 0xF) < 10 ) printf("%c", '0' + (cData&0xF));
        else printf("%c", 'A' + (cData&0xF) - 10 );
    }
}

VOID
PrintParams(
    IN      PDHCPCAPI_PARAMS_ARRAY Params
)
{
    ULONG                          Count;
    printf("\t{%ld,", Params->nParams);
    if( Params->nParams ) {
        printf("{");
        for( Count = 0; Count < Params->nParams ; Count ++ ) {
            printf("[0x%lx,%ld,", Params->Params[Count].Flags, Params->Params[Count].OptionId);
            PrintHex(Params->Params[Count].nBytesData, Params->Params[Count].Data);
            printf("] ");
        }
        printf("}");
    }
    printf("}\n");
}

ULONG
TestRequestParams(
    IN      LPWSTR                *Args,
    IN      ULONG                  nArgs
)
{
    DWORD                          Error;
    DWORD                          Flags;
    LPVOID                         Reserved;
    LPWSTR                         AdapterName, AppName;
    LPDHCPCAPI_CLASSID             ClassId;
    DHCPCAPI_PARAMS_ARRAY          SendParams;
    DHCPCAPI_PARAMS_ARRAY          RecdParams;
    BYTE                           Buffer[5000];
    DWORD                          Size;

    if( 8 != nArgs ) {
        printf("Usage: DhcpRequestParams Flags Reserved AdapterName ClassId SendParams RecdParams Size lpAppName\n");
        return ERROR_INVALID_PARAMETER;
    }

    Flags = MakeDword(Args[0]);
    Reserved = ULongToPtr(MakeDword(Args[1]));
    AdapterName = MakeLpwstr(Args[2]);
    ClassId = ULongToPtr(MakeDword(Args[3]));
    MakeParams(&SendParams, Args[4]);
    MakeParams(&RecdParams, Args[5]);
    Size = MakeDword(Args[6]);
    AppName = MakeLpwstr(Args[7]);

    printf("DhcpRequestParams(\n\t0x%lx,\n\t0x%p,\n\t%ws,\n\t0x%p,\n",
           Flags, Reserved, AdapterName, ClassId
    );
    PrintParams(&SendParams);
    PrintParams(&RecdParams);
    printf("\t0x%p,\n\t[Size = %ld],\n\t%ws\n\t);\n", (Size?Buffer:0), Size, AppName);

    Error = DhcpRequestParams(
        Flags,
        Reserved,
        AdapterName,
        ClassId,
        SendParams,
        RecdParams,
        Size?Buffer:0,
        &Size,
        AppName
    );

    printf("DhcpRequestParams: %ld (0x%lx) [Size = %ld]\n", Error, Error, Size);

    printf("Send, Recd Params are:\n");
    PrintParams(&SendParams);
    PrintParams(&RecdParams);
    UnMakeParams(&SendParams);
    UnMakeParams(&RecdParams);

    return 0;
}

ULONG
TestUndoRequestParams(
    IN      LPWSTR                *Args,
    IN      ULONG                  nArgs
)
{
    ULONG                          Flags;
    LPVOID                         Reserved;
    LPWSTR                         AdapterName, AppName;
    ULONG                          Error;

    if( nArgs != 4 ) {
        printf("usage: DhcpUndoRequestParams dwFlags dwReserved lpwAdapterName lpwAppName\n");
        return 0;
    }

    Flags = MakeDword(Args[0]);
    Reserved = ULongToPtr(MakeDword(Args[1]));
    AdapterName = MakeLpwstr(Args[2]);
    AppName = MakeLpwstr(Args[3]);

    printf("DhcpUndoRequestParams(\n\t0x%lx,\n\t%p,\n\t%ws,\n\t%ws\n\t);\n", Flags, Reserved, AdapterName, AppName);
    Error = DhcpUndoRequestParams(
        Flags,
        Reserved,
        AdapterName,
        AppName
    );

    printf("DhcpUndoRequestParams: %ld (0x%lx)\n", Error, Error);
    return 0;
}

ULONG
TestRegisterParamChange(
    IN      LPWSTR                *Args,
    IN      ULONG                  nArgs
)
{
    DWORD                          Error;
    DWORD                          Flags;
    LPVOID                         Reserved;
    LPWSTR                         AdapterName;
    LPDHCPCAPI_CLASSID             ClassId;
    DHCPCAPI_PARAMS_ARRAY          Params;
    HANDLE                         Handle;

    if( nArgs != 6 ) {
        printf("usage: DhcpRegisterParamChange dwFlags dwReserved lpwAdapterName dwClassId Params Handle\n");
        return 0;
    }
    printf("Handle of 0 causes NULL to be used, any other Handle will use default ptr\n");

    Flags = MakeDword(Args[0]);
    Reserved = ULongToPtr(MakeDword(Args[1]));
    AdapterName = MakeLpwstr(Args[2]);
    ClassId = ULongToPtr(MakeDword(Args[3]));
    MakeParams(&Params, Args[4]);
    Handle = ULongToPtr(MakeDword(Args[5]));

    printf("DhcpRegisterParamChange(\n\t0x%lx,\n\t%p,\n\t%ws,\n\t0x%p,\n", Flags, Reserved, AdapterName, ClassId);
    PrintParams(&Params);
    printf("0x%px\n\t);", Handle?&Handle: NULL);

    Error = DhcpRegisterParamChange(
        Flags,
        Reserved,
        AdapterName,
        ClassId,
        Params,
        (LPVOID)(Handle?&Handle:NULL)
    );

    printf("DhcpRegisterParamChange: %ld (0x%lx)\n", Error, Error);
    if( ERROR_SUCCESS == Error ) {
        tGlobalHandle = Handle;
    }

    printf("Handle: 0x%p\n", Handle);
    UnMakeParams(&Params);
    return 0;
}

ULONG
TestDeRegisterParamChange(
    IN      LPWSTR                *Args,
    IN      ULONG                  nArgs
)
{
    DWORD                          Error;
    DWORD                          Flags;
    LPVOID                         Reserved;
    HANDLE                         Handle;

    if( nArgs != 3 ) {
        printf("usage: DhcpRegisterParamChange dwFlags dwReserved Handle\n");
        return 0;
    }

    Flags = MakeDword(Args[0]);
    Reserved = ULongToPtr(MakeDword(Args[1]));
    Handle = ULongToPtr(MakeDword(Args[2]));

    printf("DhcpRegisterParamChange(\n\t0x%lx,\n\t%p,\n\t0x%p,\n\t);", Flags, Reserved, Handle);

    Error = DhcpDeRegisterParamChange(
        Flags,
        Reserved,
        Handle
    );
    printf("DhcpDeRegisterParamChange: %ld (0x%lx)\n", Error, Error);
    return 0;
}

ULONG
TestStaticRefreshParams(
    IN      LPWSTR                *Args,
    IN      ULONG                  nArgs
)
{
    DWORD                          Error;
    ULONG                          DhcpStaticRefreshParams( LPWSTR AdapterName );

    if( nArgs != 1 ) {
        printf("usage: DhcpStaticRefresh lpwAdapterName\n");
        return 0;
    }

    Error = DhcpStaticRefreshParams( MakeLpwstr(*Args) );
    printf("DhcpStaticRefreshParams( %ws ) : %ld\n", *Args, Error );

    return Error;
}

ULONG
DhcpApiTestLine(
    IN      LPWSTR                 Buf
)
{
    ULONG                          Error;
    LPWSTR                         Words[100];
    ULONG                          nWords;
    BOOL                           LastCharWasSpace = TRUE;

    nWords = 0;
    while( *Buf ) {                               // process each character till end
        if( *Buf == L'\t' || *Buf == L' ' || *Buf == L'\n' ) {
            if( FALSE == LastCharWasSpace ) {     // this char is space but last wasnt
                *Buf = L'\0' ;                    // terminate the run
                LastCharWasSpace = TRUE;          // change state
            }
        } else if( TRUE == LastCharWasSpace ) {   // this char is not space but last was
            Words[nWords++] = Buf;                // mark this as beginning of new string
            LastCharWasSpace = FALSE;             // change state
        }

        Buf ++;                                   // next character
    }

    if( 0 == nWords ) {
        error(Incorrect command. Please type help, 0);
        return 0;
    }

    if( 0 == _wcsicmp(Words[0], L"DhcpRequestParams") ) {
        return TestRequestParams(&Words[1], nWords-1);
    }
    if( 0 == _wcsicmp(Words[0], L"DhcpUndoRequestParams") ) {
        return TestUndoRequestParams(&Words[1], nWords-1);
    }
    if( 0 == _wcsicmp(Words[0], L"DhcpRegisterParamChange") ) {
        return TestRegisterParamChange(&Words[1], nWords-1);
    }
    if( 0 == _wcsicmp(Words[0], L"DhcpDeRegisterParamChange") ) {
        return TestDeRegisterParamChange(&Words[1], nWords-1);
    }
    if( 0 == _wcsicmp(Words[0], L"DhcpStaticRefresh") ) {
        return TestStaticRefreshParams(&Words[1], nWords-1);
    }

    printf("Unknown command!");
    while(nWords--) {
        printf("First word: %ws\n", Words[0]);
    }
    return 0;
}

ULONG
DhcpApiTestLoop(
    VOID
)
{
    ULONG                          Error;
    WCHAR                          Buffer[1000];

    printf("Usage:\n");
    printf(" For AdapterName use NULL to indicate NULL adaptername.\n");
    printf(" For Params, use a dash (-) to indcate no params.\n");
    printf(" For Params, syntax: flags,optid,[sequence of hex bytes or empty] {,flags,optid,[sequence of hex bytes]}*\n");
    printf(" For Params, prepend OptId with the character 'v' to make it vendor option.\n");
    printf(" Flags values -- DHCPCAPI_REQUEST_PERSISTENT - %ld\n", DHCPCAPI_REQUEST_PERSISTENT);
    printf(" Flags values -- DHCPCAPI_REQUEST_SYNCHRONOUS - %ld\n", DHCPCAPI_REQUEST_SYNCHRONOUS);
    printf(" Flags values -- DHCPCAPI_REGISTER_HANDLE_EVENT - %ld\n", DHCPCAPI_REGISTER_HANDLE_EVENT);
    printf("\n\n");
    printf("1)  DhcpRequestParams dwFlags dwReserved lpwAdapterName dwClassId SendParams RecdParams dwSize lpwAppName\n");
    printf("2)  DhcpUndoRequestParams dwFlags dwReserved lpwAdapterName lpwAppName\n");
    printf("3)  DhcpRegisterParamChange dwFlags dwReserved lpwAdapterName pClassId Params pHandle\n");
    printf("4)  DhcpDeRegisterParamChange dwFlags dwReserved dwEvent\n");
    printf("5)  DhcpStaticRefresh lpwAdapterName\n");

    do {
        printf("DHCP> ");
        if( NULL ==  _getws(Buffer) ) break;

        Error = DhcpApiTestLine(Buffer);
        if( ERROR_SUCCESS != Error ) {
            error(DhcpApiTestLine, Error);
        }
    } while(1);

    return 0;
}

void _cdecl main(void) {
    DWORD                          Error;

    Error = DhcpCApiInitialize(NULL);
    if( ERROR_SUCCESS != Error ) {
        fatal(DhcpApiInitialize, Error);
    }

    Error = DhcpApiTestLoop();
    if( ERROR_SUCCESS != Error ) {
        error(DhcpApiTestLoop, Error);
    }

    DhcpCApiCleanup();
    exit(0);
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\rastest.c ===
//==================================================================
//  Copyright (C) Microsoft 1998.  
//  Author: RameshV
//  Desription: test program to test the lease APIs for RAS.
//===================================================================

#include "precomp.h"
#include <dhcploc.h>
#include <dhcppro.h>

DHCP_OPTION_LIST DhcpOptList;
DWORD  AdapterAddress;
DWORD  Error;
DHCP_CLIENT_UID ClientUID;
LPDHCP_LEASE_INFO LeaseInfo;
DHCP_LEASE_INFO   LeaseInfo2;
LPDHCP_OPTION_INFO OptionInfo;

void
PrintLeaseInfo(
    LPDHCP_LEASE_INFO LeaseInfo
)
{
    DWORD Address, Mask, ServerAddress;

    if( NULL == LeaseInfo ) {
        printf("LeaseInfo = NULL\n");
        return;
    }

    Address = htonl(LeaseInfo->IpAddress);
    Mask = htonl(LeaseInfo->SubnetMask);
    ServerAddress = htonl(LeaseInfo->DhcpServerAddress);

    printf("LeaseInfo: \n");
    printf("\tIpAddress: %s\n", inet_ntoa(*(struct in_addr *)&Address));
    printf("\tSubnetMask: %s\n", inet_ntoa(*(struct in_addr *)&Mask));
    printf("\tDhcpServerAddress: %s\n", inet_ntoa(*(struct in_addr *)&ServerAddress));
    printf("\tLease: 0x%lx\n", LeaseInfo->Lease);
}

void
AcquireX(LPSTR clientid)
{

    ClientUID.ClientUIDLength = strlen(clientid);
    ClientUID.ClientUID = clientid;
    Error = DhcpLeaseIpAddress(
        AdapterAddress,
        &ClientUID,
        0,
        NULL,
        &LeaseInfo,
        &OptionInfo
    );

    if( ERROR_SUCCESS != Error ) {
        printf("DhcpLeaseIpAddress: 0x%lx (%ld)\n", Error, Error);
        return;
    }

    PrintLeaseInfo(LeaseInfo);

}

void
ReleaseOrRenew(BOOL fRelease, DWORD ipaddr, DWORD servaddr, LPSTR clientid)
{

    ClientUID.ClientUIDLength = strlen(clientid);
    ClientUID.ClientUID = clientid;
    
    AcquireX(clientid);

    if( fRelease ) {
        Error = DhcpReleaseIpAddressLease(
            AdapterAddress,
            LeaseInfo
        );
    } else {
        Error = DhcpRenewIpAddressLease(
            AdapterAddress,
            LeaseInfo,
            NULL,
            &OptionInfo
        );
    }

    if( ERROR_SUCCESS != Error ) {
        printf("Error; 0x%lx (%ld)\n", Error, Error);
        return;
    }

    printf("After the renew: \n");
    PrintLeaseInfo(LeaseInfo);

}

void
ReleaseX(DWORD ipaddr, DWORD servaddr, LPSTR clientid)
{
    ReleaseOrRenew(TRUE, ipaddr, servaddr, clientid);
}

void
RenewX(DWORD ipaddr, DWORD servaddr, LPSTR clientid)
{
    ReleaseOrRenew(FALSE, ipaddr, servaddr, clientid);
}

void
Release(
    int  argc,
    char *argv[]
)
{
    if( argc != 3 ) {
        printf("usage: Release ip-address server-address client-id-string\n");
        return;
    }
    ReleaseX(inet_addr(argv[0]), inet_addr(argv[1]), argv[2]);
}

void
Renew(
    int argc,
    char *argv[]
)
{
    if( argc != 3 ) {
        printf("usage: Renew ip-address server-address client-id-string\n");
        return;
    }
    RenewX(inet_addr(argv[0]), inet_addr(argv[1]), argv[2]);
}

void
Acquire(
    int  argc,
    char * argv[]
)
{
    if( argc != 1 ) {
        printf("usage: acquire client-id-string\n");
        return;
    }
    AcquireX(argv[0]);
}


void _cdecl main(int argc, char *argv[]) {
    WSADATA WsaData;
    
    WSAStartup( 0x0101, &WsaData );

    if( argc < 3 ) {
        printf("Usage: %s [adapter-address] cmd <options>"
               "\n\t where cmd is one of Release,Acquire,Renew\n", argv[0]);
        return;
    }  

    AdapterAddress = htonl(inet_addr(argv[1]));
    argv ++; argc --;

    if( 0 == _stricmp(argv[1], "Release") ) {
        Release(argc-2, &argv[2]);
    } else if( 0 == _stricmp(argv[1], "Renew") ) {
        Renew(argc-2, &argv[2]);
    } else if( 0 == _stricmp(argv[1], "Acquire") ) {
        Acquire(argc-2, &argv[2]);
    } else {
        printf("Usage: %s cmd <options>"
                "\n\t where cmd is one of Release,Acquire,Renew\n", argv[0]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpmib\makefile.inc ===
obj\$(TARGET_DIRECTORY)\dhcptst.res: dhcptst.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpmib\dhcpmibm.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dhcpmibm.c

Abstract:

    Sample SNMP Extension Agent for Windows NT.

    These files (dhcpdll.c, dhcpsmib.c, and dhcpmib.h) provide an example of 
    how to structure an Extension Agent DLL which works in conjunction with 
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

    28-Jun-1991

Revision History:

--*/


#ifdef UNICODE
#undef UNICODE
#endif

// General notes:
//
//   Microsoft's Extendible Agent for Windows NT is implemented by dynamically
// linking to Extension Agent DLLs that implement portions of the MIB.  These
// Extension Agents are configured in the Windows NT Registration Database.
// When the Extendible Agent Service is started, it queries the registry to
// determine which Extension Agent DLLs have been installed and need to be
// loaded and initialized.  The Extendible Agent invokes various DLL entry
// points (examples follow in this file) to request MIB queries and obtain
// Extension Agent generated traps.


// Necessary includes.

#include <windows.h>

#include <snmp.h>


// Contains definitions for the table structure describing the MIB.  This
// is used in conjunction with dhcpmib.c where the MIB requests are resolved.

#include "dhcpmib.h"


// Extension Agent DLLs need access to elapsed time agent has been active.
// This is implemented by initializing the Extension Agent with a time zero
// reference, and allowing the agent to compute elapsed time by subtracting
// the time zero reference from the current system time.  This example
// Extension Agent implements this reference with dwTimeZero.

DWORD dwTimeZero = 0;


// Extension Agent DLLs that generate traps must create a Win32 Event object
// to communicate occurence of traps to the Extendible Agent.  The event
// handle is given to the Extendible Agent when the Extension Agent is 
// initialized, it should be NULL if traps will not be generated.  This
// example Extension Agent simulates the occurance of traps with hSimulateTrap.

HANDLE hSimulateTrap = NULL;


// This is a standard Win32 DLL entry point.  See the Win32 SDK for more
// information on its arguments and their meanings.  This example DLL does 
// not perform any special actions using this mechanism.

BOOL WINAPI DllMain(
    HANDLE hDll,
    DWORD  dwReason,
    LPVOID lpReserved)
    {
    switch(dwReason)
        {
        case DLL_PROCESS_ATTACH:
        case DLL_PROCESS_DETACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;

        } // end switch()

    return TRUE;

    } // end DllEntryPoint()


// Extension Agent DLLs provide the following entry point to coordinate the
// initializations of the Extension Agent and the Extendible Agent.  The
// Extendible Agent provides the Extension Agent with a time zero reference;
// and the Extension Agent provides the Extendible Agent with an Event handle 
// for communicating occurence of traps, and an object identifier representing
// the root of the MIB subtree that the Extension Agent supports.

BOOL SnmpExtensionInit(
    IN  DWORD               dwTimeZeroReference,
    OUT HANDLE              *hPollForTrapEvent,
    OUT AsnObjectIdentifier *supportedView)
    {

    // Record the time reference provided by the Extendible Agent.

    dwTimeZero = dwTimeZeroReference;


    // Create an Event that will be used to communicate the occurence of traps
    // to the Extendible Agent.  The Extension Agent will assert this Event
    // when a trap has occured.  This is explained further later in this file.

    if ((*hPollForTrapEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
        // Indicate error?, be sure that NULL is returned to Extendible Agent.
        }


    // Indicate the MIB view supported by this Extension Agent, an object
    // identifier representing the sub root of the MIB that is supported.

    *supportedView = MIB_OidPrefix; // NOTE!  structure copy


    // Record the trap Event.  This example Extension Agent simulates traps by 
    // generating a trap after every given number of processed requests.

    hSimulateTrap = *hPollForTrapEvent;


    // Indicate that Extension Agent initialization was sucessfull.

    return TRUE;

    } // end SnmpExtensionInit()


// Extension Agent DLLs provide the following entry point to communcate traps
// to the Extendible Agent.  The Extendible Agent will query this entry point
// when the trap Event (supplied at initialization time) is asserted, which
// indicates that zero or more traps may have occured.  The Extendible Agent 
// will repetedly call this entry point until FALSE is returned, indicating 
// that all outstanding traps have been processed.

BOOL SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger          *genericTrap,
    OUT AsnInteger          *specificTrap,
    OUT AsnTimeticks        *timeStamp,
    OUT RFC1157VarBindList  *variableBindings)
    {
    // The body of this routine is an extremely simple example/simulation of
    // the trap functionality.  A real implementation will be more complex.


    // The following define data inserted into the trap below.  The Lan Manager
    // bytesAvailAlert from the Lan Manager Alerts-2 MIB is generated with an
    // empty variable bindings list.

    static UINT OidList[]  = { 1, 3, 6, 1, 4, 1, 311, 2 };
    static UINT OidListLen = 8;


    // The following variable is used for the simulation, it allows a single
    // trap to be generated and then causes FALSE to be returned indicating
    // no more traps.

    static whichTime = 0;


    // The following if/else support the simulation.

    if (whichTime == 0)
        {
        whichTime = 1;    // Supports the simulation.


        // Communicate the trap data to the Extendible Agent.

        enterprise->idLength = OidListLen;
        enterprise->ids = (UINT *)SnmpUtilMemAlloc(sizeof(UINT) * OidListLen);

	if (NULL == enterprise->ids) {
	    whichTime = 0;
	    return FALSE;
	}
        memcpy(enterprise->ids, OidList, sizeof(UINT) * OidListLen);

        *genericTrap      = SNMP_GENERICTRAP_ENTERSPECIFIC;

        *specificTrap     = 1;                    // the bytesAvailAlert trap

        *timeStamp        = GetCurrentTime() - dwTimeZero;

        variableBindings->list = NULL;
        variableBindings->len  = 0;


        // Indicate that valid trap data exists in the parameters.

        return TRUE;
        }
    else
        {
        whichTime = 0;    // Supports the simulation.


        // Indicate that no more traps are available and parameters do not
        // refer to any valid data.

        return FALSE;
        }

    } // end SnmpExtensionTrap()


// Extension Agent DLLs provide the following entry point to resolve queries
// for MIB variables in their supported MIB view (supplied at initialization
// time).  The requestType is Get/GetNext/Set.

BOOL SnmpExtensionQuery(
    IN BYTE                   requestType,
    IN OUT RFC1157VarBindList *variableBindings,
    OUT AsnInteger            *errorStatus,
    OUT AsnInteger            *errorIndex)
{
    static unsigned long requestCount = 0;  // Supports the trap simulation.
    UINT    I;


try {
    //
    // Iterate through the variable bindings list to resolve individual
    // variable bindings.
    //

    fDhcpMibVarsAccessed = FALSE;
    for ( I=0;I < variableBindings->len;I++ )
    {
        *errorStatus = ResolveVarBind( &variableBindings->list[I],
                                       requestType );


	//
        // Test and handle case where Get Next past end of MIB view supported
        // by this Extension Agent occurs.  Special processing is required to 
        // communicate this situation to the Extendible Agent so it can take 
        // appropriate action, possibly querying other Extension Agents.
	//

        if ( *errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME &&
             requestType == MIB_GETNEXT )
           {
           *errorStatus = SNMP_ERRORSTATUS_NOERROR;


           // Modify variable binding of such variables so the OID points
           // just outside the MIB view supported by this Extension Agent.
           // The Extendible Agent tests for this, and takes appropriate
           // action.

           SnmpUtilOidFree( &variableBindings->list[I].name );
           SnmpUtilOidCpy( &variableBindings->list[I].name, &MIB_OidPrefix );
           variableBindings->list[I].name.ids[MIB_PREFIX_LEN-1] ++;
           }


        // If an error was indicated, communicate error status and error
        // index to the Extendible Agent.  The Extendible Agent will ensure
        // that the origional variable bindings are returned in the response
        // packet.

        if ( *errorStatus != SNMP_ERRORSTATUS_NOERROR )
        {
	   *errorIndex = I+1;
	//   goto Exit;
	}
	else
	{
	   *errorIndex = 0;
	}
   }

} // end of try
except(EXCEPTION_EXECUTE_HANDLER) {
	//
	// for now do nothing
	//	
	}

#if 0
    // Supports the trap simulation.

    if (++requestCount % 3 == 0 && hSimulateTrap != NULL)
        SetEvent(hSimulateTrap);


    // Indicate that Extension Agent processing was sucessfull.


#if 0
      if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
      {
	 return(FALSE);
      }	

    return TRUE;
#endif
#endif
    return SNMPAPI_NOERROR;

} // end SnmpExtensionQuery()


//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpmib\dhcpmib.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dhcpmib.h

Abstract:

    Sample SNMP Extension Agent for Windows NT.

    These files (dhcpmibm.c, dhcpmib.c, and dhcpmib.h) provide an example of 
    how to structure an Extension Agent DLL which works in conjunction with 
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

    12-jan-1994

Revision History:

--*/

#ifndef dhcpmib_h
#define dhcpmib_h

// Necessary includes.

#include <snmp.h>


// MIB Specifics.

#define MIB_PREFIX_LEN            MIB_OidPrefix.idLength
#define MAX_STRING_LEN            255


// Ranges and limits for specific MIB variables.





#define NON_ASN_USED_RANGE_START	0xe0	//high 3 bits not used by
						//ASN
//
// MIB function actions.
//

#define MIB_GET         ASN_RFC1157_GETREQUEST
#define MIB_SET         ASN_RFC1157_SETREQUEST
#define MIB_GETNEXT     ASN_RFC1157_GETNEXTREQUEST
#define MIB_GETFIRST	(ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0)


// MIB Variable access privileges.

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS  	       3	


// Macro to determine number of sub-oid's in array.

#define OID_SIZEOF( Oid )      ( sizeof Oid / sizeof(UINT) )


// MIB variable ENTRY definition.  This structure defines the format for
// each entry in the MIB.

typedef struct mib_entry
           {
	   AsnObjectIdentifier Oid;
	   void *              Storage;
	   BYTE                Type;
	   UINT                Access;
	   UINT                (*MibFunc)( UINT, struct mib_entry *,
	                                   RFC1157VarBind * );
	   struct mib_entry *  MibNext;
	   } MIB_ENTRY, *PMIB_ENTRY;

typedef struct table_entry
           {
	   UINT                (*MibFunc)( UINT, struct mib_entry *,
	                                   RFC1157VarBind * );
	   struct mib_entry *  Mibptr;
	   } TABLE_ENTRY, *PTABLE_ENTRY;


// Internal MIB structure.

extern UINT      MIB_num_variables;

// Prefix to every variable in the MIB.

extern AsnObjectIdentifier MIB_OidPrefix;
extern BOOL		   fDhcpMibVarsAccessed;

//extern MIB_ENTRY	Mib[];
extern MIB_ENTRY	*pWinsMib;
// Function Prototypes.

extern
UINT ResolveVarBind(
        IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve
	IN UINT PduAction               // Action specified in PDU
	);

#endif /* dhcpmib_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\rogue\dhcploc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcploc.c

Abstract:

    This apps is used to detect the rogue DHCP server on a subnet.

    To build, 'nmake UMTEST=dhcpcli'

Author:

    Madan Appiah (madana)  21-Oct-1993

Environment:

    User Mode - Win32

Revision History:

  Oct 1996, (a-martih) Martin Holladay
		Corrected AV bug when passed an unknown cmd-line parameter.

--*/

#include <dhcpcli.h>
#include <conio.h>
#include <locmsg.h>
#include <time.h>
#include <lmcons.h>
#include <lmmsg.h>

#define RECEIVE_TIMEOUT                 5           // in secs. 5 secs
#define THREAD_TERMINATION_TIMEOUT      10000       // in msecs. 10 secs
#define SOCKET_RECEIVE_BUFFER_SIZE      1024 * 4    // 4K max.
#define AUTH_SERVERS_MAX                64
#define SMALL_BUFFER_SIZE               32
#define ALERT_INTERVAL                  5 * 60      // 5 mins
#define ALERT_MESSAGE_LENGTH            256
#define MAX_ALERT_NAMES                 256

DWORD GlobalAuthServers[AUTH_SERVERS_MAX];
BOOL GlobalNoAuthPrint = FALSE;
DWORD GlobalAuthServersCount = 0;
HANDLE GlobalRecvThreadHandle = NULL;
BOOL GlobalTerminate = FALSE;
DWORD GlobalIpAddress = 0;
time_t GlobalLastAlertTime = 0;
DWORD GlobalAlertInterval = ALERT_INTERVAL;
LPWSTR GlobalAlertNames[MAX_ALERT_NAMES];
DWORD GlobalAlertNamesCount = 0;

#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}

#endif // DBG

DWORD
OpenSocket(
    SOCKET *Socket,
    DWORD IpAddress,
    DWORD Port
    )
{
    DWORD Error;
    SOCKET Sock;
    DWORD OptValue;

    struct sockaddr_in SocketName;

    //
    // Create a socket
    //

    Sock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( Sock == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Make the socket share-able
    //

    OptValue = TRUE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_REUSEADDR,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = TRUE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_BROADCAST,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = SOCKET_RECEIVE_BUFFER_SIZE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_RCVBUF,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    SocketName.sin_family = PF_INET;
    SocketName.sin_port = htons( (unsigned short)Port );
    SocketName.sin_addr.s_addr = IpAddress;
    RtlZeroMemory( SocketName.sin_zero, 8);

    //
    // Bind this socket to the DHCP server port
    //

    Error = bind(
               Sock,
               (struct sockaddr FAR *)&SocketName,
               sizeof( SocketName )
               );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    *Socket = Sock;
    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // if we aren't successful, close the socket if it is opened.
        //

        if( Sock != INVALID_SOCKET ) {
            closesocket( Sock );
        }
    }

    return( Error );
}

BOOL
IsAuthServer(
    DWORD IpAddress
    )
{
    DWORD i;

    for( i = 0; i < GlobalAuthServersCount; i++ ) {
        if( IpAddress == GlobalAuthServers[i] ){
            return( TRUE );
        }
    }

    return( FALSE );
}


VOID
ExtractOptions1(
    POPTION Option,
    PDHCP_OPTIONS DhcpOptions,
    DWORD MessageSize
    )
{
    POPTION start = Option;
    POPTION nextOption;
    LPBYTE MagicCookie;

    //
    // initialize option data.
    //

    RtlZeroMemory( DhcpOptions, sizeof( DHCP_OPTIONS ) );

    if ( MessageSize == 0 ) {
        return;
    }

    //
    // check magic cookie.
    //

    MagicCookie = (LPBYTE) Option;

    if( (*MagicCookie != (BYTE)DHCP_MAGIC_COOKIE_BYTE1) ||
        (*(MagicCookie+1) != (BYTE)DHCP_MAGIC_COOKIE_BYTE2) ||
        (*(MagicCookie+2) != (BYTE)DHCP_MAGIC_COOKIE_BYTE3) ||
        (*(MagicCookie+3) != (BYTE)DHCP_MAGIC_COOKIE_BYTE4)) {

        return;
    }

    Option = (LPOPTION) (MagicCookie + 4);

    while ( Option->OptionType != OPTION_END ) {

        if ( Option->OptionType == OPTION_PAD ||
             Option->OptionType == OPTION_END ) {

            nextOption = (LPOPTION)( (LPBYTE)(Option) + 1);

        } else {

            nextOption = (LPOPTION)( (LPBYTE)(Option) + Option->OptionLength + 2);

        }

        //
        // Make sure that we don't walk off the edge of the message, due
        // to a forgotten OPTION_END option.
        //

        if ((PCHAR)nextOption - (PCHAR)start > (long)MessageSize ) {
            return;
        }

        switch ( Option->OptionType ) {

        case OPTION_MESSAGE_TYPE:
            DhcpAssert( Option->OptionLength == sizeof(BYTE) );
            DhcpOptions->MessageType =
                (BYTE UNALIGNED *)&Option->OptionValue;
            break;

        case OPTION_SUBNET_MASK:
            DhcpAssert( Option->OptionLength == sizeof(DWORD) );
            DhcpOptions->SubnetMask =
                (DHCP_IP_ADDRESS UNALIGNED *)&Option->OptionValue;
            break;

        case OPTION_LEASE_TIME:
            DhcpAssert( Option->OptionLength == sizeof(DWORD) );
            DhcpOptions->LeaseTime =
                (DWORD UNALIGNED *)&Option->OptionValue;
            break;

        case OPTION_SERVER_IDENTIFIER:
            DhcpAssert( Option->OptionLength == sizeof(DWORD) );
            DhcpOptions->ServerIdentifier =
                (DHCP_IP_ADDRESS UNALIGNED *)&Option->OptionValue;
            break;

        case OPTION_RENEWAL_TIME:
            DhcpAssert( Option->OptionLength == sizeof(DWORD) );
            DhcpOptions->T1Time =
                (DWORD UNALIGNED *)&Option->OptionValue;
            break;

        case OPTION_REBIND_TIME:
            DhcpAssert( Option->OptionLength == sizeof(DWORD) );
            DhcpOptions->T2Time =
                (DWORD UNALIGNED *)&Option->OptionValue;
            break;

        default:
            break;
        }

        Option = nextOption;
    }

    return;
}

DWORD
SendDiscovery(
    VOID
    )
{
    DWORD Error;
    BYTE MessageBuffer[DHCP_SEND_MESSAGE_SIZE];
    PDHCP_MESSAGE dhcpMessage = (PDHCP_MESSAGE)MessageBuffer;
    LPOPTION option;
    LPBYTE OptionEnd;
    BYTE value;

    BYTE *HardwareAddress = "123456";
    BYTE HardwareAddressLength = 6;
    LPSTR HostName = "ROGUE";

    SOCKET Sock;
    struct sockaddr_in socketName;
    DWORD i;

    //
    // prepare message.
    //

    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );

    dhcpMessage->Operation = BOOT_REQUEST;
    dhcpMessage->HardwareAddressType = 1;

    //
    // Transaction ID is filled in during send
    //

    dhcpMessage->SecondsSinceBoot = 60; // random value ??
    dhcpMessage->Reserved = htons(DHCP_BROADCAST);

    memcpy(
        dhcpMessage->HardwareAddress,
        HardwareAddress,
        HardwareAddressLength
        );

    dhcpMessage->HardwareAddressLength = (BYTE)HardwareAddressLength;

    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;

    //
    // always add magic cookie first
    //

    option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    value = DHCP_DISCOVER_MESSAGE;
    option = DhcpAppendOption(
                option,
                OPTION_MESSAGE_TYPE,
                &value,
                1,
                OptionEnd );


    //
    // Add client ID Option.
    //

    option = DhcpAppendClientIDOption(
                option,
                1,
                HardwareAddress,
                HardwareAddressLength,
                OptionEnd );

    //
    // add Host name and comment options.
    //

    option = DhcpAppendOption(
                 option,
                 OPTION_HOST_NAME,
                 (LPBYTE)HostName,
                 (BYTE)((strlen(HostName) + 1) * sizeof(CHAR)),
                 OptionEnd );

    //
    // Add END option.
    //

    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );

    //
    // Send the message
    //

    //
    // open socket.
    //

    Error = OpenSocket(
                &Sock,
                GlobalIpAddress,
                DHCP_SERVR_PORT );

    if( Error != ERROR_SUCCESS ) {

        printf("OpenReceiveSocket failed %ld.", Error );
        return( Error );
    }

    //
    // Initialize the outgoing address.
    //

    socketName.sin_family = PF_INET;
    socketName.sin_port = htons( DHCP_SERVR_PORT );
    socketName.sin_addr.s_addr = (DHCP_IP_ADDRESS)(INADDR_BROADCAST);

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    Error = sendto(
                Sock,
                (PCHAR)MessageBuffer,
                DHCP_SEND_MESSAGE_SIZE,
                0,
                (struct sockaddr *)&socketName,
                sizeof( struct sockaddr )
                );

    if ( Error == SOCKET_ERROR ) {
        Error = WSAGetLastError();
        printf("sendto failed %ld\n", Error );
        return( Error );
    }

    return( ERROR_SUCCESS );
}

VOID
LogEvent(
    LPSTR MsgTypeString,
    LPSTR IpAddressString,
    LPSTR ServerAddressString
    )
{
    HANDLE EventlogHandle;
    LPSTR Strings[3];

    //
    // open event registry.
    //

    EventlogHandle = RegisterEventSourceA(
                        NULL,
                        "DhcpTools" );

    if (EventlogHandle == NULL) {

        printf("RegisterEventSourceA failed %ld.", GetLastError() );
        return;
    }

    Strings[0] = MsgTypeString;
    Strings[1] = ServerAddressString;
    Strings[2] = IpAddressString;

    if( !ReportEventA(
            EventlogHandle,
            (WORD)EVENTLOG_INFORMATION_TYPE,
            0,            // event category
            DHCP_ROGUE_SERVER_MESSAGE,
            NULL,
            (WORD)3,
            0,
            Strings,
            NULL
            ) ) {

        printf("ReportEventA failed %ld.", GetLastError() );
    }

    DeregisterEventSource(EventlogHandle);

    return;
}

VOID
RaiseAlert(
    LPSTR MsgTypeString,
    LPSTR IpAddressString,
    LPSTR ServerAddressString
    )
{

    time_t TimeNow;
    DWORD Error;

    TimeNow = time( NULL );

    if( TimeNow > (time_t)(GlobalLastAlertTime + GlobalAlertInterval) ) {

        WCHAR uIpAddressString[SMALL_BUFFER_SIZE];
        WCHAR uServerAddressString[SMALL_BUFFER_SIZE];
        WCHAR uMsgTypeString[SMALL_BUFFER_SIZE];
        DWORD i;

        LPWSTR MessageParams[3];
        WCHAR AlertMessage[ ALERT_MESSAGE_LENGTH ];
        DWORD MsgLength;

        MessageParams[0] =
            DhcpOemToUnicode( MsgTypeString, uMsgTypeString );
        MessageParams[1] =
            DhcpOemToUnicode( ServerAddressString, uServerAddressString );
        MessageParams[2] =
            DhcpOemToUnicode( IpAddressString, uIpAddressString );

        MsgLength = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        NULL,
                        DHCP_ROGUE_SERVER_MESSAGE,
                        0,                          // language id.
                        AlertMessage,               // return buffer place holder.
                        ALERT_MESSAGE_LENGTH,       // minimum buffer size (in characters) to allocate.
                        (va_list *)MessageParams    // insert strings.
                    );

        if( MsgLength == 0 ) {

            printf("FormatMessage failed %ld.", GetLastError() );
        }
        else {

            //
            // send alert message.
            //

            for( i = 0; i < GlobalAlertNamesCount; i++) {

                Error = NetMessageBufferSend(
                            NULL,
                            GlobalAlertNames[i],
                            NULL,
                            (LPBYTE)AlertMessage,
                            MsgLength * sizeof(WCHAR) );

                if( Error != ERROR_SUCCESS ) {

                    printf("NetMessageBufferSend failed %ld.", Error );
                    break;
                }
            }
        }

        GlobalLastAlertTime = TimeNow;
    }
}

VOID
DisplayMessage(
    LPSTR MessageBuffer,
    DWORD BufferLength,
    struct sockaddr_in *source
    )
{
    DHCP_OPTIONS DhcpOptions;
    PDHCP_MESSAGE DhcpMessage;
    SYSTEMTIME SystemTime;
    DWORD MessageType;
    LPSTR MessageTypeString;

    BOOL AuthServer = FALSE;

    CHAR IpAddressString[SMALL_BUFFER_SIZE];
    CHAR ServerAddressString[SMALL_BUFFER_SIZE];

    //
    // check to see this is valid DHCP packet.
    //

    if( BufferLength < DHCP_MESSAGE_FIXED_PART_SIZE ) {
        return;
    }

    DhcpMessage = (LPDHCP_MESSAGE) MessageBuffer;

    if( (DhcpMessage->Operation != BOOT_REQUEST) &&
        (DhcpMessage->Operation != BOOT_REPLY) ) {

        return;
    }

    //
    // extract options.
    //

    ExtractOptions1(
        &DhcpMessage->Option,
        &DhcpOptions,
        BufferLength - DHCP_MESSAGE_FIXED_PART_SIZE );

    if( DhcpOptions.MessageType == NULL ) {
        return;
    }

    MessageType = *DhcpOptions.MessageType;

    if( (MessageType < DHCP_DISCOVER_MESSAGE ) ||
            (MessageType > DHCP_RELEASE_MESSAGE ) ) {
        return;
    }

    //
    // packet is valid dhcp packet, print info.
    //

    //
    // if this packet is from one of the auth server and we are asked
    // not to print auth servers packet, so so.
    //


    if( DhcpOptions.ServerIdentifier != NULL ) {
        AuthServer = IsAuthServer(*DhcpOptions.ServerIdentifier);
    }

    if( GlobalNoAuthPrint && AuthServer ) {
        return;
    }

    GetLocalTime( &SystemTime );
    printf("%02u:%02u:%02u ",
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond );


    switch ( MessageType ) {
    case DHCP_DISCOVER_MESSAGE:
        MessageTypeString = "DISCOVER";

    case DHCP_OFFER_MESSAGE:
        MessageTypeString = "OFFER";
        break;

    case DHCP_REQUEST_MESSAGE:
        MessageTypeString = "REQUEST";
        break;

    case DHCP_DECLINE_MESSAGE:
        MessageTypeString = "DECLINE";
        break;

    case DHCP_ACK_MESSAGE:
        MessageTypeString = "ACK";
        break;

    case DHCP_NACK_MESSAGE:
        MessageTypeString = "NACK";
        break;

    case DHCP_RELEASE_MESSAGE:
        MessageTypeString = "RELEASE";
        break;

    default:
        MessageTypeString = "UNKNOWN";
        break;

    }

    printf("%8s ", MessageTypeString);

    strcpy(
        IpAddressString,
        inet_ntoa(*(struct in_addr *)&DhcpMessage->YourIpAddress) );

    printf("(IP)%-15s ", IpAddressString );

    if(DhcpOptions.ServerIdentifier != NULL ) {

        DWORD ServerId;

        ServerId = *DhcpOptions.ServerIdentifier;
        strcpy( ServerAddressString, inet_ntoa(*(struct in_addr *)&ServerId) );

        printf("(S)%-15s ", ServerAddressString );

        if( source->sin_addr.s_addr != ServerId ) {

            printf("(S1)%-15s ",
                inet_ntoa(*(struct in_addr *)&source->sin_addr.s_addr) );
        }
    }

    //
    // beep if this it is a non-auth server.
    //

    if( AuthServer == FALSE ) {
        printf("***");
        MessageBeep( MB_ICONASTERISK );

        //
        // log an event.
        //

        LogEvent(
            MessageTypeString,
            IpAddressString,
            ServerAddressString );

        RaiseAlert(
            MessageTypeString,
            IpAddressString,
            ServerAddressString );
    }

    printf("\n");
}


DWORD
ReceiveDatagram(
    VOID
    )
{
    DWORD Error;
    SOCKET Sock;
    BOOL SocketOpened = FALSE;
    fd_set readSocketSet;
    struct timeval timeout;
    struct sockaddr socketName;
    int socketNameSize = sizeof( socketName );

    CHAR MessageBuffer[DHCP_MESSAGE_SIZE];

    Error = OpenSocket(
                &Sock,
                GlobalIpAddress,
                DHCP_CLIENT_PORT );

    if( Error != ERROR_SUCCESS ) {

        printf("OpenReceiveSocket failed %ld.", Error );
        goto Cleanup;
    }

    SocketOpened = TRUE;

    //
    // receive message.
    //

    while( GlobalTerminate != TRUE ) {

        FD_ZERO( &readSocketSet );
        FD_SET( Sock, &readSocketSet );

        timeout.tv_sec = RECEIVE_TIMEOUT;
        timeout.tv_usec = 0;

        Error = select( 0, &readSocketSet, NULL, NULL, &timeout);

        if ( Error == 0 ) {

            //
            // Timeout before read data is available.
            //

            // printf("Receive timeout.\n");
        }
        else {

            //
            // receive available message.
            //

            Error = recvfrom(
                        Sock,
                        MessageBuffer,
                        sizeof(MessageBuffer),
                        0,
                        &socketName,
                        &socketNameSize
                        );

            if ( Error == SOCKET_ERROR ) {

                Error = WSAGetLastError();
                printf("recvfrom failed %ld\n", Error );
                goto Cleanup;
            }

            if( GlobalTerminate == TRUE ) {
                break;
            }

            DisplayMessage(
                MessageBuffer,
                Error, // buffer length returned.
                (struct sockaddr_in *)&socketName );
        }
    }

Cleanup:

    if( SocketOpened == TRUE ) {

        //
        // close socket.
        //

        closesocket( Sock );
    }

    GlobalTerminate = TRUE;
    return( Error );
}



DWORD __cdecl
main(
    int argc,
    char **argv
    )
{

    DWORD Error;
    LPSTR AppName = NULL;
    WSADATA wsaData;
    DWORD ThreadId;

    //
    // parse input parameters.
    //

    if( argc < 1 ) {
        goto Usage;
    }

    AppName = argv[0];
    argv++;
    argc--;

    if( argc < 1 ) {
        goto Usage;
    }

    //
    // parse flag parameter.
    //

    while( (argv[0][0] == '-') || (argv[0][0] == '/') ) {

        switch (argv[0][1] ) {
        case 'p':
            GlobalNoAuthPrint = TRUE;
            break;

        case 'i':
            GlobalAlertInterval = atoi( &argv[0][3] ) * 60;
            break;

        case 'a': {

            LPSTR NextName;
            LPSTR Ptr;

            Ptr = &argv[0][3];

            //
            // skip blanks.
            //

            while( *Ptr == ' ' ) {
                Ptr++;
            }
            NextName = Ptr;

            while( *Ptr != '\0' ) {

                if( *Ptr == ' ' ) {

                    //
                    // found another name.
                    //

                    *Ptr++ = '\0';

                    GlobalAlertNames[GlobalAlertNamesCount] =
                        DhcpOemToUnicode( NextName, NULL );
                    GlobalAlertNamesCount++;

                    if( GlobalAlertNamesCount >= MAX_ALERT_NAMES ) {
                        break;
                    }

                    //
                    // skip blanks.
                    //

                    while( *Ptr == ' ' ) {
                        Ptr++;
                    }
                    NextName = Ptr;
                }
                else {

                    Ptr++;
                }
            }

            if( GlobalAlertNamesCount < MAX_ALERT_NAMES ) {
                if( NextName != Ptr ) {
                    GlobalAlertNames[GlobalAlertNamesCount] =
                        DhcpOemToUnicode( NextName, NULL );
                    GlobalAlertNamesCount++;
                }
            }

            break;
        }
 
		//
		// (a-martih) - Bug Fix
		//
        default:
			if ((_stricmp(argv[0], "/?")) &&
				(_stricmp(argv[0], "-?")) &&
				(_stricmp(argv[0], "/h")) &&
				(_stricmp(argv[0], "-h")) ) {
					printf( "\nunknown flag, %s \n", argv[0] );
			}
			goto Usage;
    		break;
        }

        argv++;
        argc--;
    }

    if( argc < 1 ) {
        goto Usage;
    }

    //
    // read ipaddress parameter.
    //

    GlobalIpAddress = inet_addr( argv[0] );

    argv++;
    argc--;

    //
    // now read auth dhcp servers ipaddresses.
    //

    while( (argc > 0) && (GlobalAuthServersCount < AUTH_SERVERS_MAX) ) {

        GlobalAuthServers[GlobalAuthServersCount++] =
            inet_addr( argv[0] );

        argv++;
        argc--;
    }


    //
    // init socket.
    //

    Error = WSAStartup( WS_VERSION_REQUIRED, &wsaData);

    if( Error != ERROR_SUCCESS ) {
        printf( "WSAStartup failed %ld.\n", Error );
        return(1);
    }

    //
    // create receive datagrams thread.
    //

    GlobalRecvThreadHandle =
        CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE)ReceiveDatagram,
            NULL,
            0,
            &ThreadId );

    if( GlobalRecvThreadHandle == NULL ) {
        printf("CreateThread failed %ld.\n", GetLastError() );
        return(1);
    }


    //
    // read input.
    //

    while ( GlobalTerminate != TRUE ) {
        CHAR ch;

        ch = (CHAR)_getch();

        switch( ch ) {
        case 'q':
        case 'Q':
        // case '\c':
            GlobalTerminate = TRUE;
            break;

        case 'd':
        case 'D':

            //
            // send out discover message.
            //

            Error = SendDiscovery();

            if(Error != ERROR_SUCCESS ) {
                printf("SendDiscover failed %ld.\n", Error );
            }

            break;

        case 'h':
        case 'H':
        default:

            printf("Type d - to discover; q - to quit; h - for help.\n");

            //
            // print out help message.
            //

            break;
        }
    }

    //
    // terminate receive thread.
    //

    WaitForSingleObject(
            GlobalRecvThreadHandle,
            THREAD_TERMINATION_TIMEOUT );


    CloseHandle( GlobalRecvThreadHandle );

// Cleanup:

    return(0);

Usage:
	printf("\nUSAGE:\n\n");
    printf("%s [-p] [-a:\"list-of-alertnames\"] [-i:alertinterval] "
            "machine-ip-address "
            "[list of valid dhcp servers ip addresses]", AppName );

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpmib\dhcpmib.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dhcpmib.c

Abstract:

    DHCP SNMP Extension Agent for Windows NT.

    These files (dhcpmibm.c, dhcpmib.c, and dhcpmib.h) provide an example of 
    how to structure an Extension Agent DLL which works in conjunction with 
    the SNMP Extendible Agent for Windows NT.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows/NT SNMP Programmer's Reference".

Created:

   15-Jan-1994 

Revision History:

        Pradeep Bahl                        1/11/94
--*/



// This Extension Agent implements the DHCP MIB.  It's  
// definition follows here:
//
//

// Necessary includes.

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>                         //for SYSTEMTIME def
#include <rpc.h>

#include "dhcpapi.h"

#include <string.h>
#include <time.h>
#include <search.h>


// Contains definitions for the table structure describing the MIB.  This
// is used in conjunction with winsmib.c where the MIB requests are resolved.

#include "dhcpmib.h"


// If an addition or deletion to the MIB is necessary, there are several
// places in the code that must be checked and possibly changed.
//
// The last field in each MIB entry is used to point to the NEXT
// leaf variable.  If an addition or deletetion is made, these pointers
// may need to be updated to reflect the modification.



#define LOCAL_ADD        L"127.0.0.1"


//
// Used by MIBStat
//
#define TMST(x)        x.wHour,\
                x.wMinute,\
                x.wSecond,\
                x.wMonth,\
                x.wDay,\
                x.wYear

#define PRINTTIME(Var, x)      sprintf(Var, "%02u:%02u:%02u on %02u:%02u:%04u.\n", TMST(x))

//
// All MIB variables in the common group have 1 as their first id
//
#define COMMON_VAL_M(pMib)         ((pMib)->Oid.ids[0] == 1) 

//
// All MIB variables in the scope group have 2 as their first id
//
#define SCOPE_VAL_M(pMib)         ((pMib)->Oid.ids[0] == 2) 

static LPDHCP_MIB_INFO        spMibInfo = NULL;

//
// The prefix to all of the DHCP MIB variables is 1.3.6.1.4.1.311.1.3
//
// The last digit -- 3 is for the DHCP MIB
//

UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 311, 1, 3 };
AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };
BOOL        fDhcpMibVarsAccessed = FALSE;
        



//
// Definition of the Dhcp MIB  (not used)
//

//UINT MIB_Dhcp[]  = { 3 };

//                        
// OID definitions for MIB
//                        

//
// Definition of group and leaf variables under the wins group
// All leaf variables have a zero appended to their OID to indicate
// that it is the only instance of this variable and it exists.
//

UINT MIB_Parameters[]                        = { 1 }; 
UINT MIB_DhcpStartTime[]                     = { 1, 1, 0 };
UINT MIB_NoOfDiscovers[]                = { 1, 2, 0 };
UINT MIB_NoOfRequests[]                        = { 1, 3, 0 };
UINT MIB_NoOfReleases[]                        = { 1, 4, 0 };
UINT MIB_NoOfOffers[]                        = { 1, 5, 0 };
UINT MIB_NoOfAcks[]                        = { 1, 6, 0 };
UINT MIB_NoOfNacks[]                        = { 1, 7, 0 };
UINT MIB_NoOfDeclines[]                        = { 1, 8, 0 };

//
// Scope table
//
UINT MIB_Scope[]                        = { 2 }; 
UINT MIB_ScopeTable[]                        = { 2, 1};
UINT MIB_ScopeTableEntry[]                = { 2, 1, 1};

//
//                             //
// Storage definitions for MIB //
//                             //
char            MIB_DhcpStartTimeStore[80];
AsnCounter MIB_NoOfDiscoversStore;
AsnCounter MIB_NoOfRequestsStore;
AsnCounter MIB_NoOfReleasesStore;
AsnCounter MIB_NoOfOffersStore;
AsnCounter MIB_NoOfAcksStore;
AsnCounter MIB_NoOfNacksStore;
AsnCounter MIB_NoOfDeclinesStore;





static
UINT 
MIB_Table(
        IN DWORD           Index, 
        IN UINT            Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
        );

static
UINT 
ScopeTable(
        IN UINT           Action,
        IN PMIB_ENTRY           pMibPtr,
        IN RFC1157VarBind *VarBind
                );

static
UINT 
MIB_leaf_func(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
        );


static
UINT 
MIB_Stat(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
        );
static
DWORD 
GetMibInfo (
        LPWSTR                        DhcpAdd,
        LPDHCP_MIB_INFO                *ppMibInfo
        );
//
// MIB definiton
//

MIB_ENTRY Mib[] = {
//parameters
      { { OID_SIZEOF(MIB_Parameters), MIB_Parameters },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[1] },

      { { OID_SIZEOF(MIB_DhcpStartTime), MIB_DhcpStartTime },
        &MIB_DhcpStartTimeStore, ASN_RFC1213_DISPSTRING,
        MIB_ACCESS_READ, MIB_Stat, &Mib[2] },

      { { OID_SIZEOF(MIB_NoOfDiscovers), MIB_NoOfDiscovers },
        &MIB_NoOfDiscoversStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[3] },

      { { OID_SIZEOF(MIB_NoOfRequests), MIB_NoOfRequests },
        &MIB_NoOfRequestsStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[4] },

      { { OID_SIZEOF(MIB_NoOfReleases), MIB_NoOfReleases },
        &MIB_NoOfReleasesStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[5] },

      { { OID_SIZEOF(MIB_NoOfOffers), MIB_NoOfOffers },
        &MIB_NoOfOffersStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[6] },

      { { OID_SIZEOF(MIB_NoOfAcks), MIB_NoOfAcks },
        &MIB_NoOfAcksStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[7] },

      { { OID_SIZEOF(MIB_NoOfNacks), MIB_NoOfNacks },
        &MIB_NoOfNacksStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[8] },

      { { OID_SIZEOF(MIB_NoOfDeclines), MIB_NoOfDeclines },
        &MIB_NoOfDeclinesStore, ASN_RFC1155_COUNTER,
        MIB_ACCESS_READ, MIB_Stat, &Mib[9] },

//
// Scope
//
      { { OID_SIZEOF(MIB_Scope), MIB_Scope },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_NOACCESS, NULL, &Mib[10] },


      { { OID_SIZEOF(MIB_ScopeTable), MIB_ScopeTable },
        NULL, ASN_RFC1155_OPAQUE,
        MIB_ACCESS_READ, NULL, &Mib[11] },

      { { OID_SIZEOF(MIB_ScopeTableEntry), MIB_ScopeTableEntry },
        NULL, ASN_SEQUENCE,
        MIB_ACCESS_READ, ScopeTable, NULL }
      };



//
//  defines pertaining to tables
//
#define SCOPE_OIDLEN                 (MIB_PREFIX_LEN + OID_SIZEOF(MIB_ScopeTableEntry))        

#define NO_FLDS_IN_SCOPE_ROW        4
#define SCOPE_TABLE_INDEX        0

#define NUM_TABLES                sizeof(Tables)/sizeof(TAB_INFO_T)

UINT MIB_num_variables = sizeof Mib / sizeof( MIB_ENTRY );

//
// table structure containing the functions to invoke for different actions
// on the table
//
typedef struct _TAB_INFO_T {
        UINT (*ti_get)(
                RFC1157VarBind *VarBind
                     );
        UINT (*ti_getf)(
                RFC1157VarBind *VarBind,
                PMIB_ENTRY        pMibEntry
                     );
        UINT (*ti_getn)(
                RFC1157VarBind *VarBind,
                PMIB_ENTRY        pMibEntry
                    );
        UINT (*ti_set)(
                RFC1157VarBind *VarBind
                    );

        PMIB_ENTRY pMibPtr;
        } TAB_INFO_T, *PTAB_INFO_T;




static
UINT
ScopeGetNext(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY          pMibPtr
        );


static
UINT
ScopeGet(
       IN RFC1157VarBind *VarBind
);


static
UINT
ScopeGetFirst(
       IN RFC1157VarBind *VarBind,
       IN PMIB_ENTRY          pMibPtr
        );


static
UINT
ScopeMatch(
       IN RFC1157VarBind          *VarBind,
       IN LPDWORD                  pIndex,
       IN LPDWORD                 pField,
       IN UINT                          PduAction,
       IN LPBOOL                 pfFirst
        );

extern
UINT
ScopeFindNext(
        INT                   SubnetIndex        
        );



static
int 
__cdecl
CompareScopes(
        const VOID *pKey1,
        const VOID *pKey2
        );
static
UINT
GetNextVar(
        IN RFC1157VarBind *pVarBind,
        IN PMIB_ENTRY          pMibPtr
);

TAB_INFO_T Tables[] = {
                        ScopeGet, 
                        ScopeGetFirst, 
                        ScopeGetNext, 
                        NULL,
                        &Mib[11]
        };






UINT 
ResolveVarBind(
        IN OUT RFC1157VarBind *VarBind, // Variable Binding to resolve
        IN UINT PduAction               // Action specified in PDU
        )
//
// ResolveVarBind
//    Resolves a single variable binding.  Modifies the variable on a GET
//    or a GET-NEXT.
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
{
   MIB_ENTRY            *MibPtr;
   AsnObjectIdentifier  TempOid;
   int                  CompResult;
   UINT                 I;
   UINT                 nResult;
   DWORD TableIndex;
   BOOL  fTableMatch = FALSE;

   //
   // Check the Tables array
   //
   // See if the prefix of the variable matches the prefix of
   // any of the tables
   //
   for (TableIndex = 0; TableIndex < NUM_TABLES; TableIndex++)
   {
        //
           // Construct OID with complete prefix for comparison purposes
        //
           SnmpUtilOidCpy( &TempOid, &MIB_OidPrefix );
           SnmpUtilOidAppend( &TempOid,  &Tables[TableIndex].pMibPtr->Oid );

        //
        // is there a match with the prefix oid of a table entry
        //
        if (
                SnmpUtilOidNCmp(
                            &VarBind->name, 
                             &TempOid,                
                             MIB_PREFIX_LEN + 
                                Tables[TableIndex].pMibPtr->Oid.idLength
                               )  == 0
           )
        {

                //
                // the prefix string of the var. matched the oid
                // of a table.
                //
                MibPtr = Tables[TableIndex].pMibPtr;
                fTableMatch = TRUE;
                break;
        }

           // Free OID memory before checking with another table entry
           SnmpUtilOidFree( &TempOid );
   }
   //
   // There was an exact match with a table entry's prefix. 
   //
   if ( fTableMatch)
   {
        
        if (
                (SnmpUtilOidCmp(
                        &VarBind->name, 
                        &TempOid
                               ) == 0)
           )
           {
           //
           // The oid specified is a prefix of a table entry. if the operation
           // is not GETNEXT, return NOSUCHNAME
           //
           if (PduAction != MIB_GETNEXT) 
           {
                           SnmpUtilOidFree( &TempOid );
                             nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                              goto Exit;
           }
           else
           {
                UINT           TableEntryIds[1];
                AsnObjectIdentifier TableEntryOid = { 
                                OID_SIZEOF(TableEntryIds), TableEntryIds };
                //
                // Replace var bind name with new name
                //

                //
                // A sequence item oid always starts with a field no.
                // The first item has a field no of 1. 
                //
                TableEntryIds[0] = 1;
                SnmpUtilOidAppend( &VarBind->name, &TableEntryOid);

                //
                // Get the first entry in the table
                //
                PduAction = MIB_GETFIRST;
           }
        }
           SnmpUtilOidFree( &TempOid );
        //
        //  if there was no exact match with a prefix entry, then we
        //  don't touch the PduAction value specified. 
        //
   }
   else
   {
        
      //
      // There was no match with any table entry.  Let us see if there is
      // a match with a group entry, a table, or a leaf variable
      //

      //
      // Search for var bind name in the MIB
      //
      I      = 0;
      MibPtr = NULL;
      while ( MibPtr == NULL && I < MIB_num_variables )
      {

         //
         // Construct OID with complete prefix for comparison purposes
         //
         SnmpUtilOidCpy( &TempOid, &MIB_OidPrefix );
         SnmpUtilOidAppend( &TempOid, &Mib[I].Oid );

         //
         //Check for OID in MIB - On a GET-NEXT the OID does not have to exactly
         // match a variable in the MIB, it must only fall under the MIB root.
         //
         CompResult = SnmpUtilOidCmp( &VarBind->name, &TempOid );

        //
        // If CompResult is negative, the only valid operation is GET_NEXT
        //
        if (  CompResult  < 0)
        {

                //
                // This could be the oid of a leaf (without a 0)
                // or it could be  an invalid oid (in between two valid oids) 
                // The next oid might be that of a group or a table or table
                // entry.  In that case, we do not change the PduAction
                //
                if (PduAction == MIB_GETNEXT)
                {
                       MibPtr = &Mib[I];
                             SnmpUtilOidFree( &VarBind->name );
                       SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
                       SnmpUtilOidAppend( &VarBind->name, &MibPtr->Oid );
                       if (
                                (MibPtr->Type != ASN_RFC1155_OPAQUE)
                                         &&
                                (MibPtr->Type != ASN_SEQUENCE)
                          )
                       {
                                 PduAction = MIB_GET;
                       }
                }
                else
                {
                  nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                        SnmpUtilOidFree( &TempOid );
                  goto Exit;
                }

                      SnmpUtilOidFree( &TempOid );
                break;
      }
      else
      {
         //
         // An exact match was found ( a group, table, or leaf).
         //
         if ( CompResult == 0)
         {
            MibPtr = &Mib[I];
         }
      }

      //
      // Free OID memory before checking another variable
      //
      SnmpUtilOidFree( &TempOid );
      I++;
    } // while
   } // end of else

   //
   // if there was a match
   //
   if (MibPtr != NULL)
   {
        //
        // the function will be NULL only if the match was with a group
        // or a sequence (table). If the match was with a table entry
        // (entire VarBind string match or partial string match), we
        // function would be a table function
        //
        if (MibPtr->MibFunc == NULL) 
        {
                if(PduAction != MIB_GETNEXT) 
                {
                              nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                              goto Exit;
                }
                else
                {
                        //
                        // Get the next variable which allows access 
                        //
                         nResult = GetNextVar(VarBind, MibPtr);
                        goto Exit;
                }
        }
   }
   else
   {
              nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
              goto Exit;
   }

   //
   // Call function to process request.  Each MIB entry has a function pointer
   // that knows how to process its MIB variable.
   //
   nResult = (*MibPtr->MibFunc)( PduAction, MibPtr, VarBind );

Exit:
   return nResult;
} // ResolveVarBind
//
// MIB_leaf_func
//    Performs generic actions on LEAF variables in the MIB.
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT MIB_leaf_func(
        IN UINT            Action,
        IN MIB_ENTRY            *MibPtr,
        IN RFC1157VarBind  *VarBind
        )

{
   UINT   ErrStat;

   switch ( Action )
   {
      case MIB_GETNEXT:
         //
         // If there is no GET-NEXT pointer, this is the end of this MIB
         //
         if ( MibPtr->MibNext == NULL )
         {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
         }
         ErrStat = GetNextVar(VarBind, MibPtr);
         if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
         {
                goto Exit;
         }
         break;

      case MIB_GETFIRST: // fall through 
      case MIB_GET:

         // Make sure that this variable's ACCESS is GET'able
         if ( MibPtr->Access != MIB_ACCESS_READ &&
              MibPtr->Access != MIB_ACCESS_READWRITE )
         {
               ErrStat = SNMP_ERRORSTATUS_NOACCESS;
               goto Exit;
         }

         // Setup varbind's return value
         VarBind->value.asnType = MibPtr->Type;
         switch ( VarBind->value.asnType )
         {
            case ASN_RFC1155_COUNTER:
               VarBind->value.asnValue.number = *(AsnCounter *)(MibPtr->Storage);
               break;
            case ASN_RFC1155_GAUGE:
            case ASN_INTEGER:
               VarBind->value.asnValue.number = *(AsnInteger *)(MibPtr->Storage);
               break;

            case ASN_RFC1155_IPADDRESS:
                                //
                                // fall through
                                //
                                
            case ASN_OCTETSTRING: 
               if (VarBind->value.asnType == ASN_RFC1155_IPADDRESS)
               {
                               VarBind->value.asnValue.string.length = 4;
               }
               else
               {
                               VarBind->value.asnValue.string.length =
                                 strlen( (LPSTR)MibPtr->Storage );
               }

               if ( NULL == 
                    (VarBind->value.asnValue.string.stream =
                    SnmpUtilMemAlloc(VarBind->value.asnValue.string.length *
                           sizeof(char))) )
               {
                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                  goto Exit;
               }

               memcpy( VarBind->value.asnValue.string.stream,
                       (LPSTR)MibPtr->Storage,
                       VarBind->value.asnValue.string.length );
               VarBind->value.asnValue.string.dynamic = TRUE;
        
               break;

                

            default:
               ErrStat = SNMP_ERRORSTATUS_GENERR;
               goto Exit;
         }

         break;

      case MIB_SET:

         // Make sure that this variable's ACCESS is SET'able
         if ( MibPtr->Access != MIB_ACCESS_READWRITE &&
              MibPtr->Access != MIB_ACCESS_WRITE )
         {
            ErrStat = SNMP_ERRORSTATUS_NOTWRITABLE;
            goto Exit;
         }

         // Check for proper type before setting
         if ( MibPtr->Type != VarBind->value.asnType )
         {
            ErrStat = SNMP_ERRORSTATUS_WRONGTYPE;
            goto Exit;
         }

         // Save value in MIB
         switch ( VarBind->value.asnType )
         {
            case ASN_RFC1155_COUNTER:
               *(AsnCounter *)(MibPtr->Storage) = VarBind->value.asnValue.number;
               break;
            case ASN_RFC1155_GAUGE:
            case ASN_INTEGER:
               *(AsnInteger *)(MibPtr->Storage) = VarBind->value.asnValue.number;
               break;

            case ASN_RFC1155_IPADDRESS:
                                //
                                // fall through
                                //
            case ASN_OCTETSTRING:
               // The storage must be adequate to contain the new string
               // including a NULL terminator.
               memcpy( (LPSTR)MibPtr->Storage,
                       VarBind->value.asnValue.string.stream,
                       VarBind->value.asnValue.string.length );

               ((LPSTR)MibPtr->Storage)[VarBind->value.asnValue.string.length] =
                                                                          '\0';
               if ( VarBind->value.asnValue.string.dynamic)
               {
                  SnmpUtilMemFree( VarBind->value.asnValue.string.stream);
               }
               break;

            default:
               ErrStat = SNMP_ERRORSTATUS_GENERR;
               goto Exit;
            }

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

   // Signal no error occurred
   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_leaf_func

//
// MIB_Stat
//    Performs specific actions on the different MIB variable
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
UINT MIB_Stat(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
        )

{
DWORD                        Status;
UINT                           ErrStat;
SYSTEMTIME                DhcpStartTime;



   switch ( Action )
      {
      case MIB_SET:
                   ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
                break;
      case MIB_GETNEXT:
                   ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );
                break;
                
      case MIB_GETFIRST:
                //
                // fall through
                //
      case MIB_GET:
        //
        // Call the DhcpStatus function to get the statistics
        //
        Status = GetMibInfo(LOCAL_ADD, &spMibInfo);

        
        if (Status == ERROR_SUCCESS) 
        {
            if (FileTimeToSystemTime( 
                                (FILETIME *)&spMibInfo->ServerStartTime,  
                                &DhcpStartTime
                                   ) == FALSE)
            {
                goto Exit;
            }
           
            if (MibPtr->Storage  == &MIB_DhcpStartTimeStore) 
            {
                PRINTTIME(MIB_DhcpStartTimeStore, DhcpStartTime);
                goto LEAF1;
            }

            if (MibPtr->Storage  == &MIB_NoOfDiscoversStore) 
            {
                MIB_NoOfDiscoversStore =  spMibInfo->Discovers;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfRequestsStore) 
            {
                MIB_NoOfRequestsStore =  spMibInfo->Requests;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfReleasesStore) 
            {
                MIB_NoOfReleasesStore =  spMibInfo->Releases;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfOffersStore) 
            {
                MIB_NoOfOffersStore =  spMibInfo->Offers;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfAcksStore) 
            {
                MIB_NoOfAcksStore =  spMibInfo->Acks;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfNacksStore) 
            {
                MIB_NoOfNacksStore =  spMibInfo->Naks;
                goto LEAF1;
            }
            if (MibPtr->Storage  == &MIB_NoOfDeclinesStore) 
            {
                MIB_NoOfNacksStore =  spMibInfo->Naks;
                goto LEAF1;
            }
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
         }
         else
         {
           printf("Error from DhcpStatus = (%d)\n", Status);
           ErrStat = (Status == RPC_S_SERVER_UNAVAILABLE) ? 
                        SNMP_ERRORSTATUS_NOSUCHNAME :
                        SNMP_ERRORSTATUS_GENERR;
           goto Exit;
         }        
LEAF1:
         // Call the more generic function to perform the action
         ErrStat = MIB_leaf_func( Action, MibPtr, VarBind );

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
         goto Exit;
      } // switch

Exit:
   return ErrStat;
} // MIB_Stat



DWORD GetMibInfo (
        LPWSTR                        DhcpAdd,
        LPDHCP_MIB_INFO                *ppMibInfo
        )
{
        DWORD  Status = ERROR_SUCCESS;
        if (!fDhcpMibVarsAccessed)
        {
           //
           // The Dhcp server does a single node allocation. So we
           // we need to free only spMibInfo.
           //
           if (spMibInfo != NULL)
           {
#if 0
                if (spMibInfo->ScopeInfo != NULL)
                {
                        DhcpRpcFreeMemory(spMibInfo->ScopeInfo);
                        spMibInfo->ScopeInfo = NULL; 
                }
#endif
                DhcpRpcFreeMemory(spMibInfo);
                spMibInfo            = NULL;
           }
           Status = DhcpGetMibInfo(LOCAL_ADD, &spMibInfo);
           if (Status == ERROR_SUCCESS)
           {
                if (spMibInfo->Scopes > 1)
                {
          ASSERT(spMibInfo->ScopeInfo != NULL);
                  qsort(spMibInfo->ScopeInfo,(size_t)spMibInfo->Scopes,
                        sizeof(SCOPE_MIB_INFO),CompareScopes );
                }
                fDhcpMibVarsAccessed = TRUE;
           }
           else
           {
                fDhcpMibVarsAccessed = FALSE;
           }
        }
        return(Status);
}

int 
__cdecl
CompareScopes(
        const VOID *pKey1,
        const VOID *pKey2
        )

{
        const LPSCOPE_MIB_INFO        pScopeKey1 = (LPSCOPE_MIB_INFO)pKey1;
        const LPSCOPE_MIB_INFO        pScopeKey2 = (LPSCOPE_MIB_INFO)pKey2;


        if( pScopeKey1->Subnet < pScopeKey2->Subnet) 
            return -1;
        if (pScopeKey1->Subnet != pScopeKey2->Subnet )
            return 1;
        return 0;
}

UINT
GetNextVar(
        IN RFC1157VarBind *pVarBind,
        IN MIB_ENTRY          *pMibPtr
)
{
       UINT                ErrStat;

       while (pMibPtr != NULL)
       {
         if (pMibPtr->MibNext != NULL)
         {
            //
            // Setup var bind name of NEXT MIB variable
            //
            SnmpUtilOidFree( &pVarBind->name );
            SnmpUtilOidCpy( &pVarBind->name, &MIB_OidPrefix );
            SnmpUtilOidAppend( &pVarBind->name, &pMibPtr->MibNext->Oid );

            //
            // If the func. ptr is  NULL and the type of the mib variable
            // is anything but OPAQUE, call function to process the
            // MIB variable
            //
            if (
                 (pMibPtr->MibNext->MibFunc != NULL) 
                        && 
                 (pMibPtr->MibNext->Type !=  ASN_RFC1155_OPAQUE)
               )
                
            {
                ErrStat = (*pMibPtr->MibNext->MibFunc)( MIB_GETFIRST,
                                                pMibPtr->MibNext, pVarBind );
                if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
                {
                        goto Exit;
                }
                break;
            }
            else
            {
                pMibPtr = pMibPtr->MibNext;        
            }
          }
          else
          {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            break;
          }
         } 

         if (pMibPtr == NULL)
         {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
         }
Exit:
        return(ErrStat);
}

UINT 
ScopeTable(
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
)
{
        DWORD status;

        if (Action == MIB_SET)
        {
                return(SNMP_ERRORSTATUS_READONLY);
        }

        //
        // if the length indicates a 0 or partial key, then only the get next 
        // operation is allowed.  The field and the full key
        // have a length of 5
        //
        if (VarBind->name.idLength <= (SCOPE_OIDLEN + 4))
        {
                if ((Action == MIB_GET) || (Action == MIB_SET))
                {
                        return(SNMP_ERRORSTATUS_NOSUCHNAME);
                }
        }
        status = GetMibInfo(LOCAL_ADD, &spMibInfo);
        if (status != ERROR_SUCCESS)
        {
                if (Action == MIB_GETNEXT)
                {
                        return(GetNextVar(VarBind, MibPtr));
                }
                else
                {
                        return (status == RPC_S_SERVER_UNAVAILABLE) ?
                                    SNMP_ERRORSTATUS_NOSUCHNAME :
                                    SNMP_ERRORSTATUS_GENERR;
                }
        }
        return( MIB_Table(SCOPE_TABLE_INDEX, Action, MibPtr, VarBind) );
}

UINT 
MIB_Table(
        IN DWORD            Index,
        IN UINT           Action,
        IN MIB_ENTRY           *MibPtr,
        IN RFC1157VarBind *VarBind
       )
{
        UINT        ErrStat;
        switch(Action)
        {
                case(MIB_GET):
                        ErrStat = (*Tables[Index].ti_get)(VarBind);
                        break;
                        
                case(MIB_GETFIRST):
                        ErrStat = (*Tables[Index].ti_getf)(VarBind, MibPtr);
                        break;

                case(MIB_GETNEXT):
                        ErrStat = (*Tables[Index].ti_getn)(VarBind, MibPtr);
                        break;
                case(MIB_SET):
                        ErrStat = (*Tables[Index].ti_set)(VarBind);
                        break;
                default:
                        ErrStat = SNMP_ERRORSTATUS_GENERR;
                        break;

        }

        return(ErrStat);

}  //MIB_Table



UINT
ScopeGet(
       IN RFC1157VarBind *VarBind
    )
{
        UINT                ErrStat = SNMP_ERRORSTATUS_NOERROR;
        DWORD           Field;
        DWORD                Index;
        LPSCOPE_MIB_INFO pScope = spMibInfo->ScopeInfo;


        ErrStat = ScopeMatch(VarBind, &Index, &Field, MIB_GET, NULL);
             if (ErrStat != SNMP_ERRORSTATUS_NOERROR)
             {
                return(ErrStat);
             }

        switch(Field)
        {
                case 1:                //subnet itself

                        VarBind->value.asnType        = ASN_RFC1155_IPADDRESS;
                               VarBind->value.asnValue.string.length = sizeof(ULONG);
                        
                               if ( NULL == 
                                    (VarBind->value.asnValue.string.stream =
                                    SnmpUtilMemAlloc(VarBind->value.asnValue.string.length
                                   )) )
                          {
                                  ErrStat = SNMP_ERRORSTATUS_GENERR;
                                  goto Exit;
                          }
                        
                        //
                        // SNMP expects the MSB to be in the first byte, MSB-1
                        // to be in the second, ....
                        //
                        VarBind->value.asnValue.string.stream[0] =
                                        (BYTE)((pScope + Index)->Subnet >> 24);
                        VarBind->value.asnValue.string.stream[1] =
                                (BYTE)(((pScope + Index)->Subnet >> 16) & 0xFF);
                        VarBind->value.asnValue.string.stream[2] =
                                (BYTE)(((pScope + Index)->Subnet >> 8) & 0xFF);
                        VarBind->value.asnValue.string.stream[3] =
                                (BYTE)((pScope + Index)->Subnet & 0xFF );
                        VarBind->value.asnValue.address.dynamic = TRUE;
                        break;

                case 2:                // NumAddressesInUse
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number = 
                                        (AsnCounter)((pScope + Index)->
                                                        NumAddressesInuse);
                               break;
                case 3:                // NumAddressesFree
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number = 
                                        (AsnCounter)((pScope + Index)->
                                                        NumAddressesFree);
                               break;
                case 4:                // NumPendingOffers
                        VarBind->value.asnType        = ASN_RFC1155_COUNTER;
                               VarBind->value.asnValue.number = 
                                        (AsnCounter)((pScope + Index)->
                                                        NumPendingOffers);
                               break;

                default:
                        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
                        break;

        }
Exit:
        return(ErrStat); 
} // ScopeGet 

          
UINT
ScopeGetNext(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY          *MibPtr
          )
{
     DWORD          OidIndex;
     INT            Index;
     DWORD         FieldNo;
     UINT         ErrStat = SNMP_ERRORSTATUS_NOERROR;
     BOOL         fFirst;
     LPSCOPE_MIB_INFO pScope = spMibInfo->ScopeInfo;
        

     //
     // Check if the name passed matches any in the table (i.e. table of
     // of ADD_KEY_T structures.  If there is a match, the address
     // of the ip address key and the matching field's no. are returned 
     //
     ErrStat = ScopeMatch(VarBind,  &Index,  &FieldNo,  MIB_GETNEXT, &fFirst); 
     if (        
                (ErrStat != SNMP_ERRORSTATUS_NOERROR)
                        &&
                (ErrStat != SNMP_ERRORSTATUS_NOSUCHNAME)
        )
     {
                return(GetNextVar(VarBind, MibPtr));
     }

     //
     // We were passed an oid that is less than all oids in the table. Set
     // the Index to -1 so that we retrieve the first record in the table
     //
     if (fFirst)
     {
        Index = -1;
     }
     //
     // Since the operation is GETNEXT, get the next IP address (i.e. one
     // that is lexicographically bigger.  If there is none, we must increment
     // the field value and move back to the lexically first item in the table
     // If the new field value is more than the largest supported, we call
     // the MibFunc of the next MIB entry.
     //
     if ((Index = ScopeFindNext(Index)) < 0) 
     {
          
          //
          // if we were trying to retrieve the second or subsequent record
          // we must increment the field number nd get the first record in 
          // the table.  If we were retrieving the first record, then 
          // we should get the next var.
          //
          if (!fFirst)
          {
            Index = ScopeFindNext(-1);
          }
          else
          {
                return(GetNextVar(VarBind, MibPtr));
          }

          //
          // If either there is no entry in the table or if we have
          // exhausted all fields of the entry, call the function
          // of the next mib entry.
          //
          if (
                (++FieldNo > NO_FLDS_IN_SCOPE_ROW) || (Index < 0)
             )
          {                
                return(GetNextVar(VarBind, MibPtr));
          }
     }
                
     if (VarBind->name.idLength <= (SCOPE_OIDLEN + 4))
     {
         UINT TableEntryIds[5];  //field and subnet mask have a length of 5
         AsnObjectIdentifier  TableEntryOid = {OID_SIZEOF(TableEntryIds),
                                             TableEntryIds };
         SnmpUtilOidFree( &VarBind->name);
         SnmpUtilOidCpy(&VarBind->name, &MIB_OidPrefix);
         SnmpUtilOidAppend(&VarBind->name, &MibPtr->Oid);
         TableEntryIds[0] = (UINT)FieldNo;
         OidIndex                  = 1;
         TableEntryIds[OidIndex++] = (UINT)((pScope + Index)->Subnet >> 24);
         TableEntryIds[OidIndex++] = (UINT)((pScope + Index)->Subnet >> 16 & 0xFF);
         TableEntryIds[OidIndex++] = (UINT)((pScope + Index)->Subnet >> 8 & 0xFF);
         TableEntryIds[OidIndex++] = (UINT)((pScope + Index)->Subnet & 0xFF);
         TableEntryOid.idLength    = OidIndex;
         SnmpUtilOidAppend(&VarBind->name, &TableEntryOid);
     }
     else
     {
        //
        // The fixed part of the objid is corect. Update the rest.
        //
        OidIndex = SCOPE_OIDLEN;
        VarBind->name.ids[OidIndex++] = (UINT)FieldNo;
        VarBind->name.ids[OidIndex++] = (UINT)((pScope + Index)->Subnet >> 24);
        VarBind->name.ids[OidIndex++] = (UINT)(((pScope + Index)->Subnet >> 16) & 0xFF);
        VarBind->name.ids[OidIndex++] = (UINT)(((pScope + Index)->Subnet >> 8) & 0xFF);
        VarBind->name.ids[OidIndex++] = (UINT)((pScope + Index)->Subnet & 0xFF);
        VarBind->name.idLength        = OidIndex;
    }

     //
     // Get the value
     //
     ErrStat = ScopeGet(VarBind);

     return(ErrStat);
}

  

UINT
ScopeMatch(
       IN RFC1157VarBind *VarBind,
       IN LPDWORD         pIndex,
       IN LPDWORD         pField,
       IN UINT                  PduAction,
       IN LPBOOL         pfFirst
        )
{
        DWORD                         OidIndex;
        DWORD                         Index;
        DWORD                         ScopeIndex;
        DWORD                          Add = 0;
        UINT                         ErrStat = SNMP_ERRORSTATUS_NOERROR;
        INT                          CmpVal;
        DWORD                         AddLen;
        LPSCOPE_MIB_INFO         pScope = spMibInfo->ScopeInfo;

        ASSERT(PduAction != MIB_SET);

        if (pfFirst != NULL)
        {
                *pfFirst = FALSE;
        } 
        //
        // If there are no keys, return error
        //
        if (spMibInfo->Scopes == 0)
        {
                if (PduAction == MIB_GETNEXT)
                {
                        *pfFirst = TRUE;
                }
                else
                {
                        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                }
                goto Exit;
        }

        //
        // fixed part of the PullPnr table entries
        //
        OidIndex = SCOPE_OIDLEN;

        //
        // if the field specified is more than the max. in the table entry
        // barf
        //
        if (
                (*pField = VarBind->name.ids[OidIndex++]) > 
                        (DWORD)NO_FLDS_IN_SCOPE_ROW
           )
        {
                if (PduAction == MIB_GETNEXT)
                {
                        *pIndex = spMibInfo->Scopes - 1;
                        goto Exit;
                }
                else
                {
                        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                        goto Exit;
                }
        }

        //
        // get the length of key specified
        //
        AddLen = VarBind->name.idLength - (SCOPE_OIDLEN + 1);
        
        ScopeIndex = OidIndex;
        for (Index = 0; Index < AddLen; Index++)
        {
           Add = Add | (((BYTE)(VarBind->name.ids[ScopeIndex++])) << (24 - (Index * 8)));
        } 

        //
        // Check if the address specified matches with one of the keys
        //
        for (Index = 0; Index < spMibInfo->Scopes; Index++, pScope++)
        {
                if (Add == pScope->Subnet)
                {
                        *pIndex = Index;
                        return(SNMP_ERRORSTATUS_NOERROR);
                }
                else
                {
                        //
                        // if passed in value is greater, continue on to
                        // the next item.  The list is in ascending order
                        //
                        if (Add > pScope->Subnet)
                        {
                                continue;
                        }
                        else
                        {
                                //
                                // the list element is > passed in value, 
                                // break out of the loop
                                //
                                break;
                        }
                }
        }

        //
        // if no match, but field is GetNext, return the (highest index - 1)
        // reached above.  This is because, ScopeFindNext will be called by
        // the caller 
        //
        if (PduAction == MIB_GETNEXT)
        {
                if (Index == 0)
                {
                        *pfFirst = TRUE;
                }
                else
                {
                        *pIndex = Index - 1;
                } 
                ErrStat =  SNMP_ERRORSTATUS_NOERROR;
        }
        else
        {
                ErrStat =  SNMP_ERRORSTATUS_NOSUCHNAME;
        }
Exit:
        return(ErrStat);
}

UINT
ScopeFindNext(
        INT           SubKeyIndex
        )
{
        DWORD i;
        LONG  nextif;
        LPSCOPE_MIB_INFO        pScope = spMibInfo->ScopeInfo;
        
        //
        // if SubKeyIndex is 0  or more, search for the key next to
        // the key passed.
        //
        for (nextif =  -1, i = 0 ; i < spMibInfo->Scopes; i++)
        {
                if (SubKeyIndex >= 0) 
                {
                        if (
                                (pScope + i)->Subnet <= 
                                        (pScope + SubKeyIndex)->Subnet
                           )
                        {
                           //
                           // This item is lexicographically less or equal, 
                           // continue 
                           //
                           continue;
                        }
                        else
                        {
                          //
                          // We found an item that is > than the item indicated
                          // to us.  Break out of the loop
                          //
                          nextif = i;
                          break;
                        }
                }
                else
                {

#if 0
                   //
                   // if we want the first entry, then continue until
                   // we get an entry that is lexicographically same or
                   // greater
                   //
                   if (
                        (nextif < 0) 
                           ||
                        (pScope + (i - 1))->Subnet < (pScope + nextif)->Subnet
                    )
                  {
                        nextif = i;
                  }
#endif
                    nextif = 0;
                    break;
                }
        }
        return(nextif);
}        

UINT
ScopeGetFirst(
       IN RFC1157VarBind *VarBind,
       IN MIB_ENTRY        *MibPtr
        )
{

        LPSCOPE_MIB_INFO pScope = spMibInfo->ScopeInfo;
        INT           Iface;
        UINT           TableEntryIds[5];
        AsnObjectIdentifier        TableEntryOid = { OID_SIZEOF(TableEntryIds),
                                                        TableEntryIds };
           UINT   ErrStat;

        
        //
        // If there is no entry in the table, go to the next MIB variable 
        //
        if (spMibInfo->Scopes == 0)
        {
                 return(GetNextVar(VarBind, MibPtr));
        }
        //
        // Get the first entry in the table
        //
        Iface = ScopeFindNext(-1);


        //
        // Write the object Id into the binding list and call get
        // func
        //
        SnmpUtilOidFree( &VarBind->name );
        SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix );
        SnmpUtilOidAppend( &VarBind->name, &MibPtr->Oid );

        //
        // The fixed part of the objid is correct. Update the rest.
        //
        
        TableEntryIds[0] = 1;
        TableEntryIds[1] = (UINT)((pScope + Iface)->Subnet >> 24);
        TableEntryIds[2] = (UINT)(((pScope + Iface)->Subnet >> 16)  & 0xFF);
        TableEntryIds[3] = (UINT)(((pScope + Iface)->Subnet >> 8)  & 0xFF);
        TableEntryIds[4] = (UINT)((pScope + Iface)->Subnet & 0xFF);
        SnmpUtilOidAppend( &VarBind->name, &TableEntryOid );

        ErrStat = ScopeGet(VarBind);
        return(ErrStat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpmib\dhcptst.c ===
//
// Copyright (c) 1991  Microsoft Corporation
//

//-------------------------- MODULE DESCRIPTION ----------------------------
//
//  dhcpmain.c
//
//---------------------------------------------------------------------------

//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <windows.h>

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include "dhcpmib.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

typedef AsnObjectIdentifier View; // temp until view is defined...

_cdecl main(
    IN int  argumentCount,
    IN char *argumentVector[])
{
    HANDLE  hExtension;
    FARPROC initAddr;
    FARPROC queryAddr;
    FARPROC trapAddr;

    DWORD  timeZeroReference;
    HANDLE hPollForTrapEvent;
    View   supportedView;
//    UINT   Val;
    DWORD  Choice;
    DWORD  Oper;

    INT numQueries = 10;

    SnmpSvcSetLogLevel(SNMP_LOG_TRACE);
    SnmpSvcSetLogType(SNMP_OUTPUT_TO_CONSOLE);

    // avoid compiler warning...
    UNREFERENCED_PARAMETER(argumentCount);
    UNREFERENCED_PARAMETER(argumentVector);

    timeZeroReference = GetCurrentTime();

    // load the extension agent dll and resolve the entry points...
    if (GetModuleHandle("dhcpmib.dll") == NULL)
    {
        if ((hExtension = LoadLibrary("dhcpmib.dll")) == NULL)
        {
            SnmpUtilDbgPrint(1, "error on LoadLibrary %d\n", GetLastError());

        }
        else
	{
	    if ((initAddr = GetProcAddress(hExtension,
                 		"SnmpExtensionInit")) == NULL)
            {
              SnmpUtilDbgPrint(1, "error on GetProcAddress %d\n", GetLastError());
            }
            else
	    {
	      if ((queryAddr = GetProcAddress(hExtension,
                 		"SnmpExtensionQuery")) == NULL)
              {
                    SnmpUtilDbgPrint(1, "error on GetProcAddress %d\n",
                              GetLastError());

              }
              else
	      {
		if ((trapAddr = GetProcAddress(hExtension,
                                   "SnmpExtensionTrap")) == NULL)
                {
                   SnmpUtilDbgPrint(1, "error on GetProcAddress %d\n",
                      GetLastError());
                }
         	else
                {
                  // initialize the extension agent via its init entry point...
                  (*initAddr)(
                       timeZeroReference,
                       &hPollForTrapEvent,
                    &supportedView);
                }
	     }
	   }
	}
      } // end if (Already loaded)

      {
         RFC1157VarBindList varBinds;
         AsnInteger         errorStatus;
         AsnInteger         errorIndex;
	// DWORD i;
         UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 311, 2 };
	 UINT OID_Suffix1[] = { 1, 2, 0};
	 UINT OID_Suffix2[] = { 1, 3, 0};
	 UINT OID_Suffix3[] = { 1, 4, 0};
         AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };
	 AsnObjectIdentifier Sf1Oid = { OID_SIZEOF(OID_Suffix1), OID_Suffix1};
	 AsnObjectIdentifier Sf2Oid = { OID_SIZEOF(OID_Suffix2), OID_Suffix2};
	 AsnObjectIdentifier Sf3Oid = { OID_SIZEOF(OID_Suffix3), OID_Suffix3};


	 errorStatus = 0;
	 errorIndex  = 0;
         varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind));
//         varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) * 4);
//         varBinds.len = 4;
         varBinds.len = 1;
         SnmpUtilOidCpy( &varBinds.list[0].name, &MIB_OidPrefix );
         varBinds.list[0].value.asnType = ASN_NULL;

	 printf("Walk ? (1 for yes) -- ");
	 scanf("%d", &Choice);
	 if (Choice == 1)
	 {
          do
          {
	    printf( "\nGET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
                                        printf( "   " );
            (*queryAddr)( (AsnInteger)ASN_RFC1157_GETNEXTREQUEST,
                          &varBinds,
		          &errorStatus,
		          &errorIndex
                          );
            printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
	    if ( errorStatus )
	       {
               printf( "\nErrorstatus:  %lu\n\n", errorStatus );
	       }
	    else
	       {
               printf( "\n  =  " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	       }
//            putchar( '\n' );

         } while ( varBinds.list[0].name.ids[MIB_PREFIX_LEN-1] == 2 );

         // Free the memory
         SnmpUtilVarBindListFree( &varBinds );
	 }
       } // block


       {


//       char String[80];
       DWORD i;
       RFC1157VarBindList varBinds;
       UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 311, 2 };
       UINT TempOid[255];
       AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };
       AsnObjectIdentifier MIB_Suffix = { OID_SIZEOF(TempOid), TempOid};
       AsnInteger errorStatus;
       AsnInteger errorIndex;
       UINT	Code = 0;


        varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
        varBinds.len = 1;
Loop:
       printf("Enter Code for Group \nPar\t1\nScope\t2\nCode is --");
       scanf("%d", &TempOid[0]);
       if (TempOid[0] < 1 || TempOid[0] > 2)
       {
	  goto Loop;
       }
LoopLT:
       printf("Leaf or Table access (0/1) -- ");
       scanf("%d", &Code);
       if (Code != 0 && Code != 1)
       {
	  goto LoopLT;

       }
       if (Code == 1)
       {
         printf("Enter Code for var. --");
        scanf("%d", &TempOid[1]);
        TempOid[2] = 0;
	MIB_Suffix.idLength = 3;
       }
       else
       {
	TempOid[2] = 1;
        printf("Enter Code for field --");
        scanf("%d", &TempOid[3]);
	printf("Input Subnet address in host order\n");
	for (i=0; i< 4; i++)
	{
		  printf("\nByte (%d) -- ", i);
		  scanf("%d", &TempOid[4 + i]);
	}
	MIB_Suffix.idLength = 8;

       }
	//
	// Construct OID with complete prefix for comparison purposes
	//
	SnmpUtilOidCpy( &varBinds.list[0].name, &MIB_OidPrefix );
	SnmpUtilOidAppend( &varBinds.list[0].name, &MIB_Suffix );

	SnmpUtilPrintOid( &varBinds.list[0].name );
//Loop1:
	printf("\nGET/GET_NEXT - 0/? -- ");
	scanf("%d", &Oper);
#if 0
	printf("\nEnter Type (1 - Integer, 2-Octet String, 3 -IP address, 4 -Counter -- ");
	scanf("%d",&Choice);
        if (Choice < 1 || Choice > 4)
	{
	  goto Loop1;
        }
	switch(Choice)
	{
		case(1):
       			varBinds.list[0].value.asnType = ASN_INTEGER;
			if (Oper == 0)
			{
			printf("\nInteger Value -- ");
			scanf("%d", &Val);
       			varBinds.list[0].value.asnValue.number = Val;
			}
			break;
		case(2):
       			varBinds.list[0].value.asnType = ASN_OCTETSTRING;
			if (Oper == 0)
			{
			printf("\nCharacter array -- ");
			scanf("%s", String);
		  	varBinds.list[0].value.asnValue.string.length =
                    		strlen( (LPSTR)String );

       			varBinds.list[0].value.asnValue.string.stream = String;

  			varBinds.list[0].value.asnValue.string.dynamic = FALSE;
			}
	
			break;
		case(3):
       			varBinds.list[0].value.asnType = ASN_RFC1155_IPADDRESS;
			if (Oper == 0)
			{
			printf("\nInput ip address bytes in network byte order\n");
			for (i=0; i< 4; i++)
			{
			  printf("\nByte (%d) -- ", i);
			  scanf("%d", &String[i]);
			}
			String[4] = 0;
		  	varBinds.list[0].value.asnValue.string.length =
                    		strlen( (LPSTR)String );

       			varBinds.list[0].value.asnValue.string.stream = String;

  			varBinds.list[0].value.asnValue.string.dynamic = TRUE;
			}
			break;
		case(4):
       			varBinds.list[0].value.asnType = ASN_RFC1155_COUNTER;
			if (Oper == 0)
			{
			printf("\nInteger Value -- ");
			scanf("%d", &Val);
       			varBinds.list[0].value.asnValue.number = Val;

			}
			break;
		default:
			printf("wrong type\n");
			break;
       }		
#endif
       errorStatus       = 0;
       errorIndex        = 0;

	switch(Oper)
	{
		case(0):
			Code = ASN_RFC1157_GETREQUEST;
       			printf( "GET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
			break;
		default:
       			printf( "GETNEXT:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
			Code = ASN_RFC1157_GETNEXTREQUEST;
			break;


	}
       (*queryAddr)( (BYTE)Code,
                              &varBinds,
			      &errorStatus,
			      &errorIndex
                              );
       printf( "\n Errorstatus:  %lu\n\n", errorStatus );
       if (Code != ASN_RFC1157_SETREQUEST)
       {
          if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
          {
            printf( "Value:  " );
	    SnmpUtilPrintAsnAny( &varBinds.list[0].value ); putchar( '\n' );
	    SnmpUtilOidFree(&varBinds.list[0].name);
	  }
       }
	
#if 0
       varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
       varBinds.len = 1;
       varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
       varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
       memcpy( varBinds.list[0].name.ids, &itemn,
               sizeof(UINT)*varBinds.list[0].name.idLength );
       varBinds.list[0].value.asnType = ASN_INTEGER;
       printf("Value ? -- ");
       scanf("%d", &Val);
       varBinds.list[0].value.asnValue.number = Val;
       printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
       printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
       (*queryAddr)( ASN_RFC1157_SETREQUEST,
                              &varBinds,
			      &errorStatus,
			      &errorIndex
                              );
       printf( "\nSET Errorstatus:  %lu\n\n", errorStatus );

       (*queryAddr)( ASN_RFC1157_GETREQUEST,
                              &varBinds,
			      &errorStatus,
			      &errorIndex
                              );
       if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
       {
          printf( "Value:  " );
	  SnmpUtilPrintAsnAny( &varBinds.list[0].value ); putchar( '\n' );
	  SnmpUtilOidFree(&varBinds.list[0].name);
	}
       printf( "\nGET Errorstatus:  %lu\n\n", errorStatus );

#endif
#if 0
       // Free the memory
       SnmpUtilVarBindListFree( &varBinds );
#endif

       printf( "\n\n" );
       printf("Enter 1 to exit -- ");
       scanf("%d", &Choice);
       if (Choice != 1)
       {
       		goto Loop;
       }
    }

    return 0;

} // end main()


//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\nt\util.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.c

Abstract:

    This file contains utility functions.

Author:

    Madan Appiah (madana) 7-Dec-1993.

Environment:

    User Mode - Win32

Revision History:

--*/

#include "precomp.h"
#include "dhcpglobal.h"
#include <dhcploc.h>
#include <dhcppro.h>

#define  MESSAGE_BOX_WIDTH_IN_CHARS 65

typedef struct _POPUP_THREAD_PARAM {
    LPWSTR Title;
    LPWSTR Message;
    ULONG  Flags;
} POPUP_THREAD_PARAM, *LPPOPUP_THREAD_PARAM;

POPUP_THREAD_PARAM PopupThreadParam = { NULL, NULL, 0 };


DWORD
DoPopup(
    PVOID Buffer
    )
/*++

Routine Description:

    This function pops up a message to the user.  It must run it's own
    thread.  When the user acknowledge the popup, the thread
    deallocates the message buffer and returns.

Arguments:

    Buffer - A pointer to a NULL terminated message buffer.

Return Values:

    Always returns 0
    
--*/
{
    DWORD Result;
    LPPOPUP_THREAD_PARAM Params = Buffer;

    Result = MessageBox(
        NULL, // no owner
        Params->Message, 
        Params->Title,
        ( MB_OK | Params->Flags |
          MB_SERVICE_NOTIFICATION |
          MB_SYSTEMMODAL |
          MB_SETFOREGROUND |
          MB_DEFAULT_DESKTOP_ONLY
            )
        );


    LOCK_POPUP();

    if( Params->Message != NULL ) {
        LocalFree( Params->Message );
        Params->Message = NULL;
    }

    if( Params->Title != NULL ) {
        LocalFree( Params->Title );
        Params->Title = NULL;
    }

    //
    // close the global handle, so that we will not consume this
    // thread resource until another popup.
    //

    CloseHandle( DhcpGlobalMsgPopupThreadHandle );
    DhcpGlobalMsgPopupThreadHandle = NULL;

    UNLOCK_POPUP();

    //
    // Always return 0
    //
    
    return 0;
}


DWORD
DisplayUserMessage(
    IN PDHCP_CONTEXT DhcpContext,
    IN DWORD MessageId,
    IN DHCP_IP_ADDRESS IpAddress
)
/*++

Routine Description:

    This function starts a new thread to display a message box.

    N.B.  If a thread already exists which is waiting for user input
    on a message box, then this routine does not create another
    thread.

Arguments:

    DhcpContext -- the context to display messages for
    
    MessageId - The ID of the message to display.
        (The actual message string is obtained from the dhcp module).

    IpAddress - Ip address involved.

--*/
{
    DWORD ThreadID, TitleLength, MsgLength, Flags;
    LPWSTR Title = NULL, Message = NULL;

    switch(MessageId) {

    case MESSAGE_FAILED_TO_OBTAIN_LEASE:
        Flags = MB_ICONSTOP;
        break;

    case MESSAGE_SUCCESSFUL_LEASE :
        Flags = MB_ICONINFORMATION;
        break;

    default:
        DhcpAssert(FALSE);
        Flags = MB_ICONSTOP;
        break;
    }

    LOCK_POPUP();

    //
    // if we are asked to display no message popup, simply return.
    //

    if ( DhcpGlobalDisplayPopup == FALSE ) {
        goto Cleanup;
    }

    //
    // if the message popup thread handle is non-null, check to see
    // the thread is still running, if so don't display another popup,
    // otherwise close the last popup handle and create another popup 
    // thread for new message.
    //

    if( DhcpGlobalMsgPopupThreadHandle != NULL ) {
        DWORD WaitStatus;

        //
        // Time out immediately if the thread is still running.
        //

        WaitStatus = WaitForSingleObject(
            DhcpGlobalMsgPopupThreadHandle,
            0 );
        
        if ( WaitStatus == WAIT_TIMEOUT ) {
            goto Cleanup;

        } else if ( WaitStatus == 0 ) {

            //
            // This shouldn't be a case, because we close this handle at
            // the end of popup thread.
            //

            DhcpAssert( WaitStatus == 0 );

            CloseHandle( DhcpGlobalMsgPopupThreadHandle );
            DhcpGlobalMsgPopupThreadHandle = NULL;

        } else {
            DhcpPrint((
                DEBUG_ERRORS,
                    "Cannot WaitFor message popup thread: %ld\n",
                        WaitStatus ));
            goto Cleanup;
        }
    }


    MsgLength = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE
        | FORMAT_MESSAGE_ARGUMENT_ARRAY 
        | FORMAT_MESSAGE_ALLOCATE_BUFFER
        | MESSAGE_BOX_WIDTH_IN_CHARS,
        (LPVOID)DhcpGlobalMessageFileHandle,
        MessageId,
        0,  // language id.
        (LPWSTR)&Message, // return buffer place holder.
        0,  // minimum buffer size to allocate.
        NULL   // No Params
    );

    if ( MsgLength == 0) {
        DhcpPrint(( DEBUG_ERRORS,
            "FormatMessage failed, err = %ld.\n", GetLastError()));
        goto Cleanup;
    }

    DhcpAssert( Message != NULL );
    DhcpAssert( (wcslen(Message)) == MsgLength );

    //
    // get message box title.
    //

    TitleLength = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE |
        FORMAT_MESSAGE_ALLOCATE_BUFFER,
        (LPVOID)DhcpGlobalMessageFileHandle,
        MESSAGE_POPUP_TITLE,
        0, // language id.
        (LPWSTR)&Title,  // return buffer place holder.
        0, // minimum buffer size to allocate.
        NULL  // insert strings.
    );

    if ( TitleLength == 0) {
        DhcpPrint(( DEBUG_ERRORS,
            "FormatMessage to Message box Title failed, err = %ld.\n",
                GetLastError()));
        goto Cleanup;
    }

    DhcpAssert( Title != NULL );
    DhcpAssert( (wcslen(Title)) == TitleLength );

    PopupThreadParam.Title = Title;
    PopupThreadParam.Message = Message;
    PopupThreadParam.Flags = Flags;


    //
    // Create a thread, to display a message box to the user.  We need
    // a new thread because MessageBox() blocks until the user clicks
    // on the OK button, and we can't block this thread.
    //
    // DoPopup frees the buffer.
    //

    DhcpGlobalMsgPopupThreadHandle = CreateThread(
        NULL,    // no security.
        0,       // default stack size.
        DoPopup, // entry point.
        (PVOID)&PopupThreadParam,
        0, 
        &ThreadID
    );

    if ( DhcpGlobalMsgPopupThreadHandle == NULL ) {
        DhcpPrint((
            DEBUG_ERRORS,
            "DisplayUserMessage:  Could not create thread, err = %ld.\n",
            GetLastError() ));
    }

Cleanup:

    UNLOCK_POPUP();

    return 0;
}

VOID
DhcpLogEvent(
    IN PDHCP_CONTEXT DhcpContext, OPTIONAL
    IN DWORD EventNumber,
    IN DWORD ErrorCode OPTIONAL
)
/*++

Routine Description:

    This functions formats and writes an event log entry.

Arguments:

    DhcpContext - The context for the event. Optional parameter.

    EventNumber - The event to log.

    ErrorCode - Windows Error code to record. Optional parameter.

--*/
{
    LPWSTR HWAddressBuffer = NULL;
    LPWSTR IPAddressBuffer = NULL;
    LPWSTR IPAddressBuffer2 = NULL;
    CHAR ErrorCodeOemStringBuf[32 + 1];
    WCHAR ErrorCodeStringBuf[32 + 1];
    LPWSTR ErrorCodeString = NULL;
    LPWSTR Strings[10];
    DHCP_IP_ADDRESS IpAddr;

    if( DhcpContext != NULL ) {

        if( EVENT_NACK_LEASE == EventNumber ) {
            IpAddr = DhcpContext->NackedIpAddress;
        } if( EVENT_ADDRESS_CONFLICT == EventNumber ) {
            IpAddr = DhcpContext->ConflictAddress;
        } else {
            IpAddr = DhcpContext->IpAddress;
        }
        
        HWAddressBuffer = DhcpAllocateMemory(
            (DhcpContext->HardwareAddressLength * 2 + 1) *
            sizeof(WCHAR)
            );

        if( HWAddressBuffer == NULL ) {
            DhcpPrint(( DEBUG_MISC, "Out of memory." ));
            goto Cleanup;
        }

        DhcpHexToString(
            HWAddressBuffer,
            DhcpContext->HardwareAddress,
            DhcpContext->HardwareAddressLength
            );

        HWAddressBuffer[DhcpContext->HardwareAddressLength * 2] = '\0';

        IPAddressBuffer = DhcpOemToUnicode(
            inet_ntoa( *(struct in_addr *)&IpAddr ),
            NULL
            );

        if( IPAddressBuffer == NULL ) {
            DhcpPrint(( DEBUG_MISC, "Out of memory." ));
            goto Cleanup;
        }

        if( EVENT_NACK_LEASE == EventNumber ) {
            IPAddressBuffer2 = DhcpOemToUnicode(
                inet_ntoa( *(struct in_addr *)&DhcpContext->DhcpServerAddress ),
                NULL
            );

            if( NULL == IPAddressBuffer2 ) goto Cleanup;
        }
    }

    strcpy( ErrorCodeOemStringBuf, "%%" );
    _ultoa( ErrorCode, ErrorCodeOemStringBuf + 2, 10 );

    ErrorCodeString = DhcpOemToUnicode(
                        ErrorCodeOemStringBuf,
                        ErrorCodeStringBuf );

    //
    // Log an event
    //

    switch ( EventNumber ) {

    case EVENT_LEASE_TERMINATED:

        DhcpAssert( HWAddressBuffer != NULL );
        DhcpAssert( IPAddressBuffer != NULL );

        Strings[0] = HWAddressBuffer;
        Strings[1] = IPAddressBuffer;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_LEASE_TERMINATED,
            EVENTLOG_ERROR_TYPE,
            2,
            0,
            Strings,
            NULL );

        break;

    case EVENT_FAILED_TO_OBTAIN_LEASE:

        DhcpAssert( HWAddressBuffer != NULL );
        DhcpAssert( ErrorCodeString != NULL );

        Strings[0] = HWAddressBuffer;
        Strings[1] = ErrorCodeString;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_FAILED_TO_OBTAIN_LEASE,
            EVENTLOG_ERROR_TYPE,
            2,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode );

        break;

    case EVENT_NACK_LEASE:

        DhcpAssert( HWAddressBuffer != NULL );
        DhcpAssert( IPAddressBuffer != NULL );
        DhcpAssert( IPAddressBuffer2 != NULL );

        Strings[0] = IPAddressBuffer;
        Strings[1] = HWAddressBuffer;
        Strings[2] = IPAddressBuffer2;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_NACK_LEASE,
            EVENTLOG_ERROR_TYPE,
            3,
            0,
            Strings,
            NULL );

        break;

    case EVENT_ADDRESS_CONFLICT:
        DhcpAssert( IPAddressBuffer != NULL );
        DhcpAssert( HWAddressBuffer != NULL );

        Strings[0] = IPAddressBuffer;
        Strings[1] = HWAddressBuffer;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_ADDRESS_CONFLICT,
            EVENTLOG_WARNING_TYPE,
            2,
            0,
            Strings,
            NULL );
        break;

    case EVENT_IPAUTOCONFIGURATION_FAILED:
        DhcpAssert( HWAddressBuffer != NULL );
        DhcpAssert( ErrorCodeString != NULL );

        Strings[0] = HWAddressBuffer;
        Strings[1] = ErrorCodeString;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_IPAUTOCONFIGURATION_FAILED,
            EVENTLOG_WARNING_TYPE,
            2,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode );

        break;

     case EVENT_FAILED_TO_RENEW:

        // The 'timeout' event should be logged only if there is no PPP
        // adapter up. It is so because having a PPP adapter means the
        // routes are hijacked, hence renewals up to T2 are expected to
        // fail.
        if (ErrorCode != ERROR_SEM_TIMEOUT ||
            DhcpGlobalNdisWanAdaptersCount == 0 ||
            time(NULL) >= DhcpContext->T2Time)
        {
            DhcpAssert( HWAddressBuffer != NULL );
            DhcpAssert( ErrorCodeString != NULL );

            Strings[0] = HWAddressBuffer;
            Strings[1] = ErrorCodeString;

            DhcpReportEventW(
                DHCP_EVENT_CLIENT,
                EVENT_FAILED_TO_RENEW,
                EVENTLOG_WARNING_TYPE,
                2,
                sizeof(ErrorCode),
                Strings,
                &ErrorCode );
        }

        break;

    case EVENT_DHCP_SHUTDOWN:

        DhcpAssert( ErrorCodeString != NULL );

        Strings[0] = ErrorCodeString;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_DHCP_SHUTDOWN,
            EVENTLOG_WARNING_TYPE,
            1,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode );

        break;

    case EVENT_IPAUTOCONFIGURATION_SUCCEEDED :

        Strings[0] = HWAddressBuffer;
        Strings[1] = IPAddressBuffer;

        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_IPAUTOCONFIGURATION_SUCCEEDED,
            EVENTLOG_WARNING_TYPE,
            2,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode
        );
        break;

    case EVENT_COULD_NOT_INITIALISE_INTERFACE :

        DhcpAssert( NULL != ErrorCodeString);
        Strings[0] = ErrorCodeString;
        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_COULD_NOT_INITIALISE_INTERFACE,
            EVENTLOG_ERROR_TYPE,
            1,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode
        );

        break;

    case EVENT_NET_ERROR:
        DhcpAssert( NULL != ErrorCodeString);
        Strings[0] = ErrorCodeString;
        DhcpReportEventW(
            DHCP_EVENT_CLIENT,
            EVENT_NET_ERROR,
            EVENTLOG_WARNING_TYPE,
            1,
            sizeof(ErrorCode),
            Strings,
            &ErrorCode
        );
        break;

    default:

        DhcpPrint(( DEBUG_MISC, "Unknown event." ));
        break;
   }

Cleanup:

    if( HWAddressBuffer != NULL ) {
        DhcpFreeMemory( HWAddressBuffer );
    }

    if( IPAddressBuffer != NULL ) {
        DhcpFreeMemory( IPAddressBuffer );
    }

    if( IPAddressBuffer2 != NULL ) {
        DhcpFreeMemory( IPAddressBuffer2 );
    }

}

#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length;
    static BeginningOfLine = TRUE;
    LPSTR Text;

    //
    // If we aren't debugging this functionality, just return.
    //

    if ( DebugFlag != 0 && (DhcpGlobalDebugFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    // EnterCriticalSection( &DhcpGlobalDebugFileCritSect );

    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        length += (ULONG) sprintf( &OutputBuffer[length], "[Dhcp] " );

        //
        // Put the timestamp at the begining of the line.
        //
        IF_DEBUG( TIMESTAMP ) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }

        //
        // Indicate the type of message on the line
        //
        switch (DebugFlag) {
        case DEBUG_ERRORS:
            Text = "ERRR";
            break;

        case DEBUG_PROTOCOL:
            Text = "PROT";
            break;

        case DEBUG_LEASE:
            Text = "LEAS";
            break;

        case DEBUG_PROTOCOL_DUMP:
            Text = "DUMP";
            break;

        case DEBUG_MISC:
            Text = "MISC";
            break;

        default:
            Text = "DHCP";
            break;
        }

        if ( Text != NULL ) {
            length += (ULONG) sprintf( &OutputBuffer[length], "[%s] ", Text );
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );

    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);


    //
    // Output to the debug terminal,
    //

    if (NULL == DhcpGlobalDebugFile) {
        (void) DbgPrint( (PCH) OutputBuffer);
    } else {

        //
        // Note: other process can still write to the log file. This should be OK since
        // only the Dhcp client service is supposed to write to the log file.
        //
        EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
        SetFilePointer(DhcpGlobalDebugFile, 0, NULL, FILE_END);
        WriteFile(DhcpGlobalDebugFile, OutputBuffer, length, &length, NULL);
        LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );
    }

    // LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );

}

#endif // DBG


PDHCP_CONTEXT
FindDhcpContextOnNicList(
    IN LPCWSTR AdapterName, OPTIONAL
    IN DWORD InterfaceContext
    )
/*++

Routine Description:

    This function finds the DHCP_CONTEXT for the specified
    adapter name on the Nic list.

    This function must be called with LOCK_RENEW_LIST().

Arguments:

    AdapterName - name of the adapter.
    HardwareAddress - The hardware address to look for.

Return Value:

    A pointer to the desired DHCP work context.
    NULL - If the specified work context block cannot be found.

--*/
{
    PLIST_ENTRY listEntry;
    PDHCP_CONTEXT dhcpContext;
    PLOCAL_CONTEXT_INFO LocalInfo;

    listEntry = DhcpGlobalNICList.Flink;
    while ( listEntry != &DhcpGlobalNICList ) {
        dhcpContext = CONTAINING_RECORD( listEntry, DHCP_CONTEXT, NicListEntry );

        LocalInfo = dhcpContext->LocalInformation;
        if ( AdapterName ) {
            if( _wcsicmp( LocalInfo->AdapterName, AdapterName ) == 0 ) {
                return( dhcpContext );
            }

        } else {
            if( LocalInfo->IpInterfaceContext == InterfaceContext ) {
                return( dhcpContext );
            }
        }

        listEntry = listEntry->Flink;
    }

    return( NULL );
}

//
// End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\ascoscal.cpp ===
/******************************************************************
   SNetScal.cpp -- WBEM provider class implementation

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains: the definition of the DHCP_SuperScope class,
        the static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "SScoFn.h"     // needed for the declarations of all the functions.
#include "SScoScal.h"   // own header
#include "AScoScal.h"   // own header

// properties names
#define PROP_SScopeSubnets_SuperScope           L"SuperScope"
#define PROP_SScopeSubnets_Subnet               L"Subnet"

// the name of the WBEM class
#define PROVIDER_NAME_DHCP_SUPERSCOPESUBNETS    "DHCP_SuperScopeSubnets"

// main class instantiation.
CDHCP_SuperScopeToSubnet MyDHCP_SuperScopeSubnet_Scalars (PROVIDER_NAME_DHCP_SUPERSCOPESUBNETS, PROVIDER_NAMESPACE_DHCP) ;

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_SuperScopeToSubnet::CDHCP_SuperScopeToSubnet
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CDHCP_SuperScopeToSubnet::CDHCP_SuperScopeToSubnet (const CHString& strName, LPCSTR pszNameSpace ) :
	Provider(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_SuperScopeToSubnet::~CDHCP_SuperScopeToSubnet
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CDHCP_SuperScopeToSubnet::~CDHCP_SuperScopeToSubnet ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_SuperScopeToSubnet::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    Enumerates all this instances of this class. As there is only one
*                   DHCP Server per system, there is only one instance for this class
*
*****************************************************************************/
HRESULT CDHCP_SuperScopeToSubnet::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    CDHCP_SuperScope_Parameters     SuperScopeParams(NULL); // don't know here the scope
    HRESULT                         hRes = WBEM_E_FAILED;
    
    LPDHCP_SUPER_SCOPE_TABLE        pScopesTable;
	LPDHCP_SUPER_SCOPE_TABLE_ENTRY  *pSortedEntries = NULL ;
    DWORD                           dwNumEntries;

    if (SuperScopeParams.GetSuperScopes(pScopesTable, TRUE) &&
        SuperScopeParams.GetSortedScopes(ENTRIES_SORTED_ON_SUBNET, pSortedEntries, dwNumEntries))
    {
        for (int i = 0; i<dwNumEntries; i++)
        {
            if(pSortedEntries[i]->SuperScopeName != NULL)
            {
                CInstance *pInstance = CreateNewInstance(pMethodContext);  // create now the instance;

                if (pInstance != NULL)
                {
                    WCHAR wcsBuffer[256];

                    // set the superscope part of the association
                    swprintf(wcsBuffer, L"DHCP_SuperScope.Name=\"%s\"",
                                 pSortedEntries[i]->SuperScopeName ) ;
                    pInstance->SetCHString(PROP_SScopeSubnets_SuperScope, wcsBuffer);

                    // set the subnet part of the association
                    swprintf(wcsBuffer, L"DHCP_Subnet.Address=\"%u.%u.%u.%u\"",
                                (pSortedEntries[i]->SubnetAddress & 0xff000000) >> 24,
                                (pSortedEntries[i]->SubnetAddress & 0x00ff0000) >> 16,
                                (pSortedEntries[i]->SubnetAddress & 0x0000ff00) >> 8,
                                (pSortedEntries[i]->SubnetAddress & 0x000000ff));
                    pInstance->SetCHString(PROP_SScopeSubnets_Subnet, wcsBuffer);

                    hRes = Commit(pInstance);
                    if (hRes != WBEM_S_NO_ERROR)
                        break;
                }
            }
        }
    }

    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_SuperScopeToSubnet::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CDHCP_SuperScopeToSubnet::GetObject ( CInstance* pInstance, long lFlags )
{
    CHString        superScope;
    CHString        subnet;
	DHCP_IP_ADDRESS subnetAddress;

    // at this point, the key information should be provided by the pInstance
    if (!pInstance->GetCHString(PROP_SScopeSubnets_SuperScope, superScope) || 
		!pInstance->GetCHString(PROP_SScopeSubnets_Subnet, subnet) ||
		!inet_wstodw(subnet, subnetAddress)) 
        return (WBEM_E_FAILED);

    int idx;
    idx = superScope.Find(_T('"'));
    if (idx == -1)
        return WBEM_E_FAILED;
    superScope = superScope.Mid(idx + 1);
    idx = superScope.Find(_T('"'));
    if (idx == -1)
        return WBEM_E_FAILED;
    superScope = superScope.Mid(0, idx);

    CDHCP_SuperScope_Parameters SuperScopeParams(superScope);
    LPDHCP_SUPER_SCOPE_TABLE        pTable;
    LPDHCP_SUPER_SCOPE_TABLE_ENTRY  *pSortedEntries;
    DWORD                           dwNumEntries;

    if (SuperScopeParams.GetSuperScopes(pTable, TRUE) &&
        SuperScopeParams.GetSortedScopes(ENTRIES_SORTED_ON_SUBNET, pSortedEntries, dwNumEntries))
    {
        for (int i = 0; pSortedEntries[i]->SubnetAddress <= subnetAddress && i < dwNumEntries; i++)
        {
            if (pSortedEntries[i]->SubnetAddress == subnetAddress)
            {
                return wcscmp(pSortedEntries[i]->SuperScopeName, SuperScopeParams.m_wcsSuperScopeName) == 0 ?
                            WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
            }
        }
    }
    
	return WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_SuperScopeToSubnet::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CDHCP_SuperScopeToSubnet::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*****************************************************************************
*
*  FUNCTION    : CDHCP_SuperScopeToSubnet::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_PROVIDER_NOT_CAPABLE, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_SuperScopeToSubnet::PutInstance ( const CInstance &Instance, long lFlags)
{
    CHString        superScope;
    CHString        subnet;
	DHCP_IP_ADDRESS subnetAddress;

    // at this point, the key information should be provided by the pInstance
    if (!Instance.GetCHString(PROP_SScopeSubnets_SuperScope, superScope) || 
		!Instance.GetCHString(PROP_SScopeSubnets_Subnet, subnet) ||
		!inet_wstodw(subnet, subnetAddress)) 
        return (WBEM_E_FAILED);

    int idx;
    idx = superScope.Find(_T('"'));
    if (idx == -1)
        return WBEM_E_FAILED;
    superScope = superScope.Mid(idx + 1);
    idx = superScope.Find(_T('"'));
    if (idx == -1)
        return WBEM_E_FAILED;
    superScope = superScope.Mid(0, idx);

    CDHCP_SuperScope_Parameters SuperScopeParams(superScope);
    LPDHCP_SUPER_SCOPE_TABLE        pTable;
    LPDHCP_SUPER_SCOPE_TABLE_ENTRY  *pSortedEntries;
    DWORD                           dwNumEntries;

    if (SuperScopeParams.GetSuperScopes(pTable, TRUE) &&
        SuperScopeParams.GetSortedScopes(ENTRIES_SORTED_ON_SUBNET, pSortedEntries, dwNumEntries))
    {
        for (int i = 0; pSortedEntries[i]->SubnetAddress <= subnetAddress && i < dwNumEntries; i++)
        {
            if (pSortedEntries[i]->SubnetAddress == subnetAddress &&
                SuperScopeParams.AlterSubnetSet(subnetAddress))
                return WBEM_S_NO_ERROR;
        }
    }
    
	return WBEM_E_FAILED;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_SuperScopeToSubnet::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_PROVIDER_NOT_CAPABLE from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from DHCP_Server_Scalars.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_SuperScopeToSubnet::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    CHString        superScope;
    CHString        subnet;
	DHCP_IP_ADDRESS subnetAddress;

    // at this point, the key information should be provided by the pInstance
    if (!Instance.GetCHString(PROP_SScopeSubnets_SuperScope, superScope) || 
		!Instance.GetCHString(PROP_SScopeSubnets_Subnet, subnet) ||
		!inet_wstodw(subnet, subnetAddress)) 
        return (WBEM_E_FAILED);

    CDHCP_SuperScope_Parameters SuperScopeParams;
    LPDHCP_SUPER_SCOPE_TABLE        pTable;
    LPDHCP_SUPER_SCOPE_TABLE_ENTRY  *pSortedEntries;
    DWORD                           dwNumEntries;

    if (SuperScopeParams.GetSuperScopes(pTable, TRUE) &&
        SuperScopeParams.GetSortedScopes(ENTRIES_SORTED_ON_SUBNET, pSortedEntries, dwNumEntries))
    {
        for (int i = 0; pSortedEntries[i]->SubnetAddress <= subnetAddress && i < dwNumEntries; i++)
        {
            if (pSortedEntries[i]->SubnetAddress == subnetAddress &&
                SuperScopeParams.AlterSubnetSet(subnetAddress))
                return WBEM_S_NO_ERROR;
        }
    }
    
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_SuperScopeToSubnet::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_SuperScopeToSubnet::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\anetrng.cpp ===
/******************************************************************
   SNetScal.cpp -- WBEM provider class implementation

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains: the definition of the DHCP_Subnet class,
        the static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "props.h"
#include "snetfn.h"
#include "rngfn.h"
#include "srvfn.h"
#include "anetrng.h"

// the name of the WBEM class
#define PROVIDER_NAME_DHCP_ASSOC_SUBNETINCLRANGE       "DHCP_SubnetIncludedRange"
#define PROVIDER_NAME_DHCP_ASSOC_SUBNETEXCLRANGE       "DHCP_SubnetExcludedRange"

// Create here the two associations: Subnet<->IncludedRegion and Subnet<->ExcludedRegions
CDHCP_AssociationSubnetToRange MyDHCP_Assoc_SubnetInclRange(PROVIDER_NAME_DHCP_ASSOC_SUBNETINCLRANGE, PROVIDER_NAMESPACE_DHCP, DhcpIpRanges);
CDHCP_AssociationSubnetToRange MyDHCP_Assoc_SubnetExclRange(PROVIDER_NAME_DHCP_ASSOC_SUBNETEXCLRANGE, PROVIDER_NAMESPACE_DHCP, DhcpExcludedIpRanges);

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_AssociationSubnetToRange::CDHCP_AssociationSubnetToRange
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CDHCP_AssociationSubnetToRange::CDHCP_AssociationSubnetToRange (const CHString& strName, LPCSTR pszNameSpace, DWORD dwRangeType ) :
	Provider(strName, pszNameSpace)
{
    m_dwRangeType = dwRangeType;
}

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_AssociationSubnetToRange::~CDHCP_AssociationSubnetToRange
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CDHCP_AssociationSubnetToRange::~CDHCP_AssociationSubnetToRange ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToRange::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    Enumerates all this instances of this class. As there is only one
*                   DHCP Server per system, there is only one instance for this class
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToRange::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    CDHCP_Server_Parameters     srvParams;
    LPDHCP_MIB_INFO             pSrvMibInfo;
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (!srvParams.GetMibInfo(pSrvMibInfo, TRUE))
        return WBEM_E_FAILED;

    // loop through all the subnets configured on the local server
    for (int i = 0; hRes == WBEM_S_NO_ERROR && i < pSrvMibInfo->Scopes; i++)
    {
        DWORD                   dwSubnet;
        DHCP_RESUME_HANDLE      ResumeHandle;
        WCHAR                   wcsSubnetQuery[64]; // should be enough for holding 'xxx.yyy.zzz.uuu\0'

        dwSubnet = pSrvMibInfo->ScopeInfo[i].Subnet;

        CDHCP_Range_Parameters  rngParams(dwSubnet);

        // build the str representation of the Subnet address
        swprintf(wcsSubnetQuery,  L"DHCP_Subnet.Address=\"%u.%u.%u.%u\"",
                                        (dwSubnet & 0xff000000) >> 24,
                                        (dwSubnet & 0x00ff0000) >> 16,
                                        (dwSubnet & 0x0000ff00) >> 8,
                                        (dwSubnet & 0x000000ff));

        ResumeHandle = 0;

        do
        {
            DWORD errCode;

            // load the next buffer
            errCode = rngParams.NextSubnetRange(ResumeHandle, (DHCP_SUBNET_ELEMENT_TYPE)m_dwRangeType);

            // if ERROR_NO_MORE_ITEMS than no information was filled into m_pRangeInfoArray (which is null)
            if (errCode == ERROR_NO_MORE_ITEMS)
                break;

            // two alternatives here: ERROR_MORE_DATA (ResumeHandle != 0) and ERROR_SUCCESS (which case 
            // the API is setting ResumeHandle to NULL (hope so :o). In both cases, just go on.
            if (errCode != ERROR_MORE_DATA && errCode != ERROR_SUCCESS)
                return WBEM_E_FAILED;

            // for the current buffer, loop through all the ranges
            for (int j = 0; hRes == WBEM_S_NO_ERROR && j < rngParams.m_pRangeInfoArray->NumElements; j++)
            {
                // this is finally the info of the current range
                LPDHCP_IP_RANGE pRange = (m_dwRangeType == DhcpIpRanges)?
                                         (LPDHCP_IP_RANGE)(rngParams.m_pRangeInfoArray->Elements[j].Element.IpRange) : 
                                         (LPDHCP_IP_RANGE)(rngParams.m_pRangeInfoArray->Elements[j].Element.ExcludeIpRange);
                WCHAR           wcsRegionQuery[128]; // should be enough for holding the whole query
                DWORD           dwQueryIndex = 0;

                // we finally have everything we need for creating one more instance
                CInstance*  pInstance = CreateNewInstance(pMethodContext);

                //------------------add 'Subnet' reference to the instance--------------------
                if (pInstance == NULL ||
                    !pInstance->SetCHString(PROP_ANetRange_Subnet, wcsSubnetQuery))
                    return WBEM_E_FAILED;

                //..................copy 'EndAddress' to the Range reference..................
                // build the str representation of the EndAddress
                dwQueryIndex += swprintf(wcsRegionQuery + dwQueryIndex, L"DHCP_Range.EndAddress=\"%u.%u.%u.%u\"",
                                                    (pRange->EndAddress & 0xff000000) >> 24,
                                                    (pRange->EndAddress & 0x00ff0000) >> 16,
                                                    (pRange->EndAddress & 0x0000ff00) >> 8,
                                                    (pRange->EndAddress & 0x000000ff));


                //..................copy 'RangeType' to the Range reference...................
                dwQueryIndex += swprintf(wcsRegionQuery + dwQueryIndex, L",RangeType=%u", m_dwRangeType);

                //..................copy 'StartAddress' to the Range reference................
                // build the str representation of the StartAddress
                dwQueryIndex += swprintf(wcsRegionQuery + dwQueryIndex ,L",StartAddress=\"%u.%u.%u.%u\"",
                                                    (pRange->StartAddress & 0xff000000) >> 24,
                                                    (pRange->StartAddress & 0x00ff0000) >> 16,
                                                    (pRange->StartAddress & 0x0000ff00) >> 8,
                                                    (pRange->StartAddress & 0x000000ff));

                //..................copy 'Subnet' to the Range reference......................
                // build the str representation of the StartAddress
                dwQueryIndex += swprintf(wcsRegionQuery + dwQueryIndex ,L",Subnet=\"%u.%u.%u.%u\"",
                                                    (dwSubnet & 0xff000000) >> 24,
                                                    (dwSubnet & 0x00ff0000) >> 16,
                                                    (dwSubnet & 0x0000ff00) >> 8,
                                                    (dwSubnet & 0x000000ff));

                //------------------add the 'Range' reference to the instance------------------
                if (!pInstance->SetCHString(PROP_ANetRange_Range, wcsRegionQuery))
                    return WBEM_E_FAILED;


                //~~~~~~~~~~~~~~~~~ Commit the instance ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                hRes = Commit(pInstance);
            }

        } while (ResumeHandle != 0);    // bail if ResumeHandle got back to 0 (the end was reached)
    }

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToRange::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToRange::GetObject ( CInstance* pInstance, long lFlags )
{
	 return WBEM_S_NO_ERROR;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToRange::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToRange::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*****************************************************************************
*
*  FUNCTION    : CDHCP_AssociationSubnetToRange::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_PROVIDER_NOT_CAPABLE, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToRange::PutInstance ( const CInstance &Instance, long lFlags)
{
	 return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToRange::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_PROVIDER_NOT_CAPABLE from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from DHCP_Server_Scalars.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToRange::DeleteInstance ( const CInstance &Instance, long lFlags )
{
	 return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToRange::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToRange::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WBEM Framework Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include <stdafx.h>

HMODULE ghModule;
//============

WCHAR *GUIDSTRING = L"{C9839D99-2345-11d2-A334-00C04F86DB06}";
CLSID CLSID_DHCP_SERVER;

//Count number of objects and number of locks.

long       g_cLock=0;


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

	CLSIDFromString(GUIDSTRING, &CLSID_DHCP_SERVER);
    if (CLSID_DHCP_SERVER!=rclsid)
        return E_FAIL;

    pObj=new CWbemGlueFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL("DHCP_SERVER"))
	{
		sc = S_OK;
	}
	else
	{
		sc = S_FALSE;
	}
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "";
    char * pModel;
    HKEY hKey1, hKey2;



    // TO DO: Using 'Both' is preferable.  The framework is designed and written to support
    // free threaded code.  If you will be writing free-threaded code, uncomment these 
    // three lines.

//    if(Is4OrMore())
//        pModel = "Both";
//    else
        pModel = "Apartment";

    // Create the path.

	CLSIDFromString(GUIDSTRING, &CLSID_DHCP_SERVER);
    StringFromGUID2(CLSID_DHCP_SERVER, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

	CLSIDFromString(GUIDSTRING, &CLSID_DHCP_SERVER);
    StringFromGUID2(CLSID_DHCP_SERVER, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID\\"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

BOOL WINAPI DllMain (	HINSTANCE hInstDLL,	// handle to dll module
						DWORD fdwReason,	// reason for calling function
						LPVOID lpReserved	)	// reserved
{
    BOOL bRet = TRUE;
	
	// Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
            ghModule = hInstDLL;
            bRet = CWbemProviderGlue::FrameworkLoginDLL("DHCP_SERVER");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\lsfn.cpp ===
/******************************************************************
   LsFn.cpp -- Properties action functions (GET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the definition for the action functions associated to
        each manageable property from the class CDHCP_Lease

   REVISION:
        08/14/98 - created

******************************************************************/
#include <stdafx.h>

#include "LsScal.h"    // needed for DHCP_Lease_Property[] (for retrieving the property's name)
#include "LsFn.h"      // own header

/*****************************************************************
 *  The definition of the class CDHCP_Lease_Parameters
 *****************************************************************/
// by default, all the data structures are NULL (and dw variables are 0'ed)
// those values indicates that no data is cached from the server.

void CDHCP_Lease_Parameters::DeleteClientInfo(LPCLIENT_INFO& pClientInfo)
{
    if (pClientInfo != NULL)
    {
        if (pClientInfo->ClientName)
            DhcpRpcFreeMemory(pClientInfo->ClientName);
        if (pClientInfo->ClientComment != NULL)
            DhcpRpcFreeMemory(pClientInfo->ClientComment);
        if (pClientInfo->ClientHardwareAddress.Data != NULL)
            DhcpRpcFreeMemory(pClientInfo->ClientHardwareAddress.Data);
        if (pClientInfo->OwnerHost.NetBiosName != NULL)
            DhcpRpcFreeMemory(pClientInfo->OwnerHost.NetBiosName);
        if (pClientInfo->OwnerHost.HostName != NULL)
            DhcpRpcFreeMemory(pClientInfo->OwnerHost.HostName);
        DhcpRpcFreeMemory(pClientInfo);
    }
}

void CDHCP_Lease_Parameters::DeleteClientInfoArray(LPCLIENT_INFO_ARRAY& pClientInfoArray)
{
    if (pClientInfoArray)
    {
        if (pClientInfoArray->Clients)
        {
            while(pClientInfoArray->NumElements)
            {
                DeleteClientInfo(pClientInfoArray->Clients[--(pClientInfoArray->NumElements)]);
            }
            DhcpRpcFreeMemory(pClientInfoArray->Clients);
        }
        DhcpRpcFreeMemory(pClientInfoArray);
        pClientInfoArray = NULL;
    }
}

CDHCP_Lease_Parameters::CDHCP_Lease_Parameters(DHCP_IP_ADDRESS dwSubnetAddress, DHCP_IP_ADDRESS dwClientAddress)
{
    m_dwSubnetAddress  = dwSubnetAddress;
    m_dwClientAddress  = dwClientAddress;
    m_pClientInfoArray = NULL;
    m_pClientInfo      = NULL;
    m_pClientSetInfo   = NULL;
}

// the DHCP API calls are allocating memory for which the caller is responsible
// to release. We are releasing this memory upon the destruction of this object's instance.
CDHCP_Lease_Parameters::~CDHCP_Lease_Parameters()
{
    DeleteClientInfoArray(m_pClientInfoArray);
    DeleteClientInfo(m_pClientSetInfo);
    m_pClientInfo = NULL;
}

// DESCRIPTION:
//      Fills the internal cache with the information from the database, starting
//      from the given handle. If the end of the database is reached, the handle is
//      reset to 0. Returns TRUE on success (regardless there is more data to be read or not).
BOOL CDHCP_Lease_Parameters::NextSubnetClients(DHCP_RESUME_HANDLE ResumeHandle)
{
    DWORD   Error;
    DWORD   ClientsRead = 0;
    DWORD   ClientsTotal = 0;

    // each time the API gets called, the previous 
    // m_pClientInfoArray is useless and should be freed
    DeleteClientInfoArray(m_pClientInfoArray);

    m_pClientInfo = NULL;

    // calls the API.
#ifdef NT5
    Error = DhcpEnumSubnetClientsV5 (
#else if NT4
    Error = DhcpEnumSubnetClientsV4 (
#endif
        SERVER_IP_ADDRESS,
        m_dwSubnetAddress,
        &ResumeHandle,
        (DWORD)(-1),
        &m_pClientInfoArray,
        &ClientsRead,
        &ClientsTotal);

    if (Error == ERROR_SUCCESS)
        ResumeHandle = 0;

    return (Error == ERROR_SUCCESS || Error == ERROR_MORE_DATA);
}

BOOL CDHCP_Lease_Parameters::GetClientInfoFromCache(LPCLIENT_INFO& pClientInfo)
{
    if (m_pClientInfo != NULL &&
        m_pClientInfo->ClientIpAddress == m_dwClientAddress)
    {
        pClientInfo = m_pClientInfo;
        return TRUE;
    }
    if (m_pClientInfoArray != NULL)
    {
        for (int i=0; i<m_pClientInfoArray->NumElements; i++)
        {
            // match the internal client id with the info from cache
            if (m_pClientInfoArray->Clients[i]->ClientIpAddress == m_dwClientAddress)
            {
                // client found, return info on client, and TRUE.
                pClientInfo = m_pClientInfoArray->Clients[i];
                m_pClientInfo = pClientInfo;
                return TRUE;
            }
        }
    }
    return FALSE;
}

// DESCRIPTION:
//      Provides the data structure filled in through the DhcpGetClientInfo API
//      If this data is cached and the caller is not forcing the refresh,
//      return the internal cache. Otherwise, the internal cache is refreshed as well.
BOOL CDHCP_Lease_Parameters::GetClientInfo(LPCLIENT_INFO& pClientInfo, BOOL fRefresh)
{
    if (m_pClientInfoArray == NULL)
        fRefresh = TRUE;

    if (!fRefresh && 
        GetClientInfoFromCache(pClientInfo))
        return TRUE;

    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD i;

    // either the caller wants full refresh, or the client was not found into the cache
    // do full refresh.
    do
    {
        if (NextSubnetClients(ResumeHandle) &&
            GetClientInfoFromCache(pClientInfo) ) 
            return TRUE;
    } while (ResumeHandle != 0);

    return FALSE;
}

BOOL CDHCP_Lease_Parameters::CheckExistsSetInfoPtr()
{
    if (m_pClientSetInfo != NULL)
        return TRUE;

    m_pClientSetInfo = (LPCLIENT_INFO)MIDL_user_allocate(sizeof(CLIENT_INFO));

    if (m_pClientSetInfo == NULL)
        return FALSE;

    memset(m_pClientSetInfo, 0, sizeof(CLIENT_INFO));

    return TRUE;
}

// DESCRIPTION:
//      Sets to the server the information available for the client.
//      It assumes the info is already filled in. It only calls DhcpSetClientInfoV4()
//      and return TRUE on success and FALSE on failure
BOOL CDHCP_Lease_Parameters::CommitSet(DWORD & errCode)
{
    LPCLIENT_INFO   pClientInfo;

    if (m_pClientSetInfo == NULL ||
        !GetClientInfo(pClientInfo, FALSE))
    {
        errCode = ERROR_FILE_NOT_FOUND;
        return FALSE;
    }

    // copies all the info we have to set onto the cache location for the client
    // duplicate the hardware address
    dupDhcpBinaryData(m_pClientSetInfo->ClientHardwareAddress, pClientInfo->ClientHardwareAddress);

    // copy the name
    if (pClientInfo->ClientName)
        DhcpRpcFreeMemory(pClientInfo->ClientName);
    pClientInfo->ClientName = _wcsdup(m_pClientSetInfo->ClientName);

    // copy the comment
    if (pClientInfo->ClientComment)
        DhcpRpcFreeMemory(pClientInfo->ClientComment);
    pClientInfo->ClientComment = _wcsdup(m_pClientSetInfo->ClientComment);

    // copy the client type
    pClientInfo->bClientType = m_pClientSetInfo->bClientType;
        
    // DHCP_CLIENT_INFO_V5 is only a one field extension of DHCP_CLIENT_INFO_V4
    errCode = DhcpSetClientInfoV4(
                SERVER_IP_ADDRESS,
                (LPDHCP_CLIENT_INFO_V4)pClientInfo);

    return errCode == ERROR_SUCCESS;
}

// GET function for the (RO)"Subnet" property
MFN_PROPERTY_ACTION_DEFN(fnLsGetSubnet, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters *pLeaseParams;
    LPCLIENT_INFO           pClientInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;

    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;
    
    if (pLeaseParams->GetClientInfo(pClientInfo, FALSE) &&
        pClientInfo != NULL)
    {
        WCHAR wsSubnet[16]; // should be enough to hold an IP Addr (xxx.xxx.xxx.xxx\0 = 16)
        DWORD dwSubnet;

        dwSubnet = pClientInfo->ClientIpAddress & pClientInfo->SubnetMask;

        swprintf(wsSubnet, L"%u.%u.%u.%u",(dwSubnet & 0xff000000) >> 24,
                                          (dwSubnet & 0x00ff0000) >> 16,
                                          (dwSubnet & 0x0000ff00) >> 8,
                                          (dwSubnet & 0x000000ff));

        pOut->SetCHString(DHCP_Lease_Property[IDX_Ls_Subnet].m_wsPropName, wsSubnet);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

// GET function for the (RO)"Address" property
MFN_PROPERTY_ACTION_DEFN(fnLsGetAddress, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters *pLeaseParams;
    LPCLIENT_INFO           pClientInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;
    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;
    
    if (pLeaseParams->GetClientInfo(pClientInfo, FALSE) &&
        pClientInfo != NULL)
    {
        WCHAR wsAddress[16]; // should be enough to hold an IP Addr (xxx.xxx.xxx.xxx\0 = 16)

        swprintf(wsAddress, L"%u.%u.%u.%u",(pClientInfo->ClientIpAddress & 0xff000000) >> 24,
                                           (pClientInfo->ClientIpAddress & 0x00ff0000) >> 16,
                                           (pClientInfo->ClientIpAddress & 0x0000ff00) >> 8,
                                           (pClientInfo->ClientIpAddress & 0x000000ff));

        pOut->SetCHString(DHCP_Lease_Property[IDX_Ls_Address].m_wsPropName, wsAddress);

        return TRUE;
    }

    // the API call failed
    return FALSE;
}

// GET function for the (RO) "Mask" property
MFN_PROPERTY_ACTION_DEFN(fnLsGetMask, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters *pLeaseParams;
    LPCLIENT_INFO           pClientInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;
    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;
    
    if (pLeaseParams->GetClientInfo(pClientInfo, FALSE) &&
        pClientInfo != NULL)
    {
        WCHAR wsMask[16]; // should be enough to hold an IP Addr (xxx.xxx.xxx.xxx\0 = 16)

        swprintf(wsMask, L"%u.%u.%u.%u",(pClientInfo->SubnetMask & 0xff000000) >> 24,
                                        (pClientInfo->SubnetMask & 0x00ff0000) >> 16,
                                        (pClientInfo->SubnetMask & 0x0000ff00) >> 8,
                                        (pClientInfo->SubnetMask & 0x000000ff));

        pOut->SetCHString(DHCP_Lease_Property[IDX_Ls_SubnetMask].m_wsPropName, wsMask);

        return TRUE;
    }

    // the API call failed
    return FALSE;
}

// GET function for the (RW)"UniqueClientIdentifier" property
MFN_PROPERTY_ACTION_DEFN(fnLsGetHdwAddress, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters *pLeaseParams;
    LPCLIENT_INFO           pClientInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;
    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;
    
    if (pLeaseParams->GetClientInfo(pClientInfo, FALSE) &&
        pClientInfo != NULL)
    {
/*
// -- uncomment the code below if want to change the format of the hdw address (from array of 6 bytes to string)
// -- in this case, remove the 'return' lines below, and change the definition of the variable 
// -- DHCP_Lease::UniqueClientIdentifier to string.

        WCHAR wsHdwAddress[32]; // should be enough to hold the hardware address (xxyyzzuuvvww)

        for (int i = 0; i < pClientInfo->ClientHardwareAddress.DataLength && i < 16; i++)
        {
            swprintf(wsHdwAddress + 2*i, L"%02x", pClientInfo->ClientHardwareAddress.Data[i]);
        }

        pOut->SetCHString(DHCP_Lease_Property[IDX_Ls_UniqueClientIdentifier].m_wsPropName, wsHdwAddress);
        return TRUE;
*/
        return InstanceSetByteArray(
                pOut, 
                DHCP_Lease_Property[IDX_Ls_UniqueClientIdentifier].m_wsPropName,
                pClientInfo->ClientHardwareAddress.Data,
                pClientInfo->ClientHardwareAddress.DataLength );

    }

    // the API call failed
    return FALSE;
}

// SET function for the (RW)"UniqueClientIdentifier" property
MFN_PROPERTY_ACTION_DEFN(fnLsSetHdwAddress, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters  *pLeaseParams;

    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;

    // only some of the client info can be set (Name, Comment, HdwAddress, Type
    // therefore, the client has to be present into the cache. We will alter only (one of) the
    // parameters above.
    if (pLeaseParams == NULL || 
        !pLeaseParams->CheckExistsSetInfoPtr() ||
        pIn == NULL ||
        !InstanceGetByteArray(
                pIn, 
                DHCP_Lease_Property[IDX_Ls_UniqueClientIdentifier].m_wsPropName,
                pLeaseParams->m_pClientSetInfo->ClientHardwareAddress.Data,
                pLeaseParams->m_pClientSetInfo->ClientHardwareAddress.DataLength)
        )
        return FALSE;

    // if this is a request for 'instant apply', do it now
    if (pOut != NULL)
    {
        DWORD errCode;

        pLeaseParams->CommitSet(errCode);
        // fill back the code returned by the underlying level
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, errCode);
    }

    // the API call succeded
    return TRUE;
}

// GET function for the (RW)"Name" property
MFN_PROPERTY_ACTION_DEFN(fnLsGetName, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters *pLeaseParams;
    LPCLIENT_INFO           pClientInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;
    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;
    
    if (pLeaseParams->GetClientInfo(pClientInfo, FALSE) &&
        pClientInfo != NULL)
    {
        pOut->SetCHString(DHCP_Lease_Property[IDX_Ls_Name].m_wsPropName, 
                          pClientInfo->ClientName);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

// SET function for the (RW)"Name" property
MFN_PROPERTY_ACTION_DEFN(fnLsSetName, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters  *pLeaseParams;
    CHString                wsName;
    LPCLIENT_INFO           pClientInfo;

    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;

    // only some of the client info can be set (Name, Comment, HdwAddress, Type
    // therefore, the client has to be present into the cache. We will alter only (one of) the
    // parameters above.
    if (pLeaseParams == NULL || 
        !pLeaseParams->CheckExistsSetInfoPtr() ||
        pIn == NULL ||
        !pIn->GetCHString(DHCP_Lease_Property[IDX_Ls_Name].m_wsPropName, wsName))
        return FALSE;

    pClientInfo = pLeaseParams->m_pClientSetInfo;

    if (pClientInfo->ClientName != NULL)
		DhcpRpcFreeMemory(pClientInfo->ClientName);

    // allocate a new buffer able to hold this new name
    pClientInfo->ClientName = (WCHAR*)MIDL_user_allocate(sizeof(WCHAR)*wsName.GetLength()+sizeof(WCHAR));

    // make sure the allocation succeeded
    if (pClientInfo->ClientName == NULL)
        return FALSE;

    // copy the name to the new buffer
#ifdef _UNICODE
    wcscpy(pClientInfo->ClientName, wsName);
#else
    swprintf(pClientInfo->ClientName, L"%S", wsName);
#endif

    // if this is a request for 'instant apply', do it now
    if (pOut != NULL)
    {
        DWORD errCode;

        pLeaseParams->CommitSet(errCode);
        // fill back the code returned by the underlying level
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, errCode);
    }

    // the API call succeded
    return TRUE;
}

// GET function for the (RW)"Comment" property
MFN_PROPERTY_ACTION_DEFN(fnLsGetComment, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters *pLeaseParams;
    LPCLIENT_INFO           pClientInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;
    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;
    
    if (pLeaseParams->GetClientInfo(pClientInfo, FALSE) &&
        pClientInfo != NULL)
    {
        pOut->SetCHString(DHCP_Lease_Property[IDX_Ls_Comment].m_wsPropName, 
                          pClientInfo->ClientComment);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

// SET function for the (RW)"Comment" property
MFN_PROPERTY_ACTION_DEFN(fnLsSetComment, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters  *pLeaseParams;
    CHString                wsComment;
    LPCLIENT_INFO           pClientInfo;

    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;

    // only some of the client info can be set (Name, Comment, HdwAddress, Type
    // therefore, the client has to be present into the cache. We will alter only (one of) the
    // parameters above.
    if (pLeaseParams == NULL || 
        !pLeaseParams->CheckExistsSetInfoPtr() ||
        pIn == NULL ||
        !pIn->GetCHString(DHCP_Lease_Property[IDX_Ls_Comment].m_wsPropName, wsComment))
        return FALSE;

    pClientInfo = pLeaseParams->m_pClientSetInfo;

    if (pClientInfo->ClientComment != NULL)
		DhcpRpcFreeMemory(pClientInfo->ClientComment);

    // allocate a new buffer able to hold this new name
    pClientInfo->ClientComment = (WCHAR*)MIDL_user_allocate(sizeof(WCHAR)*wsComment.GetLength()+sizeof(WCHAR));

    // make sure the allocation succeeded
    if (pClientInfo->ClientComment == NULL)
        return FALSE;

    // copy the name to the new buffer
#ifdef _UNICODE
    wcscpy(pClientInfo->ClientComment, wsComment);
#else
    swprintf(pClientInfo->ClientComment, L"%S", wsComment);
#endif

    // if this is a request for 'instant apply', do it now
    if (pOut != NULL)
    {
        DWORD errCode;

        pLeaseParams->CommitSet(errCode);
        // fill back the code returned by the underlying level
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, errCode);
    }

    // the API call succeded
    return TRUE;
}

// GET function for the (RO)"LeaseExpiryDate" property
MFN_PROPERTY_ACTION_DEFN(fnLsGetExpiry, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters *pLeaseParams;
    LPCLIENT_INFO           pClientInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;
    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;
    
    if (pLeaseParams->GetClientInfo(pClientInfo, FALSE) &&
        pClientInfo != NULL)
    {
        SYSTEMTIME sysTime;
        wchar_t wchBuffer [32];

        // convert the server startup time to a string (UTC) representation.
	    _tzset () ;

        // timezone is offset from UTC in seconds, _daylight is 1 or 0 regarding the DST period
	    LONG  t_Offset = _timezone / 60 - _daylight * 60;
        char    chOffset = t_Offset < 0 ? '+' : '-';
        // take the absolute value from t_Offset
        LONG  t_absOffset = (1 - ((t_Offset < 0)<<1)) * t_Offset;

	    FileTimeToSystemTime((FILETIME *)&(pClientInfo->ClientLeaseExpires), &sysTime);

        // should ensure we have a valid date format (even if inf.)
        if (sysTime.wYear > 9999)
        {
            sysTime.wYear = 9999;
            sysTime.wMonth = 12;
            sysTime.wDay = 31;
            sysTime.wHour = 23;
            sysTime.wMinute = 59;
            sysTime.wSecond = 59;
            sysTime.wMilliseconds = 0;
        }

   		swprintf ( 
			wchBuffer , 
			L"%04ld%02ld%02ld%02ld%02ld%02ld.%06ld%c%03ld" ,
			sysTime.wYear,
			sysTime.wMonth,
			sysTime.wDay,
			sysTime.wHour,
			sysTime.wMinute,
			sysTime.wSecond,
			sysTime.wMilliseconds,
			chOffset,
            t_absOffset
		);

        // set the value of the property into the (CInstance*)pOut
        pOut->SetCHString(DHCP_Lease_Property[IDX_Ls_LeaseExpiryDate].m_wsPropName, wchBuffer);

        return TRUE;
    }

    // the API call failed
    return FALSE;
}

// GET function for the (RW)"Type" property
MFN_PROPERTY_ACTION_DEFN(fnLsGetType, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters *pLeaseParams;
    LPCLIENT_INFO           pClientInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;
    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;
    
    if (pLeaseParams->GetClientInfo(pClientInfo, FALSE) &&
        pClientInfo != NULL)
    {
        pOut->SetByte(DHCP_Lease_Property[IDX_Ls_Type].m_wsPropName, 
                      pClientInfo->bClientType);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

// SET function for the (RW)"Type" property
MFN_PROPERTY_ACTION_DEFN(fnLsSetType, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters  *pLeaseParams;
    BYTE                    bClientType;
    LPCLIENT_INFO           pClientInfo;

    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;

    // only some of the client info can be set (Name, Comment, HdwAddress, Type
    // therefore, the client has to be present into the cache. We will alter only (one of) the
    // parameters above.
    if (pLeaseParams == NULL || 
        !pLeaseParams->CheckExistsSetInfoPtr() ||
        pIn == NULL ||
        !pIn->GetByte(DHCP_Lease_Property[IDX_Ls_Type].m_wsPropName, bClientType))
        return FALSE;

    pClientInfo = pLeaseParams->m_pClientSetInfo;
    pClientInfo->bClientType = bClientType;

    // if this is a request for 'instant apply', do it now
    if (pOut != NULL)
    {
        DWORD errCode;

        pLeaseParams->CommitSet(errCode);
        // fill back the code returned by the underlying level
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, errCode);
    }

    // the API call succeded
    return TRUE;
}

#ifdef NT5
// GET function for the (RO)"State" property
MFN_PROPERTY_ACTION_DEFN(fnLsGetState, pParams, pIn, pOut)
{
    CDHCP_Lease_Parameters *pLeaseParams;
    LPCLIENT_INFO           pClientInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;
    pLeaseParams = (CDHCP_Lease_Parameters *)pParams;
    
    if (pLeaseParams->GetClientInfo(pClientInfo, FALSE) &&
        pClientInfo != NULL)
    {
        pOut->SetByte(DHCP_Lease_Property[IDX_Ls_State].m_wsPropName, 
                      pClientInfo->AddressState);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\anetlea.cpp ===
/******************************************************************
   SNetScal.cpp -- WBEM provider class implementation

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains: the definition of the DHCP_Subnet class,
        the static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "props.h"
#include "snetfn.h"
#include "lsfn.h"
#include "srvfn.h"
#include "anetlea.h"

// the name of the WBEM class
#define PROVIDER_NAME_DHCP_ASSOCIATIONSUBNETLEASE       "DHCP_SubnetLease"

// the properties' names
#define PROP_NAME_SUBNET                                L"Subnet"
#define PROP_NAME_LEASE                                 L"Lease"

// main class instantiation.
CDHCP_AssociationSubnetToLease MyDHCP_Association_Subnet_Lease (PROVIDER_NAME_DHCP_ASSOCIATIONSUBNETLEASE, PROVIDER_NAMESPACE_DHCP) ;

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_AssociationSubnetToLease::CDHCP_AssociationSubnetToLease
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CDHCP_AssociationSubnetToLease::CDHCP_AssociationSubnetToLease (const CHString& strName, LPCSTR pszNameSpace ) :
	Provider(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_AssociationSubnetToLease::~CDHCP_AssociationSubnetToLease
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CDHCP_AssociationSubnetToLease::~CDHCP_AssociationSubnetToLease ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToLease::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    Enumerates all this instances of this class. As there is only one
*                   DHCP Server per system, there is only one instance for this class
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToLease::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CDHCP_Server_Parameters     srvParams;
    LPDHCP_MIB_INFO             pSrvMibInfo;

    if (srvParams.GetMibInfo(pSrvMibInfo, TRUE))
    {
        // loop through all the subnets configured on the local server
        for (int i = 0; i < pSrvMibInfo->Scopes; i++)
        {
            DWORD                   dwSubnet;
            DHCP_RESUME_HANDLE      ResumeHandle;

            dwSubnet = pSrvMibInfo->ScopeInfo[i].Subnet;

            CDHCP_Lease_Parameters  lsParams(dwSubnet, 0);

            ResumeHandle = 0;

            // for each subnet, loop through all the client buffers belonging to it
            do
            {
                // load the next buffer
                if (!lsParams.NextSubnetClients(ResumeHandle))
                    return WBEM_E_FAILED;  // will fail here

                // for the current buffer, loop through all the clients
                for (int j = 0; hRes == WBEM_S_NO_ERROR && j < lsParams.m_pClientInfoArray->NumElements; j++)
                {
                    // this is finally the info of the current client
                    LPCLIENT_INFO   pClient = lsParams.m_pClientInfoArray->Clients[j];
                    WCHAR           wcsSubnet[256], wcsAddress[256]; // should be enough for holding 'xxx.yyy.zzz.uuu\0'

                    // build the str representation of the Subnet address
                    swprintf(wcsSubnet,  L"DHCP_Subnet.Address=\"%u.%u.%u.%u\"",(dwSubnet & 0xff000000) >> 24,
                                                        (dwSubnet & 0x00ff0000) >> 16,
                                                        (dwSubnet & 0x0000ff00) >> 8,
                                                        (dwSubnet & 0x000000ff));

                    // build the str representation of the ClientIpAddress address
                    swprintf(wcsAddress, L"DHCP_Lease.Subnet=\"%u.%u.%u.%u\",Address=\"%u.%u.%u.%u\"",

														(dwSubnet & 0xff000000) >> 24,
                                                        (dwSubnet & 0x00ff0000) >> 16,
                                                        (dwSubnet & 0x0000ff00) >> 8,
                                                        (dwSubnet & 0x000000ff) ,
														(pClient->ClientIpAddress & 0xff000000) >> 24,
                                                        (pClient->ClientIpAddress & 0x00ff0000) >> 16,
                                                        (pClient->ClientIpAddress & 0x0000ff00) >> 8,
                                                        (pClient->ClientIpAddress & 0x000000ff));

                    // we finally have everything we need for the creating one more instance
                    CInstance*  pInstance = CreateNewInstance(pMethodContext);

                    // initialize the instance with the key info and call LoadInstanceProperties for the rest of the info
                    if (pInstance->SetCHString(PROP_NAME_SUBNET, wcsSubnet) &&
                        pInstance->SetCHString(PROP_NAME_LEASE, wcsAddress))                      
                    {
                        hRes = Commit(pInstance);
                        // now everything relys on the err returned above.
                    }
                }

                // if there was an error above, bail
                if (hRes != WBEM_S_NO_ERROR)
                    return WBEM_E_FAILED;

            } while (ResumeHandle != 0);    // bail if ResumeHandle got back to 0 (the end was reached)
        }
    }

	return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToLease::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToLease::GetObject ( CInstance* pInstance, long lFlags )
{
    return LoadInstanceProperties(pInstance)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToLease::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToLease::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    : CDHCP_AssociationSubnetToLease::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_PROVIDER_NOT_CAPABLE, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToLease::PutInstance ( const CInstance &Instance, long lFlags)
{
	 return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToLease::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_PROVIDER_NOT_CAPABLE from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from DHCP_Server_Scalars.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToLease::DeleteInstance ( const CInstance &Instance, long lFlags )
{
	 return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToLease::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToLease::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}


/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToLease::LoadInstanceProperties
*
*  RETURNS     :	TRUE if the values for all the properties was loaded successfully,
*           FALSE otherwise.
*
*  COMMENTS    :    It loops through the Server_Property table, calling the GET functions.
*
*****************************************************************************/
BOOL CDHCP_AssociationSubnetToLease::LoadInstanceProperties(CInstance* pInstance)
{
	CHString        str;
    char            *pAddress;
    DHCP_IP_ADDRESS dwSubnet, dwAddress;

    // at this point, the key information should be provided by the pInstance
    if (!pInstance->GetCHString (PROP_NAME_SUBNET, str ) ||
        !inet_wstodw(str, dwSubnet) || 
        !pInstance->GetCHString ( PROP_NAME_LEASE, str) ||
        !(pAddress = strchr ( str.GetBuffer(0), ',' )) || 
        !inet_wstodw(pAddress, dwAddress))
        return FALSE;

	CDHCP_Subnet_Parameters subnetParams(dwSubnet) ;
    CDHCP_Lease_Parameters  leaseParams(dwSubnet, dwAddress);
    LPDHCP_SUBNET_INFO      pSubnetInfo;
	LPCLIENT_INFO           pClientInfo;

	return subnetParams.GetSubnetInfo(pSubnetInfo, TRUE) && leaseParams.GetClientInfo(pClientInfo, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\lsscal.cpp ===
/******************************************************************
   LsScal.cpp -- WBEM provider class implementation

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains: the definition of the DHCP_Lease class,
        the static table of manageable objects.

   REVISION:
        08/14/98 - created

******************************************************************/
#include <stdafx.h>

#include "LsFn.h"     // needed for the declarations of all the functions.
#include "LsScal.h"   // own header
#include "SrvFn.h"    // for server parameters
#include "ResFn.h"    // for checking if a lease is a reservation or not

// static table of CDHCP_Property objects containing the DHCP Lease
// scalar parameters (properties) which are WBEM manageable. Each object associates
// the name of the property with their SET and GET functions.
// *** NOTE ***
// The name of each property has to be in sync with the ones specified in the DhcpSchema.mof.
// The indices specified in LsScal.h should also be in sync with the actual row from this table (they are used
// in the property's action functions.
static const CDHCP_Property DHCP_Lease_Property[]=
{
 CDHCP_Property(L"Subnet",                  fnLsGetSubnet,      NULL),
 CDHCP_Property(L"Address",                 fnLsGetAddress,     NULL),
 CDHCP_Property(L"SubnetMask",              fnLsGetMask,        NULL),
 CDHCP_Property(L"UniqueClientIdentifier",  fnLsGetHdwAddress,  fnLsSetHdwAddress),
 CDHCP_Property(L"Name",                    fnLsGetName,        fnLsSetName),
 CDHCP_Property(L"Comment",                 fnLsGetComment,     fnLsSetComment),
 CDHCP_Property(L"LeaseExpiryDate",         fnLsGetExpiry,      NULL),
 CDHCP_Property(L"Type",                    fnLsGetType,        fnLsSetType),
#ifdef NT5
 CDHCP_Property(L"State",                   fnLsGetState,       NULL)
#endif
};

// the name of the WBEM class
#define PROVIDER_NAME_DHCP_LEASE    "DHCP_Lease"

// main class instantiation.
CDHCP_Lease MyDHCP_Lease_Scalars (PROVIDER_NAME_DHCP_LEASE, PROVIDER_NAMESPACE_DHCP) ;

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_Lease::CDHCP_Lease
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CDHCP_Lease::CDHCP_Lease (const CHString& strName, LPCSTR pszNameSpace ) :
	Provider(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_Lease::~CDHCP_Lease
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CDHCP_Lease::~CDHCP_Lease ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Lease::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    Enumerates all this instances of this class. Here we scan
*                   all the subnets, for which we get the info on all
*                   clients.
*****************************************************************************/
HRESULT CDHCP_Lease::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    CDHCP_Server_Parameters     srvParams;
    LPDHCP_MIB_INFO             pSrvMibInfo;

    if (srvParams.GetMibInfo(pSrvMibInfo, TRUE))
    {
        // loop through all the subnets configured on the local server
        for (int i = 0; i < pSrvMibInfo->Scopes; i++)
        {
            DWORD                   dwSubnet;
            DHCP_RESUME_HANDLE      ResumeHandle;

            dwSubnet = pSrvMibInfo->ScopeInfo[i].Subnet;

            CDHCP_Lease_Parameters  lsParams(dwSubnet, 0);

            ResumeHandle = 0;

            // for each subnet, loop through all the client buffers belonging to it
            do
            {
                HRESULT hRes = WBEM_S_NO_ERROR;

                // load the next buffer
                if (!lsParams.NextSubnetClients(ResumeHandle))
                    return WBEM_E_FAILED;  // will fail here

                // for the current buffer, loop through all the clients
                for (int j = 0; hRes == WBEM_S_NO_ERROR && j < lsParams.m_pClientInfoArray->NumElements; j++)
                {
                    // this is finally the info of the current client
#ifdef NT5
                    LPDHCP_CLIENT_INFO_V5   pClient = lsParams.m_pClientInfoArray->Clients[j];
#else if NT4
                    LPDHCP_CLIENT_INFO_V4   pClient = lsParams.m_pClientInfoArray->Clients[j];
#endif
                    WCHAR                   wcsSubnet[16], wcsAddress[16]; // should be enough for holding 'xxx.yyy.zzz.uuu\0'

                    // build the str representation of the Subnet address
                    swprintf(wcsSubnet,  L"%u.%u.%u.%u",(dwSubnet & 0xff000000) >> 24,
                                                        (dwSubnet & 0x00ff0000) >> 16,
                                                        (dwSubnet & 0x0000ff00) >> 8,
                                                        (dwSubnet & 0x000000ff));

                    // build the str representation of the ClientIpAddress address
                    swprintf(wcsAddress, L"%u.%u.%u.%u",(pClient->ClientIpAddress & 0xff000000) >> 24,
                                                        (pClient->ClientIpAddress & 0x00ff0000) >> 16,
                                                        (pClient->ClientIpAddress & 0x0000ff00) >> 8,
                                                        (pClient->ClientIpAddress & 0x000000ff));

                    // update the second key into the lsParams
                    lsParams.m_dwClientAddress = pClient->ClientIpAddress;

                    // we finally have everything we need for the creating one more instance
                    CInstance*  pInstance = CreateNewInstance(pMethodContext);

                    // initialize the instance with the key info and call LoadInstanceProperties for the rest of the info
                    if (pInstance->SetCHString(DHCP_Lease_Property[IDX_Ls_Subnet].m_wsPropName, wcsSubnet) &&
                        pInstance->SetCHString(DHCP_Lease_Property[IDX_Ls_Address].m_wsPropName, wcsAddress) &&
                        LoadInstanceProperties(pInstance))
                    {
                        hRes = Commit(pInstance);
                        // now everything relys on the err returned above.
                    }
                }

                // if there was an error above, bail
                if (hRes != WBEM_S_NO_ERROR)
                    return WBEM_E_FAILED;

            } while (ResumeHandle != 0);    // bail if ResumeHandle got back to 0 (the end was reached)
        }
    }

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Lease::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CDHCP_Lease::GetObject ( CInstance* pInstance, long lFlags )
{
    return LoadInstanceProperties(pInstance)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Lease::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CDHCP_Lease::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    : CDHCP_Lease::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_PROVIDER_NOT_CAPABLE, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Lease::PutInstance ( const CInstance &Instance, long lFlags)
{
    CHString        str;
    DHCP_IP_ADDRESS dwSubnet, dwAddress;
    DWORD           errCode;

    // at this point, the key information should be provided by the pInstance
    if (!Instance.GetCHString(DHCP_Lease_Property[IDX_Ls_Subnet].m_wsPropName, str) ||
        !inet_wstodw(str, dwSubnet) ||
        !Instance.GetCHString(DHCP_Lease_Property[IDX_Ls_Address].m_wsPropName, str) ||
        !inet_wstodw(str, dwAddress)
       )
        return WBEM_E_FAILED;

    CDHCP_Lease_Parameters leaseParams(dwSubnet, dwAddress);

    return LoadLeaseParams(&leaseParams, (CInstance *)&Instance) &&
           leaseParams.CommitSet(errCode) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Lease::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_PROVIDER_NOT_CAPABLE from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from DHCP_Server_Scalars.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Lease::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Lease::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Lease::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Lease::LoadInstanceProperties
*
*  RETURNS     :	TRUE if the values for all the properties was loaded successfully,
*           FALSE otherwise.
*
*  COMMENTS    :    wrapper for LoadInstanceProperties.
*
*****************************************************************************/
BOOL CDHCP_Lease::LoadInstanceProperties(CInstance* pInstance)
{
    DWORD dwSubnet, dwAddress;

    return LoadInstanceProperties(pInstance, dwSubnet, dwAddress);
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Lease::LoadInstanceProperties
*
*  RETURNS     :	TRUE if the values for all the properties was loaded successfully,
*           FALSE otherwise.
*
*  COMMENTS    :    It loops through the Lease_Property table, calling the GET functions.
*                   The pInstance parameter must have at this point all the key information
*                   (Subnet and Address in this case)
*
*****************************************************************************/
BOOL CDHCP_Lease::LoadInstanceProperties(CInstance* pInstance, DWORD &dwSubnet, DWORD &dwAddress)
{
    CHString        str;

    // at this point, the key information should be provided by the pInstance
    if (!pInstance->GetCHString(DHCP_Lease_Property[IDX_Ls_Subnet].m_wsPropName, str) ||
        !inet_wstodw(str, dwSubnet) ||
        !pInstance->GetCHString(DHCP_Lease_Property[IDX_Ls_Address].m_wsPropName, str) ||
        !inet_wstodw(str, dwAddress))
        return FALSE;

    CDHCP_Lease_Parameters  leaseParams(dwSubnet, dwAddress);

    for (int i = 0; i < NUM_LEASE_PROPERTIES; i++)
    {
        // if there is an invisible property (does not support GET) just skip it.
        if (DHCP_Lease_Property[i].m_pfnActionGet == NULL)
            continue;

        // call the appropriate GET function, fail if the call fails (there should be no reason for failure)
        if (!(*(DHCP_Lease_Property[i].m_pfnActionGet))(&leaseParams, NULL, pInstance))
            return FALSE;
    }
    return TRUE;
}


// Loader function for the lease parameters;
BOOL CDHCP_Lease::LoadLeaseParams(CDHCP_Lease_Parameters *pLeaseParams, CInstance *pInstance)
{
    for (int i = 0; i < NUM_LEASE_PROPERTIES; i++)
    {
        // if there is an invisible property (does not support SET) just skip it.
        if (DHCP_Lease_Property[i].m_pfnActionSet == NULL)
            continue;

        // call the appropriate SET function, fail if the call fails (there should be no reason for failure)
        if (!(*(DHCP_Lease_Property[i].m_pfnActionSet))(pLeaseParams, pInstance, NULL))
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\props.cpp ===
/******************************************************************
   SrvProp.cpp -- Properties class definition

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the definition of the class modeling the DHCP_Server property.


   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "Props.h"

/*------------------------Utility functions below------------------------------*/
// DESCRIPTION:
//      Converts a CHString containing the string representation of an IPAddress to the DHCP_IP_ADDRESS type.
//      I would have used here inet_addr but this one only takes char * as arguments (not wchar_t *)
//      Note that the IPAddress can be any substring of 'str'!
BOOL inet_wstodw(CHString str, DHCP_IP_ADDRESS & IpAddress)
{
    DWORD   value;
    int     i;

    for (i = 0; i < str.GetLength(); i++)
        if (str[i] >= _T('0') && str[i] <= _T('9'))
            break;

    IpAddress = 0;
    for (int k = 0; i < str.GetLength(); k++)
    {
        value = 0;

        // at this point, str[i] is definitely a decimal digit
        do
        {
            value *= 10;
            value += str[i++] - _T('0');
        } while(str[i] >= _T('0') && str[i] <= _T('9'));

        if (str[i] == _T('.'))
        {
            IpAddress <<= 8;
            IpAddress |= (value & 0xff);
            i++;
            if (str[i] >= _T('0') && str[i] <= _T('9'))
                continue;
        }
        if (k != 3)
            return FALSE;
        else
            break;
    }

    IpAddress <<= 8;
    IpAddress |= (value & 0xff);
    return TRUE;
}

BOOL dupDhcpBinaryData(DHCP_BINARY_DATA &src, DHCP_BINARY_DATA &dest)
{
    dest.DataLength = src.DataLength;
    if (dest.DataLength == NULL)
        return TRUE;
    if (src.Data == NULL)
        return FALSE;
    dest.Data = (BYTE*)MIDL_user_allocate(dest.DataLength);
    if (!dest.Data) 
        return FALSE;
    memcpy(dest.Data, src.Data, dest.DataLength);
    return TRUE;
}

BOOL InstanceSetByteArray(CInstance *pInstance,  const CHString& strProperty, BYTE *bArray, DWORD dwSzArray)
{
    SAFEARRAY       *saVariable;
    SAFEARRAYBOUND  saVector;
    HRESULT         retCode = WBEM_E_FAILED;

    if (pInstance == NULL)
        return FALSE;

    // first create the SAFEARRAY to pass to the pInstance
    saVector.cElements = dwSzArray;                     // on the only dimension we have, there are dwSzArray elements
    saVector.lLbound   = 0;                             // the lowest index of the dimension is 0
    saVariable = SafeArrayCreate(VT_UI1, 1, &saVector); // create a unsigned char array on one dimension
    if (saVariable != NULL)                             // continue if creation succeeded
    {
        // transfer the binary array to the SAFEARRAY
        for (long i = 0; i<dwSzArray; i++)
        {
            if (SafeArrayPutElement(saVariable, &i, bArray + i) != S_OK)
                break;
        }

        if (i == dwSzArray)                         // if the SAFEARRAY was built successfully continue
        {
            // build the Variant that holds the SAFEARRAY
	        VARIANT Variant;
            Variant.vt = VT_UI1 | VT_ARRAY;
            Variant.parray = saVariable;

            // build the BSTR holding the property name
            BSTR bstrProp = strProperty.AllocSysString();

            if (bstrProp != NULL)                   // if the property was converted to BSTR successfully go on..
            {
                IWbemClassObject *wbemClassObject = pInstance->GetClassObjectInterface();

                if (wbemClassObject != NULL)        // everything went fine, now just put the value
                    retCode = wbemClassObject->Put(bstrProp, 0, &Variant, 0);

                SysFreeString ( bstrProp );
	        }
        }

        SafeArrayDestroy(saVariable);
    }
    return retCode == WBEM_S_NO_ERROR;
}

BOOL InstanceGetByteArray(CInstance *pInstance,  const CHString& name, BYTE *&bArray, DWORD &dwSzArray)
{
    SAFEARRAY       *saVariable;
    SAFEARRAYBOUND  saVector;
    BOOL bRet = FALSE ;

    if (pInstance == NULL)
        return FALSE;

	IWbemClassObject *wbemClassObject = pInstance->GetClassObjectInterface();
	if ( wbemClassObject )
	{
		VARIANT v;
		VariantInit(&v);

		BSTR pName = name.AllocSysString();
		HRESULT hr = wbemClassObject->Get(pName, 0, &v, NULL, NULL);
		SysFreeString(pName);
		
		if ( ( v.vt != VT_NULL) && (v.vt != (VT_UI1|VT_ARRAY)))
		{
			VariantClear(&v);
			return FALSE ;
		}

		if (bRet = SUCCEEDED(hr))
		{
			if ( v.vt != VT_NULL && v.parray != NULL )
			{
				SAFEARRAY *t_SafeArray = v.parray ;
				if ( SafeArrayGetDim ( t_SafeArray ) == 1 )
				{
					LONG t_Dimension = 1 ;
					LONG t_LowerBound ;
					SafeArrayGetLBound ( t_SafeArray , t_Dimension , & t_LowerBound ) ;
					LONG t_UpperBound ;
					SafeArrayGetUBound ( t_SafeArray , t_Dimension , & t_UpperBound ) ;

					dwSzArray = t_UpperBound - t_LowerBound + 1 ;
					bArray = (BYTE*)MIDL_user_allocate(dwSzArray * sizeof(BYTE));

					for ( LONG t_Index = t_LowerBound ; t_Index <= t_UpperBound ; t_Index ++ )
					{
						BYTE t_Element ;
						SafeArrayGetElement ( t_SafeArray , &t_Index , & t_Element ) ;

						bArray [ t_Index ] = t_Element ;
					}

					bRet = TRUE ;
				}
			}
		}

		VariantClear(&v);
	}

	return bRet ;
}

/*-----------------------CDHCP_Property class definition---------------------------------*/
// constructor. An instance of this class has to be defined by the parameters below:
CDHCP_Property::CDHCP_Property(
    const WCHAR *wsPropName,                        // the name of the property
    const PFN_PROPERTY_ACTION pfnActionGet,         // the pointer to its GET function
    const PFN_PROPERTY_ACTION pfnActionSet)         // the pointer to its SET function
{
    m_pfnActionGet = pfnActionGet;
    m_pfnActionSet = pfnActionSet;

    if (wsPropName != NULL)
    {
        m_wsPropName = new WCHAR[wcslen(wsPropName) + 1];   // the name is copied into a local member variable
        wcscpy(m_wsPropName, wsPropName);                   // released upon destruction
    }
    else
        m_wsPropName = NULL;
}

CDHCP_Property::~CDHCP_Property()
{
    if (m_wsPropName != NULL)
        delete m_wsPropName;        // release the memory allocated for the property name
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\anetres.cpp ===
/******************************************************************
   SNetScal.cpp -- WBEM provider class implementation

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains: the definition of the DHCP_Subnet class,
        the static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "props.h"
#include "snetfn.h"
#include "resfn.h"
#include "srvfn.h"
#include "anetres.h"

// the name of the WBEM class
#define PROVIDER_NAME_DHCP_ASSOCIATIONSUBNETRESERVATION       "DHCP_SubnetReservation"

// the names of the properties
#define PROP_NAME_SUBNET        L"Subnet"
#define PROP_NAME_RESERVATION   L"Reservation"

// main class instantiation.
CDHCP_AssociationSubnetToReservation MyDHCP_Association_Subnet_Reservation (PROVIDER_NAME_DHCP_ASSOCIATIONSUBNETRESERVATION, PROVIDER_NAMESPACE_DHCP) ;

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_AssociationSubnetToReservation::CDHCP_AssociationSubnetToReservation
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CDHCP_AssociationSubnetToReservation::CDHCP_AssociationSubnetToReservation (const CHString& strName, LPCSTR pszNameSpace ) :
	Provider(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_AssociationSubnetToReservation::~CDHCP_AssociationSubnetToReservation
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CDHCP_AssociationSubnetToReservation::~CDHCP_AssociationSubnetToReservation ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToReservation::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    Enumerates all this instances of this class. As there is only one
*                   DHCP Server per system, there is only one instance for this class
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToReservation::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    CDHCP_Server_Parameters     srvParams;
    LPDHCP_MIB_INFO             pSrvMibInfo;

    if (srvParams.GetMibInfo(pSrvMibInfo, TRUE))
    {
        // loop through all the subnets configured on the local server
        for (int i = 0; i < pSrvMibInfo->Scopes; i++)
        {
            DWORD                   dwSubnet;
            DHCP_RESUME_HANDLE      ResumeHandle;

            dwSubnet = pSrvMibInfo->ScopeInfo[i].Subnet;

            CDHCP_Reservation_Parameters  resParams(dwSubnet, 0);

            ResumeHandle = 0;

            // for each subnet, loop through all the client buffers belonging to it
            do
            {
                HRESULT hRes = WBEM_S_NO_ERROR;

                // load the next buffer
				LONG t_Res = resParams.NextSubnetReservation(ResumeHandle) ;
                if ( t_Res < 0 )
                    return WBEM_E_FAILED;  // will fail here
				if ( t_Res == 0 )
					return WBEM_S_NO_ERROR ;

                // for the current buffer, loop through all the clients
                for (int j = 0; hRes == WBEM_S_NO_ERROR && j < resParams.m_pReservationInfoArray->NumElements; j++)
                {
                    // this is finally the info of the current client
                    LPDHCP_IP_RESERVATION_V4   pReservation = RESERVATION_CAST(resParams.m_pReservationInfoArray->Elements[j].Element.ReservedIp);
                    WCHAR                      wcsSubnet[256], wcsAddress[256]; // should be enough for holding 'xxx.yyy.zzz.uuu\0'

                    // build the str representation of the Subnet address
                    swprintf(wcsSubnet,  L"DHCP_Subnet.Address=\"%u.%u.%u.%u\"",
                                                        (dwSubnet & 0xff000000) >> 24,
                                                        (dwSubnet & 0x00ff0000) >> 16,
                                                        (dwSubnet & 0x0000ff00) >> 8,
                                                        (dwSubnet & 0x000000ff));

                    // build the str representation of the ClientIpAddress address
                    swprintf(wcsAddress, L"DHCP_Reservation.Subnet=\"%u.%u.%u.%u\",Address=\"%u.%u.%u.%u\"",
														(dwSubnet & 0xff000000) >> 24,
                                                        (dwSubnet & 0x00ff0000) >> 16,
                                                        (dwSubnet & 0x0000ff00) >> 8,
                                                        (dwSubnet & 0x000000ff) ,
														(pReservation->ReservedIpAddress & 0xff000000) >> 24,
                                                        (pReservation->ReservedIpAddress & 0x00ff0000) >> 16,
                                                        (pReservation->ReservedIpAddress & 0x0000ff00) >> 8,
                                                        (pReservation->ReservedIpAddress & 0x000000ff));

                    // we finally have everything we need for the creating one more instance
                    CInstance*  pInstance = CreateNewInstance(pMethodContext);

                    // initialize the instance with the key info and call LoadInstanceProperties for the rest of the info
                    if (pInstance->SetCHString(PROP_NAME_SUBNET, wcsSubnet) &&
                        pInstance->SetCHString(PROP_NAME_RESERVATION, wcsAddress))                      
                    {
                        hRes = Commit(pInstance);
                        // now everything relys on the err returned above.
                    }
                }

                // if there was an error above, bail
                if (hRes != WBEM_S_NO_ERROR)
                    return WBEM_E_FAILED;

            } while (ResumeHandle != 0);    // bail if ResumeHandle got back to 0 (the end was reached)
        }
    }

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToReservation::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToReservation::GetObject ( CInstance* pInstance, long lFlags )
{
    return LoadInstanceProperties(pInstance)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToReservation::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToReservation::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    : CDHCP_AssociationSubnetToReservation::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_PROVIDER_NOT_CAPABLE, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToReservation::PutInstance ( const CInstance &Instance, long lFlags)
{
	 return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToReservation::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_PROVIDER_NOT_CAPABLE from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from DHCP_Server_Scalars.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToReservation::DeleteInstance ( const CInstance &Instance, long lFlags )
{
	 return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToReservation::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_AssociationSubnetToReservation::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}


/*****************************************************************************
*
*  FUNCTION    :	CDHCP_AssociationSubnetToReservation::LoadInstanceProperties
*
*  RETURNS     :	TRUE if the values for all the properties was loaded successfully,
*           FALSE otherwise.
*
*  COMMENTS    :    It loops through the Server_Property table, calling the GET functions.
*
*****************************************************************************/
BOOL CDHCP_AssociationSubnetToReservation::LoadInstanceProperties(CInstance* pInstance)
{
	CHString        str;
    char            *pAddress;
    DHCP_IP_ADDRESS dwSubnet, dwAddress;

    // at this point, the key information should be provided by the pInstance
    if (!pInstance->GetCHString (PROP_NAME_SUBNET, str ) ||
        !inet_wstodw(str, dwSubnet) || 
        !pInstance->GetCHString ( PROP_NAME_RESERVATION, str) ||
        !(pAddress = strchr ( str.GetBuffer(0), ',' )) || 
        !inet_wstodw(pAddress, dwAddress))
        return FALSE;

	CDHCP_Subnet_Parameters         subnetParams(dwSubnet) ;
    CDHCP_Reservation_Parameters    reservationParams(dwSubnet, dwAddress);
    LPDHCP_SUBNET_INFO              pSubnetInfo;
	LPDHCP_IP_RESERVATION_V4        pReservationInfo;

	return subnetParams.GetSubnetInfo(pSubnetInfo, TRUE) && reservationParams.GetReservationInfo(pReservationInfo, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\snetfn.cpp ===
/******************************************************************
   SNetFn.cpp -- Properties action functions (GET/SET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the definition for the action functions associated to
        each manageable property from the class CDHCP_Server

   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "SNetScal.h"    // needed for DHCP_Subnet_Property[] (for retrieving the property's name, for SET's)
#include "SNetFn.h"      // own header

/*****************************************************************
 *  The definition of the class CDHCP_Subnet_Parameters
 *****************************************************************/
// by default, all the data structures are NULL (and dw variables are 0'ed)
// those values indicates that no data is cached from the server.
CDHCP_Subnet_Parameters::CDHCP_Subnet_Parameters(DHCP_IP_ADDRESS dwSubnetAddress)
{
    m_dwSubnetAddress = dwSubnetAddress;
    m_pMibInfo        = NULL;
    m_pScopeMibInfo   = NULL;
	m_pSubnetInfo     = NULL;
}

CDHCP_Subnet_Parameters::CDHCP_Subnet_Parameters(DHCP_IP_ADDRESS dwSubnetAddress, DHCP_IP_ADDRESS dwSubnetMask)
{
    m_dwSubnetAddress = dwSubnetAddress;
    m_pMibInfo        = NULL;
    m_pScopeMibInfo   = NULL;
	m_pSubnetInfo     = NULL;

    CheckExistsInfoPtr();
    if (m_pSubnetInfo != NULL)
        m_pSubnetInfo->SubnetMask = dwSubnetMask;
}

// the DHCP API calls are allocating memory for which the caller is responsible
// to release. We are releasing this memory upon the destruction of this object's instance.
CDHCP_Subnet_Parameters::~CDHCP_Subnet_Parameters()
{
    if (m_pMibInfo != NULL)
    {
        if (m_pMibInfo->ScopeInfo != NULL)
            DhcpRpcFreeMemory(m_pMibInfo->ScopeInfo);

        DhcpRpcFreeMemory(m_pMibInfo);
    }

    // LPDHCP_CONFIG_INFO_V4 contains pointers to memory allocated by the DHCP server and
    // which should be released by the caller.
    if (m_pSubnetInfo!= NULL)
	{
		if (m_pSubnetInfo->SubnetName != NULL)
			DhcpRpcFreeMemory(m_pSubnetInfo->SubnetName);

		if (m_pSubnetInfo->SubnetComment != NULL)
			DhcpRpcFreeMemory(m_pSubnetInfo->SubnetComment);

		DhcpRpcFreeMemory(m_pSubnetInfo);
	}

}

// DESCRIPTION:
//      Checks the m_pConfigInfoV4 pointer to insure it points to a valid buffer.
//      It allocates the DHCP_SUBNET_INFO if needed.
BOOL CDHCP_Subnet_Parameters::CheckExistsInfoPtr()
{
    if (m_pSubnetInfo != NULL)
        return TRUE;
    
    m_pSubnetInfo = (LPDHCP_SUBNET_INFO)MIDL_user_allocate(sizeof(DHCP_SUBNET_INFO));

    if (m_pSubnetInfo != NULL)
    {
        m_pSubnetInfo->SubnetAddress = m_dwSubnetAddress;
        return TRUE;
    }
    return FALSE;
}

// DESCRIPTION:
//      Provides the data structure filled in through the DhcpGetMibInfo API
//      If this data is cached and the caller is not forcing the refresh,
//      returns the internal cache.
BOOL CDHCP_Subnet_Parameters::GetMibInfo(LPDHCP_MIB_INFO& pMibInfo, LPSCOPE_MIB_INFO& pScopeMibInfo, BOOL fRefresh)
{
    if (m_pMibInfo == NULL)
        fRefresh = TRUE;

    if (fRefresh)
    {
        pMibInfo = NULL;

        if (DhcpGetMibInfo(SERVER_IP_ADDRESS, &pMibInfo) != ERROR_SUCCESS)
            return FALSE;

        if (m_pMibInfo != NULL)
            DhcpRpcFreeMemory(m_pMibInfo);

        m_pMibInfo = pMibInfo;

        pScopeMibInfo = NULL;
        for (int i=0; i<pMibInfo->Scopes; i++)
        {
            LPSCOPE_MIB_INFO pLocal = &pMibInfo->ScopeInfo[i];

            if (pLocal != NULL && pLocal->Subnet == m_dwSubnetAddress)
            {
                pScopeMibInfo = pLocal;
                break;
            }
        }

        m_pScopeMibInfo = pScopeMibInfo;
    }
    else
    {
        pMibInfo = m_pMibInfo;
        pScopeMibInfo = m_pScopeMibInfo;
    }

    return TRUE;
}

// DESCRIPTION:
//      Provides the data structure filled in through the DhcpSubnetInfo API
//      If this data is cached and the caller is not forcing the refresh,
//      return the internal cache. Otherwise, the internal cache is refreshed as well.
BOOL CDHCP_Subnet_Parameters::GetSubnetInfo(LPDHCP_SUBNET_INFO& pSubnetInfo, BOOL fRefresh)
{
    if (m_pSubnetInfo == NULL)
        fRefresh = TRUE;

    if (fRefresh)
    {
        pSubnetInfo = NULL;

        if (DhcpGetSubnetInfo(SERVER_IP_ADDRESS, m_dwSubnetAddress, &pSubnetInfo) != ERROR_SUCCESS)
            return FALSE;

        if (m_pSubnetInfo != NULL)
            DhcpRpcFreeMemory(m_pSubnetInfo);
        m_pSubnetInfo = pSubnetInfo;
    }
    else
        pSubnetInfo = m_pSubnetInfo;

    return TRUE;
}

// DESCRIPTION:
//      Creates a new subnet.
//      Assumes that all the fields from the DHCP_SUBNET_INFO structure are valid, and filled with
//      the data to be set. Calls the underlying API and returns TRUE (on success) or FALSE (on failure)
BOOL CDHCP_Subnet_Parameters::CommitNew(DWORD &returnCode)
{
    if (m_pSubnetInfo == NULL)
        return FALSE;

    returnCode = DhcpCreateSubnet(
                SERVER_IP_ADDRESS,
                m_pSubnetInfo->SubnetAddress,
                m_pSubnetInfo );

    return returnCode == ERROR_SUCCESS;
}

// DESCRIPTION:
//      Modifies info on an existing subnet.
//      Assumes that all the fields from the DHCP_SUBNET_INFO structure are valid, and filled with
//      the data to be set. Calls the underlying API and returns TRUE (on success) or FALSE (on failure)
BOOL CDHCP_Subnet_Parameters::CommitSet(DWORD &returnCode)
{
    if (m_pSubnetInfo == NULL)
        return FALSE;

    returnCode = DhcpSetSubnetInfo(
                SERVER_IP_ADDRESS,
                m_pSubnetInfo->SubnetAddress,
                m_pSubnetInfo );

    return returnCode == ERROR_SUCCESS;
}

// DESCRIPTION:
//      Assumes the m_dwSubnet is initialized, case in which it calls the DHCPAPI to delete that subnet
//      from the server.
BOOL CDHCP_Subnet_Parameters::DeleteSubnet()
{
    if (DhcpDeleteSubnet(SERVER_IP_ADDRESS, m_dwSubnetAddress, DhcpFullForce) == ERROR_SUCCESS)
    {
        m_dwSubnetAddress = 0;
        // don't look below :o)
        // It's only an exotic way of calling the destructor without destroying the object itself
        this->~CDHCP_Subnet_Parameters();
        m_pSubnetInfo = NULL;
        m_pScopeMibInfo = NULL;
        m_pMibInfo = NULL;
        return TRUE;
    }
    return FALSE;
}

/*------------------------Property Action Functions below-----------------------*/
// unlike for SrvScal, we expect the pParams to be not-null, or otherwise this call fails.
// we do this because pParams is the one holding the subnet address which must be known 
// in order to call the DHCP api (it has to be filled in by the caller).
// This applies to all 'GET' functions.
MFN_PROPERTY_ACTION_DEFN(fnSNetGetAddress, pParams, pIn, pOut)
{
    BOOL                    fRefresh;
    CDHCP_Subnet_Parameters *pSubnetParams;
    LPDHCP_SUBNET_INFO      pSubnetInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;

    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    fRefresh = pSubnetParams->m_pSubnetInfo == NULL;
    
    if (pSubnetParams->GetSubnetInfo(pSubnetInfo, fRefresh) &&
        pSubnetInfo != NULL)
    {
        // nothing special to do here, the property (Address) should be just there!
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSNetGetMask, pParams, pIn, pOut)
{
    BOOL                    fRefresh;
    CDHCP_Subnet_Parameters *pSubnetParams;
    LPDHCP_SUBNET_INFO      pSubnetInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;

    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    fRefresh = pSubnetParams->m_pSubnetInfo == NULL;
    
    if (pSubnetParams->GetSubnetInfo(pSubnetInfo, fRefresh) &&
        pSubnetInfo != NULL)
    {
        WCHAR szMask[16]; // should be enough for holding 'xxx.yyy.zzz.uuu\0'

        swprintf(szMask, L"%u.%u.%u.%u",(pSubnetInfo->SubnetMask & 0xff000000) >> 24,
                                        (pSubnetInfo->SubnetMask & 0x00ff0000) >> 16,
                                        (pSubnetInfo->SubnetMask & 0x0000ff00) >> 8,
                                        (pSubnetInfo->SubnetMask & 0x000000ff));

        pOut->SetCHString(DHCP_Subnet_Property[IDX_SNET_Mask].m_wsPropName, szMask);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSNetGetName, pParams, pIn, pOut)
{
    BOOL                    fRefresh;
    CDHCP_Subnet_Parameters *pSubnetParams;
    LPDHCP_SUBNET_INFO      pSubnetInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;

    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    fRefresh = pSubnetParams->m_pSubnetInfo == NULL;
    
    if (pSubnetParams->GetSubnetInfo(pSubnetInfo, fRefresh) &&
        pSubnetInfo != NULL)
    {
        pOut->SetCHString(DHCP_Subnet_Property[IDX_SNET_Name].m_wsPropName, pSubnetInfo->SubnetName);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

// Set functions require the SubnetAddress which can be taken only from pParams.
// The changes are applied instantly only if pOut is not NULL (so the caller wants and
// gets a return code)
MFN_PROPERTY_ACTION_DEFN(fnSNetSetName, pParams, pIn, pOut)
{
    CDHCP_Subnet_Parameters *pSubnetParams;
    CHString                wsName;

    // pParams and pIn have to be valid to provide the SubnetAddress and the Name to set
    if (pParams == NULL || pIn == NULL)
        return FALSE;

    // get the CDHCP_Subnet_Parameters out of pParams
    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    // make sure there is a buffer for holding all this info.
    pSubnetParams->CheckExistsInfoPtr();

    // get the value to set from the pIn parameter
    if (!pIn->GetCHString(DHCP_Subnet_Property[IDX_SNET_Name].m_wsPropName, wsName))
        return FALSE;

    // release any old buffer
    if (pSubnetParams->m_pSubnetInfo->SubnetName != NULL)
		DhcpRpcFreeMemory(pSubnetParams->m_pSubnetInfo->SubnetName);

    // allocate a new buffer able to hold this new name
    pSubnetParams->m_pSubnetInfo->SubnetName = (WCHAR*)MIDL_user_allocate(sizeof(WCHAR)*wsName.GetLength()+sizeof(WCHAR));

    // make sure the allocation succeeded
    if (pSubnetParams->m_pSubnetInfo->SubnetName == NULL)
        return FALSE;

    // copy the name to the new buffer
#ifdef _UNICODE
    wcscpy(pSubnetParams->m_pSubnetInfo->SubnetName, wsName);
#else
    swprintf(pSubnetParams->m_pSubnetInfo->SubnetName, L"%S", wsName);
#endif

    // if this is a request for 'instant apply', do it now
    if (pOut != NULL)
    {
        DWORD errCode;

        pSubnetParams->CommitSet(errCode);
        // fill back the code returned by the underlying level
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, errCode);
    }

    // the API call succeeded
    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSNetGetComment, pParams, pIn, pOut)
{
    BOOL                    fRefresh;
    CDHCP_Subnet_Parameters *pSubnetParams;
    LPDHCP_SUBNET_INFO      pSubnetInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;

    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    fRefresh = pSubnetParams->m_pSubnetInfo == NULL;
    
    if (pSubnetParams->GetSubnetInfo(pSubnetInfo, fRefresh) &&
        pSubnetInfo != NULL)
    {
        pOut->SetCHString(DHCP_Subnet_Property[IDX_SNET_Comment].m_wsPropName, pSubnetInfo->SubnetComment);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

// Set functions require the SubnetAddress which can be taken only from pParams.
// The changes are applied instantly only if pOut is not NULL (so the caller wants and
// gets a return code)
MFN_PROPERTY_ACTION_DEFN(fnSNetSetComment, pParams, pIn, pOut)
{
    CDHCP_Subnet_Parameters *pSubnetParams;
    CHString                wsComment;

    // pIn has to be not-null to provide the comment
    if (pParams == NULL || pIn == NULL)
        return FALSE;

    // get the pSubnetParams out of pParams
    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    // make sure there is a buffer for holding all this info.
    pSubnetParams->CheckExistsInfoPtr();

    // get the value to set from the pIn parameter
    if (!pIn->GetCHString(DHCP_Subnet_Property[IDX_SNET_Comment].m_wsPropName, wsComment))
        return FALSE;

    // release any old buffer
    if (pSubnetParams->m_pSubnetInfo->SubnetComment != NULL)
		DhcpRpcFreeMemory(pSubnetParams->m_pSubnetInfo->SubnetComment);

    // allocate a new buffer able to hold the new comment
    pSubnetParams->m_pSubnetInfo->SubnetComment = (WCHAR*)MIDL_user_allocate(sizeof(WCHAR)*wsComment.GetLength()+sizeof(WCHAR));

    if (pSubnetParams->m_pSubnetInfo->SubnetComment == NULL)
        return FALSE;

    // copy the comment to the new buffer
#ifdef _UNICODE
    wcscpy(pSubnetParams->m_pSubnetInfo->SubnetComment, wsComment);
#else
    swprintf(pSubnetParams->m_pSubnetInfo->SubnetComment, L"%S", wsComment);
#endif

    // if this is a request for 'instant apply', do it now
    if (pOut != NULL)
    {
        DWORD errCode;

        pSubnetParams->CommitSet(errCode);
        // fill back the code returned by the underlying level
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, errCode);
    }

    // the API call succeeded
    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSNetGetState, pParams, pIn, pOut)
{
    BOOL                    fRefresh;
    CDHCP_Subnet_Parameters *pSubnetParams;
    LPDHCP_SUBNET_INFO      pSubnetInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;

    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    fRefresh = pSubnetParams->m_pSubnetInfo == NULL;
    
    if (pSubnetParams->GetSubnetInfo(pSubnetInfo, fRefresh) &&
        pSubnetInfo != NULL)
    {
        pOut->SetDWORD(DHCP_Subnet_Property[IDX_SNET_State].m_wsPropName, pSubnetInfo->SubnetState);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

// Set functions require the SubnetAddress which can be taken only from pParams.
// The changes are applied instantly only if pOut is not NULL (so the caller wants and
// gets a return code)
MFN_PROPERTY_ACTION_DEFN(fnSNetSetState, pParams, pIn, pOut)
{
    CDHCP_Subnet_Parameters *pSubnetParams;
    DWORD                   dwState;

    // pIn has to be not-null to provide the new State
    if (pParams == NULL || pIn == NULL)
        return FALSE;

    // get pSubnetParams out of pParams
    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    // make sure there is a buffer for holding all this info.
    pSubnetParams->CheckExistsInfoPtr();

    // get the value to set from the pIn parameter
    if (!pIn->GetDWORD(DHCP_Subnet_Property[IDX_SNET_State].m_wsPropName, dwState))
        return FALSE;

    // test roughly if the new value matches the range of admissible values
    switch((DHCP_SUBNET_STATE)dwState)
    {
    case DhcpSubnetEnabled:
        pSubnetParams->m_pSubnetInfo->SubnetState = DhcpSubnetEnabled;
        break;
    case DhcpSubnetDisabled:
        pSubnetParams->m_pSubnetInfo->SubnetState = DhcpSubnetDisabled;
        break;
    default:
        return FALSE;
    }

    // if the request is for an 'instant apply', do it now
    if (pOut != NULL)
    {
        DWORD errCode;

        pSubnetParams->CommitSet(errCode);
        // fill back the code returned by the underlying level
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, errCode);
    }

    // the API call succeeded
    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSNetGetNumberOfAddressesInUse, pParams, pIn, pOut)
{
    BOOL                    fRefresh;
    CDHCP_Subnet_Parameters *pSubnetParams;
    LPDHCP_MIB_INFO         pMibInfo;
    LPSCOPE_MIB_INFO   pScopeMibInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;

    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    fRefresh = pSubnetParams->m_pMibInfo == NULL;
    
    if (pSubnetParams->GetMibInfo(pMibInfo, pScopeMibInfo, fRefresh) &&
        pScopeMibInfo != NULL)
    {
        pOut->SetDWORD(DHCP_Subnet_Property[IDX_SNET_NbAddrInUse].m_wsPropName, pScopeMibInfo->NumAddressesInuse);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSNetGetNumberOfAddressesFree, pParams, pIn, pOut)
{
    BOOL                    fRefresh;
    CDHCP_Subnet_Parameters *pSubnetParams;
    LPDHCP_MIB_INFO         pMibInfo;
    LPSCOPE_MIB_INFO   pScopeMibInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;

    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    fRefresh = pSubnetParams->m_pMibInfo == NULL;
    
    if (pSubnetParams->GetMibInfo(pMibInfo, pScopeMibInfo, fRefresh) && 
        pScopeMibInfo != NULL)
    {
        pOut->SetDWORD(DHCP_Subnet_Property[IDX_SNET_NbAddrFree].m_wsPropName, pScopeMibInfo->NumAddressesFree);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSNetGetNumberOfPendingOffers, pParams, pIn, pOut)
{
    BOOL                    fRefresh;
    CDHCP_Subnet_Parameters *pSubnetParams;
    LPDHCP_MIB_INFO         pMibInfo;
    LPSCOPE_MIB_INFO   pScopeMibInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;

    pSubnetParams = (CDHCP_Subnet_Parameters *)pParams;
    fRefresh = pSubnetParams->m_pMibInfo == NULL;

    if (pSubnetParams->GetMibInfo(pMibInfo, pScopeMibInfo, fRefresh) && 
        pScopeMibInfo != NULL)
    {
        pOut->SetDWORD(DHCP_Subnet_Property[IDX_SNET_NbPendingOffers].m_wsPropName, pScopeMibInfo->NumPendingOffers);
        return TRUE;
    }

    // the API call failed
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\snetscal.cpp ===
/******************************************************************
   SNetScal.cpp -- WBEM provider class implementation

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains: the definition of the DHCP_Subnet class,
        the static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "SNetFn.h"     // needed for the declarations of all the functions.
#include "SNetScal.h"   // own header

// static table of CDHCP_Property objects containing the DHCP Server
// scalar parameters (properties) which are WBEM manageable. Each object associates
// the name of the property with their SET and GET functions.
// *** NOTE ***
// The name of each property has to be in sync with the ones specified in the DhcpSchema.mof.
// The indices specified in SrvScal.h should also be in sync with the actual row from this table (they are used
// in the property's action functions.
static const CDHCP_Property DHCP_Subnet_Property[]=
{
 CDHCP_Property(L"Address",                 fnSNetGetAddress,                   NULL),
 CDHCP_Property(L"Mask",                    fnSNetGetMask,                      NULL),
 CDHCP_Property(L"Name",                    fnSNetGetName,                      fnSNetSetName),
 CDHCP_Property(L"Comment",                 fnSNetGetComment,                   fnSNetSetComment),
 CDHCP_Property(L"State",                   fnSNetGetState,                     fnSNetSetState),
 CDHCP_Property(L"NumberOfAddressesInUse",  fnSNetGetNumberOfAddressesInUse,    NULL),
 CDHCP_Property(L"NumberOfAddressesFree",   fnSNetGetNumberOfAddressesFree,     NULL),
 CDHCP_Property(L"NumberOfPendingOffers",   fnSNetGetNumberOfPendingOffers,     NULL)
};

// the name of the WBEM class
#define PROVIDER_NAME_DHCP_SUBNET       "DHCP_Subnet"

// main class instantiation.
CDHCP_Subnet MyDHCP_Subnet_Scalars (PROVIDER_NAME_DHCP_SUBNET, PROVIDER_NAMESPACE_DHCP) ;

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_Subnet::CDHCP_Subnet
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CDHCP_Subnet::CDHCP_Subnet (const CHString& strName, LPCSTR pszNameSpace ) :
	Provider(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_Subnet::~CDHCP_Subnet
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CDHCP_Subnet::~CDHCP_Subnet ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Subnet::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    Enumerates all this instances of this class. As there is only one
*                   DHCP Server per system, there is only one instance for this class
*
*****************************************************************************/
HRESULT CDHCP_Subnet::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
	CInstance*              pInstance;
    CDHCP_Subnet_Parameters subnetParams(0); // don't know here the IP address
    LPDHCP_MIB_INFO         pMibInfo;
    LPSCOPE_MIB_INFO        pScopeMibInfo;

    HRESULT                 hRes = WBEM_E_FAILED;


    if (subnetParams.GetMibInfo(pMibInfo, pScopeMibInfo, TRUE) && pMibInfo != NULL)
    {
        hRes = WBEM_S_NO_ERROR;

        for (int i=0; hRes == WBEM_S_NO_ERROR && i < pMibInfo->Scopes; i++)
        {
            LPSCOPE_MIB_INFO    pScope = &(pMibInfo->ScopeInfo[i]);             // this is the info from the server,
            CInstance*          pInstance = CreateNewInstance(pMethodContext);  // create now the instance

            if (pScope != NULL && 
                pInstance != NULL)
            {
                WCHAR szSubnetAddr[16]; // should be enough for holding 'xxx.yyy.zzz.uuu\0'

                // don't want to link to ws2_32.lib just for using inet_ntoa only
                swprintf(szSubnetAddr, L"%u.%u.%u.%u",(pScope->Subnet & 0xff000000) >> 24,
                                                      (pScope->Subnet & 0x00ff0000) >> 16,
                                                      (pScope->Subnet & 0x0000ff00) >> 8,
                                                      (pScope->Subnet & 0x000000ff));

                if (pInstance->SetCHString(DHCP_Subnet_Property[IDX_SNET_Address].m_wsPropName, szSubnetAddr) &&
                    LoadInstanceProperties(pInstance))
                {
                    hRes = Commit(pInstance);
                    // now everything relys on the err returned above.
                    continue;
                }
            }

            // at this point something should have definitively gone wrong
            hRes = WBEM_E_FAILED;
         }
    }

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Subnet::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CDHCP_Subnet::GetObject ( CInstance* pInstance, long lFlags )
{
    return LoadInstanceProperties(pInstance)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Subnet::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CDHCP_Subnet::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    : CDHCP_Subnet::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_PROVIDER_NOT_CAPABLE, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Subnet::PutInstance ( const CInstance &Instance, long lFlags)
{
    int                 i;
    DWORD               returnCode;
    CHString            strName, strMask;
    DHCP_IP_ADDRESS     dwAddress, dwMask;
    LPDHCP_SUBNET_INFO  pSubnetInfo;
    BOOL                newInstance;

    if (!Instance.GetCHString(DHCP_Subnet_Property[IDX_SNET_Address].m_wsPropName, strName) ||
        !Instance.GetCHString(DHCP_Subnet_Property[IDX_SNET_Mask].m_wsPropName, strMask) ||
        !inet_wstodw(strName, dwAddress) ||
        !inet_wstodw(strMask, dwMask))
        return FALSE;

    // the object below is used as a "repository" for all the properties' values.
    // once it is filled up with data, it is commited explicitely to the DHCP Server.
    CDHCP_Subnet_Parameters SubnetParameters(dwAddress, dwMask);

    // first get the subnet information, just to get the info that doesn't change
    // if fails => a new instance has to be created
    newInstance = !SubnetParameters.GetSubnetInfo(pSubnetInfo,TRUE);

    for (i = 0; i < NUM_SUBNET_PROPERTIES; i++)
    {
        if (DHCP_Subnet_Property[i].m_pfnActionSet != NULL)
        {
            // execute the SET property action function
            // because of the last NULL, no data is written to DHCP Server at this moment, 
            // only SubnetParameters object is filled up with the values taken from the Instance.
            // don't care much here about the error codes. Failure means some properties will
            // not be written. At least we are giving a chance to all the writable properties.
            (*(DHCP_Subnet_Property[i].m_pfnActionSet))(&SubnetParameters, (CInstance *)&Instance, NULL);
        }
    }

    if (newInstance)
        return SubnetParameters.CommitNew(returnCode) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
    else
        // commit the values of all the writable properties to DHCP Server
        return SubnetParameters.CommitSet(returnCode) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Subnet::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_PROVIDER_NOT_CAPABLE from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from DHCP_Server_Scalars.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Subnet::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    DWORD           returnCode;
    CHString        str;
    DHCP_IP_ADDRESS dwAddress;

    if (!Instance.GetCHString(DHCP_Subnet_Property[IDX_SNET_Address].m_wsPropName, str) ||
        !inet_wstodw(str, dwAddress))
        return (WBEM_E_FAILED);

    // the object below is used as a "repository" for all the properties' values.
    // once it is filled up with data, it is commited explicitely to the DHCP Server.
    CDHCP_Subnet_Parameters SubnetParameters(dwAddress);

    return SubnetParameters.DeleteSubnet() ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Subnet::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Subnet::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
    int                 i;
    DWORD               returnCode;
    CHString            str;
    DHCP_IP_ADDRESS     dwAddress;
    LPDHCP_SUBNET_INFO  pSubnetInfo;
    int     nSetPrefixLen = wcslen(_SNET_SET_PREFIX);

    if (!Instance.GetCHString(DHCP_Subnet_Property[IDX_SNET_Address].m_wsPropName, str) ||
        !inet_wstodw(str, dwAddress))
        return FALSE;

    // build the object identifying the subnet against which the method is executed
    CDHCP_Subnet_Parameters SubnetParameters(dwAddress);

    // get the subnet information, just to preserve the info that doesn't change
    if (!SubnetParameters.GetSubnetInfo(pSubnetInfo,TRUE))
        return WBEM_E_FAILED;

    // is it a "SET" operation?
    if (!_wcsnicmp (bstrMethodName, _SNET_SET_PREFIX, nSetPrefixLen))
    {
        int i;

        WCHAR *wcsPropertyName = bstrMethodName + nSetPrefixLen;    // pointer to the property name

        // scan the DHCP_Subnet_Property table looking for the property's row
        for (i = 0; i < NUM_SUBNET_PROPERTIES; i++)
        {
            // if the property row is found
            if (!_wcsicmp(wcsPropertyName, DHCP_Subnet_Property[i].m_wsPropName))
            {
                // see if the property is writable 
                if (DHCP_Subnet_Property[i].m_pfnActionSet != NULL)
                {
                    // execute the SET property action function
                    // because of the pOutParams, the method will be commited inside the call
                    if ((*(DHCP_Subnet_Property[i].m_pfnActionSet))(&SubnetParameters, pInParams, pOutParams))
                        // everything worked fine.
                        return WBEM_S_NO_ERROR;
                    else
                        // an error occured during "SET"
                        return WBEM_E_FAILED;
                }
                else
                    // no, the property cannot be written. (shouldn't really happen, as the methods from the
                    // repository should match the writable properties only)
                    return WBEM_E_READ_ONLY;
            }
        }
    }

    // if this point was reached, no method was found => provider not capable
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}


/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Subnet::LoadInstanceProperties
*
*  RETURNS     :	TRUE if the values for all the properties was loaded successfully,
*           FALSE otherwise.
*
*  COMMENTS    :    It loops through the Server_Property table, calling the GET functions.
*
*****************************************************************************/
BOOL CDHCP_Subnet::LoadInstanceProperties(CInstance* pInstance)
{
    CHString        str;
    DHCP_IP_ADDRESS dwAddress;

    if (!pInstance->GetCHString(DHCP_Subnet_Property[IDX_SNET_Address].m_wsPropName, str) ||
        !inet_wstodw(str, dwAddress))
        return FALSE;

    // there should be used this object, in order to not call several times the DHCP Server API.
    CDHCP_Subnet_Parameters SubnetParameters(dwAddress);

    for (int i = 0; i < NUM_SUBNET_PROPERTIES; i++)
    {
        // if there is an invisible property (does not support GET) just skip it.
        if (DHCP_Subnet_Property[i].m_pfnActionGet == NULL)
            continue;

        // call the appropriate GET function, fail if the call fails (there should be no reason for failure)
        if (!(*(DHCP_Subnet_Property[i].m_pfnActionGet))(&SubnetParameters, NULL, pInstance))
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\resscal.cpp ===
/******************************************************************
   ResScal.cpp -- WBEM provider class implementation

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains: the definition of the DHCP_Reservation class,
        the static table of manageable objects.

   REVISION:
        08/14/98 - created

******************************************************************/
#include <stdafx.h>

#include "ResFn.h"     // needed for the declarations of all the functions.
#include "ResScal.h"   // own header
#include "SrvFn.h"     // for server parameters
#include "LsFn.h"      // for lease parameters

// static table of CDHCP_Property objects containing the DHCP Reservation
// scalar parameters (properties) which are WBEM manageable. Each object associates
// the name of the property with their SET and GET functions.
// *** NOTE ***
// The name of each property has to be in sync with the ones specified in the DhcpSchema.mof.
// The indices specified in ResScal.h should also be in sync with the actual row from this table (they are used
// in the property's action functions.
static const CDHCP_Property DHCP_Reservation_Property[]=
{
// CDHCP_Property(L"Subnet",                      fnResGetSubnet,           NULL),
// CDHCP_Property(L"Address",                     fnResGetAddress,          fnResSetAddress),
// CDHCP_Property(L"UniqueClientIdentifier",      fnResGetHdwAddress,       fnResSetHdwAddress),
 CDHCP_Property(L"ReservationType",             fnResGetReservationType,  fnResSetReservationType)
};



// the name of the WBEM class
#define PROVIDER_NAME_DHCP_RESERVATION    "DHCP_Reservation"

// main class instantiation.
CDHCP_Reservation MyDHCP_Reservation_Scalars (PROVIDER_NAME_DHCP_RESERVATION, PROVIDER_NAMESPACE_DHCP) ;

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_Reservation::CDHCP_Reservation
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CDHCP_Reservation::CDHCP_Reservation (const CHString& strName, LPCSTR pszNameSpace ) :
	CDHCP_Lease(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_Reservation::~CDHCP_Reservation
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CDHCP_Reservation::~CDHCP_Reservation ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Reservation::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    Enumerates all this instances of this class. Here we scan
*                   all the subnets, for which we get the info on all
*                   clients.
*****************************************************************************/
HRESULT CDHCP_Reservation::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    CDHCP_Server_Parameters     srvParams;
    LPDHCP_MIB_INFO             pSrvMibInfo;

    if (srvParams.GetMibInfo(pSrvMibInfo, TRUE))
    {
        // loop through all the subnets configured on the local server
        for (int i = 0; i < pSrvMibInfo->Scopes; i++)
        {
            DWORD                   dwSubnet;
            DHCP_RESUME_HANDLE      ResumeHandle;

            dwSubnet = pSrvMibInfo->ScopeInfo[i].Subnet;

            CDHCP_Reservation_Parameters  resParams(dwSubnet, 0);

            ResumeHandle = 0;

            // for each subnet, loop through all the client buffers belonging to it
            do
            {
                HRESULT hRes = WBEM_S_NO_ERROR;

                // load the next buffer
				LONG t_Res = resParams.NextSubnetReservation(ResumeHandle) ;
                if ( t_Res < 0 )
                    return WBEM_E_FAILED;  // will fail here
				if ( t_Res == 0 )
					return WBEM_S_NO_ERROR ;

                // for the current buffer, loop through all the clients
                for (int j = 0; hRes == WBEM_S_NO_ERROR && j < resParams.m_pReservationInfoArray->NumElements; j++)
                {
                    // this is finally the info of the current client
                    LPDHCP_IP_RESERVATION_V4   pReservation = RESERVATION_CAST(resParams.m_pReservationInfoArray->Elements[j].Element.ReservedIp);
                    WCHAR                   wcsSubnet[16], wcsAddress[16]; // should be enough for holding 'xxx.yyy.zzz.uuu\0'

                    // build the str representation of the Subnet address
                    swprintf(wcsSubnet,  L"%u.%u.%u.%u",(dwSubnet & 0xff000000) >> 24,
                                                        (dwSubnet & 0x00ff0000) >> 16,
                                                        (dwSubnet & 0x0000ff00) >> 8,
                                                        (dwSubnet & 0x000000ff));

                    // build the str representation of the ReservationIpAddress address
                    swprintf(wcsAddress, L"%u.%u.%u.%u",(pReservation->ReservedIpAddress & 0xff000000) >> 24,
                                                        (pReservation->ReservedIpAddress & 0x00ff0000) >> 16,
                                                        (pReservation->ReservedIpAddress & 0x0000ff00) >> 8,
                                                        (pReservation->ReservedIpAddress & 0x000000ff));

                    // update the second key into the resParams
                    resParams.m_dwReservationAddress = pReservation->ReservedIpAddress;

                    // we finally have everything we need for the creating one more instance
                    CInstance*  pInstance = CreateNewInstance(pMethodContext);

                    // initialize the instance with the key info and call LoadInstanceProperties for the rest of the info
                    if (pInstance->SetCHString(DHCP_Lease_Property[IDX_Ls_Subnet].m_wsPropName, wcsSubnet) &&
                        pInstance->SetCHString(DHCP_Lease_Property[IDX_Ls_Address].m_wsPropName, wcsAddress) &&
                        LoadInstanceProperties(pInstance))
                    {
                        hRes = Commit(pInstance);
                        // now everything relys on the err returned above.
                    }
                }

                // if there was an error above, bail
                if (hRes != WBEM_S_NO_ERROR)
                    return WBEM_E_FAILED;

            } while (ResumeHandle != 0);    // bail if ResumeHandle got back to 0 (the end was reached)
        }
    }

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Reservation::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CDHCP_Reservation::GetObject ( CInstance* pInstance, long lFlags )
{
    return LoadInstanceProperties(pInstance)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    : CDHCP_Reservation::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_PROVIDER_NOT_CAPABLE, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Reservation::PutInstance ( const CInstance &Instance, long lFlags)
{
    int                 i;
    DWORD               returnCode;
    CHString            strName, str ;
    DHCP_IP_ADDRESS     dwSubnet, dwAddress;
    LPDHCP_IP_RESERVATION_V4 pReservationInfo;

    // at this point, the key information should be provided by the pInstance
    if (!Instance.GetCHString(DHCP_Lease_Property[IDX_Ls_Subnet].m_wsPropName, str) ||
        !inet_wstodw(str, dwSubnet) ||
        !Instance.GetCHString(DHCP_Lease_Property[IDX_Ls_Address].m_wsPropName, str) ||
        !inet_wstodw(str, dwAddress))
        return (WBEM_E_FAILED);

    // the object below is used as a "repository" for all the properties' values.
    // once it is filled up with data, it is commited explicitely to the DHCP Server.
    CDHCP_Reservation_Parameters resParams(dwSubnet,dwAddress);

    // if GetReservationInfo succeeds, then we have to remove the old reservation and create a
    // new one with the info from Instance.
    // if GetReservationInfo fails, Instance is a new reservation already
    if (resParams.GetReservationInfo(pReservationInfo,TRUE) &&
        !resParams.DeleteReservation())
        return WBEM_E_FAILED;

    for (i = 0; i < NUM_RESERVATION_PROPERTIES; i++)
    {
        if (DHCP_Reservation_Property[i].m_pfnActionSet != NULL)
        {
            // execute the SET property action function
            // because of the last NULL, no data is written to DHCP Server at this moment, 
            // only SubnetParameters object is filled up with the values taken from the Instance.
            // don't care much here about the error codes. Failure means some properties will
            // not be written. At least we are giving a chance to all the writable properties.
            if (!(*(DHCP_Reservation_Property[i].m_pfnActionSet))(&resParams, (CInstance *)&Instance, NULL))
                return WBEM_E_FAILED;
        }
    }

    // get from the instance the info which is missing for creating a reservation
    CDHCP_Lease_Parameters       leaseParams(dwSubnet, dwAddress);
    CDHCP_Lease::LoadLeaseParams(&leaseParams, (CInstance *)&Instance);

    // transfer the key lease info from the leaseParams to reservationParameters
    resParams.GetKeyInfoFromLease(&leaseParams);

    return (resParams.CommitNew(returnCode) &&
            returnCode == ERROR_SUCCESS &&
            leaseParams.CommitSet(returnCode) &&
            returnCode == ERROR_SUCCESS) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Reservation::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_PROVIDER_NOT_CAPABLE from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from DHCP_Server_Scalars.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Reservation::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    DWORD           returnCode;
    CHString        str;
    DHCP_IP_ADDRESS dwSubnet;
	DHCP_IP_ADDRESS dwAddress;

    // at this point, the key information should be provided by the pInstance
    if (!Instance.GetCHString(DHCP_Lease_Property[IDX_Ls_Subnet].m_wsPropName, str) ||
        !inet_wstodw(str, dwSubnet) ||
        !Instance.GetCHString(DHCP_Lease_Property[IDX_Ls_Address].m_wsPropName, str) ||
        !inet_wstodw(str, dwAddress))
        return (WBEM_E_FAILED);

    CDHCP_Reservation_Parameters ReservationParameters(dwSubnet,dwAddress);

    return ReservationParameters.DeleteReservation() ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Reservation::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CDHCP_Reservation::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Reservation::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Reservation::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}


/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Reservation::LoadInstanceProperties
*
*  RETURNS     :	TRUE if the values for all the properties was loaded successfully,
*           FALSE otherwise.
*
*  COMMENTS    :    It loops through the Reservation_Property table, calling the GET functions.
*                   The pInstance parameter must have at this point all the key information
*                   (Subnet and Address in this case)
*
*****************************************************************************/
BOOL CDHCP_Reservation::LoadInstanceProperties(CInstance* pInstance)
{
    CHString        str;
    DHCP_IP_ADDRESS dwSubnet, dwAddress;

    // load first the lease properties 
    if (!CDHCP_Lease::LoadInstanceProperties(pInstance, dwSubnet, dwAddress))
        return FALSE;

    CDHCP_Reservation_Parameters  reservationParams(dwSubnet, dwAddress);

    // load now the properties of the reservation
    for (int i = 0; i < NUM_RESERVATION_PROPERTIES; i++)
    {
        // if there is an invisible property (does not support GET) just skip it.
        if (DHCP_Reservation_Property[i].m_pfnActionGet == NULL)
            continue;

        // call the appropriate GET function, fail if the call fails (there should be no reason for failure)
        if (!(*(DHCP_Reservation_Property[i].m_pfnActionGet))(&reservationParams, NULL, pInstance))
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\rngfn.cpp ===
/******************************************************************
   LsFn.cpp -- Properties action functions (GET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the definition for the action functions associated to
        each manageable property from the class CDHCP_Range

   REVISION:
        08/14/98 - created

******************************************************************/
#include <stdafx.h>

#include "RngFn.h"      // own header

/*****************************************************************
 *  The definition of the class CDHCP_Range_Parameters
 *****************************************************************/
// by default, all the data structures are NULL (and dw variables are 0'ed)
// those values indicates that no data is cached from the server.

void CDHCP_Range_Parameters::DeleteRangeInfoArray(LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4& pRangeInfoArray)
{
    if (pRangeInfoArray)
    {
        if (pRangeInfoArray->Elements)
        {
            for (int i = 0; i < pRangeInfoArray->NumElements; i++)
            {
                if (pRangeInfoArray->Elements[i].ElementType == DhcpIpRanges)
                    DhcpRpcFreeMemory(pRangeInfoArray->Elements[i].Element.IpRange);
                if (pRangeInfoArray->Elements[i].ElementType == DhcpExcludedIpRanges)
                    DhcpRpcFreeMemory(pRangeInfoArray->Elements[i].Element.ExcludeIpRange);
            }
            DhcpRpcFreeMemory(pRangeInfoArray->Elements);
        }
        DhcpRpcFreeMemory(pRangeInfoArray);
        pRangeInfoArray = NULL;
    }
}

CDHCP_Range_Parameters::CDHCP_Range_Parameters(
        DHCP_IP_ADDRESS dwSubnet,
        DHCP_IP_ADDRESS dwStartAddress,
        DHCP_IP_ADDRESS dwEndAddress)
{
    m_dwSubnet        = dwSubnet;
    m_dwStartAddress  = dwStartAddress;
    m_dwEndAddress    = dwEndAddress;
    m_pRangeInfoArray = NULL;
}

// the DHCP API calls are allocating memory for which the caller is responsible
// to release. We are releasing this memory upon the destruction of this object's instance.
CDHCP_Range_Parameters::~CDHCP_Range_Parameters()
{
    DeleteRangeInfoArray(m_pRangeInfoArray);
}

// DESCRIPTION:
//      Fills in the internal cache with the information from the database, starting
//      from the given handle. If the end of the database is reached, the handle is
//      reset to 0. Returns TRUE on success (regardless there is more data to be read or not).
DWORD CDHCP_Range_Parameters::NextSubnetRange(DHCP_RESUME_HANDLE & hResume, DHCP_SUBNET_ELEMENT_TYPE rangeType)
{
    DWORD   dwError;
    DWORD   dwRangeRead = 0;
    DWORD   dwRangeTotal = 0;

    // each time the API gets called, the previous 
    // m_pReservationInfoArray is useless and should be freed
    DeleteRangeInfoArray(m_pRangeInfoArray);

    // calls the API.
    dwError = DhcpEnumSubnetElementsV4 (
        SERVER_IP_ADDRESS,
        m_dwSubnet,
		rangeType,
        &hResume,
        (DWORD)(-1),
        &m_pRangeInfoArray,
        &dwRangeRead,
        &dwRangeRead);

    if (dwError == ERROR_SUCCESS)
        hResume = 0;

    return dwError; // possible (normal) codes: ERROR_SUCCESS, ERROR_MORE_DATA, ERROR_NO_MORE_ITEMS
}

// DESCRIPTION:
//      Check the cache for the existance of a given subnet range, of the given range type.
BOOL CDHCP_Range_Parameters::CheckExistsRangeInCache(DHCP_SUBNET_ELEMENT_TYPE rangeType)
{
    if (m_pRangeInfoArray == NULL)
        return FALSE;

    for (int i=0; i < m_pRangeInfoArray->NumElements; i++)
    {
        LPDHCP_IP_RANGE lpRange;

        if (m_pRangeInfoArray->Elements[i].ElementType != rangeType)
            continue;

        if (rangeType == DhcpIpRanges)
            lpRange = m_pRangeInfoArray->Elements[i].Element.IpRange;
        else if (rangeType == DhcpExcludedIpRanges)
            lpRange = m_pRangeInfoArray->Elements[i].Element.ExcludeIpRange;
        else
            return FALSE;

        if (lpRange->StartAddress == m_dwStartAddress &&
            lpRange->EndAddress == m_dwEndAddress)
            return TRUE;
    }

    return FALSE;
}

// DESCRIPTION:
//      Check the existance of a given subnet range, first in cache, and if this fails, from the info refreshed from
//      the server. This method assumes m_dwSubnet, m_dwStartAddress and m_dwEndAddress are already filled in
//      with consistent data.
BOOL CDHCP_Range_Parameters::CheckExistsRange(DHCP_SUBNET_ELEMENT_TYPE rangeType)
{
    DHCP_RESUME_HANDLE  hResume;

    if (CheckExistsRangeInCache(rangeType))
        return TRUE;

    hResume = 0;

    do
    {
        DWORD errCode;
        
        errCode = NextSubnetRange(hResume, rangeType);

        if (errCode != ERROR_SUCCESS &&
            errCode != ERROR_MORE_DATA)
            break;

        if (CheckExistsRangeInCache(rangeType))
            return TRUE;

    } while(hResume != 0);

    return FALSE;
}

BOOL CDHCP_Range_Parameters::CreateRange(DHCP_SUBNET_ELEMENT_TYPE rangeType)
{
    DWORD                       errCode;
    DHCP_SUBNET_ELEMENT_DATA_V4 subnetElementInfo;
    DHCP_IP_RANGE               rangeInfo;

    rangeInfo.StartAddress = m_dwStartAddress;
    rangeInfo.EndAddress = m_dwEndAddress;
    subnetElementInfo.ElementType = rangeType;

    // no matter the range type, 'Element' is a union so this pointer is set
    // to both IpRange and ExcludeIpRange;
    subnetElementInfo.Element.IpRange = &rangeInfo;

    errCode = DhcpAddSubnetElementV4(
                SERVER_IP_ADDRESS,
                m_dwSubnet,
                &subnetElementInfo);

    return (errCode == ERROR_SUCCESS);
}

BOOL CDHCP_Range_Parameters::DeleteRange(DHCP_SUBNET_ELEMENT_TYPE rangeType)
{
    DWORD                       errCode;
    DHCP_SUBNET_ELEMENT_DATA_V4 subnetElementInfo;
    DHCP_IP_RANGE               rangeInfo;

    rangeInfo.StartAddress = m_dwStartAddress;
    rangeInfo.EndAddress = m_dwEndAddress;
    subnetElementInfo.ElementType = rangeType;

    // no matter the range type, 'Element' is a union so this pointer is set
    // to both IpRange and ExcludeIpRange;
    subnetElementInfo.Element.IpRange = &rangeInfo;

    errCode = DhcpRemoveSubnetElementV4(
                SERVER_IP_ADDRESS,
                m_dwSubnet,
                &subnetElementInfo,
                DhcpFullForce);

    return (errCode == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\resfn.cpp ===
/******************************************************************
   LsFn.cpp -- Properties action functions (GET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the definition for the action functions associated to
        each manageable property from the class CDHCP_Reservation

   REVISION:
        08/14/98 - created

******************************************************************/
#include <stdafx.h>

#include "ResScal.h"    // needed for DHCP_Reservation_Property[] (for retrieving the property's name)
#include "ResFn.h"      // own header
#include "LsFn.h"       // for GetKeyInfoFromLease

/*****************************************************************
 *  The definition of the class CDHCP_Reservation_Parameters
 *****************************************************************/
// by default, all the data structures are NULL (and dw variables are 0'ed)
// those values indicates that no data is cached from the server.

void CDHCP_Reservation_Parameters::DeleteReservationInfo(LPDHCP_IP_RESERVATION_V4& pReservationInfo)
{
    if (pReservationInfo != NULL)
    {
        if (pReservationInfo->ReservedForClient != NULL)
        {
            if (pReservationInfo->ReservedForClient->Data != NULL)
                DhcpRpcFreeMemory(pReservationInfo->ReservedForClient->Data);
            DhcpRpcFreeMemory(pReservationInfo->ReservedForClient);
        }
        DhcpRpcFreeMemory(pReservationInfo);
    }
}

void CDHCP_Reservation_Parameters::DeleteReservationInfoArray(LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4& pReservationInfoArray)
{
    if (pReservationInfoArray)
    {
        if (pReservationInfoArray->Elements)
        {
            while(pReservationInfoArray->NumElements)
            {
                DeleteReservationInfo(pReservationInfoArray->Elements[--(pReservationInfoArray->NumElements)].Element.ReservedIp);
            }
            DhcpRpcFreeMemory(pReservationInfoArray->Elements);
        }
        DhcpRpcFreeMemory(pReservationInfoArray);
        pReservationInfoArray = NULL;
    }

	if ( m_pReservationInfo )
	{
        if (m_pReservationInfo->Element.ReservedIp)
            DeleteReservationInfo(m_pReservationInfo->Element.ReservedIp);

        DhcpRpcFreeMemory(m_pReservationInfo);
		m_pReservationInfo = NULL ;
	}
}

CDHCP_Reservation_Parameters::CDHCP_Reservation_Parameters(DHCP_IP_ADDRESS dwSubnetAddress, DHCP_IP_ADDRESS dwReservationAddress)
{
    m_dwSubnetAddress  = dwSubnetAddress;
    m_dwReservationAddress  = dwReservationAddress;
    m_pReservationInfoArray = NULL;
	m_pReservationInfo = NULL ;
}

// the DHCP API calls are allocating memory for which the caller is responsible
// to release. We are releasing this memory upon the destruction of this object's instance.
CDHCP_Reservation_Parameters::~CDHCP_Reservation_Parameters()
{
    DeleteReservationInfoArray(m_pReservationInfoArray);
}

BOOL CDHCP_Reservation_Parameters::GetKeyInfoFromLease(CDHCP_Lease_Parameters *pLeaseParams)
{
    if (pLeaseParams == NULL ||
        pLeaseParams->m_pClientSetInfo == NULL)
        return FALSE;

    if (!CheckExistsInfoPtr())
        return FALSE;

    m_pReservationInfo->Element.ReservedIp->ReservedIpAddress = pLeaseParams->m_pClientSetInfo->ClientIpAddress;

    return dupDhcpBinaryData(
                pLeaseParams->m_pClientSetInfo->ClientHardwareAddress,
                *(m_pReservationInfo->Element.ReservedIp->ReservedForClient));
}

// DESCRIPTION:
//      Fills in the internal cache with the information from the database, starting
//      from the given handle. If the end of the database is reached, the handle is
//      reset to 0. Returns TRUE on success (regardless there is more data to be read or not).
LONG CDHCP_Reservation_Parameters::NextSubnetReservation(DHCP_RESUME_HANDLE ResumeHandle)
{
    DWORD   Error;
    DWORD   ReservationsRead = 0;
    DWORD   ReservationsTotal = 0;

    // each time the API gets called, the previous 
    // m_pReservationInfoArray is useless and should be freed
    DeleteReservationInfoArray(m_pReservationInfoArray);

    // calls the API.
    Error = DhcpEnumSubnetElementsV4 (
        SERVER_IP_ADDRESS,
        m_dwSubnetAddress,
		DhcpReservedIps,
        &ResumeHandle,
        (DWORD)(-1),
        &m_pReservationInfoArray,
        &ReservationsRead,
        &ReservationsTotal);

    if (Error == ERROR_SUCCESS) 
        ResumeHandle = 0;

    return (Error == ERROR_SUCCESS || Error == ERROR_MORE_DATA);
}

BOOL CDHCP_Reservation_Parameters::GetReservationInfoFromCache(LPDHCP_IP_RESERVATION_V4& pReservationInfo)
{
    if (m_pReservationInfoArray != NULL)
    {
        for (int i=0; i<m_pReservationInfoArray->NumElements; i++)
        {
            // match the internal reservation id with the info from cache
            if (m_pReservationInfoArray->Elements[i].Element.ReservedIp->ReservedIpAddress == m_dwReservationAddress)
            {
                DHCP_CLIENT_UID  *pClientUid;
                // reservation found, return info on client, and TRUE.
                pReservationInfo = m_pReservationInfoArray->Elements[i].Element.ReservedIp;

                pClientUid = pReservationInfo->ReservedForClient;
                if (pClientUid->DataLength >= sizeof(DHCP_IP_ADDRESS) &&
                    memcmp(pClientUid->Data, &m_dwSubnetAddress, sizeof(DHCP_IP_ADDRESS)) == 0)
                {
                    UINT nPrefix = sizeof(DHCP_IP_ADDRESS) + sizeof(BYTE);
                    pClientUid->DataLength -= nPrefix;
                    memmove(pClientUid->Data, pClientUid->Data + nPrefix, pClientUid->DataLength);
                }
                return TRUE;
            }
        }
    }
    return FALSE;
}

// DESCRIPTION:
//      Provides the data structure filled in through the DhcpGetReservationInfo API
//      If this data is cached and the caller is not forcing the refresh,
//      return the internal cache. Otherwise, the internal cache is refreshed as well.
BOOL CDHCP_Reservation_Parameters::GetReservationInfo(LPDHCP_IP_RESERVATION_V4& pReservationInfo, BOOL fRefresh)
{
    if (m_pReservationInfoArray == NULL)
        fRefresh = TRUE;

    if (!fRefresh && 
        GetReservationInfoFromCache(pReservationInfo))
        return TRUE;

    DHCP_RESUME_HANDLE ResumeHandle = 0;
    DWORD i;

    // either the caller wants full refresh, or the reservation was not found into the cache
    // do full refresh.
    do
    {
        if ( ( NextSubnetReservation(ResumeHandle) > 0 ) &&
            GetReservationInfoFromCache(pReservationInfo) ) 
            return TRUE;
    } while (ResumeHandle != 0);

    return FALSE;
}

// DESCRIPTION:
//      Checks the m_pConfigInfoV4 pointer to insure it points to a valid buffer.
//      It allocates the DHCP_SUBNET_INFO if needed.
BOOL CDHCP_Reservation_Parameters::CheckExistsInfoPtr()
{
    if (m_pReservationInfo != NULL)
        return TRUE;
    
    m_pReservationInfo = (LPDHCP_SUBNET_ELEMENT_DATA_V4)MIDL_user_allocate(sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));

    if (m_pReservationInfo != NULL)
    {
		m_pReservationInfo->ElementType = DhcpReservedIps ;
        m_pReservationInfo->Element.ReservedIp = (LPDHCP_IP_RESERVATION_V4) MIDL_user_allocate(sizeof(DHCP_IP_RESERVATION_V4));
        if (m_pReservationInfo->Element.ReservedIp != NULL)
        {
            m_pReservationInfo->Element.ReservedIp->ReservedForClient = (DHCP_CLIENT_UID*)MIDL_user_allocate(sizeof(DHCP_CLIENT_UID));
            return TRUE;
        }
    }
    return FALSE;
}

// DESCRIPTION:
//      Creates a new subnet.
//      Assumes that all the fields from the DHCP_SUBNET_INFO structure are valid, and filled with
//      the data to be set. Calls the underlying API and returns TRUE (on success) or FALSE (on failure)
BOOL CDHCP_Reservation_Parameters::CommitNew(DWORD &returnCode)
{
    if (m_pReservationInfo == NULL ||
        m_pReservationInfo->Element.ReservedIp == NULL)
        return FALSE;

    // fill in the reservation address
    m_pReservationInfo->Element.ReservedIp->ReservedIpAddress = m_dwReservationAddress;

    // we only add here the reservation info. In order to have the reservation active, a lease record has to be created into
    // the database as well.
    returnCode = DhcpAddSubnetElementV4(
                    SERVER_IP_ADDRESS,
                    m_dwSubnetAddress,
                    m_pReservationInfo);
    return returnCode == ERROR_SUCCESS;
}

// DESCRIPTION:
//      Assumes the m_dwSubnetAddress,m_dwReservationAddress is initialized, case in 
//		which it calls the DHCPAPI to delete that reservation from the server.
BOOL CDHCP_Reservation_Parameters::DeleteReservation()
{
    LPDHCP_IP_RESERVATION_V4       pReservationInfo;

    
    if (GetReservationInfo(pReservationInfo, FALSE) &&
        pReservationInfo != NULL)
    {
        DHCP_SUBNET_ELEMENT_DATA_V4 subnetElement;

        subnetElement.ElementType = DhcpReservedIps;
        subnetElement.Element.ReservedIp = pReservationInfo;

        // this removes both the reservation registration and the record from the databse
		if (DhcpRemoveSubnetElementV4(SERVER_IP_ADDRESS, m_dwSubnetAddress, &subnetElement, DhcpFullForce) == ERROR_SUCCESS)
		{
			// don't look below :o)
			// It's only an exotic way of calling the destructor without destroying the object itself
			this->~CDHCP_Reservation_Parameters();
			return TRUE;
		}
		return FALSE;
	}

	return FALSE ;
}

// GET function for the (RO)"Type" property
MFN_PROPERTY_ACTION_DEFN(fnResGetReservationType, pParams, pIn, pOut)
{
    CDHCP_Reservation_Parameters *pReservationParams;
    LPDHCP_IP_RESERVATION_V4   pReservationInfo;

    if (pParams == NULL || pOut == NULL)
        return FALSE;
    pReservationParams = (CDHCP_Reservation_Parameters *)pParams;
    
    if (pReservationParams->GetReservationInfo(pReservationInfo, FALSE) &&
        pReservationInfo != NULL)
    {
		// get the value to set from the pIn parameter
		return pOut->SetByte(DHCP_Reservation_Property[IDX_Res_ReservationType].m_wsPropName, pReservationInfo->bAllowedClientTypes) ;
	}

    // the API call failed
    return FALSE;
}

// SET function for the (CREATE)"Type" property
MFN_PROPERTY_ACTION_DEFN(fnResSetReservationType, pParams, pIn, pOut)
{
    CDHCP_Reservation_Parameters *pReservationParams;
    BYTE dwClientType;

    // pParams and pIn have to be valid to provide the SubnetAddress and the Name to set
    if (pParams == NULL || pIn == NULL)
        return FALSE;

    // get the CDHCP_Subnet_Parameters out of pParams
    pReservationParams = (CDHCP_Reservation_Parameters *)pParams;
    // make sure there is a buffer for holding all this info.
    pReservationParams->CheckExistsInfoPtr();

    // get the value to set from the pIn parameter
    if (!pIn->GetByte(DHCP_Reservation_Property[IDX_Res_ReservationType].m_wsPropName, dwClientType))
        return FALSE;

    pReservationParams->m_pReservationInfo->Element.ReservedIp->bAllowedClientTypes = dwClientType ;

	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\rngscal.cpp ===
/******************************************************************
   ResScal.cpp -- WBEM provider class implementation

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains: the definition of the DHCP_Reservation class,
        the static table of manageable objects.

   REVISION:
        08/14/98 - created

******************************************************************/
#include <stdafx.h>

#include "RngFn.h"     // needed for the declarations of all the functions.
#include "RngScal.h"   // own header
#include "SrvFn.h"     // for server parameters

// the name of the WBEM class
#define PROVIDER_NAME_DHCP_RANGE    "DHCP_Range"

// main class instantiation.
CDHCP_Range MyDHCP_Range_Scalars (PROVIDER_NAME_DHCP_RANGE, PROVIDER_NAMESPACE_DHCP) ;

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_Range::CDHCP_Range
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CDHCP_Range::CDHCP_Range (const CHString& strName, LPCSTR pszNameSpace ) :
	Provider(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_Range::~CDHCP_Range
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CDHCP_Range::~CDHCP_Range()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Range::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    Enumerates all this instances of this class. Here we scan
*                   all the subnets, for which we get the info on all
*                   clients.
*****************************************************************************/
HRESULT CDHCP_Range::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    CDHCP_Server_Parameters     srvParams;
    LPDHCP_MIB_INFO             pSrvMibInfo;
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (!srvParams.GetMibInfo(pSrvMibInfo, TRUE))
        return WBEM_E_FAILED;

    // loop through all the subnets configured on the local server
    for (int i = 0; hRes == WBEM_S_NO_ERROR && i < pSrvMibInfo->Scopes; i++)
    {
        DWORD                   dwSubnet;
        DHCP_RESUME_HANDLE      ResumeHandle;
        WCHAR                   wcsSubnet[16]; // should be enough for holding 'xxx.yyy.zzz.uuu\0'

        dwSubnet = pSrvMibInfo->ScopeInfo[i].Subnet;

        CDHCP_Range_Parameters  rngParams(dwSubnet);

        // build the str representation of the Subnet address
        swprintf(wcsSubnet,  L"%u.%u.%u.%u",(dwSubnet & 0xff000000) >> 24,
                                            (dwSubnet & 0x00ff0000) >> 16,
                                            (dwSubnet & 0x0000ff00) >> 8,
                                            (dwSubnet & 0x000000ff));

        // one loop for included ranges, one loop for excluded ranges
        for (int k = 0; k < 2; k++)
        {
            ResumeHandle = 0;

            // for each subnet and each type of range, loop through all the range buffers belonging to it
            do
            {
                DWORD errCode;

                // load the next buffer
                errCode = rngParams.NextSubnetRange(ResumeHandle, k == 0 ? DhcpIpRanges : DhcpExcludedIpRanges);

                // if ERROR_NO_MORE_ITEMS than no information was filled into m_pRangeInfoArray (which is null)
                if (errCode == ERROR_NO_MORE_ITEMS)
                    break;

                // two alternatives here: ERROR_MORE_DATA (ResumeHandle != 0) and ERROR_SUCCESS (which case 
                // the API is setting ResumeHandle to NULL (hope so :o). In both cases, just go on.
                if (errCode != ERROR_MORE_DATA && errCode != ERROR_SUCCESS)
                    return WBEM_E_FAILED;

                // for the current buffer, loop through all the ranges
                for (int j = 0; hRes == WBEM_S_NO_ERROR && j < rngParams.m_pRangeInfoArray->NumElements; j++)
                {
                    // this is finally the info of the current range
                    LPDHCP_IP_RANGE pRange = (k == 0)?
                                             (LPDHCP_IP_RANGE)(rngParams.m_pRangeInfoArray->Elements[j].Element.IpRange) : 
                                             (LPDHCP_IP_RANGE)(rngParams.m_pRangeInfoArray->Elements[j].Element.ExcludeIpRange);
                    WCHAR wcsAddress[16]; // should be enough for holding 'xxx.yyy.zzz.uuu\0'
                    // we finally have everything we need for the creating one more instance
                    CInstance*  pInstance = CreateNewInstance(pMethodContext);

                    //----------------- add 'Subnet' property to the instance -------------------
                    if (pInstance == NULL ||
                        !pInstance->SetCHString(PROP_Range_Subnet, wcsSubnet))
                        return WBEM_E_FAILED;

                    //----------------- add 'StartAddress' property to the instance -------------
                    // build the str representation of the ReservationIpAddress address
                    swprintf(wcsAddress, L"%u.%u.%u.%u",(pRange->StartAddress & 0xff000000) >> 24,
                                                        (pRange->StartAddress & 0x00ff0000) >> 16,
                                                        (pRange->StartAddress & 0x0000ff00) >> 8,
                                                        (pRange->StartAddress & 0x000000ff));

                    if (!pInstance->SetCHString(PROP_Range_StartAddress, wcsAddress))
                        return WBEM_E_FAILED;

                    //----------------- add 'EndAddress' property to the instance ---------------
                    // build the str representation of the ReservationIpAddress address
                    swprintf(wcsAddress, L"%u.%u.%u.%u",(pRange->EndAddress & 0xff000000) >> 24,
                                                        (pRange->EndAddress & 0x00ff0000) >> 16,
                                                        (pRange->EndAddress & 0x0000ff00) >> 8,
                                                        (pRange->EndAddress & 0x000000ff));

                    if (!pInstance->SetCHString(PROP_Range_EndAddress, wcsAddress))
                        return WBEM_E_FAILED;

                    //----------------- add 'RangeType' property to the instance ----------------
                    if (!pInstance->SetDWORD(PROP_Range_RangeType, k==0? DhcpIpRanges : DhcpExcludedIpRanges));

                    //~~~~~~~~~~~~~~~~~ Commit the instance ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    hRes = Commit(pInstance);
                }

            } while (ResumeHandle != 0);    // bail if ResumeHandle got back to 0 (the end was reached)
        }
    }

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Range::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CDHCP_Range::GetObject ( CInstance* pInstance, long lFlags )
{
    CHString    str;
    DWORD       dwSubnet, dwStartAddress, dwEndAddress, dwRangeType;

    if (pInstance == NULL ||
        !pInstance->GetCHString(PROP_Range_Subnet, str) ||
        !inet_wstodw(str, dwSubnet) ||
        !pInstance->GetCHString(PROP_Range_StartAddress, str) ||
        !inet_wstodw(str, dwStartAddress) ||
        !pInstance->GetCHString(PROP_Range_EndAddress, str) ||
        !inet_wstodw(str, dwEndAddress) ||
        !pInstance->GetDWORD(PROP_Range_RangeType, dwRangeType))
        return WBEM_E_FAILED;

    CDHCP_Range_Parameters  rngParams(dwSubnet, dwStartAddress, dwEndAddress);

    return rngParams.CheckExistsRange((DHCP_SUBNET_ELEMENT_TYPE)dwRangeType) ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    : CDHCP_Range::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_PROVIDER_NOT_CAPABLE, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Range::PutInstance ( const CInstance &Instance, long lFlags)
{
    CHString    str;
    DWORD       dwSubnet, dwStartAddress, dwEndAddress, dwRangeType;

    if (!Instance.GetCHString(PROP_Range_Subnet, str) ||
        !inet_wstodw(str, dwSubnet) ||
        !Instance.GetCHString(PROP_Range_StartAddress, str) ||
        !inet_wstodw(str, dwStartAddress) ||
        !Instance.GetCHString(PROP_Range_EndAddress, str) ||
        !inet_wstodw(str, dwEndAddress) ||
        !Instance.GetDWORD(PROP_Range_RangeType, dwRangeType))
        return WBEM_E_FAILED;

    CDHCP_Range_Parameters  rngParams(dwSubnet, dwStartAddress, dwEndAddress);

    return rngParams.CreateRange((DHCP_SUBNET_ELEMENT_TYPE)dwRangeType) ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Range::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_PROVIDER_NOT_CAPABLE from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from DHCP_Server_Scalars.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Range::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    CHString    str;
    DWORD       dwSubnet, dwStartAddress, dwEndAddress, dwRangeType;

    if (!Instance.GetCHString(PROP_Range_Subnet, str) ||
        !inet_wstodw(str, dwSubnet) ||
        !Instance.GetCHString(PROP_Range_StartAddress, str) ||
        !inet_wstodw(str, dwStartAddress) ||
        !Instance.GetCHString(PROP_Range_EndAddress, str) ||
        !inet_wstodw(str, dwEndAddress) ||
        !Instance.GetDWORD(PROP_Range_RangeType, dwRangeType))
        return WBEM_E_FAILED;

    CDHCP_Range_Parameters  rngParams(dwSubnet, dwStartAddress, dwEndAddress);

    return rngParams.DeleteRange((DHCP_SUBNET_ELEMENT_TYPE)dwRangeType) ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Range::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CDHCP_Range::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Range::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Range::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\srvscal.cpp ===
/******************************************************************
   SrvScal.cpp -- WBEM provider class implementation

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains: the definition of the DHCP_Server class,
        the static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "SrvFn.h"      // needed for the declarations of all the functions.
#include "SrvScal.h"    // own header

// static table of CDHCP_Property objects containing the DHCP Server
// scalar parameters (properties) which are WBEM manageable. Each object associates
// the name of the property with their SET and GET functions.
// *** NOTE ***
// The name of each property has to be in sync with the ones specified in the DhcpSchema.mof.
// The indices specified in SrvScal.h should also be in sync with the actual row from this table (they are used
// in the property's action functions.
static const CDHCP_Property DHCP_Server_Property[]=
{
 CDHCP_Property(L"StartTime",                  fnSrvGetStartTime,                    NULL),
 CDHCP_Property(L"TotalNoOfAcks",              fnSrvGetTotalNoOfAcks,                NULL),
 CDHCP_Property(L"TotalNoOfDeclines",          fnSrvGetTotalNoOfDeclines,            NULL),
 CDHCP_Property(L"TotalNoOfDiscovers",         fnSrvGetTotalNoOfDiscovers,           NULL),
 CDHCP_Property(L"TotalNoOfNacks",             fnSrvGetTotalNoOfNacks,               NULL),
 CDHCP_Property(L"TotalNoOfOffers",            fnSrvGetTotalNoOfOffers,              NULL),
 CDHCP_Property(L"TotalNoOfReleases",          fnSrvGetTotalNoOfReleases,            NULL),
 CDHCP_Property(L"TotalNoOfRequests",          fnSrvGetTotalNoOfRequests,            NULL),
 CDHCP_Property(L"ServerVersion",              fnSrvGetServerVersion,                NULL),
 CDHCP_Property(L"APIProtocol",                fnSrvGetAPIProtocol,                  fnSrvSetAPIProtocol),
 CDHCP_Property(L"DatabaseName",               fnSrvGetDatabaseName,                 fnSrvSetDatabaseName),
 CDHCP_Property(L"DatabasePath",               fnSrvGetDatabasePath,                 fnSrvSetDatabasePath),
 CDHCP_Property(L"BackupPath",                 fnSrvGetBackupPath,                   fnSrvSetBackupPath),
 CDHCP_Property(L"BackupInterval",             fnSrvGetBackupInterval,               fnSrvSetBackupInterval),
 CDHCP_Property(L"DatabaseLoggingFlag",        fnSrvGetDatabaseLoggingFlag,          fnSrvSetDatabaseLoggingFlag),
 CDHCP_Property(L"RestoreFlag",                fnSrvGetRestoreFlag,                  fnSrvSetRestoreFlag),
 CDHCP_Property(L"DatabaseCleanupInterval",    fnSrvGetDatabaseCleanupInterval,      fnSrvSetDatabaseCleanupInterval),
 CDHCP_Property(L"DebugFlag",                  fnSrvGetDebugFlag,                    fnSrvSetDebugFlag),
 CDHCP_Property(L"PingRetries",                fnSrvGetPingRetries,                  fnSrvSetPingRetries),
 CDHCP_Property(L"BootFileTable",              fnSrvGetBootFileTable,                fnSrvSetBootFileTable),
 CDHCP_Property(L"AuditLog",                   fnSrvGetAuditLog,                     fnSrvSetAuditLog)
};

// the name of the WBEM class
#define PROVIDER_NAME_DHCP_SERVER   "DHCP_Server"

// main class instantiation.
CDHCP_Server MyDHCP_Server_Scalars (PROVIDER_NAME_DHCP_SERVER, PROVIDER_NAMESPACE_DHCP) ;


/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_Server::CDHCP_Server
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CDHCP_Server::CDHCP_Server (const CHString& strName, LPCSTR pszNameSpace ) :
	Provider(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_Server::~CDHCP_Server
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CDHCP_Server::~CDHCP_Server ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Server::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    Enumerates all this instances of this class. As there is only one
*                   DHCP Server per system, there is only one instance for this class
*
*****************************************************************************/
HRESULT CDHCP_Server::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
	CInstance* pInstance;
	HRESULT hRes = WBEM_S_NO_ERROR;

		if ((pInstance = CreateNewInstance(pMethodContext)) != NULL &&
            LoadInstanceProperties(pInstance))
        {
			hRes = Commit(pInstance);
		} 
        else 
        {
			hRes = WBEM_E_OUT_OF_MEMORY;
		}

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Server::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CDHCP_Server::GetObject ( CInstance* pInstance, long lFlags )
{
    return LoadInstanceProperties(pInstance)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Server::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CDHCP_Server::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    : CDHCP_Server::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_PROVIDER_NOT_CAPABLE, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Server::PutInstance ( const CInstance &Instance, long lFlags)
{
    int     i;
    DWORD   returnCode;
    // the object below is used as a "repository" for all the properties' values.
    // once it is filled up with data, it is commited explicitely to the DHCP Server.
    CDHCP_Server_Parameters ServerParameters;

    for (i = 0; i < NUM_SERVER_PROPERTIES; i++)
    {
        if (DHCP_Server_Property[i].m_pfnActionSet != NULL)
        {
            // execute the SET property action function
            // no data is written to DHCP Server at this moment, only ServerParameters object
            // is filled up with the values taken from the Instance.
            // don't care much here about the error codes. Failure means some properties will
            // not be written. At least we are giving a chance to all the writable properties.
            (*(DHCP_Server_Property[i].m_pfnActionSet))(&ServerParameters, (CInstance *)&Instance, NULL);
        }
    }

    // commit the values of all the writable properties to DHCP Server
    return ServerParameters.CommitSet(returnCode) ? WBEM_S_NO_ERROR : WBEM_E_FAILED;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Server::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_PROVIDER_NOT_CAPABLE from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from DHCP_Server_Scalars.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Server::DeleteInstance ( const CInstance &Instance, long lFlags )
{
	return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Server::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_Server::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
    int     nSetPrefixLen = wcslen(_SRV_SET_PREFIX);

    // is it a "SET" operation?
    if (!_wcsnicmp (bstrMethodName, _SRV_SET_PREFIX, nSetPrefixLen))
    {
        int i;

        WCHAR *wcsPropertyName = bstrMethodName + nSetPrefixLen;    // pointer to the property name

        // scan the DHCP_Server_Property table looking for the property's row
        for (i = 0; i < NUM_SERVER_PROPERTIES; i++)
        {
            // if the property row is found
            if (!_wcsicmp(wcsPropertyName, DHCP_Server_Property[i].m_wsPropName))
            {
                // see if the property is writable 
                if (DHCP_Server_Property[i].m_pfnActionSet != NULL)
                {
                    // execute the SET property action function
                    if ((*(DHCP_Server_Property[i].m_pfnActionSet))(NULL, pInParams, pOutParams))
                        // everything worked fine.
                        return WBEM_S_NO_ERROR;
                    else
                        // an error occured during "SET"
                        return WBEM_E_FAILED;
                }
                else
                    // no, the property cannot be written. (shouldn't really happen, as the methods from the
                    // repository should match the writable properties only)
                    return WBEM_E_READ_ONLY;
            }
        }
    }

    // if this point was reached, no method was found => provider not capable
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}


/*****************************************************************************
*
*  FUNCTION    :	CDHCP_Server::LoadInstanceProperties
*
*  RETURNS     :	TRUE if the values for all the properties was loaded successfully,
*           FALSE otherwise.
*
*  COMMENTS    :    It loops through the Server_Property table, calling the GET functions.
*
*****************************************************************************/
BOOL CDHCP_Server::LoadInstanceProperties(CInstance* pInstance)
{
    int i;

    // there should be used this object, in order to not call several times the DHCP Server API.
    CDHCP_Server_Parameters ServerParameters;

    for (i = 0; i < NUM_SERVER_PROPERTIES; i++)
    {
        // if there is an invisible property (does not support GET) just skip it.
        if (DHCP_Server_Property[i].m_pfnActionGet == NULL)
            continue;

        // call the appropriate GET function, fail if the call fails (there should be no reason for failure)
        if (!(*(DHCP_Server_Property[i].m_pfnActionGet))(&ServerParameters, NULL, pInstance))
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\srvfn.cpp ===
/******************************************************************
   SrvFn.cpp -- Properties action functions (GET/SET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the definition for the action functions associated to
        each manageable property from the class CDHCP_Server

   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "SrvScal.h"    // needed for DHCP_Server_Property[] (for retrieving the property's name, for SET's)
#include "SrvFn.h"      // own header

/*****************************************************************
 *  The definition of the class CDHCP_Server_Parameters
 *****************************************************************/
// by default, all the data structures are NULL (and dw variables are 0'ed)
// those values indicates that no data is cached from the server.
CDHCP_Server_Parameters::CDHCP_Server_Parameters()
{
    m_pMibInfo = NULL;
	m_dwMajor = 0;
	m_dwMinor = 0;
    m_dwConfigInfoV4Flags = 0;
    m_pConfigInfoV4 = NULL;
}

// the DHCP API calls are allocating memory for which the caller is responsible
// to release. We are releasing this memory upon the destruction of this object's instance.
CDHCP_Server_Parameters::~CDHCP_Server_Parameters()
{

    if (m_pMibInfo != NULL)
    {
        if (m_pMibInfo->ScopeInfo != NULL)
            DhcpRpcFreeMemory(m_pMibInfo->ScopeInfo);

        DhcpRpcFreeMemory(m_pMibInfo);
        m_pMibInfo = NULL;
    }

    // LPDHCP_CONFIG_INFO_V4 contains pointers to memory allocated by the DHCP server and
    // which should be released by the caller.
    if (m_pConfigInfoV4!= NULL)
	{
		if (m_pConfigInfoV4->DatabaseName != NULL)
			DhcpRpcFreeMemory(m_pConfigInfoV4->DatabaseName);

		if (m_pConfigInfoV4->DatabasePath != NULL)
			DhcpRpcFreeMemory(m_pConfigInfoV4->DatabasePath);

		if (m_pConfigInfoV4->BackupPath != NULL)
			DhcpRpcFreeMemory(m_pConfigInfoV4->BackupPath);

	    if (m_pConfigInfoV4->wszBootTableString != NULL)
			DhcpRpcFreeMemory(m_pConfigInfoV4->wszBootTableString );

		DhcpRpcFreeMemory(m_pConfigInfoV4);
        m_pConfigInfoV4 = NULL;
	}
}

// DESCRIPTION:
//      Checks the m_pConfigInfoV4 pointer to insure it points to a valid buffer.
//      It allocates the DHCP_SERVER_CONFIG_INFO_V4 if needed, which case it resets the m_dwConfigInfoV4Flags member
BOOL CDHCP_Server_Parameters::CheckExistsConfigPtr()
{
    if (m_pConfigInfoV4 != NULL)
        return TRUE;
    
    m_pConfigInfoV4 = (LPDHCP_SERVER_CONFIG_INFO_V4)MIDL_user_allocate(sizeof(DHCP_SERVER_CONFIG_INFO_V4));

    if (m_pConfigInfoV4 != NULL)
    {
        m_dwConfigInfoV4Flags = 0;
        return TRUE;
    }
    return FALSE;
}

// DESCRIPTION:
//      Provides the data structure filled in through the DhcpGetMibInfo API
//      If this data is cached and the caller is not forcing the refresh,
//      returns the internal cache.
BOOL CDHCP_Server_Parameters::GetMibInfo(LPDHCP_MIB_INFO& MibInfo, BOOL fRefresh)
{
    if (m_pMibInfo == NULL)
        fRefresh = TRUE;

    if (fRefresh)
    {
        MibInfo = NULL;
        if (DhcpGetMibInfo(SERVER_IP_ADDRESS, &MibInfo) != ERROR_SUCCESS)
            return FALSE;
        if (m_pMibInfo != NULL)
            DhcpRpcFreeMemory(m_pMibInfo);
        m_pMibInfo = MibInfo;
    }
    else
        MibInfo = m_pMibInfo;

    return TRUE;
}

// DESCRIPTION:
//      Provides the data structure filled in through the DhcpGetVersion API
//      If this data is cached and the caller is not forcing the refresh,
//      returns the internal cache.
BOOL CDHCP_Server_Parameters::GetVersion(DWORD &Major, DWORD& Minor,  BOOL fRefresh)
{
    if  (m_dwMajor == 0 && m_dwMinor == 0)
        fRefresh = TRUE;
    if (fRefresh)
    {
        if (DhcpGetVersion(SERVER_IP_ADDRESS,&Major,&Minor) != ERROR_SUCCESS)
            return FALSE;
        m_dwMajor = Major;
        m_dwMinor = Minor;
    }
    else
    {
        Major = m_dwMajor;
        Minor = m_dwMinor;
    }

    return TRUE;
}

// DESCRIPTION:
//      Provides the data structure filled in through the DhcpServerGetConfigInfoV4 API
//      If this data is cached and the caller is not forcing the refresh,
//      return the internal cache. Otherwise, the internal cache is refreshed as well.
BOOL CDHCP_Server_Parameters::GetServerConfigInfoV4(LPDHCP_SERVER_CONFIG_INFO_V4& ServerConfigInfoV4, BOOL fRefresh)
{
    if (m_pConfigInfoV4 == NULL)
        fRefresh = TRUE;
    if (fRefresh)
    {
        ServerConfigInfoV4 = NULL;
        if (DhcpServerGetConfigV4(SERVER_IP_ADDRESS, &ServerConfigInfoV4) != ERROR_SUCCESS)
            return FALSE;
        if (m_pConfigInfoV4 != NULL)
            DhcpRpcFreeMemory(m_pConfigInfoV4);
        m_pConfigInfoV4 = ServerConfigInfoV4;
    }
    else
        ServerConfigInfoV4 = m_pConfigInfoV4;

    return TRUE;
}

// DESCRIPTION:
//      Assumes that the internal pointers to the server configuration structures are valid, and filled with
//      the data to be set. Calls the underlying API and returns TRUE (on success) or FALSE (on failure)
BOOL CDHCP_Server_Parameters::CommitSet(DWORD &returnCode)
{
    if (m_pConfigInfoV4 == NULL)
        return FALSE;

    returnCode = DhcpServerSetConfigV4(
                SERVER_IP_ADDRESS,
                m_dwConfigInfoV4Flags,
                m_pConfigInfoV4 );

    return returnCode == ERROR_SUCCESS;
}

/*****************************************************************
 * For all the calls below, is the callers responsibility to release the allocated memory by
 * properly destructing the pServerParams objects. If this param is NULL, the functions will
 * use the static parameter which will be destroyed upon the DLL unload.
 *****************************************************************/

static CDHCP_Server_Parameters backupParameters;

// for any of the functions below, if the caller does not specify a DHCP_Server_Parameters object
// the static 'backupParameters' object will be used instead. In this case, the info is automatically
// retrieved from the lower levels, regardless the cache.
// the macro also convert the generic (void *) pParams to (CDHCP_Server_Parameters *)pServerParams;
#define ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh)   \
    if (pParams == NULL)                                         \
    {                                                            \
        pServerParams = &backupParameters;                       \
        fRefresh = TRUE;                                         \
    }                                                            \
    else                                                         \
    {                                                            \
        pServerParams = (CDHCP_Server_Parameters *)pParams;      \
        fRefresh = FALSE;                                        \
    }
    

MFN_PROPERTY_ACTION_DEFN(fnSrvGetStartTime, pParams, pIn, pOut)
{
    LPDHCP_MIB_INFO           pMibInfo;
    BOOL                      fRefresh;
    CDHCP_Server_Parameters   *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetMibInfo
    if (pServerParams->GetMibInfo(pMibInfo, fRefresh))
    {
        SYSTEMTIME sysTime;
        wchar_t wchBuffer [32];

        // convert the server startup time to a string (UTC) representation.
	    _tzset () ;

        // timezone is offset from UTC in seconds, _daylight is 1 or 0 regarding the DST period
	    LONG  t_Offset = _timezone / 60 - _daylight * 60;
        char  chOffset = t_Offset < 0 ? '+' : '-';
        // take the absolute value from t_Offset
        LONG  t_absOffset = (1 - ((t_Offset < 0)<<1)) * t_Offset;

	    FileTimeToSystemTime((FILETIME *)&(pMibInfo->ServerStartTime), &sysTime);

        // should ensure we have a valid date format (even if inf.)
        if (sysTime.wYear > 9999)
        {
            sysTime.wYear = 9999;
            sysTime.wMonth = 12;
            sysTime.wDay = 31;
            sysTime.wHour = 23;
            sysTime.wMinute = 59;
            sysTime.wSecond = 59;
            sysTime.wMilliseconds = 0;
        }

   		swprintf ( 
			wchBuffer , 
			L"%04ld%02ld%02ld%02ld%02ld%02ld.%06ld%c%03ld" ,
			sysTime.wYear,
			sysTime.wMonth,
			sysTime.wDay,
			sysTime.wHour,
			sysTime.wMinute,
			sysTime.wSecond,
			sysTime.wMilliseconds,
			chOffset,
            t_absOffset
		);

        // set the value of the property into the (CInstance*)pOut
        pOut->SetCHString(DHCP_Server_Property[IDX_SRV_StartTime].m_wsPropName, wchBuffer);

        return TRUE;
    }

    // the API call failed
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetTotalNoOfAcks, pParams, pIn, pOut)
{
    LPDHCP_MIB_INFO             pMibInfo;
    BOOL                        fRefresh;
    CDHCP_Server_Parameters     *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetMibInfo
    if (pServerParams->GetMibInfo(pMibInfo, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_TotalNoOfAcks].m_wsPropName, pMibInfo->Acks);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetTotalNoOfDeclines, pParams, pIn, pOut)
{
    LPDHCP_MIB_INFO             pMibInfo;
    BOOL                        fRefresh;
    CDHCP_Server_Parameters     *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetMibInfo
    if (pServerParams->GetMibInfo(pMibInfo, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_TotalNoOfDeclines].m_wsPropName, pMibInfo->Declines);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetTotalNoOfDiscovers, pParams, pIn, pOut)
{
    LPDHCP_MIB_INFO             pMibInfo;
    BOOL                        fRefresh;
    CDHCP_Server_Parameters     *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetMibInfo
    if (pServerParams->GetMibInfo(pMibInfo, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_TotalNoOfDiscovers].m_wsPropName, pMibInfo->Discovers);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetTotalNoOfNacks, pParams, pIn, pOut)
{
    LPDHCP_MIB_INFO             pMibInfo;
    BOOL                        fRefresh;
    CDHCP_Server_Parameters     *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetMibInfo
    if (pServerParams->GetMibInfo(pMibInfo, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_TotalNoOfNacks].m_wsPropName, pMibInfo->Naks);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetTotalNoOfOffers, pParams, pIn, pOut)
{
    LPDHCP_MIB_INFO             pMibInfo;
    BOOL                        fRefresh;
    CDHCP_Server_Parameters     *pServerParams;
    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetMibInfo
    if (pServerParams->GetMibInfo(pMibInfo, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_TotalNoOfOffers].m_wsPropName, pMibInfo->Offers);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetTotalNoOfReleases, pParams, pIn, pOut)
{
    LPDHCP_MIB_INFO             pMibInfo;
    BOOL                        fRefresh;
    CDHCP_Server_Parameters     *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetMibInfo
    if (pServerParams->GetMibInfo(pMibInfo, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_TotalNoOfReleases].m_wsPropName, pMibInfo->Releases);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetTotalNoOfRequests, pParams, pIn, pOut)
{
    LPDHCP_MIB_INFO             pMibInfo;
    BOOL                        fRefresh;
    CDHCP_Server_Parameters     *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetMibInfo
    if (pServerParams->GetMibInfo(pMibInfo, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_TotalNoOfRequests].m_wsPropName, pMibInfo->Requests);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetServerVersion, pParams, pIn, pOut)
{
    DWORD                       Major, Minor;
    BOOL                        fRefresh;
    CDHCP_Server_Parameters     *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetVersion
    if (pServerParams->GetVersion(Major, Minor, fRefresh))
    {
        wchar_t wchBuffer [16];

        // convert the two DWORD version numbers
        // to a "Major.Minor" string representation
        swprintf (
			wchBuffer,
			L"%lu.%lu",
			Major,
			Minor
		);
        // set the value of the property into the (CInstance*)pOut
        pOut->SetCHString(DHCP_Server_Property[IDX_SRV_ServerVersion].m_wsPropName, wchBuffer);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetAPIProtocol, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_APIProtocol].m_wsPropName, serverConfig->APIProtocolSupport);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetAPIProtocol, pParams, pIn, pOut)
{
    BOOL                            fRefresh;
    DWORD                           newAPIProtocol;
    CDHCP_Server_Parameters         *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetDWORD(DHCP_Server_Property[IDX_SRV_APIProtocol].m_wsPropName, newAPIProtocol))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    pServerParams->m_pConfigInfoV4->APIProtocolSupport = newAPIProtocol;

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_APIProtocolSupport;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the parameter to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_APIProtocolSupport;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetDatabaseName, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetCHString(DHCP_Server_Property[IDX_SRV_DatabaseName].m_wsPropName, serverConfig->DatabaseName);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetDatabaseName, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CHString                        newDatabaseName;
    CDHCP_Server_Parameters         *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetCHString(DHCP_Server_Property[IDX_SRV_DatabaseName].m_wsPropName, newDatabaseName))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    serverConfig = pServerParams->m_pConfigInfoV4;

    // if there is any allocated memory for the DatabaseName, just release it.
    if (serverConfig->DatabaseName != NULL)
		DhcpRpcFreeMemory(serverConfig->DatabaseName);
    
    // allocate memory for the new database name. It has to fit the WCHAR string size.
    serverConfig->DatabaseName = (WCHAR*)MIDL_user_allocate(sizeof(WCHAR)*newDatabaseName.GetLength()+sizeof(WCHAR));

    if (serverConfig->DatabaseName == NULL)
        return FALSE;

    //copy the new database name to server param. It has to be translated to WCHAR
#ifdef _UNICODE
    wcscpy(serverConfig->DatabaseName, newDatabaseName);
#else
    swprintf(serverConfig->DatabaseName, L"%S", newDatabaseName);
#endif

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_DatabaseName;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the DatabaseName to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_DatabaseName;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetDatabasePath, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut        
        pOut->SetCHString(DHCP_Server_Property[IDX_SRV_DatabasePath].m_wsPropName, serverConfig->DatabasePath);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetDatabasePath, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CHString                        newDatabasePath;
    CDHCP_Server_Parameters         *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetCHString(DHCP_Server_Property[IDX_SRV_DatabasePath].m_wsPropName, newDatabasePath))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    serverConfig = pServerParams->m_pConfigInfoV4;

    // if there is any allocated memory for the DatabasePath, just release it.
    if (serverConfig->DatabasePath != NULL)
		DhcpRpcFreeMemory(serverConfig->DatabasePath);
    
    // allocate memory for the new database path. It has to fit the WCHAR string size.
    serverConfig->DatabasePath = (WCHAR*)MIDL_user_allocate(sizeof(WCHAR)*newDatabasePath.GetLength()+sizeof(WCHAR));

    if (serverConfig->DatabasePath == NULL)
        return FALSE;

    //copy the new database path to server param. It has to be translated to WCHAR
#ifdef _UNICODE
    wcscpy(serverConfig->DatabasePath, newDatabasePath);
#else
    swprintf(serverConfig->DatabasePath, L"%S", newDatabasePath);
#endif

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_DatabasePath;

        // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the DatabasePath to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_DatabasePath;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetBackupPath, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetCHString(DHCP_Server_Property[IDX_SRV_BackupPath].m_wsPropName, serverConfig->BackupPath);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetBackupPath, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CHString                        newBackupPath;
    CDHCP_Server_Parameters         *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetCHString(DHCP_Server_Property[IDX_SRV_BackupPath].m_wsPropName, newBackupPath))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    serverConfig = pServerParams->m_pConfigInfoV4;

    // if there is any allocated memory for the BackupPath, just release it.
    if (serverConfig->BackupPath != NULL)
		DhcpRpcFreeMemory(serverConfig->BackupPath);
    
    // allocate memory for the new database path. It has to fit the WCHAR string size.
    serverConfig->BackupPath = (WCHAR*)MIDL_user_allocate(sizeof(WCHAR)*newBackupPath.GetLength()+sizeof(WCHAR));

    if (serverConfig->BackupPath == NULL)
        return FALSE;

    //copy the new database path to server param. It has to be translated to WCHAR
#ifdef _UNICODE
    wcscpy(serverConfig->BackupPath, newBackupPath);
#else
    swprintf(serverConfig->BackupPath, L"%S", newBackupPath);
#endif

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_BackupPath;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the BackupPath to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_BackupPath;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetBackupInterval, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_BackupInterval].m_wsPropName, serverConfig->BackupInterval);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetBackupInterval, pParams, pIn, pOut)
{
    BOOL                        fRefresh;
    DWORD                       newBackupInterval;
    CDHCP_Server_Parameters     *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetDWORD(DHCP_Server_Property[IDX_SRV_BackupInterval].m_wsPropName, newBackupInterval))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    pServerParams->m_pConfigInfoV4->BackupInterval = newBackupInterval;

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_BackupInterval;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the parameter to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_BackupInterval;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetDatabaseLoggingFlag, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_DatabaseLoggingFlag].m_wsPropName, serverConfig->DatabaseLoggingFlag);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetDatabaseLoggingFlag, pParams, pIn, pOut)
{
    BOOL                        fRefresh;
    DWORD                       newDatabaseLoggingFlag;
    CDHCP_Server_Parameters     *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetDWORD(DHCP_Server_Property[IDX_SRV_DatabaseLoggingFlag].m_wsPropName, newDatabaseLoggingFlag))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    pServerParams->m_pConfigInfoV4->DatabaseLoggingFlag = newDatabaseLoggingFlag;

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_DatabaseLoggingFlag;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the parameter to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_DatabaseLoggingFlag;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetRestoreFlag, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_RestoreFlag].m_wsPropName, serverConfig->RestoreFlag);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetRestoreFlag, pParams, pIn, pOut)
{
    BOOL                        fRefresh;
    DWORD                       newRestoreFlag;
    CDHCP_Server_Parameters     *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetDWORD(DHCP_Server_Property[IDX_SRV_RestoreFlag].m_wsPropName, newRestoreFlag))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    pServerParams->m_pConfigInfoV4->RestoreFlag = newRestoreFlag;

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_RestoreFlag;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the parameter to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_RestoreFlag;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetDatabaseCleanupInterval, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_DatabaseCleanupInterval].m_wsPropName, serverConfig->DatabaseCleanupInterval);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetDatabaseCleanupInterval, pParams, pIn, pOut)
{
    BOOL                        fRefresh;
    DWORD                       newDatabaseCleanupInterval;
    CDHCP_Server_Parameters     *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetDWORD(DHCP_Server_Property[IDX_SRV_DatabaseCleanupInterval].m_wsPropName, newDatabaseCleanupInterval))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    pServerParams->m_pConfigInfoV4->DatabaseCleanupInterval = newDatabaseCleanupInterval;

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_DatabaseCleanupInterval;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the parameter to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_DatabaseCleanupInterval;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetDebugFlag, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_DebugFlag].m_wsPropName, serverConfig->DebugFlag);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetDebugFlag, pParams, pIn, pOut)
{
    BOOL                        fRefresh;
    DWORD                       newDebugFlag;
    CDHCP_Server_Parameters     *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetDWORD(DHCP_Server_Property[IDX_SRV_DebugFlag].m_wsPropName, newDebugFlag))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    pServerParams->m_pConfigInfoV4->DebugFlag = newDebugFlag;

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_DebugFlag;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the parameter to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_DebugFlag;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetPingRetries, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->SetDWORD(DHCP_Server_Property[IDX_SRV_PingRetries].m_wsPropName, serverConfig->dwPingRetries);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetPingRetries, pParams, pIn, pOut)
{
    BOOL                        fRefresh;
    DWORD                       newPingRetries;
    CDHCP_Server_Parameters     *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetDWORD(DHCP_Server_Property[IDX_SRV_PingRetries].m_wsPropName, newPingRetries))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    pServerParams->m_pConfigInfoV4->dwPingRetries = newPingRetries;

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_PingRetries;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the parameter to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_PingRetries;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetBootFileTable, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        WCHAR *wcpTemp = serverConfig->wszBootTableString;
        DWORD dwTemp = serverConfig->cbBootTableString / sizeof(WCHAR);

        // convert the BootFileTable string array to one single array
        while(dwTemp--)
        {
            if (dwTemp != 0 && *wcpTemp == L'\0')
                *wcpTemp = L';';
            wcpTemp++;
        }
        
        // set the value of the property into the (CInstance*)pOut
        pOut->SetCHString(DHCP_Server_Property[IDX_SRV_BootFileTable].m_wsPropName, serverConfig->wszBootTableString);

        // convert back the single string to BootFileTable string array (less costy than alloc/copy/free)
        dwTemp = serverConfig->cbBootTableString;
        wcpTemp = serverConfig->wszBootTableString;
        while(dwTemp--)
        {
            if (dwTemp != 0 && *wcpTemp == L';')
                *wcpTemp = L'\0';
            wcpTemp++;
        }

        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetBootFileTable, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;
    CHString                        newBootFileTable;
    DWORD                           dwTemp;
    WCHAR                           *wcpTemp;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->GetCHString(DHCP_Server_Property[IDX_SRV_BootFileTable].m_wsPropName, newBootFileTable))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    serverConfig = pServerParams->m_pConfigInfoV4;

    // if there is any allocated memory for the BackupPath, just release it.
    if (serverConfig->wszBootTableString != NULL)
		DhcpRpcFreeMemory(serverConfig->wszBootTableString);
    
    // allocate memory for the new database path. It has to fit the WCHAR string size.
    serverConfig->wszBootTableString = (WCHAR*)MIDL_user_allocate(sizeof(WCHAR)*newBootFileTable.GetLength()+sizeof(WCHAR));

    if (serverConfig->wszBootTableString == NULL)
        return FALSE;

    //copy the new database path to server param. It has to be translated to WCHAR
#ifdef _UNICODE
    wcscpy(serverConfig->wszBootTableString, newBootFileTable);
#else
    swprintf(serverConfig->wszBootTableString, L"%S", newBootFileTable);
#endif

    dwTemp = wcslen(serverConfig->wszBootTableString) + 1;
    wcpTemp = serverConfig->wszBootTableString;
    serverConfig->cbBootTableString = dwTemp * sizeof(WCHAR);

    // convert the one single string to the BootTableString array
    while(dwTemp--)
    {
        if (dwTemp && *wcpTemp == L';')
            *wcpTemp = L'\0';
        wcpTemp++;
    }

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_BootFileTable;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
        if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the BackupPath to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_BootFileTable;
    }

    return TRUE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvGetAuditLog, pParams, pIn, pOut)
{
    LPDHCP_SERVER_CONFIG_INFO_V4    serverConfig;
    BOOL                            fRefresh;
    CDHCP_Server_Parameters         *pServerParams;

    if (pOut == NULL)
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // call the DHCP api through the DHCP_Server_Parameter::GetServerConfigInfoV4
    if (pServerParams->GetServerConfigInfoV4(serverConfig, fRefresh))
    {
        // set the value of the property into the (CInstance*)pOut
        pOut->Setbool(DHCP_Server_Property[IDX_SRV_AuditLog].m_wsPropName, serverConfig->fAuditLog);
        return TRUE;
    }
    return FALSE;
}

MFN_PROPERTY_ACTION_DEFN(fnSrvSetAuditLog, pParams, pIn, pOut)
{
    BOOL                        fRefresh;
    bool                        newAuditLog;
    CDHCP_Server_Parameters     *pServerParams;

    // somehow the property we are expecting does not exist in CInstance *pIn
    if (pIn == NULL || !pIn->Getbool(DHCP_Server_Property[IDX_SRV_AuditLog].m_wsPropName, newAuditLog))
        return FALSE;

    // after this call, pServerParams will surely be not-NULL
    ADJUST_SERVER_PARAMS(pParams, pServerParams, fRefresh);

    // if there isn't any ConfigInfoV4 structure in the pServerParams, just allocate one, and reset the m_pConfigInfoV4Flags
    if (!pServerParams->CheckExistsConfigPtr())
            return FALSE;

    pServerParams->m_pConfigInfoV4->fAuditLog = newAuditLog;

    // if fRefresh -> working on backupParameters -> we are going to commit the changes
    if (fRefresh)
    {
        DWORD returnCode;

        // this is the only field we are changing.
        pServerParams->m_dwConfigInfoV4Flags = Set_AuditLogState;

         // commit the changes now!
        pServerParams->CommitSet(returnCode);

        // save the output parameter
         if (pOut != NULL)
            pOut->SetDWORD(RETURN_CODE_PROPERTY_NAME, returnCode);
    }
    else
    {
        // we are working on supplied DHCP_Server_Parameter -> changes are commited by the caller,
        // we only add the parameter to the fields that are going to be commited.
        pServerParams->m_dwConfigInfoV4Flags |= Set_AuditLogState;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\sscofn.cpp ===
/******************************************************************
   SNetFn.cpp -- Properties action functions (GET/SET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the definition for the action functions associated to
        each manageable property from the class CDHCP_Server

   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "SScoScal.h"    // needed for DHCP_SuperScope_Property[] (for retrieving the property's name, for SET's)
#include "SScoFn.h"      // own header


static UINT  g_uSortFlags;
int __cdecl sortHandler(const void* elem1, const void* elem2)
{
    LPDHCP_SUPER_SCOPE_TABLE_ENTRY entry1, entry2;

    entry1 = *((LPDHCP_SUPER_SCOPE_TABLE_ENTRY*)elem1);
    entry2 = *((LPDHCP_SUPER_SCOPE_TABLE_ENTRY*)elem2);

    switch (g_uSortFlags)
    {
    case ENTRIES_SORTED_ON_SUPER_SCOPE:
        return entry1->SuperScopeNumber - entry2->SuperScopeNumber;
    case ENTRIES_SORTED_ON_SUBNET:
        return entry1->SubnetAddress - entry2->SubnetAddress;
    }
    return 0;
}

// DESCRIPTION:
//      Frees the memory allocated for the tables
void CDHCP_SuperScope_Parameters::CleanupTable()
{
   if (m_pSuperScopeTable != NULL)
    {
        if (m_pSuperScopeTable->cEntries > 0)
        {
            do
            {
                DhcpRpcFreeMemory(m_pSuperScopeTable->pEntries[--(m_pSuperScopeTable->cEntries)].SuperScopeName);
            } while (m_pSuperScopeTable->cEntries > 0);
            
            DhcpRpcFreeMemory(m_pSuperScopeTable->pEntries);
        }

        DhcpRpcFreeMemory(m_pSuperScopeTable);
        m_pSuperScopeTable = NULL;

        DhcpRpcFreeMemory(m_pSortedEntries);
        m_pSortedEntries = NULL;
    }
}

// DESCRIPTION:
//      Class constructor. All internal variables are NULL, no data is cached
CDHCP_SuperScope_Parameters::CDHCP_SuperScope_Parameters( const WCHAR *wcsSuperScopeName )
{
    m_pSuperScopeTable = NULL;
    m_pSortedEntries = NULL;
    m_wcsSuperScopeName = wcsSuperScopeName != NULL ? _wcsdup(wcsSuperScopeName) : NULL;
}

CDHCP_SuperScope_Parameters::CDHCP_SuperScope_Parameters(const CHString & str)
{
    m_pSuperScopeTable = NULL;
    m_pSortedEntries = NULL;

    m_wcsSuperScopeName = (WCHAR *)MIDL_user_allocate(sizeof(WCHAR)*str.GetLength() + sizeof(WCHAR));

    if (m_wcsSuperScopeName != NULL)
    {
#ifdef _UNICODE
        wcscpy(m_wcsSuperScopeName, str);
#else
        swprintf(m_wcsSuperScopeName, L"%S", str);
#endif
    }
}

// DESCRIPTION:
//      Class destructor. All internal variables are released, if they are not null
CDHCP_SuperScope_Parameters::~CDHCP_SuperScope_Parameters()
{
    CleanupTable();

    if (m_wcsSuperScopeName != NULL)
        DhcpRpcFreeMemory(m_wcsSuperScopeName);
}

BOOL CDHCP_SuperScope_Parameters::ExistsSuperScope (BOOL fRefresh)
{
    LPDHCP_SUPER_SCOPE_TABLE pSuperScopes;

    if (!GetSuperScopes(pSuperScopes, fRefresh))
        return FALSE;

    for (int i=0; i<pSuperScopes->cEntries; i++)
    {
        // cover the NULL case
        if (m_wcsSuperScopeName == pSuperScopes->pEntries[i].SuperScopeName)
            return TRUE;
        // make sure there is something to compare on both sides
        if (m_wcsSuperScopeName == NULL || pSuperScopes->pEntries[i].SuperScopeName == NULL)
            continue;
        // check if this is the same super scope name
        if (wcscmp(m_wcsSuperScopeName, pSuperScopes->pEntries[i].SuperScopeName) == 0)
            return TRUE;
    }
    return FALSE;
}

// DESCRIPTION:
//      Provides the data structure filled in through the DhcpGetSuperScopeInfoV4 API
//      If this data is cached and the caller is not forcing the refresh,
//      return the internal cache. Otherwise, the internal cache is refreshed as well.
BOOL CDHCP_SuperScope_Parameters::GetSuperScopes(LPDHCP_SUPER_SCOPE_TABLE & pSuperScopes, BOOL fRefresh)
{
    if (m_pSuperScopeTable == NULL)
        fRefresh = TRUE;

    if (fRefresh)
    {
        // just make sure everything is cleaned up before getting new info from server
        CleanupTable();

        // call the server for getting the super scope info
        if (DhcpGetSuperScopeInfoV4(SERVER_IP_ADDRESS, &m_pSuperScopeTable) != ERROR_SUCCESS)
            return FALSE;

        // allocate and initialize the sorted entry array of pointers
        m_pSortedEntries = (LPDHCP_SUPER_SCOPE_TABLE_ENTRY *)
                           MIDL_user_allocate(m_pSuperScopeTable->cEntries * sizeof(LPDHCP_SUPER_SCOPE_TABLE_ENTRY));

        if (m_pSortedEntries == NULL)
            return FALSE;

        for (int i = 0; i < m_pSuperScopeTable->cEntries; i++)
            m_pSortedEntries[i] = &(m_pSuperScopeTable->pEntries[i]);
    }

	pSuperScopes = m_pSuperScopeTable;

	return TRUE;
}

BOOL CDHCP_SuperScope_Parameters::GetSortedScopes(UINT sortFlags, LPDHCP_SUPER_SCOPE_TABLE_ENTRY * & pSortedEntries, DWORD &dwNumEntries)
{
    if (m_pSuperScopeTable == NULL)
        return FALSE;

    g_uSortFlags = sortFlags;

    qsort(m_pSortedEntries,
          m_pSuperScopeTable->cEntries,
          sizeof(LPDHCP_SUPER_SCOPE_TABLE_ENTRY),
          sortHandler);

    pSortedEntries = m_pSortedEntries;
    dwNumEntries = m_pSuperScopeTable->cEntries;

    return TRUE;
}

BOOL CDHCP_SuperScope_Parameters::AlterSubnetSet(DHCP_IP_ADDRESS subnetAddress)
{
    LPDHCP_SUPER_SCOPE_TABLE pSuperScopes;

    return DhcpSetSuperScopeV4(SERVER_IP_ADDRESS, subnetAddress, m_wcsSuperScopeName, TRUE) == ERROR_SUCCESS;
}

BOOL CDHCP_SuperScope_Parameters::DeleteSuperScope()
{
    LPDHCP_SUPER_SCOPE_TABLE    pSuperScopes;
    DWORD                       retCode;

    return(m_wcsSuperScopeName != NULL &&
           DhcpDeleteSuperScopeV4(SERVER_IP_ADDRESS, m_wcsSuperScopeName) == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\stdafx.h ===
#include <fwcommon.h>
#include <provider.h>
#include <instance.h>
#include <windows.h>
extern "C"
{
#include <dhcpapi.h>
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\dll\sscoscal.cpp ===
/******************************************************************
   SNetScal.cpp -- WBEM provider class implementation

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains: the definition of the DHCP_SuperScope class,
        the static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include <stdafx.h>

#include "SScoFn.h"     // needed for the declarations of all the functions.
#include "SScoScal.h"   // own header

// the name of the WBEM class
#define PROVIDER_NAME_DHCP_SUPERSCOPE       "DHCP_SuperScope"

#define PROP_SScope_Name    L"Name"

// main class instantiation.
CDHCP_SuperScope MyDHCP_SuperScope_Scalars (PROVIDER_NAME_DHCP_SUPERSCOPE, PROVIDER_NAMESPACE_DHCP) ;

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_SuperScope::CDHCP_SuperScope
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CDHCP_SuperScope::CDHCP_SuperScope (const CHString& strName, LPCSTR pszNameSpace ) :
	Provider(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CDHCP_SuperScope::~CDHCP_SuperScope
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CDHCP_SuperScope::~CDHCP_SuperScope ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_SuperScope::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    Enumerates all this instances of this class. As there is only one
*                   DHCP Server per system, there is only one instance for this class
*
*****************************************************************************/
HRESULT CDHCP_SuperScope::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    CDHCP_SuperScope_Parameters     SuperScopeParams(NULL); // don't know here the scope
    HRESULT                         hRes = WBEM_E_FAILED;
    
    LPDHCP_SUPER_SCOPE_TABLE        pScopesTable;
	LPDHCP_SUPER_SCOPE_TABLE_ENTRY  *pSortedEntries = NULL ;
    DWORD                           dwNumEntries;

    if (SuperScopeParams.GetSuperScopes(pScopesTable, TRUE) &&
        SuperScopeParams.GetSortedScopes(ENTRIES_SORTED_ON_SUPER_SCOPE, pSortedEntries, dwNumEntries))
    {
        for (int i = 0; i<dwNumEntries; i++)
        {
            if(pSortedEntries[i]->SuperScopeName != NULL &&
               (i == 0 || pSortedEntries[i]->SuperScopeNumber != pSortedEntries[i-1]->SuperScopeNumber))
            {
                CInstance *pInstance = CreateNewInstance(pMethodContext);  // create now the instance;

                if (pInstance != NULL)
                {
                    pInstance->SetCHString(PROP_SScope_Name, pSortedEntries[i]->SuperScopeName);
                    hRes = Commit(pInstance);
                    if (hRes != WBEM_S_NO_ERROR)
                        break;
                }
            }
        }
    }

    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_SuperScope::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    :
*
*****************************************************************************/
HRESULT CDHCP_SuperScope::GetObject ( CInstance* pInstance, long lFlags )
{
    CHString    str;

    if (pInstance->GetCHString(PROP_SScope_Name, str))
    {
        CDHCP_SuperScope_Parameters SuperScopeParams(str);

        if (SuperScopeParams.ExistsSuperScope())
        {
            return WBEM_S_NO_ERROR;
        }
    }
    return WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_SuperScope::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CDHCP_SuperScope::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*****************************************************************************
*
*  FUNCTION    : CDHCP_SuperScope::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_PROVIDER_NOT_CAPABLE, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_SuperScope::PutInstance ( const CInstance &Instance, long lFlags)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_SuperScope::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_PROVIDER_NOT_CAPABLE from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from DHCP_Server_Scalars.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_SuperScope::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    CHString    str;

    if (Instance.GetCHString(PROP_SScope_Name, str))
    {
        CDHCP_SuperScope_Parameters SuperScopeParams(str);

        if (SuperScopeParams.DeleteSuperScope())
        {
            return WBEM_S_NO_ERROR;
        }
    }
    return WBEM_E_FAILED;
}

/*****************************************************************************
*
*  FUNCTION    :	CDHCP_SuperScope::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CDHCP_SuperScope::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\lsfn.h ===
/******************************************************************
   LsFn.h -- Properties action functions declarations (GET/SET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the CDHCP_Lease_Parameters class, modeling all
        the datastructures used to retrieve the information from the DHCP Client.
        Contains the declarations for the action functions associated to
        each manageable property from the class CDHCP_Server

   REVISION:
        08/14/98 - created

******************************************************************/
#include "Props.h"          // needed for MFN_PROPERTY_ACTION_DECL definition

#ifndef _LSFN_H
#define _LSFN_H

#ifdef NT5
#define LPCLIENT_INFO_ARRAY     LPDHCP_CLIENT_INFO_ARRAY_V5
#define LPCLIENT_INFO           LPDHCP_CLIENT_INFO_V5
#define CLIENT_INFO             DHCP_CLIENT_INFO_V5
#else if NT4
#define LPCLIENT_INFO_ARRAY     LPDHCP_CLIENT_INFO_ARRAY_V4
#define LPCLIENT_INFO           LPDHCP_CLIENT_INFO_V4
#define CLIENT_INFO             DHCP_CLIENT_INFO_V4
#endif

// gathers the data structures needed for retrieving data from the DHCP Lease.
class CDHCP_Lease_Parameters
{
private:
    void DeleteClientInfo(LPCLIENT_INFO& pClientInfo);
    void DeleteClientInfoArray(LPCLIENT_INFO_ARRAY& pClientInfoArray);

public:
    DHCP_IP_ADDRESS             m_dwSubnetAddress;
    DHCP_IP_ADDRESS             m_dwClientAddress;

    LPCLIENT_INFO_ARRAY         m_pClientInfoArray;
    LPCLIENT_INFO               m_pClientInfo;
    LPCLIENT_INFO               m_pClientSetInfo;

    CDHCP_Lease_Parameters(DHCP_IP_ADDRESS dwSubnetAddress, DHCP_IP_ADDRESS dwClientAddress);
    ~CDHCP_Lease_Parameters();

    BOOL NextSubnetClients(DHCP_RESUME_HANDLE ResumeHandle);

    BOOL GetClientInfoFromCache(LPCLIENT_INFO& pClientInfo);
    BOOL GetClientInfo(LPCLIENT_INFO& pClientInfo, BOOL fRefresh);

    BOOL CheckExistsSetInfoPtr();

    BOOL CommitSet(DWORD & errCode);
};

// GET function for the (RO)"Subnet" property
MFN_PROPERTY_ACTION_DECL(fnLsGetSubnet);

// GET function for the (RO)"Address" property
MFN_PROPERTY_ACTION_DECL(fnLsGetAddress);

// GET function for the (RO) "Mask" property
MFN_PROPERTY_ACTION_DECL(fnLsGetMask);

// GET function for the (RW)"UniqueClientIdentifier" property
MFN_PROPERTY_ACTION_DECL(fnLsGetHdwAddress);

// SET function for the (RW)"UniqueClientIdentifier" property
MFN_PROPERTY_ACTION_DECL(fnLsSetHdwAddress);

// GET function for the (RW)"Name" property
MFN_PROPERTY_ACTION_DECL(fnLsGetName);

// SET function for the (RW)"Name" property
MFN_PROPERTY_ACTION_DECL(fnLsSetName);

// GET function for the (RW)"Comment" property
MFN_PROPERTY_ACTION_DECL(fnLsGetComment);

// SET function for the (RW)"Comment" property
MFN_PROPERTY_ACTION_DECL(fnLsSetComment);

// GET function for the (RO)"LeaseExpiryDate" property
MFN_PROPERTY_ACTION_DECL(fnLsGetExpiry);

// GET function for the (RW)"Type" property
MFN_PROPERTY_ACTION_DECL(fnLsGetType);

// SET function for the (RW)"Type" property
MFN_PROPERTY_ACTION_DECL(fnLsSetType);

#ifdef NT5
// GET function for the (RO)"State" property
MFN_PROPERTY_ACTION_DECL(fnLsGetState);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\anetrng.h ===
/******************************************************************
   SNetScal.h -- WBEM provider class declaration

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the DHCP_Subnet_Scalar class and
        the indices definitions for its static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include "Props.h"      // needed for CDHCP_Property definition

#ifndef _ANETRGN_H
#define _ANETRGN_H

#define PROP_ANetRange_Subnet   L"Subnet"
#define PROP_ANetRange_Range    L"Range"

class CDHCP_AssociationSubnetToRange : public Provider 
{
	private:
        DWORD m_dwRangeType;

	protected:
		// Reading Functions
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );
   
    public:
		// Constructor/destructor
		CDHCP_AssociationSubnetToRange(const CHString& chsClassName, LPCSTR lpszNameSpace, DWORD dwRangeType);
		virtual ~CDHCP_AssociationSubnetToRange();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\anetlea.h ===
/******************************************************************
   SNetScal.h -- WBEM provider class declaration

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the DHCP_Subnet_Scalar class and
        the indices definitions for its static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include "Props.h"      // needed for CDHCP_Property definition

#ifndef _ANETLEA_H
#define _ANETLEA_H

class CDHCP_AssociationSubnetToLease : public Provider 
{
	private:
        // Loader function for the properties values.
        BOOL LoadInstanceProperties(CInstance* pInstance);

	protected:
		// Reading Functions
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );
   
    public:
		// Constructor/destructor
		CDHCP_AssociationSubnetToLease(const CHString& chsClassName, LPCSTR lpszNameSpace);
		virtual ~CDHCP_AssociationSubnetToLease();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\ascoscal.h ===
/******************************************************************
   SNetScal.h -- WBEM provider class declaration

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the DHCP_Subnet_Scalar class and
        the indices definitions for its static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include "Props.h"      // needed for CDHCP_Property definition

#ifndef _ASCOSCAL_H
#define _ASCOSCAL_H

class CDHCP_SuperScopeToSubnet : public Provider 
{
	protected:
		// Reading Functions
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );
    public:
		// Constructor/destructor
		CDHCP_SuperScopeToSubnet(const CHString& chsClassName, LPCSTR lpszNameSpace);
		virtual ~CDHCP_SuperScopeToSubnet();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\anetres.h ===
/******************************************************************
   SNetScal.h -- WBEM provider class declaration

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the DHCP_Subnet_Scalar class and
        the indices definitions for its static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include "Props.h"      // needed for CDHCP_Property definition

#ifndef _ANETRES_H
#define _ANETRES_H

class CDHCP_AssociationSubnetToReservation : public Provider 
{
	private:
        // Loader function for the properties values.
        BOOL LoadInstanceProperties(CInstance* pInstance);

	protected:
		// Reading Functions
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);

		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );
   
    public:
		// Constructor/destructor
		CDHCP_AssociationSubnetToReservation(const CHString& chsClassName, LPCSTR lpszNameSpace);
		virtual ~CDHCP_AssociationSubnetToReservation();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\lsscal.h ===
/******************************************************************
   LsScal.h -- WBEM provider class declaration

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the DHCP_Lease class and
        the indices definitions for its static table of manageable objects.

   REVISION:
        08/14/98 - created

******************************************************************/
#include "Props.h"      // needed for CDHCP_Property definition

#ifndef _LSSCAL_H
#define _LSSCAL_H

// indices for the DHCP_Lease_Property static table (defined in LsScal.cpp)
#define IDX_Ls_Subnet                 0
#define IDX_Ls_Address                1
#define IDX_Ls_SubnetMask             2
#define IDX_Ls_UniqueClientIdentifier 3
#define IDX_Ls_Name                   4
#define IDX_Ls_Comment                5
#define IDX_Ls_LeaseExpiryDate        6
#define IDX_Ls_Type                   7
#define IDX_Ls_State                  8

class CDHCP_Lease_Parameters;

// external definition for the static table of manageable objects (properties)
extern const CDHCP_Property  DHCP_Lease_Property[];

// the number of entries into the DHCP_Subnet_Property static table
#define NUM_LEASE_PROPERTIES       (sizeof(DHCP_Lease_Property)/sizeof(CDHCP_Property))

class CDHCP_Lease : public Provider 
{
	protected:
        // Loader function for the properties values.
        BOOL LoadInstanceProperties(CInstance* pInstance);

        // Loader function for the properties values, which returns the key info from the pInstance;
        BOOL LoadInstanceProperties(CInstance* pInstance, DWORD &dwSubnet, DWORD &dwAddress);

        // Loader function for the lease parameters;
        BOOL LoadLeaseParams(CDHCP_Lease_Parameters *pLeaseParams, CInstance *pInstance);

		// Reading Functions
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );
    public:
		// Constructor/destructor
		CDHCP_Lease(const CHString& chsClassName, LPCSTR lpszNameSpace);
		virtual ~CDHCP_Lease();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\snetscal.h ===
/******************************************************************
   SNetScal.h -- WBEM provider class declaration

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the DHCP_Subnet_Scalar class and
        the indices definitions for its static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include "Props.h"      // needed for CDHCP_Property definition

#ifndef _SNETSCAL_H
#define _SNETSCAL_H

// indices for the DHCP_Subnet_Property static table (defined in SrvScal.cpp)
#define IDX_SNET_Address                0
#define IDX_SNET_Mask                   1
#define IDX_SNET_Name                   2
#define IDX_SNET_Comment                3
#define IDX_SNET_State                  4
#define IDX_SNET_NbAddrInUse            5
#define IDX_SNET_NbAddrFree             6
#define IDX_SNET_NbPendingOffers        7

// external definition for the static table of manageable objects (properties)
extern const CDHCP_Property  DHCP_Subnet_Property[];

// the number of entries into the DHCP_Subnet_Property static table
#define NUM_SUBNET_PROPERTIES       (sizeof(DHCP_Subnet_Property)/sizeof(CDHCP_Property))

class CDHCP_Subnet : public Provider 
{
	private:
        // Loader function for the properties values.
        BOOL LoadInstanceProperties(CInstance* pInstance);

	protected:
		// Reading Functions
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );
    public:
		// Constructor/destructor
		CDHCP_Subnet(const CHString& chsClassName, LPCSTR lpszNameSpace);
		virtual ~CDHCP_Subnet();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\resscal.h ===
/******************************************************************
   LsScal.h -- WBEM provider class declaration

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the DHCP_Reservation class and
        the indices definitions for its static table of manageable objects.

   REVISION:
        08/14/98 - created

******************************************************************/
#include "Props.h"      // needed for CDHCP_Property definition
#include "LsScal.h"

#ifndef _RESSCAL_H
#define _RESSCAL_H

// indices for the DHCP_Reservation_Property static table (defined in ResScal.cpp)
//#define IDX_Res_Subnet                 0
//#define IDX_Res_Address                1
//#define IDX_Res_UniqueClientIdentifier 2
#define IDX_Res_ReservationType         0

// external definition for the static table of manageable objects (properties)
extern const CDHCP_Property  DHCP_Reservation_Property[];

// the number of entries into the DHCP_Subnet_Property static table
#define NUM_RESERVATION_PROPERTIES       (sizeof(DHCP_Reservation_Property)/sizeof(CDHCP_Property))

class CDHCP_Reservation : public CDHCP_Lease 
{
	private:
        // Loader function for the properties values.
        BOOL LoadInstanceProperties(CInstance* pInstance);

	protected:
		// Reading Functions
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );
    public:
		// Constructor/destructor
		CDHCP_Reservation(const CHString& chsClassName, LPCSTR lpszNameSpace);
		virtual ~CDHCP_Reservation();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\rngfn.h ===
/******************************************************************
   ResFn.h -- Properties action functions declarations (GET/SET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the CDHCP_Reservation_Parameters class, modeling all
        the datastructures used to retrieve the information from the DHCP Reservation.
        Contains the declarations for the action functions associated to
        each manageable property from the class CDHCP_Server

   REVISION:
        08/14/98 - created

******************************************************************/

#include "Props.h"          // needed for MFN_PROPERTY_ACTION_DECL definition

#ifndef _RNGFN_H
#define _RNGFN_H

// gathers the data structures needed for retrieving data from the DHCP Lease.
class CDHCP_Range_Parameters
{
private:
    void DeleteRangeInfoArray(LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4& pRangeInfoArray);

public:
    DHCP_IP_ADDRESS                     m_dwSubnet;
    DHCP_IP_ADDRESS                     m_dwStartAddress;
    DHCP_IP_ADDRESS                     m_dwEndAddress;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 m_pRangeInfoArray;

    CDHCP_Range_Parameters(
        DHCP_IP_ADDRESS dwSubnet,
        DHCP_IP_ADDRESS dwStartAddress = 0,
        DHCP_IP_ADDRESS dwEndAddress = 0);

    ~CDHCP_Range_Parameters();

    DWORD NextSubnetRange(DHCP_RESUME_HANDLE & hResume, DHCP_SUBNET_ELEMENT_TYPE rangeType);
    BOOL CheckExistsRangeInCache(DHCP_SUBNET_ELEMENT_TYPE rangeType);
    BOOL CheckExistsRange(DHCP_SUBNET_ELEMENT_TYPE rangeType);

    BOOL CreateRange(DHCP_SUBNET_ELEMENT_TYPE rangeType);
    BOOL DeleteRange(DHCP_SUBNET_ELEMENT_TYPE rangeType);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\resfn.h ===
/******************************************************************
   ResFn.h -- Properties action functions declarations (GET/SET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the CDHCP_Reservation_Parameters class, modeling all
        the datastructures used to retrieve the information from the DHCP Reservation.
        Contains the declarations for the action functions associated to
        each manageable property from the class CDHCP_Server

   REVISION:
        08/14/98 - created

******************************************************************/
#include "Props.h"          // needed for MFN_PROPERTY_ACTION_DECL definition

#ifndef _RESFN_H
#define _RESFN_H

#define RESERVATION_CAST (LPDHCP_IP_RESERVATION_V4)

class CDHCP_Lease_Parameters;

// gathers the data structures needed for retrieving data from the DHCP Lease.
class CDHCP_Reservation_Parameters
{
private:
    void DeleteReservationInfo(LPDHCP_IP_RESERVATION_V4& pReservationInfo);
    void DeleteReservationInfoArray(LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4& pReservationInfoArray);

public:
    DHCP_IP_ADDRESS                     m_dwSubnetAddress;
    DHCP_IP_ADDRESS                     m_dwReservationAddress;
	LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 m_pReservationInfoArray;
	LPDHCP_SUBNET_ELEMENT_DATA_V4       m_pReservationInfo ;

    CDHCP_Reservation_Parameters(DHCP_IP_ADDRESS dwSubnetAddress, DHCP_IP_ADDRESS dwReservationAddress);
    ~CDHCP_Reservation_Parameters();

    BOOL GetKeyInfoFromLease(CDHCP_Lease_Parameters *pLeaseParams);
    LONG NextSubnetReservation(DHCP_RESUME_HANDLE ResumeHandle);
    BOOL GetReservationInfoFromCache(LPDHCP_IP_RESERVATION_V4& pReservationInfo);
    BOOL GetReservationInfo(LPDHCP_IP_RESERVATION_V4& pReservationInfo, BOOL fRefresh);

	BOOL CheckExistsInfoPtr();
    BOOL CommitNew(DWORD &returnCode);
    BOOL DeleteReservation();
};

/*
// GET function for the (RO)"Subnet" property
MFN_PROPERTY_ACTION_DECL(fnResGetSubnet);

// GET function for the (RO)"Address" property
MFN_PROPERTY_ACTION_DECL(fnResGetAddress);

// SET function for the (CREATE)"Address" property
MFN_PROPERTY_ACTION_DECL(fnResSetAddress);

// GET function for the (RO)"UniqueReservationIdentifier" property
MFN_PROPERTY_ACTION_DECL(fnResGetHdwAddress);

// SET function for the (CREATE)"UniqueReservationIdentifier" property
MFN_PROPERTY_ACTION_DECL(fnResSetHdwAddress);
*/
// GET function for the (RO)"ReservationType" property
MFN_PROPERTY_ACTION_DECL(fnResGetReservationType);

// SET function for the (Create)"ReservationType" property
MFN_PROPERTY_ACTION_DECL(fnResSetReservationType);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\props.h ===
/******************************************************************
   SrvProp.h -- Properties functions and class declarations

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains macros and declaration for the properties action function type.
        Contains the declaration of the class modeling the DHCP_Server property.


   REVISION:
        08/03/98 - created

******************************************************************/

#ifndef _PROPS_H
#define _PROPS_H

//------------General Definitions--------------------
#define PROVIDER_NAMESPACE_DHCP         "root\\dhcp"
#define SERVER_IP_ADDRESS	            L"127.0.0.1"

//------------General Utility functions--------------
BOOL inet_wstodw(CHString str, DHCP_IP_ADDRESS & IpAddress);
BOOL dupDhcpBinaryData(DHCP_BINARY_DATA &src, DHCP_BINARY_DATA &dest);
BOOL InstanceSetByteArray(CInstance *pInstance,  const CHString& name, BYTE *bArray, DWORD dwSzArray);
BOOL InstanceGetByteArray(CInstance *pInstance,  const CHString& name, BYTE *&bArray, DWORD &dwSzArray);

// this is a default DWORD property of the "out" CInstance
#define RETURN_CODE_PROPERTY_NAME       "ReturnValue"

// macro for declaration of the property action functions (imposed prototype)
#define MFN_PROPERTY_ACTION_DECL(fnName)    \
    BOOL fnName(void *,                     \
                CInstance *,                \
                CInstance *)

// macro for the definition of the property action functions (imposed prototype)
#define MFN_PROPERTY_ACTION_DEFN(fnName, pServerParams, pIn, pOut)  \
    BOOL fnName(void *pServerParams,                                \
                CInstance *pIn,                                     \
                CInstance *pOut)

// property action function type
typedef BOOL (*PFN_PROPERTY_ACTION)(void *pServerParams, CInstance *pIn, CInstance *pOut);

// general class defining the DHCP_Server property.
// the DHCP_Server_Property static table (defined in SrvScal.cpp) is made up by instances of this class
class CDHCP_Property
{
public:
    WCHAR                   *m_wsPropName;      // property name
    PFN_PROPERTY_ACTION     m_pfnActionGet;     // pointer to GET action function 
    PFN_PROPERTY_ACTION     m_pfnActionSet;     // pointer to SET action function

    // constructor
    CDHCP_Property(const WCHAR *wsPropName, const PFN_PROPERTY_ACTION pfnActionGet, const PFN_PROPERTY_ACTION pfnActionSet);

    // destructor
    virtual ~CDHCP_Property();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\rngscal.h ===
/******************************************************************
   LsScal.h -- WBEM provider class declaration

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the DHCP_Range class and
        the indices definitions for its static table of manageable objects.

   REVISION:
        08/14/98 - created

******************************************************************/
#include "Props.h"      // needed for CDHCP_Property definition

#ifndef _RNGSCAL_H
#define _RNGSCAL_H

// all the properties are keys - no use for a property table
#define PROP_Range_Subnet       L"Subnet"
#define PROP_Range_StartAddress L"StartAddress"
#define PROP_Range_EndAddress   L"EndAddress"
#define PROP_Range_RangeType    L"RangeType"

class CDHCP_Range : public Provider
{
	private:
        // Loader function for the properties values.
        BOOL LoadInstanceProperties(CInstance* pInstance);

	protected:
		// Reading Functions
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );
    public:
		// Constructor/destructor
		CDHCP_Range(const CHString& chsClassName, LPCSTR lpszNameSpace);
		virtual ~CDHCP_Range();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\snetfn.h ===
/******************************************************************
   SNetFn.h -- Properties action functions declarations (GET/SET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the CDHCP_Subnet_Parameters class, modeling all
        the datastructures used to retrieve the information from the DHCP Subnet.
        Contains the declarations for the action functions associated to
        each manageable property from the class CDHCP_Server

   REVISION:
        08/03/98 - created

******************************************************************/

#include "Props.h"          // needed for MFN_PROPERTY_ACTION_DECL definition

#ifndef _SNETFN_H
#define _SNETFN_H

// gathers the data structures needed for retrieving data from the DHCP Server.
class CDHCP_Subnet_Parameters
{
public:
    DHCP_IP_ADDRESS     m_dwSubnetAddress;
	LPDHCP_MIB_INFO		m_pMibInfo;
    LPSCOPE_MIB_INFO    m_pScopeMibInfo;
    LPDHCP_SUBNET_INFO  m_pSubnetInfo;

    CDHCP_Subnet_Parameters(DHCP_IP_ADDRESS dwSubnetAddress);
    CDHCP_Subnet_Parameters(DHCP_IP_ADDRESS dwSubnetAddress, DHCP_IP_ADDRESS dwSubnetMask);
    ~CDHCP_Subnet_Parameters();

    BOOL CheckExistsInfoPtr();

    BOOL GetMibInfo(LPDHCP_MIB_INFO& MibInfo, LPSCOPE_MIB_INFO &pScopeMibInfo, BOOL fRefresh);
    BOOL GetSubnetInfo(LPDHCP_SUBNET_INFO& SubnetInfo, BOOL fRefresh);

    BOOL CommitNew(DWORD &returnCode);
    BOOL CommitSet(DWORD &returnCode);
    BOOL DeleteSubnet();
};

// the repository defines the SET methods as the _PRMFUNCS_SET_PREFIX
// concatenated with the property name
#define _SNET_SET_PREFIX    L"Set"

// GET function for the (RO)"Address" property
MFN_PROPERTY_ACTION_DECL(fnSNetGetAddress);

// GET function for the (RO)"Mask" property
MFN_PROPERTY_ACTION_DECL(fnSNetGetMask);

// GET function for the (RW) "Name" property
MFN_PROPERTY_ACTION_DECL(fnSNetGetName);
MFN_PROPERTY_ACTION_DECL(fnSNetSetName);

// GET function for the (RW)"Comment" property
MFN_PROPERTY_ACTION_DECL(fnSNetGetComment);
MFN_PROPERTY_ACTION_DECL(fnSNetSetComment);

// GET function for the (RW)"State" property
MFN_PROPERTY_ACTION_DECL(fnSNetGetState);
MFN_PROPERTY_ACTION_DECL(fnSNetSetState);

// GET function for the (RO)"NumberOfAddressesInUse" property
MFN_PROPERTY_ACTION_DECL(fnSNetGetNumberOfAddressesInUse);

// GET function for the (RO)"NumberOfAddressesFree" property
MFN_PROPERTY_ACTION_DECL(fnSNetGetNumberOfAddressesFree);

// GET function for the (RO)"NumberOfPendingOffers" property
MFN_PROPERTY_ACTION_DECL(fnSNetGetNumberOfPendingOffers);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\sscofn.h ===
/******************************************************************
   SNetFn.h -- Properties action functions declarations (GET/SET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the CDHCP_SuperScope_Parameters class, modeling all
        the datastructures used to retrieve the information from the DHCP Subnet.
        Contains the declarations for the action functions associated to
        each manageable property from the class CDHCP_Server

   REVISION:
        08/03/98 - created

******************************************************************/

#include "Props.h"          // needed for MFN_PROPERTY_ACTION_DECL definition

#ifndef _SSCOFN_H
#define _SSCOFN_H

#define ENTRIES_SORTED_ON_SUPER_SCOPE   1
#define ENTRIES_SORTED_ON_SUBNET        2

extern UINT  g_uSortFlags;
int __cdecl sortHandler(const void* elem1, const void* elem2);

// gathers the data structures needed for retrieving data from the DHCP Server.
class CDHCP_SuperScope_Parameters
{
public:

    WCHAR                           *m_wcsSuperScopeName;
	LPDHCP_SUPER_SCOPE_TABLE        m_pSuperScopeTable;
    LPDHCP_SUPER_SCOPE_TABLE_ENTRY  *m_pSortedEntries;

    void CleanupTable();

    CDHCP_SuperScope_Parameters(const WCHAR *wcsSuperScopeName = NULL);
    CDHCP_SuperScope_Parameters(const CHString & str);
    ~CDHCP_SuperScope_Parameters();

    BOOL ExistsSuperScope (BOOL fRefresh = FALSE);
    BOOL GetSuperScopes(LPDHCP_SUPER_SCOPE_TABLE &superScopeTable, BOOL fRefresh);
    BOOL GetSortedScopes(UINT sortFlags, LPDHCP_SUPER_SCOPE_TABLE_ENTRY * & pSortedEntries, DWORD &dwNumEntries);
    BOOL AlterSubnetSet(DHCP_IP_ADDRESS subnetAddress);
    BOOL DeleteSuperScope();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\inc\dhcpbinl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dhcpbinl.h

Abstract:

    This file defines the interface between the DHCP server service
    and the BINL service (used to setup and load NetPC machines).

Author:

    Colin Watson (colinw)  28-May-1997

Environment:

    User Mode - Win32

Revision History:

--*/

//
// Constants for communicating with BINL and common data structures
//

#define DHCP_STOPPED        0
#define DHCP_STARTING       1

#define DHCP_NOT_AUTHORIZED 2
#define DHCP_AUTHORIZED     3

#define DHCP_READY_TO_UNLOAD 4

#define BINL_LIBRARY_NAME L"binlsvc.dll"
#define BINL_STATE_ROUTINE_NAME "TellBinlState"
#define BINL_READ_STATE_ROUTINE_NAME "BinlState"
#define BINL_DISCOVER_CALLBACK_ROUTINE_NAME "ProcessBinlDiscoverInDhcp"
#define BINL_REQUEST_CALLBACK_ROUTINE_NAME "ProcessBinlRequestInDhcp"

typedef
VOID
(*DhcpStateChange) (
        int NewState
        );

typedef
BOOL
(*ReturnBinlState) (
        VOID
        );

typedef
DWORD
(*ProcessBinlDiscoverCallback) (
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions
    );

typedef
DWORD
(*ProcessBinlRequestCallback) (
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions,
    PCHAR HostName,
    PCHAR BootFileName,
    DHCP_IP_ADDRESS *BootstrapServerAddress,
    LPOPTION *Option,
    PBYTE OptionEnd
    );

DWORD
ExtractOptions(
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions,
    DWORD ReceiveMessageSize
);

PCHAR
GetDhcpDomainName(
    VOID
);

LPOPTION
FormatDhcpInformAck(
    IN      LPDHCP_MESSAGE         Request,
    OUT     LPDHCP_MESSAGE         Response,
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      DHCP_IP_ADDRESS        ServerAddress
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\inc\dhcpexim.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    dhcpexim.h

Abstract:

    Routines that are exported out of the exim.lib

--*/

#ifndef DHCPEXIM_H
#define DHCPEXIM_H

typedef struct _DHCPEXIM_CONTEXT {
    LPWSTR FileName;
    BOOL fExport;
    BOOL fDisableExportedScopes;
    HANDLE hFile;
    LPBYTE Mem;
    DWORD MemSize;
    PVOID SvcConfig;
    PVOID FileConfig;
    DWORD nScopes;
    struct {
        BOOL fSelected;
        LPWSTR SubnetName;
        DWORD SubnetAddress;
    } *Scopes;
    

} DHCPEXIM_CONTEXT, *PDHCPEXIM_CONTEXT;

    
DWORD
DhcpEximInitializeContext(
    IN OUT PDHCPEXIM_CONTEXT Ctxt,
    IN LPWSTR FileName,
    IN BOOL fExport
    );

DWORD
DhcpEximCleanupContext(
    IN OUT PDHCPEXIM_CONTEXT Ctxt,
    IN BOOL fAbort
    );


DWORD
CmdLineDoImport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    );

DWORD
CmdLineDoExport(
    IN LPWSTR *Args,
    IN ULONG nArgs
    );

//
// the following functions are not implemented in the exim.lib,
// but these should be implemented by whoever uses exim.lib
//

VOID
DhcpEximErrorClassConflicts(
    IN LPWSTR SvcClass,
    IN LPWSTR ConfigClass
    );

VOID
DhcpEximErrorOptdefConflicts(
    IN LPWSTR SvcOptdef,
    IN LPWSTR ConfigOptdef
    );

VOID
DhcpEximErrorOptionConflits(
    IN LPWSTR SubnetName OPTIONAL,
    IN LPWSTR ResAddress OPTIONAL,
    IN LPWSTR OptId,
    IN LPWSTR UserClass OPTIONAL,
    IN LPWSTR VendorClass OPTIONAL
    );

VOID
DhcpEximErrorSubnetNotFound(
    IN LPWSTR SubnetAddress
    );

VOID
DhcpEximErrorSubnetAlreadyPresent(
    IN LPWSTR SubnetAddress,
    IN LPWSTR SubnetName OPTIONAL
    );

VOID
DhcpEximErrorDatabaseEntryFailed(
    IN LPWSTR ClientAddress,
    IN LPWSTR ClientHwAddress,
    IN DWORD Error,
    OUT BOOL *fAbort
    );







#endif  DHCPEXIM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\srvscal.h ===
/******************************************************************
   SrvScal.h -- WBEM provider class declaration

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the DHCP_Server_Scalar class and
        the indices definitions for the static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include "Props.h"      // needed for CDHCP_Property definition

#ifndef _SRVSCAL_H
#define _SRVSCAL_H

// Property set identification
#define PROVIDER_NAME_DHCP_SERVER   "DHCP_Server"
#define PROVIDER_NAMESPACE_DHCP     "root\\dhcp"

// indices for the DHCP_Server_Property static table (defined in SrvScal.cpp)
#define IDX_SRV_StartTime                   0
#define IDX_SRV_TotalNoOfAcks               1
#define IDX_SRV_TotalNoOfDeclines           2
#define IDX_SRV_TotalNoOfDiscovers          3
#define IDX_SRV_TotalNoOfNacks              4
#define IDX_SRV_TotalNoOfOffers             5
#define IDX_SRV_TotalNoOfReleases           6
#define IDX_SRV_TotalNoOfRequests           7
#define IDX_SRV_ServerVersion               8
#define IDX_SRV_APIProtocol                 9
#define IDX_SRV_DatabaseName                10
#define IDX_SRV_DatabasePath                11
#define IDX_SRV_BackupPath                  12
#define IDX_SRV_BackupInterval              13
#define IDX_SRV_DatabaseLoggingFlag         14
#define IDX_SRV_RestoreFlag                 15
#define IDX_SRV_DatabaseCleanupInterval     16
#define IDX_SRV_DebugFlag                   17
#define IDX_SRV_PingRetries                 18
#define IDX_SRV_BootFileTable               19
#define IDX_SRV_AuditLog                    20

// external definition for the static table of manageable objects (properties)
extern const CDHCP_Property  DHCP_Server_Property[];

// the number of entries into the DHCP_Server_Property static table
#define NUM_SERVER_PROPERTIES       (sizeof(DHCP_Server_Property)/sizeof(CDHCP_Property))

class CDHCP_Server : public Provider 
{
	private:
        // Loader function for the properties values.
        BOOL LoadInstanceProperties(CInstance* pInstance);

	protected:
		// Reading Functions
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );
    public:
		// Constructor/destructor
		CDHCP_Server(const CHString& chsClassName, LPCSTR lpszNameSpace);
		virtual ~CDHCP_Server();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\inc\dhcp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.h

Abstract:

    This module defines the DHCP server service definitions and structures.

Author:

    Manny Weiser  (mannyw)  11-Aug-1992

Revision History:

    Madan Appiah (madana) 10-Oct-1993

--*/

#ifndef _DHCP_
#define _DHCP_

#define WS_VERSION_REQUIRED     MAKEWORD( 1, 1)

//
// update dhcpapi.h also if you modify the following three typedefs.
//

typedef DWORD DHCP_IP_ADDRESS, *PDHCP_IP_ADDRESS, *LPDHCP_IP_ADDRESS;
typedef DWORD DHCP_OPTION_ID;

typedef struct _DATE_TIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} DATE_TIME, *PDATE_TIME, *LPDATE_TIME;

#define DHCP_DATE_TIME_ZERO_HIGH        0
#define DHCP_DATE_TIME_ZERO_LOW         0

#define DHCP_DATE_TIME_INFINIT_HIGH     0x7FFFFFFF
#define DHCP_DATE_TIME_INFINIT_LOW      0xFFFFFFFF

#define DOT_IP_ADDR_SIZE                16          // XXX.XXX.XXX.XXX + '\0'
#define NO_DHCP_IP_ADDRESS              ((DHCP_IP_ADDRESS)-1)
#define DHCP_IP_KEY_LEN                 32          //arbitary size.

#define INFINIT_TIME                    MAXINT_PTR // time_t is int_ptr
#define INFINIT_LEASE                   0xFFFFFFFF  // in secs. (unsigned int.)

// MDHCP server well known address. Relative "1" assignment in IPv4 local scope.
/* FROM RFC 2365
The high order /24 in every scoped region is reserved for relative
   assignments. A relative assignment is an integer offset from highest
   address in the scope and represents a 32-bit address (for IPv4). For
   example, in the Local Scope defined above, 239.255.255.0/24 is
   reserved for relative allocations. The de-facto relative assignment
   "0", (i.e., 239.255.255.255 in the Local Scope) currently exists for
   SAP [SAP]. The next relative assignment, "1", corresponds to the
   address 239.255.255.254 in the Local Scope. The rest of a scoped
   region below the reserved /24 is available for dynamic assignment
   (presumably by an address allocation protocol).
*/
#define MADCAP_SERVER_IP_ADDRESS         0xfeffffef // 239.255.255.254
//
// hardware types.
//
#define HARDWARE_TYPE_NONE              0 // used for non-hardware type client id
#define HARDWARE_TYPE_10MB_EITHERNET    1
#define HARDWARE_TYPE_IEEE_802          6
#define HARDWARE_ARCNET                 7
#define HARDWARE_PPP                    8
#define HARDWARE_1394                   24

//
// Client-server protoocol reserved ports
//

#define DHCP_CLIENT_PORT    68
#define DHCP_SERVR_PORT     67
#define MADCAP_SERVER_PORT 2535
//
// DHCP BROADCAST flag.
//

#define DHCP_BROADCAST      0x8000
#define DHCP_NO_BROADCAST   0x0000

// MDHCP flag
#define DHCP_MBIT           0x4000
#define IS_MDHCP_MESSAGE( _msg ) ( ntohs((_msg)->Reserved) & DHCP_MBIT ? TRUE : FALSE )
#define MDHCP_MESSAGE( _msg ) ( (_msg)->Reserved |= htons(DHCP_MBIT) )

#define CLASSD_NET_ADDR(a)   ((a & 0xf0) == 0xe0)
#define CLASSD_HOST_ADDR(a)  ((a & 0xf0000000) == 0xe0000000)

#define CLASSE_HOST_ADDR(a)  ((a & 0xf0000000) == 0xf0000000)
#define CLASSE_NET_ADDR(a)   ((a & 0xf0) == 0xf0)

#define DHCP_MESSAGE_SIZE       576
#define DHCP_RECV_MESSAGE_SIZE  4096
#define DHCP_SEND_MESSAGE_SIZE  1024
#define BOOTP_MESSAGE_SIZE      300 // the options field for bootp is 64 bytes.

//
// The amount of time to wait for a DHCP response after a request
// has been sent.
//

#if !DBG
#define WAIT_FOR_RESPONSE_TIME          5
#else
#define WAIT_FOR_RESPONSE_TIME          10
#endif

//
// DHCP Operations
//

#define BOOT_REQUEST   1
#define BOOT_REPLY     2

//
// DHCP Standard Options.
//

#define OPTION_PAD                      0
#define OPTION_SUBNET_MASK              1
#define OPTION_TIME_OFFSET              2
#define OPTION_ROUTER_ADDRESS           3
#define OPTION_TIME_SERVERS             4
#define OPTION_IEN116_NAME_SERVERS      5
#define OPTION_DOMAIN_NAME_SERVERS      6
#define OPTION_LOG_SERVERS              7
#define OPTION_COOKIE_SERVERS           8
#define OPTION_LPR_SERVERS              9
#define OPTION_IMPRESS_SERVERS          10
#define OPTION_RLP_SERVERS              11
#define OPTION_HOST_NAME                12
#define OPTION_BOOT_FILE_SIZE           13
#define OPTION_MERIT_DUMP_FILE          14
#define OPTION_DOMAIN_NAME              15
#define OPTION_SWAP_SERVER              16
#define OPTION_ROOT_DISK                17
#define OPTION_EXTENSIONS_PATH          18

//
// IP layer parameters - per host
//

#define OPTION_BE_A_ROUTER              19
#define OPTION_NON_LOCAL_SOURCE_ROUTING 20
#define OPTION_POLICY_FILTER_FOR_NLSR   21
#define OPTION_MAX_REASSEMBLY_SIZE      22
#define OPTION_DEFAULT_TTL              23
#define OPTION_PMTU_AGING_TIMEOUT       24
#define OPTION_PMTU_PLATEAU_TABLE       25

//
// Link layer parameters - per interface.
//

#define OPTION_MTU                      26
#define OPTION_ALL_SUBNETS_MTU          27
#define OPTION_BROADCAST_ADDRESS        28
#define OPTION_PERFORM_MASK_DISCOVERY   29
#define OPTION_BE_A_MASK_SUPPLIER       30
#define OPTION_PERFORM_ROUTER_DISCOVERY 31
#define OPTION_ROUTER_SOLICITATION_ADDR 32
#define OPTION_STATIC_ROUTES            33
#define OPTION_TRAILERS                 34
#define OPTION_ARP_CACHE_TIMEOUT        35
#define OPTION_ETHERNET_ENCAPSULATION   36

//
// TCP Paramters - per host
//

#define OPTION_TTL                      37
#define OPTION_KEEP_ALIVE_INTERVAL      38
#define OPTION_KEEP_ALIVE_DATA_SIZE     39

//
// Application Layer Parameters
//

#define OPTION_NETWORK_INFO_SERVICE_DOM 40
#define OPTION_NETWORK_INFO_SERVERS     41
#define OPTION_NETWORK_TIME_SERVERS     42

//
// Vender specific information option
//

#define OPTION_VENDOR_SPEC_INFO         43

//
// NetBIOS over TCP/IP Name server option
//

#define OPTION_NETBIOS_NAME_SERVER      44
#define OPTION_NETBIOS_DATAGRAM_SERVER  45
#define OPTION_NETBIOS_NODE_TYPE        46
#define OPTION_NETBIOS_SCOPE_OPTION     47

//
// X Window System Options.
//

#define OPTION_XWINDOW_FONT_SERVER      48
#define OPTION_XWINDOW_DISPLAY_MANAGER  49

//
// Other extensions
//

#define OPTION_REQUESTED_ADDRESS        50
#define OPTION_LEASE_TIME               51
#define OPTION_OK_TO_OVERLAY            52
#define OPTION_MESSAGE_TYPE             53
#define OPTION_SERVER_IDENTIFIER        54
#define OPTION_PARAMETER_REQUEST_LIST   55
#define OPTION_MESSAGE                  56
#define OPTION_MESSAGE_LENGTH           57
#define OPTION_RENEWAL_TIME             58      // T1
#define OPTION_REBIND_TIME              59      // T2
#define OPTION_CLIENT_CLASS_INFO        60
#define OPTION_CLIENT_ID                61

#define OPTION_TFTP_SERVER_NAME         66
#define OPTION_BOOTFILE_NAME            67

//
//  user class id
//
#define OPTION_USER_CLASS               77

//
//  Dynamic DNS Stuff.  Tells if we should do both A+PTR updates?
//
#define OPTION_DYNDNS_BOTH              81

//
//  used by binl
//
#define OPTION_NETWORK_INTERFACE_TYPE   91
#define OPTION_SYSTEM_ARCHITECTURE      93
#define OPTION_CLIENT_GUID              97

// Multicast options.
#define OPTION_MCAST_SCOPE_ID           101
#define OPTION_MCAST_LEASE_START        102
#define OPTION_MCAST_TTL                103
#define OPTION_CLIENT_PORT              105
#define OPTION_MCAST_SCOPE_LIST         107

// disable autoconfiguration
#define OPTION_IETF_AUTOCONF            116

// special option to extend options
#define OPTION_LARGE_OPTION             127
#define OPTION_CLASSLESS_ROUTES         249

#define OPTION_END                      255

// MADCAP OPTIONS
#define MADCAP_OPTION_END               0
#define MADCAP_OPTION_LEASE_TIME        1
#define MADCAP_OPTION_SERVER_ID         2
#define MADCAP_OPTION_LEASE_ID          3
#define MADCAP_OPTION_MCAST_SCOPE       4
#define MADCAP_OPTION_REQUEST_LIST      5
#define MADCAP_OPTION_START_TIME        6
#define MADCAP_OPTION_ADDR_COUNT        7
#define MADCAP_OPTION_REQUESTED_LANG    8
#define MADCAP_OPTION_MCAST_SCOPE_LIST  9
#define MADCAP_OPTION_ADDR_LIST         10
#define MADCAP_OPTION_TIME              11
#define MADCAP_OPTION_FEATURE_LIST      12
#define MADCAP_OPTION_RETRY_TIME        13
#define MADCAP_OPTION_MIN_LEASE_TIME    14
#define MADCAP_OPTION_MAX_START_TIME    15
#define MADCAP_OPTION_ERROR             16
// update the total whenever changes
#define MADCAP_OPTION_TOTAL             17
#define MADCAP_OPTION_NONE              0xffff

// MADCAP error option codes
#define MADCAP_NAK_REQ_NOT_COMPLETED    0
#define MADCAP_NAK_INVALID_REQ          1
#define MADCAP_NAK_CLOCK_SKEW           2
#define MADCAP_NAK_INVALID_LEASE_ID     3
#define MADCAP_NAK_UNSUPPORTED_FEATURE  4



//
// MADCAP Message types
//


#define MADCAP_DISCOVER_MESSAGE  1
#define MADCAP_OFFER_MESSAGE     2
#define MADCAP_REQUEST_MESSAGE   3
#define MADCAP_RENEW_MESSAGE     4
#define MADCAP_ACK_MESSAGE       5
#define MADCAP_NACK_MESSAGE      6
#define MADCAP_RELEASE_MESSAGE   7
#define MADCAP_INFORM_MESSAGE    8
// update the total when above changes
#define MADCAP_TOTAL_MESSAGE     9

// MADCAP version constants
#define MADCAP_VERSION           0
enum {
    MADCAP_ADDR_FAMILY_V4 = 1,
    MADCAP_ADDR_FAMILY_V6
};

// The following definations specify how the options are
// formatted based on different versions and protocols

enum {
    PROTO_DHCP,
    PROTO_MADCAP_V4,
    PROTO_MADCAP_V6
};

typedef struct _OPTION_VERSION {
    WORD    Proto;
    WORD    Version;
} OPTION_VERSION, *POPTION_VERSION;

#define OPT_VER_DHCP {PROTO_DHCP, 1 }
#define OPT_VER_MADCAP_V4 {PROTO_MADCAP_V4, 0 }
#define OPT_VER_MADCAP_V6 {PROTO_MADCAP_V6, 0 }

// default mcast_ttl value.
#define DEFAULT_MCAST_TTL               32

//
// Different option values for the DYNDNS_BOTH option ...
//

#define DYNDNS_S_BIT 0x01
#define DYNDNS_O_BIT 0x02
#define DYNDNS_E_BIT 0x04

#define IS_CLIENT_DOING_A_AND_PTR(X)  (((X)&DYNDNS_S_BIT)== 0)

#define DYNDNS_REGISTER_AT_CLIENT       0     // Client will do both registrations
#define DYNDNS_REGISTER_AT_SERVER       1     // Server will do registrations
#define DYNDNS_DOWNLEVEL_CLIENT         0xFFFF // arbitraty # diff from above

//
// Microsoft-specific options
//
#define OPTION_MSFT_DSDOMAINNAME_REQ    94    // send me your DS Domain name
#define OPTION_MSFT_DSDOMAINNAME_RESP   95    // sending my DS Domain name

#define OPTION_MSFT_CONTINUED           250   // the previous option is being continued..
#define OPTION_MSFT_AUTOCONF            251   // enable disable autoconf
#define OPTION_MSFT_IE_PROXY            252   // IE5 proxy <string type>
#define OPTION_MSFT_SERVER_APPL         253   // has a struct.

#define OPTION_MSFT_VENDOR_NETBIOSLESS  1     // vendor option # 1
#define OPTION_MSFT_VENDOR_FEATURELIST  2     // vendor option # 2
#define BIT_RELEASE_ON_SHUTDOWN         0x01  // release on shutdown bit in feature list
#define OPTION_MSFT_VENDOR_METRIC_BASE  3     // default gateway base metric.

#define AUTOCONF_ENABLED                1
#define AUTOCONF_DISABLED               0

//
// DHCP Message types
//

#define DHCP_DISCOVER_MESSAGE  1
#define DHCP_OFFER_MESSAGE     2
#define DHCP_REQUEST_MESSAGE   3
#define DHCP_DECLINE_MESSAGE   4
#define DHCP_ACK_MESSAGE       5
#define DHCP_NACK_MESSAGE      6
#define DHCP_RELEASE_MESSAGE   7
#define DHCP_INFORM_MESSAGE    8

#define DHCP_MAGIC_COOKIE_BYTE1     99
#define DHCP_MAGIC_COOKIE_BYTE2     130
#define DHCP_MAGIC_COOKIE_BYTE3     83
#define DHCP_MAGIC_COOKIE_BYTE4     99

#define BOOT_FILE_SIZE          128
#define BOOT_SERVER_SIZE        64
#define BOOT_FILE_SIZE_W        ( BOOT_FILE_SIZE * sizeof( WCHAR ))
#define BOOT_SERVER_SIZE_W      ( BOOT_SERVER_SIZE * sizeof( WCHAR ))

//
// DHCP APP names - used to indentify to the eventlogger.
//

#define DHCP_EVENT_CLIENT     TEXT("Dhcp")
#define DHCP_EVENT_SERVER     TEXT("DhcpServer")


typedef struct _OPTION {
    BYTE OptionType;
    BYTE OptionLength;
    BYTE OptionValue[1];
} OPTION, *POPTION, *LPOPTION;

typedef struct _WIDE_OPTION {
    WORD OptionType;
    WORD OptionLength;
    BYTE OptionValue[1];
} WIDE_OPTION, *PWIDE_OPTION, *LPWIDE_OPTION;

//
// A DHCP message buffer
//


#pragma pack(1)         /* Assume byte packing */
typedef struct _DHCP_MESSAGE {
    BYTE Operation;
    BYTE HardwareAddressType;
    BYTE HardwareAddressLength;
    BYTE HopCount;
    DWORD TransactionID;
    WORD SecondsSinceBoot;
    WORD Reserved;
    DHCP_IP_ADDRESS ClientIpAddress;
    DHCP_IP_ADDRESS YourIpAddress;
    DHCP_IP_ADDRESS BootstrapServerAddress;
    DHCP_IP_ADDRESS RelayAgentIpAddress;
    BYTE HardwareAddress[16];
    BYTE HostName[ BOOT_SERVER_SIZE ];
    BYTE BootFileName[BOOT_FILE_SIZE];
    OPTION Option;
} DHCP_MESSAGE, *PDHCP_MESSAGE, *LPDHCP_MESSAGE;

typedef struct _MADCAP_MESSAGE {
    BYTE Version;
    BYTE MessageType;
    WORD AddressFamily;
    DWORD TransactionID;
//    DHCP_IP_ADDRESS ClientIpAddress;
//    DHCP_IP_ADDRESS YourIpAddress;
    WIDE_OPTION Option;
} MADCAP_MESSAGE, *PMADCAP_MESSAGE, *LPMADCAP_MESSAGE;
#pragma pack()

#define DHCP_MESSAGE_FIXED_PART_SIZE \
            (sizeof(DHCP_MESSAGE) - sizeof(OPTION))
#define MADCAP_MESSAGE_FIXED_PART_SIZE \
            (sizeof(MADCAP_MESSAGE) - sizeof (WIDE_OPTION))

#define DHCP_MIN_SEND_RECV_PK_SIZE \
            (DHCP_MESSAGE_FIXED_PART_SIZE + 64)

//
// Per message structure... Most of the structures here point within the
// message.

typedef struct _DHCP_SERVER_OPTIONS {
    BYTE                       *MessageType;
    DHCP_IP_ADDRESS UNALIGNED  *SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED  *RequestedAddress;
    DWORD UNALIGNED            *RequestLeaseTime;
    BYTE                       *OverlayFields;
    DHCP_IP_ADDRESS UNALIGNED  *RouterAddress;
    DHCP_IP_ADDRESS UNALIGNED  *Server;
    BYTE                       *ParameterRequestList;
    DWORD                       ParameterRequestListLength;
    CHAR                       *MachineName;
    DWORD                       MachineNameLength;
    BYTE                        ClientHardwareAddressType;
    BYTE                        ClientHardwareAddressLength;
    BYTE                       *ClientHardwareAddress;
    CHAR                       *ClassIdentifier;
    DWORD                       ClassIdentifierLength;
    BYTE                       *VendorClass;
    DWORD                       VendorClassLength;
    DWORD                       DNSFlags;
    DWORD                       DNSNameLength;
    LPBYTE                      DNSName;
    BOOLEAN                     DSDomainNameRequested;
    CHAR                       *DSDomainName;
    DWORD                       DSDomainNameLen;
    USHORT                      SystemArchitecture;
    DWORD                       SystemArchitectureLength;
    CHAR                       *NetworkInterfaceType;
    DWORD                       NetworkInterfaceTypeLength;
    CHAR                       *Guid;
    DWORD                       GuidLength;
} DHCP_SERVER_OPTIONS, *LPDHCP_SERVER_OPTIONS;

typedef struct _MADCAP_SERVER_OPTIONS {
    BYTE  UNALIGNED            *AddrRangeList;
    WORD                        AddrRangeListSize;
    DWORD UNALIGNED            *RequestLeaseTime;
    DWORD UNALIGNED            *LeaseStartTime;
    DHCP_IP_ADDRESS UNALIGNED  *Server;
    BYTE                       *RequestList;
    WORD                        RequestListLength;
    DWORD   UNALIGNED          *ScopeId;
    CHAR                       *Guid;
    WORD                        GuidLength;
    WORD    UNALIGNED          *MinAddrCount;
    WORD    UNALIGNED          *AddrCount;
    BYTE                       *RequestLang;
    WORD                        RequestLangLength;
    DWORD   UNALIGNED          *Time;
    WORD    UNALIGNED          *Features[3];
    WORD                        FeatureCount[3];
    DWORD   UNALIGNED          *RetryTime;
    DWORD   UNALIGNED          *MinLeaseTime;
    DWORD   UNALIGNED          *MaxStartTime;
    BOOL                        OptPresent[MADCAP_OPTION_TOTAL];
} MADCAP_SERVER_OPTIONS, *LPMADCAP_SERVER_OPTIONS;

// the indices for Features array above
enum {
    SUPPORTED_FEATURES, REQUESTED_FEATURES, REQUIRED_FEATURES
};
//
// JET - DHCP database constants.
//

#define DB_TABLE_SIZE       10      // table size in 4K pages.
#define DB_TABLE_DENSITY    80      // page density
#define DB_LANGID           0x0409  // language id
#define DB_CP               1252    // code page

#if DBG

//
// debug functions.
//

#ifdef CHICAGO // No Tracing available on CHICAGO
#define DhcpPrintTrace
#endif

#define IF_DEBUG(flag) if (DhcpGlobalDebugFlag & (DEBUG_ ## flag))
#define DhcpPrint(_x_) DhcpPrintRoutine _x_
#define Trace          DhcpPrintTrace

#ifndef CHICAGO
VOID
DhcpPrintTrace(
    IN LPSTR Format,
    ...
    );

#endif

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#else

#define IF_DEBUG(flag) if (FALSE)
#define DhcpPrint(_x_)
#define Trace       (void)

#endif // DBG

#define OpenDriver     DhcpOpenDriver

#endif // _DHCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\sscoscal.h ===
/******************************************************************
   SNetScal.h -- WBEM provider class declaration

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the DHCP_Subnet_Scalar class and
        the indices definitions for its static table of manageable objects.

   REVISION:
        08/03/98 - created

******************************************************************/
#include "Props.h"      // needed for CDHCP_Property definition

#ifndef _SSCOSCAL_H
#define _SSCOSCAL_H

class CDHCP_SuperScope : public Provider 
{
	protected:
		// Reading Functions
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );
    public:
		// Constructor/destructor
		CDHCP_SuperScope(const CHString& chsClassName, LPCSTR lpszNameSpace);
		virtual ~CDHCP_SuperScope();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\inc\dhcplib.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcplib.h

Abstract:

    This file contains proto type definitions for the dhcp lib
    functions.

Author:

    Madan Appiah  (madana)  12-Aug-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#ifndef DHCPLIB_H_INCLUDED
#define DHCPLIB_H_INCLUDED
#include <madcapcl.h>

#undef DhcpAllocateMemory
#undef DhcpFreeMemory

//
// network.c
//

DHCP_IP_ADDRESS
DhcpDefaultSubnetMask(
    DHCP_IP_ADDRESS IpAddress
    );

//
// dhcp.c
//


PVOID
DhcpAllocateMemory(
    DWORD Size
    );

VOID
DhcpFreeMemory(
    PVOID Memory
    );


#if DBG

#ifndef DEBUG_ALLOC
#define DEBUG_ALLOC 0x02000000
#endif

PVOID _inline
DhcpAllocateMemoryEx(
    DWORD Size,
    DWORD LineNo,
    LPSTR FileName
) {
    LPVOID Ptr = DhcpAllocateMemory(Size);

    DhcpPrint((DEBUG_ALLOC, "Allocate %010x %04x %04d %s\n", Ptr, Size, LineNo, FileName));
    return Ptr;
}

VOID _inline
DhcpFreeMemoryEx(
    LPVOID Ptr,
    DWORD  LineNo,
    LPSTR  FileName
) {
    DhcpFreeMemory(Ptr);
    DhcpPrint((DEBUG_ALLOC, "Free %010x %04x %04d %s\n", Ptr, 0, LineNo, FileName));
}


#define DhcpAllocateMemory(Sz)    DhcpAllocateMemoryEx(Sz, __LINE__, __FILE__)
#define DhcpFreeMemory(Ptr)       DhcpFreeMemoryEx(Ptr, __LINE__, __FILE__)

#endif

LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
    );

WIDE_OPTION UNALIGNED *
AppendWideOption(
    WIDE_OPTION UNALIGNED *Option,
    WORD  OptionType,
    PVOID OptionValue,
    WORD OptionLength,
    LPBYTE OptionEnd
);

WIDE_OPTION UNALIGNED *
AppendMadcapAddressList(
    WIDE_OPTION UNALIGNED *Option,
    DWORD UNALIGNED *AddrList,
    WORD            AddrCount,
    LPBYTE          OptionEnd
);

DWORD
ExpandMadcapAddressList(
    PBYTE   AddrRangeList,
    WORD    AddrRangeListSize,
    DWORD  UNALIGNED *ExpandList,
    WORD   *ExpandListSize
    );


LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    );

LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd

    );

LPOPTION
DhcpAppendEnterpriseName(
    LPOPTION Option,
    PCHAR    DSEnterpriseName,
    LPBYTE   OptionEnd
    );

DATE_TIME
DhcpCalculateTime(
    DWORD RelativeTime
    );

DATE_TIME
DhcpGetDateTime(
    VOID
    );

DWORD
DhcpReportEventW(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    );

DWORD
DhcpReportEventA(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    );

DWORD
DhcpLogUnknownOption(
    LPWSTR Source,
    DWORD EventID,
    LPOPTION Option
    );

VOID
DhcpCancelWaitableTimer(
    HANDLE TimerHandle
    );

DWORD
DhcpStartWaitableTimer(
    HANDLE TimerHandle,
    DWORD SleepTime);


//
// convert.c
//

LPWSTR
DhcpOemToUnicodeN(
    IN      LPSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    );

LPWSTR
DhcpOemToUnicode(
    IN LPSTR Ansi,
    IN OUT LPWSTR Unicode
    );

LPSTR
DhcpUnicodeToOem(
    IN LPWSTR Unicode,
    IN LPSTR Ansi
    );

ULONG
DhcpUnicodeToOemSize(
    IN LPWSTR Unicode
    );

DWORD
ConvertUTF8ToUnicode(
    LPBYTE  UTF8String,
    DWORD   UTF8Length,
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength
    );

DWORD
ConvertUnicodeToUTF8(
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength,
    LPBYTE  UTF8String,
    DWORD   UTF8Length
    );

#if 0

VOID
DhcpIpAddressToString(
    LPWSTR Buffer,
    DWORD HexNumber
    );

VOID
DhcpStringToIpAddress(
    LPSTR Buffer,
    LPDHCP_IP_ADDRESS IpAddress,
    BOOL NetOrder
    );

#endif

VOID
DhcpHexToString(
    LPWSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    );

VOID
DhcpHexToAscii(
    LPSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    );

VOID
DhcpDecimalToString(
    LPWSTR Buffer,
    BYTE Number
    );

DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    );

LPSTR
DhcpIpAddressToDottedString(
    DWORD IpAddress
    );

DWORD
DhcpStringToHwAddress(
    LPSTR AddressBuffer,
    LPSTR AddressString
    );

#if 0

DHCP_IP_ADDRESS
DhcpHostOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    );

DHCP_IP_ADDRESS
DhcpNetworkOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    );

#endif

LPWSTR
DhcpRegIpAddressToKey(
    DHCP_IP_ADDRESS IpAddress,
    LPWSTR KeyBuffer
    );

DWORD
DhcpRegKeyToIpAddress(
    LPWSTR Key
    );

LPWSTR
DhcpRegOptionIdToKey(
    DHCP_OPTION_ID OptionId,
    LPWSTR KeyBuffer
    );

DHCP_OPTION_ID
DhcpRegKeyToOptionId(
    LPWSTR Key
    );

#if DBG

VOID
DhcpDumpMessage(
    DWORD DhcpDebugFlag,
    LPDHCP_MESSAGE DhcpMessage,
    ULONG MessageSize
    );

VOID
MadcapDumpMessage(
    DWORD DhcpDebugFlag,
    LPMADCAP_MESSAGE MadcapMessage,
    ULONG MessageSize
    );

VOID
DhcpAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define DhcpAssert(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#define DhcpVerify(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#else

#define DhcpAssert(_x_)
#define DhcpDumpMessage(_x_, _y_, _z_)
#define MadcapDumpMessage(_x_, _y_, _z_)
#define DhcpVerify(_x_) (_x_)

#endif // not DBG

VOID
DhcpNTToNTPTime(
    LPDATE_TIME AbsNTTime,
    DWORD       Offset,
    PULONG      NTPTimeStamp
    );

VOID
DhcpNTPToNTTime(
    PULONG          NTPTimeStamp,
    DWORD           Offset,
    DATE_TIME       *NTTime
    );


#endif DHCPLIB_H_INCLUDED

//------------------------------------------------------------------------
// End of file
//------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\dhcpprov\inc\srvfn.h ===
/******************************************************************
   SrvFuncs.h -- Properties action functions declarations (GET/SET)

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        Contains the declaration of the CDHCP_Server_Parameters class, modeling all
        the datastructures used to retrieve the information from the DHCP Server.
        Contains the declarations for the action functions associated to
        each manageable property from the class CDHCP_Server

   REVISION:
        08/03/98 - created

******************************************************************/

#include "Props.h"          // needed for MFN_PROPERTY_ACTION_DECL definition

#ifndef _SRVFN_H
#define _SRVFN_H

/******************************************************************
   SrvPrms.h -- CDHCP_Server_Parameters declaration.

   MODULE:
        DhcpProv.dll

   DESCRIPTION:
        CDHCP_Server_Parameters gathers all the data structures used for
        retrieving the low level information from the DHCP Server, and
        the methods needed to update this information

   REVISION:
        08/03/98 - created

******************************************************************/

// gathers the data structures needed for retrieving data from the DHCP Server.
class CDHCP_Server_Parameters
{
public:
	LPDHCP_MIB_INFO					m_pMibInfo;
	DWORD							m_dwMajor;
	DWORD							m_dwMinor;

    DWORD                           m_dwConfigInfoV4Flags;  // specifies what info is to be set from m_pConfigInfoV4 below
	LPDHCP_SERVER_CONFIG_INFO_V4	m_pConfigInfoV4;

    CDHCP_Server_Parameters();
    ~CDHCP_Server_Parameters();

    BOOL CheckExistsConfigPtr();

    BOOL GetMibInfo(LPDHCP_MIB_INFO& MibInfo, BOOL fRefresh);
    BOOL GetVersion(DWORD &Major, DWORD& Minor,  BOOL fRefresh);
    BOOL GetServerConfigInfoV4(LPDHCP_SERVER_CONFIG_INFO_V4& ServerConfigInfoV4, BOOL fRefresh);

    BOOL CommitSet(DWORD &returnCode);
};

// the repository defines the SET methods as the _PRMFUNCS_SET_PREFIX
// concatenated with the property name
#define _SRV_SET_PREFIX    L"Set"

// GET function for the (RO)"StartTime" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetStartTime);

// GET function for the (RO)"TotalNoOfAcks" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetTotalNoOfAcks);

// GET function for the (RO) "TotalNoOfDeclines" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetTotalNoOfDeclines);

// GET function for the (RO)"TotalNoOfDiscovers" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetTotalNoOfDiscovers);

// GET function for the (RO)"TotalNoOfNacks" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetTotalNoOfNacks);

// GET function for the (RO)"TotalNoOfOffers" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetTotalNoOfOffers);

// GET function for the (RO)"TotalNoOfReleases" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetTotalNoOfReleases);

// GET function for the (RO)"TotalNoOfRequests" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetTotalNoOfRequests);

// GET function for the (RO)"ServerVersion" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetServerVersion);

// GET/SET functions for the (RW)"APIProtocol" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetAPIProtocol);
MFN_PROPERTY_ACTION_DECL(fnSrvSetAPIProtocol);

// GET/SET functions for the (RW)"DatabaseName" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetDatabaseName);
MFN_PROPERTY_ACTION_DECL(fnSrvSetDatabaseName);

// GET/SET functions for the (RW)"DatabasePath" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetDatabasePath);
MFN_PROPERTY_ACTION_DECL(fnSrvSetDatabasePath);

// GET/SET functions for the (RW)"BackupPath" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetBackupPath);
MFN_PROPERTY_ACTION_DECL(fnSrvSetBackupPath);

// GET/SET functions for the (RW)"BackupInterval" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetBackupInterval);
MFN_PROPERTY_ACTION_DECL(fnSrvSetBackupInterval);

// GET/SET functions for the (RW)"DatabaseLoggingFlag" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetDatabaseLoggingFlag);
MFN_PROPERTY_ACTION_DECL(fnSrvSetDatabaseLoggingFlag);

// GET/SET functions for the (RW)"RestoreFlag" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetRestoreFlag);
MFN_PROPERTY_ACTION_DECL(fnSrvSetRestoreFlag);

// GET/SET functions for the (RW)"DatabaseCleanupInterval" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetDatabaseCleanupInterval);
MFN_PROPERTY_ACTION_DECL(fnSrvSetDatabaseCleanupInterval);

// GET/SET functions for the (RW)"DebugFlag" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetDebugFlag);
MFN_PROPERTY_ACTION_DECL(fnSrvSetDebugFlag);

// GET/SET functions for the (RW)"PingRetries" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetPingRetries);
MFN_PROPERTY_ACTION_DECL(fnSrvSetPingRetries);

// GET/SET functions for the (RW)"BootFileTable" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetBootFileTable);
MFN_PROPERTY_ACTION_DECL(fnSrvSetBootFileTable);

// GET/SET functions for the (RW)"AuditLog" property
MFN_PROPERTY_ACTION_DECL(fnSrvGetAuditLog);
MFN_PROPERTY_ACTION_DECL(fnSrvSetAuditLog);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\inc\dhcprog.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcprog.h

Abstract:

    This file contain function prototypes for the DHCP server rogue detection
    routines.

Author:

    Ramesh Vyaghrapuri (rameshv) 17-Aug-1998

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#ifndef ROGUE_H_INCLUDED
#define ROGUE_H_INCLUDED

//
// Structure that holds the state information for Rogue detection
//

#define         MAX_DNS_NAME_LEN                 260

typedef struct {
    BOOL        fInitialized;
    HANDLE      TerminateEvent;
    HANDLE      WaitHandle;

    BOOL        fDhcp;
    BOOL        fLogEvents;
    BOOL        fIsSamSrv;
    ULONG       NoNetTriesCount;
    ULONG       GetDsDcNameRetries;
    BOOL        fIsWorkGroup;
    BOOL        fDcIsDsEnabled;
    BOOL        fJustUpgraded;
    ULONG       CachedAuthStatus;
    ULONG       RogueState;
    ULONG       InformsSentCount;
    ULONG       SleepTime;
    ULONG       ReceiveTimeLimit;
    ULONG       ProcessAckRetries;
    ULONG       WaitForAckRetries;
    ULONG       nResponses;
    BOOL        fSomeDsExists;
    ULONG       StartTime;
    ULONG       LastUnauthLogTime;
    
    WCHAR       DomainDnsName[MAX_DNS_NAME_LEN];
    WCHAR       DnsForestName[MAX_DNS_NAME_LEN];
    SOCKET      SendSocket;
    SOCKET      RecvSocket;
    BOOL        fFormattedMessage;
    BYTE        SendMessage[DHCP_MESSAGE_SIZE];
    UUID        FakeHardwareAddress;
    ULONG       SendMessageSize;
    BYTE        RecvMessage[DHCP_MESSAGE_SIZE];

    ULONG       LastSeenIpAddress;
    WCHAR       LastSeenDomain[MAX_DNS_NAME_LEN];

    LIST_ENTRY  CachedServersList;

}   DHCP_ROGUE_STATE_INFO, *PDHCP_ROGUE_STATE_INFO;


//
// Rogue.C
//

DWORD
APIENTRY
DhcpRogueInit(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL,
    IN      HANDLE                 WaitEvent,
    IN      HANDLE                 TerminateEvent
);

VOID
APIENTRY
DhcpRogueCleanup(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL
);

ULONG
APIENTRY
RogueDetectStateMachine(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\inc\heapx.h ===
//
// Copyright (C) 1995 Microsoft Corporation
//
//

#ifndef __HEAPX_H__

#define __HEAPX_H__

#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__

#include <stdlib.h>
#include <malloc.h>

#define _DEBUG
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>

#define HEAPX_NORMAL    0
#define HEAPX_VERIFY    1
#define HEAPX_RETAIN    3


#define INIT_DEBUG_HEAP( Level ) \
{  \
    int nDbgFlags; \
   _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_DEBUG );\
   _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );\
   _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_DEBUG );\
   nDbgFlags = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG ); \
   \
   if ( Level & HEAPX_VERIFY ) \
   { \
       nDbgFlags |= _CRTDBG_CHECK_ALWAYS_DF; \
   } \
   if ( Level & HEAPX_RETAIN ) \
   { \
       nDbgFlags |= _CRTDBG_DELAY_FREE_MEM_DF; \
   } \
   _CrtSetDbgFlag( nDbgFlags ); \
}

#define UNINIT_DEBUG_HEAP() \
 _ASSERT( _CrtCheckMemory() ); \
 _ASSERT( !_CrtDumpMemoryLeaks() );

#else // #ifdef __DHCP_USE_DEBUG_HEAP__
#define INIT_DEBUG_HEAP( Level )
#define UNINIT_DEBUG_HEAP()
#endif




#else // #ifdef DBG

#define INIT_DEBUG_HEAP( Level )
#define UNINIT_DEBUG_HEAP()

#endif






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\lib\convert.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    convert.c

Abstract:

    This module contains miscellaneous utility routines used by the
    DHCP server service.

Author:

    Manny Weiser (mannyw) 12-Aug-1992

Revision History:

    Madan Appiah (madana) 21-Oct-1992

--*/

#include "dhcpl.h"
#include <winnls.h>

LPWSTR
DhcpOemToUnicodeN(
    IN      LPSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    )
{

    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength =
        cChars * sizeof( WCHAR );

    if( Unicode == NULL ) {
        UnicodeString.Buffer =
            DhcpAllocateMemory( UnicodeString.MaximumLength );
    }
    else {
        UnicodeString.Buffer = Unicode;
    }

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        if( Unicode == NULL ) {
            DhcpFreeMemory( UnicodeString.Buffer );
        }
        return NULL;
    }

    return UnicodeString.Buffer;

}



LPWSTR
DhcpOemToUnicode(
    IN      LPSTR Ansi,
    IN OUT  LPWSTR Unicode
    )
/*++

Routine Description:

    Convert an OEM (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Ansi - Specifies the ASCII zero terminated string to convert.

    Unicode - Specifies the pointer to the unicode buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/
{
    OEM_STRING  AnsiString;

    RtlInitString( &AnsiString, Ansi );

    return DhcpOemToUnicodeN(
                Ansi,
                Unicode,
                (USHORT) RtlOemStringToUnicodeSize( &AnsiString )
                );
}


ULONG
DhcpUnicodeToOemSize(
    IN LPWSTR Unicode
    )
/*++

Routine Description:

    This routine returns the number of bytes requried
    to store the OEM string equivalent of the provided
    UNICODE string.

Arguments:

    Unicode -- the input unicode string.

Return Values:

    0 -- if the string cannot be converted or is NULL
    number of bytes of storage required

--*/
{
    UNICODE_STRING UnicodeString;

    if( NULL == Unicode ) return 0;
    
    RtlInitUnicodeString( &UnicodeString, Unicode );
    return (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );
}

    


LPSTR
DhcpUnicodeToOem(
    IN LPWSTR Unicode,
    IN LPSTR Ansi
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding OEM
    string.

Arguments:

    Ansi - Specifies the UNICODE zero terminated string to convert.

    Ansi - Specifies the pointer to the oem buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated OEM string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/

{
    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );

    if( Ansi == NULL ) {
        AnsiString.Buffer = DhcpAllocateMemory( AnsiString.MaximumLength
    ); }
    else {
        AnsiString.Buffer = Ansi;
    }

    if ( AnsiString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUnicodeStringToOemString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        if( Ansi == NULL ) {
            DhcpFreeMemory( AnsiString.Buffer );
        }

        return NULL;
    }

    return AnsiString.Buffer;
}

DWORD
ConvertUnicodeToUTF8(
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength,
    LPBYTE  UTF8String,
    DWORD   UTF8Length
    )
/*++

Routine Description:

    This functions converts Unicodestring into Utf8 format.
    The unicodestring must be NULL terminated.

Arguments:

    Unicodestring - Pointer to the unicodestring

    UnicodeLength - Length of above string, or pass -1 if the above string is
                    NULL terminated.

    UTF8String - Buffer to receive UTF8String. If this is null then the function
                    returns the # of bytes needed for this buffer for conversion.

    UTF8Length - Length of the above buffer. if this is 0, the function
                will return the required length.

Return Value:

    No. of bytes converted.

--*/
{
    DWORD   Result;
    Result = WideCharToMultiByte(
                CP_UTF8,
                0,
                UnicodeString,
                UnicodeLength,
                UTF8String,
                UTF8Length,
                NULL,
                NULL
                );
    if (Result == 0 ) {
        DhcpPrint((0, "WideCharToMultiByte returned %ld\n", GetLastError()));
        DhcpAssert(0);
    }
    return Result;
}

DWORD
ConvertUTF8ToUnicode(
    LPBYTE  UTF8String,
    DWORD   UTF8Length,
    LPWSTR  UnicodeString,
    DWORD   UnicodeLength
    )
/*++

Routine Description:

    This functions converts Unicodestring into Utf8 format.
    The unicodestring must be NULL terminated.

Arguments:

    UTF8String - Buffer to UTFString.

    UTF8Length - Length of above buffer ; or pass -1 if the above string is NULL terminated.

    Unicodestring - Pointer to the buffer receiving unicodestring.

    UnicodeLength - Length of the above buffer. if this is 0, the function
                will return the required length.

Return Value:

    No. of bytes converted.

--*/
{
    DWORD Result;
    Result = MultiByteToWideChar(
                CP_UTF8,
                0,
                UTF8String,
                UTF8Length,
                UnicodeString,
                UnicodeLength
                );
    if (Result == 0 ) {
        DhcpPrint((0, "MultiByteToWideChar returned %ld\n", GetLastError()));
        DhcpAssert(0);
    }
    return Result;

}



VOID
DhcpHexToString(
    LPWSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to a Unicode
    string.  The string is not NULL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.


Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length * 2; i+=2 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + L'0';
        } else {
            Buffer[i+1] = j + L'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
DhcpHexToAscii(
    LPSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to an ASCII
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.

Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length; i+=1 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + '0';
        } else {
            Buffer[i+1] = j + 'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + '0';
        } else {
            Buffer[i] = j + 'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
DhcpDecimalToString(
    LPWSTR Buffer,
    BYTE Number
    )
/*++

Routine Description:

    This functions converts a single byte decimal digit to a 3 character
    Unicode string.  The string not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least 3 characters in size.

    Number - The number to convert.

Return Value:

    None.

--*/
{
    Buffer[2] = Number % 10 + L'0';
    Number /= 10;

    Buffer[1] = Number % 10 + L'0';
    Number /= 10;

    Buffer[0] = Number + L'0';

    return;
}



DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    )
/*++

Routine Description:

    This functions converts a dotted decimal form ASCII string to a
    Host order IP address.

Arguments:

    String - The address to convert.

Return Value:

    The corresponding IP address.

--*/
{
    struct in_addr addr;

    addr.s_addr = inet_addr( String );
    return( ntohl(*(LPDWORD)&addr) );
}



LPSTR
DhcpIpAddressToDottedString(
    DWORD IpAddress
    )
/*++

Routine Description:

    This functions converts a Host order IP address to a dotted decimal
    form ASCII string.

Arguments:

    IpAddress - Host order IP Address.

Return Value:

    String for IP Address.

--*/
{
    DWORD NetworkOrderIpAddress;

    NetworkOrderIpAddress = htonl(IpAddress);
    return(inet_ntoa( *(struct in_addr *)&NetworkOrderIpAddress));
}



DWORD
DhcpStringToHwAddress(
    LPSTR AddressBuffer,
    LPSTR AddressString
    )
/*++

Routine Description:

    This functions converts an ASCII string to a hex number.

Arguments:

    AddressBuffer - A pointer to a buffer which will contain the hex number.

    AddressString - The string to convert.

Return Value:

    The number of bytes written to AddressBuffer.

--*/
{
    int i = 0;
    char c1, c2;
    int value1, value2;

    while ( *AddressString != 0) {

        c1 = (char)toupper(*AddressString);

        if ( isdigit(c1) ) {
            value1 = c1 - '0';
        } else if ( c1 >= 'A' && c1 <= 'F' ) {
            value1 = c1 - 'A' + 10;
        }
        else {
            break;
        }

        c2 = (char)toupper(*(AddressString+1));

        if ( isdigit(c2) ) {
            value2 = c2 - '0';
        } else if ( c2 >= 'A' && c2 <= 'F' ) {
            value2 = c2 - 'A' + 10;
        }
        else {
            break;
        }

        AddressBuffer [i] = value1 * 16 + value2;
        AddressString += 2;
        i++;
    }

    return( i );
}


#if 0



DHCP_IP_ADDRESS
DhcpHostOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    )
/*++

Routine Description:

    This functions converts a network order IP address to host order.

Arguments:

    NetworkOrderAddress - A network order IP address.

Return Value:

    The host order IP address.

--*/
{
    return( ntohl( NetworkOrderAddress ) );
}



DHCP_IP_ADDRESS
DhcpNetworkOrder(
    DHCP_IP_ADDRESS HostOrderAddress
    )
/*++

Routine Description:

    This functions converts a network order IP address to host order.

Arguments:

    HostOrderAddress - A host order IP address.

Return Value:

    The network order IP address.

--*/
{
    return( htonl( HostOrderAddress ) );
}



VOID
DhcpIpAddressToString(
    LPWSTR Buffer,
    DWORD IpAddress
    )
/*++

Routine Description:

    This function converts an IP address from host order ASCII form.

Arguments:

    Buffer - Points to a buffer to the receive the ASCII form.  The
        buffer must be at least 8 WCHARs long.

    IpAddress - The IP address to convert.

Return Value:

    Nothing.

--*/
{
    int i;
    int j;

    for (i = 7; i >= 0; i-- ) {
        j = IpAddress & 0xF;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        IpAddress >>=4;
    }

    return;
}




VOID
DhcpStringToIpAddress(
    LPSTR Buffer,
    LPDHCP_IP_ADDRESS IpAddress,
    BOOL NetOrder
    )
/*++

Routine Description:

    This function converts an ASCII string IP Address to binary format.

Arguments:

    Buffer - Pointer to buffer containing the IP address.

    IpAddress - Points to a buffer to contain the binary format IP address.

    NetOrder - If TRUE, the address is converted to a network order address.
               If FALSE, the address is converted to a host order address.

Return Value:

    None.

--*/
{
    DWORD value;

    value = strtol( Buffer, NULL, 16 );

    if ( NetOrder ) {
        *IpAddress = htonl( value );
    } else {
        *IpAddress = value;
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\lib\dhcpcom.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpcom.c

Abstract:

    This module contains OS independent routines


Author:

    John Ludeman (johnl) 13-Nov-1993
        Broke out independent routines from existing files

Revision History:


--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <dhcpl.h>



LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
)
/*++

Routine Description:

    This function writes a DHCP option to message buffer.

Arguments:

    Option - A pointer to a message buffer.

    OptionType - The option number to append.

    OptionValue - A pointer to the option data.

    OptionLength - The lenght, in bytes, of the option data.

    OptionEnd - End of Option Buffer.

Return Value:

    A pointer to the end of the appended option.

--*/
{
    DWORD  i;

    if ( OptionType == OPTION_END ) {

        //
        // we should alway have atleast one BYTE space in the buffer
        // to append this option.
        //

        DhcpAssert( (LPBYTE)Option < OptionEnd );


        Option->OptionType = OPTION_END;
        return( (LPOPTION) ((LPBYTE)(Option) + 1) );

    }

    if ( OptionType == OPTION_PAD ) {

        //
        // add this option only iff we have enough space in the buffer.
        //

        if(((LPBYTE)Option + 1) < (OptionEnd - 1) ) {
            Option->OptionType = OPTION_PAD;
            return( (LPOPTION) ((LPBYTE)(Option) + 1) );
        }

        DhcpPrint(( 0, "DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }


    //
    // add this option only iff we have enough space in the buffer.
    //

    if(((LPBYTE)Option + 2 + OptionLength) >= (OptionEnd - 1) ) {
        DhcpPrint(( 0, "DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }

    if( OptionLength <= 0xFF ) {
        // simple option.. no need to use OPTION_MSFT_CONTINUED
        Option->OptionType = OptionType;
        Option->OptionLength = (BYTE)OptionLength;
        memcpy( Option->OptionValue, OptionValue, OptionLength );
        return( (LPOPTION) ((LPBYTE)(Option) + Option->OptionLength + 2) );
    }

    // option size is > 0xFF --> need to continue it using multiple ones..
    // there are OptionLenght / 0xFF occurances using 0xFF+2 bytes + one
    // using 2 + (OptionLength % 0xFF ) space..

    // check to see if we have the space first..

    if( 2 + (OptionLength%0xFF) + 0x101*(OptionLength/0xFF)
        + (LPBYTE)Option >= (OptionEnd - 1) ) {
        DhcpPrint(( 0, "DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }

    // first finish off all chunks of 0xFF size that we can do..

    i = OptionLength/0xFF;
    while(i --) {
        Option->OptionType = OptionType;
        Option->OptionLength = 0xFF;
        memcpy(Option->OptionValue, OptionValue, 0xFF);
        OptionValue = 0xFF+(LPBYTE)OptionValue;
        Option = (LPOPTION)(0x101 + (LPBYTE)Option);
        OptionType = OPTION_MSFT_CONTINUED;       // all but the first use this ...
        OptionLength -= 0xFF;
    }

    // now finish off the remaining stuff..
    DhcpAssert(OptionLength <= 0xFF);
    Option->OptionType = OPTION_MSFT_CONTINUED;
    Option->OptionLength = (BYTE)OptionLength;
    memcpy(Option->OptionValue, OptionValue, OptionLength);
    Option = (LPOPTION)(2 + OptionLength + (LPBYTE)Option);
    DhcpAssert((LPBYTE)Option < OptionEnd);

    return Option;
}

WIDE_OPTION UNALIGNED *
AppendWideOption(
    WIDE_OPTION UNALIGNED *Option,
    WORD  OptionType,
    PVOID OptionValue,
    WORD OptionLength,
    LPBYTE OptionEnd
)
/*++

Routine Description:

    This function writes a DHCP option to message buffer.

Arguments:

    Option - A pointer to a message buffer.

    OptionType - The option number to append.

    OptionValue - A pointer to the option data.

    OptionLength - The lenght, in bytes, of the option data.

    OptionEnd - End of Option Buffer.

Return Value:

    A pointer to the end of the appended option.

--*/
{
    DWORD  i;


    //
    // add this option only iff we have enough space in the buffer.
    //

    if(((LPBYTE)&Option->OptionValue + OptionLength) >= (OptionEnd - FIELD_OFFSET(WIDE_OPTION, OptionValue)) ) {
        DhcpPrint(( 0, "AppendWideOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }


    Option->OptionType = ntohs(OptionType);
    Option->OptionLength = ntohs(OptionLength);
    memcpy(Option->OptionValue, OptionValue, OptionLength);
    Option = (WIDE_OPTION UNALIGNED *)((PBYTE)&Option->OptionValue + OptionLength );
    DhcpAssert((LPBYTE)Option < OptionEnd);

    return Option;
}

WIDE_OPTION UNALIGNED *
AppendMadcapAddressList(
    WIDE_OPTION UNALIGNED * Option,
    DWORD UNALIGNED *AddrList,
    WORD            AddrCount,
    LPBYTE          OptionEnd
)
/*++

Routine Description:

    This function appends madcap address list option.

Arguments:

    Option - A pointer to a message buffer.

    AddrList - The list of the addresses to be attached.

    AddrCount - Count of addresses in above list.

    OptionEnd - End of Option Buffer.

Return Value:

    A pointer to the end of the appended option.

--*/
{
    DWORD StartAddr;
    WORD i;
    WORD BlockCount,BlockSize;
    PBYTE Buff;
    WORD  OptionLength;

    if (AddrCount < 1) {
        return Option;
    }
    // First find out how many blocks do we need
    for (BlockCount = i = 1; i<AddrCount; i++  ) {
        if (ntohl(AddrList[i]) != ntohl(AddrList[i-1]) + 1 ) {
            BlockCount++;
        }
    }

    OptionLength = BlockCount*6;
    if(((LPBYTE)&Option->OptionValue + OptionLength) >= (OptionEnd - FIELD_OFFSET(WIDE_OPTION, OptionValue)) ) {
        DhcpPrint(( 0, "AppendMadcapAddressList failed to append Option "
                    "Buffer too small\n" ));
        return Option;
    }

    StartAddr = AddrList[0];
    BlockSize = 1;
    Buff = Option->OptionValue;
    for (i = 1; i<AddrCount; i++  ) {
        if (ntohl(AddrList[i]) != ntohl(AddrList[i-1]) + 1 ) {
            BlockCount--;
            *(DWORD UNALIGNED *)Buff = StartAddr;
            Buff += 4;
            *(WORD UNALIGNED *)Buff = htons(BlockSize);
            Buff += 2;
            BlockSize = 1;
            StartAddr = AddrList[i];
        } else {
            BlockSize++;
        }
    }
    BlockCount--;
    DhcpAssert(0==BlockCount);
    *(DWORD UNALIGNED *)Buff = StartAddr;
    Buff += 4;
    *(WORD UNALIGNED *)Buff = htons(BlockSize);
    Buff += 2;

    Option->OptionType = ntohs(MADCAP_OPTION_ADDR_LIST);
    Option->OptionLength = htons(OptionLength);
    Option = (WIDE_OPTION UNALIGNED *)Buff;
    DhcpAssert((LPBYTE)Option < OptionEnd);

    return Option;

}

DWORD
ExpandMadcapAddressList(
    PBYTE   AddrRangeList,
    WORD    AddrRangeListSize,
    DWORD UNALIGNED *ExpandList,
    WORD   *ExpandListSize
    )

/*++

Routine Description:

    This function expands AddrRangeList from the wire format to array of
    addresses.

Arguments:

    AddrRangeList - pointer to the AddrRangeList option Buffer.

    AddrRangeListSize - size of the above buffer.

    ExpandList - the pointer to the array where addresses are to be expanded.
                   pass NULL if you want to determine the size of the expanded list.

    ExpandListSize - No. of elements in above array.

Return Value:

    Win32 ErrorCode
--*/
{
    WORD TotalCount, BlockSize;
    PBYTE ListEnd, Buff;
    DWORD StartAddr;

    // first count how many addresses we have in the list
    ListEnd = AddrRangeList + AddrRangeListSize;
    Buff = AddrRangeList;
    TotalCount = 0;
    while ((Buff + 6 ) <= ListEnd) {
        StartAddr = *(DWORD UNALIGNED *) Buff;
        Buff += 4;
        BlockSize = ntohs(*(WORD UNALIGNED *)Buff);
        Buff += 2;
        if (!CLASSD_NET_ADDR(StartAddr) || !CLASSD_NET_ADDR(htonl(ntohl(StartAddr)+BlockSize-1)) ) {
            return ERROR_BAD_FORMAT;
        }
        TotalCount += BlockSize;
    }
    if (NULL == ExpandList) {
        *ExpandListSize = TotalCount;
        return ERROR_BUFFER_OVERFLOW;
    }
    if (Buff != ListEnd || TotalCount > *ExpandListSize || 0 == TotalCount) {
        return ERROR_BAD_FORMAT;
    }
    // now expand the actual list.
    ListEnd = AddrRangeList + AddrRangeListSize;
    Buff = AddrRangeList;

    while ((Buff + 6 ) <= ListEnd) {
        StartAddr = *(DWORD UNALIGNED *) Buff;
        Buff += 4;
        BlockSize = ntohs(*(WORD UNALIGNED *)Buff);
        Buff += 2;
        StartAddr = ntohl(StartAddr);
        while (BlockSize--) {
            *ExpandList = htonl(StartAddr);
            StartAddr++;
            ExpandList++;
        }
    }
    DhcpAssert(Buff == ListEnd);
    *ExpandListSize = TotalCount;
    return ERROR_SUCCESS;
}


LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    )
/*++

Routine Description:

    This routine appends client ID option to a DHCP message.

History:
    8/26/96 Frankbee    Removed 16 byte limitation on the hardware
                        address

Arguments:

    Option - A pointer to the place to append the option request.

    ClientHWType - Client hardware type.

    ClientHWAddr - Client hardware address

    ClientHWAddrLength - Client hardware address length.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the newly appended option.

    Note : The client ID option will look like as below in the message:

     -----------------------------------------------------------------
    | OpNum | Len | HWType | HWA1 | HWA2 | .....               | HWAn |
     -----------------------------------------------------------------

--*/
{
    struct _CLIENT_ID {
        BYTE    bHardwareAddressType;
        BYTE    pbHardwareAddress[0];
    } *pClientID;

    LPOPTION lpNewOption;

    pClientID = DhcpAllocateMemory( sizeof( struct _CLIENT_ID ) + ClientHWAddrLength );

    //
    // currently there is no way to indicate failure.  simply return unmodified option
    // list
    //

    if ( !pClientID )
        return Option;

    pClientID->bHardwareAddressType    = ClientHWType;
    memcpy( pClientID->pbHardwareAddress, ClientHWAddr, ClientHWAddrLength );

    lpNewOption =  DhcpAppendOption(
                         Option,
                         OPTION_CLIENT_ID,
                         (LPBYTE)pClientID,
                         (BYTE)(ClientHWAddrLength + sizeof(BYTE)),
                         OptionEnd );

    DhcpFreeMemory( pClientID );

    return lpNewOption;
}



LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd
    )
/*++

Routine Description:

    This routine appends magic cookie to a DHCP message.

Arguments:

    Option - A pointer to the place to append the magic cookie.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the appended cookie.

    Note : The magic cookie is :

     --------------------
    | 99 | 130 | 83 | 99 |
     --------------------

--*/
{
    DhcpAssert( (Option + 4) < (OptionEnd - 1) );
    if( (Option + 4) < (OptionEnd - 1) ) {
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE1;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE2;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE3;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE4;
    }

    return( Option );
}



LPOPTION
DhcpAppendEnterpriseName(
    LPOPTION Option,
    PCHAR    DSEnterpriseName,
    LPBYTE   OptionEnd
    )
/*++

Routine Description:

    This routine appends the name of the enterprise as a MSFT-option to the
    DHCP message.

Arguments:

    Option - A pointer to the place to append the magic cookie.
    DSEnterpriseName - null-terminated string containing name of enterprise
    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the appended cookie.
--*/
{

    CHAR        Buffer[260];    // enough room?  should we malloc?
    DWORD       DSEnpriNameLen;
    LPOPTION    RetOpt;


    Buffer[0] = OPTION_MSFT_DSDOMAINNAME_RESP;

    if (DSEnterpriseName)
    {
        // how big is the enterprise name? (include the null terminator)
        DSEnpriNameLen = strlen(DSEnterpriseName) + 1;

        Buffer[1] = (BYTE)DSEnpriNameLen;

        strcpy(&Buffer[2],DSEnterpriseName);
    }

    //
    // if we are not part of any enterprise then DSEnterpriseName will be NULL
    // In that case, just return a null-string, so the receiver can positively
    // say we are a standalone server (as opposed to ignoring the option)
    //
    else
    {
        DSEnpriNameLen = 1;
        Buffer[1] = 1;
        Buffer[2] = '\0';
    }

    RetOpt = DhcpAppendOption(
                 Option,
                 OPTION_VENDOR_SPEC_INFO,
                 Buffer,
                 (BYTE)(DSEnpriNameLen + 2),  // include Buffer[0] and Buffer[1]
                 OptionEnd );

    return(RetOpt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\lib\dhcpl.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpl.h

Abstract:

    This file is the main header file for the dhcp library functions.

Author:

    Manny Weiser (mannyw) 12-Oct-1992

Revision History:

--*/

//#define __DHCP_USE_DEBUG_HEAP__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <winsock.h>

#include <stdlib.h>

#include <dhcp.h>
#include <dhcplib.h>

//
// debug heap support
//

#include <heapx.h>

#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__

#pragma message ( "*** DHCP Library will use debug heap ***" )

#define DhcpAllocateMemory(x) calloc(1,x)
#define DhcpFreeMemory(x)     free(x)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\inc\gmacros.h ===
/*================================================================================
$ Copyright (C) 1997 Microsoft Corporation
  File: gmacros.h
  Contains: Macros used in common by both the DHCP Server and the DHCP Client.
  	Most of them are inlines for sake of elegance and ease of usage.
  Author: RameshV
  Created: 04-Jun-97 00:01

================================================================================*/
#include <align.h>

//  Some block macros; usage at end

//  Disable the warning about unreference labels.
#pragma warning(disable : 4102)

#define _shorten(string)    ( strrchr(string, '\\')? strrchr(string, '\\') : (string) )

// print a message and the file and line # of whoever is printing this.
#define _TracePrintLine(Msg)  DhcpPrint((DEBUG_TRACE_CALLS, "%s:%d %s\n", _shorten(__FILE__), __LINE__, Msg))

#define BlockBegin(Name)    { BlockStart_ ## Name : _TracePrintLine( "Block -> " #Name );
#define BlockEnd(Name)      BlockEnd_ ## Name : _TracePrintLine( "Block <- " #Name ) ;}
#define BlockContinue(Name) do { _TracePrintLine( "Continue to " #Name); goto BlockStart_ ## Name; } while (0)
#define BlockBreak(Name)    do { _TracePrintLine( "Breaking out of " #Name); goto BlockEnd_ ## Name; } while (0)
#define RetFunc(F,Ret)      do {_TracePrintLine( "Quitting function " #F ); return Ret ; } while (0)

// The way to use the above set of simple block macros is as follows: (example usage)
#if     0
int
DummyFunction(VOID) {
    BlockBegin(DummyFunctionMain) {
        if(GlobalCount > 0 )
            BlockContinue(DummyFunctionMain);
        else GlobalCount ++;

        if(GlobalCount > GlobalCountMax)
            BlockBreak(DummyFunctionMain);
    } BlockEnd(DummyFunctionMain);

    RetFunc(DummyFunction, RetVal);
}
#endif

// now come some little more complicated functions..
// note that these can be freely mixed with the above set of simple functions.
#define BlockBeginEx(Name, String)    {BlockStart_ ## Name : _TracePrintLine( #String );
#define BlockEndEx(Name, String)      BlockEnd_## Name : _TracePrintLine( #String );}
#define BlockContinueEx(Name, String) do {_TracePrintLine( #String); goto BlockStart_ ## Name; } while (0)
#define BlockBreakEx(Name, String)    do {_TracePrintLine( #String); goto BlockEnd_ ## Name; } while(0)

#define RetFuncEx(Name,Ret,DebMsg)    do {_TracePrintLine( "QuittingFunction " #Name); DhcpPrint(DebMsg); return Ret;} while(0)

// usage example:

#if 0
int
DummyFunction(VOID) {
    BlockBeginEx(Main, "Entering Dummy Function" ) {
        if( GlobalCount > 0)
            BlockContinueEx(Main, GlobalCount > 0);
        else GlobalCount ++;

        if(GlobalCount > GlobalCountMax)
            BlockBreak(Main);
    } BlockEndEx(Main, "Done Dummy Function");

    RetFunc(DummyFunc, RetVal);
    // OR
    RetFuncEx(DummyFunc, RetVal, (DEBUG_ERRROS, "Function returning, gcount = %ld\n", GlobalCount));

}

#endif 0


#define NOTHING

// Now if a VOID function (procedure) returns, we can say RetFunc(VoidFunc, NOTHING) and things will work.


//================================================================================
//  Now some useful inlines.
//================================================================================

VOID _inline
FreeEx(LPVOID Ptr) {
    if(Ptr) DhcpFreeMemory(Ptr);
}

VOID _inline
FreeEx2(LPVOID Ptr1, LPVOID Ptr2) {
    FreeEx(Ptr1); FreeEx(Ptr2);
}

VOID _inline
FreeEx3(LPVOID Ptr1, LPVOID Ptr2, LPVOID Ptr3) {
    FreeEx(Ptr1); FreeEx(Ptr2); FreeEx(Ptr3);
}

VOID _inline
FreeEx4(LPVOID Ptr1, LPVOID Ptr2, LPVOID Ptr3, LPVOID Ptr4) {
    FreeEx2(Ptr1, Ptr2); FreeEx2(Ptr3, Ptr4);
}

//--------------------------------------------------------------------------------
//  All the alloc functions below, allocate in one shot a few pointers,
//  and initialize them.. aligning them correctly.
//--------------------------------------------------------------------------------
LPVOID _inline
AllocEx(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + Size2;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);

    return Ptr;
}

LPVOID _inline
AllocEx2(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + Size2;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);

    return Ptr;
}

LPVOID _inline
AllocEx3(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2, LPVOID *Ptr3, DWORD Size3) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST) + Size3;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);
    (*Ptr3) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST);
    return Ptr;
}

LPVOID _inline
AllocEx4(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2,
         LPVOID *Ptr3, DWORD Size3, LPVOID *Ptr4, DWORD Size4) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) +
    	ROUND_UP_COUNT(Size2, ALIGN_WORST) + ROUND_UP_COUNT(Size3, ALIGN_WORST) + Size4;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);
    (*Ptr3) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST);
    (*Ptr4) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) +
    	ROUND_UP_COUNT(Size2, ALIGN_WORST) + ROUND_UP_COUNT(Size3, ALIGN_WORST);
    return Ptr;
}

//--------------------------------------------------------------------------------
//  This function takes an input string and a static buffer and if the input
//  string is not nul terminated, copies it to the static buffer and then null
//  terminates it.  It also change the size to reflect the new size..
//--------------------------------------------------------------------------------
LPBYTE _inline
AsciiNulTerminate(LPBYTE Input, DWORD *Size, LPBYTE StaticBuf, DWORD BufSize) {
    if( 0 == *Size) return Input;   // nothing to copy
    if(!Input[(*Size)-1]) return Input; // Everything is fine.

    if(*Size >= BufSize) {
        // Nothing much can be done here.. this is an error.. insufficient buffer space.
        DhcpAssert(FALSE);

        *Size = BufSize - 1;
    }

    memcpy(StaticBuf, Input, (*Size));
    StaticBuf[*Size] = '\0';
    (*Size) ++;
    return StaticBuf;
}

#if DBG
#define INLINE
#else
#define INLINE _inline
#endif

#define BEGIN_EXPORT
#define END_EXPORT

#define AssertReturn(Condition, RetVal )    do { DhcpAssert(Condition); return RetVal ;} while(0)

//================================================================================
//  End of File.
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\lib\dhcp.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.c

Abstract:

    This module contains DHCP specific utility routines used by the
    DHCP components.

Author:

    Manny Weiser (mannyw) 12-Aug-1992

Revision History:

    Madan Appiah (madana) 21-Oct-1992

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <dhcpl.h>

DWORD
NTTimeToNTPTime(PULONG pTime,
                PFILETIME pft OPTIONAL);

DWORD
NTPTimeToNTFileTime(PLONG pTime, PFILETIME pft, BOOL bHostOrder);

#undef DhcpAllocateMemory
#undef DhcpFreeMemory


PVOID
DhcpAllocateMemory(
    DWORD Size
    )
/*++

Routine Description:

    This function allocates the required size of memory by calling
    LocalAlloc.

Arguments:

    Size - size of the memory block required.

Return Value:

    Pointer to the allocated block.

--*/
{

    ASSERT( Size != 0 );

    return( LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size ) );
}

#undef DhcpFreeMemory

VOID
DhcpFreeMemory(
    PVOID Memory
    )
/*++

Routine Description:

    This function frees up the memory that was allocated by
    DhcpAllocateMemory.

Arguments:

    Memory - pointer to the memory block that needs to be freed up.

Return Value:

    none.

--*/
{

    LPVOID Ptr;

    ASSERT( Memory != NULL );
    Ptr = LocalFree( Memory );

    ASSERT( Ptr == NULL );
}



DATE_TIME
DhcpCalculateTime(
    DWORD RelativeTime
    )
/*++

Routine Description:

    The function calculates the absolute time of a time RelativeTime
    seconds from now.

Arguments:

    RelativeTime - Relative time, in seconds.

Return Value:

    The time in RelativeTime seconds from the current system time.

--*/
{
    SYSTEMTIME systemTime;
    ULONGLONG absoluteTime;

    if( RelativeTime == INFINIT_LEASE ) {
        ((DATE_TIME *)&absoluteTime)->dwLowDateTime =
            DHCP_DATE_TIME_INFINIT_LOW;
        ((DATE_TIME *)&absoluteTime)->dwHighDateTime =
            DHCP_DATE_TIME_INFINIT_HIGH;
    }
    else {

        GetSystemTime( &systemTime );
        SystemTimeToFileTime(
            &systemTime,
            (FILETIME *)&absoluteTime );

        absoluteTime = absoluteTime + RelativeTime * (ULONGLONG)10000000; }

    return( *(DATE_TIME *)&absoluteTime );
}


DATE_TIME
DhcpGetDateTime(
    VOID
    )
/*++

Routine Description:

    This function returns FILETIME.

Arguments:

    none.

Return Value:

    FILETIME.

--*/
{
    SYSTEMTIME systemTime;
    DATE_TIME Time;

    GetSystemTime( &systemTime );
    SystemTimeToFileTime( &systemTime, (FILETIME *)&Time );

    return( Time );
}

VOID
DhcpNTToNTPTime(
    LPDATE_TIME AbsNTTime,
    DWORD       Offset,
    PULONG      NTPTimeStamp
    )
/*++

Routine Description:

    The function calculates the absolute NTP timestamp from AbsTime on
    NT added by given offset.

Arguments:

    AbsNTTime - AbsTime on NT. If 0, it will use current time.

    RelativeOffset - offset to be added to AnsNTTime (in seconds.)

Return Value:

    The time in RelativeTime seconds from the current system time.

--*/
{
    ULONGLONG   LocalAbsNTTime;
    DWORD       Error;

    if ( AbsNTTime == 0 ) {
        GetSystemTimeAsFileTime((FILETIME *)&LocalAbsNTTime );
    } else {
        LocalAbsNTTime = *(ULONGLONG *)AbsNTTime;
    }

    // add offset
    LocalAbsNTTime += Offset * (ULONGLONG)10000000;

    // now convert to NT timestamp
    Error = NTTimeToNTPTime( NTPTimeStamp, (PFILETIME)&LocalAbsNTTime );

    DhcpAssert( ERROR_SUCCESS == Error );
    return;
}

VOID
DhcpNTPToNTTime(
    PULONG          NTPTimeStamp,
    DWORD           Offset,
    DATE_TIME       *NTTime
    )
/*++

Routine Description:

    The function calculates the absolute NTP timestamp from AbsTime on
    NT added by given offset.

Arguments:

    AbsNTTime - AbsTime on NT. If 0, it will use current time.

    RelativeOffset - offset to be added to AnsNTTime (in seconds.)

Return Value:

    The time in RelativeTime seconds from the current system time.

--*/
{
    ULONGLONG LocalAbsNTTime;
    DWORD       Error;

    Error = NTPTimeToNTFileTime(
                NTPTimeStamp,
                (FILETIME *)&LocalAbsNTTime,
                FALSE                           // not in host order.
                );

    DhcpAssert( ERROR_SUCCESS == Error );

    // add offset
    LocalAbsNTTime += Offset * (ULONGLONG)10000000;

    // now convert to NT timestamp
    // MBUG

    *(ULONGLONG *)NTTime = LocalAbsNTTime;
    return;
}


DWORD
DhcpReportEventW(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    Source - Points to a null-terminated string that specifies the name
             of the module referenced. The node must exist in the
             registration database, and the module name has the
             following format:

                \EventLog\System\Lanmanworkstation

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //

    EventlogHandle = RegisterEventSourceW(
                    NULL,
                    Source
                    );

    if (EventlogHandle == NULL) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //

    if( !ReportEventW(
            EventlogHandle,
            (WORD)EventType,
            0,            // event category
            EventID,
            NULL,
            (WORD)NumStrings,
            DataLength,
            Strings,
            Data
            ) ) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {

        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


DWORD
DhcpReportEventA(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    Source - Points to a null-terminated string that specifies the name
             of the module referenced. The node must exist in the
             registration database, and the module name has the
             following format:

                \EventLog\System\Lanmanworkstation

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //

    EventlogHandle = RegisterEventSourceW(
                    NULL,
                    Source
                    );

    if (EventlogHandle == NULL) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //

    if( !ReportEventA(
            EventlogHandle,
            (WORD)EventType,
            0,            // event category
            EventID,
            NULL,
            (WORD)NumStrings,
            DataLength,
            Strings,
            Data
            ) ) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {

        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


DWORD
DhcpLogUnknownOption(
    LPWSTR Source,
    DWORD EventID,
    LPOPTION Option
    )
/*++

Routine Description:

    This routine logs an unknown DHCP option to event log.

Arguments:

    Source - name of the app that logs this error. it should be either
        "DhcpClient" or "DhcpServer".

    EventID - Event identifier number.

    Option - pointer to the unknown option structure.

Return Value:

    Windows Error code.

--*/
{
    LPWSTR  Strings[2];
    WCHAR StringsBuffer[ 2 * (3 + 1) ];
        // for two string each is 1byte decimal number (0 - 255).

    LPWSTR StringsPtr = StringsBuffer;

    //
    // convert option number.
    //

    Strings[0] = StringsPtr;
    DhcpDecimalToString( StringsPtr, Option->OptionType );
    StringsPtr += 3;

    *StringsPtr++ = L'\0';

    //
    // convert option length.
    //
    Strings[1] = StringsPtr;
    DhcpDecimalToString( StringsPtr, Option->OptionLength );
    StringsPtr += 3;

    *StringsPtr++ = L'\0';


    //
    // log error.
    //

    return(
        DhcpReportEventW(
            Source,
            EventID,
            EVENTLOG_WARNING_TYPE,
            2,
            (DWORD)Option->OptionLength,
            Strings,
            (PVOID)Option->OptionValue )
        );
}

#if DBG

VOID
DhcpAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{
#ifndef DHCP_NOASSERT
    RtlAssert(
            FailedAssertion,
            FileName,
            (ULONG) LineNumber,
            (PCHAR) Message);
#endif

    DhcpPrint(( 0, "Assert @ %s \n", FailedAssertion ));
    DhcpPrint(( 0, "Assert Filename, %s \n", FileName ));
    DhcpPrint(( 0, "Line Num. = %ld.\n", LineNumber ));
    DhcpPrint(( 0, "Message is %s\n", Message ));

}

#endif



LPWSTR
DhcpRegIpAddressToKey(
    DHCP_IP_ADDRESS IpAddress,
    LPWSTR KeyBuffer
    )
/*++

Routine Description:

    This function converts an IpAddress to registry key. The registry
    key is unicode string of IpAddress in dotted form.

Arguments:

    IpAddress : IpAddress that needs conversion. The IpAddress is in
                host order.

    KeyBuffer : pointer a buffer that will hold the converted
                registry key. The buffer should be big enough to
                converted key.

Return Value:

    Pointer to the key the buffer.

--*/
{
    LPSTR OemKey;
    LPWSTR UnicodeKey;
    DWORD NetworkOrderIpAddress;

    NetworkOrderIpAddress = htonl(IpAddress);

    OemKey = inet_ntoa( *(struct in_addr *)&NetworkOrderIpAddress );
    UnicodeKey = DhcpOemToUnicode( OemKey, KeyBuffer );

    DhcpAssert( UnicodeKey == KeyBuffer );

    return( UnicodeKey );

}



DHCP_IP_ADDRESS
DhcpRegKeyToIpAddress(
    LPWSTR Key
    )
/*++

Routine Description:

    This function converts registry key to Ip Address.

Arguments:

    Key : Pointer to registry key.

Return Value:

    Converted IpAddress.

--*/
{
    CHAR OemKeyBuffer[DHCP_IP_KEY_LEN];
    LPSTR OemKey;


    OemKey = DhcpUnicodeToOem( Key, OemKeyBuffer );
    DhcpAssert( OemKey == OemKeyBuffer );

    return( ntohl(inet_addr( OemKey )) );
}



LPWSTR
DhcpRegOptionIdToKey(
    DHCP_OPTION_ID OptionId,
    LPWSTR KeyBuffer
    )
/*++

Routine Description:

    This function converts an OptionId to registry key. The registry
    key is unicode string of OptionId, 3 unicode char. long and of the
    form L"000".

Arguments:

    IpAddress : IpAddress that needs conversion.

    KeyBuffer : pointer a buffer that will hold the converted
                registry key. The buffer should be at least 8 char.
                long.

Return Value:

    Pointer to the key the buffer.

--*/

{
    int i;

    for (i = 2; i >= 0; i--) {
        KeyBuffer[i] = L'0' + (BYTE)(OptionId % 10 );
        OptionId /= 10;
    }
    KeyBuffer[3] = L'\0';

    return( KeyBuffer );
}



DHCP_OPTION_ID
DhcpRegKeyToOptionId(
    LPWSTR Key
    )
/*++

Routine Description:

    This function converts registry key to OptionId.

Arguments:

    Key : Pointer to registry key.

Return Value:

    Converted OptionId.

--*/

{
    DHCP_OPTION_ID OptionId = 0;
    int i;

    for (i = 0; i < 3 && Key[i] != L'\0'; i++) {
        OptionId = (OptionId * 10) + (Key[i] - L'0');
    }
    return( OptionId );
}

DWORD
DhcpStartWaitableTimer(
    HANDLE TimerHandle,
    DWORD SleepTime)
/*++

Routine Description:

    This routine starts the waitable timer. This timer fires off even
    when the system is in hibernate state.

Arguments

    TimerHandle - Waitable Timer Handle

    SleepTime   - Sleep Time in seconds.

Return Value:

    Status of the operation.

--*/
{
    DATE_TIME       SleepTimeInNSec; // sleep time in nano seconds since Jan 1 1901
    DWORD           Error;
    BOOL            Result;

    Error = STATUS_SUCCESS;
    SleepTimeInNSec = DhcpCalculateTime( SleepTime );

    Result = SetWaitableTimer(
                TimerHandle,            // handle to timer object
                (LARGE_INTEGER *)&SleepTimeInNSec,       // due time.
                0,                      // not periodic
                NULL,                   // completion routine
                NULL,                   // completion routine arg
                TRUE                    // resume power state when due
                );
    if ( !Result ) {
        DhcpPrint((0, "SetWaitableTimer reported Error = %d\n",Error=GetLastError()));
    }
    return Error;
}

VOID
DhcpCancelWaitableTimer(
    HANDLE TimerHandle
    )
/*++

Routine Description:

    This routine cancels the waitable timer.

Arguments

    TimerHandle - Waitable Timer Handle

Return Value:


--*/
{
    BOOL Result;

    Result = CancelWaitableTimer( TimerHandle );
    if ( !Result ) {
        DhcpPrint((0,"SetWaitableTimer reported Error = %lx\n",GetLastError()));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\lib\dhcpdump.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpprt.c

Abstract:

    This module contains DHCP specific utility routines used by the
    DHCP components.

Author:

    Madan Appiah (madana) 16-Sep-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <dhcpl.h>


#if DBG

VOID
DhcpDumpMessage(
    DWORD DhcpDebugFlag,
    LPDHCP_MESSAGE DhcpMessage,
    ULONG MessageSize
    )
/*++

Routine Description:

    This function dumps a DHCP packet in human readable form.

Arguments:

    DhcpDebugFlag - debug flag that indicates what we are debugging.

    DhcpMessage - A pointer to a DHCP message.

Return Value:

    None.

--*/
{
    LPOPTION option;
    BYTE i;

    DhcpPrint(( DhcpDebugFlag, "Dhcp message: \n\n"));

    DhcpPrint(( DhcpDebugFlag, "Operation              :"));
    if ( DhcpMessage->Operation == BOOT_REQUEST ) {
        DhcpPrint(( DhcpDebugFlag,  "BootRequest\n"));
    } else if ( DhcpMessage->Operation == BOOT_REPLY ) {
        DhcpPrint(( DhcpDebugFlag,  "BootReply\n"));
    } else {
        DhcpPrint(( DhcpDebugFlag,  "Unknown\n"));
    }

    DhcpPrint(( DhcpDebugFlag, "Hardware Address type  : %d\n", DhcpMessage->HardwareAddressType));
    DhcpPrint(( DhcpDebugFlag, "Hardware Address Length: %d\n", DhcpMessage->HardwareAddressLength));
    DhcpPrint(( DhcpDebugFlag, "Hop Count              : %d\n", DhcpMessage->HopCount ));
    DhcpPrint(( DhcpDebugFlag, "Transaction ID         : %lx\n", DhcpMessage->TransactionID ));
    DhcpPrint(( DhcpDebugFlag, "Seconds Since Boot     : %d\n", DhcpMessage->SecondsSinceBoot ));
    DhcpPrint(( DhcpDebugFlag, "Client IP Address      : " ));
    DhcpPrint(( DhcpDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&DhcpMessage->ClientIpAddress ) ));

    DhcpPrint(( DhcpDebugFlag, "Your IP Address        : " ));
    DhcpPrint(( DhcpDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&DhcpMessage->YourIpAddress ) ));

    DhcpPrint(( DhcpDebugFlag, "Server IP Address      : " ));
    DhcpPrint(( DhcpDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&DhcpMessage->BootstrapServerAddress ) ));

    DhcpPrint(( DhcpDebugFlag, "Relay Agent IP Address : " ));
    DhcpPrint(( DhcpDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&DhcpMessage->RelayAgentIpAddress ) ));

    DhcpPrint(( DhcpDebugFlag, "Hardware Address       : "));
    for ( i = 0; i < DhcpMessage->HardwareAddressLength; i++ ) {
        DhcpPrint(( DhcpDebugFlag, "%2.2x", DhcpMessage->HardwareAddress[i] ));
    }

    option = &DhcpMessage->Option;

    DhcpPrint(( DhcpDebugFlag, "\n\n"));
    DhcpPrint(( DhcpDebugFlag, "Magic Cookie: "));
    for ( i = 0; i < 4; i++ ) {
        DhcpPrint(( DhcpDebugFlag, "%d ", *((LPBYTE)option)++ ));
    }
    DhcpPrint(( DhcpDebugFlag, "\n\n"));

    DhcpPrint(( DhcpDebugFlag, "Options:\n"));
    while ( option->OptionType != 255 ) {
        DhcpPrint(( DhcpDebugFlag, "\tType = %d ", option->OptionType ));
        for ( i = 0; i < option->OptionLength; i++ ) {
            DhcpPrint(( DhcpDebugFlag, "%2.2x", option->OptionValue[i] ));
        }
        DhcpPrint(( DhcpDebugFlag, "\n"));

        if ( option->OptionType == OPTION_PAD ||
             option->OptionType == OPTION_END ) {

            option = (LPOPTION)( (LPBYTE)(option) + 1);

        } else {

            option = (LPOPTION)( (LPBYTE)(option) + option->OptionLength + 2);

        }

        if ( (ULONG)((LPBYTE)option - (LPBYTE)DhcpMessage) > MessageSize ) {
            DhcpPrint(( DhcpDebugFlag, "End of message, but no trailer found!\n"));
            break;
        }
    }
}

VOID
MadcapDumpMessage(
    DWORD DhcpDebugFlag,
    LPMADCAP_MESSAGE MadcapMessage,
    ULONG MessageSize
    )
/*++

Routine Description:

    This function dumps a DHCP packet in human readable form.

Arguments:

    DhcpDebugFlag - debug flag that indicates what we are debugging.

    MadcapMessage - A pointer to a DHCP message.

Return Value:

    None.

--*/
{
    WIDE_OPTION UNALIGNED*         NextOpt;
    BYTE        UNALIGNED*         EndOpt;
    DWORD                          Size;
    DWORD                          OptionType;
    BYTE i;

    DhcpPrint(( DhcpDebugFlag, "Madcap message: \n\n"));

    DhcpPrint(( DhcpDebugFlag, "Version                : %d\n",MadcapMessage->Version));
    DhcpPrint(( DhcpDebugFlag, "MessageType            : %d\n",MadcapMessage->MessageType));
    DhcpPrint(( DhcpDebugFlag, "AddressFamily          : %d\n",ntohs(MadcapMessage->AddressFamily)));
    DhcpPrint(( DhcpDebugFlag, "TransactionId          : %d\n",MadcapMessage->TransactionID));

    DhcpPrint(( DhcpDebugFlag, "\n\n"));
    DhcpPrint(( DhcpDebugFlag, "Options:\n"));
    // MBUG CHANGE 255 TO end option
    NextOpt = (WIDE_OPTION UNALIGNED*)&MadcapMessage->Option;
    EndOpt = (PBYTE)MadcapMessage + MessageSize;
    while( NextOpt->OptionValue <= EndOpt &&
           MADCAP_OPTION_END != (OptionType = ntohs(NextOpt->OptionType)) ) {

        Size = ntohs(NextOpt->OptionLength);
        if ((NextOpt->OptionValue + Size) > EndOpt) {
            break;
        }

        DhcpPrint(( DhcpDebugFlag, "\tType = %d ", OptionType ));
        for ( i = 0; i < Size; i++ ) {
            DhcpPrint(( DhcpDebugFlag, "%2.2x", NextOpt->OptionValue[i] ));
        }
        DhcpPrint(( DhcpDebugFlag, "\n"));

        NextOpt = (WIDE_OPTION UNALIGNED*)(NextOpt->OptionValue + Size);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\common\precomp.h ===
/*++

Copyright (C) 1999 Microsoft corporation

--*/

#define MAX_DLL_NAME    48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>

#include <winsock.h>

#include <dhcpapi.h>

#include <mdhcsapi.h>

#include <tchar.h>
#include <wchar.h>

#include <netsh.h>
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\lib\network.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    network.c

Abstract:

    This module contains network specific utility routines used by the
    DHCP components.

Author:

    Manny Weiser (mannyw) 12-Aug-1992

Revision History:

--*/

#include "dhcpl.h"


DHCP_IP_ADDRESS
DhcpDefaultSubnetMask(
    DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:

    This function calculates the default subnet mask for a given IP
    address.

Arguments:

    IpAddress - The address for which a subnet mask is needed.

Return Value:

    The default subnet mask.
    -1, if the supplied IP address is invalid.

--*/
{
    if ( IN_CLASSA( IpAddress ) ) {
        return( IN_CLASSA_NET );
    } else if ( IN_CLASSB( IpAddress ) ) {
        return( IN_CLASSB_NET );
    } else if ( IN_CLASSC( IpAddress ) ) {
        return( IN_CLASSC_NET );
    } else {
        return( (DHCP_IP_ADDRESS)-1 );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\dump.c ===
//
// Copyright (C) 1999 Microsoft Corporation
//
//Implementation of dump functionality for DHCP

#include "precomp.h"


DWORD
DhcpDumpServer(
               IN LPCWSTR  pwszIpAddress,
               IN DWORD    dwMajor,
               IN DWORD    dwMinor
               )
{
    DWORD                       Error = NO_ERROR;
    DHCP_RESUME_HANDLE          ResumeHandle = 0;
    LPDHCP_CLASS_INFO_ARRAY     ClassInfoArray = NULL;
    LPDHCP_OPTION_ARRAY         OptionsArray = NULL;
    LPDHCP_ALL_OPTIONS          OptionsAll = NULL;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    LPDHCP_OPTION_VALUE         OptionValue = NULL;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo = {0};
    LPDHCP_OPTION_VALUE_ARRAY   OptionArray = NULL;
    LPDHCP_IP_ARRAY             IpArray = NULL;
    LPDHCP_MSCOPE_TABLE         MScopeTable = NULL;

    DWORD                       nRead = 0,
                                dw = 0,
                                nCount = 0,
                                nTotal = 0;


    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerScriptHeader(pwszIpAddress);

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    DhcpDumpServerClassHeader();

    if( dwMajor >= CLASS_ID_VERSION )
    {
        //Dump Class Information script.

        while(TRUE)
        {
            Error = DhcpEnumClasses(
                        (LPWSTR)pwszIpAddress,
                        0,
                        &ResumeHandle,
                        ~0,
                        &ClassInfoArray,
                        &nRead,
                        &nTotal);

            if( Error is ERROR_NO_MORE_ITEMS)
                break;

            if( Error is NO_ERROR or
                Error is ERROR_MORE_DATA )
            {
                for( dw=0; dw<nRead; dw++ )
                {
                    DhcpDumpServerClass(pwszIpAddress,
                                        ClassInfoArray->Classes[dw]
                                       );
                }
            
                nCount += nRead;

                if( Error is ERROR_MORE_DATA )
                {
                    DhcpRpcFreeMemory(ClassInfoArray);
                    ClassInfoArray = NULL;
                    continue;
                }
                else
                    break;
            }
            else
                goto ErrorReturn;
        }
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerClassFooter();

    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    //Dump Optiondefs


    DhcpDumpServerOptiondefHeader();

    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    ResumeHandle = 0;
    nRead = nTotal = nCount = 0;

    while(TRUE)
    {
        if( dwMajor >= CLASS_ID_VERSION )
        {
            Error = DhcpGetAllOptions(
                           (LPWSTR)pwszIpAddress,
                           0,
                           &OptionsAll);
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                break;
            }
            
            if( Error is NO_ERROR or
                Error is ERROR_MORE_DATA )
            {
                DhcpDumpServerOptiondefV5(pwszIpAddress,
                                          OptionsAll);
                if( Error is NO_ERROR )
                    break;
                else
                {
                    DhcpRpcFreeMemory(OptionsAll);
                    OptionsAll = NULL;
                    continue;
                }
            }
            else
                goto ErrorReturn;
        }
        else
        {
            Error = DhcpEnumOptions(
                           (LPWSTR)pwszIpAddress,
                           &ResumeHandle,
                           ~0,
                           &OptionsArray,
                           &nRead,
                           &nTotal);

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                break;
            }

            if( Error is NO_ERROR or
                Error is ERROR_MORE_DATA )
            {

                DhcpDumpServerOptiondef(pwszIpAddress,
                                        OptionsArray);
                if( Error is NO_ERROR )
                    break;
                else
                {
                    DhcpRpcFreeMemory(OptionsArray);
                    OptionsArray = NULL;
                    continue;
                }
            }
        }                        
    }

    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    DhcpDumpServerOptiondefFooter();
    
    
    //Dump Option Values set


    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerOptionvalueHeader();

    ResumeHandle = 0;
    nRead = nTotal = nCount = 0;

    ScopeInfo.ScopeType = DhcpGlobalOptions;

    while(TRUE)
    {
        if( dwMajor >= CLASS_ID_VERSION )
        {
            Error = DhcpGetAllOptionValues(
                            (LPWSTR)pwszIpAddress,
                            DHCP_OPT_ENUM_IGNORE_VENDOR,
                            &ScopeInfo,
                            &OptionValues
                            );

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                break;
            }
            
            if( Error is NO_ERROR or
                Error is ERROR_MORE_DATA )
            {
                DhcpDumpServerOptionValuesV5(pwszIpAddress,
                                             NULL,
                                             NULL,
                                             OptionValues);
                if( Error is NO_ERROR )
                    break;
                else
                {
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                    continue;
                }
            }
            else
                goto ErrorReturn;
        }
        else
        {
             Error = DhcpEnumOptions(
                            (LPWSTR)pwszIpAddress,
                            &ResumeHandle,
                            ~0,
                            &OptionsArray,
                            &nRead,
                            &nTotal);
        
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                Error = NO_ERROR;
                break;
            }

            if( Error isnot NO_ERROR  &&
                Error isnot ERROR_MORE_DATA )
                goto ErrorReturn;

            for( dw = 0; dw < nRead; dw++ )
            {
                DHCP_OPTION_ID OptionId = OptionsArray->Options[dw].OptionID;
                DWORD          dwError = NO_ERROR;
                dwError = DhcpGetOptionValue(
                                             (LPWSTR)pwszIpAddress,
                                             OptionId,
                                             &ScopeInfo,
                                             &OptionValue);
                               
                if( dwError isnot NO_ERROR )
                {
                    continue;
                }
        
                if( OptionValue )
                {
                    DhcpDumpServerOptionValue(pwszIpAddress,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL,
                                              FALSE,
                                              *OptionValue);
                    DhcpRpcFreeMemory(OptionValue);
                    OptionValue = NULL;
                }
            }
    
            if( OptionsArray )
            {
                DhcpRpcFreeMemory(OptionsArray);
                OptionsArray = NULL;
            }

            if( Error is NO_ERROR )
                break;
            else
                continue;
        }
                        
    }


    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    
    DhcpDumpServerOptionvalueFooter();

    //Dump Audit Log Information
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    {
        LPWSTR pwszLogDir = NULL;
        DWORD  DiskCheckInterval=0, MaxLogFileSize=0, MinSpaceOnDisk=0;

        Error = DhcpAuditLogGetParams( g_ServerIpAddressUnicodeString,
                                       0,
                                       &pwszLogDir,
                                       &DiskCheckInterval,
                                       &MaxLogFileSize,
                                       &MinSpaceOnDisk);
        
        if( Error is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_AUDITLOG,
                           g_ServerIpAddressUnicodeString,
                           pwszLogDir);
        }

        if( pwszLogDir )
        {
            DhcpRpcFreeMemory(pwszLogDir);
            pwszLogDir = NULL;
        }

    }

    //Dump Dns Information
    {
        DHCP_OPTION_SCOPE_INFO ScopeInfo = {0};
        DHCP_OPTION_ID         OptionId = 81;
        LPDHCP_OPTION_VALUE    OptionValue = NULL;

        DWORD   dwValue = 0;

        ScopeInfo.ScopeType = DhcpGlobalOptions;

        if( g_dwMajorVersion >= CLASS_ID_VERSION )
        {
            Error = DhcpGetOptionValueV5(g_ServerIpAddressUnicodeString,
                                         0,
                                         OptionId,    //DYNDNS option
                                         NULL,
                                         NULL,
                                         &ScopeInfo,
                                         &OptionValue);
        }
        else
        {
            Error = DhcpGetOptionValue(g_ServerIpAddressUnicodeString,
                                       OptionId,//81,
                                       &ScopeInfo,
                                       &OptionValue);
        }

        if( Error is NO_ERROR )
        {
            dwValue = OptionValue->Value.Elements->Element.DWordOption;

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DNSCONFIG,
                           g_ServerIpAddressUnicodeString,
                           ( dwValue & DNS_FLAG_ENABLED ) ? 1 : 0,
                           ( dwValue & DNS_FLAG_UPDATE_BOTH_ALWAYS ) ? 1 : 0,
                           ( dwValue & DNS_FLAG_CLEANUP_EXPIRED ) ? 1 : 0,
                           ( dwValue & DNS_FLAG_UPDATE_DOWNLEVEL ) ? 1 : 0 );

        }

        if( OptionValue )
        {
            DhcpRpcFreeMemory(OptionValue);
            OptionValue = NULL;
        }

    }
       
    //Dump database configuration information

    {
        LPDHCP_SERVER_CONFIG_INFO_V4    ConfigInfo = NULL;

        Error = DhcpServerGetConfigV4(g_ServerIpAddressUnicodeString,
                                      &ConfigInfo);

        if( Error is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_BACKUPINTERVAL,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->BackupInterval);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_BACKUPPATH,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->BackupPath);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DATABASECLEANUPINTERVAL,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->DatabaseCleanupInterval);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DATABASELOGGINGFLAG,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->DatabaseLoggingFlag);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DATABASENAME,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->DatabaseName);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DATABASEPATH,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->DatabasePath);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DATABASERESTOREFLAG,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->RestoreFlag);

            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_DETECTCONFLICTRETRY,
                           g_ServerIpAddressUnicodeString,
                           ConfigInfo->dwPingRetries);
        }

        if( ConfigInfo )
        {
            DhcpRpcFreeMemory(ConfigInfo);
            ConfigInfo = NULL;
        }
    }
    //Dump Scope Information

    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerScopeHeader();

    nRead = nTotal = 0;
    ResumeHandle = 0;


    while(TRUE)
    {

        Error = DhcpEnumSubnets(
                    (LPWSTR)pwszIpAddress,
                    &ResumeHandle,
                    ~0,
                    &IpArray,
                    &nRead,
                    &nTotal
                    );
        
        if( Error is ERROR_NO_MORE_ITEMS )
        {
            Error = NO_ERROR;
            break;
        }
        if( Error isnot NO_ERROR and
            Error isnot ERROR_MORE_DATA )
        {
            goto ErrorReturn;
        }

       
        for( dw=0; dw<nRead; dw++ )
        {
            Error = DhcpDumpScope(pwszIpAddress,
                          dwMajor,
                          dwMinor,
                          IpArray->Elements[dw]);
            if( Error is ERROR_NOT_ENOUGH_MEMORY )
                goto ErrorReturn;
        }
        if( Error is NO_ERROR )
            break;
        else
        {
            DhcpRpcFreeMemory(IpArray);
            IpArray = NULL;
            continue;
        }

     }    

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    DhcpDumpServerScopeFooter();

    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    // Dump SuperScopes

    DhcpDumpSuperScopes(( LPWSTR ) pwszIpAddress,
			dwMajor, dwMinor );


    // Dump Multicast Scopes


    DhcpDumpServerMScopeHeader();

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    nRead = nTotal = 0;
    ResumeHandle = 0;

    {
        while(TRUE)
        {
            Error = DhcpEnumMScopes((LPWSTR)pwszIpAddress,
                                    &ResumeHandle,
                                    ~0,
                                    &MScopeTable,
                                    &nRead,
                                    &nTotal);

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( MScopeTable )
                {
                    DhcpRpcFreeMemory(MScopeTable);
                    MScopeTable = NULL;                            
                }
                break;
            }
            
            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
            {
                goto ErrorReturn;
            }


            for( dw=0; dw<nRead; dw++ )
            {
                DWORD   dwError = NO_ERROR;
                dwError = DhcpDumpServerMScope(pwszIpAddress,
                                               dwMajor,
                                               dwMinor,
                                               MScopeTable->pMScopeNames[dw]);
                if( dwError is ERROR_NOT_ENOUGH_MEMORY )
                {
                    Error = dwError;
                    goto ErrorReturn;
                }
            }
            
            DhcpRpcFreeMemory(MScopeTable);
            MScopeTable = NULL;

            if( Error is NO_ERROR )
                break;
            else
                continue;                                    
        }
    }
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerMScopeFooter();

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DhcpDumpServerScriptFooter(pwszIpAddress);
    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);
CommonReturn:
    if( ClassInfoArray )
    {
        DhcpRpcFreeMemory(ClassInfoArray);
        ClassInfoArray = NULL;
    }
    
    if( OptionsAll )
    {
        DhcpRpcFreeMemory(OptionsAll);
        OptionsAll = NULL;
    }

    if( OptionsArray )
    {
        DhcpRpcFreeMemory(OptionsArray);
        OptionsArray = NULL;
    }

    if( OptionValue )
    {
        DhcpRpcFreeMemory(OptionValue);
        OptionValue = NULL;
    }

    if( OptionValues )
    {
        DhcpRpcFreeMemory(OptionValues);
        OptionValues = NULL;
    }

    if( OptionArray )
    {
        DhcpRpcFreeMemory(OptionArray);
        OptionArray = NULL;
    }

    if( IpArray )
    {
        DhcpRpcFreeMemory(IpArray);
        IpArray = NULL;
    }

    return Error;

ErrorReturn:
    goto CommonReturn;

}

VOID
DhcpDumpScriptHeader()
{
    DisplayMessage(g_hModule,
                   DMP_DHCP_SCRIPTHEADER);
}

VOID
DhcpDumpServerScriptHeader(IN LPCWSTR pwszServer)
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_SERVER_HEADER,
                   pwszServer);
}


VOID
DhcpDumpServerClass(
                    IN LPCWSTR          pwszServer,
                    IN DHCP_CLASS_INFO ClassInfo
                   )
{
    WCHAR       Comment[256] = {L'\0'},
                Name[256] = {L'\0'},
                Data[1024] = {L'\0'};
    DWORD       dw = 0;
    

    Name[0] = L'\"';
    dw = wcslen(ClassInfo.ClassName);
    wcsncpy(Name+1, ClassInfo.ClassName, (dw>252)? 252 : dw);
    dw = wcslen(Name);
    Name[dw] = L'\"';
    Name[dw+1] = L'\0';

    if( ClassInfo.ClassComment )
    {
        Comment[0] = L'\"';
        dw = wcslen(ClassInfo.ClassComment);
        wcsncpy(Comment+1, ClassInfo.ClassComment, (dw>252)? 252 : dw);
        dw = wcslen(Comment);
        Comment[dw] = L'\"';        
        Comment[dw+1] = L'\0';
    }
    
    for( dw=0; dw<ClassInfo.ClassDataLength && dw<1020/sizeof(WCHAR); dw++ )
    {
        wsprintf(Data+dw*sizeof(WCHAR), L"%.02x", ClassInfo.ClassData[dw]);
    }
    
    Data[dw*sizeof(WCHAR)] = L'\0';
    
    DisplayMessage(g_hModule,
                   DMP_SRVR_ADD_CLASS,
                   pwszServer,
                   ClassInfo.ClassName,
                   Comment,
                   Data,
                   ClassInfo.IsVendor ? L"1" : L"0" );
}

DWORD
DhcpDumpServerOptiondefV5(
                          IN LPCWSTR             pwszServerIp,
                          IN LPDHCP_ALL_OPTIONS OptionsAll
                         )
{
    DWORD       Error = NO_ERROR;
    DWORD       dw = 0;
    DWORD       dwOption = 0;
    WCHAR       Buffer[30] = {L'\0'};
    if( OptionsAll is NULL )
        return Error;

    Error = DhcpDumpServerOptiondef(pwszServerIp,
                                    OptionsAll->NonVendorOptions);

    if( Error is ERROR_NOT_ENOUGH_MEMORY )
        return Error;
    else
        Error = NO_ERROR; 

    for( dw = 0; dw < OptionsAll->NumVendorOptions; dw++ ) 
    {
        
        DHCP_OPTION Option = OptionsAll->VendorOptions[dw].Option;
        DHCP_OPTION_DATA Data = Option.DefaultValue;
        DWORD       dwLen = 0;

        WCHAR       wcVendor[256] = {L'\0'},// = OptionsAll->VendorOptions[dw].VendorName;
                    Name[256] = {L'\0'},
                    Comment[256] = {L'\0'};
        LPWSTR      pwszType = NULL;
        LPWSTR      pwszDefData = NULL;

        memset(wcVendor, 0x00, 256*sizeof(WCHAR));
        memset(Name, 0x00, 256*sizeof(WCHAR));
        memset(Comment, 0x00, 256*sizeof(WCHAR));

        switch(Option.OptionType)
        {
        case DhcpArrayTypeOption:
            {
                dwOption = 1;
                break;
            }
        default:
            {
                dwOption = 0;
                break;
            }
        }

        
	pwszType = TagOptionType[ Data.Elements[ 0 ].OptionType ].pwcTag;

        switch(Data.Elements[0].OptionType)
        {
        case DhcpByteOption:
            {
                pwszDefData = _ultow((ULONG)(Data.Elements[0].Element.ByteOption), Buffer, 10);
                if( pwszDefData is NULL )
                    pwszDefData = L"00";
                break;
            }
        case DhcpWordOption:
            {
                pwszDefData = _ultow((ULONG)(Data.Elements[0].Element.WordOption), Buffer, 10);
                if( pwszDefData is NULL )
                    pwszDefData = L"0";
                break;
            }
        case DhcpDWordOption:
            {
                pwszDefData = _ultow((ULONG)(Data.Elements[0].Element.DWordOption), Buffer, 10);
                if( pwszDefData is NULL )
                    pwszDefData = L"0";
                break;
            }
        case DhcpDWordDWordOption:
            {
                if( pwszDefData is NULL )
                    pwszDefData = L"0";
                break;
            }
        case DhcpIpAddressOption:
            {
                pwszDefData = IpAddressToString(Data.Elements[0].Element.IpAddressOption);
                if( pwszDefData is NULL )
                    pwszDefData = L"0.0.0.0";
                break;
            }
        case DhcpStringDataOption:
            {
                pwszDefData = Data.Elements[0].Element.StringDataOption;
                if( pwszDefData is NULL )
                    pwszDefData = L"None";
                break;
            }
        case DhcpBinaryDataOption:
            {
                if( pwszDefData is NULL ) {
                    pwszDefData = L"0";
		}
		break;
            }
        case DhcpEncapsulatedDataOption:
            {
                if( pwszDefData is NULL ) {
                    pwszDefData = L"0";
		}
		break;
            }
        default:
	    {
		// We should always handle our datatypes.
		DhcpAssert( FALSE );
		break;
	    } // default
        } // switch

	if (OptionsAll->VendorOptions[dw].VendorName) {
	    wcVendor[0] = L'\"';
	    dwLen = wcslen(OptionsAll->VendorOptions[dw].VendorName);

	    wcsncpy(wcVendor+1, OptionsAll->VendorOptions[dw].VendorName, (dwLen>252) ? 252 : dwLen);
	    dwLen = wcslen(wcVendor);
	    wcVendor[dwLen] = L'\"';
	    wcVendor[dwLen+1] = L'\0';
	} // if 
        
        if( Option.OptionComment)
        {
            Comment[0] = L'\"';
            dwLen = wcslen(Option.OptionComment);
            wcsncpy(Comment+1, Option.OptionComment, (dwLen>252) ? 252:dwLen);
            dwLen = wcslen(Comment);
            Comment[dwLen] = L'\"';
            Comment[dwLen+1] = L'\0';

        }

        Name[0] = L'\"';
        dwLen = wcslen(Option.OptionName);
        wcsncpy(Name+1, Option.OptionName, (dwLen>252) ?252:dwLen);
        dwLen = wcslen(Name);
        Name[dwLen] = L'\"';
        Name[dwLen+1] = L'\0';

        DisplayMessage(g_hModule,
                       DMP_SRVR_ADD_OPTIONDEF_VENDOR,
                       pwszServerIp,
                       Option.OptionID,
                       Name,
                       pwszType,
                       dwOption ? L"1" : L"0",
                       pwszDefData,
                       wcVendor,       
                       Comment);


        memset(Name, 0x00, sizeof(Name));
        memset(Comment, 0x00, sizeof(Comment));
        pwszType = NULL;

    }
    return Error;
}


DWORD
DhcpDumpServerOptiondef(
                        IN LPCWSTR              pwszServer,
                        IN LPDHCP_OPTION_ARRAY OptionArray
                       )
{
    DWORD       Error = NO_ERROR;
    DWORD       i=0, dw = 0;
    DWORD       dwOption = 0;
    WCHAR       Comment[256] = {L'\0'};
    WCHAR       Name[256] = {L'\0'};


    if( OptionArray is NULL )
        return Error;
    
    DisplayMessage(g_hModule, 
                   DMP_SRVR_OPTION_NONVENDOR);

    for( i=0; i<OptionArray->NumElements; i++ )
    {
        DHCP_OPTION Option = OptionArray->Options[i];
        DHCP_OPTION_DATA Data = Option.DefaultValue;

        LPWSTR      pwszType = NULL;
        LPWSTR      pwszDefData = NULL;
        
        dw = 0;

        memset(Name, 0x00, 256*sizeof(WCHAR));
        memset(Comment, 0x00, 256*sizeof(WCHAR));

        switch(Option.OptionType)
        {
        case DhcpArrayTypeOption:
            {
                dwOption = 1;
                break;
            }
        default:
            {
                dwOption = 0;
                break;
            }
        }
        
	pwszType = TagOptionType[ Data.Elements[ 0 ].OptionType ].pwcTag;

        switch(Data.Elements[0].OptionType)
        {
            WCHAR   Buffer[20] = {L'\0'};
        case DhcpByteOption:
            {
                pwszDefData = _itow((int)(Data.Elements[0].Element.ByteOption), Buffer, 10);
                break;
            }
        case DhcpWordOption:
            {
                pwszDefData = _itow((int)(Data.Elements[0].Element.WordOption), Buffer, 10);
                break;
            }
        case DhcpDWordOption:
            {
                pwszDefData = _itow((int)(Data.Elements[0].Element.DWordOption), Buffer, 10);
                break;
            }
        case DhcpDWordDWordOption:
            {
                break;
            }
        case DhcpIpAddressOption:
            {
                pwszDefData = IpAddressToString(Data.Elements[0].Element.IpAddressOption);
                break;
            }
        case DhcpStringDataOption:
            {
                pwszDefData = Data.Elements[0].Element.StringDataOption;
                break;
            }
        case DhcpBinaryDataOption:
            {
		break;
            }
        case DhcpEncapsulatedDataOption:
            {
		break;
            }
        default:
            {
		// We should always handle our data types
		DhcpAssert( FALSE );
                break;
            }
        } // switch

        if( Option.OptionComment )
        {
            Comment[0] = L'\"';
            dw = wcslen(Option.OptionComment);
            wcsncpy(Comment+1, Option.OptionComment, (dw>252)? 252 : dw);
            dw = wcslen(Comment);
            Comment[dw] = L'\"';
            Comment[dw+1] = L'\0';
        }

        Name[0] = L'\"';
        wcsncpy(Name+1, Option.OptionName, 252);
        dw = wcslen(Name);
        Name[dw] = L'\"';
        Name[dw+1] = L'\0';

        if( pwszDefData is NULL )
        {
            DisplayMessage(g_hModule,
                           DMP_SRVR_ADD_OPTIONDEF_NONE,
                           pwszServer,
                           Option.OptionID,
                           Name,
                           pwszType,
                           dwOption ? L"1" : L"0",
                           Comment);
        }
        else
        {
            DisplayMessage(g_hModule,
                           DMP_SRVR_ADD_OPTIONDEF,
                           pwszServer,
                           Option.OptionID,
                           Name,
                           pwszType,
                           dwOption ? L"1" : L"0",
                           pwszDefData,
                           Comment);
        }

    }    
    return Error;
}

DWORD
DhcpDumpServerOptionValuesV5(
                             IN LPCWSTR                  pwszServer,
                             IN LPCWSTR                  pwszScope,
                             IN LPCWSTR                  pwszReserved,
                             IN LPDHCP_ALL_OPTION_VALUES OptionValues
                            )
{
    DWORD                       Error = NO_ERROR,
                                dwOptionCount = 0,
                                dw = 0,
                                dwNum = 0,
                                i = 0;

    LPDHCP_OPTION_VALUE_ARRAY   Array = NULL;
    DHCP_OPTION_DATA_TYPE       eType = DhcpDWordOption;
    LPWSTR                      pwcUser = NULL,
                                pwcVendor = NULL;
    BOOL                        fVendor = FALSE;

    if( OptionValues is NULL )
        return Error;

    dwOptionCount = OptionValues->NumElements;
    
    if( dwOptionCount < 1 )
        return Error;


    for( i=0; i<dwOptionCount; i++ )
    {
        DWORD   dwCount = 0,
                j = 0;
        DHCP_OPTION_VALUE   Value = {0};

        pwcUser = OptionValues->Options[i].ClassName;
        pwcVendor = OptionValues->Options[i].VendorName;
        fVendor = OptionValues->Options[i].IsVendor;
        Array = OptionValues->Options[i].OptionsArray;
    
        if( Array is NULL )
            continue;

        dwCount = Array->NumElements;

        for( j=0; j<dwCount; j++ )
        {
            Value = Array->Values[j];
            if( Value.OptionID is 81 )
                continue;
            Error = DhcpDumpServerOptionValue(pwszServer,
                                              pwszScope,
                                              pwszReserved,
                                              pwcUser,
                                              pwcVendor,
                                              TRUE,
                                              Value);

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
            {
                return Error;
            }
                                        
        }

        pwcUser = pwcVendor = NULL;
        Array = NULL;
        fVendor = FALSE;

    }
    return Error;
}

DWORD
DhcpDumpServerOptionValue(
                          IN LPCWSTR                     pwszServer,
                          IN LPCWSTR                     pwszScope,
                          IN LPCWSTR                     pwszReserved,
                          IN LPCWSTR                     pwcUser,
                          IN LPCWSTR                     pwcVendor,
                          IN BOOL                        fIsV5,
                          IN DHCP_OPTION_VALUE           OptionValue
                         )
{
    DWORD                   Error = NO_ERROR,
                            dw = 0, 
                            dwNum = 0,
                            i=0;
    DHCP_OPTION_DATA        Data;
    DHCP_OPTION_DATA_TYPE   eType = DhcpDWordOption;
    WCHAR                   wcString[1024] = {L'\0'}; 
    LPWSTR                  pwcType = NULL;
    WCHAR                   wcVendor[256] = {L'\0'},
                            wcUser[256] = {L'\0'};

    Data = OptionValue.Value;


    //Form optionvalue string..

    dwNum = Data.NumElements;

    if( dwNum <= 0 )
        return Error;;

    eType = Data.Elements[0].OptionType;
    
    dw = 0;

    while(dwNum>i)
    {
        WCHAR   Buffer[15] = {L'\0'};

        wcscpy(wcString+dw, L"\""); dw ++;
        switch(eType)
        {
        case DhcpByteOption:
            {
                _itow((int)Data.Elements[i].Element.ByteOption, Buffer, 10);
                wcscpy(wcString+dw, Buffer );
                break;
            }
        case DhcpWordOption:
            {
                _itow((int)Data.Elements[i].Element.WordOption, Buffer, 10);
                wcscpy(wcString+dw, Buffer);
                break;
            }
	case DhcpBinaryDataOption:
	case DhcpEncapsulatedDataOption:
	    {
		DWORD j;
                DWORD Length;
		
                Length = Data.Elements[ i ].Element.BinaryDataOption.DataLength;
                for( j = 0; j < Length; j++ ) {
		    wsprintf( &wcString[ dw + sizeof( WCHAR ) * j ], L"%02x",
			      Data.Elements[ i ].Element.BinaryDataOption.Data[ j ]);
                }
		wcString[ dw + sizeof( WCHAR ) * Length] = L'\0';
		break;
	    }

        case DhcpDWordOption:
            {
                _itow((int)Data.Elements[i].Element.DWordOption, Buffer, 10);
                wcscpy(wcString+dw, Buffer );
		if ( DhcpDWordOption != eType ) {
		    eType = DhcpDWordOption ;
		}
                break;
            }
        case DhcpStringDataOption:
            {
                wcscpy(wcString+dw, Data.Elements[i].Element.StringDataOption);
                break;
            }
        case DhcpIpAddressOption:
            {
		LPWSTR tmp;

		tmp =  IpAddressToString(Data.Elements[i].Element.IpAddressOption);
		if ( NULL != tmp ) {
		    wcscpy( wcString+dw, tmp );
		}
                break;
            }
        default: 
	    {
		DhcpAssert( FALSE );
		break;
	    }
        } // switch

	if ( NULL == pwcType ) {
	    pwcType = TagOptionType[ eType ].pwcTag;
	}

        dw = wcslen(wcString);

        wcString[dw] = L'\"';
        dw++;
        wcString[dw] = L' ';
        dw++;
        i++;
    }

    if( fIsV5 is FALSE )
    {
        
        if( pwszScope is NULL )
        {


            DisplayMessage(g_hModule,
                           DMP_SRVR_SET_OPTIONVALUE,
                           pwszServer,
                           OptionValue.OptionID,
                           pwcType,
                           wcString);
            return Error;
        }

        if( pwszReserved is NULL and
            pwszScope isnot NULL )
        {
            DisplayMessage(g_hModule,
                           DMP_SCOPE_SET_OPTIONVALUE,
                           pwszServer,
                           pwszScope,
                           OptionValue.OptionID,
                           pwcType,
                           wcString);
            return Error;
        }

        DisplayMessage(g_hModule,
                       DMP_SCOPE_SET_RESERVEDOPTIONVALUE,
                       pwszServer,
                       pwszScope,
                       pwszReserved,
                       OptionValue.OptionID,
                       pwcType,
                       wcString);
        return Error;

    }
    else
    {
        if( pwcUser )
        {
            wcUser[0] = L'\"';
            dw = wcslen(pwcUser);
            wcsncpy(wcUser+1, pwcUser, (dw>252) ? 252:dw);
            dw = wcslen(wcUser);
            wcUser[dw] = L'\"';
            wcUser[dw+1] = L'\0';
        }

        if( pwcVendor )
        {
            wcVendor[0] = L'\"';
            dw = wcslen(pwcVendor);
            wcsncpy(wcVendor+1, pwcVendor, (dw>252) ? 252:dw);
            dw = wcslen(wcVendor);
            wcVendor[dw] = L'\"';
            wcVendor[dw+1] = L'\0';
        }
        if( pwszScope is NULL )
        {
            
            if( pwcUser && pwcVendor )
            {

                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_OPTIONVALUE_CLASS,
                               pwszServer,
                               OptionValue.OptionID,
                               pwcType,
                               wcUser,
                               wcVendor,
                               wcString);
            }
            else if( ( pwcUser ) && 
                     ( pwcVendor is NULL ) )
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_OPTIONVALUE_USER,
                               pwszServer,
                               OptionValue.OptionID,
                               pwcType,
                               wcUser,
                               wcString);
            }
            else if( ( pwcUser is NULL ) &&
                     ( pwcVendor ) )
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_OPTIONVALUE_VENDOR,
                               pwszServer,
                               OptionValue.OptionID,
                               pwcType,
                               wcVendor,
                               wcString);
            }
            else
            {
                DisplayMessage(g_hModule,
                               DMP_SRVR_SET_OPTIONVALUE,
                               pwszServer,
                               OptionValue.OptionID,
                               pwcType,
                               wcString);
            }

            return Error;
        }

        if( pwszReserved is NULL and
            pwszScope isnot NULL )
        {
            if( pwcUser && pwcVendor )
            {
                DisplayMessage(g_hModule,
                               DMP_SCOPE_SET_OPTIONVALUE_CLASS,
                               pwszServer,
                               pwszScope,
                               OptionValue.OptionID,
                               pwcType,
                               wcUser,
                               wcVendor,
                               wcString);
            }
            else if( ( pwcUser ) &&
                     ( pwcVendor is NULL ) )
            {
                DisplayMessage(g_hModule,
                               DMP_SCOPE_SET_OPTIONVALUE_USER,
                               pwszServer,
                               pwszScope,
                               OptionValue.OptionID,
                               pwcType,
                               wcUser,
                               wcString);
            }
            else if ( ( pwcUser is NULL ) &&
                      ( pwcVendor ) )
            {
                DisplayMessage(g_hModule,
                               DMP_SCOPE_SET_OPTIONVALUE_VENDOR,
                               pwszServer,
                               pwszScope,
                               OptionValue.OptionID,
                               pwcType,
                               wcVendor,
                               wcString);
            }
            else
            {
                DisplayMessage(g_hModule,
                               DMP_SCOPE_SET_OPTIONVALUE,
                               pwszServer,
                               pwszScope,
                               OptionValue.OptionID,
                               pwcType,
                               wcString);

            }
            return Error;
        }

        if( pwcUser && pwcVendor )
        {
            DisplayMessage(g_hModule,
                           DMP_SCOPE_SET_RESERVEDOPTIONVALUE_CLASS,
                           pwszServer,
                           pwszScope,
                           pwszReserved,
                           OptionValue.OptionID,
                           pwcType,
                           wcUser,
                           wcVendor,
                           wcString);
        }
        else if( ( pwcUser ) &&
                 ( pwcVendor is NULL ) )
        {
            DisplayMessage(g_hModule,
                           DMP_SCOPE_SET_RESERVEDOPTIONVALUE_USER,
                           pwszServer,
                           pwszScope,
                           pwszReserved,
                           OptionValue.OptionID,
                           pwcType,
                           wcUser,
                           wcString);
        }
        else if( ( pwcUser is NULL ) &&
                 ( pwcVendor ) )
        {
            DisplayMessage(g_hModule,
                           DMP_SCOPE_SET_RESERVEDOPTIONVALUE_VENDOR,
                           pwszServer,
                           pwszScope,
                           pwszReserved,
                           OptionValue.OptionID,
                           pwcType,
                           wcVendor,
                           wcString);
        }
        else
        {
            DisplayMessage(g_hModule,
                           DMP_SCOPE_SET_RESERVEDOPTIONVALUE,
                           pwszServer,
                           pwszScope,
                           pwszReserved,
                           OptionValue.OptionID,
                           pwcType,
                           wcString);
        }
        return Error;

    }
}

DWORD
DhcpDumpScope(
              IN LPCWSTR pwszServerIp,
              IN DWORD   dwMajor,
              IN DWORD   dwMinor,
              IN DWORD   ScopeIp)
{
    DWORD                               Error = NO_ERROR,
                                        dwLen = 0,
                                        dwRead = 0,
                                        dwTotal = 0,
                                        dw = 0, i = 0, j = 0;
                        
    LPDHCP_SUBNET_INFO                  SubnetInfo = NULL;
    DHCP_OPTION_SCOPE_INFO              ScopeInfo = {0};


    WCHAR                               Name[256] = {L'\0'},
                                        Comment[256] = {L'\0'};

    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY    Elem = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4 = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5 = NULL;
    LPDHCP_ALL_OPTION_VALUES            OptionValues = NULL;
    LPDHCP_OPTION_VALUE_ARRAY           OptionArray = NULL;
    LPDHCP_OPTION_VALUE                 OptionValue = NULL;
    DHCP_RESUME_HANDLE                  Resume = 0;
    LPDHCP_OPTION_ARRAY                 OptionsArray = NULL;
    ULONG                               MajorVersion = 0, NumElements = 0;
    BOOL                                fIsV5Call;
    
    //First Dhcp Server Add Scope

    Error = DhcpGetSubnetInfo(
                              (LPWSTR)pwszServerIp,                              
                              ScopeIp,
                              &SubnetInfo);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;


    if( SubnetInfo->SubnetName )
    {
        Name[0] = L'\"';
        dwLen = wcslen(SubnetInfo->SubnetName);
        wcsncpy(Name+1, SubnetInfo->SubnetName, (dwLen>252)? 252:dwLen);
        dwLen = wcslen(Name);
        Name[dwLen] = L'\"';
        Name[dwLen+1] = L'\0';
    }

    if( SubnetInfo->SubnetComment )
    {
        Comment[0] = L'\"';
        dwLen = wcslen(SubnetInfo->SubnetComment);
        wcsncpy(Comment+1, SubnetInfo->SubnetComment, (dwLen>252)? 252:dwLen);
        dwLen = wcslen(Comment);
        Comment[dwLen] = L'\"';
        Comment[dwLen+1] = L'\0';
    }

    MajorVersion = g_dwMajorVersion;
    
    if( MajorVersion >= CLASS_ID_VERSION )
    {
        fIsV5Call = TRUE;
    }
    else
    {
        fIsV5Call = FALSE;
    }
    
    DisplayMessage(g_hModule,
                   DMP_SRVR_ADD_SCOPE,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress),
                   IpAddressToString(SubnetInfo->SubnetMask),
                   Name,
                   Comment);

    //Set the state of the Scope
    DisplayMessage(g_hModule,
                   DMP_SCOPE_SET_STATE,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress),
                   ( SubnetInfo->SubnetState == DhcpSubnetEnabled ) ? 1 : 0);



    Resume = 0;
    dwRead = dwTotal = 0;

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_ADD_IPRANGES_HEADER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    //Add IPRanges
    {

        while(TRUE)
        {
            if( FALSE == fIsV5Call ) 
            {
                Error = DhcpEnumSubnetElements(
                                                (LPWSTR)pwszServerIp, 
                                                SubnetInfo->SubnetAddress,
                                                DhcpIpRanges, 
                                                &Resume,
                                                ~0, 
                                                &Elem,
                                                &dwRead,
                                                &dwTotal
                                                );
            } 
            else 
            {
                Error = DhcpEnumSubnetElementsV5(
                                                (LPWSTR)pwszServerIp, 
                                                SubnetInfo->SubnetAddress,
                                                DhcpIpRangesDhcpBootp, 
                                                &Resume,
                                                ~0, 
                                                &Elements5,
                                                &dwRead, 
                                                &dwTotal
                                                );
            }

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( Elem )
                {
                    DhcpRpcFreeMemory(Elem);
                    Elem = NULL;
                }

                if( Elements5 )
                {
                    DhcpRpcFreeMemory(Elements5);
                    Elements5 = NULL;
                }
                
                break;
            }

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
            {
                goto ErrorReturn;
            }

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
                break;

            if( fIsV5Call ) 
                NumElements = Elements5->NumElements;
            else 
                NumElements = Elem->NumElements;
            
            for( dw=0; dw<dwRead && dw < NumElements ; dw++ )
            {
                LPTSTR ElementType, StartAddress, EndAddress;
                
                if( fIsV5Call ) {
                    if( Elements5->Elements[dw].ElementType == DhcpIpRangesDhcpOnly ) {
                        ElementType = TEXT("");
                    } else if( Elements5->Elements[dw].ElementType == DhcpIpRangesBootpOnly ) {
                        ElementType = TEXT("BOOTP");
                    } else {
                        ElementType = TEXT("BOTH");
                    }
                    StartAddress = IpAddressToString(
                        Elements5->Elements[dw].Element.IpRange->StartAddress
                        );
                    EndAddress = IpAddressToString(
                        Elements5->Elements[dw].Element.IpRange->EndAddress
                        );
                    
                } else {
                    ElementType = TEXT("");
                    StartAddress = IpAddressToString(Elem->Elements[dw].Element.IpRange->StartAddress);
                    EndAddress = IpAddressToString(Elem->Elements[dw].Element.IpRange->EndAddress);
                }
                
                DisplayMessage(
                    g_hModule,
                    DMP_SCOPE_ADD_IPRANGE,
                    pwszServerIp,
                    IpAddressToString(SubnetInfo->SubnetAddress),
                    StartAddress,
                    EndAddress,
                    ElementType
                    );
            }

            if( Error is NO_ERROR )
                break;
            else
            {
                if( Elem ) DhcpRpcFreeMemory(Elem);
                if( Elements5 ) DhcpRpcFreeMemory(Elements5);
                Elem = NULL; Elements5 = NULL;
                continue;
            }
        }
                                             
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_ADD_IPRANGES_FOOTER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_ADD_EXCLUDERANGES_HEADER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    Resume = 0;
    dwRead = dwTotal = 0;
    
    //Add ExcludeRanges
    {
 
        while(TRUE)
        {
            Error = DhcpEnumSubnetElements((LPWSTR)pwszServerIp,
                                           SubnetInfo->SubnetAddress,
                                           DhcpExcludedIpRanges,
                                           &Resume,
                                           ~0,
                                           &Elem,
                                           &dwRead,
                                           &dwTotal);

            if( Error is ERROR_NO_MORE_ITEMS )
                break;

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
            {
                goto ErrorReturn;
            }

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
                break;



            for( dw=0; dw<dwRead && dw<Elem->NumElements ; dw++ )
            {
                DisplayMessage(g_hModule,
                               DMP_SCOPE_ADD_EXCLUDERANGE,
                               pwszServerIp,
                               IpAddressToString(SubnetInfo->SubnetAddress),
                               IpAddressToString(Elem->Elements[dw].Element.ExcludeIpRange->StartAddress),
                               IpAddressToString(Elem->Elements[dw].Element.ExcludeIpRange->EndAddress));


            }

            if( Error is NO_ERROR )
                break;
            else
            {
                DhcpRpcFreeMemory(Elem);
                Elem = NULL;
                continue;
            }
        }                                        
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_ADD_EXCLUDERANGES_FOOTER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    
    DisplayMessage(g_hModule,
                   DMP_SCOPE_SET_OPTIONVALUE_HEADER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));


    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);


    //Set Scope Optionvalues
    
    Resume = 0;
    dwRead = dwTotal = 0;

    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo = SubnetInfo->SubnetAddress;

    while(TRUE)
    {
        if( dwMajor >= CLASS_ID_VERSION )
        {
            Error = DhcpGetAllOptionValues(
                                            (LPWSTR)pwszServerIp,
                                            DHCP_OPT_ENUM_IGNORE_VENDOR,
                                            &ScopeInfo,
                                            &OptionValues
                                            );

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( OptionValues )
                {
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
                break;
            }
            
            if( Error is ERROR_NOT_ENOUGH_MEMORY )
            {
                goto ErrorReturn;
            }

            if( Error is NO_ERROR or
                Error is ERROR_MORE_DATA )
            {
                DhcpDumpServerOptionValuesV5(pwszServerIp,
                                             IpAddressToString(SubnetInfo->SubnetAddress),
                                             NULL,
                                             OptionValues);

                if( OptionValues )
                {
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }

                if( Error is NO_ERROR )
                    break;
                else
                {
                    continue;
                }
            }
            else
                break;
        }
        else
        {
             Error = DhcpEnumOptions(
                            (LPWSTR)pwszServerIp,
                            &Resume,
                            ~0,
                            &OptionsArray,
                            &dwRead,
                            &dwTotal);
        
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                Error = NO_ERROR;
                if( OptionsArray )
                {
                    DhcpRpcFreeMemory(OptionsArray);
                    OptionsArray = NULL;
                }
                break;
            }

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
            {
                goto ErrorReturn;
            }

            if( Error isnot NO_ERROR  &&
                Error isnot ERROR_MORE_DATA )
                break;

            for( dw = 0; dw < dwRead; dw++ )
            {
                DHCP_OPTION_ID OptionId = OptionsArray->Options[dw].OptionID;
                DWORD          dwError = NO_ERROR;
                dwError = DhcpGetOptionValue(
                                             (LPWSTR)pwszServerIp,
                                             OptionId,
                                             &ScopeInfo,
                                             &OptionValue);
                               
                if( dwError isnot NO_ERROR )
                {
                    continue;
                }
        
                if( OptionValue )
                {
                    dwError = DhcpDumpServerOptionValue(pwszServerIp,
                                              IpAddressToString(SubnetInfo->SubnetAddress),
                                              NULL,
                                              NULL,
                                              NULL,
                                              FALSE,
                                              *OptionValue);
                    DhcpRpcFreeMemory(OptionValue);
                    OptionValue = NULL;
                    if( dwError is ERROR_NOT_ENOUGH_MEMORY )
                    {
                        Error = dwError;
                        goto ErrorReturn;
                    }
                }
            }
    
            if( OptionsArray )
            {
                DhcpRpcFreeMemory(OptionsArray);
                OptionsArray = NULL;
            }
            if( Error is NO_ERROR )
                break;
            else
                continue;
        }
                        
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_SET_OPTIONVALUE_FOOTER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    
    DisplayMessage(g_hModule,
                   DMP_SCOPE_SET_RESERVEDIP_HEADER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));


    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    Resume = 0;
    dwRead = dwTotal = 0;
    
    while( TRUE ) 
    {
        Elements5 = NULL;
        Elements4 = NULL;
        dwRead = dwTotal = 0;
        
        if( dwMajor >= CLASS_ID_VERSION ) 
        {
            Error = DhcpEnumSubnetElementsV5(
                (LPWSTR)pwszServerIp,
                SubnetInfo->SubnetAddress,
                DhcpReservedIps,
                &Resume,
                ~0,
                &Elements5,
                &dwRead,
                &dwTotal
                );
        } 
        else 
        {
            Error = DhcpEnumSubnetElementsV4(
                (LPWSTR)pwszServerIp,
                SubnetInfo->SubnetAddress,
                DhcpReservedIps,
                &Resume,
                ~0,
                &Elements4,
                &dwRead,
                &dwTotal
                );
        }

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            if( Elements5 )
            {
                DhcpRpcFreeMemory(Elements5);
                Elements5 = NULL;
            }

            if( Elements4 )
            {
                DhcpRpcFreeMemory(Elements4);
                Elements4 = NULL;
            }

            break;
        }

        if( Error is ERROR_NOT_ENOUGH_MEMORY )
        {
            goto ErrorReturn;
        }

        if( Error isnot NO_ERROR and
            Error isnot ERROR_MORE_DATA )
        {
            break;
        }

        {
            
            for( i = 0; i < dwRead ; i ++ ) 
            {
                DWORD DataLength;
                LPBYTE Data;
                DWORD dw=0, k=0;
                WCHAR  wcData[40] = {L'\0'};
                WCHAR  IpAddress[MAX_IP_STRING_LEN+1] = {L'\0'};
                LPWSTR pwszComment = L"";
                LPWSTR pwszName = L"";
                LPWSTR pwszType = L"";
                DHCP_SEARCH_INFO SearchInfo = {0};
                LPDHCP_CLIENT_INFO_V4 ClientInfo = NULL;

                if( dwMajor >= CLASS_ID_VERSION ) 
                {

					DataLength = Elements5->Elements[i].Element.ReservedIp->ReservedForClient->DataLength;
                    Data = Elements5->Elements[i].Element.ReservedIp->ReservedForClient->Data;

                    j=0;

                    while( j < DataLength )
                    {
                        wsprintf(wcData+wcslen(wcData), L"%.2x", (DWORD)Data[j]);
                        j++;                      
                    }
                    
                    wsprintf(IpAddress, L"%s", IpAddressToString(Elements5->Elements[i].Element.ReservedIp->ReservedIpAddress));

                    IpAddress[15] = L'\0';
                    
                    SearchInfo.SearchType = DhcpClientIpAddress;
                    SearchInfo.SearchInfo.ClientIpAddress = Elements5->Elements[i].Element.ReservedIp->ReservedIpAddress;

                    Error = DhcpGetClientInfoV4(
                                        g_ServerIpAddressUnicodeString,
                                        &SearchInfo,
                                        &ClientInfo);

                    if( Error isnot NO_ERROR )
                        continue;

                    pwszName = ClientInfo->ClientName;
                    ClientInfo->bClientType = Elements5->Elements[i].Element.ReservedIp->bAllowedClientTypes;
                    
                    if( pwszName is NULL )
                    {
                        pwszName = L"";
                        pwszComment = L"";
                        pwszType = L"";
                    }
                    else
                    {
                        pwszComment = ClientInfo->ClientComment;
                        if( pwszComment is NULL )
                        {
                            pwszComment = L"";
                            pwszType = L"";
                        }
                        else
                        {
                            switch(ClientInfo->bClientType)
                            {
                            case CLIENT_TYPE_DHCP:
                                {
                                    pwszType = L"DHCP";
                                    break;
                                }
                            case CLIENT_TYPE_BOOTP:
                                {
                                    pwszType = L"BOOTP";
                                    break;
                                }
                            case CLIENT_TYPE_BOTH:
                            default:
                                {
                                    pwszType = L"BOTH";
                                    break;
                                }
                            }
                        }
                    }
                    DisplayMessage(g_hModule, 
                                   DMP_SCOPE_ADD_RESERVEDIP,
                                   pwszServerIp,
                                   IpAddressToString(SubnetInfo->SubnetAddress),
                                   IpAddress,
                                   wcData+10,
                                   pwszName,
                                   pwszComment,
                                   pwszType);

                    Error = DhcpDumpReservedOptionValues(pwszServerIp,
                                                 dwMajor,
                                                 dwMinor,
                                                 IpAddressToString(SubnetInfo->SubnetAddress),
                                                 IpAddress);

                    if( ClientInfo )
                    {
                        DhcpRpcFreeMemory(ClientInfo);
                        ClientInfo = NULL;
                    }


                    if( Error is ERROR_NOT_ENOUGH_MEMORY )
                    {
                        goto ErrorReturn;
                    }
                } 
                else 
                {
                    DataLength = Elements4->Elements[i].Element.ReservedIp->ReservedForClient->DataLength;
                    Data = Elements4->Elements[i].Element.ReservedIp->ReservedForClient->Data;
                    
                    j = 0;

                    while( j < DataLength )
                    {
                        wsprintf(wcData+2*j, L"%.2x", (DWORD)Data[j]);
                        j++;
                    }

                    wsprintf(IpAddress, L"%s", IpAddressToString(Elements4->Elements[i].Element.ReservedIp->ReservedIpAddress));
                    IpAddress[15] = L'\0';

                    SearchInfo.SearchType = DhcpClientIpAddress;
                    SearchInfo.SearchInfo.ClientIpAddress = Elements4->Elements[i].Element.ReservedIp->ReservedIpAddress;

                    Error = DhcpGetClientInfoV4(
                                        g_ServerIpAddressUnicodeString,
                                        &SearchInfo,
                                        &ClientInfo);

                    if( Error isnot NO_ERROR )
                        continue;

                    pwszName = ClientInfo->ClientName;
                    ClientInfo->bClientType = Elements4->Elements[i].Element.ReservedIp->bAllowedClientTypes;

                    if( pwszName is NULL )
                    {
                        pwszName = L"";
                        pwszComment = L"";
                        pwszType = L"";
                    }
                    else
                    {
                        pwszComment = ClientInfo->ClientComment;
                        if( pwszComment is NULL )
                        {
                            pwszComment = L"";
                            pwszType = L"";
                        }
                        else
                        {
                            switch(ClientInfo->bClientType)
                            {
                            case CLIENT_TYPE_DHCP:
                                {
                                    pwszType = L"DHCP";
                                    break;
                                }
                            case CLIENT_TYPE_BOOTP:
                                {
                                    pwszType = L"BOOTP";
                                    break;
                                }
                            case CLIENT_TYPE_BOTH:
                            default:
                                {
                                    pwszType = L"BOTH";
                                    break;
                                }
                            }
                        }
                    }                 
                    DisplayMessage(g_hModule,
                                   DMP_SCOPE_ADD_RESERVEDIP,
                                   pwszServerIp,
                                   IpAddressToString(SubnetInfo->SubnetAddress),
                                   IpAddress,
                                   wcData+10,
                                   pwszName,
                                   pwszComment,
                                   pwszType);

                    Error = DhcpDumpReservedOptionValues(pwszServerIp,
                                                 dwMajor,
                                                 dwMinor,
                                                 IpAddressToString(SubnetInfo->SubnetAddress),
                                                 IpAddress);

                    if( Error is ERROR_NOT_ENOUGH_MEMORY )
                    {
                        goto ErrorReturn;
                    }
                }
				
            }
        }

        if( Elements4 ) 
        {
            DhcpRpcFreeMemory( Elements4 );
            Elements4 = NULL;
        }

        if( Elements5 )
        {
            DhcpRpcFreeMemory( Elements5 );
            Elements5 = NULL;
        }
        
        if( Error is NO_ERROR )
        {
             break;
        }
        else
            continue;
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_SCOPE_SET_RESERVEDIP_FOOTER,
                   pwszServerIp,
                   IpAddressToString(SubnetInfo->SubnetAddress));

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

CommonReturn:

    if( Elem )
    {
        DhcpRpcFreeMemory(Elem);
        Elem = NULL;
    }

    if( Elements4 )
    {
        DhcpRpcFreeMemory(Elements4);
        Elements4 = NULL;
    }

    if( Elements5 )
    {
        DhcpRpcFreeMemory(Elements5);
        Elements5 = NULL;
    }

    if( OptionValues )
    {
        DhcpRpcFreeMemory(OptionValues);
        OptionValues = NULL;
    }

    if( OptionArray )
    {
        DhcpRpcFreeMemory(OptionArray);
        OptionArray = NULL;
    }
    
    if( OptionValue )
    {
        DhcpRpcFreeMemory(OptionValue);
        OptionValue = NULL;
    }

    if( SubnetInfo )
    {
        DhcpRpcFreeMemory(SubnetInfo);
        SubnetInfo = NULL;
    }
    if( OptionsArray )
    {
        DhcpRpcFreeMemory(OptionsArray);
        OptionsArray = NULL;
    }
    return Error;

ErrorReturn:
    goto CommonReturn;

}


DWORD
DhcpDumpServerMScope(
                     IN LPCWSTR pwszServer,
                     IN DWORD   dwMajor,
                     IN DWORD   dwMinor,
                     IN LPCWSTR pwszMScope)
{

    DWORD                               Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO                  MScopeInfo = NULL;
    DHCP_RESUME_HANDLE                  Resume = 0;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Element = NULL;
    DWORD                               dw = 0,
                                        dwRead = 0,
                                        dwTotal = 0,
                                        dwLen = 0;
    WCHAR                               Name[256] = {L'\0'},
                                        Comment[256] = {L'\0'};
    LPWSTR                              pwcTemp = NULL;
    DHCP_OPTION_SCOPE_INFO              ScopeInfo = {0};
    LPDHCP_OPTION_VALUE                 Value = NULL;
    DHCP_OPTION_ID                      OptionId = 1; //Lease time    
    DATE_TIME                           InfTime;

    if( pwszMScope is NULL )
        return NO_ERROR;
    
    Error = DhcpGetMScopeInfo((LPWSTR)pwszServer,
                              (LPWSTR)pwszMScope,
                              &MScopeInfo);

    if( Error isnot NO_ERROR )
        return Error;


    if( MScopeInfo->MScopeComment )
    {
        Comment[0] = L'\"';
        dw = wcslen(MScopeInfo->MScopeComment);
        wcsncpy(Comment+1, MScopeInfo->MScopeComment, (dw>252)?252:dw);
        dw = wcslen(Comment);
        Comment[dw] = L'\"';
        Comment[dw+1] = L'\0';
    }


    if( MScopeInfo->MScopeName )
    {
        Name[0] = L'\"';
        dw = wcslen(MScopeInfo->MScopeName);
        wcsncpy(Name+1, MScopeInfo->MScopeName, (dw>252)?252:dw);
        dw = wcslen(Name);
        Name[dw] = L'\"';
        Name[dw+1] = L'\0';
    }

    DisplayMessage(g_hModule,
                   DMP_SRVR_ADD_MSCOPE,
                   pwszServer,
                   Name,
                   Comment,
                   (DWORD)MScopeInfo->TTL);

    DisplayMessage(g_hModule,
                   DMP_MSCOPE_SET_STATE,
                   pwszServer,
                   Name,
                   ( MScopeInfo->MScopeState == DhcpSubnetEnabled ) ? 1 : 0);

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    

    InfTime = DhcpCalculateTime(INFINIT_LEASE);
    if( !memcmp(&InfTime, &MScopeInfo->ExpiryTime, sizeof(InfTime)) )
    {
        //
        // No expiry time set.. 
        //
    }
    else
    {
        DisplayMessage(
            g_hModule,
            DMP_SRVR_MSCOPE_SET_EXPIRY,
            pwszServer,
            MScopeInfo->MScopeName,
            MScopeInfo->ExpiryTime.dwHighDateTime,
            MScopeInfo->ExpiryTime.dwLowDateTime
            );
    }
    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    Resume = 0;
    dwRead = dwTotal = 0;

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_MSCOPE_ADD_IPRANGES_HEADER,
                   pwszServer,
                   Name);

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    //Add ipranges
    {
        while(TRUE)
        {
            Error = DhcpEnumMScopeElements((LPWSTR)pwszServer,
                                           MScopeInfo->MScopeName,
                                           DhcpIpRanges,
                                           &Resume,
                                           ~0,
                                           &Element,
                                           &dwRead,
                                           &dwTotal);

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( Element )
                {
                    DhcpRpcFreeMemory(Element);
                    Element = NULL;
                }
                break;
            }

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
                goto CommonReturn;

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
            {
                if( Element )
                {
                    DhcpRpcFreeMemory(Element);
                    Element = NULL;
                }
                break;
            }

            //Now get the default Lease duration
            {

                ScopeInfo.ScopeType = DhcpMScopeOptions;
                ScopeInfo.ScopeInfo.MScopeInfo =  MScopeInfo->MScopeName;

                Error = DhcpGetOptionValue(g_ServerIpAddressUnicodeString,
                                           OptionId,
                                           &ScopeInfo,
                                           &Value);
                if( Error isnot NO_ERROR )
                {
                    DisplayErrorMessage(g_hModule,
                                        EMSG_SCOPE_DEFAULT_LEASE_TIME,
                                        Error);
                    goto CommonReturn;
                }
            }
            
            for( dw=0; dw<dwRead && dw<Element->NumElements; dw++ )
            {

                DisplayMessage(g_hModule,
                               DMP_MSCOPE_ADD_IPRANGE,
                               pwszServer,
                               Name,
                               IpAddressToString(Element->Elements[dw].Element.IpRange->StartAddress),
                               IpAddressToString(Element->Elements[dw].Element.IpRange->EndAddress),
                               Value ? Value->Value.Elements[0].Element.DWordOption : DEFAULT_BOOTP_LEASE);
            }
            
            DhcpRpcFreeMemory(Element);
            Element = NULL;

            if( Error is NO_ERROR )
                break;
            else
                continue;

        }
                                        
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_MSCOPE_ADD_IPRANGES_FOOTER,
                   pwszServer,
                   Name);


    DisplayMessage(g_hModule,
                   DMP_MSCOPE_ADD_EXCLUDERANGES_HEADER,
                   pwszServer,
                   Name);

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    Resume = 0;
    //Add ipranges
    {
        while(TRUE)
        {
            Error = DhcpEnumMScopeElements((LPWSTR)pwszServer,
                                           MScopeInfo->MScopeName,
                                           DhcpExcludedIpRanges,
                                           &Resume,
                                           ~0,
                                           &Element,
                                           &dwRead,
                                           &dwTotal);

            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( Element )
                {
                    DhcpRpcFreeMemory(Element);
                    Element = NULL;
                }
                break;
            }

            if( Error is ERROR_NOT_ENOUGH_MEMORY )
                goto CommonReturn;

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
            {
                if( Element )
                {
                    DhcpRpcFreeMemory(Element);
                    Element = NULL;
                }
                break;
            }
            
            for( dw=0; dw<dwRead && dw<Element->NumElements; dw++ )
            {
                DisplayMessage(g_hModule,
                               DMP_MSCOPE_ADD_EXCLUDERANGE,
                               pwszServer,
                               Name,
                               IpAddressToString(Element->Elements[dw].Element.ExcludeIpRange->StartAddress),
                               IpAddressToString(Element->Elements[dw].Element.ExcludeIpRange->EndAddress));
            }

            DhcpRpcFreeMemory(Element);
            Element = NULL;

            if( Error is NO_ERROR )
                break;
            else
                continue;

        }
                                        
    }

    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule,
                   DMP_MSCOPE_ADD_EXCLUDERANGES_FOOTER,
                   pwszServer,
                   Name);

    memset(Name, 0x00, sizeof(Name));
    memset(Comment, 0x00, sizeof(Comment));

CommonReturn:
    
    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }

    if( Element )
    {
        DhcpRpcFreeMemory(Element);
        Element = NULL;
    }

    return Error;
}

DWORD
DhcpDumpReservedOptionValues(
                             IN LPCWSTR    pwszServer,
                             IN DWORD      dwMajor,
                             IN DWORD      dwMinor,
                             IN LPCWSTR    pwszScope,
                             IN LPCWSTR    pwszReservedIp
                             )
{

    DWORD                               Error = NO_ERROR,
                                        dw = 0, 
                                        dwLen = 0,
                                        dwRead = 0,
                                        dwTotal = 0,
                                        i =0, j = 0;
    DHCP_OPTION_SCOPE_INFO              ScopeInfo = {0};
    LPDHCP_ALL_OPTION_VALUES            OptionValues = NULL;
    LPDHCP_OPTION_VALUE_ARRAY           OptionArray = NULL;
    LPDHCP_OPTION_VALUE                 OptionValue = NULL;
    DHCP_RESUME_HANDLE                  Resume = 0;
    LPDHCP_OPTION_ARRAY                 OptionsArray = NULL;

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	StringToIpAddress(pwszScope);
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	StringToIpAddress( pwszReservedIp );

    if( ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress is INADDR_NONE )
    {
        return Error;
    }



    if( dwMajor >= CLASS_ID_VERSION )
    {
        Error = DhcpGetAllOptionValues(
                    (LPWSTR)pwszServer,
                    DHCP_OPT_ENUM_IGNORE_VENDOR,
                    &ScopeInfo,
                    &OptionValues
                    );

        if( Error isnot NO_ERROR and 
            Error isnot ERROR_MORE_DATA )
            return Error;
        
        if( OptionValues )
        {
            Error = DhcpDumpServerOptionValuesV5(pwszServer,
                                                 pwszScope,
                                                 pwszReservedIp,
                                                 OptionValues);    
            DhcpRpcFreeMemory(OptionValues);
            OptionValues = NULL;
        }
        return Error;
    }

    else
    {
        while( TRUE )
        {
            Error = DhcpEnumOptionValues(
                            (LPWSTR)pwszServer,
                            &ScopeInfo,
                            &Resume,
                            ~0,
                            &OptionArray,
                            &dwRead,
                            &dwTotal);
  
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                if( OptionArray )
                {
                    DhcpRpcFreeMemory(OptionArray);
                    OptionArray = NULL;
                }
                Error = NO_ERROR;
                return Error;
            }

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
            {
                return Error;
            }
        
            for( dw = 0; dw < dwRead; dw++ )
            {                      
               Error = DhcpDumpServerOptionValue(pwszServer,
                                                 pwszScope,
                                                 pwszReservedIp,
                                                 NULL,
                                                 NULL,
                                                 FALSE,
                                                 OptionArray->Values[dw]);

               if( Error isnot NO_ERROR )
                   break;
            }

            if( OptionArray )
            {
                DhcpRpcFreeMemory(OptionArray);
                OptionArray = NULL;
            }

            if( Error isnot NO_ERROR and
                Error isnot ERROR_MORE_DATA )
                return Error;

            if( Error is NO_ERROR )
                break;
            else
                continue;
        }
        
    }
    return Error;
}

VOID
DhcpDumpServerConfig(IN LPCWSTR pwszServer)
{
}

VOID
DhcpDumpScriptFooter()
{
    DisplayMessage(g_hModule,
                   DMP_DHCP_SCRIPTFOOTER);
}

VOID
DhcpDumpServerScriptFooter(IN LPCWSTR   pwszServer)
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_SERVER_FOOTER,
                   pwszServer);
 
}

DWORD
WINAPI
DhcpDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    BOOL bDone = TRUE;
    extern LPCWSTR g_DhcpGlobalServerName;

    g_DhcpGlobalServerName = pwszRouter;
    return HandleDhcpDump(pwszRouter, ppwcArguments, 0, dwArgCount, 0, pvData, &bDone);
}

VOID
DhcpDumpServerClassHeader()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_CLASS_HEADER);
}
VOID
DhcpDumpServerClassFooter()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_CLASS_FOOTER);
}

VOID
DhcpDumpServerOptiondefHeader()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_OPTIONDEF_HEADER);
}

VOID
DhcpDumpServerOptiondefFooter()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_OPTIONDEF_FOOTER);
}

VOID
DhcpDumpServerOptionvalueHeader()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_OPTIONVALUE_HEADER);
}

VOID
DhcpDumpServerOptionvalueFooter()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_OPTIONVALUE_FOOTER);
}

VOID
DhcpDumpServerScopeHeader()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_SCOPE_HEADER);
}

VOID
DhcpDumpServerScopeFooter()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_SCOPE_FOOTER);
}

VOID
DhcpDumpServerMScopeHeader()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_MSCOPE_HEADER);
}

VOID
DhcpDumpServerMScopeFooter()
{
    DisplayMessage(g_hModule,
                   DMP_SRVR_MSCOPE_FOOTER);
}

VOID
DhcpDumpServerSScopeHeader()
{
    DisplayMessage( g_hModule,
		    DMP_SRVR_SUPER_SCOPE_HEADER );
}

VOID
DhcpDumpServerSScopeFooter()
{
    DisplayMessage( g_hModule,
		    DMP_SRVR_SUPER_SCOPE_FOOTER );
}

VOID
DhcpDumpSuperScopes( IN LPCWSTR pwszServer, 
		     IN DWORD dwMajor, 
		     IN DWORD dwMinor )
{
    LPDHCP_SUPER_SCOPE_TABLE pTable;
    DWORD dwResult, i;

    const int OUT_STR_LEN = 256;
    pTable = NULL;
    
    DhcpDumpServerSScopeHeader();

    dwResult = DhcpGetSuperScopeInfoV4( (LPWSTR) pwszServer, &pTable );
    if ( ERROR_SUCCESS == dwResult ) {

	for ( i = 0; i < pTable->cEntries; i++ ) {

	    if ( NULL != pTable->pEntries[ i ].SuperScopeName ) {
		DisplayMessage( g_hModule,
				DMP_SRVR_ADD_SUPER_SCOPE,
				pwszServer,
				IpAddressToString( pTable->pEntries[ i ].SubnetAddress ),
				pTable->pEntries[ i ].SuperScopeName,
				1 );
	    } // if 
	} // for
    } // if 

    DisplayMessage( g_hModule,
		    MSG_DHCP_FORMAT_LINE );
    DhcpDumpServerSScopeFooter();
} // DhcpDumpSuperScopes()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\dhcphandle.c ===
#include "precomp.h"
#pragma hdrstop


extern ULONG g_ulNumTopCmds;
extern ULONG g_ulNumGroups;
extern ULONG g_ulNumSubContext;

extern CMD_GROUP_ENTRY                  g_DhcpCmdGroups[];
extern CMD_ENTRY                        g_DhcpCmds[];
extern DHCPMON_SUBCONTEXT_TABLE_ENTRY   g_DhcpSubContextTable[];

DWORD
HandleDhcpList(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulNumTopCmds-2; i++)
    {
        DisplayMessage(g_hModule, g_DhcpCmds[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    for(i = 0; i < g_ulNumGroups; i++)
    {
        for(j = 0; j < g_DhcpCmdGroups[i].ulCmdGroupSize; j++)
        {
            DisplayMessage(g_hModule, g_DhcpCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);

            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        }
    }

    for(i=0; i < g_ulNumSubContext; i++)
    {
        DisplayMessage(g_hModule, g_DhcpSubContextTable[i].dwShortCmdHlpToken);

        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}


DWORD
HandleDhcpHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulNumTopCmds-2; i++)
    {
        if(g_DhcpCmds[i].dwCmdHlpToken != MSG_DHCP_NULL)
        {
            DisplayMessage(g_hModule, g_DhcpCmds[i].dwShortCmdHelpToken);
        }
    }

    for(i = 0; i < g_ulNumGroups; i++)
    {
        DisplayMessage(g_hModule, g_DhcpCmdGroups[i].dwShortCmdHelpToken);
    }
    
    for(i=0; i < g_ulNumSubContext; i++)
    {
        DisplayMessage(g_hModule, g_DhcpSubContextTable[i].dwShortCmdHlpToken);

        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }    
    
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}

DWORD
HandleDhcpContexts(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}

extern
LPCWSTR g_DhcpGlobalServerName;

DWORD
HandleDhcpDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                     Error = NO_ERROR;
    BOOL                      fDsInit = FALSE;
    DWORD                     dwMajor = 0,
                              dwMinor = 0;
    DHCP_IP_ADDRESS           dwIpAddress = 0;

    //Optionally required when DhcpEnumServers fails

    DWORD                     dwComputerNameLen = 0;
    LPWSTR                    pwszComputerName = NULL;
    LPSTR                     pszComputerName = NULL;
    struct hostent*           lpHostEnt = NULL;
    BYTE                      pbAdd[4];
    char                      szAdd[4];
    DWORD                     dwHostName = 0;
    DWORD                     i = 0, nLen = 0;
    CHAR                      TempIp[MAX_IP_STRING_LEN+1] = {L'\0'};

    DhcpDumpScriptHeader();
    Error = DhcpDsInit();
    
    fDsInit = TRUE;

        pwszComputerName = NULL;

        if( NULL != g_DhcpGlobalServerName && IsIpAddress( g_DhcpGlobalServerName ) )
        {
            if( NO_ERROR isnot ( Error = DhcpGetVersion(
                (LPWSTR)g_DhcpGlobalServerName,
                &dwMajor, &dwMinor
                ) ) ) {

                DisplayMessage(
                    g_hModule, EMSG_SRVR_UNKNOWN_VERSION, g_DhcpGlobalServerName
                    );
                goto CommonReturn;
            }

            Error = DhcpDumpServer(
                g_DhcpGlobalServerName, dwMajor, dwMinor
                );

            if( NO_ERROR is Error ) goto CommonReturn;
            else goto ErrorReturn;
        }
        
        if( NULL == g_DhcpGlobalServerName ) {

            // 
            // prefix bug in whistler db - 259757
            // GetComputerNameEx doesnt like to have NULL as second parameter
            // work around it
            //

            WCHAR   DummyBuf;
            dwComputerNameLen = 1;

            if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                                   &DummyBuf,
                                   &dwComputerNameLen) )
            {
                
                pwszComputerName = DhcpAllocateMemory((dwComputerNameLen+1)*sizeof(WCHAR));
                
                if(pwszComputerName is NULL)
                {
                    Error = ERROR_NOT_ENOUGH_MEMORY;                
                    goto ErrorReturn;
                }
                
                dwComputerNameLen++;
                if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                                       pwszComputerName,
                                       &dwComputerNameLen) )
                {
                    Error = GetLastError();
		    DhcpFreeMemory( pwszComputerName );
                    goto ErrorReturn;
                }
            } // if !GetComputerName....
        } else {
            pwszComputerName = (LPWSTR)g_DhcpGlobalServerName ; // ISSUE: Invalid const_cast.

        } // else

        //Now process the Computer name and convert it to ANSI because
        //gethostbyname requires ANSI character string.
        
        pszComputerName = DhcpUnicodeToOem(pwszComputerName, NULL);

	// pwszComputerName is no longer needed. Free if memory is allocated to it
	if ( pwszComputerName != g_DhcpGlobalServerName ) {
	    DhcpFreeMemory( pwszComputerName );
	}

        if( pszComputerName is NULL )
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }
        
        //Now get the server IP Address
        lpHostEnt = gethostbyname(pszComputerName);
        
        //Not a valid server name
        if( lpHostEnt is NULL )
        {
            DisplayMessage(g_hModule, EMSG_SRVR_INVALID_COMPUTER_NAME);
            if( pszComputerName )
            {
                DhcpFreeMemory(pszComputerName);
                pszComputerName = NULL;
            }
            Error = WSAGetLastError();
            goto ErrorReturn;
            
        }

        DhcpFreeMemory( pszComputerName );

        //Get the IP Address from the returned struct...
        memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
        nLen = 0;
        for( i=0; i<4; i++)
        {
            
            _itoa((int)pbAdd[i], szAdd, 10);
            memcpy(TempIp+nLen, szAdd, strlen(szAdd));
            nLen += strlen(szAdd);
            *(TempIp+nLen) = '.';
            nLen++;
            
        }
        *(TempIp+nLen-1) = '\0';
        
        if( NO_ERROR isnot ( Error = DhcpGetVersion(DhcpOemToUnicode(TempIp,NULL),
                                                    &dwMajor,
                                                    &dwMinor) ) )
        {
            DisplayMessage(g_hModule, 
                           EMSG_SRVR_UNKNOWN_VERSION,
                           DhcpOemToUnicode(TempIp, NULL));
            goto CommonReturn;
        }
        
        Error = DhcpDumpServer(DhcpOemToUnicode(TempIp, NULL),
                               dwMajor,
                               dwMinor);
        
        if( Error is NO_ERROR )
            goto CommonReturn;
        else
            goto ErrorReturn;
        
CommonReturn:
    if( Error is NO_ERROR)
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    DhcpDumpScriptFooter();

    if( fDsInit )
    {
        DhcpDsCleanup();
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_DHCP_DUMP,
                        Error);
    goto CommonReturn;    
}

DWORD
HandleDhcpAddServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                          Error = NO_ERROR;
    DHCP_SERVER_INFO               Server;
    BOOL                           fDsInit = FALSE;
    
    memset(&Server, 0x00, sizeof(DHCP_SERVER_INFO));
    
    if ( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule,
                       HLP_DHCP_ADD_SERVER_EX);

        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

#ifdef NT5
    Error = DhcpDsInit();
    if( Error isnot NO_ERROR )
    {
        //DisplayMessage(g_hModule, EMSG_DHCP_DSINIT_FAILED, Error);
        //fDsInit = FALSE;
        goto ErrorReturn;
//        return Error;
    }
    fDsInit = TRUE;
#endif //NT5

    Server.ServerName = ppwcArguments[dwCurrentIndex];
    Server.ServerAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);
    Server.Version = 0;
    Server.Flags = 0;
    Server.State = 0;
    Server.DsLocation = NULL;
    Server.DsLocType = 0;


    DisplayMessage(g_hModule,
                   MSG_DHCP_SERVER_ADDING, 
                   ppwcArguments[dwCurrentIndex], 
                   ppwcArguments[dwCurrentIndex+1]);

    Error = DhcpAddServer(0, NULL, &Server, NULL, NULL);
  
    if( NO_ERROR isnot Error ) 
    {
        // could not add the server
        goto ErrorReturn;
    }

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, 
                       EMSG_DHCP_ERROR_SUCCESS);

    if( fDsInit )
    {
        DhcpDsCleanup();
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                   EMSG_DHCP_ADD_SERVER,
                   Error);
    goto CommonReturn;
}

#if 0
DWORD
HandleDhcpAddHelper(
    PWCHAR    pwszMachineName,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwCmdFlags,
    PVOID     pvData,
    BOOL      *pbDone
)
{
     DWORD   dwErr;

    if (dwArgCount-dwCurrentIndex != 3)
    {
        //
        // Install requires name of helper, dll name, entry point
        //

        DisplayMessage(g_hModule,
                       HLP_DHCP_ADD_HELPER_EX);

        return NO_ERROR;
    }

    if(IsReservedKeyWord(ppwcArguments[dwCurrentIndex]))
    {
        DisplayMessage(g_hModule, EMSG_RSVD_KEYWORD,
                       ppwcArguments[dwCurrentIndex]);

        return ERROR_INVALID_PARAMETER;
    }

    dwErr = InstallHelper(REG_KEY_DHCPMGR_HELPER,
                          ppwcArguments[dwCurrentIndex],
                          ppwcArguments[dwCurrentIndex+1],
                          ppwcArguments[dwCurrentIndex+2],
                          &g_HelperTable,
                          &g_dwNumTableEntries);

    if (dwErr is ERROR_NOT_ENOUGH_MEMORY)
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
    }

    return dwErr;
}
#endif //0

DWORD
HandleDhcpDeleteServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                  Error = NO_ERROR;
    DHCP_SERVER_INFO       Server;
    BOOL                   fDsInit = FALSE;

    memset(&Server, 0x00, sizeof(DHCP_SERVER_INFO));

    if( dwArgCount < dwCurrentIndex + 2 )
    {
        DisplayMessage(g_hModule,
                       HLP_DHCP_DELETE_SERVER_EX);

        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
#ifdef NT5
    Error = DhcpDsInit();
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }
    fDsInit = TRUE;
#endif //NT5
    
    Server.Version = 0;
    Server.ServerName = ppwcArguments[dwCurrentIndex];
    Server.ServerAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);
    Server.Flags = 0;
    Server.State = 0;
    Server.DsLocation = NULL;
    Server.DsLocType = 0;

	DisplayMessage(g_hModule,
                   MSG_DHCP_SERVER_DELETING, 
                   ppwcArguments[dwCurrentIndex], 
                   ppwcArguments[dwCurrentIndex+1]);


    Error = DhcpDeleteServer(0, NULL, &Server, NULL, NULL);
    
    if( NO_ERROR isnot Error ) 
    {   
        // could not delete the server
        goto ErrorReturn;
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( fDsInit)
    {
        DhcpDsCleanup();
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                   EMSG_DHCP_DELETE_SERVER,
                   Error);
    goto CommonReturn;
}

#if 0

DWORD
HandleDhcpDeleteHelper(
    PWCHAR    pwszMachineName,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwCmdFlags,
    PVOID     pvData,
    BOOL      *pbDone
)
{
    DWORD   dwErr;

    if (dwArgCount-dwCurrentIndex != 1)
    {
        //
        // Uninstall requires name of helper
        //

        DisplayMessage(g_hModule, 
                       HLP_DHCP_DELETE_HELPER_EX);

        return NO_ERROR;
    }

    dwErr = UninstallHelper(REG_KEY_DHCPMGR_HELPER,
                            ppwcArguments[dwCurrentIndex],
                            &g_HelperTable,
                            &g_dwNumTableEntries);

    if (dwErr is ERROR_NOT_ENOUGH_MEMORY)
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
    }

    return dwErr;
}
#endif //0

DWORD
HandleDhcpShowServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    LPDHCP_SERVER_INFO_ARRAY    Servers = NULL;
    BOOL                        fDsInit = FALSE;

#ifdef NT5
    Error = DhcpDsInit();
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }
    fDsInit = TRUE;
#endif //NT5

    Error = DhcpEnumServers(0, NULL, &Servers, NULL, NULL);
    
    if( NO_ERROR isnot Error ) 
    {
        goto ErrorReturn;
    }

    PrintServerInfoArray(Servers);

CommonReturn:
    if( Error is NO_ERROR)
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if(Servers)
    {
        DhcpRpcFreeMemory(Servers);
        Servers = NULL;
    }

    if( fDsInit )
    {
        DhcpDsCleanup();
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_DHCP_SHOW_SERVER, 
                        Error);
    goto CommonReturn;
}


#if 0
DWORD
HandleDhcpShowHelper(
    PWCHAR    pwszMachineName,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount
    DWORD     dwCmdFlags,
    PVOID     pvData,
    BOOL      *pbDone
)
{
    DWORD    i;

    for (i = 0; i < g_dwNumTableEntries; i++)
    {
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_STRING, g_HelperTable[i].pwszHelper);
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    return NO_ERROR;
}

#endif //0

VOID
PrintServerInfo(                                  // print server information
    LPDHCP_SERVER_INFO       Server
)
{
    DHCP_IP_ADDRESS ServerAddress = (Server->ServerAddress);

    if( Server->DsLocation )
    {
        DisplayMessage(g_hModule, 
                       MSG_DHCP_SERVER_SHOW_INFO,
                       Server->ServerName,
                       IpAddressToString(ServerAddress),
                       Server->DsLocation
                       );
    }
    else
    {
        DisplayMessage(g_hModule, 
                       MSG_DHCP_SERVER_SHOW_INFO,
                       Server->ServerName,
                       IpAddressToString(ServerAddress)
                       );
    }
}

VOID
PrintServerInfoArray(                             // print list of servers
    LPDHCP_SERVER_INFO_ARRAY Servers
)
{
    DWORD   i;

    DisplayMessage(g_hModule, 
                   MSG_DHCP_SERVER_SHOW_INFO_ARRAY, 
                   Servers->NumElements);

    for( i = 0; i < Servers->NumElements; i ++ ) 
    {
        PrintServerInfo(&Servers->Servers[i]);
    }
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\mscopehndl.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
#include "precomp.h"


extern ULONG g_ulMScopeNumTopCmds;
extern ULONG g_ulMScopeNumGroups;

extern CMD_GROUP_ENTRY      g_MScopeCmdGroups[];
extern CMD_ENTRY            g_MScopeCmds[];

extern DWORD  GlobalClientCount;

extern BOOL    GlobalVerbose;

#define DHCP_INFINIT_LEASE  0xffffffff  // Inifinite lease LONG value


DWORD
HandleMScopeList(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulMScopeNumTopCmds-2; i++)
    {
        DisplayMessage(g_hModule, g_MScopeCmds[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);


    for(i = 0; i < g_ulMScopeNumGroups; i++)
    {
        for(j = 0; j < g_MScopeCmdGroups[i].ulCmdGroupSize; j++)
        {
            DisplayMessage(g_hModule, g_MScopeCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);

            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        }
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    return NO_ERROR;
}

DWORD
HandleMScopeHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulMScopeNumTopCmds-2; i++)
    {
        if(g_MScopeCmds[i].dwCmdHlpToken != MSG_DHCP_NULL)
        {
            DisplayMessage(g_hModule, g_MScopeCmds[i].dwShortCmdHelpToken);
        }
    }

    for(i = 0; i < g_ulMScopeNumGroups; i++)
    {
        DisplayMessage(g_hModule, g_MScopeCmdGroups[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}

DWORD
HandleMScopeDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD       Error = NO_ERROR;

    Error = DhcpDumpServerMScope(g_ServerIpAddressUnicodeString,
                                 g_dwMajorVersion,
                                 g_dwMinorVersion,
                                 g_MScopeNameUnicodeString);

    return Error;
}

DWORD
HandleMScopeContexts(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
    }

DWORD
HandleMScopeAddIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{ 
    DWORD                       Error = NO_ERROR;
    DHCP_IP_RANGE               IpRange;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    LPDHCP_MSCOPE_INFO MScopeInfo = NULL;
    DWORD                       dwExpiry = DEFAULT_BOOTP_LEASE;
    BOOL                        fExpiry = FALSE;
    //
    // Expected Parameters are : <MScopeName IpRangeStart IpRangeEnd [Expiry]>
    //

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_ADD_IPRANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    if( IpRange.StartAddress < MSCOPE_START_RANGE or
        IpRange.StartAddress > MSCOPE_END_RANGE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IpRange.EndAddress < MSCOPE_START_RANGE or
        IpRange.EndAddress > MSCOPE_END_RANGE or
        IpRange.EndAddress < IpRange.StartAddress )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    if( dwArgCount > 2 )
    {
        if( IsPureNumeric( ppwcArguments[dwCurrentIndex+2] ) is FALSE )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        dwExpiry = STRTOUL(ppwcArguments[dwCurrentIndex+2], NULL, 10);
        if( dwExpiry <= 0 )
            dwExpiry = DEFAULT_BOOTP_LEASE;
        if( dwExpiry > INFINIT_LEASE )
            dwExpiry = INFINIT_LEASE;

        fExpiry = TRUE;
    }

    //Set the MScopeID & Expiry
    {

        Error = DhcpGetMScopeInfo(g_ServerIpAddressUnicodeString,
                                  g_MScopeNameUnicodeString,
                                  &MScopeInfo
                                  );

        if( Error isnot NO_ERROR )
        {
            goto ErrorReturn;
        }

        MScopeInfo->MScopeId = IpRange.StartAddress;

        //Since we are setting the MSCopeID here, let us first delete the MScope
        //and recreate it again.

        Error = DhcpDeleteMScope(g_ServerIpAddressUnicodeString,
                                 g_MScopeNameUnicodeString,
                                 DhcpFullForce);

        if( Error isnot NO_ERROR )
            goto ErrorReturn;

        Error = DhcpSetMScopeInfo(g_ServerIpAddressUnicodeString,
                                  g_MScopeNameUnicodeString,
                                  MScopeInfo,
                                  TRUE);
        if( Error isnot NO_ERROR )
            goto ErrorReturn;

        Error = DhcpAddMScopeElement( g_ServerIpAddressUnicodeString,
                                      g_MScopeNameUnicodeString,
                                      &Element );
    
        if( Error isnot NO_ERROR )
            goto ErrorReturn;

    }

    //Now set the default lease duration
    {
        DHCP_OPTION_SCOPE_INFO   ScopeInfo = {0};
        DHCP_OPTION_DATA_ELEMENT OptionData = {0};
        DHCP_OPTION_DATA         Option = {0};
        DHCP_OPTION_ID           OptionId = 1; //Lease time

        ScopeInfo.ScopeType = DhcpMScopeOptions;
        ScopeInfo.ScopeInfo.MScopeInfo =  g_MScopeNameUnicodeString;

        OptionData.OptionType = DhcpDWordOption;
        OptionData.Element.DWordOption = dwExpiry;


        Option.NumElements = 1;
        Option.Elements = &OptionData;

        Error = DhcpSetOptionValue(g_ServerIpAddressUnicodeString,
                                   OptionId,
                                   &ScopeInfo,
                                   &Option);
        if( Error isnot NO_ERROR )
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SCOPE_DEFAULT_LEASE_TIME,
                                Error);
            goto CommonReturn;
        }
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_ADD_IPRANGE,
                        Error );
    goto CommonReturn;


}

DWORD
HandleMScopeAddExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DHCP_IP_RANGE               ExcludeRange;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    BOOL                        fPresent = FALSE;

    //
    // Expected Parameters are : <MScopeName IpRangeStart IpRangeEnd>
    //
    
    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));


    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_ADD_EXCLUDERANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
        
    }
    ExcludeRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    ExcludeRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( ExcludeRange.StartAddress is INADDR_NONE or 
        ExcludeRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    //Check to see if this is a valid exclusion range.
    {
        ULONG                               nRead, nTotal, i, nCount;
        ULONG                               Resume;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements = NULL;
        BOOL                                fTable = FALSE;


        Resume = 0;
        nRead = nTotal = nCount = 0;

        while( TRUE ) 
        {
            Elements = NULL;
            nRead = nTotal = 0;
        
            Error = DhcpEnumMScopeElements(
                    g_ServerIpAddressUnicodeString,
                    g_MScopeNameUnicodeString,
                    DhcpIpRanges,
                    &Resume,
                    ~0,
                    &Elements,
                    &nRead,
                    &nTotal
                    );
        
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                Error = NO_ERROR;
                break;
            }

            nCount+= nRead;

           
            if( ERROR isnot NO_ERROR and
                ERROR isnot ERROR_MORE_DATA )
            {
                DisplayMessage(g_hModule,
                               EMSG_MSCOPE_IPRANGE_VERIFY);
            }

            if( NO_ERROR is Error or
                ERROR_MORE_DATA is Error ) 
            {
                for( i = 0; i < nRead ; i ++ ) 
                {
                    if( ExcludeRange.StartAddress >= Elements->Elements[i].Element.IpRange->StartAddress and
                        ExcludeRange.EndAddress <= Elements->Elements[i].Element.IpRange->EndAddress )
                    {
                        fPresent = TRUE;
                    }
                }
            }

            DhcpRpcFreeMemory( Elements );
        
            Elements = NULL;

            if( Error is ERROR_MORE_DATA )
            {
                continue;
            }
            else
                break;
        }
        if( fPresent is FALSE )
        {
            DisplayMessage(g_hModule,
                           EMSG_SCOPE_INVALID_EXCLUDERANGE);

            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }



    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.IpRange = &ExcludeRange;
    


    Error = DhcpAddMScopeElement(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                &Element );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_ADD_EXCLUDERANGE,
                        Error);
    goto CommonReturn;
}


DWORD
HandleMScopeCheckDatabase(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD            Error = NO_ERROR;
    LPDHCP_SCAN_LIST ScanList    = NULL;
   
   //
   // Expected Parameters are : <MScopeName>
   //

   Error = DhcpScanMDatabase(
               g_ServerIpAddressUnicodeString,
               g_MScopeNameUnicodeString,
               TRUE,        // fix bad entries.
               &ScanList );

   if( Error isnot ERROR_SUCCESS )
       goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if (ScanList) 
    {
        DhcpRpcFreeMemory( ScanList );
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_CHECK_DATABASE,
                        Error);
    goto CommonReturn;

}

DWORD
HandleMScopeDeleteIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                         Error = NO_ERROR;
    DHCP_SUBNET_ELEMENT_DATA_V4   RemoveElementInfo;
    DHCP_FORCE_FLAG               bFlag = DhcpFullForce;
    DHCP_IP_RANGE                 IpRange;
    //
    //Expected parameters <start-ip-range> <end-ip-range>
    //

    memset(&RemoveElementInfo, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    memset(&IpRange, 0x00, sizeof(DHCP_IP_RANGE));
    
    if( dwArgCount < 2 )
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_DELETE_IPRANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    RemoveElementInfo.ElementType = DhcpIpRanges;
    RemoveElementInfo.Element.IpRange = &IpRange;

    Error = DhcpRemoveMScopeElement(g_ServerIpAddressUnicodeString,
                                    g_MScopeNameUnicodeString, 
                                    &RemoveElementInfo,
                                    bFlag);
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_DELETE_IPRANGE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeDeleteExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                         Error = NO_ERROR;
    DHCP_SUBNET_ELEMENT_DATA_V4   RemoveElementInfo;
    DHCP_FORCE_FLAG               bFlag = DhcpFullForce;
    DHCP_IP_RANGE                 IpRange;
    //
    //Expected parameters <start-ip-range> <end-ip-range>
    //

    memset(&RemoveElementInfo, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    memset(&IpRange, 0x00, sizeof(DHCP_IP_RANGE));

    if( dwArgCount < 2 )
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_DELETE_EXCLUDERANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    RemoveElementInfo.ElementType = DhcpExcludedIpRanges;
    RemoveElementInfo.Element.ExcludeIpRange = &IpRange;

    Error = DhcpRemoveMScopeElement(g_ServerIpAddressUnicodeString,
                                    g_MScopeNameUnicodeString, 
                                    &RemoveElementInfo,
                                    bFlag);
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_DELETE_EXCLUDERANGE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeDeleteOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD             Error = NO_ERROR;
    DHCP_OPTION_ID          OptionID;
    DHCP_OPTION_SCOPE_INFO  ScopeInfo;
    

    LPWSTR         pwcTag = NULL;
    LPWSTR         pwcUser = NULL;   
    LPWSTR         pwcVendor = NULL;
    LPWSTR         pwcTemp = NULL;

    BOOL           fUser = FALSE;
    BOOL           fVendor = FALSE;

    DWORD          dwIndex = 0;

    //
    // Expected Parameters are :
    // subnet-address <OptionID>
    //

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));


    if( dwArgCount < 1 ) 
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_DELETE_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ScopeInfo.ScopeType = DhcpMScopeOptions;
    ScopeInfo.ScopeInfo.MScopeInfo =  g_MScopeNameUnicodeString;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );

    dwIndex = 1;
    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    Error = RemoveOptionValue(
        g_ServerIpAddressUnicodeString,
        0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo
    );
       
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( pwcUser )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_DELETE_OPTIONVALUE,
                        Error);

    goto CommonReturn;
}


DWORD
HandleMScopeSetState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;
    DWORD               State = 0;
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_SET_STATE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IsPureNumeric( ppwcArguments[dwCurrentIndex] ) is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    Error = DhcpGetMScopeInfo( g_ServerIpAddressUnicodeString,
                               g_MScopeNameUnicodeString,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    State = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 0 );

    if( State == 0 ) 
    {
        if( MScopeInfo->MScopeState == DhcpSubnetDisabled ) 
        {
            Error = NO_ERROR;
            goto CommonReturn;
        }
        MScopeInfo->MScopeState = DhcpSubnetDisabled;
    }
    else if( State == 1 )
    {
        if( MScopeInfo->MScopeState == DhcpSubnetEnabled ) 
        {
            Error = NO_ERROR;
            goto CommonReturn;
        }
        MScopeInfo->MScopeState = DhcpSubnetEnabled;
    }
    else
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Error = DhcpSetMScopeInfo( g_ServerIpAddressUnicodeString,
                               g_MScopeNameUnicodeString,
                               MScopeInfo,
                               FALSE);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }
    DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    return Error;

ErrorReturn:
    
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SET_STATE,
                        Error);

    goto CommonReturn;
}   

DWORD
HandleMScopeSetOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = NO_ERROR;
    DHCP_OPTION_ID           OptionID;
    DHCP_OPTION_SCOPE_INFO   ScopeInfo;
    DHCP_OPTION_DATA         OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData;
    DHCP_OPTION_DATA_TYPE    OptionType;
    LPWSTR                   UnicodeOptionValueString = NULL;
    LPDHCP_OPTION            OptionInfo = NULL;
    LPWSTR                   OptionTypeString = NULL;

    LPWSTR                   pwcTag = NULL;
    LPWSTR                   pwcUser = NULL;
    LPWSTR                   pwcVendor = NULL;
    LPWSTR                   pwcTemp = NULL;

    BOOL                     fUser = FALSE;
    BOOL                     fVendor = FALSE;
    BOOL                     fValidType = FALSE;

    DWORD                    i = 0;
    DWORD                    dwIndex = 0;

    //
    // Expected Parameters are :
    // subnet-address <OptionID OptionType OptionValue>
    //

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    memset(&OptionValue, 0x00, sizeof(DHCP_OPTION_DATA));
    memset(&OptionData, 0x00, sizeof(DHCP_OPTION_DATA_ELEMENT));


    if( dwArgCount < 3 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    
    ScopeInfo.ScopeType = DhcpMScopeOptions;
    ScopeInfo.ScopeInfo.MScopeInfo =  g_MScopeNameUnicodeString;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+dwIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex+dwIndex], NULL, 10 );
    
    dwIndex++;

    OptionTypeString = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;

    while( NULL isnot wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
    {
        LPWSTR  pwcStr = NULL;
        if( dwArgCount <= dwIndex + 1 )
        {
            DisplayMessage(g_hModule, HLP_SRVR_SET_OPTIONVALUE_EX);
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionInfoV5(g_ServerIpAddressUnicodeString,
                                    fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                    OptionID,
                                    NULL,
                                    pwcVendor,
                                    &OptionInfo);
    }
    else
    {
    
        Error = DhcpGetOptionInfo(g_ServerIpAddressUnicodeString,
                                  OptionID,
                                  &OptionInfo);
    }

    if( Error isnot NO_ERROR )
        return Error;

    //Check if OptionType supplied is the same as defined.

    //Find out the OptionType
    for(i=0; i < sizeof(TagOptionType)/sizeof(COMMAND_OPTION_TYPE); i++)
    {
        if( MatchToken(OptionTypeString, TagOptionType[i].pwszTagID) )
        {
            OptionType = TagOptionType[i].DataType;
            fValidType = TRUE;
            break;
        }
    }
    
    if( fValidType is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( OptionType isnot OptionInfo->DefaultValue.Elements[0].OptionType )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_OPTIONTYPE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    
    switch(OptionInfo->OptionType)
    {
    case DhcpArrayTypeOption:
        {
            Error = SetOptionDataTypeArray(
                            OptionType,
                            ppwcArguments+dwCurrentIndex,
                            dwIndex,
                            dwArgCount, //Corrections
                            &OptionValue);
            if( Error isnot NO_ERROR )
                goto ErrorReturn;
            break;
        }
    case DhcpUnaryElementTypeOption:
    default:
        {

            Error = SetOptionDataType(
                        OptionType,
                        ppwcArguments[dwCurrentIndex+dwIndex],
                        &OptionData,
                        &UnicodeOptionValueString );

            if( Error != NO_ERROR ) 
            {
                goto ErrorReturn;
            }

            OptionValue.NumElements = 1;
            OptionValue.Elements = &OptionData;
            break;
        }
    }
        
    Error = SetOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo,
        &OptionValue
    );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( OptionInfo )
    {
        if(OptionInfo->OptionType is DhcpArrayTypeOption)
        {
            if( OptionValue.Elements isnot NULL )
            {
                free(OptionValue.Elements);
                OptionValue.Elements = NULL;
            }
        }
    }

    if( pwcUser )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                   EMSG_SCOPE_SET_OPTIONVALUE,
                   Error);

    goto CommonReturn;

}


DWORD
HandleMScopeSetMScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_MSCOPE_SET_MSCOPE_EX);
        DisplayErrorMessage(g_hModule,
                            EMSG_MSCOPE_SET_MSCOPE,
                            ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
                            
    }
    if( SetMScopeInfo(ppwcArguments[dwCurrentIndex]))
    {
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
        return NO_ERROR;
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_MSCOPE_SET_MSCOPE,
                            ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }
}

DWORD
HandleMScopeSetName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = ERROR_SUCCESS;
    LPDHCP_MSCOPE_INFO MScopeInfo = NULL;
    
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_MSCOPE_SET_NAME_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    Error = DhcpGetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                &MScopeInfo );

    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
    DhcpAssert(MScopeInfo isnot NULL);

    
    MScopeInfo->MScopeName = ppwcArguments[dwCurrentIndex];

    Error = DhcpSetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                MScopeInfo,
				FALSE);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    SetMScopeInfo(ppwcArguments[dwCurrentIndex]);

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( MScopeInfo != NULL )
    {
        DhcpRpcFreeMemory( MScopeInfo );
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SET_NAME,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeSetComment(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = ERROR_SUCCESS;
    LPDHCP_MSCOPE_INFO MScopeInfo = NULL;

    Error = DhcpGetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                &MScopeInfo );
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
    DhcpAssert(MScopeInfo isnot NULL);

    
    if( dwArgCount < 1 )
    {
        MScopeInfo->MScopeComment = NULL;
    }
    else
    {
        MScopeInfo->MScopeComment = ppwcArguments[dwCurrentIndex];
    }

    Error = DhcpSetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                MScopeInfo,
				FALSE);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    if( MScopeInfo != NULL )
    {
        DhcpRpcFreeMemory( MScopeInfo );
    }
    return( Error );

ErrorReturn:

    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SET_COMMENT,
                        Error);
    
    goto CommonReturn;
}

DWORD
HandleMScopeSetTTL(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = ERROR_SUCCESS;
    LPDHCP_MSCOPE_INFO MScopeInfo = NULL;
    DWORD              dwTTL = 255;
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_MSCOPE_SET_TTL_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IsPureNumeric(ppwcArguments[dwCurrentIndex]) is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwTTL = STRTOUL(ppwcArguments[dwCurrentIndex], NULL, 10);

    if( dwTTL <= 0 )
        dwTTL = 1;

    if( dwTTL > 255 )
        dwTTL = 255;

    Error = DhcpGetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                &MScopeInfo );

    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
    
    MScopeInfo->TTL = (BYTE)dwTTL;

    Error = DhcpSetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                MScopeInfo,
				FALSE);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( MScopeInfo != NULL )
    {
        DhcpRpcFreeMemory( MScopeInfo );
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SET_TTL,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeSetExpiry(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = ERROR_SUCCESS;
    LPDHCP_MSCOPE_INFO MScopeInfo = NULL;
    DWORD              dwExpiry = 0;
    DWORD              dwExpiry2 = 0;

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_MSCOPE_SET_EXPIRY_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IsPureNumeric(ppwcArguments[dwCurrentIndex]) is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( dwArgCount >= 2 &&
        IsPureNumeric(ppwcArguments[dwCurrentIndex]) is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
                                   
    Error = DhcpGetMScopeInfo(
        g_ServerIpAddressUnicodeString,
        g_MScopeNameUnicodeString,
        &MScopeInfo
        );
    
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;        
    
    dwExpiry = STRTOUL(ppwcArguments[dwCurrentIndex], NULL, 10);

    if( dwArgCount >= 2 )
    {
        //
        // One more arg -- this is absolute time 
        //

        dwExpiry2 = STRTOUL(ppwcArguments[dwCurrentIndex+1], NULL, 10);

        MScopeInfo->ExpiryTime.dwHighDateTime = dwExpiry;
        MScopeInfo->ExpiryTime.dwLowDateTime = dwExpiry2;
        
    } else {

        //
        // Only one parameter -- relative time in hours
        //
        
        if( dwExpiry == 0 ) {
            dwExpiry = INFINIT_LEASE;
        } else {
            dwExpiry *= 60 * 60;
        }

        MScopeInfo->ExpiryTime = DhcpCalculateTime(dwExpiry);
    }
    
    Error = DhcpSetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                MScopeInfo,
				FALSE);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( MScopeInfo != NULL )
    {
        DhcpRpcFreeMemory( MScopeInfo );
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SET_EXPIRY,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeSetLease(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                    Error = ERROR_SUCCESS;
    DHCP_OPTION_SCOPE_INFO   ScopeInfo = {0};
    DHCP_OPTION_DATA_ELEMENT OptionData = {0};
    DHCP_OPTION_DATA         Option = {0};
    DHCP_OPTION_ID           OptionId = 1; //Lease time
    DWORD                    dwExpiry = 0;

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_MSCOPE_SET_LEASE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //if -1 => Infinite lease
    if( wcscmp(ppwcArguments[dwCurrentIndex], L"-1") is 0 )
    {
        dwExpiry = DHCP_INFINIT_LEASE;
    }
    //else if not proper numeric value, return Bad parameter
    else if( IsPureNumeric(ppwcArguments[dwCurrentIndex]) is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    else
    {
        dwExpiry = STRTOUL(ppwcArguments[dwCurrentIndex], NULL, 10);
    }

    ScopeInfo.ScopeType = DhcpMScopeOptions;
    ScopeInfo.ScopeInfo.MScopeInfo =  g_MScopeNameUnicodeString;

    OptionData.OptionType = DhcpDWordOption;
    OptionData.Element.DWordOption = dwExpiry;


    Option.NumElements = 1;
    Option.Elements = &OptionData;

    Error = DhcpSetOptionValue(g_ServerIpAddressUnicodeString,
                               OptionId,
                               &ScopeInfo,
                               &Option);
    if( Error isnot ERROR_SUCCESS )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SET_LEASE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleMScopeShowClients(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                     Error = NO_ERROR;
    DHCP_RESUME_HANDLE        ResumeHandle = 0;
    LPDHCP_MCLIENT_INFO_ARRAY ClientEnumInfo = NULL;
    DWORD                     ClientsRead = 0;
    DWORD                     ClientsTotal = 0;
    DWORD                     nCount = 0;
    DWORD                     i;

    //
    // Expected Parameters are : <MScopeNames>
    //
    
    GlobalClientCount = 1;

    for(;;) 
    {

        ClientEnumInfo = NULL;
        Error = DhcpEnumMScopeClients(
                    g_ServerIpAddressUnicodeString,
                    g_MScopeNameUnicodeString,
                    &ResumeHandle,
                    ~0,
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule,
                           MSG_MSCOPE_CLIENTS_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);

            Error = NO_ERROR;
            break;
        }

        if( Error isnot ERROR_SUCCESS and
            Error isnot ERROR_MORE_DATA ) 
        {
            goto ErrorReturn;
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );
        
        nCount += ClientsRead;

        if( GlobalVerbose )
        {

            for( i = 0; i < ClientsRead; i++ )
            {
                PrintMClientInfo(ClientEnumInfo->Clients[i]);
            }
        }
        else
        {
            for( i = 0; i < ClientsRead; i++ ) 
            {
                PrintMClientInfoShort(ClientEnumInfo->Clients[i]);
            }
            
        }
        

        DhcpRpcFreeMemory( ClientEnumInfo );
        ClientEnumInfo = NULL;


        if( Error is ERROR_MORE_DATA ) 
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_MSCOPE_CLIENTS_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);
            break;
        }

    }
    if( Error isnot ERROR_SUCCESS )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_CLIENTS,
                        Error);

    goto CommonReturn;
}


DWORD
HandleMScopeShowIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    ULONG                               nRead, nTotal, i, nCount;
    ULONG                               Resume;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements = NULL;
    BOOL                                fTable = FALSE;


    Resume = 0;
    nRead = nTotal = nCount = 0;

    while( TRUE ) 
    {
        Elements = NULL;
        nRead = nTotal = 0;
        
        Error = DhcpEnumMScopeElements(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                DhcpIpRanges,
                &Resume,
                ~0,
                &Elements,
                &nRead,
                &nTotal
                );
        
        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule,
                           MSG_MSCOPE_IPRANGE_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);
            Error = NO_ERROR;
            break;
        }

        nCount+= nRead;

        if( fTable is FALSE )
        {

            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_TABLE);

            fTable = TRUE;
        }

        if( NO_ERROR == Error || ERROR_MORE_DATA == Error ) 
        {
            for( i = 0; i < nRead ; i ++ ) 
            {
                PrintRange(
                    Elements->Elements[i].ElementType,
                    Elements->Elements[i].Element.IpRange->StartAddress,
                    Elements->Elements[i].Element.IpRange->EndAddress,
                    0,
                    0,
                    FALSE);
            }
        }

        DhcpRpcFreeMemory( Elements );
        
        Elements = NULL;

        if( Error is ERROR_MORE_DATA )
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_MSCOPE_IPRANGE_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);
            break;
        }
    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_IPRANGE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleMScopeShowExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    ULONG                               nRead, nTotal, i, nCount;
    ULONG                               Resume;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements = NULL;
    BOOL                                fTable = FALSE;

    Resume = 0;
    nCount = 0;

    while( TRUE ) 
    {
        Elements = NULL;
        nRead = nTotal = 0;
        
        Error = DhcpEnumMScopeElements(
                g_ServerIpAddressUnicodeString,
                g_MScopeNameUnicodeString,
                DhcpExcludedIpRanges,
                &Resume,
                ~0,
                &Elements,
                &nRead,
                &nTotal
                );
    
        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule, 
                           MSG_MSCOPE_EXCLUDERANGE_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);

            Error = NO_ERROR;

            break;
        }


        if( fTable is FALSE )
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_EXCLUDERANGE_TABLE);

            fTable = TRUE;
        }

        if( NO_ERROR is Error or
            ERROR_MORE_DATA is Error ) 
        {
            
            nCount+= nRead;

            for( i = 0; i < nRead ; i ++ ) 
            {
                PrintRange(
                    Elements->Elements[i].ElementType,
                    Elements->Elements[i].Element.IpRange->StartAddress,
                    Elements->Elements[i].Element.IpRange->EndAddress,
                    0,
                    0,
                    TRUE);
            }
        }

        DhcpRpcFreeMemory( Elements );

        Elements = NULL;
        
        if( Error is ERROR_MORE_DATA )
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule, 
                           MSG_MSCOPE_EXCLUDERANGE_COUNT,
                           nCount,
                           g_MScopeNameUnicodeString);

            break;
        }
        
    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SHOW_IPRANGE,
                        Error);

    goto CommonReturn;


}

DWORD
HandleMScopeShowState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;
    BOOL                fActive = FALSE;


    Error = DhcpGetMScopeInfo( g_ServerIpAddressUnicodeString,
                               g_MScopeNameUnicodeString,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    if( MScopeInfo->MScopeState is DhcpSubnetEnabled )
    {
        fActive = TRUE;
    }
    else
    {
        fActive = FALSE;
    }

    if( fActive )
    {
        DisplayMessage(g_hModule,
                       MSG_MSCOPE_STATE_ACTIVE,
                       g_MScopeNameUnicodeString);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_MSCOPE_STATE_NOTACTIVE,
                       g_MScopeNameUnicodeString);
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_STATE,
                        Error);

    goto CommonReturn;

}

DWORD
HandleMScopeShowMibinfo(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                   Error = NO_ERROR;
    LPDHCP_MCAST_MIB_INFO   MScopeMib = NULL;
    FILETIME                ftTime;
    LPMSCOPE_MIB_INFO       ScopeInfo = NULL;
    DWORD                   i=0;
    LPWSTR                  pwszTime = NULL;

    Error = DhcpGetMCastMibInfo( g_ServerIpAddressUnicodeString,
                                 &MScopeMib);

    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    DhcpAssert(MScopeMib isnot NULL);

    DisplayMessage(g_hModule, MSG_MSCOPE_MIB);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_DISCOVERS, MScopeMib->Discovers);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_OFFERS, MScopeMib->Offers);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_REQUESTS, MScopeMib->Requests);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_RENEWS, MScopeMib->Renews);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_ACKS, MScopeMib->Acks);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_NAKS, MScopeMib->Naks);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_RELEASES, MScopeMib->Releases);
    DisplayMessage(g_hModule, MSG_MSCOPE_MIB_INFORMS, MScopeMib->Informs);
    
    ftTime = *(FILETIME *)(&MScopeMib->ServerStartTime);

    i=0;
    pwszTime = GetDateTimeString(ftTime,
                                 FALSE,
                                 &i);

    DisplayMessage(g_hModule,
                   MSG_MSCOPE_MIB_SERVERSTARTTIME,
                   pwszTime ? pwszTime : L" ");

    if( pwszTime ) 
    {
        DhcpFreeMemory(pwszTime);
        pwszTime = NULL;
    }

    
    DisplayMessage(g_hModule, MSG_SRVR_MIB_SCOPES, MScopeMib->Scopes);

    ScopeInfo = MScopeMib->ScopeInfo;


    for ( i = 0; i < MScopeMib->Scopes; i++ ) 
    {
        DisplayMessage(g_hModule, MSG_MSCOPE_MIB_MSCOPEID, ScopeInfo[i].MScopeId);
        DisplayMessage(g_hModule, MSG_MSCOPE_MIB_MSCOPENAME, ScopeInfo[i].MScopeName);
                   
        DisplayMessage(g_hModule, MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMADDRESSESINUSE,
                    ScopeInfo[i].NumAddressesInuse );
        DisplayMessage(g_hModule, MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMADDRESSESFREE,
                    ScopeInfo[i].NumAddressesFree );
        DisplayMessage(g_hModule, MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMPENDINGOFFERS,
                    ScopeInfo[i].NumPendingOffers );
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

CommonReturn:

    DhcpRpcFreeMemory( MScopeMib );
    return Error;
ErrorReturn:
    DisplayMessage(g_hModule,
                   EMSG_SRVR_SHOW_MIBINFO,
                   Error);
    goto CommonReturn;

}

DWORD
HandleMScopeShowMScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DisplayMessage(g_hModule,
                   MSG_MSCOPE_MSCOPE,
                   g_MScopeNameUnicodeString,
                   g_ServerIpAddressUnicodeString);
    return NO_ERROR;
}

DWORD
HandleMScopeShowExpiry(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;
    FILETIME            ftTime;
    DATE_TIME           InfTime;
    LPWSTR              pwszTime = NULL;
    
    Error = DhcpGetMScopeInfo( g_ServerIpAddressUnicodeString,
                               g_MScopeNameUnicodeString,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }


    InfTime = DhcpCalculateTime(INFINIT_LEASE);

    if( !memcmp(&InfTime, &MScopeInfo->ExpiryTime, sizeof(InfTime)) )
    {
        DisplayMessage(
            g_hModule, MSG_MSCOPE_INFINITE_EXPIRATION
            );

    } 
    else
    {
        int i=0;
        ftTime = *(FILETIME *)(&MScopeInfo->ExpiryTime);

        pwszTime = GetDateTimeString(ftTime,
                                     FALSE,
                                     &i);

        DisplayMessage(g_hModule, 
                       MSG_MSCOPE_EXPIRY,
                       pwszTime ? pwszTime : L" ");

        if( pwszTime )
        {   
            DhcpFreeMemory(pwszTime);
            pwszTime = NULL;
        }

    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_EXPIRY,
                        Error);

    goto CommonReturn;

}

DWORD
HandleMScopeShowTTL(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;
    

    Error = DhcpGetMScopeInfo( g_ServerIpAddressUnicodeString,
                               g_MScopeNameUnicodeString,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    DisplayMessage(g_hModule,
                   MSG_MSCOPE_TTL,
                   (DWORD)MScopeInfo->TTL);

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( MScopeInfo )
    {
        DhcpRpcFreeMemory(MScopeInfo);
        MScopeInfo = NULL;
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_TTL,
                        Error);

    goto CommonReturn;

}

DWORD
HandleMScopeShowLease(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    DHCP_OPTION_SCOPE_INFO              ScopeInfo = {0};
    LPDHCP_OPTION_VALUE                 Value = NULL;
    DHCP_OPTION_ID                      OptionId = 1; //Lease time
    LPWSTR                              pwszTime = NULL;

    ScopeInfo.ScopeType = DhcpMScopeOptions;
    ScopeInfo.ScopeInfo.MScopeInfo =  g_MScopeNameUnicodeString;

    Error = DhcpGetOptionValue(g_ServerIpAddressUnicodeString,
                               OptionId,
                               &ScopeInfo,
                               &Value);

    if(Error is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       EMSG_MSCOPE_LEASE_NOTSET);
        goto CommonReturn;
    }
    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }

    if( DHCP_INFINIT_LEASE isnot Value->Value.Elements[0].Element.DWordOption )
    {
        pwszTime = MakeDayTimeString(Value->Value.Elements[0].Element.DWordOption);
        DisplayMessage(g_hModule,
                       MSG_MSCOPE_LEASE,
                       pwszTime);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_MSCOPE_INFINITE_LEASE);
    }


CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( pwszTime )
    {
        free(pwszTime);
        pwszTime = NULL;
    }
    if( Value )
    {
        DhcpRpcFreeMemory(Value);
        Value = NULL;
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_MSCOPE_SHOW_TTL,
                        Error);

    goto CommonReturn;

}



VOID
PrintMClientInfo(
    LPDHCP_MCLIENT_INFO ClientInfo
    )
{
    DWORD i = 0;
    DWORD DataLength = 0;
    LPBYTE Data = NULL;
    FILETIME ftTime = {0};
    char *szClientType = NULL;
    LPWSTR  pwszTime = NULL;

    DisplayMessage(g_hModule, MSG_MSCOPE_CLIENT_INFO);
    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_IPADDRESS,
        IpAddressToString(ClientInfo->ClientIpAddress));
    DisplayMessage(g_hModule, MSG_SCOPE_MULTICAST_SCOPEID,
        ClientInfo->MScopeId);

    DataLength = ClientInfo->ClientId.DataLength;
    Data = ClientInfo->ClientId.Data;
    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS);
    for( i = 0; i < DataLength; i++ ) 
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS_FORMAT, (DWORD)Data[i]);
        if( (i+1) < DataLength ) 
        {
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_DASH);
        }
    }
    
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_NAME, ClientInfo->ClientName);

    
    if ( ClientInfo->ClientLeaseStarts.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseStarts.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_DURATION_STR);
    }


    else
    {
        ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseStarts);
        i=0;
        pwszTime = GetDateTimeString(ftTime,
                                     TRUE,
                                     &i);
        DisplayMessage(g_hModule,
                       MSG_SCOPE_CLIENT_DURATION_DATE_STARTS,
                       pwszTime ? pwszTime : L" ");

        if( pwszTime )
        {
            DhcpFreeMemory(pwszTime);
            pwszTime = NULL;
        }


    }
    
    if ( ClientInfo->ClientLeaseEnds.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseEnds.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_DURATION_STR);
    }
    else
    {
        ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseEnds);
        i=0;
        pwszTime = GetDateTimeString(ftTime,
                                     TRUE,
                                     &i);

       DisplayMessage(g_hModule,
                      MSG_SCOPE_CLIENT_DURATION_DATE_EXPIRES,
                      pwszTime ? pwszTime : L" ");

       if( pwszTime )
       {
           DhcpFreeMemory(pwszTime);
           pwszTime = NULL;
       }

    }
    DisplayMessage(g_hModule, 
                   MSG_SCOPE_OWNER_IPADDRESS,
                   IpAddressToString(ClientInfo->OwnerHost.IpAddress));

    DisplayMessage(g_hModule, 
                   MSG_SCOPE_OWNER_NETBIOSNAME,
                   ClientInfo->OwnerHost.NetBiosName );

    DisplayMessage(g_hModule, 
                   MSG_SCOPE_OWNER_NAME,
                   ClientInfo->OwnerHost.HostName );

    DisplayMessage(g_hModule, 
                   MSG_SCOPE_CLIENT_STATE, 
                   ClientInfo->AddressState );
}

DWORD
HandleMScopeShowOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DWORD                       Major;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY   OptionArray = NULL;
    DHCP_RESUME_HANDLE          Resume = 0;
    
    LPWSTR                      pwcTag = NULL;
    LPWSTR                      pwcUser = NULL;
    LPWSTR                      pwcVendor = NULL;
    LPWSTR                      pwcTemp = NULL;

    BOOL                        fUser = FALSE;
    BOOL                        fVendor = FALSE;

    DWORD                       dwRead = 0;
    DWORD                       dwTotal = 0;
    DWORD                       dwCount = 0;

    BOOL                        fTable = FALSE;

    DWORD                       dwIndex=0;
    enum                        { all=0, user, vendor, both}eDisplay;

    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    
    ScopeInfo.ScopeType = DhcpMScopeOptions;
    ScopeInfo.ScopeInfo.MScopeInfo = g_MScopeNameUnicodeString;

    eDisplay = all;

    if( dwArgCount > dwIndex )
    {
        if( _wcsicmp(ppwcArguments[dwCurrentIndex], L"all") is 0 )
        {
            eDisplay = all;
        }
        else
        {
            while( TRUE )
            {
                LPWSTR  pwcStr = NULL;
        
                if( dwArgCount <= dwIndex )
                    break;
                if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
                    break;
    
                pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
                if( pwcTemp is NULL )
                {
                    Error = ERROR_OUT_OF_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

                pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
                if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
                {
                    if( fUser is TRUE ) //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcUser = NULL;
                        else
                        {
                            pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcUser is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcUser, pwcStr);
                        }
                        eDisplay = user;
                        fUser = TRUE;
                    }
                }
                else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
                {
                    if( fVendor is TRUE )   //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcVendor = NULL;
                        else
                        {
                            pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcVendor is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcVendor, pwcStr);
                        }
                        eDisplay = vendor;
                        fVendor = TRUE;
                    }
                }
                else
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
                    return ERROR_INVALID_PARAMETER;
                }

                if( pwcTemp )
                {
                    DhcpFreeMemory(pwcTemp);
                    pwcTemp = NULL;
                }
        
                dwIndex++;
            }

        }
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }    

    if( fUser && fVendor )
    {
        eDisplay = both;
    }

    switch( eDisplay )
    {
    case all:
        {
            Error = DhcpGetAllOptionValues(
                        g_ServerIpAddressUnicodeString,
                        0,
                        &ScopeInfo,
                        &OptionValues
                        );
            if( Error is ERROR_NO_MORE_ITEMS )
            {
                DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
                goto CommonReturn;
            }
            if( Error isnot NO_ERROR )
                goto ErrorReturn;
            
            if( OptionValues )
            {
                DisplayMessage(g_hModule, MSG_MSCOPE_OPTION_ALL, g_MScopeNameUnicodeString);
                PrintAllOptionValues(OptionValues);
                DhcpRpcFreeMemory(OptionValues);
            }

            break;
        }
    default:
        {
            dwRead = dwTotal = dwCount = 0;

            while(TRUE)
            {
                if( g_dwMajorVersion >= CLASS_ID_VERSION )
                {
                    Error = DhcpEnumOptionValuesV5(
                                g_ServerIpAddressUnicodeString,
                                0,
                                pwcUser,
                                pwcVendor,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
                else
                {
                    Error = DhcpEnumOptionValues(
                                g_ServerIpAddressUnicodeString,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
            
                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    Error = NO_ERROR;
                    break;

                }
                if( ( Error isnot NO_ERROR ) and
                    ( Error isnot ERROR_MORE_DATA ) )
                {
                    goto ErrorReturn;
                }
            
                dwCount += dwRead;

                if( OptionArray )
                {
                    DisplayMessage(g_hModule, MSG_MSCOPE_OPTION_ALL, g_MScopeNameUnicodeString);
                    PrintOptionValuesArray(OptionArray);
                    DhcpRpcFreeMemory(OptionArray);
                    OptionArray = NULL;
                }
                
                if( Error is NO_ERROR )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    break;
                }
                else
                {
                    continue;
                }

            }
            break;
        }
    }    

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( pwcUser )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_MSCOPE_SHOW_OPTIONVALUE,
                        Error);
    goto CommonReturn;
}


VOID
PrintMClientInfoShort(
    LPDHCP_MCLIENT_INFO ClientInfo
    )
{

    FILETIME ftTime = {0};
    LPWSTR   pwszTime = NULL;
    int      i = 0;

    DisplayMessage(g_hModule,
                MSG_SCOPE_CLIENT,
                GlobalClientCount++,
                IpAddressToString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );
    if ( ClientInfo->ClientLeaseEnds.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseEnds.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_DURATION_STR);
    }
    else 
    {
        ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseEnds);

        pwszTime = GetDateTimeString(ftTime,
                                     TRUE,
                                     &i);

        DisplayMessage(g_hModule,
                       MSG_SCOPE_CLIENT_DURATION_DATE_EXPIRES,
                       pwszTime ? pwszTime : L" ");

        if( pwszTime )
        {
            DhcpFreeMemory(pwszTime);
            pwszTime = NULL;
        }
                          
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\mscopemon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.c

Abstract:

    SRVR Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/
#include "precomp.h"

//
// The DHCP manager's commands are broken into 2 sets
//      - The commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        SHOW or SET.  This is not for any technical reason - only for
//        staying with the semantics used in netsh with which it will be 
//		  integrated
//      - The commands which are supported by the subcontext commands of 
//        the server. The subcontext supported by DHCP is Server.
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// NOTE: Since we have only one entry per group, currently, we really didnt
// need command groups. This is done for later extensibility.
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//


extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;

extern BOOL     g_fMScope;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;
extern PWCHAR   g_pwszServer;
extern WCHAR    g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR     g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern CHAR     g_ScopeIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR    g_ScopeIpAddressUnicodeString[MAX_IP_STRING_LEN+1];

BOOL     g_fMScope;

extern LPWSTR   g_pwszServer;
extern DHCP_IP_ADDRESS g_ServerIpAddress;



LPSTR           g_MScopeNameAnsiString = NULL;
LPWSTR          g_MScopeNameUnicodeString = NULL;
DWORD           g_MScopeID = 0;

CMD_ENTRY  g_MScopeAddCmdTable[] = {
    CREATE_CMD_ENTRY(MSCOPE_ADD_EXCLUDERANGE, HandleMScopeAddExcluderange),
    CREATE_CMD_ENTRY(MSCOPE_ADD_IPRANGE, HandleMScopeAddIprange),
};

CMD_ENTRY  g_MScopeCheckCmdTable[] = {
    CREATE_CMD_ENTRY(MSCOPE_CHECK_DATABASE, HandleMScopeCheckDatabase),
};

CMD_ENTRY  g_MScopeDeleteCmdTable[] = {
    CREATE_CMD_ENTRY(MSCOPE_DELETE_EXCLUDERANGE, HandleMScopeDeleteExcluderange),
    CREATE_CMD_ENTRY(MSCOPE_DELETE_IPRANGE, HandleMScopeDeleteIprange),
 //   CREATE_CMD_ENTRY(MSCOPE_DELETE_OPTIONVALUE, HandleMScopeDeleteOptionvalue),
};


CMD_ENTRY g_MScopeSetCmdTable[] = {
    CREATE_CMD_ENTRY(MSCOPE_SET_COMMENT, HandleMScopeSetComment),
    CREATE_CMD_ENTRY(MSCOPE_SET_EXPIRY, HandleMScopeSetExpiry),
    CREATE_CMD_ENTRY(MSCOPE_SET_LEASE, HandleMScopeSetLease),
    CREATE_CMD_ENTRY(MSCOPE_SET_MSCOPE, HandleMScopeSetMScope),
    CREATE_CMD_ENTRY(MSCOPE_SET_NAME, HandleMScopeSetName),
//     CREATE_CMD_ENTRY(MSCOPE_SET_OPTIONVALUE, HandleMScopeSetOptionvalue),        
    CREATE_CMD_ENTRY(MSCOPE_SET_STATE, HandleMScopeSetState),
    CREATE_CMD_ENTRY(MSCOPE_SET_TTL, HandleMScopeSetTTL),
};

CMD_ENTRY g_MScopeShowCmdTable[] = {
    CREATE_CMD_ENTRY(MSCOPE_SHOW_CLIENTS, HandleMScopeShowClients),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_EXCLUDERANGE, HandleMScopeShowExcluderange),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_EXPIRY, HandleMScopeShowExpiry),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_IPRANGE, HandleMScopeShowIprange),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_LEASE, HandleMScopeShowLease),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_MIBINFO, HandleMScopeShowMibinfo),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_MSCOPE, HandleMScopeShowMScope),
//    CREATE_CMD_ENTRY(MSCOPE_SHOW_OPTIONVALUE, HandleMScopeShowOptionvalue),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_STATE, HandleMScopeShowState),
    CREATE_CMD_ENTRY(MSCOPE_SHOW_TTL, HandleMScopeShowTTL),
};


CMD_GROUP_ENTRY g_MScopeCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_MScopeAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_MScopeDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_CHECK, g_MScopeCheckCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_MScopeSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_MScopeShowCmdTable),
};


CMD_ENTRY g_MScopeCmds[] = 
{
    CREATE_CMD_ENTRY(DHCP_LIST, HandleMScopeList),
    CREATE_CMD_ENTRY(DHCP_DUMP, HandleMScopeDump),
    CREATE_CMD_ENTRY(DHCP_HELP1, HandleMScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP2, HandleMScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP3, HandleMScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP4, HandleMScopeHelp),
};



ULONG g_ulMScopeNumTopCmds = sizeof(g_MScopeCmds)/sizeof(CMD_ENTRY);
ULONG g_ulMScopeNumGroups = sizeof(g_MScopeCmdGroups)/sizeof(CMD_GROUP_ENTRY);

DWORD
WINAPI
MScopeCommit(
    IN  DWORD   dwAction
)
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Srvr current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}

DWORD
WINAPI
MScopeMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD           dwError = NO_ERROR;
    DWORD           dwIndex, i, j, k;
    BOOL            bFound = FALSE;
    PFN_HANDLE_CMD  pfnHandler = NULL;
    DWORD           dwNumMatched;
    DWORD           dwCmdHelpToken = 0;
    DWORD           dwIsMScope = 0;
    PWCHAR          pwcContext = NULL;
    LPWSTR          pwszMScopeTemp = NULL;
    BOOL            fTemp = FALSE;

    if( dwArgCount < 2 )
    {
        DisplayMessage(g_hModule, EMSG_MSCOPE_NO_MSCOPENAME);
        return ERROR_INVALID_PARAMETER;
    }

    dwIndex = 1;

    if( IsValidMScope( g_ServerIpAddressUnicodeString, ppwcArguments[dwIndex] ) )
    {
        if( g_fMScope is TRUE and
            dwArgCount> 2)
        {
            pwszMScopeTemp = DhcpAllocateMemory((wcslen(g_MScopeNameUnicodeString)+1)*sizeof(WCHAR));
            if( pwszMScopeTemp is NULL )
                return ERROR_INVALID_PARAMETER;
            memset(pwszMScopeTemp, 0x00, (wcslen(g_MScopeNameUnicodeString)+1)*sizeof(WCHAR));
            wcscpy(pwszMScopeTemp, g_MScopeNameUnicodeString);
            fTemp = TRUE;
        }
        if( SetMScopeInfo(ppwcArguments[dwIndex]) is FALSE )
        {
            if( g_MScopeNameUnicodeString is NULL )
            {
                DisplayMessage(g_hModule, EMSG_MSCOPE_INVALID_MSCOPE_NAME);
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            g_fMScope = TRUE;
            pwcNewContext[wcslen(pwcNewContext) - wcslen(ppwcArguments[dwIndex]) - 1] = L'\0';
            dwIndex++;
            dwIsMScope++;
            //dwArgCount--;
            if( fTemp is FALSE )
            {
                DisplayMessage(g_hModule,
                               MSG_MSCOPE_CHANGE_CONTEXT,
                               g_MScopeNameUnicodeString);
            }
        }
    }
    
    if( g_MScopeNameUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_MSCOPE_NO_MSCOPENAME);
        dwError = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    //No more arguments. Context switch.
    if( dwIndex >= dwArgCount )
    {
        dwError = ERROR_CONTEXT_SWITCH;
        //wcscpy( pwcNewContext, L"dhcp server mscope");
        goto CleanUp;
    }

    //Is it a top level(non Group command)?

    for(i=0; i<g_ulMScopeNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_MScopeCmds[i].pwszCmdToken))
        {
            bFound = TRUE;

            pfnHandler = g_MScopeCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_MScopeCmds[i].dwCmdHlpToken;
            dwIndex++;
            break;
        }
    }


    if(bFound)
    {
        if(dwArgCount > 3 && IsHelpToken(ppwcArguments[dwIndex]))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);

            return NO_ERROR;
        }
        
        dwIndex++;

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount, 
                                dwFlags, pvData, &bFound);
        
        return dwError;
    }

    if( g_fMScope is FALSE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_NO_SCOPENAME);
        dwError = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    bFound = FALSE;


    //It is not a non Group Command. Then is it a config command for the manager?
    for(i = 0; (i < g_ulMScopeNumGroups) and !bFound; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_MScopeCmdGroups[i].pwszCmdGroupToken))
        {

            //
            // Command matched entry i, so look at the table of sub commands 
            // for this command
            //
            
            if( dwArgCount > dwIndex+1 )
            {
                for (j = 0; j < g_MScopeCmdGroups[i].ulCmdGroupSize; j++)
                {
                    if (MatchCmdLine(ppwcArguments+dwIndex,
                                      dwArgCount - 1,
                                      g_MScopeCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                      &dwNumMatched))
                    {
                        bFound = TRUE;
                
                        pfnHandler = g_MScopeCmdGroups[i].pCmdGroup[j].pfnCmdHandler;
                
                        dwCmdHelpToken = g_MScopeCmdGroups[i].pCmdGroup[j].dwCmdHlpToken;

                        dwIndex++;
                        //
                        // break out of the for(j) loop
                        //
                        break;
                    }
                }
            }

            if(!bFound)
            {
                //
                // We matched the command group token but none of the
                // sub commands
                //

                DisplayMessage(g_hModule, 
                               EMSG_SCOPE_INCOMPLETE_COMMAND);

                for (j = 0; j < g_MScopeCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                             g_MScopeCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                    
                    DisplayMessage(g_hModule,
                                   MSG_DHCP_FORMAT_LINE);
                }

                dwError = ERROR_INVALID_PARAMETER;
                goto CleanUp;
            }
            else
            {
                //
                // quit the for(i)
                //

                break;
            }
        }
    }

    if (!bFound)
    {
        //
        // Command not found. 
        //
        if( _wcsicmp(ppwcArguments[dwIndex], L"..") is 0 )
        {
            if( g_MScopeNameUnicodeString )
            {
                memset(g_MScopeNameUnicodeString, 0x00, (wcslen(g_MScopeNameUnicodeString)+1)*sizeof(WCHAR));
                DhcpFreeMemory(g_MScopeNameUnicodeString);
                g_MScopeNameUnicodeString = NULL;
            }
            if( g_MScopeNameAnsiString )
            {
                memset(g_MScopeNameAnsiString, 0x00, (strlen(g_MScopeNameAnsiString)+1)*sizeof(CHAR));
                DhcpFreeMemory(g_MScopeNameAnsiString);
                g_MScopeNameAnsiString = NULL;
            }

            g_MScopeID = 0;     
            g_fMScope = FALSE;
        }

        dwError = ERROR_CMD_NOT_FOUND;
        goto CleanUp;
    }

    //
    // See if it is a request for help.
    //

    dwNumMatched += dwIsMScope;
    if (dwNumMatched < (dwArgCount - 1) &&
        IsHelpToken(ppwcArguments[dwNumMatched + 1]))
    {
        DisplayMessage(g_hModule, dwCmdHelpToken);

        dwError = NO_ERROR;
        goto CleanUp;
    }
    
    //
    // Call the parsing routine for the command
    //

    dwError = (*pfnHandler)(pwszMachine, ppwcArguments+1, 
                            /*dwNumMatched + 1*/dwIndex, 
                            dwArgCount-1 - dwIndex, dwFlags, pvData, &bFound);
CleanUp:
    if( fTemp is TRUE )
    {
        if( pwszMScopeTemp )
        {
            fTemp = SetMScopeInfo(pwszMScopeTemp);
            memset(pwszMScopeTemp, 0x00, (wcslen(pwszMScopeTemp)+1)*sizeof(WCHAR));
            DhcpFreeMemory(pwszMScopeTemp);
            pwszMScopeTemp = NULL;
        }
        
    }
    return dwError;
}



DWORD
WINAPI
MScopeUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}


BOOL
SetMScopeInfo(
    IN  LPWSTR  pwszMScope
)
{
    DWORD   Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;
    LPSTR Tmp;
    
    if( pwszMScope is NULL )
        return FALSE;
    Error = DhcpGetMScopeInfo( g_ServerIpAddressUnicodeString,
                               pwszMScope,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
        return FALSE;
    
    g_MScopeID = MScopeInfo->MScopeId;
    
    g_MScopeNameUnicodeString = DhcpAllocateMemory((wcslen(pwszMScope)+1)*sizeof(WCHAR));
    if( g_MScopeNameUnicodeString is NULL )
        return FALSE;
    memset(g_MScopeNameUnicodeString, 0x00, (wcslen(pwszMScope)+1)*sizeof(WCHAR));
    wcscpy(g_MScopeNameUnicodeString, pwszMScope);
    
    g_MScopeNameAnsiString = DhcpAllocateMemory((wcslen(pwszMScope)+1)*sizeof(CHAR));
    if( NULL == g_MScopeNameAnsiString ) {
        DhcpFreeMemory( g_MScopeNameUnicodeString );
        g_MScopeNameUnicodeString = NULL;
        DhcpRpcFreeMemory( MScopeInfo );
        return FALSE ;
    }
    
    memset(g_MScopeNameAnsiString, 0x00, (wcslen(pwszMScope)+1)*sizeof(CHAR));
    Tmp = DhcpUnicodeToOem(pwszMScope, NULL);
    if( NULL == Tmp ) {
        DhcpFreeMemory( g_MScopeNameUnicodeString );
        DhcpFreeMemory( g_MScopeNameAnsiString );
        g_MScopeNameUnicodeString = NULL;
        g_MScopeNameAnsiString = NULL;
        DhcpRpcFreeMemory( MScopeInfo );
        return FALSE;
    }
    
    strcpy(g_MScopeNameAnsiString, Tmp);

    DhcpRpcFreeMemory(MScopeInfo);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\precomp.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/

#define MAX_DLL_NAME    48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>

#include <winsock.h>

#include <tchar.h>
#include <wchar.h>

#include <netsh.h>
#include <netshp.h>

#include <jet.h>

#include <dhcpapi.h>
#include <ipexport.h>
#include <icmpif.h>
#include <icmpapi.h>

#ifdef NT5
#include <mdhcsapi.h>
#endif NT5

#include "common.h"
#include "dhcpmgr.h"
#include "dhcpdefs.h"
#include "strdefs.h"
#include "dhcphandle.h"
#include "dhcpmon.h"
#include "srvrmon.h"
#include "srvrhndl.h"
#include "scopemon.h"
#include "scopehndl.h"
#include "mscopemon.h"
#include "mscopehndl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\common\common.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module contains miscellaneous utility routines used by the
    DHCP server service. Code is hacked from convert.c

Author:

    Shubho Bhattacharya (a-sbhatt) 11/17/98

Revision History:

   

--*/

#include <precomp.h>

PVOID
DhcpAllocateMemory(
    DWORD Size
    )
/*++

Routine Description:

    This function allocates the required size of memory by calling
    LocalAlloc.

Arguments:

    Size - size of the memory block required.

Return Value:

    Pointer to the allocated block.

--*/
{

    return calloc(1, Size);
}

#undef DhcpFreeMemory

VOID
DhcpFreeMemory(
    PVOID Memory
    )
/*++

Routine Description:

    This function frees up the memory that was allocated by
    DhcpAllocateMemory.

Arguments:

    Memory - pointer to the memory block that needs to be freed up.

Return Value:

    none.

--*/
{

    LPVOID Ptr;

    ASSERT( Memory != NULL );
    free( Memory );
}


LPWSTR
DhcpOemToUnicodeN(
    IN      LPCSTR  Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    )
{

    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength =
        cChars * sizeof( WCHAR );

    if( Unicode == NULL ) {
        UnicodeString.Buffer =
            DhcpAllocateMemory( UnicodeString.MaximumLength );
    }
    else {
        UnicodeString.Buffer = Unicode;
    }

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        if( Unicode == NULL ) {
            DhcpFreeMemory( UnicodeString.Buffer );
            UnicodeString.Buffer = NULL;
        }
        return NULL;
    }

    return UnicodeString.Buffer;
}



LPWSTR
DhcpOemToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    )
{
    OEM_STRING  AnsiString;

    RtlInitString( &AnsiString, Ansi );

    return DhcpOemToUnicodeN(
                Ansi,
                Unicode,
                (USHORT) RtlOemStringToUnicodeSize( &AnsiString )
                );
}

/*++

Routine Description:

    Convert an OEM (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Ansi - Specifies the ASCII zero terminated string to convert.

    Unicode - Specifies the pointer to the unicode buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/



LPSTR
DhcpUnicodeToOem(
    IN  LPCWSTR Unicode,
    OUT LPSTR   Ansi
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding OEM
    string.

Arguments:

    Ansi - Specifies the UNICODE zero terminated string to convert.

    Ansi - Specifies the pointer to the oem buffer. If this
        pointer is NULL then this routine allocates buffer using
        DhcpAllocateMemory and returns. The caller should freeup this
        memory after use by calling DhcpFreeMemory.

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated OEM string in
    an allocated buffer.  The buffer can be freed using DhcpFreeMemory.

--*/

{

    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );

    if( Ansi == NULL ) {
        AnsiString.Buffer = DhcpAllocateMemory( AnsiString.MaximumLength
    ); }
    else {
        AnsiString.Buffer = Ansi;
    }

    if ( AnsiString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUnicodeStringToOemString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        if( Ansi == NULL ) {
            DhcpFreeMemory( AnsiString.Buffer );
            AnsiString.Buffer = NULL;
        }

        return NULL;
    }

    return AnsiString.Buffer;
}



VOID
DhcpHexToString(
    OUT LPWSTR  Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to a Unicode
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.


Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length * 2; i+=2 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + L'0';
        } else {
            Buffer[i+1] = j + L'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + L'0';
        } else {
            Buffer[i] = j + L'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
DhcpHexToAscii(
    OUT LPSTR Buffer,
    IN  LPBYTE HexNumber,
    IN  DWORD Length
    )
/*++

Routine Description:

    This functions converts are arbitrary length hex number to an ASCII
    string.  The string is not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least Length * 2 characters in size.

    HexNumber - The hex number to convert.

    Length - The length of HexNumber, in bytes.

Return Value:

    None.

--*/
{
    DWORD i;
    int j;

    for (i = 0; i < Length; i+=1 ) {

        j = *HexNumber & 0xF;
        if ( j <= 9 ) {
            Buffer[i+1] = j + '0';
        } else {
            Buffer[i+1] = j + 'A' - 10;
        }

        j = *HexNumber >> 4;
        if ( j <= 9 ) {
            Buffer[i] = j + '0';
        } else {
            Buffer[i] = j + 'A' - 10;
        }

        HexNumber++;
    }

    return;
}



VOID
DhcpDecimalToString(
    OUT LPWSTR Buffer,
    IN  BYTE Number
    )
/*++

Routine Description:

    This functions converts a single byte decimal digit to a 3 character
    Unicode string.  The string not NUL terminated.

Arguments:

    Buffer - A pointer to a buffer for the resultant Unicode string.
        The buffer must be at least 3 characters in size.

    Number - The number to convert.

Return Value:

    None.

--*/
{
    Buffer[2] = Number % 10 + L'0';
    Number /= 10;

    Buffer[1] = Number % 10 + L'0';
    Number /= 10;

    Buffer[0] = Number + L'0';

    return;
}



DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    )
/*++

Routine Description:

    This functions converts a dotted decimal form ASCII string to a
    Host order IP address.

Arguments:

    String - The address to convert.

Return Value:

    The corresponding IP address.

--*/
{
    struct in_addr addr;

    addr.s_addr = inet_addr( String );
    return( ntohl(*(LPDWORD)&addr) );
}



LPSTR
DhcpIpAddressToDottedString(
    IN DWORD IpAddress
    )
/*++

Routine Description:

    This functions converts a Host order IP address to a dotted decimal
    form ASCII string.

Arguments:

    IpAddress - Host order IP Address.

Return Value:

    String for IP Address.

--*/
{
    DWORD NetworkOrderIpAddress;

    NetworkOrderIpAddress = htonl(IpAddress);
    return(inet_ntoa( *(struct in_addr *)&NetworkOrderIpAddress));
}



DWORD
DhcpStringToHwAddress(
    OUT LPSTR  AddressBuffer,
    IN  LPCSTR AddressString
    )
/*++

Routine Description:

    This functions converts an ASCII string to a hex number.

Arguments:

    AddressBuffer - A pointer to a buffer which will contain the hex number.

    AddressString - The string to convert.

Return Value:

    The number of bytes written to AddressBuffer.

--*/
{
    int i = 0;
    char c1, c2;
    int value1, value2;

    while ( *AddressString != 0) {

        c1 = (char)toupper(*AddressString);

        if ( isdigit(c1) ) {
            value1 = c1 - '0';
        } else if ( c1 >= 'A' && c1 <= 'F' ) {
            value1 = c1 - 'A' + 10;
        }
        else {
            break;
        }

        c2 = (char)toupper(*(AddressString+1));

        if ( isdigit(c2) ) {
            value2 = c2 - '0';
        } else if ( c2 >= 'A' && c2 <= 'F' ) {
            value2 = c2 - 'A' + 10;
        }
        else {
            break;
        }

        AddressBuffer [i] = value1 * 16 + value2;
        AddressString += 2;
        i++;
    }

    return( i );
}

#if DBG

VOID
DhcpAssertFailed(
    IN LPCSTR FailedAssertion,
    IN LPCSTR FileName,
    IN DWORD LineNumber,
    IN LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{
#ifndef DHCP_NOASSERT
    RtlAssert(
            (PVOID)FailedAssertion,
            (PVOID)FileName,
            (ULONG) LineNumber,
            (PCHAR) Message);
#endif

    DhcpPrint(( 0, "Assert @ %s \n", FailedAssertion ));
    DhcpPrint(( 0, "Assert Filename, %s \n", FileName ));
    DhcpPrint(( 0, "Line Num. = %ld.\n", LineNumber ));
    DhcpPrint(( 0, "Message is %s\n", Message ));

}

VOID
DhcpPrintRoutine(
    IN DWORD  DebugFlag,
    IN LPCSTR Format,
    ...
)

{

#define WSTRSIZE( wsz ) ( ( wcslen( wsz ) + 1 ) * sizeof( WCHAR ) )

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

#if DBG
    DhcpAssert(length <= MAX_PRINTF_LEN);
#endif //DBG


    //
    // Output to the debug terminal,
    //

    DbgPrint( "%s", OutputBuffer);
}

#endif // DBG

DWORD
CreateDumpFile(
    IN  PWCHAR  pwszName,
    OUT PHANDLE phFile
    )
{
    HANDLE  hFile;

    *phFile = NULL;

    hFile = CreateFileW(pwszName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if(hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    *phFile = hFile;

    return NO_ERROR;
}

VOID
CloseDumpFile(
    IN HANDLE  hFile
)
{
    if( hFile )
        CloseHandle(hFile);
}





DWORD
DhcpDottedStringToIpAddressW(
    IN LPCWSTR pwszString
)
{
    DWORD dwStrlen = 0;
    DWORD dwLen = 0;
    DWORD dwRes = 0;
    LPSTR pszString = NULL;
    if( pwszString == NULL )
        return dwRes;

    pszString = DhcpUnicodeToOem(pwszString, NULL);
    if( pszString )
    {
        dwRes = DhcpDottedStringToIpAddress(pszString);
    }
    
    return dwRes;
}


LPWSTR
DhcpIpAddressToDottedStringW(
    IN DWORD   IpAddress
)
{
    DWORD dwStrlen = 0;
    DWORD dwLen = 0;
    DWORD dwRes = 0;
    LPWSTR pwszString = NULL;
    LPSTR  pszString = NULL;
    
    pszString = DhcpIpAddressToDottedString(IpAddress);

    pwszString = DhcpOemToUnicode(pszString, NULL);

    return pwszString;
}

BOOL
IsIpAddress(
    IN LPCWSTR pwszAddress
)
{
    LPSTR pszAdd = NULL;
    LPSTR pszTemp = NULL;

    if( IsBadStringPtr(pwszAddress, MAX_IP_STRING_LEN+1) is TRUE )
         return FALSE;
    if( wcslen(pwszAddress) < 3 )
        return FALSE;
    
    pszAdd = DhcpUnicodeToOem(pwszAddress, NULL);

    pszTemp = strtok(pszAdd, ".");
    while(pszTemp isnot NULL )
    {
        DWORD i=0;
      
        for(i=0; i<strlen(pszTemp); i++)
        {
            if( tolower(pszTemp[i]) < L'0' or
                tolower(pszTemp[i]) > L'9' )
            return FALSE;
        }

        if( atol(pszTemp) < 0 or
            atol(pszTemp) > 255 )
        {
            return FALSE;
        }
        pszTemp = strtok(NULL, ".");
    }


    if( INADDR_NONE is inet_addr(pszAdd) )
    {
        DhcpFreeMemory(pszAdd);
        pszAdd = NULL;
        return FALSE;
    }
    else
    {
        DhcpFreeMemory(pszAdd);
        pszAdd = NULL;
        return TRUE;
    }
}

BOOL
IsValidScope(
    IN LPCWSTR pwszServer,
    IN LPCWSTR pwszAddress
)
{
    if( ( pwszServer is NULL ) or ( pwszAddress is NULL ) )
        return FALSE;

    if( IsIpAddress(pwszAddress) )
    {
        LPDHCP_SUBNET_INFO SubnetInfo = NULL;
        DHCP_IP_ADDRESS    IpAddress = StringToIpAddress(pwszAddress);
        DWORD              dwError = NO_ERROR;
        
        dwError = DhcpGetSubnetInfo((LPWSTR)pwszServer,
                                    IpAddress,
                                    &SubnetInfo);
        if(dwError is NO_ERROR )
        {
            DWORD SubnetAddress = SubnetInfo->SubnetAddress;
            DhcpRpcFreeMemory(SubnetInfo);
            return (IpAddress == SubnetAddress);
        }
        else
            return FALSE;

    }
    return FALSE;
}

BOOL
IsValidMScope(
    IN LPCWSTR   pwszServer,
    IN LPCWSTR   pwszMScope
)
{
    DWORD   Error = NO_ERROR;
    LPDHCP_MSCOPE_INFO  MScopeInfo = NULL;

    if( ( pwszMScope is NULL ) or ( pwszServer is NULL ) )
        return FALSE;
    
    Error = DhcpGetMScopeInfo( (LPWSTR)pwszServer,
                               (LPWSTR)pwszMScope,
                               &MScopeInfo);
    
    if( Error isnot NO_ERROR )
        return FALSE;

    DhcpRpcFreeMemory(MScopeInfo);
    return TRUE;
}

BOOL
IsValidServer(
    IN LPCWSTR   pwszServer
)
{

    struct  hostent * lpHostEnt = NULL;
    DWORD             dwIpAddress = 0;
    
    if( pwszServer is NULL )
        return FALSE;
    //Is it an IPAddress?
    if( IsIpAddress(pwszServer) )
    {   
        dwIpAddress = inet_addr(DhcpUnicodeToOem(pwszServer, NULL));

        lpHostEnt = gethostbyaddr((char *)&dwIpAddress, 4, AF_INET);
        
        if( lpHostEnt is NULL )
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    else if( wcslen(pwszServer) > 2 && 
             wcsncmp(pwszServer, L"\\\\", 2) is 0 )
    {
        lpHostEnt = gethostbyname(DhcpUnicodeToOem(pwszServer+2, NULL));

        if( lpHostEnt is NULL )
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    else
        return FALSE;

    return FALSE;
}

#define MAX_COMPUTER_NAME_LEN 512
BOOL
IsLocalServer(IN LPCWSTR pwszServer)
{
    BOOL    fReturn = TRUE;
    WCHAR   wcName[MAX_COMPUTER_NAME_LEN+1];
    DWORD   dwLen = MAX_COMPUTER_NAME_LEN;

    if( IsBadStringPtr(pwszServer, MAX_COMPUTER_NAME_LEN) is TRUE )
        return FALSE;

    fReturn = GetComputerNameEx(ComputerNameDnsFullyQualified,
                                wcName,
                                &dwLen);
    if( fReturn is TRUE )
    {
        if( _wcsnicmp(wcName, pwszServer, (dwLen>wcslen(pwszServer))?wcslen(pwszServer):dwLen) is 0 )
        {
            return TRUE;
        }
        else
            return FALSE;
    }
    else
    {
        return FALSE;
    }
    
}

BOOL
IsPureNumeric(IN LPCWSTR  pwszStr)
{
    DWORD   dwLen = 0,
            i;

    if( pwszStr is NULL )
        return FALSE;

    dwLen = wcslen(pwszStr);

    for(i=0; i<dwLen; i++ )
    {
        if( pwszStr[i] >= L'0' and
            pwszStr[i] <= L'9' )
        {
            continue;
        }
        else
            return FALSE;
            
    }
    return TRUE;
}

#define CHARTONUM(chr) (isalpha(chr)?(tolower(chr)-'a')+10:chr-'0')

WCHAR  StringToHex(IN LPCWSTR pwcString)
{
    LPSTR   pcInput = NULL;
    LPWSTR  pwcOut = NULL;
    int     i = 0,
            len = 0;
    UCHAR   tmp[2048] = {L'\0'};


    pcInput = DhcpUnicodeToOem(pwcString, NULL);
    
    if(pcInput is NULL )
        return (WCHAR)0x00;

    len = strlen(pcInput);

    for (i=0;i<(len-1);i+=2)
    {
        UCHAR hi=CHARTONUM(pcInput[i])*16;
        UCHAR lo=CHARTONUM(pcInput[i+1]);
        tmp[(i)/2]=hi+lo;
    }

    //
    // The last byte...
    //
    if (i<len)
    {
        tmp[(i)/2]=CHARTONUM(pcInput[i]);
        i+=2;
    }
    
    pwcOut = DhcpOemToUnicode(tmp, NULL);

    if( pwcOut is NULL )
        return (WCHAR)0x00;

    return pwcOut[0];

}

LPSTR
StringToHexString(IN LPCSTR pszInput)
{
    int     i = 0,
            len = 0;
    
    LPSTR   pcOutput = NULL;


    if(pszInput is NULL )
    {
        return NULL;
    }

   

    len = strlen(pszInput);

    pcOutput = DhcpAllocateMemory(len);

    if( pcOutput is NULL )
    {
        return NULL;
    }

    for (i=0;i<(len-1);i+=2)
    {
        UCHAR hi=CHARTONUM(pszInput[i])*16;
        UCHAR lo=CHARTONUM(pszInput[i+1]);
        pcOutput[(i)/2]=hi+lo;
    }

    //
    // The last byte...
    //
    if (i<len)
    {
        pcOutput[(i)/2]=CHARTONUM(pszInput[i]);
        i+=2;
    }

    return pcOutput;

}

BOOL
IsPureHex(
    IN LPCWSTR pwszString
)
{
    DWORD dw = 0,
          i = 0;

    BOOL  fResult = TRUE;

    if( pwszString is NULL )
        return FALSE;

    if( wcslen(pwszString) > 2 or
        wcslen(pwszString) is 0 )
        return FALSE;

    dw = wcslen(pwszString);

    for( i=0; i<dw; i++ )
    {
        WCHAR wc = pwszString[i];
        
        if( iswxdigit(wc) )
        {
            continue;
        }
        else
        {
            fResult = FALSE;
            break;
        }            
    }
    return fResult;

}

DATE_TIME
DhcpCalculateTime(
    IN DWORD RelativeTime
    )
/*++

Routine Description:

    The function calculates the absolute time of a time RelativeTime
    seconds from now.

Arguments:

    RelativeTime - Relative time, in seconds.

Return Value:

    The time in RelativeTime seconds from the current system time.

--*/
{
    SYSTEMTIME systemTime;
    ULONGLONG absoluteTime;

    if( RelativeTime == INFINIT_LEASE ) {
        ((DATE_TIME *)&absoluteTime)->dwLowDateTime =
            DHCP_DATE_TIME_INFINIT_LOW;
        ((DATE_TIME *)&absoluteTime)->dwHighDateTime =
            DHCP_DATE_TIME_INFINIT_HIGH;
    }
    else {

        GetSystemTime( &systemTime );
        SystemTimeToFileTime(
            &systemTime,
            (FILETIME *)&absoluteTime );

        absoluteTime = absoluteTime + RelativeTime * (ULONGLONG)10000000; }

    return( *(DATE_TIME *)&absoluteTime );
}

PBYTE
GetLangTagA(
    )
{
    char b1[8], b2[8];
    static char buff[80];

    GetLocaleInfoA(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO639LANGNAME, b1, sizeof(b1));

    GetLocaleInfoA(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO3166CTRYNAME, b2, sizeof(b2));

    if (_stricmp(b1, b2))
        sprintf(buff, "%s-%s", b1, b2);
    else
        strcpy(buff, b1);

    return buff;
}


LPWSTR
MakeDayTimeString(
               IN DWORD dwTime
)
{
    LPWSTR  pwszTime = NULL;
    WCHAR   wcDay[4] = {L'\0'},
            wcHr[3] = {L'\0'},
            wcMt[3] = {L'\0'};
    DWORD   dwDay = 0,
            dwHr = 0,
            dwMt = 0,
            dw = 0;

    pwszTime = malloc(10*sizeof(WCHAR));
    

    if( pwszTime )
    {
        for( dw=0; dw < 10; dw++ )
            pwszTime[dw] = L'0';


        pwszTime[3] = L':';
        pwszTime[6] = L':';
        pwszTime[9] = L'\0';

        dwDay = dwTime/(24*60*60);
        dwTime = dwTime - dwDay*24*60*60;

        dwHr = dwTime/(60*60);
        dwTime = dwTime - dwHr*60*60;

        dwMt = dwTime/60;
        dwTime = dwTime - dwMt*60;

        _itow(dwDay, wcDay,10);
        _itow(dwHr, wcHr, 10);
        _itow(dwMt, wcMt, 10);

        if( dwDay isnot 0 )
        {
            wcsncpy(pwszTime+3-wcslen(wcDay), wcDay, wcslen(wcDay));
        }

        if( dwHr isnot 0 )
        {
            wcsncpy(pwszTime+6-wcslen(wcHr), wcHr, wcslen(wcHr));
        }

        if( dwMt isnot 0 )
        {
            wcsncpy(pwszTime+9-wcslen(wcMt), wcMt, wcslen(wcMt));
        }
    }
    return pwszTime;
}

DWORD
GetDateTimeInfo(IN     LCTYPE          lcType,
                IN     LPSYSTEMTIME    lpSystemTime,
                OUT    LPWSTR          pwszBuffer,
                IN OUT DWORD           *pdwBufferLen)
{
    DWORD   dwError = NO_ERROR;
    BOOL    fQueryLen = FALSE;
    int     cchFormat = 0,
            cchData = 0;
    
    PVOID   pfnPtr = NULL;
    DWORD   dwBuff = 0,
            dwInputBuff = 0;


    LPWSTR  pwszFormat = NULL,
            pwszData = NULL;


    if( pdwBufferLen is NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwInputBuff = *pdwBufferLen;
    *pdwBufferLen = 0;

    if( pwszBuffer is NULL or
        dwInputBuff is 0 )
    {
        fQueryLen = TRUE;
    }

    cchFormat = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT,
                            lcType,
                            NULL,
                            0);

    if( cchFormat is 0 )
    {
        dwError = GetLastError();
        goto RETURN;
    }

    pwszFormat = DhcpAllocateMemory(cchFormat*sizeof(WCHAR));
    if( pwszFormat is NULL )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto RETURN;
    }

    cchFormat = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT,
                              lcType,
                              pwszFormat,
                              cchFormat);

    if( cchFormat is 0 )
    {
        dwError = GetLastError();
        goto RETURN;
    }
    
    if( lcType isnot LOCALE_STIMEFORMAT )
    {
        cchData = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                0,
                                lpSystemTime,
                                pwszFormat,
                                NULL,
                                0);

        if( cchData is 0 )
        {
            dwError = GetLastError();
            goto RETURN;
        }
    
        if( fQueryLen is FALSE )
        {    
            if( cchData > (int)dwInputBuff )
            {
                dwError = ERROR_INSUFFICIENT_BUFFER;
                goto RETURN;
            }

            cchData = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                    0,
                                    lpSystemTime,
                                    pwszFormat,
                                    pwszBuffer,
                                    (int)dwInputBuff);

            if( cchData is 0 )
            {
                dwError = GetLastError();
                goto RETURN;
            }   
        }
    }
    else
    {
        cchData = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                0,
                                lpSystemTime,
                                pwszFormat,
                                NULL,
                                0);

        if( cchData is 0 )
        {
            dwError = GetLastError();
            goto RETURN;
        }
    
        if( fQueryLen is FALSE )
        {    
            if( cchData > (int)dwInputBuff )
            {
                dwError = ERROR_INSUFFICIENT_BUFFER;
                goto RETURN;
            }

            cchData = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                    0,
                                    lpSystemTime,
                                    pwszFormat,
                                    pwszBuffer,
                                    (int)dwInputBuff);

            if( cchData is 0 )
            {
                dwError = GetLastError();
                goto RETURN;
            }   
        }
    }

    dwBuff += cchData;
    *pdwBufferLen = dwBuff;

RETURN:
    if( pwszFormat )
    {
        DhcpFreeMemory(pwszFormat);
        pwszFormat = NULL;
    }
    return dwError;

}

DWORD
FormatDateTimeString( IN  FILETIME ftTime,
                      IN  BOOL    fShort,
                      OUT LPWSTR  pwszBuffer,
                      OUT DWORD  *pdwBuffLen)
{
    BOOL        fQueryLen = FALSE;
    DWORD       dwError = NO_ERROR,
                dwBufferLen = 0;
    DWORD       dwBuff = 0,
                dwInputBuff = 0;
    FILETIME    ftLocalTime = {0};
    SYSTEMTIME  stTime = {0};

    if( pdwBuffLen is NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    dwInputBuff = *pdwBuffLen;

    if( pwszBuffer is NULL or
        dwInputBuff is 0 )
    {
        fQueryLen = TRUE;
    }
    

    if( !FileTimeToLocalFileTime(&ftTime, &ftLocalTime) )
    {
        dwError = GetLastError();
        goto RETURN;
    }

    if( !FileTimeToSystemTime(&ftLocalTime, &stTime) )
    {
        dwError = GetLastError();
        goto RETURN;
    }
    
    if( fQueryLen is TRUE )
    {
        dwError = GetDateTimeInfo(fShort ? LOCALE_SSHORTDATE : LOCALE_SLONGDATE,
                                  &stTime,
                                  NULL,
                                  &dwBuff);

        if( dwError isnot NO_ERROR )
            goto RETURN;

    }
    else
    {
        dwBuff = dwInputBuff;
        dwError = GetDateTimeInfo(fShort ? LOCALE_SSHORTDATE : LOCALE_SLONGDATE,
                                  &stTime,
                                  pwszBuffer,
                                  &dwBuff);
    }

    dwBufferLen += dwBuff;

    //Increment to add a space between date and time
    dwBufferLen ++;

    if( fQueryLen is TRUE )
    {
        dwBuff = 0;
        dwError = GetDateTimeInfo(LOCALE_STIMEFORMAT,
                                  &stTime,
                                  NULL,
                                  &dwBuff);
        if( dwError isnot NO_ERROR )
            goto RETURN;
    }
    else
    {
        if( dwBufferLen > dwInputBuff )
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
            goto RETURN;
        }

        wcscat( pwszBuffer, L" ");
        dwBuff = dwInputBuff - dwBufferLen;
        dwError = GetDateTimeInfo(LOCALE_STIMEFORMAT,
                                  &stTime,
                                  pwszBuffer + dwBufferLen - 1,
                                  &dwBuff);
        if( dwError isnot NO_ERROR )
            goto RETURN;
    }

    dwBufferLen += dwBuff;
    
    *pdwBuffLen = dwBufferLen;
    
RETURN:
    return dwError;
}

LPWSTR
GetDateTimeString(IN FILETIME  ftTime,
                  IN BOOL      fShort,
                  OUT int     *piType
                  )
{

    DWORD       Status = NO_ERROR, i=0,
                dwTime = 0;

    LPWSTR      pwszTime = NULL;

    int         iType = 0;
    DWORD       dwLen = 0;

    Status = FormatDateTimeString(ftTime,
                                  fShort,
                                  NULL,
                                  &dwTime);

    if( Status is NO_ERROR )
    {
        dwLen = ( 23 > dwTime ) ? 23 : dwTime;
        pwszTime = DhcpAllocateMemory((dwLen+1)*sizeof(WCHAR));

        if( pwszTime is NULL )
        {
            iType = 1;
        }
        else
        {
            dwTime++;
            Status = FormatDateTimeString(ftTime,
                                          fShort,
                                          pwszTime,
                                          &dwTime);

            if( Status is NO_ERROR )
            {
                iType = 0;
            }
            else
            {
                DhcpFreeMemory(pwszTime);
                pwszTime = NULL;
                iType = 1;
            }
        }
    }
    else
    {
        pwszTime = NULL;
        iType = 1;
    }

    if( pwszTime )
    {
        for( i=wcslen(pwszTime); i<dwLen; i++ )
                pwszTime[i] = L' ';
    }

    *piType = iType;
    
    return pwszTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\dhcpmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.c

Abstract:

    DHCP Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/
#include "precomp.h"

//
// The DHCP manager's commands are broken into 2 sets
//      - The commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        SHOW or SET.  This is not for any technical reason - only for
//        staying with the semantics used in netsh with which it will be 
//		  integrated
//      - The commands which are supported by the subcontext commands of 
//        the server. The subcontext supported by DHCP is Server.
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// NOTE: Since we have only one entry per group, currently, we really didnt
// need command groups. This is done for later extensibility.
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//


HANDLE   g_hModule = NULL;
HANDLE   g_hDhcpsapiModule = NULL;
BOOL     g_bCommit = TRUE;
BOOL     g_hConnect = FALSE;
BOOL     g_bDSInit = FALSE;
BOOL     g_bDSTried = FALSE;
DWORD    g_dwNumTableEntries = 0;
PWCHAR   g_pwszRouter = NULL;

//{0f7412f0-80fc-11d2-be57-00c04fc3357a}
static const GUID g_MyGuid = 
{ 0x0f7412f0, 0x80fc, 0x11d2, { 0xbe, 0x57, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

static const GUID g_NetshGuid = NETSH_ROOT_GUID;

#define DHCP_HELPER_VERSION 1

//


ULONG   g_ulInitCount = 0;

DHCPMON_SUBCONTEXT_TABLE_ENTRY  g_DhcpSubContextTable[] =
{
    {L"Server", HLP_DHCP_CONTEXT_SERVER, HLP_DHCP_CONTEXT_SERVER_EX, SrvrMonitor},
};


CMD_ENTRY  g_DhcpAddCmdTable[] = {
    CREATE_CMD_ENTRY(DHCP_ADD_SERVER, HandleDhcpAddServer),
//    CREATE_CMD_ENTRY(DHCP_ADD_HELPER, HandleDhcpAddHelper)
};

CMD_ENTRY  g_DhcpDeleteCmdTable[] = {
    CREATE_CMD_ENTRY(DHCP_DELETE_SERVER, HandleDhcpDeleteServer),
//    CREATE_CMD_ENTRY(DHCP_DELETE_HELPER, HandleDhcpDeleteHelper)
};

CMD_ENTRY g_DhcpShowCmdTable[] = {
    CREATE_CMD_ENTRY(DHCP_SHOW_SERVER, HandleDhcpShowServer),
//    CREATE_CMD_ENTRY(DHCP_SHOW_HELPER, HandleDhcpShowHelper)
};


CMD_GROUP_ENTRY g_DhcpCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_DhcpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_DhcpDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_DhcpShowCmdTable),
};


CMD_ENTRY g_DhcpCmds[] = 
{
    CREATE_CMD_ENTRY(DHCP_LIST, HandleDhcpList),
    CREATE_CMD_ENTRY(DHCP_DUMP, HandleDhcpDump),
    CREATE_CMD_ENTRY(DHCP_HELP1, HandleDhcpHelp),
    CREATE_CMD_ENTRY(DHCP_HELP2, HandleDhcpHelp),
    CREATE_CMD_ENTRY(DHCP_HELP3, HandleDhcpHelp),
    CREATE_CMD_ENTRY(DHCP_HELP4, HandleDhcpHelp),
};



ULONG g_ulNumTopCmds = sizeof(g_DhcpCmds)/sizeof(CMD_ENTRY);
ULONG g_ulNumGroups = sizeof(g_DhcpCmdGroups)/sizeof(CMD_GROUP_ENTRY);
ULONG g_ulNumSubContext = sizeof(g_DhcpSubContextTable)/sizeof(DHCPMON_SUBCONTEXT_TABLE_ENTRY);

DWORD
WINAPI
DhcpCommit(
    IN  DWORD   dwAction
)
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Dhcp current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}

BOOL 
WINAPI
DhcpDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    )
{
    WORD wVersion = MAKEWORD(1,1); //Winsock version 1.1 will do?
    WSADATA wsaData;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            if(WSAStartup(wVersion,&wsaData) isnot NO_ERROR)
            {
                return FALSE;
            }


            break;
        }
        case DLL_PROCESS_DETACH:
        {
            
            if( g_ServerIpAddressUnicodeString )
            {
                memset(g_ServerIpAddressUnicodeString, 0x00, 
                      (wcslen(g_ServerIpAddressUnicodeString)+1)*sizeof(WCHAR));
            }

            
            if( g_ServerIpAddressAnsiString )
            {
                memset(g_ServerIpAddressAnsiString, 0x00, 
                      (strlen(g_ServerIpAddressAnsiString)+1)*sizeof(CHAR));
            }

            if( g_pwszServer )
            {
                memset(g_pwszServer, 0x00, (wcslen(g_pwszServer)+1)*sizeof(WCHAR));
                DhcpFreeMemory(g_pwszServer);
                g_pwszServer = NULL;
            }

            if( g_ScopeIpAddressUnicodeString )
            {
                memset(g_ScopeIpAddressUnicodeString, 0x00, 
                      (wcslen(g_ScopeIpAddressUnicodeString)+1)*sizeof(WCHAR));
            }

            if( g_ScopeIpAddressAnsiString )
            {
                memset(g_ScopeIpAddressAnsiString, 0x00, 
                      (strlen(g_ScopeIpAddressAnsiString)+1)*sizeof(CHAR));
            }

            if( g_MScopeNameUnicodeString )
            {
                memset(g_MScopeNameUnicodeString, 0x00, 
                       (wcslen(g_MScopeNameUnicodeString)+1)*sizeof(WCHAR));
                DhcpFreeMemory(g_MScopeNameUnicodeString);
                g_MScopeNameUnicodeString = NULL;
            }

            if( g_MScopeNameUnicodeString )
            {
                memset(g_MScopeNameAnsiString, 0x00, 
                       (strlen(g_MScopeNameAnsiString)+1)*sizeof(CHAR));
                DhcpFreeMemory(g_MScopeNameAnsiString);
                g_MScopeNameAnsiString = NULL;
            }
            if(g_hDhcpsapiModule)
            {
                FreeLibrary(g_hDhcpsapiModule);
            }
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}


DWORD
WINAPI
DhcpStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
    PNS_PRIV_CONTEXT_ATTRIBUTES  pNsPrivContextAttributes;

    pNsPrivContextAttributes = HeapAlloc(GetProcessHeap(), 0, sizeof(PNS_PRIV_CONTEXT_ATTRIBUTES));
    if (!pNsPrivContextAttributes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    ZeroMemory(pNsPrivContextAttributes, sizeof(PNS_PRIV_CONTEXT_ATTRIBUTES));

    attMyAttributes.pwszContext = L"dhcp";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.pfnCommitFn = DhcpCommit;
    attMyAttributes.pfnDumpFn   = DhcpDump;

    pNsPrivContextAttributes->pfnEntryFn    = DhcpMonitor;
    attMyAttributes.pReserved     = pNsPrivContextAttributes;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
    DWORD   dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }


    g_bCommit = TRUE;

    // Register helpers
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );

    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = DHCP_HELPER_VERSION;
    attMyAttributes.pfnStart           = DhcpStartHelper;
    attMyAttributes.pfnStop            = NULL;
 
    if( NULL is (g_hDhcpsapiModule = LoadLibrary(TEXT("Dhcpsapi.dll")) ) )
    {
        return GetLastError();
    }

    RegisterHelper( &g_NetshGuid, &attMyAttributes );

    return NO_ERROR;
}

LPCWSTR g_DhcpGlobalServerName = NULL;

DWORD
WINAPI
DhcpMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD  dwError = NO_ERROR;
    DWORD  dwIndex, i, j;
    BOOL   bFound = FALSE;
    PFN_HANDLE_CMD    pfnHandler = NULL;
    DWORD  dwNumMatched;
    DWORD  dwCmdHelpToken = 0;
    DWORD  ThreadOptions = 0;    
    PNS_CONTEXT_ENTRY_FN     pfnHelperEntryPt;
    PNS_CONTEXT_DUMP_FN      pfnHelperDumpPt;

    g_DhcpGlobalServerName = pwszMachine;
    
    //if dwArgCount is 1 then it must be a context switch fn. or looking for help
    if( FALSE is g_bDSInit )
    {
        ThreadOptions |= DHCP_FLAGS_DONT_DO_RPC;
        ThreadOptions |= DHCP_FLAGS_DONT_ACCESS_DS;
        DhcpSetThreadOptions(ThreadOptions, 0);
        g_bDSInit = TRUE;
        g_bDSTried = TRUE;
    }

    if(dwArgCount is 1)
    {
        return ERROR_CONTEXT_SWITCH;
    }

    dwIndex = 1;

    //Is it a top level(non Group command)?
    for(i=0; i<g_ulNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_DhcpCmds[i].pwszCmdToken))
        {
            bFound = TRUE;
            dwIndex++;
            //dwArgCount--;
            pfnHandler = g_DhcpCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_DhcpCmds[i].dwCmdHlpToken;

            break;
        }
    }


    if(bFound)
    {
        if(dwArgCount > dwIndex && IsHelpToken(ppwcArguments[dwIndex]))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);

            return NO_ERROR;
        }

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount, dwFlags, pvData, &bFound);

        return dwError;
    }

    bFound = FALSE;


    //Is it meant for subcontext?
    for(i = 0; i<g_ulNumSubContext; i++)
    {
        //if( _wcsicmp(ppwcArguments[dwIndex], g_DhcpSubContextTable[i].pwszContext) is 0 )
        if( MatchToken(ppwcArguments[dwIndex], g_DhcpSubContextTable[i].pwszContext) )
        {
            bFound = TRUE;
            dwIndex++;
            dwArgCount--;           
            pfnHelperEntryPt = g_DhcpSubContextTable[i].pfnEntryFn;
            DEBUG("Meant for subcontext under it");
            break;
        }
    }

    if( bFound )    //Subcontext
    {
        dwError = (pfnHelperEntryPt)(pwszMachine,
                                     ppwcArguments+1,
                                     dwArgCount,
                                     dwFlags,
                                     pvData,
                                     pwcNewContext);
        return dwError;
    }

    bFound = FALSE;

    //It is not a non Group Command. Not for any helper or subcontext.
    //Then is it a config command for the manager?
    for(i = 0; (i < g_ulNumGroups) and !bFound; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_DhcpCmdGroups[i].pwszCmdGroupToken))
        {
            // See if it's a request for help

            if (dwArgCount > 2 && IsHelpToken(ppwcArguments[2]))
            {
                for (j = 0; j < g_DhcpCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                           g_DhcpCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
					DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);					
                }
				
                return NO_ERROR;
            }

            //
            // Command matched entry i, so look at the table of sub commands 
            // for this command
            //

            for (j = 0; j < g_DhcpCmdGroups[i].ulCmdGroupSize; j++)
            {
                if (MatchCmdLine(ppwcArguments + 1,
                                  dwArgCount - 1,
                                  g_DhcpCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                  &dwNumMatched))
                {
                    bFound = TRUE;
                
                    pfnHandler = g_DhcpCmdGroups[i].pCmdGroup[j].pfnCmdHandler;
                
                    dwCmdHelpToken = g_DhcpCmdGroups[i].pCmdGroup[j].dwCmdHlpToken;

                    //
                    // break out of the for(j) loop
                    //

                    break;
                }
            }

            if(!bFound)
            {
                //
                // We matched the command group token but none of the
                // sub commands
                //

                DisplayMessage(g_hModule, 
                               EMSG_DHCP_INCOMPLETE_COMMAND);

                for (j = 0; j < g_DhcpCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                             g_DhcpCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                    
                    DisplayMessage(g_hModule,
                                   MSG_DHCP_FORMAT_LINE);
                }

                return ERROR_INVALID_PARAMETER;
            }
            else
            {
                //
                // quit the for(i)
                //

                break;
            }
        }
    }

    if (!bFound)
    {
        //
        // Command not found. 
        //
        if( g_bDSInit )
        {
            g_bDSInit = FALSE;
        }
        return ERROR_CMD_NOT_FOUND;
    }

    //
    // See if it is a request for help.
    //

    if (dwNumMatched < (dwArgCount - 1) &&
        IsHelpToken(ppwcArguments[dwNumMatched + 1]))
    {
        DisplayMessage(g_hModule, dwCmdHelpToken);

        return NO_ERROR;
    }
    
    //
    // Call the parsing routine for the command
    //

    dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwNumMatched+1, dwArgCount, dwFlags, pvData, &bFound);
    
    return dwError;
}



DWORD
WINAPI
DhcpUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}

BOOL
IsHelpToken(
    PWCHAR  pwszToken
    )
{
    if(MatchToken(pwszToken, CMD_DHCP_HELP1))
        return TRUE;
    
    if(MatchToken(pwszToken, CMD_DHCP_HELP2))
        return TRUE;

    if(MatchToken(pwszToken, CMD_DHCP_HELP3))
        return TRUE;

    if(MatchToken(pwszToken, CMD_DHCP_HELP4))
        return TRUE;

    return FALSE;
}


VOID
OEMPrintf(
    IN  PWCHAR  pwszUnicode
    )
{
    PCHAR achOem;
    DWORD dwLen;

    dwLen = WideCharToMultiByte( CP_OEMCP,
                         0,
                         pwszUnicode,
                         -1,
                         NULL,
                         0,
                         NULL,
                         NULL );

    achOem = LocalAlloc(LMEM_FIXED, dwLen);
    if (achOem)
    {
        WideCharToMultiByte( CP_OEMCP,
                             0,
                             pwszUnicode,
                             -1,
                             achOem,
                             dwLen,
                             NULL,
                             NULL );

        fprintf( stdout, "%hs", achOem );

        LocalFree(achOem);
    }
}

DWORD
DisplayErrorMessage(
    HANDLE  hModule,
    DWORD   dwMsgID,
    DWORD   dwErrID,
    ...
)
{
    LPWSTR  pwszErrorMsg = NULL;
    WCHAR   rgwcInput[MAX_MSG_LENGTH + 1] = {L'\0'};
    WCHAR   ErrStringU[MAX_MSG_LENGTH + 1] = {L'\0'};
    DWORD   dwMsgLen = 0;
    DWORD   dwMsg = 0;
    va_list arglist;
    
    va_start(arglist, dwErrID);

    switch(dwErrID)
    {
    case ERROR_INVALID_PARAMETER:
        {
            DisplayMessage(hModule, dwMsgID, arglist);
            DisplayMessage(hModule, EMSG_DHCP_INVALID_PARAMETER);          
            return dwErrID;
        }
    case ERROR_NOT_ENOUGH_MEMORY:
    case ERROR_OUT_OF_MEMORY:
        {
            DisplayMessage(hModule, dwMsgID, arglist);
            DisplayMessage(hModule, EMSG_DHCP_OUT_OF_MEMORY);
            return dwErrID;
            
        }
    case ERROR_NO_MORE_ITEMS:
        {
            DisplayMessage(hModule, dwMsgID, arglist);
            DisplayMessage(hModule, EMSG_DHCP_NO_MORE_ITEMS);
            return dwErrID;
        }
    case ERROR_MORE_DATA:
        {
            DisplayMessage(hModule, dwMsgID, arglist);
            DisplayMessage(hModule, EMSG_DHCP_MORE_DATA);
            return dwErrID;
        }
    case ERROR_INVALID_COMPUTER_NAME:
        {
            DisplayMessage(hModule, dwMsgID, arglist);
            DisplayMessage(hModule, EMSG_SRVR_INVALID_COMPUTER_NAME);
            return dwErrID;
        }
    default:
        break;
    }

    //check to see if DHCPSAPI.DLL is loaded. If not, load the dll

    if( g_hDhcpsapiModule is NULL )
    {
        g_hDhcpsapiModule = LoadLibrary(TEXT("Dhcpsapi.dll"));
     
        if( g_hDhcpsapiModule is NULL )
        {
            DisplayMessage(hModule, MSG_DLL_LOAD_FAILED, TEXT("Dhcpsapi.dll"));
            goto SYSTEM;
        }
    }

    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |FORMAT_MESSAGE_FROM_HMODULE,
                              g_hDhcpsapiModule,
                              dwErrID,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),         // Default country ID.
                              (LPWSTR)&pwszErrorMsg,
                              1,
                              NULL);
    
    if( dwMsgLen > 0 )
    {
        goto DISPLAY;
    }

SYSTEM: //Is is a system error 

    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwErrID,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              (LPWSTR)&pwszErrorMsg,
                              0,
                              NULL);

    if( dwMsgLen > 0 )
        goto DISPLAY;

    //Otherwise show the error number
    //pwszErrorMsg = _itow((int)dwErrID, rgwcInput, 10);
    DisplayMessage(hModule, dwMsgID, arglist);
    wsprintf( ErrStringU,  L"Error = 0x%lx\n", dwErrID );
    OEMPrintf(ErrStringU);

    return dwMsgLen = wcslen(ErrStringU);

DISPLAY:
    DisplayMessage(hModule, dwMsgID, arglist);
    OEMPrintf(pwszErrorMsg);

    if ( pwszErrorMsg) 
    { 
        LocalFree( pwszErrorMsg ); 
    }

    return dwMsgLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\scopehndl.c ===
#include "precomp.h"


extern ULONG g_ulScopeNumTopCmds;
extern ULONG g_ulScopeNumGroups;

extern CMD_GROUP_ENTRY      g_ScopeCmdGroups[];
extern CMD_ENTRY            g_ScopeCmds[];

DWORD  GlobalClientCount = 0;
BOOL    GlobalNoRPC = FALSE;
BOOL    GlobalVerbose = TRUE;

LPWSTR
GetDynBootpClassName();

DWORD
HandleScopeList(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulScopeNumTopCmds-2; i++)
    {
        DisplayMessage(g_hModule, g_ScopeCmds[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    for(i = 0; i < g_ulScopeNumGroups; i++)
    {
        for(j = 0; j < g_ScopeCmdGroups[i].ulCmdGroupSize; j++)
        {
            DisplayMessage(g_hModule, g_ScopeCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);

            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        }
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    return NO_ERROR;
}

DWORD
HandleScopeHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulScopeNumTopCmds-2; i++)
    {
        if(g_ScopeCmds[i].dwCmdHlpToken != MSG_DHCP_NULL)
        {
            DisplayMessage(g_hModule, g_ScopeCmds[i].dwShortCmdHelpToken);
        }
    }

    for(i = 0; i < g_ulScopeNumGroups; i++)
    {
        DisplayMessage(g_hModule, g_ScopeCmdGroups[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}

DWORD
HandleScopeDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD       Error = NO_ERROR;

    Error = DhcpDumpScope(g_ServerIpAddressUnicodeString,
                          g_dwMajorVersion,
                          g_dwMinorVersion,
                          g_ScopeIpAddress);

    return Error;
}

DWORD
HandleScopeContexts(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}

DWORD
HandleScopeAddIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{ 
    DWORD                    Error = NO_ERROR;
    ULONG                    Resume;
    DHCP_IP_RANGE            IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_SUBNET_ELEMENT_TYPE ElementType;
    LPDHCP_SUBNET_INFO       SubnetInfo = NULL;
    DWORD                    DhcpMask = 0;
    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //
    
    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA));
    memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_ADD_IPRANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    //If either of the addresses is invalid, return
    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    //Make sure the start address is < EndAddress
    if( IpRange.StartAddress > IpRange.EndAddress )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPRANGE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Make sure the address range is not in the Multicast area
    if( ( IpRange.StartAddress >= MSCOPE_START_RANGE and
          IpRange.StartAddress <= MSCOPE_END_RANGE ) or
        ( IpRange.EndAddress >= MSCOPE_START_RANGE and
          IpRange.EndAddress <= MSCOPE_END_RANGE ) )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPRANGE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    Error = DhcpGetSubnetInfo(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    &SubnetInfo);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DhcpMask = (DWORD)SubnetInfo->SubnetMask;
    
    //Make sure starting Address isnot subnet address
    if( ( IpRange.StartAddress & ~DhcpMask ) is (DWORD) 0 )
    {
        DisplayMessage(g_hModule, 
                       EMSG_SCOPE_INVALID_STARTADDRESS, 
                       IpAddressToString(IpRange.StartAddress));
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //Make sure the subnet broadcast address isnot the ending address
    if( ( IpRange.EndAddress & ~DhcpMask ) is ~DhcpMask )
    {
        DisplayMessage(g_hModule, 
                       EMSG_SCOPE_INVALID_ENDADDRESS, 
                       IpAddressToString(IpRange.EndAddress));
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;

    }

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    if( g_dwMajorVersion >= CLASS_ID_VERSION ) {
        if( dwArgCount > 2 ) 
        {
            DHCP_BOOTP_IP_RANGE ThisRange = {IpRange.StartAddress, IpRange.EndAddress, 0, ~0};
            
            Element.Element.IpRange = (PVOID)&ThisRange;

            if( g_dwMajorVersion >= CLASS_ID_VERSION ) 
            {
                if( dwArgCount > 3 ) 
                {
                    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+3]) )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    ThisRange.MaxBootpAllowed = STRTOUL( ppwcArguments[dwCurrentIndex+3], NULL, 10 ) ;
                }
                
                if( 0 is STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("DHCP")) ) 
                {
                    Element.ElementType = DhcpIpRangesDhcpOnly;
                } 
                else if( 0 is STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("BOOTP")) ) 
                {
                    Element.ElementType = DhcpIpRangesBootpOnly;
                } 
                else if( ( 0 is STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("DHCPBOOTP") ) ) or 
                         ( 0 is STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("BOTH")) ) )
                {
                    Element.ElementType = DhcpIpRangesDhcpBootp;
                } 
                else 
                {
                    DisplayMessage(g_hModule, HLP_SCOPE_ADD_IPRANGE_EX);
                    goto CommonReturn;
                }
            
                Error = DhcpAddSubnetElementV5(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                (PVOID)&Element
                    );
                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
                
            }
        }
        else
        {
            Error = DhcpAddSubnetElementV5(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                (PVOID)&Element);
            
            if( Error isnot NO_ERROR )
                goto ErrorReturn;
        }
    } else {
        
        Error = DhcpAddSubnetElement(
            g_ServerIpAddressUnicodeString,
            g_ScopeIpAddress,
            &Element );
        
        if( Error isnot NO_ERROR )
            goto ErrorReturn;
    }

    //Now set the default lease duration
    {
        DHCP_OPTION_SCOPE_INFO   ScopeInfo = {0};
        DHCP_OPTION_DATA_ELEMENT OptionData = {0};
        DHCP_OPTION_DATA         Option = {0};
        DHCP_OPTION_ID           OptionId = 51; //Lease time
        LPWSTR                   pwszUser = NULL;

        ScopeInfo.ScopeType = DhcpSubnetOptions;
        ScopeInfo.ScopeInfo.SubnetScopeInfo =  g_ScopeIpAddress;

        switch(Element.ElementType)
        {
        case DhcpIpRangesBootpOnly:
            {
                OptionData.OptionType = DhcpDWordOption;
                OptionData.Element.DWordOption = DEFAULT_BOOTP_LEASE;
                pwszUser = GetDynBootpClassName();
                break;
            }
        default:
            {
                OptionData.OptionType = DhcpDWordOption;
                OptionData.Element.DWordOption = DEFAULT_DHCP_LEASE;
                break;
            }
        }

        Option.NumElements = 1;
        Option.Elements = &OptionData;

        if( g_dwMajorVersion >= CLASS_ID_VERSION ) {
            Error = DhcpSetOptionValueV5(
                g_ServerIpAddressUnicodeString,
                0,
                OptionId,
                pwszUser,
                NULL,
                &ScopeInfo,
                &Option);
        } else {
            Error = DhcpSetOptionValue(
                g_ServerIpAddressUnicodeString,
                OptionId,
                &ScopeInfo,
                &Option);
        }

        if( Error isnot NO_ERROR )
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SCOPE_DEFAULT_LEASE_TIME,
                                Error);
            goto CommonReturn;
        }
    }


    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

CommonReturn:
       if( SubnetInfo )
       {
           DhcpRpcFreeMemory(SubnetInfo);
           SubnetInfo = NULL;
       }
       return( Error );
ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_ADD_IPRANGE,
                        Error);

    goto CommonReturn; 

}

DWORD
HandleScopeAddExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{

    DWORD              Error = NO_ERROR;
    DHCP_IP_RANGE            IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_ADD_EXCLUDERANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE or
        IpRange.StartAddress > IpRange.EndAddress )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IpRange.StartAddress > IpRange.EndAddress )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPRANGE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    

    //Now check to see if it is really an exclusion range for a valid Ip range
    {
        DWORD                               MajorVersion;
        ULONG                               nRead, nTotal, i, nCount;
        ULONG                               Resume;
        BOOL                                fIsV5Call = TRUE,
                                            fPresent = FALSE;

        DHCP_SUBNET_ELEMENT_TYPE            ElementType;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4 = NULL;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5 = NULL;

        memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));

        nRead = nTotal = nCount = 0;

        MajorVersion = g_dwMajorVersion;
    
        if( MajorVersion >= CLASS_ID_VERSION ) 
        {
            fIsV5Call = TRUE;
        } 
        else 
        {
            fIsV5Call = FALSE;
        }

        Resume = 0;
    
        while( TRUE ) 
        {
            Elements5 = NULL;
            Elements4 = NULL;
            nRead = nTotal = 0;
        
            if( fIsV5Call ) 
            {
                Error = DhcpEnumSubnetElementsV5(
                    (LPWSTR)g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    DhcpIpRangesDhcpBootp,
                    &Resume,
                    ~0,
                    &Elements5,
                    &nRead,
                    &nTotal
                    );
            } 
            else 
            {
                Error = DhcpEnumSubnetElementsV4(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    DhcpIpRanges,
                    &Resume,
                    ~0,
                    &Elements4,
                    &nRead,
                    &nTotal
                    );
            }

            if( (Error isnot NO_ERROR) and
                (Error isnot ERROR_MORE_DATA) ) 
            {
                goto ErrorReturn;
            }
            for( i = 0; i < nRead ; i ++ ) 
            {
                if( fIsV5Call ) 
                {
                    if( IpRange.StartAddress >= Elements5->Elements[i].Element.IpRange->StartAddress and
                        IpRange.EndAddress <= Elements5->Elements[i].Element.IpRange->EndAddress )
                    {
                        fPresent = TRUE;
                    }
                } 
                else 
                {
                    if( IpRange.StartAddress >= Elements4->Elements[i].Element.IpRange->StartAddress and
                        IpRange.EndAddress <= Elements4->Elements[i].Element.IpRange->EndAddress )
                    {
                        fPresent = TRUE;
                    }
                   
                }
            }

            if( Elements4 ) 
            {
                DhcpRpcFreeMemory( Elements4 );
                Elements4 = NULL;
            }

            if( Elements5 ) 
            {
                DhcpRpcFreeMemory( Elements5 );
                Elements5 = NULL;
            }

            if( Error is ERROR_MORE_DATA )
            {
                continue;
            }
            else
                break;
        }

        if( fPresent is FALSE )
        {
            DisplayMessage(g_hModule,
                           EMSG_SCOPE_INVALID_EXCLUDERANGE);

            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;


        }
    }
    


    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.IpRange = &IpRange;
    
    if( g_dwMajorVersion < CLASS_ID_VERSION )
    {
        Error = DhcpAddSubnetElement(
                        g_ServerIpAddressUnicodeString,
                        g_ScopeIpAddress,
                        &Element );
    }
    else
    {
        Error = DhcpAddSubnetElementV5(
                        g_ServerIpAddressUnicodeString,
                        g_ScopeIpAddress,
                        (PVOID)&Element);
    }
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_ADD_EXCLUDERANGE,
                        Error);
                    
    goto CommonReturn;
}

DWORD
HandleScopeAddReservedip(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
#define MAX_ADDRESS_LENGTH  64  // 64 bytes
#define COMMAND_ARG_CLIENT_COMMENT  4

    DWORD                 Error = NO_ERROR;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element = {0};
    DHCP_SUBNET_ELEMENT_DATA_V5 ElementV5 = {0};
    DHCP_IP_RESERVATION_V4      ReserveElement={0};
    DHCP_CLIENT_UID             ClientUID;
    BYTE                        Address[MAX_ADDRESS_LENGTH];
    DWORD                       i = 0;
    DHCP_IP_ADDRESS             ReservedIpAddress;
    BOOL                        fIsV5 = TRUE;
    LPWSTR                      pwszName = L"",
                                pwszComment = L"";
                                


    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    memset(&ReserveElement, 0x00, sizeof(DHCP_IP_RESERVATION_V4));
    memset(&ClientUID, 0x00, sizeof(DHCP_CLIENT_UID));
    memset(&ReservedIpAddress, 0x00, sizeof(DHCP_IP_ADDRESS));
        

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_ADD_RESERVEDIP_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // make HardwareAddress.
    //

    ClientUID.DataLength = STRLEN(ppwcArguments[dwCurrentIndex+1]);
    if( ClientUID.DataLength % 2 != 0 ) 
    {
        //
        // address must be even length.
        //

        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_HARDWAREADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ClientUID.DataLength /= 2;

    DhcpAssert( ClientUID.DataLength < MAX_ADDRESS_LENGTH );

#ifdef UNICODE
    {
        LPSTR    pszAddString = NULL;
        pszAddString = DhcpUnicodeToOem(ppwcArguments[dwCurrentIndex+1], NULL);
        if( NULL == pszAddString ) i = 0;
        else i = DhcpStringToHwAddress((LPSTR)Address, pszAddString);
        DhcpFreeMemory(pszAddString);
        pszAddString = NULL;
    }
#else
    i = DhcpStringToHwAddress( (LPSTR)Address, ppwcArguments[dwCurrentIndex+1] );
    
#endif //UNICODE
    
    if( i != ClientUID.DataLength )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;        
    }

    ClientUID.Data = Address;

    
    //
    // make reserve element.
    //

    ReservedIpAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);

    if( ReservedIpAddress is INADDR_NONE or
        ReservedIpAddress is g_ScopeIpAddress )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ReserveElement.ReservedIpAddress = ReservedIpAddress;
    ReserveElement.ReservedForClient = &ClientUID;

    if( dwArgCount > 4 )
    {
        
        Error = ProcessBootpParameters( ( dwArgCount > 2 ) ? (dwArgCount - 2) : 0, 
                                        ( dwArgCount > 2 ) ? ppwcArguments+dwCurrentIndex+2 : NULL,
                                        &ReserveElement );
        if ( NO_ERROR isnot Error )
        {
            goto ErrorReturn;        
        }
    }
    else
    {
        ReserveElement.bAllowedClientTypes = CLIENT_TYPE_DHCP;
    }


    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        ElementV5.ElementType = DhcpReservedIps;
        ElementV5.Element.ReservedIp = &ReserveElement;

        Error = DhcpAddSubnetElementV5(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    &ElementV5 );
    }
    else
    {
        Element.ElementType = DhcpReservedIps;
        Element.Element.ReservedIp = &ReserveElement;

        Error = DhcpAddSubnetElementV4(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    &Element );
        fIsV5 = FALSE;
    }
    
    if( Error isnot NO_ERROR ) 
    {
        goto ErrorReturn;
    }

    //
    // if we are asked to set the client name, do so.
    //

    if( dwArgCount > 2 )
    {
        pwszName = ppwcArguments[dwCurrentIndex+2];
    }

    if( dwArgCount > 3 )
    {
        pwszComment = ppwcArguments[dwCurrentIndex+3];
    }

    //Set the name and comment for this reservation address
    {

        DHCP_SEARCH_INFO      ClientSearchInfo;
        LPDHCP_CLIENT_INFO_V4 ClientInfo = NULL;
        
        memset(&ClientSearchInfo, 0x00, sizeof(DHCP_SEARCH_INFO));

        //
        // set client name.
        //

        ClientSearchInfo.SearchType = DhcpClientIpAddress;
        ClientSearchInfo.SearchInfo.ClientIpAddress = ReservedIpAddress;

        do 
        {
            Error = DhcpGetClientInfoV4(
                        g_ServerIpAddressUnicodeString,
                        &ClientSearchInfo,
                        &ClientInfo );

            if( Error isnot NO_ERROR ) 
            {
                break;
            }

            if ( ( wcslen( pwszName ) + 1 ) * sizeof(WCHAR) > JET_cbColumnMost ) 
            {
                DisplayMessage(g_hModule, EMSG_DHCP_CLIENT_NAME_TOOLONG);
                Error = ERROR_INVALID_PARAMETER;
                break;
            }

            //
            // if client comment is also given in the argument, store that
            // as well.
            //
            if ( ( wcslen( pwszComment ) + 1 ) * sizeof(WCHAR) > JET_cbColumnMost ) 
            {
                DisplayMessage(g_hModule, EMSG_DHCP_CLIENT_COMMENT_TOOLONG);
                Error = ERROR_INVALID_PARAMETER;
                break;
            }

            ClientInfo->ClientComment = pwszComment;


            ClientInfo->ClientName = pwszName;

            ClientInfo->bClientType = ReserveElement.bAllowedClientTypes;

        } while ( FALSE );

        if ( Error is NO_ERROR ) 
        {

            Error = DhcpSetClientInfoV4(
                        g_ServerIpAddressUnicodeString,
                        ClientInfo );
    
        } 
        else 
        {
             //
            // Cleanup.
            //
            if ( ClientInfo ) 
            {
                DhcpRpcFreeMemory( ClientInfo );
                ClientInfo = NULL;
            }
        }

    } // if( (dwArgCount - dwCurrentIndex) > 3 )

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SCOPE_ADD_RESERVEDIP,
                        Error);
    goto CommonReturn;
}


DWORD
HandleScopeCheckDatabase(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD      Error = NO_ERROR;
    LPDHCP_SCAN_LIST ScanList = NULL;
    BOOL             FixFlag = FALSE;

    if( dwArgCount > 0 ) 
    {
        //
        // parse fix parameter.
        //

        if( STRICMP(ppwcArguments[dwCurrentIndex], TEXT("fix") ) is 0 ) 
        {
            FixFlag = TRUE;
        }
    }

    //
    // scan dhcp database and registry, check consistency and get bad
    // entries if any.
    //

    Error = DhcpScanDatabase(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                FixFlag,
                &ScanList
                );

    if( Error isnot NO_ERROR ) 
    {
        goto ErrorReturn;
    }

    if( FixFlag )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_RECONCILE_SCOPE,
                       IpAddressToString(g_ScopeIpAddress));
    }
    
    //
    // display bad entries.
    //

    if( (ScanList != NULL) &&
        (ScanList->NumScanItems != 0) &&
        (ScanList->ScanItems != NULL) ) 
    {

        LPDHCP_SCAN_ITEM ScanItem;
        LPDHCP_SCAN_ITEM ScanItemEnd;
        DWORD i = 1;

        if( !FixFlag ) {
            DisplayMessage(
                g_hModule,
                MSG_SRVR_RECONCILE_SCOPE_NEEDFIX,
                IpAddressToString(g_ScopeIpAddress)
                );
        }
                
        ScanItemEnd =
            ScanList->ScanItems +
            ScanList->NumScanItems;

        for( ScanItem = ScanList->ScanItems;
                ScanItem < ScanItemEnd; ScanItem++ ) 
        {

            DisplayMessage(g_hModule, MSG_SCOPE_IPADDRESS,
                i++,
                IpAddressToString(ScanItem->IpAddress) );

            if( ScanItem->ScanFlag == DhcpRegistryFix ) 
            {
                DisplayMessage(g_hModule, MSG_SCOPE_FIX_REGISTRY);
            }
            else if( ScanItem->ScanFlag == DhcpDatabaseFix ) 
            {
                DisplayMessage(g_hModule, MSG_SCOPE_FIX_DATABASE);
            }
            else 
            {
                DisplayMessage(g_hModule, MSG_SCOPE_FIX_UNKNOWN);
            }
        }
    }
    else
    {
        if( !FixFlag ) {
            DisplayMessage(
                g_hModule,
                MSG_SRVR_RECONCILE_SCOPE_NOFIX,
                IpAddressToString(g_ScopeIpAddress)
                );
        }
    }        

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_RECONCILE_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_CHECK_DATABASE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeDeleteIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = NO_ERROR;
    DWORD                    MajorVersion;
    DHCP_IP_RANGE            IpRange;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_SUBNET_ELEMENT_TYPE ElementType;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA));
    memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));


    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_DELETE_IPRANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Element.ElementType = DhcpIpRanges;
    Element.Element.IpRange = &IpRange;

    MajorVersion = g_dwMajorVersion;

    if( MajorVersion >= CLASS_ID_VERSION ) 
    {

        if( dwArgCount > 2) 
        {
            if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("DHCP")) ) 
            {
                Element.ElementType = DhcpIpRangesDhcpOnly;
            } 
            else if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("BOOTP")) ) 
            {
                Element.ElementType = DhcpIpRangesBootpOnly;
            } 
            else if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("DHCPBOOTP") ) ) 
            {
                Element.ElementType = DhcpIpRangesDhcpBootp;
            } 
            else 
            {
                DisplayMessage(g_hModule, HLP_SCOPE_DELETE_IPRANGE_EX);
                return ERROR_INVALID_PARAMETER;
            }
            
            Error = DhcpRemoveSubnetElementV5(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                (PVOID)&Element,
                FALSE
                );
            if( Error is NO_ERROR )
                goto CommonReturn;
            else 
                goto ErrorReturn;
        }
    }

    Error = DhcpRemoveSubnetElement(
        g_ServerIpAddressUnicodeString,
        g_ScopeIpAddress,
        &Element,
        FALSE
        );
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_DELETE_IPRANGE,
                        Error);
                   
    goto CommonReturn;
}

DWORD
HandleScopeDeleteExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = NO_ERROR;
    DHCP_SUBNET_ELEMENT_DATA Element;
    DHCP_IP_RANGE            IpRange;

    //
    // Expected Parameters are : <SubnetAddress IpRangeStart IpRangeEnd>
    //

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA));
    memset(&IpRange, 0x00, sizeof(DHCP_IP_RANGE));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_DELETE_EXCLUDERANGE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    IpRange.StartAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    IpRange.EndAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( IpRange.StartAddress is INADDR_NONE or 
        IpRange.EndAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Element.ElementType = DhcpExcludedIpRanges;
    Element.Element.ExcludeIpRange = &IpRange;

    Error = DhcpRemoveSubnetElement(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &Element,
                DhcpFullForce );
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayMessage(g_hModule, 
                   EMSG_SCOPE_DELETE_EXCLUDERANGE,
                   Error);
    goto CommonReturn;

}

DWORD
HandleScopeDeleteReservedip(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                 Error = NO_ERROR;
    DHCP_SUBNET_ELEMENT_DATA_V4 Element;
    DHCP_IP_RESERVATION_V4      ReserveElement;
    DHCP_CLIENT_UID             ClientUID;
    BYTE                        Address[MAX_ADDRESS_LENGTH] = {L'\0'};
    DWORD                       i = 0;

    //
    // Expected Parameters are : <SubnetAddress ReservedIp HWAddressString>
    //

    memset(&Element, 0x00, sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    memset(&ReserveElement, 0x00, sizeof(DHCP_IP_RESERVATION_V4));
    memset(&ClientUID, 0x00, sizeof(DHCP_CLIENT_UID));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_DELETE_RESERVEDIP_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // make HardwareAddress.
    //

    ClientUID.DataLength = STRLEN(ppwcArguments[dwCurrentIndex+1]);
    if( ClientUID.DataLength % 2 != 0 ) 
    {
        //
        // address must be even length.
        //

        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_HARDWAREADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ClientUID.DataLength /= 2;

    DhcpAssert( ClientUID.DataLength < MAX_ADDRESS_LENGTH );

#ifdef UNICODE
    {
        LPSTR    pszAddString = NULL;
        pszAddString = DhcpUnicodeToOem(ppwcArguments[dwCurrentIndex+1], NULL);
        if( NULL == pszAddString ) i = 0;
        else i = DhcpStringToHwAddress((LPSTR)Address, pszAddString);
        DhcpFreeMemory(pszAddString);
        pszAddString = NULL;
    }
#else
    i = DhcpStringToHwAddress( (LPSTR)Address, ppwcArguments[dwCurrentIndex+1] );
    
#endif //UNICODE


//    i = DhcpStringToHwAddress( (LPSTR)Address, ppwcArguments[dwCurrentIndex+1] );

    DhcpAssert( i == ClientUID.DataLength );

    ClientUID.Data = Address;

    //
    // make reserve element.
    //

    ReserveElement.ReservedIpAddress = StringToIpAddress(ppwcArguments[dwCurrentIndex]);

    if( ReserveElement.ReservedIpAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ReserveElement.ReservedForClient = &ClientUID;

    Element.ElementType = DhcpReservedIps;
    Element.Element.ReservedIp = &ReserveElement;

    Error = DhcpRemoveSubnetElementV4(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &Element,
                DhcpFullForce );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_DELETE_RESERVEDIP,
                        Error);
    goto CommonReturn;
}


DWORD
HandleScopeDeleteOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD             Error = NO_ERROR;
    DHCP_OPTION_ID          OptionID;
    DHCP_OPTION_SCOPE_INFO  ScopeInfo;
    

    LPWSTR         pwcTag = NULL;
    LPWSTR         pwcUser = NULL;   
    LPWSTR         pwcVendor = NULL;
    LPWSTR         pwcTemp = NULL;

    BOOL           fUser = FALSE;
    BOOL           fVendor = FALSE;

    DWORD          dwIndex = 0;

    //
    // Expected Parameters are :
    // subnet-address <OptionID>
    //

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));


    if( dwArgCount < 1 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_DELETE_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo =  g_ScopeIpAddress;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );

    dwIndex = 1;
    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    Error = RemoveOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo
    );
       
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( pwcUser && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_DELETE_OPTIONVALUE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleScopeDeleteReservedoptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD             Error = NO_ERROR; 
    DHCP_OPTION_ID          OptionID;
    DHCP_OPTION_SCOPE_INFO  ScopeInfo;

    LPWSTR         pwcTag = NULL;
    LPWSTR         pwcUser = NULL;   
    LPWSTR         pwcVendor = NULL;
    LPWSTR         pwcTemp = NULL;

    BOOL           fUser = FALSE;
    BOOL           fVendor = FALSE;

    DWORD          dwIndex = 0;

    //
    // Expected Parameters are :
    // subnet-address reservation-address <OptionID>
    //

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_DELETE_RESERVEDOPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	g_ScopeIpAddress;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	StringToIpAddress( ppwcArguments[dwCurrentIndex] );
    
    if( ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress is INADDR_NONE )        
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwIndex++;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+1]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex+1], NULL, 10 );
    dwIndex++;

    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule,
                               EMSG_DHCP_DUPLICATE_TAG, 
                               pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }


    Error = RemoveOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo
    );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( pwcUser && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SCOPE_DELETE_RESERVEDOPTIONVALUE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleScopeSetState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        Error = NO_ERROR;
    LPDHCP_SUBNET_INFO SubnetInfo = NULL;
    DHCP_SUBNET_STATE State = 0;

    //
    // Expected Parameters are : <1|0>
    //

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_STATE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
       
    Error = DhcpGetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &SubnetInfo );

    if( Error isnot NO_ERROR ) 
    {
        goto ErrorReturn;
    }
    
    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    State = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );
    switch(State) {
    case 0: SubnetInfo->SubnetState = DhcpSubnetDisabled; break;
    case 1: SubnetInfo->SubnetState = DhcpSubnetEnabled; break;
    case 2: SubnetInfo->SubnetState = DhcpSubnetDisabledSwitched; break;
    case 3: SubnetInfo->SubnetState = DhcpSubnetEnabledSwitched; break;
    default:
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    if( SubnetInfo->SubnetState == State ) 
    {
        Error = NO_ERROR;
        goto CommonReturn;
    }

    Error = DhcpSetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                SubnetInfo );
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    if( SubnetInfo != NULL )
    {
        DhcpRpcFreeMemory( SubnetInfo );
        SubnetInfo = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SET_STATE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleScopeSetScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD       Error = NO_ERROR;
    if( dwArgCount < 1)
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_SCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( IsIpAddress(ppwcArguments[dwCurrentIndex]) is FALSE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    if( SetScopeInfo(ppwcArguments[dwCurrentIndex] ) )
    {
        Error = NO_ERROR;
    }
    else
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

CommonReturn:
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SCOPE_SET_SCOPE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeSetOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = NO_ERROR;
    DHCP_OPTION_ID           OptionID;
    DHCP_OPTION_SCOPE_INFO   ScopeInfo;
    DHCP_OPTION_DATA         OptionValue;
    DHCP_OPTION_DATA_ELEMENT OptionData;
    LPWSTR                   UnicodeOptionValueString = NULL;
    LPDHCP_OPTION            OptionInfo = NULL;
    DHCP_OPTION_DATA_TYPE    OptionType;

    LPWSTR                   OptionTypeString = NULL;
    DWORD                    OptionArrayType;

    LPWSTR                   pwcTag = NULL;
    LPWSTR                   pwcUser = NULL;
    LPWSTR                   pwcVendor = NULL;
    LPWSTR                   pwcTemp = NULL;

    BOOL                     fUser = FALSE;
    BOOL                     fVendor = FALSE;
    BOOL                     fValidType = FALSE;

    DWORD                    dwIndex = 0;
    DWORD                    i = 0;

    //
    // Expected Parameters are :
    // subnet-address <OptionID OptionType OptionValue>
    //

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    memset(&OptionValue, 0x00, sizeof(DHCP_OPTION_DATA));
    memset(&OptionData, 0x00, sizeof(DHCP_OPTION_DATA_ELEMENT));


    if( dwArgCount < 3 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    
    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo =  g_ScopeIpAddress;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+dwIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex+dwIndex], NULL, 10 );
    
    dwIndex++;

    OptionTypeString = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;

    while( NULL isnot wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
    {
        LPWSTR  pwcStr = NULL;
        if( dwArgCount <= dwIndex + 1 )
        {
            DisplayMessage(g_hModule, HLP_SRVR_SET_OPTIONVALUE_EX);
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionInfoV5(g_ServerIpAddressUnicodeString,
                                    fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                    OptionID,
                                    NULL,
                                    pwcVendor,
                                    &OptionInfo);
    }
    else
    {
    
        Error = DhcpGetOptionInfo(g_ServerIpAddressUnicodeString,
                                  OptionID,
                                  &OptionInfo);
    }

    if( Error isnot NO_ERROR or OptionInfo is NULL ) 
    {
        //
        // if no option template is present,
        // assume it is unary if only one option, assume array if more
        //
        goto ErrorReturn;
    }
    else 
    {
        OptionArrayType = OptionInfo->OptionType;
    }

    //Check if OptionType supplied is the same as defined.

    //Find out the OptionType
    for(i=0; i < sizeof(TagOptionType)/sizeof(COMMAND_OPTION_TYPE); i++)
    {
        if( MatchToken(OptionTypeString, TagOptionType[i].pwszTagID) )
        {
            OptionType = TagOptionType[i].DataType;
            fValidType = TRUE;
            break;
        }
    }
    
    if( fValidType is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( OptionType isnot OptionInfo->DefaultValue.Elements[0].OptionType )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_OPTIONTYPE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    switch(OptionArrayType)
    {
    case DhcpArrayTypeOption:
        {
            Error = SetOptionDataTypeArray(
                            OptionType,
                            ppwcArguments+dwCurrentIndex,
                            dwIndex,
                            dwArgCount, //Corrections
                            &OptionValue);
            if( Error isnot NO_ERROR )
                goto ErrorReturn;
            break;
        }
    case DhcpUnaryElementTypeOption:
    default:
        {

            Error = SetOptionDataType(
                        OptionType,
                        ppwcArguments[dwCurrentIndex+dwIndex],
                        &OptionData,
                        &UnicodeOptionValueString );

            if( Error != NO_ERROR ) 
            {
                goto ErrorReturn;
            }

            OptionValue.NumElements = 1;
            OptionValue.Elements = &OptionData;
            break;
        }
    }
        
    Error = SetOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo,
        &OptionValue
    );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    
    if( OptionInfo )
    {
        if(OptionInfo->OptionType is DhcpArrayTypeOption)
        {
            if( OptionValue.Elements isnot NULL )
            {
                free(OptionValue.Elements);
                OptionValue.Elements = NULL;
            }
        }
    }

    if( pwcUser && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                   EMSG_SCOPE_SET_OPTIONVALUE,
                   Error);

    goto CommonReturn;

}

DWORD
HandleScopeSetReservedoptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DHCP_OPTION_ID              OptionID;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo;
    DHCP_OPTION_DATA            OptionValue;
    DHCP_OPTION_DATA_ELEMENT    OptionData;
    DHCP_OPTION_DATA_TYPE       OptionType;
    LPWSTR                      UnicodeOptionValueString = NULL;
    LPWSTR                      OptionTypeString = NULL;
    LPDHCP_OPTION               OptionInfo = NULL;
    DWORD                       OptionArrayType;

    LPWSTR                      pwcTag = NULL;
    LPWSTR                      pwcUser = NULL;
    LPWSTR                      pwcVendor = NULL;
    LPWSTR                      pwcTemp = NULL;

    BOOL                        fUser = FALSE;
    BOOL                        fVendor = FALSE;
    BOOL                        fValidType = FALSE;

    DWORD                       dwIndex = 0;
    DWORD                       i = 0;
    //
    // Expected Parameters are :
    // subnet-address reservation-address <OptionID OptionType OptionValue>
    //


    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    memset(&OptionValue, 0x00, sizeof(DHCP_OPTION_DATA));
    memset(&OptionData, 0x00, sizeof(DHCP_OPTION_DATA_ELEMENT));

    if( dwArgCount < 4 ) 
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_RESERVEDOPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	g_ScopeIpAddress;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	StringToIpAddress( ppwcArguments[dwCurrentIndex+dwIndex] );

    if( ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwIndex++;

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+dwIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex+dwIndex], NULL, 10 );
    
    dwIndex++;

    OptionTypeString = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;

    while( NULL isnot wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
    {
        LPWSTR  pwcStr = NULL;
        if( dwArgCount <= dwIndex + 1 )
        {
            DisplayMessage(g_hModule, HLP_SCOPE_SET_RESERVEDOPTIONVALUE_EX);
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionInfoV5(g_ServerIpAddressUnicodeString,
                                    fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                    OptionID,
                                    NULL,
                                    pwcVendor,
                                    &OptionInfo);
    }
    else
    {
        Error = DhcpGetOptionInfo(
                                    g_ServerIpAddressUnicodeString,
                                    OptionID,
                                    &OptionInfo);
    }

    if( Error isnot NO_ERROR or OptionInfo is NULL ) 
    {
        //
        // if no option template is present,
        // assume it is unary if only one option, assume array if more
        //
        goto ErrorReturn;
    }
    else 
    {
        OptionArrayType = OptionInfo->OptionType;
    }

    //Check if OptionType supplied is the same as defined.

    //Find out the OptionType
    for(i=0; i < sizeof(TagOptionType)/sizeof(COMMAND_OPTION_TYPE); i++)
    {
        if( MatchToken(OptionTypeString, TagOptionType[i].pwszTagID) )
        {
            OptionType = TagOptionType[i].DataType;
            fValidType = TRUE;
            break;
        }
    }
    
    if( fValidType is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( OptionType isnot OptionInfo->DefaultValue.Elements[0].OptionType )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_OPTIONTYPE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    switch(OptionArrayType)
    {
    case DhcpArrayTypeOption:
        {
            Error = SetOptionDataTypeArray(
                                OptionType,
                                ppwcArguments+dwCurrentIndex,
                                dwIndex,
                                dwArgCount, //Corrections
                                &OptionValue);
            if( Error isnot NO_ERROR )
                goto ErrorReturn;
            break;
        }
    case DhcpUnaryElementTypeOption:
        {
            Error = SetOptionDataType(
                OptionType,
                ppwcArguments[dwCurrentIndex+dwIndex],
                &OptionData,
                &UnicodeOptionValueString
            );

            if( Error != NO_ERROR ) 
            {
                goto ErrorReturn;
            }

            OptionValue.NumElements = 1;
            OptionValue.Elements = &OptionData;
            break;
        }
    }

    Error = SetOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo,
        &OptionValue
    );
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);

    if( OptionInfo )
    {
        if( OptionInfo->OptionType is DhcpArrayTypeOption)
        {
            if( OptionValue.Elements isnot NULL )
            {
                free(OptionValue.Elements);
                OptionValue.Elements = NULL;
            }
        }
    }

    if( pwcUser && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SET_RESERVEDOPTIONVALUE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeSetName(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        Error = NO_ERROR;
    LPDHCP_SUBNET_INFO SubnetInfo = NULL;
    DWORD              State;


    Error = DhcpGetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &SubnetInfo );

    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
    DhcpAssert(SubnetInfo isnot NULL);
    
    if( dwArgCount < 1 )
        SubnetInfo->SubnetName = NULL;
    else
    {
        SubnetInfo->SubnetName = ppwcArguments[dwCurrentIndex];
    }

    Error = DhcpSetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                SubnetInfo );

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    if( SubnetInfo != NULL )
    {
        DhcpRpcFreeMemory( SubnetInfo );
        SubnetInfo = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SET_NAME,
                        Error);
    goto CommonReturn;

}

DWORD
HandleScopeSetComment(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        Error = NO_ERROR;
    LPDHCP_SUBNET_INFO SubnetInfo = NULL;
    DWORD              State;

    //
    // Expected Parameters are :  <SubnetComment>
    //
        
    Error = DhcpGetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &SubnetInfo );

    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
    DhcpAssert(SubnetInfo isnot NULL);

    
    if( dwArgCount < 1 )
        SubnetInfo->SubnetComment = NULL;
    else
    {
        SubnetInfo->SubnetComment = ppwcArguments[dwCurrentIndex];
    }

    Error = DhcpSetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                SubnetInfo );
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    if( SubnetInfo != NULL )
    {
        DhcpRpcFreeMemory( SubnetInfo );
        SubnetInfo = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SET_COMMENT,
                        Error);
    goto CommonReturn;

}


DWORD
HandleScopeSetSuperscope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DHCP_IP_ADDRESS SubnetAddress;
    WCHAR           *pwszSuperScopeName;
    BOOL            fChangeExisting;
    DWORD     Error = NO_ERROR;

    memset(&SubnetAddress, 0x00, sizeof(DHCP_IP_ADDRESS));

    if( dwArgCount < 2 )
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SET_SUPERSCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    pwszSuperScopeName = ppwcArguments[dwCurrentIndex];

    fChangeExisting = (BOOL) ( *(ppwcArguments[dwCurrentIndex+1]) - _T('0') );

    Error = DhcpSetSuperScopeV4( g_ServerIpAddressUnicodeString,
                                 g_ScopeIpAddress,
                                 pwszSuperScopeName,
                                 fChangeExisting );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SET_SUPERSCOPE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleScopeShowClients(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                 Error = NO_ERROR;
    DHCP_RESUME_HANDLE          ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V4 ClientEnumInfo = NULL;
    DWORD                       ClientsRead = 0;
    DWORD                       ClientsTotal = 0;
    DWORD                       i = 0;
    DWORD                       dwCount = 0, Level = 0;
    

    if( dwArgCount >= 1 )
    {
        if( !IsPureNumeric( ppwcArguments[dwCurrentIndex ] ) )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        
        Level = ATOI( ppwcArguments[dwCurrentIndex]);
    }

  
    GlobalClientCount = 1;

    if( Level == 0 )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_TABLE);
    }
    else
    {
        DisplayMessage( g_hModule, MSG_SCOPE_CLIENT_TABLE2);
    }
    
    for(;;) 
    {

        ClientEnumInfo = NULL;
        Error = DhcpEnumSubnetClientsV4(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    &ResumeHandle,
                    (DWORD)(-1),
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( Error is ERROR_NO_MORE_ITEMS )
        {
    
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENTS_COUNT,
                           dwCount,//ClientsTotal,
                           g_ScopeIpAddressUnicodeString);

            Error = NO_ERROR;

            break;
        }

        if( (Error isnot NO_ERROR) and
            (Error isnot ERROR_MORE_DATA) ) 
        {
            goto ErrorReturn;
        }


        if( GlobalVerbose )
        {
            dwCount+= ClientsRead;
            for( i = 0; i < ClientsRead; i++ ) 
            {
                LPDHCP_CLIENT_INFO_V4 TempClientInfo = NULL;
                DWORD                 dwError = NO_ERROR;
                DHCP_SEARCH_INFO      SearchInfo = {0};

                SearchInfo.SearchType = DhcpClientIpAddress;
                SearchInfo.SearchInfo.ClientIpAddress = ClientEnumInfo->Clients[i]->ClientIpAddress;
                dwError = DhcpGetClientInfoV4(
                                     g_ServerIpAddressUnicodeString,
                                     &SearchInfo,
                                     &TempClientInfo);

                if( dwError isnot NO_ERROR )
                    continue;                                                             
                                            
                PrintClientInfo( TempClientInfo, Level );
                DhcpRpcFreeMemory(TempClientInfo);
                TempClientInfo = NULL;
            }
        }
        else
        {
            dwCount+= ClientsRead;

            for( i = 0; i < ClientsRead; i++ ) 
            {
                LPDHCP_CLIENT_INFO_V4 TempClientInfo = NULL;
                DWORD                 dwError = NO_ERROR;
                DHCP_SEARCH_INFO      SearchInfo = {0};

                SearchInfo.SearchType = DhcpClientIpAddress;
                SearchInfo.SearchInfo.ClientIpAddress = ClientEnumInfo->Clients[i]->ClientIpAddress;
                dwError = DhcpGetClientInfoV4(
                                     g_ServerIpAddressUnicodeString,
                                     &SearchInfo,
                                     &TempClientInfo);

                if( dwError isnot NO_ERROR )
                    continue;                                                             

                PrintClientInfoShort( TempClientInfo);
                DhcpRpcFreeMemory(TempClientInfo);
                TempClientInfo = NULL;
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );
        ClientEnumInfo = NULL;

        if( Error isnot ERROR_MORE_DATA ) 
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENTS_COUNT,
                           dwCount,
                           g_ScopeIpAddressUnicodeString);

            break;
        }
        else
        {
            continue;
        }
    }
    


CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_CLIENTS,
                        Error);
                   
    goto CommonReturn;
}

DWORD
HandleScopeShowClientsv5(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DHCP_RESUME_HANDLE          ResumeHandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V5 ClientEnumInfo = NULL;
    DWORD                       ClientsRead = 0;
    DWORD                       ClientsTotal = 0;
    DWORD                       i, dwCount = 0, Level = 0;
    BOOL                        fTable = FALSE;


    if( dwArgCount >= 1 )
    {
        if( !IsPureNumeric( ppwcArguments[dwCurrentIndex ] ) )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        
        Level = ATOI( ppwcArguments[dwCurrentIndex]);
    }

    if( g_dwMajorVersion < CLASS_ID_VERSION )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_VERSION,
                       g_ServerIpAddressUnicodeString,
                       g_dwMajorVersion,
                       g_dwMinorVersion);
        return NO_ERROR;
    }

    GlobalClientCount = 1;

    if( Level == 0 )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_TABLE);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_TABLE2 );
    }
    
    for(;;) 
    {

        ClientEnumInfo = NULL;
        Error = DhcpEnumSubnetClientsV5(
                    g_ServerIpAddressUnicodeString,
                    g_ScopeIpAddress,
                    &ResumeHandle,
                    (DWORD)(-1),
                    &ClientEnumInfo,
                    &ClientsRead,
                    &ClientsTotal );

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENTSV5_COUNT,
                           dwCount,
                           g_ScopeIpAddressUnicodeString);
            
            Error = NO_ERROR;

            break;
        }

        if( (Error isnot NO_ERROR) and
            (Error isnot ERROR_MORE_DATA) ) 
        {
            goto ErrorReturn;
        }

        DhcpAssert( ClientEnumInfo != NULL );
        DhcpAssert( ClientEnumInfo->NumElements == ClientsRead );

        if( GlobalVerbose )
        {
            dwCount += ClientsRead;
        
            for( i=0; i< ClientsRead; i++)
            {
                LPDHCP_CLIENT_INFO_V4 TempClientInfo = NULL;
                DWORD                 dwError = NO_ERROR;
                DHCP_SEARCH_INFO      SearchInfo = {0};

                SearchInfo.SearchType = DhcpClientIpAddress;
                SearchInfo.SearchInfo.ClientIpAddress = ClientEnumInfo->Clients[i]->ClientIpAddress;
                dwError = DhcpGetClientInfoV4(
                                      g_ServerIpAddressUnicodeString,
                                      &SearchInfo,
                                      &TempClientInfo);

                if( dwError isnot NO_ERROR )
                    continue;                                                             

                PrintClientInfo( TempClientInfo, Level );
                DhcpRpcFreeMemory(TempClientInfo);
                TempClientInfo = NULL;
            }

        }
        else
        {
            dwCount += ClientsRead;

            for( i = 0; i < ClientsRead; i++ ) 
            {
                LPDHCP_CLIENT_INFO_V4 TempClientInfo = NULL;
                DWORD                 dwError = NO_ERROR;
                DHCP_SEARCH_INFO      SearchInfo = {0};

                SearchInfo.SearchType = DhcpClientIpAddress;
                SearchInfo.SearchInfo.ClientIpAddress = ClientEnumInfo->Clients[i]->ClientIpAddress;
                dwError = DhcpGetClientInfoV4(
                                      g_ServerIpAddressUnicodeString,
                                      &SearchInfo,
                                      &TempClientInfo);

                if( dwError isnot NO_ERROR )
                    continue;                                                             

                PrintClientInfo( TempClientInfo, Level );
                DhcpRpcFreeMemory(TempClientInfo);
                TempClientInfo = NULL;
            }
        }

        DhcpRpcFreeMemory( ClientEnumInfo );
        ClientEnumInfo = NULL;

        if( Error isnot ERROR_MORE_DATA ) 
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENTSV5_COUNT,
                           dwCount,
                           g_ScopeIpAddressUnicodeString);
            break;
        }
        else
            continue;
    }
    if (Error isnot NO_ERROR )
        goto ErrorReturn;
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_CLIENTSV5,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeShowIprange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    DWORD                               MajorVersion;
    ULONG                               nRead, nTotal, i, nCount;
    ULONG                               Resume;
    BOOL                                fIsV5Call = TRUE,
                                        fTable = FALSE;

    DHCP_SUBNET_ELEMENT_TYPE            ElementType;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4 = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5 = NULL;

    memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));

    nRead = nTotal = nCount = 0;

    MajorVersion = g_dwMajorVersion;
    
    if( MajorVersion >= CLASS_ID_VERSION ) 
    {
        fIsV5Call = TRUE;
    } 
    else 
    {
        fIsV5Call = FALSE;
    }

    Resume = 0;
    
    while( TRUE ) 
    {
        Elements5 = NULL;
        Elements4 = NULL;
        nRead = nTotal = 0;
        
        if( fIsV5Call ) 
        {
            Error = DhcpEnumSubnetElementsV5(
                (LPWSTR)g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpIpRangesDhcpBootp,
                &Resume,
                ~0,
                &Elements5,
                &nRead,
                &nTotal
                );
        } 
        else 
        {
            Error = DhcpEnumSubnetElementsV4(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpIpRanges,
                &Resume,
                ~0,
                &Elements4,
                &nRead,
                &nTotal
                );
        }

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_IPRANGE_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            
            Error = NO_ERROR;

            break;
        }

        if( (Error isnot NO_ERROR) and
            (Error isnot ERROR_MORE_DATA) ) 
        {
            goto ErrorReturn;
        }

        nCount+= nRead;

        if( fTable is FALSE )
        {
         
            DisplayMessage(g_hModule, MSG_SCOPE_IPRANGE_TABLE);
            
            fTable = TRUE;
        }

        for( i = 0; i < nRead ; i ++ ) 
        {
            if( fIsV5Call ) 
            {
                PrintRange(
                    Elements5->Elements[i].ElementType,
                    Elements5->Elements[i].Element.IpRange->StartAddress,
                    Elements5->Elements[i].Element.IpRange->EndAddress,
                    Elements5->Elements[i].Element.IpRange->BootpAllocated,
                    Elements5->Elements[i].Element.IpRange->MaxBootpAllowed,
                    FALSE
                    );
            } 
            else 
            {
                PrintRange(
                    Elements4->Elements[i].ElementType,
                    Elements4->Elements[i].Element.IpRange->StartAddress,
                    Elements4->Elements[i].Element.IpRange->EndAddress,
                    0,
                    0,
                    FALSE
                    );
            }
        }

        if( Elements4 ) 
        {
            DhcpRpcFreeMemory( Elements4 );
            Elements4 = NULL;
        }

        if( Elements5 ) 
        {
            DhcpRpcFreeMemory( Elements5 );
            Elements5 = NULL;
        }

        if( Error is ERROR_MORE_DATA )
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_IPRANGE_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            break;
        }

    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_IPRANGE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeShowExcluderange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    DWORD                               MajorVersion;
    ULONG                               nRead, nTotal, i, nCount;
    ULONG                               Resume;
    BOOL                                fIsV5Call = TRUE,
                                        fTable = FALSE;
    DHCP_SUBNET_ELEMENT_TYPE            ElementType;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4 = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5 = NULL;

    memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));

    nRead = nTotal = nCount = 0;

    MajorVersion = g_dwMajorVersion;
    if( MajorVersion >= CLASS_ID_VERSION ) 
    {
        fIsV5Call = TRUE;
    } 
    else 
    {
        fIsV5Call = FALSE;
    }

    Resume = 0;
    while( TRUE ) 
    {
        Elements5 = NULL;
        Elements4 = NULL;
        
        if( fIsV5Call ) 
        {
            Error = DhcpEnumSubnetElementsV5(
                (LPWSTR)g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpExcludedIpRanges,
                &Resume,
                ~0,
                &Elements5,
                &nRead,
                &nTotal
                );
        } 
        else 
        {
            Error = DhcpEnumSubnetElementsV4(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpExcludedIpRanges,
                &Resume,
                ~0,
                &Elements4,
                &nRead,
                &nTotal
                );
        }

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_EXCLUDERANGE_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            break;
        }

        if( (Error isnot NO_ERROR) and
            (Error isnot ERROR_MORE_DATA) ) 
        {
            goto ErrorReturn;
        }

        nCount += nRead;

        if( fTable is FALSE )
        {
            DisplayMessage(g_hModule, MSG_SCOPE_EXCLUDERANGE_TABLE);

            fTable = TRUE;
        }

        for( i = 0; i < nRead ; i ++ ) 
        {
            if( fIsV5Call ) 
            {
                PrintRange(
                    Elements5->Elements[i].ElementType,
                    Elements5->Elements[i].Element.ExcludeIpRange->StartAddress,
                    Elements5->Elements[i].Element.ExcludeIpRange->EndAddress,
                    0,
                    0,
                    TRUE
                    );
            } 
            else 
            {
                PrintRange(
                    Elements4->Elements[i].ElementType,
                    Elements4->Elements[i].Element.IpRange->StartAddress,
                    Elements4->Elements[i].Element.IpRange->EndAddress,
                    0,
                    0,
                    TRUE
                    );
            }
        }

        if( Elements4 ) 
        {
            DhcpRpcFreeMemory( Elements4 );
            Elements4 = NULL;
        }

        if( Elements5 ) 
        {
            DhcpRpcFreeMemory( Elements5 );
            Elements5 = NULL;
        }

        if( Error is ERROR_MORE_DATA )
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_EXCLUDERANGE_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            break;
        }
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SCOPE_SHOW_EXCLUDERANGE,
                        Error);
    goto CommonReturn;

}

DWORD
HandleScopeShowReservedip(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                         Error = NO_ERROR;
    DWORD                               MajorVersion;
    ULONG                               nRead, nTotal, i, j, nCount;
    ULONG                               Resume;
    BOOL                                fIsV5Call;
    DHCP_SUBNET_ELEMENT_TYPE            ElementType;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 Elements4 = NULL;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 Elements5 = NULL;
    BOOL                                fTable = FALSE;

    memset(&ElementType, 0x00, sizeof(DHCP_SUBNET_ELEMENT_TYPE));

    MajorVersion = g_dwMajorVersion;
    if( MajorVersion >= CLASS_ID_VERSION ) 
    {
        fIsV5Call = TRUE;
    } 
    else 
    {
        fIsV5Call = FALSE;
    }

    Resume = 0;
    nCount = 0;

    while( TRUE ) 
    {
        Elements5 = NULL;
        Elements4 = NULL;
        nRead = nTotal = 0;
        
        if( fIsV5Call ) 
        {
            Error = DhcpEnumSubnetElementsV5(
                (LPWSTR)g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpReservedIps,
                &Resume,
                ~0,
                &Elements5,
                &nRead,
                &nTotal
                );
        } 
        else 
        {
            Error = DhcpEnumSubnetElementsV4(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                DhcpReservedIps,
                &Resume,
                ~0,
                &Elements4,
                &nRead,
                &nTotal
                );
        }

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_RESERVEDIP_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            Error = NO_ERROR;
            break;
        }

        if( Error isnot NO_ERROR and
            Error isnot ERROR_MORE_DATA )
        {
            goto ErrorReturn;
        }

        if( fTable is FALSE )
        {
            DisplayMessage(g_hModule, MSG_SCOPE_RESERVEDIP_TABLE);
            fTable = TRUE;
        }

        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        
        nCount += nRead;

        {
            
            for( i = 0; i < nRead ; i ++ ) 
            {
                DWORD DataLength;
                LPBYTE Data;
                DWORD dw=0, k=0;
                WCHAR  wcData[40] = {L'\0'};
                WCHAR  IpAddress[23] = {L'\0'};

                if( fIsV5Call ) 
                {
					DataLength = Elements5->Elements[i].Element.ReservedIp->ReservedForClient->DataLength;
                    Data = Elements5->Elements[i].Element.ReservedIp->ReservedForClient->Data;

                    j=5;

                    while( j < DataLength )
                    {
                        wsprintf(wcData+wcslen(wcData), L"%.2x-", (DWORD)Data[j]);
                        j++;                      
                    }
                    
                    wcData[wcslen(wcData)-1] = L'\0';
                    wsprintf(IpAddress, L"    %s", IpAddressToString(Elements5->Elements[i].Element.ReservedIp->ReservedIpAddress));
                    for( dw = wcslen(IpAddress); dw < 23; dw++)
                    {
                        IpAddress[dw] = L' ';
                    }
                    IpAddress[22] = L'\0';

                    DisplayMessage(g_hModule, 
                                   MSG_SCOPE_RESERVEDIP_INFO,
                                   IpAddress,
                                   wcData);
                } 
                else 
                {
                    DataLength = Elements4->Elements[i].Element.ReservedIp->ReservedForClient->DataLength;
                    Data = Elements4->Elements[i].Element.ReservedIp->ReservedForClient->Data;
                    
                    j = 0;

                    while( j < DataLength )
                    {
                        wsprintf(wcData+2*j, L"%.2x-", (DWORD)Data[j]);
                        j++;
                    }
                    wcData[wcslen(wcData)-1] = L'\0';
                    wcData[wcslen(wcData)-1] = L'\0';
                    wsprintf(IpAddress, L"    %s", IpAddressToString(Elements4->Elements[i].Element.ReservedIp->ReservedIpAddress));
                    for( dw = wcslen(IpAddress); dw < 23; dw++)
                    {
                        IpAddress[dw] = L' ';
                    }
                    IpAddress[22] = L'\0';


                    DisplayMessage(g_hModule,
                                   MSG_SCOPE_RESERVEDIP_INFO,
                                   IpAddress,
                                   wcData);

                }
				
            }
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        }

        if( Elements4 ) 
        {
            DhcpRpcFreeMemory( Elements4 );
            Elements4 = NULL;
        }

        if( Elements5 )
        {
            DhcpRpcFreeMemory( Elements5 );
            Elements5 = NULL;
        }
        
        if( Error is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_RESERVEDIP_COUNT,
                           nCount,
                           g_ScopeIpAddressUnicodeString);
            break;
        }
        else
            continue;
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_RESERVEDIP,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeShowOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DWORD                       Major;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY   OptionArray = NULL;
    DHCP_RESUME_HANDLE          Resume = 0;
    
    LPWSTR                      pwcTag = NULL;
    LPWSTR                      pwcUser = NULL;
    LPWSTR                      pwcVendor = NULL;
    LPWSTR                      pwcTemp = NULL;

    BOOL                        fUser = FALSE;
    BOOL                        fVendor = FALSE;

    DWORD                       dwRead = 0;
    DWORD                       dwTotal = 0;
    DWORD                       dwCount = 0;
    DWORD                       dwOption = 0;

    BOOL                        fTable = FALSE;

    DWORD                       dwIndex=0;
    enum                        { all=0, user, vendor, both}eDisplay;

    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    
    ScopeInfo.ScopeType = DhcpSubnetOptions;
    ScopeInfo.ScopeInfo.SubnetScopeInfo = g_ScopeIpAddress;

    eDisplay = all;

    if( dwArgCount > dwIndex )
    {
        if( _wcsicmp(ppwcArguments[dwCurrentIndex], L"all") is 0 )
        {
            eDisplay = all;
        }
        else
        {
            while( TRUE )
            {
                LPWSTR  pwcStr = NULL;
        
                if( dwArgCount <= dwIndex )
                    break;
                if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
                    break;
    
                pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
                if( pwcTemp is NULL )
                {
                    Error = ERROR_OUT_OF_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

                pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
                if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
                {
                    if( fUser is TRUE ) //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcUser = NULL;
                        else
                        {
                            pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcUser is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcUser, pwcStr);
                        }
                        eDisplay = user;
                        fUser = TRUE;
                    }
                }
                else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
                {
                    if( fVendor is TRUE )   //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcVendor = NULL;
                        else
                        {
                            pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcVendor is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcVendor, pwcStr);
                        }
                        eDisplay = vendor;
                        fVendor = TRUE;
                    }
                }
                else
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
                    return ERROR_INVALID_PARAMETER;
                }

                if( pwcTemp )
                {
                    DhcpFreeMemory(pwcTemp);
                    pwcTemp = NULL;
                }
        
                dwIndex++;
            }

        }
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }    

    if( fUser && fVendor )
    {
        eDisplay = both;
    }


    switch( eDisplay )
    {
    case all:
        {
            if( g_dwMajorVersion >= CLASS_ID_VERSION )
            {
                Error = DhcpGetAllOptionValues(
                            g_ServerIpAddressUnicodeString,
                            0,
                            &ScopeInfo,
                            &OptionValues
                            );
                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
                    goto CommonReturn;
                }
                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
        
                if( OptionValues )
                {
                    DisplayMessage(g_hModule, MSG_SCOPE_OPTION_ALL, g_ScopeIpAddressUnicodeString);
                    dwOption += PrintAllOptionValues(OptionValues);
                    dwCount = OptionValues->NumElements;
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
            }
            else
            {
                Error = ShowOptionValues4(g_ServerIpAddressUnicodeString,
                                         &ScopeInfo,
                                         &dwOption);
                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
            }
            break;
        }
    default:
        {
            dwRead = dwTotal = dwCount = 0;

            while(TRUE)
            {
                if( g_dwMajorVersion >= CLASS_ID_VERSION )
                {
                    Error = DhcpEnumOptionValuesV5(
                                g_ServerIpAddressUnicodeString,
                                0,
                                pwcUser,
                                pwcVendor,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
                else
                {
                    Error = DhcpEnumOptionValues(
                                g_ServerIpAddressUnicodeString,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
        
                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    Error = NO_ERROR;
                    dwOption += dwCount;
                    break;

                }
                if( ( Error isnot NO_ERROR ) and
                    ( Error isnot ERROR_MORE_DATA ) )
                {
                    goto ErrorReturn;
                }
        
                dwCount += dwRead;

                if( OptionArray )
                {
                    DisplayMessage(g_hModule, MSG_SCOPE_OPTION_ALL, g_ScopeIpAddressUnicodeString);
                    PrintOptionValuesArray(OptionArray);
                    DhcpRpcFreeMemory(OptionArray);
                    OptionArray = NULL;
                }
            
                if( Error is NO_ERROR )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    dwOption += dwCount;
                    break;
                }
                else
                {
                    continue;
                }

            }
            break;
        }
    }
    

CommonReturn:
    if( Error is NO_ERROR )
    {
        if( dwOption is 0 )
        {
            DisplayMessage(g_hModule,
                           MSG_DHCP_NO_OPTIONVALUE_SET);
        }
        
        {
            DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
        }
    }

    if( pwcUser && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_OPTIONVALUE,
                        Error);
    goto CommonReturn;
}


DWORD
HandleScopeShowReservedoptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DWORD                       Major;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY   OptionArray = NULL;
    DHCP_RESUME_HANDLE          Resume = 0;

    LPWSTR                      pwcTag = NULL;
    LPWSTR                      pwcUser = NULL;
    LPWSTR                      pwcVendor = NULL;
    LPWSTR                      pwcTemp = NULL;

    BOOL                        fUser = FALSE;
    BOOL                        fVendor = FALSE;

    DWORD                       dwRead = 0;
    DWORD                       dwTotal = 0;
    DWORD                       dwCount = 0;
    DWORD                       dwOption = 0;
    DWORD                       dwIndex=0;

    enum                        { all=0, user, vendor, both}eDisplay;

    eDisplay = all;
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SCOPE_SHOW_RESERVEDOPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;        
    }


    ScopeInfo.ScopeType = DhcpReservedOptions;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress =
    	g_ScopeIpAddress;
    ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress =
    	StringToIpAddress( ppwcArguments[dwCurrentIndex] );

    if( ScopeInfo.ScopeInfo.ReservedScopeInfo.ReservedIpAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    dwIndex++;

    if( dwArgCount > dwIndex )
    {
        if( _wcsicmp(ppwcArguments[dwCurrentIndex+dwIndex], L"all") is 0 )
        {
            eDisplay = all;
        }
        else
        {
            while( TRUE )
            {
                LPWSTR  pwcStr = NULL;
        
                if( dwArgCount <= dwIndex )
                    break;
                if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
                    break;
    
                pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
                if( pwcTemp is NULL )
                {
                    Error = ERROR_OUT_OF_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

                pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
                if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
                {
                    if( fUser is TRUE ) //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcUser = NULL;
                        else
                        {
                            pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcUser is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcUser, pwcStr);
                        }
                        eDisplay = user;
                        fUser = TRUE;
                    }
                }
                else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
                {
                    if( fVendor is TRUE )   //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcVendor = NULL;
                        else
                        {
                            pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcVendor is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcVendor, pwcStr);
                        }
                        eDisplay = vendor;
                        fVendor = TRUE;
                    }
                }
                else
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
                    return ERROR_INVALID_PARAMETER;
                }

                if( pwcTemp )
                {
                    DhcpFreeMemory(pwcTemp);
                    pwcTemp = NULL;
                }
        
                dwIndex++;
            }

        }
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }    

    if( fUser && fVendor )
    {
        eDisplay = both;
    }

    switch( eDisplay )
    {
    case all:
        {
            if( g_dwMajorVersion >= CLASS_ID_VERSION )
            {
                Error = DhcpGetAllOptionValues(
                            g_ServerIpAddressUnicodeString,
                            0,
                            &ScopeInfo,
                            &OptionValues
                            );
                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
                    goto CommonReturn;
                }

                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
            
                if( OptionValues )
                {
                    DisplayMessage(g_hModule, 
                        MSG_SCOPE_RESERVEDOPTION_ALL, 
                        g_ScopeIpAddressUnicodeString, 
                        ppwcArguments[dwCurrentIndex] );
                    dwOption += PrintAllOptionValues(OptionValues);
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
            }
            else
            {
                Error = ShowOptionValues4(g_ServerIpAddressUnicodeString,
                                          &ScopeInfo,
                                          &dwOption);
                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
            }
            break;
        }
    default:
        {
            while( TRUE )
            {
                if( g_dwMajorVersion >= CLASS_ID_VERSION )
                {
                    Error = DhcpEnumOptionValuesV5(
                                g_ServerIpAddressUnicodeString,
                                0,
                                pwcUser,
                                pwcVendor,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
                else
                {
                    Error = DhcpEnumOptionValues(
                                g_ServerIpAddressUnicodeString,
                                &ScopeInfo,
                                &Resume,
                                ~0,
                                &OptionArray,
                                &dwRead,
                                &dwTotal);
                }
                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    Error = NO_ERROR;
                    dwOption += dwCount;
                    break;
                }

                if( Error isnot NO_ERROR and
                    Error isnot ERROR_MORE_DATA )
                {
                    goto ErrorReturn;
                }
            
                dwCount += dwRead;

                if( OptionArray )
                {
                    DisplayMessage(g_hModule, 
                                   MSG_SCOPE_RESERVEDOPTION_ALL, 
                                   g_ScopeIpAddressUnicodeString, 
                                   ppwcArguments[dwCurrentIndex]);

                    PrintOptionValuesArray(OptionArray);
                    DhcpRpcFreeMemory(OptionArray);
                    OptionArray = NULL;
                }
                
                if( Error is NO_ERROR )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTIONVAL_COUNT,
                                   dwCount);
                    dwOption += dwCount;
                    break;
                                    
                }
                else
                {
                    continue;
                }

            }
            break;
        }
    }    



CommonReturn:
    if( Error is NO_ERROR )
    {
        if( dwOption is 0 ) 
        {
            DisplayMessage(g_hModule,
                           MSG_DHCP_NO_OPTIONVALUE_SET);
        }

        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    }

    if( pwcUser  && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SCOPE_SHOW_RESERVEDOPTIONVALUE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeShowState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD              Error = NO_ERROR;
    LPDHCP_SUBNET_INFO SubnetInfo = NULL;
    BOOL               fActive = TRUE;
    DWORD              MsgId;
    
    Error = DhcpGetSubnetInfo(
                g_ServerIpAddressUnicodeString,
                g_ScopeIpAddress,
                &SubnetInfo );

    if( Error isnot NO_ERROR ) 
    {
        goto ErrorReturn;
    }

    switch( SubnetInfo->SubnetState ) {
    case DhcpSubnetDisabled :
        MsgId = MSG_SCOPE_STATE_NOTACTIVE; break;
    case DhcpSubnetEnabled :
        MsgId = MSG_SCOPE_STATE_ACTIVE; break;
    case DhcpSubnetDisabledSwitched :
        MsgId = MSG_SCOPE_STATE_NOTACTIVE_SWITCHED; break;
    case DhcpSubnetEnabledSwitched :
        MsgId = MSG_SCOPE_STATE_ACTIVE_SWITCHED; break;
    default:
        Error = ERROR_INTERNAL_ERROR;
        goto ErrorReturn;
    }
    
    DisplayMessage(g_hModule, MsgId, g_ScopeIpAddressUnicodeString);

CommonReturn:
    if(Error is NO_ERROR)
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SCOPE_SHOW_STATE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleScopeShowMibinfo(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}

DWORD
HandleScopeShowScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DisplayMessage(g_hModule, 
                   MSG_SCOPE_SERVER, 
                   g_ScopeIpAddressUnicodeString, 
                   g_ServerIpAddressUnicodeString);
    return NO_ERROR;
}


DWORD
ProcessBootpParameters(
    DWORD                    cArgs,
    LPTSTR                   *ppszArgs,
    DHCP_IP_RESERVATION_V4   *pReservation
)
{
    DWORD dwResult = ERROR_SUCCESS;


    if ( cArgs > 2 )
    {
        // user specified the allowed client type

        if ( !STRICMP( ppszArgs[ 2 ], TEXT("BOOTP") ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_BOOTP;
        }
        else if ( !STRICMP ( ppszArgs[ 2 ], TEXT("DHCP") ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_DHCP;
        }
        else if ( !STRICMP ( ppszArgs[ 2 ], TEXT("BOTH") ) )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_BOTH;
        }
        else if ( wcslen(ppszArgs[2]) is 0 )
        {
            pReservation->bAllowedClientTypes = CLIENT_TYPE_BOTH;
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_RESERVATION_TYPE);
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        // allow dhcp clients by default.
        pReservation->bAllowedClientTypes = CLIENT_TYPE_DHCP;
        return ERROR_SUCCESS;
    }

    return dwResult;
}

DWORD
RemoveOptionValue(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
)
{
    DWORD                          MajorVersion;
    DWORD                          Error;

    if( g_dwMajorVersion >= CLASS_ID_VERSION ) 
    {
        return DhcpRemoveOptionValueV5(
                            ServerAddress,
                            Flags,
                            OptionID,
                            ClassName,
                            VendorName,
                            ScopeInfo
                            );
    }

    // incorrect version, just do like before..

    return DhcpRemoveOptionValue(
                            ServerAddress,
                            OptionID,
                            ScopeInfo
                            );
}

VOID
PrintRange(
    DHCP_SUBNET_ELEMENT_TYPE Type,
    DHCP_IP_ADDRESS Start,
    DHCP_IP_ADDRESS End,
    ULONG BootpAllocated,
    ULONG MaxBootpAllowed,
    BOOL  fExclude
)
{
    WCHAR IpStart[20] = {L'\0'};
    WCHAR IpEnd[20] = {L'\0'};
    DWORD dw = 0;

    wsprintf(IpStart, L"   %s", IpAddressToString(Start));
    for( dw=wcslen(IpStart); dw<20; dw++)
    {
        IpStart[dw] = L' ';
    }
    IpStart[19] = L'\0';

    wsprintf(IpEnd, L"   %s", IpAddressToString(End));
    for( dw=wcslen(IpEnd); dw<20; dw++)
    {
        IpEnd[dw] = L' ';
    }
    IpEnd[19] = L'\0';

    if( FALSE is fExclude )
    {
        switch(Type ) 
        {
        case DhcpIpRanges : 
            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_INFO_DHCP,
                           IpStart,
                           IpEnd);
            break;
        case DhcpIpRangesDhcpOnly : 
            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_INFO_DHCPONLY,
                           IpStart,
                           IpEnd);
            break;
        case DhcpIpRangesDhcpBootp: 
            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_INFO_DHCPBOOTP,
                           IpStart,
                           IpEnd);
            break;
        case DhcpIpRangesBootpOnly:
            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_INFO_BOOTP,
                           IpStart,
                           IpEnd);
            break;
        case DhcpExcludedIpRanges:
            break;
        default: 
            DisplayMessage(g_hModule,
                           MSG_SCOPE_IPRANGE_INFO_UNKNOWN,
                           IpStart,
                           IpEnd);
            break;
        }
    }
    else
    {
        DisplayMessage(g_hModule, 
                       MSG_SCOPE_EXCLUDERANGE_INFO,
                       IpStart,
                       IpEnd);

    }
}


VOID
PrintClientInfo(
    LPDHCP_CLIENT_INFO_V4 ClientInfo,
    DWORD Level
)
{
    DWORD           i = 0, 
                    dwError = NO_ERROR;
    DWORD           DataLength = 0;
    LPBYTE          Data = NULL;
    FILETIME        ftTime = {0};
    WCHAR           *pwszClientType = NULL;
    WCHAR           IpAddress[17] = {L'\0'};
    WCHAR           SubnetMask[17] = {L'\0'};
    WCHAR           HardwareAdd[256*4] = {L'\0'};
    LPWSTR          pwszLease = NULL;
    WCHAR           ClientType[13] = {L'\0'};
    LPWSTR          pwcTemp = NULL;
    DWORD           dwTemp = 0, MsgId;

    enum {Time=0, Never, Inactive}Type = Time;

    DWORD dw = 0;

    pwcTemp = IpAddressToString(ClientInfo->ClientIpAddress);
    if( pwcTemp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    dwTemp = wcslen(pwcTemp);

    wcsncat(IpAddress, 
            pwcTemp,
            ( 16 < dwTemp ) ? 16 : dwTemp );


    for(dw=wcslen(IpAddress); dw<17; dw++)
    {
        IpAddress[dw] = L' ';
    }
    
    IpAddress[16] = L'\0';

    DhcpFreeMemory(pwcTemp);
    pwcTemp = NULL;

    pwcTemp = IpAddressToString(ClientInfo->SubnetMask);

    if( pwcTemp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    dwTemp = wcslen(pwcTemp);


    wcscpy(SubnetMask, L" ");
   
    wcsncat(SubnetMask,
            pwcTemp,
            ( dwTemp > 16 ) ? 16 : dwTemp);
   
    for(dw=wcslen(SubnetMask); dw<17; dw++)
    {
        SubnetMask[dw] = L' ';
    }

    SubnetMask[16] = L'\0';

    DhcpFreeMemory(pwcTemp);
    pwcTemp = NULL;

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    
    Data = ClientInfo->ClientHardwareAddress.Data;
    
    if( Data is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    i = 0;
    while ( i < DataLength )
    {
        wsprintf(HardwareAdd + wcslen(HardwareAdd), L"%.2x-", (DWORD)Data[i]);
        i++;
    }

    for( dw=wcslen(HardwareAdd)-1;dw<3*10; dw++)
    {
        HardwareAdd[dw] = L' ';
    }

    HardwareAdd[3*10-10] = L'\0';

    switch( ClientInfo->bClientType )
    {
        case CLIENT_TYPE_NONE:
            pwszClientType= L"N";
            break;

        case CLIENT_TYPE_DHCP:
            pwszClientType = L"D";
            break;

        case CLIENT_TYPE_BOOTP:
            pwszClientType = L"B";
            break;

        case CLIENT_TYPE_UNSPECIFIED:
        default:
            pwszClientType = L"U";
            break;
        
        case CLIENT_TYPE_RESERVATION_FLAG:
            pwszClientType = L"R";
            break;
    }

    for( dw=0; dw<13; dw++ )
        ClientType[dw] = L' ';

    ClientType[12] = L'\0';

    if( IsBadStringPtr(pwszClientType, MAX_STRING_LEN) is FALSE )
    {
        dwTemp = wcslen(pwszClientType);
        dwTemp = (dwTemp>12) ? 12 : dwTemp;

        wcsncpy(ClientType,
                pwszClientType,
                dwTemp);

        for( dw=wcslen(ClientType); dw<13; dw++ )
            ClientType[dw] = L' ';

        ClientType[12] = L'\0';                
    }
    
    if( Data is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }
    
    ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseExpires);

 
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseExpires.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        Type = Never;
    }
    else if (ClientInfo->ClientLeaseExpires.dwLowDateTime ==
             DHCP_DATE_TIME_ZERO_LOW &&
             ClientInfo->ClientLeaseExpires.dwHighDateTime ==
             DHCP_DATE_TIME_ZERO_HIGH )
    {
        Type = Inactive;
    }
    else
    {
        pwszLease = GetDateTimeString(ftTime,
                                      TRUE,
                                      (int*)&Type);
    }


    if( Level == 0 ) {
        switch(Type)
        {
        case Never:
            MsgId = MSG_SCOPE_CLIENT_INFO_NEVER;
            break;
        case Inactive :
            MsgId = MSG_SCOPE_CLIENT_INFO_INACTIVE;
            break;
        case Time :
        default :
            MsgId = MSG_SCOPE_CLIENT_INFO;
            break;
        }
    } else {
        switch(Type)
        {
        case Never:
            MsgId = MSG_SCOPE_CLIENT_INFO2_NEVER;
            break;
        case Inactive :
            MsgId = MSG_SCOPE_CLIENT_INFO2_INACTIVE;
            break;
        case Time :
        default :
            MsgId = MSG_SCOPE_CLIENT_INFO2;
            break;
        }
    }
    
    DisplayMessage(g_hModule,
                   MsgId,
                   IpAddress,
                   SubnetMask,
                   HardwareAdd,
                   pwszClientType,
                   pwszLease ? pwszLease : L" ",
                   ClientInfo->ClientName ?
                   ClientInfo->ClientName : L""
        );

    if( pwszLease )
    {
        DhcpFreeMemory(pwszLease);
        pwszLease = NULL;
    }
}

VOID
PrintClientInfoV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    DWORD       i = 0;
    DWORD       DataLength = 0;
    LPBYTE      Data = NULL;
    FILETIME    ftTime = {0};
    WCHAR       *pwszClientType = NULL;
    WCHAR       IpAddress[17] = {L'\0'};
    WCHAR       SubnetMask[17] = {L'\0'};
    WCHAR       HardwareAdd[256*4] = {L'\0'};
    LPWSTR      pwszLease = NULL;
    WCHAR       ClientType[13] = {L'\0'};
    DWORD       dwTemp = 0;
    LPWSTR      pwcTemp = NULL;
    enum {Time=0, Never, Inactive}Type = Time;

    DWORD       dw = 0;

    pwcTemp = IpAddressToString(ClientInfo->ClientIpAddress);
    if( pwcTemp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    dwTemp = wcslen(pwcTemp);

    wcsncat(IpAddress, 
            pwcTemp,
            ( dwTemp > 16 ) ? 16 : dwTemp );

    
    for(dw=wcslen(IpAddress); dw<17; dw++)
    {
        IpAddress[dw] = L' ';
    }
    IpAddress[16] = L'\0';

    DhcpFreeMemory(pwcTemp);
    pwcTemp = NULL;
    dwTemp = 0;

    pwcTemp = IpAddressToString(ClientInfo->SubnetMask);

    if( pwcTemp is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    dwTemp = wcslen(pwcTemp);

    wcscpy(SubnetMask, L" ");

    wcsncat(SubnetMask,
            pwcTemp,
            ( dwTemp > 16 ) ? 16 : dwTemp );

    
    for(dw=wcslen(SubnetMask); dw<17; dw++)
    {
        SubnetMask[dw] = L' ';
    }
    SubnetMask[16] = L'\0';

    DhcpFreeMemory(pwcTemp);
    pwcTemp = NULL;
    dwTemp = 0;

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    
    if( Data is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
    }

    i = 0;
    dwTemp = DataLength; 

    while ( i < dwTemp )
    {
        wsprintf(HardwareAdd + wcslen(HardwareAdd), L"%.2x-", (DWORD)Data[i]);
        i++;
    }

    for( dw=wcslen(HardwareAdd)-1;dw<3*10; dw++)
    {
        HardwareAdd[dw] = L' ';
    }
    HardwareAdd[3*10-10] = L'\0';

    switch( ClientInfo->bClientType )
    {
        case CLIENT_TYPE_NONE:
            pwszClientType= L"N";
            break;

        case CLIENT_TYPE_DHCP:
            pwszClientType = L"D";
            break;

        case CLIENT_TYPE_BOOTP:
            pwszClientType = L"B";
            break;

        case CLIENT_TYPE_UNSPECIFIED:
        default:
            pwszClientType = L"U";
            break;
        
        case CLIENT_TYPE_RESERVATION_FLAG:
            pwszClientType = L"R";
            break;
    }

    if( IsBadStringPtr(pwszClientType, MAX_STRING_LEN) is FALSE )
    {
        dwTemp = wcslen(pwszClientType);

        wcsncpy(ClientType,
                pwszClientType,
                ( dwTemp > 12 ) ? 12 : dwTemp );
        for( dw=wcslen(ClientType); dw<13; dw++ )
            ClientType[dw] = L' ';

        ClientType[12] = L'\0';                
    }
    
    if( Data is NULL )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_DISPLAY_CLIENTS);
        return;
    }

    ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseExpires);
 
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
            DHCP_DATE_TIME_INFINIT_LOW &&
         ClientInfo->ClientLeaseExpires.dwHighDateTime ==
            DHCP_DATE_TIME_INFINIT_HIGH )
    {
        Type = Never;
    }
    else if (ClientInfo->ClientLeaseExpires.dwLowDateTime ==
             DHCP_DATE_TIME_ZERO_LOW &&
             ClientInfo->ClientLeaseExpires.dwHighDateTime ==
             DHCP_DATE_TIME_ZERO_HIGH )
    {
        Type = Inactive;
    }
    else
    {
        Type = 0;
        pwszLease = GetDateTimeString(ftTime,
                                      TRUE,
                                      (int*)&Type);

    }


    switch(Type)
    {
    case Never:
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_CLIENT_INFO_NEVER,
                           IpAddress,
                           SubnetMask,
                           HardwareAdd,
                           pwszClientType);
            break;
        }
    case Inactive:
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_CLIENT_INFO_INACTIVE,
                           IpAddress,
                           SubnetMask,
                           HardwareAdd,
                           pwszClientType);
            break;
        }
    case Time:
    default:
        {
            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENT_INFO,
                           IpAddress,
                           SubnetMask,
                           HardwareAdd,
                           pwszLease ? pwszLease : L" ",
                           pwszClientType);
        }
        break;
    }
    if( pwszLease )
    {
        DhcpFreeMemory(pwszLease);
        pwszLease = NULL;
    }
}

VOID
PrintClientInfoShort(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
{
    FILETIME ftTime = {0};
    LPWSTR   pwszTime = NULL;

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT,
                GlobalClientCount++,
                IpAddressToString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );

    ftTime = *(FILETIME *)(&ClientInfo->ClientLeaseExpires);
    
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseExpires.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_DURATION_STR);
    }
    else
    {
        int i = 0;
        pwszTime = GetDateTimeString(ftTime,
                                     FALSE,
                                     &i);

        DisplayMessage(g_hModule,
                       MSG_SCOPE_CLIENT_DURATION_DATE_EXPIRES,
                       pwszTime ? pwszTime : L" ");

        if( pwszTime )
        {
            DhcpFreeMemory(pwszTime);
            pwszTime = NULL;
        }
                          
    }
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}

VOID
PrintClientInfoShortV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT,
                GlobalClientCount++,
                IpAddressToString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );
    if ( ClientInfo->ClientLeaseExpires.dwLowDateTime ==
        DHCP_DATE_TIME_INFINIT_LOW &&
     ClientInfo->ClientLeaseExpires.dwHighDateTime ==
        DHCP_DATE_TIME_INFINIT_HIGH )
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_DURATION_STR);
    }
    else if( FileTimeToLocalFileTime(
            (FILETIME *)(&ClientInfo->ClientLeaseExpires),
            &LocalTime) ) 
    {

        if( FileTimeToSystemTime( &LocalTime, &SystemTime ) ) 
        {

            DisplayMessage(g_hModule, 
                           MSG_SCOPE_CLIENT_DURATION_DATE_EXPIRES,
                           SystemTime.wMonth,
                           SystemTime.wDay,
                           SystemTime.wYear,
                           SystemTime.wHour,
                           SystemTime.wMinute,
                           SystemTime.wSecond );
        }
        else 
        {
            DisplayMessage(g_hModule, EMSG_SCOPE_INTERNAL_ERROR);
        }
    }
    else 
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_INTERNAL_ERROR);
    }
    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_STATE, ClientInfo->AddressState);
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}

VOID
PrintClientInfoShort1(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT,
                GlobalClientCount++,
                IpAddressToString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;
    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS);
    for( i = 0; i < DataLength; i++ ) 
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS_FORMAT, (DWORD)Data[i]);
        if((i+1)<DataLength)
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_DASH);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}


VOID
PrintClientInfoShort1V5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
    )
{
    DWORD i;
    DWORD DataLength;
    LPBYTE Data;

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT,
                GlobalClientCount++,
                IpAddressToString(ClientInfo->ClientIpAddress),
                ClientInfo->ClientName
                );

    DataLength = ClientInfo->ClientHardwareAddress.DataLength;
    Data = ClientInfo->ClientHardwareAddress.Data;

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS);

    for( i = 0; i < DataLength; i++ ) 
    {
        DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_HWADDRESS_FORMAT, (DWORD)Data[i]);
        if((i+1)<DataLength)
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_DASH);
    }

    DisplayMessage(g_hModule, MSG_SCOPE_CLIENT_STATE, ClientInfo->AddressState);
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}

LPWSTR
GetDynBootpClassName()
{
    DWORD                          Error = NO_ERROR;
    DWORD                          nRead, nTotal, nCount;
    DHCP_RESUME_HANDLE             ResumeHandle;
    LPDHCP_CLASS_INFO_ARRAY        ClassInfoArray = NULL;
    LPWSTR                         pwszClass = NULL;


    while(TRUE)
    {
        Error = DhcpEnumClasses(
                    g_ServerIpAddressUnicodeString,
                    0,
                    &ResumeHandle,
                    ~0,
                    &ClassInfoArray,
                    &nRead,
                    &nTotal
                );

        if( Error isnot NO_ERROR )
        {
            return NULL;
        }
       
        for( nCount = 0; nCount < ClassInfoArray->NumElements; nCount ++ )
        {
            if( ClassInfoArray->Classes[nCount].ClassData )
            {              
                if( strlen(DHCP_BOOTP_CLASS_TXT) is ClassInfoArray->Classes[nCount].ClassDataLength )
                {                    
                    if( memcmp(DHCP_BOOTP_CLASS_TXT, 
                               ClassInfoArray->Classes[nCount].ClassData, 
                               strlen(DHCP_BOOTP_CLASS_TXT))is 0 )
                    {
                        pwszClass = DhcpAllocateMemory( ( wcslen(ClassInfoArray->Classes[nCount].ClassName) + 1 )*sizeof(WCHAR));
                        if( pwszClass is NULL )
                        {
                            DhcpRpcFreeMemory(ClassInfoArray);
                            ClassInfoArray = NULL;
                            return NULL;
                        }
                    
                        wcscpy(pwszClass, ClassInfoArray->Classes[nCount].ClassName);
                        DhcpRpcFreeMemory(ClassInfoArray);
                        ClassInfoArray = NULL;
                        return pwszClass;
                    }
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\srvrmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.c

Abstract:

    SRVR Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/
#include "precomp.h"

#define MAX_FQDN_SIZE 256

//
// The DHCP manager's commands are broken into 2 sets
//      - The commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        SHOW or SET.  This is not for any technical reason - only for
//        staying with the semantics used in netsh with which it will be 
//		  integrated
//      - The commands which are supported by the subcontext commands of 
//        the server. The subcontext supported by DHCP is Server.
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// NOTE: Since we have only one entry per group, currently, we really didnt
// need command groups. This is done for later extensibility.
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//

#define CONTEXT_DHCP            L"Dhcp"
#define CONTEXT_SERVER          L"Dhcp Server"
#define CONTEXT_SCOPE           L"Scope"
#define CONTEXT_MSCOPE          L"MScope"

extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern BOOL     g_fServer = FALSE;
extern PWCHAR   g_pwszServer = NULL;


LPWSTR  g_CurrentSubContext = NULL;

ULONG   g_ulSrvrInitCount = 0;
DWORD   g_dwMajorVersion = 0;
DWORD   g_dwMinorVersion = 0;

BOOL   g_IsSubcontext = FALSE;

DHCPMON_SUBCONTEXT_TABLE_ENTRY  g_SrvrSubContextTable[] =
{
    {L"Scope", HLP_SRVR_CONTEXT_SCOPE, HLP_SRVR_CONTEXT_SCOPE_EX, ScopeMonitor},
    {L"MScope", HLP_SRVR_CONTEXT_MSCOPE, HLP_SRVR_CONTEXT_MSCOPE_EX, MScopeMonitor},
};



CMD_ENTRY  g_SrvrAddCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_ADD_CLASS, HandleSrvrAddClass),
    CREATE_CMD_ENTRY(SRVR_ADD_MSCOPE, HandleSrvrAddMscope),
    CREATE_CMD_ENTRY(SRVR_ADD_OPTIONDEF, HandleSrvrAddOptiondef),
    CREATE_CMD_ENTRY(SRVR_ADD_SCOPE, HandleSrvrAddScope),
};

CMD_ENTRY  g_SrvrDeleteCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_DELETE_CLASS, HandleSrvrDeleteClass),
    CREATE_CMD_ENTRY(SRVR_DELETE_DNSCREDENTIALS, HandleSrvrDeleteDnsCredentials),
    CREATE_CMD_ENTRY(SRVR_DELETE_MSCOPE, HandleSrvrDeleteMscope),
    CREATE_CMD_ENTRY(SRVR_DELETE_OPTIONDEF, HandleSrvrDeleteOptiondef),
    CREATE_CMD_ENTRY(SRVR_DELETE_OPTIONVALUE, HandleSrvrDeleteOptionvalue),
    CREATE_CMD_ENTRY(SRVR_DELETE_SCOPE, HandleSrvrDeleteScope),
    CREATE_CMD_ENTRY(SRVR_DELETE_SUPERSCOPE, HandleSrvrDeleteSuperscope),
};

CMD_ENTRY g_SrvrRedoCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_REDO_AUTH, HandleSrvrRedoAuth),
    CREATE_CMD_ENTRY(SRVR_INITIATE_RECONCILE, HandleSrvrInitiateReconcile),
};

CMD_ENTRY g_SrvrExportCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_EXPORT, HandleSrvrExport),
};

CMD_ENTRY g_SrvrImportCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_IMPORT, HandleSrvrImport),
};

CMD_ENTRY g_SrvrSetCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_SET_AUDITLOG, HandleSrvrSetAuditlog),
    CREATE_CMD_ENTRY(SRVR_SET_BACKUPINTERVAL, HandleSrvrSetBackupinterval),
    CREATE_CMD_ENTRY(SRVR_SET_BACKUPPATH, HandleSrvrSetBackuppath),
    CREATE_CMD_ENTRY(SRVR_SET_DATABASECLEANUPINTERVAL, HandleSrvrSetDatabasecleanupinterval),
    CREATE_CMD_ENTRY(SRVR_SET_DATABASELOGGINGFLAG, HandleSrvrSetDatabaseloggingflag),
    CREATE_CMD_ENTRY(SRVR_SET_DATABASENAME, HandleSrvrSetDatabasename),
    CREATE_CMD_ENTRY(SRVR_SET_DATABASEPATH, HandleSrvrSetDatabasepath),
    CREATE_CMD_ENTRY(SRVR_SET_DATABASERESTOREFLAG, HandleSrvrSetDatabaserestoreflag),
    CREATE_CMD_ENTRY(SRVR_SET_DETECTCONFLICTRETRY, HandleSrvrSetDetectconflictretry),
    CREATE_CMD_ENTRY(SRVR_SET_DNSCREDENTIALS, HandleSrvrSetDnsCredentials),
    CREATE_CMD_ENTRY(SRVR_SET_DNSCONFIG, HandleSrvrSetDnsconfig),
    CREATE_CMD_ENTRY(SRVR_SET_OPTIONVALUE, HandleSrvrSetOptionvalue),
    CREATE_CMD_ENTRY(SRVR_SET_SERVER, HandleSrvrSetServer),
    CREATE_CMD_ENTRY(SRVR_SET_USERCLASS, HandleSrvrSetUserclass),
    CREATE_CMD_ENTRY(SRVR_SET_VENDORCLASS, HandleSrvrSetVendorclass),
};

CMD_ENTRY g_SrvrShowCmdTable[] = {
    CREATE_CMD_ENTRY(SRVR_SHOW_ALL, HandleSrvrShowAll),
    CREATE_CMD_ENTRY(SRVR_SHOW_AUDITLOG, HandleSrvrShowAuditlog),
    CREATE_CMD_ENTRY(SRVR_SHOW_BINDINGS, HandleSrvrShowBindings),
    CREATE_CMD_ENTRY(SRVR_SHOW_CLASS, HandleSrvrShowClass),
    CREATE_CMD_ENTRY(SRVR_SHOW_DETECTCONFLICTRETRY, HandleSrvrShowDetectconflictretry),
    CREATE_CMD_ENTRY(SRVR_SHOW_DNSCONFIG, HandleSrvrShowDnsconfig),
    CREATE_CMD_ENTRY(SRVR_SHOW_DNSCREDENTIALS, HandleSrvrShowDnsCredentials),
    CREATE_CMD_ENTRY(SRVR_SHOW_MIBINFO, HandleSrvrShowMibinfo),
    CREATE_CMD_ENTRY(SRVR_SHOW_MSCOPE, HandleSrvrShowMscope),
    CREATE_CMD_ENTRY(SRVR_SHOW_OPTIONDEF, HandleSrvrShowOptiondef),
    CREATE_CMD_ENTRY(SRVR_SHOW_OPTIONVALUE, HandleSrvrShowOptionvalue),
    CREATE_CMD_ENTRY(SRVR_SHOW_SCOPE, HandleSrvrShowScope),
    CREATE_CMD_ENTRY(SRVR_SHOW_SERVER, HandleSrvrShowServer),
    CREATE_CMD_ENTRY(SRVR_SHOW_SERVERCONFIG, HandleSrvrShowServerconfig),
    CREATE_CMD_ENTRY(SRVR_SHOW_SERVERSTATUS, HandleSrvrShowServerstatus),
    CREATE_CMD_ENTRY(SRVR_SHOW_USERCLASS, HandleSrvrShowUserclass),
    CREATE_CMD_ENTRY(SRVR_SHOW_VENDORCLASS, HandleSrvrShowVendorclass),
    CREATE_CMD_ENTRY(SRVR_SHOW_VERSION, HandleSrvrShowVersion),
};


CMD_GROUP_ENTRY g_SrvrCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_SrvrAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_SrvrDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_EXPORT, g_SrvrExportCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_IMPORT, g_SrvrImportCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_REDO, g_SrvrRedoCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_SrvrSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_SrvrShowCmdTable),
};


CMD_ENTRY g_SrvrCmds[] = 
{
    CREATE_CMD_ENTRY(SRVR_LIST, HandleSrvrList),
    CREATE_CMD_ENTRY(SRVR_DUMP, HandleSrvrDump),
    CREATE_CMD_ENTRY(SRVR_HELP1, HandleSrvrHelp),
    CREATE_CMD_ENTRY(SRVR_HELP2, HandleSrvrHelp),
    CREATE_CMD_ENTRY(SRVR_HELP3, HandleSrvrHelp),
    CREATE_CMD_ENTRY(SRVR_HELP4, HandleSrvrHelp),
};


ULONG g_ulSrvrNumSubContext = sizeof(g_SrvrSubContextTable)/sizeof(DHCPMON_SUBCONTEXT_TABLE_ENTRY);
ULONG g_ulSrvrNumTopCmds = sizeof(g_SrvrCmds)/sizeof(CMD_ENTRY);
ULONG g_ulSrvrNumGroups = sizeof(g_SrvrCmdGroups)/sizeof(CMD_GROUP_ENTRY);

DWORD
WINAPI
SrvrCommit(
    IN  DWORD   dwAction
)
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Srvr current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}


DWORD
WINAPI
SrvrMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD                   dwError = NO_ERROR;
    DWORD                   dwIndex, i, j, k;
    DWORD                   dwIsServer = 0;
    BOOL                    bFound = FALSE;
    PFN_HANDLE_CMD          pfnHandler = NULL;
    PNS_CONTEXT_ENTRY_FN    pfnHelperEntryPt;
    PNS_CONTEXT_DUMP_FN     pfnHelperDumpPt;
    WCHAR                   wcSvrTemp[MAX_IP_STRING_LEN+1] = {L'\0'};
    BOOL                    fTemp = FALSE;                            
    DWORD                   dwNumMatched;
    DWORD                   dwCmdHelpToken = 0;
    DWORD                   dw = 0;

    if(dwArgCount is 1)
    {
        //Hmm! Hasn't passed any Server Info. Set the server to the
        // value pwsRouter
        WCHAR ServerInfo[1000] = L"\\\\";

        if( pwszMachine and
            wcslen(pwszMachine) > 2 and
            wcsncmp(pwszMachine, L"\\\\", 2) and
            IsIpAddress(pwszMachine) is FALSE )
        {
            wcscpy(&ServerInfo[2], pwszMachine );
            pwszMachine = ServerInfo;
        }

        if( FALSE is SetServerInfo(pwszMachine) )
        {
            return GetLastError();
        }
        else
        {
            g_fServer = TRUE;
            //wcscpy(pwcNewContext, L"dhcp server");
            return ERROR_CONTEXT_SWITCH;
        }
    }

    dwIndex = 1;

    //If it is a help for server command
    if( IsHelpToken(ppwcArguments[dwIndex]) is TRUE and
        g_fServer is FALSE )
    {
        DisplayMessage(g_hModule, HLP_DHCP_CONTEXT_SERVER_EX);
        dwError = NO_ERROR;
        goto CleanUp;
    }

    //Is it a servername or address?
    if( IsValidServer(ppwcArguments[dwIndex]) )
    {
        if( g_fServer is TRUE and
            dwArgCount > 2 )
        {
            wcscpy(wcSvrTemp, g_ServerIpAddressUnicodeString);
            fTemp = TRUE;
        }
        if( FALSE is SetServerInfo(ppwcArguments[dwIndex]) )
        {
            dwError = GetLastError();
            goto CleanUp;
        }

        pwcNewContext[wcslen(pwcNewContext)- wcslen(ppwcArguments[dwIndex]) -1 ] = L'\0';
        
        dw++;
        dwIndex++;
        dwIsServer++;
        g_fServer = TRUE;

    }
    else if( g_fServer is FALSE )
    {
        WCHAR ServerInfo[1000] = L"\\\\";

        if( pwszMachine and 
            wcslen(pwszMachine) > 2 and
            wcsncmp(pwszMachine, L"\\\\", 2) and
            IsIpAddress(pwszMachine) is FALSE )
        {
            wcscpy(&ServerInfo[2], pwszMachine );
            pwszMachine = ServerInfo;
        }
        
        if( FALSE is SetServerInfo(pwszMachine) )
        {
            dwError = GetLastError();
            goto CleanUp;
        }
        g_fServer = TRUE;
    }

    
    if( dwIndex >= dwArgCount )
    {            
        dwError = ERROR_CONTEXT_SWITCH;
        //wcscpy(pwcNewContext, L"dhcp server");
        goto CleanUp;
    }

    //Is it a top level(non Group command)?
    for(i=0; i<g_ulSrvrNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_SrvrCmds[i].pwszCmdToken))
        {
            bFound = TRUE;

            pfnHandler = g_SrvrCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_SrvrCmds[i].dwCmdHlpToken;
            
            dwIndex++;

            break;
        }
    }


    if(bFound)
    {
        if(dwArgCount > 3 && IsHelpToken(ppwcArguments[dwIndex]))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);

            dwError = NO_ERROR;
            goto CleanUp;
        }
        
        dwIndex++;

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments+dw, dwIndex, dwArgCount-dw, dwFlags, pvData, &bFound);

        goto CleanUp;
    }
    //Is it meant for any of the subcontext?
    for(i = 0; i<g_ulSrvrNumSubContext; i++)
    {
        if( MatchToken(ppwcArguments[dwIndex], g_SrvrSubContextTable[i].pwszContext) )
        {
            bFound = TRUE;
            dwIndex++;
            pfnHelperEntryPt = g_SrvrSubContextTable[i].pfnEntryFn;
            DEBUG("Meant for subcontext under it");
            break;
        }
    }

    if( bFound )    //Subcontext
    {
        dwError = (pfnHelperEntryPt)(pwszMachine,
                                     ppwcArguments+1+dw,
                                     dwArgCount-1 -dw,
                                     dwFlags,
                                     pvData,
                                     pwcNewContext);
        if( dwError is ERROR_CONTEXT_SWITCH )
        {
            if( g_CurrentSubContext isnot NULL )
            {
                memset(g_CurrentSubContext, 0x00, (wcslen(g_CurrentSubContext)+1)*sizeof(WCHAR));
                DhcpFreeMemory(g_CurrentSubContext);
                g_CurrentSubContext = NULL;
            }

            g_CurrentSubContext = DhcpAllocateMemory((wcslen(g_SrvrSubContextTable[i].pwszContext)+1)*sizeof(WCHAR));
            if( g_CurrentSubContext is NULL )
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanUp;
            }
            g_CurrentSubContext[0] = L'\0';
            wcscpy(g_CurrentSubContext, g_SrvrSubContextTable[i].pwszContext);
            g_IsSubcontext = TRUE;
        }

        goto CleanUp;
    }

    bFound = FALSE;

    //It is not a non Group Command. Then is it a config command for the manager?
    for(i = 0; (i < g_ulSrvrNumGroups) and !bFound; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_SrvrCmdGroups[i].pwszCmdGroupToken))
        {
            //
            // Command matched entry i, so look at the table of sub commands 
            // for this command
            //
            if( dwArgCount > dwIndex+1 )
            {
                for (j = 0; j < g_SrvrCmdGroups[i].ulCmdGroupSize; j++)
                {
                    if (MatchCmdLine(ppwcArguments+dwIndex,
                                      dwArgCount - 1,
                                      g_SrvrCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                      &dwNumMatched))
                    {
                        bFound = TRUE;
                
                        pfnHandler = g_SrvrCmdGroups[i].pCmdGroup[j].pfnCmdHandler;
                
                        dwCmdHelpToken = g_SrvrCmdGroups[i].pCmdGroup[j].dwCmdHlpToken;

                        //
                        // break out of the for(j) loop
                        //
                        dwIndex+=dwNumMatched;
                        break;
                    }
                }
            }

            if(!bFound)
            {
                //
                // We matched the command group token but none of the
                // sub commands
                //

                DisplayMessage(g_hModule, 
                               EMSG_SRVR_INCOMPLETE_COMMAND);

                for (j = 0; j < g_SrvrCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                             g_SrvrCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                    
					DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                }

                dwError = ERROR_INVALID_PARAMETER;
                goto CleanUp;
            }
            else
            {
                //
                // quit the for(i)
                //

                break;
            }
        }
    }




    if (!bFound)
    {
        //
        // Command not found. 
        //
        if( _wcsicmp(ppwcArguments[dwIndex], L"..") is 0 )
        {
            if( g_IsSubcontext is FALSE )
            {
                if(g_pwszServer)
                {
                    DhcpFreeMemory(g_pwszServer);
                    g_pwszServer = NULL;
                }
                memset(g_ServerIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
                memset(g_ServerIpAddressAnsiString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(CHAR));
                g_fServer = FALSE;
            }
            else
            {
                g_IsSubcontext = FALSE;
            }
        }

        dwError = ERROR_CMD_NOT_FOUND;
        goto CleanUp;
    }

    //
    // See if it is a request for help.
    //

    dwNumMatched += dwIsServer;

    if (dwNumMatched < (dwArgCount - 1) &&
        IsHelpToken(ppwcArguments[dwNumMatched + 1]))
    {
        DisplayMessage(g_hModule, dwCmdHelpToken);

        dwError = NO_ERROR;
        goto CleanUp;
    }
    
    //
    // Call the parsing routine for the command
    //

    dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount - dwIndex, dwFlags, pvData, &bFound);

    if( dwError is ERROR_CONTEXT_SWITCH )
    {
        if( ( _wcsicmp(g_CurrentSubContext, CONTEXT_SCOPE) is 0 ) or
            ( _wcsicmp(g_CurrentSubContext, CONTEXT_MSCOPE) is 0 ) )
        {
            //pwcNewContext[0] = L'\0';
            //wcscpy(pwcNewContext, CONTEXT_SERVER);
            dwError = ERROR_CONTEXT_SWITCH;

        }
        else
        {
            dwError = NO_ERROR;
        }
        goto CleanUp;
    }
CleanUp:
    if( fTemp )
    {
        fTemp = SetServerInfo(wcSvrTemp);
    }
    return dwError;
}



DWORD
WINAPI
SrvrUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulSrvrInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}

BOOL
SetServerInfo(
    IN  LPCWSTR  pwszServerInfo
)
{
    BOOL    fReturn = TRUE;
    DWORD   dwComputerNameLen = 0;
    LPSTR   pszComputerName = NULL;
    LPWSTR  pwszComputerName = NULL;
    struct  hostent * lpHostEnt = NULL;
    BYTE    pbAdd[4];
    char    szAdd[4];
    DWORD   dwHostName = 0;
    DWORD   dwIpAddress = 0;
    DWORD   i = 0, nLen = 0;
    CHAR    TempIp[MAX_IP_STRING_LEN+1] = {L'\0'};
    CHAR    cTempIp[MAX_IP_STRING_LEN+1] = {L'\0'};
    WCHAR   wTempIp[MAX_IP_STRING_LEN+1] = {L'\0'};
    LPWSTR  pwszTempServer = NULL;
    DWORD   dwError = NO_ERROR;

    if( strlen(g_ServerIpAddressAnsiString) > 7 and
        IsIpAddress(g_ServerIpAddressUnicodeString) is TRUE and
        g_pwszServer isnot NULL )
    {
        strcpy(cTempIp, g_ServerIpAddressAnsiString);
        wcscpy(wTempIp, g_ServerIpAddressUnicodeString);
        pwszTempServer = g_pwszServer;
    }
    
    //If no server information is passed, assume local server.
    if( pwszServerInfo is NULL )
    {
        if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                              NULL,
                              &dwComputerNameLen) )
        {
            pwszComputerName = DhcpAllocateMemory((dwComputerNameLen+1)*sizeof(WCHAR));

            if(pwszComputerName is NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            
            dwComputerNameLen++;
            if( !GetComputerNameEx(ComputerNameDnsFullyQualified,
                                   pwszComputerName,
                                   &dwComputerNameLen) )
            {
                return FALSE;
            }

        }
        else 
        {
            return FALSE;
        }
    }

    else    //might be a computer name or IP address. Determine what.
    {
        if( wcslen(pwszServerInfo) > 2 &&
            wcsncmp(pwszServerInfo, L"\\\\", 2 ) is 0 )
        {
            pwszComputerName = DhcpAllocateMemory((wcslen(pwszServerInfo) - 1)*sizeof(WCHAR));
            if( pwszComputerName is NULL )
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            
            memcpy(pwszComputerName, 
                   (pwszServerInfo+2), 
                   (wcslen(pwszServerInfo) - 1)*sizeof(WCHAR));
        }
        else if( IsIpAddress(pwszServerInfo) is TRUE )  //it is an IP Address
        {
            LPSTR Tmp;

            if( NO_ERROR isnot ( dwError = DhcpGetVersion((LPWSTR)pwszServerInfo,
                                                          &g_dwMajorVersion,
                                                          &g_dwMinorVersion) ) )
            {
                DisplayMessage(g_hModule, 
                               EMSG_SRVR_UNKNOWN_VERSION,
                               pwszServerInfo);
                SetLastError(dwError);
                return FALSE;
            }
              
            memset(g_ServerIpAddressUnicodeString, 0x00, 
                   (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
            

            wcscpy(g_ServerIpAddressUnicodeString, 
                    pwszServerInfo);


            memset(g_ServerIpAddressAnsiString, 0x00, 
                   (MAX_IP_STRING_LEN+1)*sizeof(CHAR));

            Tmp = DhcpUnicodeToOem(g_ServerIpAddressUnicodeString, NULL);
            if( NULL != Tmp ) strcpy(g_ServerIpAddressAnsiString, Tmp);

           
            dwIpAddress = inet_addr(g_ServerIpAddressAnsiString);


            if( dwIpAddress is INADDR_NONE or
                NULL is ( lpHostEnt = gethostbyaddr((char *)&dwIpAddress, 4, AF_INET)) )
            
            {
                DisplayMessage(g_hModule, EMSG_SRVR_UNKNOWN_SERVER);

                if ( 0 ) {
                    g_pwszServer = pwszTempServer;
                    wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
                    strcpy(g_ServerIpAddressAnsiString, cTempIp);
                    SetLastError(WSAGetLastError());
                    return FALSE;
                }

                //
                // Even if the service can't be resolved by name,
                // since GetVersion succeeded, let it through
                //

                g_pwszServer = DhcpAllocateMemory((wcslen(pwszServerInfo)+1)*sizeof(WCHAR));
                if( NULL != g_pwszServer ) {
                    wcscpy(g_pwszServer, pwszServerInfo );
                }

                if( pwszTempServer ) {
                    DhcpFreeMemory( pwszTempServer );
                    pwszTempServer = NULL;
                }
                
                return TRUE;
            }

            dwHostName = strlen(lpHostEnt->h_name);

            
            g_pwszServer = DhcpAllocateMemory((dwHostName+1)*sizeof(WCHAR));
            if( NULL != g_pwszServer ) 
            {
                CHAR Buf[MAX_FQDN_SIZE];

                strcpy(Buf, lpHostEnt->h_name);
                CharToOemA( Buf, Buf );
                wcscpy(g_pwszServer, DhcpOemToUnicode(Buf, NULL));
            }
            
            if( pwszTempServer )
            {
                DhcpFreeMemory(pwszTempServer);
                pwszTempServer = NULL;
            }
            return TRUE;
        }
        else
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_INVALID_COMPUTER_NAME);
            SetLastError(ERROR_INVALID_COMPUTER_NAME);
            g_pwszServer = pwszTempServer;
            wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
            strcpy(g_ServerIpAddressAnsiString, cTempIp);
            return FALSE;
        }
    }
    
    //Now process the Computer name and convert it to ANSI because
    //gethostbyname requires ANSI character string.

    {
        int dw = 0;
        
        dw = WideCharToMultiByte(CP_ACP,
                                 0,
                                 pwszComputerName,
                                 wcslen(pwszComputerName),
                                 pszComputerName,
                                 0,
                                 NULL,
                                 NULL);

        if( dw is 0 )
        {
            g_pwszServer = pwszTempServer;
            wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
            strcpy(g_ServerIpAddressAnsiString, cTempIp);
            return FALSE;
        }

        pszComputerName = DhcpAllocateMemory((dw+1)*sizeof(CHAR));

        if( pszComputerName is NULL )
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            g_pwszServer = pwszTempServer;
            wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
            strcpy(g_ServerIpAddressAnsiString, cTempIp);
            return FALSE;
        }

        dw = WideCharToMultiByte(CP_ACP,
                                 0,
                                 pwszComputerName,
                                 wcslen(pwszComputerName),
                                 pszComputerName,
                                 dw+1,
                                 NULL,
                                 NULL);

        if( dw is 0 )
        {
            g_pwszServer = pwszTempServer;
            wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
            strcpy(g_ServerIpAddressAnsiString, cTempIp);
            DhcpFreeMemory(pszComputerName);
            return FALSE;
        }

    }

    //Now get the server IP Address
    lpHostEnt = gethostbyname(pszComputerName);

    //Not a valid server name
    if( lpHostEnt is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_INVALID_COMPUTER_NAME);
        if( pszComputerName )
        {
            DhcpFreeMemory(pszComputerName);
            pszComputerName = NULL;
        }
        g_pwszServer = pwszTempServer;
        wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
        strcpy(g_ServerIpAddressAnsiString, cTempIp);
        SetLastError(ERROR_INVALID_COMPUTER_NAME);
        return FALSE;        
    }

    if( pszComputerName )
    {
        DhcpFreeMemory(pszComputerName);
        pszComputerName = NULL;
    }
    if( pwszComputerName )
    {
        DhcpFreeMemory(pwszComputerName);
        pwszComputerName = NULL;
    }

    //Get the IP Address from the returned struct...
    memcpy(pbAdd, lpHostEnt->h_addr_list[0], 4);
    nLen = 0;
    for( i=0; i<4; i++)
    {

        _itoa((int)pbAdd[i], szAdd, 10);
        memcpy(TempIp+nLen, szAdd, strlen(szAdd));
        nLen += strlen(szAdd);
        *(TempIp+nLen) = '.';
        nLen++;
    
    }
    *(TempIp+nLen-1) = '\0';


    if( NO_ERROR isnot ( dwError = DhcpGetVersion(DhcpOemToUnicode(TempIp,NULL),
                                                  &g_dwMajorVersion,
                                                  &g_dwMinorVersion) ) )
    {
        DisplayMessage(g_hModule, 
                       EMSG_SRVR_UNKNOWN_VERSION,
                       DhcpOemToUnicode(TempIp, NULL));
        g_pwszServer = pwszTempServer;
        wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
        strcpy(g_ServerIpAddressAnsiString, cTempIp);
        SetLastError(dwError);
        return FALSE;
    }

    strcpy(g_ServerIpAddressAnsiString, TempIp);

    dwIpAddress = DhcpDottedStringToIpAddress(g_ServerIpAddressAnsiString);
    
    dwHostName = strlen(g_ServerIpAddressAnsiString);

    //Convert IP Address to a Unicode string and store it to the global variable.
    memset(g_ServerIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));

    wcscpy(g_ServerIpAddressUnicodeString, DhcpOemToUnicode(g_ServerIpAddressAnsiString, NULL));
  
    g_pwszServer = DhcpAllocateMemory((strlen(lpHostEnt->h_name) + 1)*sizeof(WCHAR));

    if( g_pwszServer is NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        
        g_pwszServer = pwszTempServer;
        wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
        strcpy(g_ServerIpAddressAnsiString, cTempIp);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    {
        int dw = 0;
        dw = MultiByteToWideChar(CP_ACP,
                                 0,
                                 lpHostEnt->h_name,
                                 strlen(lpHostEnt->h_name),
                                 g_pwszServer,
                                 (strlen(lpHostEnt->h_name)+1)*sizeof(WCHAR));

        if( dw is 0 )
        {
            DhcpFreeMemory(g_pwszServer);
            g_pwszServer = pwszTempServer;
            wcscpy(g_ServerIpAddressUnicodeString, wTempIp);
            strcpy(g_ServerIpAddressAnsiString, cTempIp);       
            return FALSE;
        }
    }

    if( pwszTempServer )
    {
        DhcpFreeMemory(pwszTempServer);
        pwszTempServer = NULL;
    }
    
    if( pwszTempServer )
    {
        DhcpFreeMemory(pwszTempServer);
        pwszTempServer = NULL;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    

Author:

    Shubho Bhattacharya(a-sbhatt)  11/14/98

Revision History:

        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__

#define MSG_DHCP_NULL                           1001
#define MSG_DHCP_FORMAT_LINE                    1002
#define MSG_DHCP_FORMAT_TAB                     1003
#define MSG_DHCP_FORMAT_DASH                    1004
#define MSG_DHCP_FORMAT_STRING                  1005

#define DHCP_ARG_DELIMITER                      L"="


#define TAG_OPTION_BYTE                         L"byte"
#define TAG_OPTION_WORD                         L"word"
#define TAG_OPTION_DWORD                        L"dword"
#define TAG_OPTION_IPADDRESS                    L"ipaddress"
#define TAG_OPTION_STRING                       L"string"
#define TAG_OPTION_DWORDDWORD                   L"dworddword"
#define TAG_OPTION_BINARY                       L"binary"
#define TAG_OPTION_ENCAPSULATED                 L"encapsulated"

#define TOKEN_VENDOR_CLASS                      L"vendor"
#define TOKEN_USER_CLASS                        L"user"
#define TOKEN_OPTION_COMMENT                    L"comment"


#define CMD_GROUP_ADD                           L"add"
#define CMD_GROUP_CHECK                         L"initiate"
#define CMD_GROUP_DELETE                        L"delete"
#define CMD_GROUP_REDO                          L"initiate"
#define CMD_GROUP_SET                           L"set"
#define CMD_GROUP_SHOW                          L"show"
#define CMD_GROUP_EXPORT                        L"export"
#define CMD_GROUP_IMPORT                        L"import"

#define CMD_DHCP_LIST                           L"list"
#define CMD_DHCP_HELP1                          L"help"
#define CMD_DHCP_HELP2                          L"?"
#define CMD_DHCP_HELP3                          L"/?"
#define CMD_DHCP_HELP4                          L"-?"
#define CMD_DHCP_DUMP                           L"dump"

#define CMD_DHCP_ADD_SERVER 	                L"add server"
#define CMD_DHCP_ADD_HELPER                     L"add helper"
#define CMD_DHCP_DELETE_SERVER                  L"delete server"
#define CMD_DHCP_DELETE_HELPER                  L"delete helper"
#define CMD_DHCP_SHOW_SERVER                    L"show server"
#define CMD_DHCP_SHOW_HELPER                    L"show helper"



#define HLP_DHCP_HELP1                          2601
#define HLP_DHCP_HELP1_EX                       2602
#define HLP_DHCP_HELP2                          2604
#define HLP_DHCP_HELP2_EX                       2605
#define HLP_DHCP_HELP3                          2606
#define HLP_DHCP_HELP3_EX                       2607
#define HLP_DHCP_HELP4                          2608
#define HLP_DHCP_HELP4_EX                       2609
#define HLP_DHCP_LIST                           2610
#define HLP_DHCP_LIST_EX                        2611
#define HLP_DHCP_DUMP                           2612
#define HLP_DHCP_DUMP_EX                        2613

#define HLP_DHCP_CONTEXT_SERVER                 2701
#define HLP_DHCP_CONTEXT_SERVER_EX              2702
#define HLP_SRVR_CONTEXT_SCOPE                  2703
#define HLP_SRVR_CONTEXT_SCOPE_EX               2704
#define HLP_SRVR_CONTEXT_MSCOPE                 2705
#define HLP_SRVR_CONTEXT_MSCOPE_EX              2706

#define HLP_DHCP_ADD_SERVER                     3101
#define HLP_DHCP_ADD_SERVER_EX                  3102
#define HLP_DHCP_ADD_HELPER                     3103
#define HLP_DHCP_ADD_HELPER_EX                  3104


#define HLP_DHCP_DELETE_SERVER                  3201
#define HLP_DHCP_DELETE_SERVER_EX               3202
#define HLP_DHCP_DELETE_HELPER                  3203
#define HLP_DHCP_DELETE_HELPER_EX               3204


#define HLP_DHCP_SHOW_SERVER                    3401
#define HLP_DHCP_SHOW_SERVER_EX                 3402
#define HLP_DHCP_SHOW_HELPER                    3403
#define HLP_DHCP_SHOW_HELPER_EX                 3404


#define HLP_GROUP_ADD                           3501
#define HLP_GROUP_CHECK                         3502
#define HLP_GROUP_DELETE                        3503
#define HLP_GROUP_REDO                          3504
#define HLP_GROUP_SET                           3505
#define HLP_GROUP_SHOW                          3506
#define HLP_GROUP_EXPORT                        3507
#define HLP_GROUP_IMPORT                        3508

#define DMP_DHCP_ADD_SERVER                     4101
#define MSG_DHCP_SERVER_ADDING                  4102
#define DMP_DHCP_DELETE_SERVER                  4103
#define MSG_DHCP_SERVER_DELETING                4104
#define DMP_DHCP_SHOW_SERVER                    4105
#define MSG_DHCP_SERVER_SHOW_INFO_ARRAY         4106
#define MSG_DHCP_SERVER_SHOW_INFO               4107
#define DMP_DHCP_ADD_HELPER                     4108
#define DMP_DHCP_DELETE_HELPER                  4109
#define DMP_DHCP_SHOW_HELPER                    4110
#define DMP_DHCP_SCRIPTHEADER                   4111
#define DMP_DHCP_SCRIPTFOOTER                   4112
#define MSG_DHCP_SERVER_SHOW_INFO_NODS          4113

#define EMSG_DHCP_ERROR_SUCCESS                 6100
#define EMSG_DHCP_ADD_SERVER                    6101
#define EMSG_DHCP_DELETE_SERVER                 6102
#define EMSG_DHCP_SHOW_SERVER                   6103

#define EMSG_DHCP_INCOMPLETE_COMMAND            6104
#define EMSG_DHCP_UNABLE_TO_CREATE_FILE         6105
#define EMSG_INSTALL_KEY_FAILED                 6106
#define	EMSG_UNINSTALL_KEY_FAILED               6107
#define	EMSG_UNINSTALL_SUBKEYS                  6108
#define EMSG_RSVD_KEYWORD                       6109
#define EMSG_DHCP_FAILED_TO_LOAD_HELPER         6110
#define EMSG_DHCP_DSINIT_FAILED                 6111
#define EMSG_DHCP_INVALID_PARAMETER             6112
#define EMSG_DHCP_OUT_OF_MEMORY                 6113
#define EMSG_DHCP_NO_MORE_ITEMS                 6114
#define EMSG_DHCP_MORE_DATA                     6115
#define EMSG_DHCP_INVALID_TAG                   6116
#define EMSG_DHCP_DUPLICATE_TAG                 6117
#define EMSG_DHCP_DUMP                          6118

#define CMD_SRVR_HELP1                          L"help"
#define CMD_SRVR_HELP2                          L"/?"
#define CMD_SRVR_HELP3                          L"-?"
#define CMD_SRVR_HELP4                          L"?"
#define CMD_SRVR_LIST                           L"list"
#define CMD_SRVR_DUMP                           L"dump"


#define CMD_SRVR_ADD_CLASS                      L"add      class"
#define CMD_SRVR_ADD_HELPER                     L"add      helper"
#define CMD_SRVR_ADD_MSCOPE                     L"add      mscope"
#define CMD_SRVR_ADD_OPTIONDEF                  L"add      optiondef"
#define CMD_SRVR_ADD_SCOPE                      L"add      scope"

#define CMD_SRVR_DELETE_CLASS                   L"delete   class"
#define CMD_SRVR_DELETE_HELPER                  L"delete   helper"
#define CMD_SRVR_DELETE_MSCOPE                  L"delete   mscope"
#define CMD_SRVR_DELETE_OPTIONDEF               L"delete   optiondef"
#define CMD_SRVR_DELETE_OPTIONVALUE             L"delete   optionvalue"
#define CMD_SRVR_DELETE_SCOPE                   L"delete   scope"
#define CMD_SRVR_DELETE_SUPERSCOPE              L"delete   superscope"
#define CMD_SRVR_DELETE_DNSCREDENTIALS          L"delete   dnscredentials"

#define CMD_SRVR_REDO_AUTH                      L"initiate auth"
#define CMD_SRVR_INITIATE_RECONCILE             L"initiate reconcile"

#define CMD_SRVR_EXPORT                         L"export"
#define CMD_SRVR_IMPORT                         L"import"

#define CMD_SRVR_SET_BACKUPINTERVAL             L"set      databasebackupinterval"
#define CMD_SRVR_SET_BACKUPPATH                 L"set      databasebackuppath"
#define CMD_SRVR_SET_DATABASECLEANUPINTERVAL    L"set      databasecleanupinterval"
#define CMD_SRVR_SET_DATABASELOGGINGFLAG        L"set      databaseloggingflag"
#define CMD_SRVR_SET_DATABASENAME               L"set      databasename"
#define CMD_SRVR_SET_DATABASEPATH               L"set      databasepath"
#define CMD_SRVR_SET_DATABASERESTOREFLAG        L"set      databaserestoreflag"
#define CMD_SRVR_SET_OPTIONVALUE                L"set      optionvalue"
#define CMD_SRVR_SET_SERVER                     L"set      server"
#define CMD_SRVR_SET_USERCLASS                  L"set      userclass"
#define CMD_SRVR_SET_VENDORCLASS                L"set      vendorclass"
#define CMD_SRVR_SET_DNSCREDENTIALS             L"set      dnscredentials"
#define CMD_SRVR_SET_DETECTCONFLICTRETRY        L"set      detectconflictretry"
#define CMD_SRVR_SET_DNSCONFIG                  L"set      dnsconfig"
#define CMD_SRVR_SET_AUDITLOG                   L"set      auditlog"

#define CMD_SRVR_SHOW_ALL                       L"show     all"
#define CMD_SRVR_SHOW_BINDINGS                  L"show     bindings"
#define CMD_SRVR_SHOW_CLASS                     L"show     class"
#define CMD_SRVR_SHOW_SERVERCONFIG              L"show     dbproperties"
#define CMD_SRVR_SHOW_HELPER                    L"show     helper"
#define CMD_SRVR_SHOW_MIBINFO                   L"show     mibinfo"
#define CMD_SRVR_SHOW_MSCOPE                    L"show     mscope"
#define CMD_SRVR_SHOW_OPTIONDEF                 L"show     optiondef"
#define CMD_SRVR_SHOW_OPTIONVALUE               L"show     optionvalue"
#define CMD_SRVR_SHOW_SCOPE                     L"show     scope"
#define CMD_SRVR_SHOW_SERVER                    L"show     server"
#define CMD_SRVR_SHOW_SERVERSTATUS              L"show     serverstatus"
#define CMD_SRVR_SHOW_USERCLASS                 L"show     userclass"
#define CMD_SRVR_SHOW_VENDORCLASS               L"show     vendorclass"
#define CMD_SRVR_SHOW_DNSCREDENTIALS            L"show     dnscredentials"
#define CMD_SRVR_SHOW_VERSION                   L"show     version"
#define CMD_SRVR_SHOW_DETECTCONFLICTRETRY       L"show     detectconflictretry"
#define CMD_SRVR_SHOW_DNSCONFIG                 L"show     dnsconfig"
#define CMD_SRVR_SHOW_AUDITLOG                  L"show     auditlog"



#define HLP_SRVR_HELP1                          26001
#define HLP_SRVR_HELP1_EX                       26002
#define HLP_SRVR_HELP2                          26004
#define HLP_SRVR_HELP2_EX                       26005
#define HLP_SRVR_HELP3                          26006
#define HLP_SRVR_HELP3_EX                       26007
#define HLP_SRVR_HELP4                          26008
#define HLP_SRVR_HELP4_EX                       26009
#define HLP_SRVR_LIST                           26010
#define HLP_SRVR_LIST_EX                        26011
#define HLP_SRVR_DUMP                           26012
#define HLP_SRVR_DUMP_EX                        26013


#define HLP_SRVR_ADD_CLASS                      31001
#define HLP_SRVR_ADD_CLASS_EX                   31002
#define HLP_SRVR_ADD_HELPER                     31003
#define HLP_SRVR_ADD_HELPER_EX                  31004
#define HLP_SRVR_ADD_MSCOPE                     31005
#define HLP_SRVR_ADD_MSCOPE_EX                  31006
#define HLP_SRVR_ADD_OPTIONDEF                  31007
#define HLP_SRVR_ADD_OPTIONDEF_EX               31008
#define HLP_SRVR_ADD_SCOPE                      31009
#define HLP_SRVR_ADD_SCOPE_EX                   31010

#define HLP_SRVR_DELETE_CLASS                   32001
#define HLP_SRVR_DELETE_CLASS_EX                32002
#define HLP_SRVR_DELETE_HELPER                  32003
#define HLP_SRVR_DELETE_HELPER_EX               32004
#define HLP_SRVR_DELETE_MSCOPE                  32005
#define HLP_SRVR_DELETE_MSCOPE_EX               32006
#define HLP_SRVR_DELETE_OPTIONDEF               32007
#define HLP_SRVR_DELETE_OPTIONDEF_EX            32008
#define HLP_SRVR_DELETE_OPTIONVALUE             32009
#define HLP_SRVR_DELETE_OPTIONVALUE_EX          32010
#define HLP_SRVR_DELETE_SCOPE                   32011
#define HLP_SRVR_DELETE_SCOPE_EX                32012
#define HLP_SRVR_DELETE_SUPERSCOPE              32013
#define HLP_SRVR_DELETE_SUPERSCOPE_EX           32014
#define HLP_SRVR_DELETE_DNSCREDENTIALS          32015
#define HLP_SRVR_DELETE_DNSCREDENTIALS_EX       32016

#define HLP_SRVR_REDO_AUTH                      33001
#define HLP_SRVR_REDO_AUTH_EX                   33002
#define HLP_SRVR_INITIATE_RECONCILE             33003
#define HLP_SRVR_INITIATE_RECONCILE_EX          33004
#define HLP_SRVR_EXPORT                         33005
#define HLP_SRVR_EXPORT_EX                      33006
#define HLP_SRVR_IMPORT                         33007
#define HLP_SRVR_IMPORT_EX                      33008

#define HLP_SRVR_SET_BACKUPINTERVAL             34001
#define HLP_SRVR_SET_BACKUPINTERVAL_EX          34002
#define HLP_SRVR_SET_BACKUPPATH                 34003
#define HLP_SRVR_SET_BACKUPPATH_EX              34004
#define HLP_SRVR_SET_DATABASECLEANUPINTERVAL    34005
#define HLP_SRVR_SET_DATABASECLEANUPINTERVAL_EX 34006
#define HLP_SRVR_SET_DATABASELOGGINGFLAG        34007
#define HLP_SRVR_SET_DATABASELOGGINGFLAG_EX     34008
#define HLP_SRVR_SET_DATABASENAME               34009
#define HLP_SRVR_SET_DATABASENAME_EX            34010
#define HLP_SRVR_SET_DATABASEPATH               34011
#define HLP_SRVR_SET_DATABASEPATH_EX            34012
#define HLP_SRVR_SET_DATABASERESTOREFLAG        34013
#define HLP_SRVR_SET_DATABASERESTOREFLAG_EX     34014
#define HLP_SRVR_SET_OPTIONVALUE                34015
#define HLP_SRVR_SET_OPTIONVALUE_EX             34016
#define HLP_SRVR_SET_SERVER                     34017
#define HLP_SRVR_SET_SERVER_EX                  34018
#define HLP_SRVR_SET_USERCLASS                  34019
#define HLP_SRVR_SET_USERCLASS_EX               34020
#define HLP_SRVR_SET_VENDORCLASS                34021
#define HLP_SRVR_SET_VENDORCLASS_EX             34022
#define HLP_SRVR_SET_DETECTCONFLICTRETRY        34023
#define HLP_SRVR_SET_DETECTCONFLICTRETRY_EX     34024
#define HLP_SRVR_SET_DNSCONFIG                  34025
#define HLP_SRVR_SET_DNSCONFIG_EX               34026
#define HLP_SRVR_SET_AUDITLOG                   34027
#define HLP_SRVR_SET_AUDITLOG_EX                34028
#define HLP_SRVR_SET_DNSCREDENTIALS             34029
#define HLP_SRVR_SET_DNSCREDENTIALS_EX          34030

#define HLP_SRVR_SHOW_ALL                       35001
#define HLP_SRVR_SHOW_ALL_EX                    35002
#define HLP_SRVR_SHOW_CLASS                     35003
#define HLP_SRVR_SHOW_CLASS_EX                  35004
#define HLP_SRVR_SHOW_HELPER                    35005
#define HLP_SRVR_SHOW_HELPER_EX                 35006
#define HLP_SRVR_SHOW_MIBINFO                   35007
#define HLP_SRVR_SHOW_MIBINFO_EX                35008
#define HLP_SRVR_SHOW_MSCOPE                    35009
#define HLP_SRVR_SHOW_MSCOPE_EX                 35010
#define HLP_SRVR_SHOW_OPTIONDEF                 35011
#define HLP_SRVR_SHOW_OPTIONDEF_EX              35012
#define HLP_SRVR_SHOW_OPTIONVALUE               35013
#define HLP_SRVR_SHOW_OPTIONVALUE_EX            35014
#define HLP_SRVR_SHOW_SCOPE                     35015
#define HLP_SRVR_SHOW_SCOPE_EX                  35016
#define HLP_SRVR_SHOW_SERVER                    35017
#define HLP_SRVR_SHOW_SERVER_EX                 35018
#define HLP_SRVR_SHOW_SERVERCONFIG              35019
#define HLP_SRVR_SHOW_SERVERCONFIG_EX           35020
#define HLP_SRVR_SHOW_SERVERSTATUS              35021
#define HLP_SRVR_SHOW_SERVERSTATUS_EX           35022
#define HLP_SRVR_SHOW_USERCLASS                 35023
#define HLP_SRVR_SHOW_USERCLASS_EX              35024
#define HLP_SRVR_SHOW_VENDORCLASS               35025
#define HLP_SRVR_SHOW_VENDORCLASS_EX            35026
#define HLP_SRVR_SHOW_VERSION                   35027
#define HLP_SRVR_SHOW_VERSION_EX                35028
#define HLP_SRVR_SHOW_BINDINGS                  35029
#define HLP_SRVR_SHOW_BINDINGS_EX               35030
#define HLP_SRVR_SHOW_DETECTCONFLICTRETRY       35031
#define HLP_SRVR_SHOW_DETECTCONFLICTRETRY_EX    35032
#define HLP_SRVR_SHOW_DNSCONFIG                 35033
#define HLP_SRVR_SHOW_DNSCONFIG_EX              35034
#define HLP_SRVR_SHOW_AUDITLOG                  35035
#define HLP_SRVR_SHOW_AUDITLOG_EX               35036
#define HLP_SRVR_SHOW_DNSCREDENTIALS            35037
#define HLP_SRVR_SHOW_DNSCREDENTIALS_EX         35038


#define DMP_SRVR_ADD_CLASS                      41101
#define DMP_SRVR_ADD_HELPER                     41102
#define DMP_SRVR_ADD_MSCOPE                     41103
#define DMP_SRVR_ADD_OPTIONDEF                  41104
#define DMP_SRVR_ADD_SCOPE                      41105
#define DMP_SRVR_ADD_SUPER_SCOPE                41106

#define DMP_SRVR_DELETE_CLASS                   41201
#define DMP_SRVR_DELETE_HELPER                  41202
#define DMP_SRVR_DELETE_MSCOPE                  41203
#define DMP_SRVR_DELETE_OPTIONDEF               41204
#define DMP_SRVR_DELETE_OPTIONVALUE             41005
#define DMP_SRVR_DELETE_SCOPE                   41206
#define DMP_SRVR_DELETE_SUPERSCOPE              41207

#define DMP_SRVR_REDO_AUTH                      41301

#define DMP_SRVR_SET_BACKUPINTERVAL             41401
#define DMP_SRVR_SET_BACKUPPATH                 41402
#define DMP_SRVR_SET_DATABASECLEANUPINTERVAL    41403
#define DMP_SRVR_SET_DATABASELOGGINGFLAG        41404
#define DMP_SRVR_SET_DATABASENAME               41405
#define DMP_SRVR_SET_DATABASEPATH               41406
#define DMP_SRVR_SET_DATABASERESTOREFLAG        41407
#define DMP_SRVR_SET_OPTIONVALUE                41408
#define DMP_SRVR_SET_SERVER                     41409
#define DMP_SRVR_SET_CLASSNAME                  41410
#define DMP_SRVR_SET_VENDORNAME                 41411
#define DMP_SRVR_SET_OPTIONVALUE_CLASS          41412
#define DMP_SRVR_SET_DETECTCONFLICTRETRY        41413
#define DMP_SRVR_SET_DNSCONFIG                  41414
#define DMP_SRVR_SET_AUDITLOG                   41415
#define DMP_SRVR_SET_OPTIONVALUE_USER           41416
#define DMP_SRVR_SET_OPTIONVALUE_VENDOR         41417


#define DMP_SRVR_SHOW_ALL                       41501
#define DMP_SRVR_SHOW_CLASS                     41502
#define DMP_SRVR_SHOW_HELPER                    41503
#define DMP_SRVR_SHOW_MIBINFO                   41504
#define DMP_SRVR_SHOW_MSCOPE                    41505
#define DMP_SRVR_SHOW_OPTIONDEF                 41506
#define DMP_SRVR_SHOW_OPTIONVALUE               41507
#define DMP_SRVR_SHOW_SCOPE                     41508
#define DMP_SRVR_SHOW_SERVER                    41509
#define DMP_SRVR_SHOW_SERVERCONFIG              41510
#define DMP_SRVR_SHOW_SERVERSTATUS              41511
#define DMP_SRVR_SHOW_CLASSNAME                 41512
#define DMP_SRVR_SHOW_VENDORNAME                41513

#define DMP_SRVR_OPTION_NONVENDOR               42001
#define DMP_SRVR_ADD_OPTIONDEF_VENDOR           42002
#define DMP_SRVR_ADD_OPTIONDEF_NONE             42003
#define DMP_SRVR_ADD_OPTIONDEF_VENDOR_NONE      42004



#define DMP_SRVR_CLASS_HEADER                   42101
#define DMP_SRVR_CLASS_FOOTER                   42102
#define DMP_SRVR_OPTIONDEF_HEADER               42103
#define DMP_SRVR_OPTIONDEF_FOOTER               42104
#define DMP_SRVR_OPTIONVALUE_HEADER             42105
#define DMP_SRVR_OPTIONVALUE_FOOTER             42106
#define DMP_SRVR_SCOPE_HEADER                   42107
#define DMP_SRVR_SCOPE_FOOTER                   42108
#define DMP_SRVR_SERVER_HEADER                  42109
#define DMP_SRVR_SERVER_FOOTER                  42010
#define DMP_SRVR_MSCOPE_HEADER                  42011
#define DMP_SRVR_MSCOPE_FOOTER                  42012
#define DMP_SCOPE_ADD_IPRANGES_HEADER           42013
#define DMP_SCOPE_ADD_IPRANGES_FOOTER           42014
#define DMP_SCOPE_ADD_EXCLUDERANGES_HEADER      42015
#define DMP_SCOPE_ADD_EXCLUDERANGES_FOOTER      42016
#define DMP_SCOPE_SET_OPTIONVALUE_HEADER        42017
#define DMP_SCOPE_SET_OPTIONVALUE_FOOTER        42018
#define DMP_SCOPE_SET_RESERVEDIP_HEADER         42019
#define DMP_SCOPE_SET_RESERVEDIP_FOOTER         42020
#define DMP_MSCOPE_ADD_IPRANGES_HEADER          42021
#define DMP_MSCOPE_ADD_IPRANGES_FOOTER          42022
#define DMP_MSCOPE_ADD_EXCLUDERANGES_HEADER     42023
#define DMP_MSCOPE_ADD_EXCLUDERANGES_FOOTER     42024
#define DMP_SRVR_MSCOPE_SET_EXPIRY              42025
#define DMP_SRVR_SUPER_SCOPE_HEADER             42026
#define DMP_SRVR_SUPER_SCOPE_FOOTER             42027

#define MSG_NO_ENTRY_PT                         51001
#define MSG_DLL_LOAD_FAILED                     51002
#define MSG_DLL_START_FAILED                    51003
#define MSG_NO_HELPER                           51004
#define	MSG_DHCP_NOT_ENOUGH_MEMORY              51005
#define MSG_HELPER_HELP                         51006
#define MSG_SRVR_COMPUTER_NAME                  51007
#define MSG_SRVR_CLASS_INFO                     51008
#define MSG_SRVR_CLASS_DATA                     51009
#define MSG_SRVR_CLASS_DATA_FORMAT              51010
#define MSG_SRVR_CLASS_INFO_ARRAY               51011

#define MSG_SRVR_OPTION_INFO                    51012
#define MSG_SRVR_OPTION_ID                      51013
#define MSG_SRVR_OPTION_NAME                    51014
#define MSG_SRVR_OPTION_COMMENT                 51015
#define MSG_SRVR_OPTION_TYPE1                   51016
#define MSG_SRVR_OPTION                         51017
#define MSG_SRVR_OPTION_COUNT                   51018
#define MSG_SRVR_OPTION_TYPE                    51019
#define MSG_SRVR_OPTION_TYPE_BYTE               51020
#define MSG_SRVR_OPTION_TYPE_WORD               51021
#define MSG_SRVR_OPTION_TYPE_DWORD              51022
#define MSG_SRVR_OPTION_TYPE_DWORDDWORD         51023
#define MSG_SRVR_OPTION_TYPE_IPADDRESS          51024
#define MSG_SRVR_OPTION_TYPE_STRINGDATA         51025
#define MSG_SRVR_OPTION_TYPE_BINARYDATA         51026
#define MSG_SRVR_OPTION_TYPE_ENCAPSULATEDDATA   51027
#define MSG_SRVR_OPTION_TYPE_UNKNOWN            51028
#define MSG_SRVR_OPTION_VALUE                   51029
#define MSG_SRVR_OPTION_VALUE_NUM               51030
#define MSG_SRVR_OPTION_VALUE_LONGNUM           51031
#define MSG_SRVR_OPTION_VALUE_STRING            51032
#define MSG_SRVR_OPTION_VALUE_BINARY            51033
#define MSG_SRVR_OPTION_READ                    51034
#define MSG_SRVR_OPTION_TOTAL                   51035
#define MSG_SRVR_OPTION_PROPS                   51036
#define MSG_SRVR_OPTIONS                        51037
#define MSG_SRVR_CLASS_VENDOR                   51038
#define MSG_SRVR_CLASS_USER                     51039
#define MSG_SRVR_UNKNOWN_FORCEFLAG              51040
#define MSG_SRVR_MIB                            51041
#define MSG_SRVR_MIB_DISCOVERS                  51042
#define MSG_SRVR_MIB_OFFERS                     51043
#define MSG_SRVR_MIB_REQUESTS                   51044
#define MSG_SRVR_MIB_RENEWS                     51045
#define MSG_SRVR_MIB_ACKS                       51055
#define MSG_SRVR_MIB_NAKS                       51056
#define MSG_SRVR_MIB_DECLINES                   51057
#define MSG_SRVR_MIB_RELEASES                   51058
#define MSG_SRVR_MIB_SERVERSTARTTIME            51059
#define MSG_SRVR_MIB_SCOPES                     51060
#define MSG_SRVR_MIB_SCOPES_SUBNET              51061
#define MSG_SRVR_MIB_SCOPES_SUBNET_NUMADDRESSESINUSE  51062
#define MSG_SRVR_MIB_SCOPES_SUBNET_NUMADDRESSESFREE   51063
#define MSG_SRVR_MIB_SCOPES_SUBNET_NUMPENDINGOFFERS   51064

#define MSG_SRVR_SERVER_STATUS                  51065
#define MSG_SRVR_SERVER_ATTRIB                  51067
#define MSG_SRVR_SERVER_ATTRIB_TYPE_BOOL        51068
#define MSG_SRVR_SERVER_ATTRIB_TYPE_ULONG       51069

#define MSG_SRVR_SERVERCONFIG_DATABASENAME             51070
#define MSG_SRVR_SERVERCONFIG_DATABASEPATH             51071
#define MSG_SRVR_SERVERCONFIG_BACKUPPATH               51072
#define MSG_SRVR_SERVERCONFIG_BACKUPINTERVAL           51073
#define MSG_SRVR_SERVERCONFIG_DATABASELOGGINGFLAG      51074
#define MSG_SRVR_SERVERCONFIG_RESTOREFLAG              51075
#define MSG_SRVR_DBPROPERTIES                          51076
#define MSG_SRVR_SERVERCONFIG_DATABASECLEANUPINTERVAL  51078

#define MSG_SRVR_SERVERCONFIG                                     51079
#define MSG_SRVR_VERSION                                          51081           
#define MSG_SRVR_SERVERCONFIG_DATABASENAME_VALUE                  51082
#define MSG_SRVR_SERVERCONFIG_DATABASEPATH_VALUE                  51083
#define MSG_SRVR_SERVERCONFIG_BACKUPPATH_VALUE                    51084
#define MSG_SRVR_SERVERCONFIG_BACKUPINTERVAL_VALUE                51085
#define MSG_SRVR_SERVERCONFIG_DATABASELOGGINGFLAG_VALUE           51086
#define MSG_SRVR_SERVERCONFIG_RESTOREFLAG_VALUE                   51087
#define MSG_SRVR_SERVERCONFIG_DATABASECLEANUPINTERVAL_VALUE       51088
#define MSG_SRVR_SERVERCONFIG_DEBUGFLAG_VALUE                     51089

#define MSG_SRVR_SCOPE                          51090
#define MSG_SRVR_SCOPE_IPADDRESS                51091
#define MSG_SRVR_SCOPE_SUBNETMASK               51092
#define MSG_SRVR_SCOPE_NAME                     51093
#define MSG_SRVR_SCOPE_COMMENT                  51094
#define MSG_SRVR_SCOPE_STATE                    51095
#define MSG_SRVR_SCOPE_COUNT                    51096
#define MSG_SRVR_CLIENT_DURATION_DATE           51097

#define MSG_SRVR_OWNER_NAME                     51098
#define MSG_SRVR_OWNER_NETBIOSNAME              51099
#define MSG_SRVR_OWNER_IPADDRESS                51100

#define MSG_SRVR_MULTICAST_CLIENT_COUNT         51101
#define MSG_SRVR_MULTICAST_SCOPES               51102
#define MSG_SRVR_MULTICAST_SCOPEID              51103
#define MSG_SRVR_OPTIONDEF_TABLE                51104
#define MSG_SRVR_OPTIONDEF_INFO                 51105
#define MSG_SRVR_CLASSNAME                      51106
#define MSG_SRVR_VENDORNAME                     51107
#define MSG_SRVR_OPTION_NONVENDOR               51108
#define MSG_SRVR_OPTION_VENDOR                  51109
#define MSG_SRVR_CLASS_NONE                     51110
#define MSG_SRVR_SCOPE_TABLE                    51111
#define MSG_SRVR_SCOPE_INFO_ACTIVE              51112
#define MSG_SRVR_MSCOPE_TABLE                   51113
#define MSG_SRVR_MSCOPE_INFO_ACTIVE             51114
#define MSG_SRVR_USER_CLASS                     51115
#define MSG_SRVR_VENDOR_CLASS                   51116
#define MSG_SRVR_OPTIONVAL_COUNT                51117
#define MSG_SRVR_CLASS_COUNT                    51118
#define MSG_SRVR_BINDINGS                       51119
#define MSG_SRVR_NO_BINDINGS                    51120
#define MSG_SRVR_BOUNDTOSERVER_TRUE             51121
#define MSG_SRVR_PRIMARY_ADDRESS                51122
#define MSG_SRVR_SUBNET_ADDRESS                 51123
#define MSG_SRVR_IF_DESCRIPTION                 51124
#define MSG_SRVR_IFID                           51125
#define MSG_SRVR_STANDARD_OPTION                51126
#define MSG_SRVR_RECONCILE_SCOPE                51127
#define MSG_SRVR_BOUNDTOSERVER_FALSE            51128
#define MSG_SRVR_SCOPE_INFO_NOTACTIVE           51129
#define MSG_SRVR_MSCOPE_INFO_NOTACTIVE          51130
#define MSG_SRVR_CLASSNAME_NONE                 51131
#define MSG_SRVR_VENDORNAME_NONE                51132
#define MSG_SRVR_CLASS_INFO_VENDOR              51133
#define MSG_SRVR_SERVER_ATTRIB_ISROUGE          51134
#define MSG_SRVR_SERVER_ATTRIB_ISDYNBOOTP       51135
#define MSG_SRVR_SERVER_ATTRIB_ISPARTDSDC       51136
#define MSG_SRVR_SERVER_ATTRIB_ISBINDING        51138
#define MSG_SRVR_SERVER_ATTRIB_ISADMIN          51139
#define MSG_SRVR_TRUE                           51140
#define MSG_SRVR_FALSE                          51141
#define MSG_SRVR_AUDIT_SETTINGS                 51142
#define MSG_SRVR_NEED_RESTART                   51143
#define MSG_SRVR_CHANGE_AUDIT_SETTINGS          51144
#define MSG_SRVR_PING_RETRY                     51145
#define MSG_SRVR_DNS_ENABLED                    51146
#define MSG_SRVR_DNS_DISABLED                   51147
#define MSG_SRVR_UPDATE_DOWNLEVEL_ENABLED       51148
#define MSG_SRVR_UPDATE_DOWNLEVEL_DISABLED      51149
#define MSG_SRVR_CLEANUP_EXPIRED_ENABLED        51150
#define MSG_SRVR_CLEANUP_EXPIRED_DISABLED       51151
#define MSG_SRVR_UPDATE_BOTH_ENABLED            51152
#define MSG_SRVR_UPDATE_BOTH_DISABLED           51153
#define MSG_SRVR_UPDATE_LOOKUP                  51154
#define MSG_SRVR_DNS_OPTIONS                    51155
#define MSG_SRVR_MSCOPE_ADD                     51156
#define MSG_DHCP_NO_OPTIONVALUE_SET             51157
#define MSG_SRVR_DNS_CREDENTIALS                51158
#define MSG_SRVR_SCOPE_INFO_ACTIVE_SWITCHED     51159
#define MSG_SRVR_SCOPE_INFO_NOTACTIVE_SWITCHED  51160
#define MSG_SRVR_RECONCILE_SCOPE_NEEDFIX        51161
#define MSG_SRVR_RECONCILE_SCOPE_NOFIX          51162

#define MSG_SRVR_IMPORT_CLASS_CONFLICT          51200
#define MSG_SRVR_IMPORT_OPTDEF_CONFLICT         51201
#define MSG_SRVR_IMPORT_OPTION_CONFLICT         51202
#define MSG_SRVR_IMPORT_SUBNET_OPTION_CONFLICT  51203
#define MSG_SRVR_IMPORT_RES_OPTION_CONFLICT     51204
#define MSG_SRVR_EXPORT_SUBNET_NOT_FOUND        51205
#define MSG_SRVR_IMPORT_SUBNET_CONFLICT         51206
#define MSG_SRVR_IMPORT_DBENTRY_CONFLICT        51207


#define EMSG_SRVR_ERROR_SUCCESS                 52000
#define EMSG_SRVR_INCOMPLETE_COMMAND            52001
#define EMSG_SRVR_UNABLE_TO_CREATE_FILE         52002
#define EMSG_SRVR_NO_COMPUTER_NAME              52007
#define EMSG_SRVR_INVALID_COMPUTER_NAME         52008
#define EMSG_SRVR_UNKNOWN_OPTION_TYPE           52009
#define EMSG_SRVR_VALUE_OUT_OF_RANGE            52010
#define EMSG_SRVR_UNKNOWN_SERVER_ATTRIB         52011
#define EMSG_SRVR_UNKNOWN_SERVER                52012
#define EMSG_SRVR_UNKNOWN_VERSION               52013
#define EMSG_SRVR_FAILED_TO_LOAD_HELPER         52014
#define EMSG_DHCP_ERROR_TEXT                    52015
#define EMSG_SRVR_STRING_ARRAY_OPTIONS          52016

#define EMSG_SRVR_ADD_CLASS                     53001
#define EMSG_SRVR_ADD_HELPER                    53002
#define EMSG_SRVR_ADD_MSCOPE                    53003
#define EMSG_SRVR_ADD_SCOPE                     53004
#define EMSG_SRVR_ADD_OPTIONDEF                 53005

#define EMSG_SRVR_DELETE_CLASS                  53101
#define EMSG_SRVR_DELETE_HELPER                 53102
#define EMSG_SRVR_DELETE_MSCOPE                 53103
#define EMSG_SRVR_DELETE_OPTIONDEF              53104
#define EMSG_SRVR_DELETE_OPTIONVALUE            53105
#define EMSG_SRVR_DELETE_SCOPE                  53106
#define EMSG_SRVR_DELETE_SUPERSCOPE             53107
#define EMSG_SRVR_DELETE_DNSCREDENTIALS         53108

#define EMSG_SRVR_REDO_AUTH                     53201
#define EMSG_SRVR_INITIATE_RECONCILE            53202
#define EMSG_SRVR_EXPORT                        53203
#define EMSG_SRVR_IMPORT                        53204
#define EMSG_SRVR_EXIM_LOCAL                    53205

#define EMSG_SRVR_SET_BACKUPINTERVAL            53301
#define EMSG_SRVR_SET_BACKUPPATH                53302
#define EMSG_SRVR_SET_DATABASECLEANUPINTERVAL   53303
#define EMSG_SRVR_SET_DATABASELOGGINGFLAG       53304
#define EMSG_SRVR_SET_DATABASENAME              53305
#define EMSG_SRVR_SET_DATABASEPATH              53306
#define EMSG_SRVR_SET_DATABASERESTOREFLAG       53307
#define EMSG_SRVR_SET_OPTIONVALUE               53308
#define EMSG_SRVR_SET_SERVER                    53309
#define EMSG_SRVR_SET_USERCLASS                 53310
#define EMSG_SRVR_SET_VENDORCLASS               53311
#define EMSG_SRVR_SET_DETECTCONFLICTRETRY       53312
#define EMSG_SRVR_SET_DNSCONFIG                 53313
#define EMSG_SRVR_SET_AUDITLOG                  53314
#define EMSG_SRVR_SET_DNSCREDENTIALS            53315

#define EMSG_SRVR_SHOW_ALL                      53401
#define EMSG_SRVR_SHOW_CLASS                    53402
#define EMSG_SRVR_SHOW_HELPER                   53403
#define EMSG_SRVR_SHOW_MIBINFO                  53404
#define EMSG_SRVR_SHOW_MSCOPE                   53405
#define EMSG_SRVR_SHOW_OPTIONDEF                53406
#define EMSG_SRVR_SHOW_OPTIONVALUE              53407
#define EMSG_SRVR_SHOW_SCOPE                    53408
#define EMSG_SRVR_SHOW_SERVER                   53409
#define EMSG_SRVR_SHOW_SERVERCONFIG             53410
#define EMSG_SRVR_SHOW_SERVERSTATUS             53411
#define EMSG_SRVR_SHOW_USERCLASS                53412
#define EMSG_SRVR_SHOW_VENDORCLASS              53413
#define EMSG_SRVR_INVALID_VERSION               53414
#define EMSG_SRVR_SHOW_BINDINGS                 53415
#define EMSG_SRVR_BINDINGS_SUPPORT              53416
#define EMSG_SRVR_RECONCILE_SCOPE               53417
#define EMSG_SRVR_SHOW_DETECTCONFLICTRETRY      53418
#define EMSG_SRVR_SHOW_DNSCONFIG                53419
#define EMSG_SRVR_SHOW_AUDITLOG                 53420
#define EMSG_SRVR_NO_SHOWDNSCONFIG              53421
#define EMSG_SRVR_NO_SETDNSCONFIG               53422
#define EMSG_SRVR_INVALID_OPTIONTYPE            53423
#define EMSG_SRVR_INVALID_DIRECTORY             53424
#define EMSG_SRVR_SHOW_DNSCREDENTIALS           53425
#define EMSG_SRVR_NEED_DNS_CREDENTIALS_SUPPORT  53426

#define CMD_SCOPE_HELP1                          L"help"
#define CMD_SCOPE_HELP2                          L"/?"
#define CMD_SCOPE_HELP3                          L"-?"
#define CMD_SCOPE_HELP4                          L"?"
#define CMD_SCOPE_LIST                           L"list"
#define CMD_SCOPE_DUMP                           L"dump"

#define CMD_SCOPE_ADD_IPRANGE                    L"add      iprange"
#define CMD_SCOPE_ADD_EXCLUDERANGE               L"add      excluderange"
#define CMD_SCOPE_ADD_RESERVEDIP                 L"add      reservedip"

#define CMD_SCOPE_CHECK_DATABASE                 L"initiate reconcile"

#define CMD_SCOPE_DELETE_IPRANGE                 L"delete   iprange"
#define CMD_SCOPE_DELETE_EXCLUDERANGE            L"delete   excluderange"
#define CMD_SCOPE_DELETE_RESERVEDIP              L"delete   reservedip"
#define CMD_SCOPE_DELETE_OPTIONVALUE             L"delete   optionvalue"
#define CMD_SCOPE_DELETE_RESERVEDOPTIONVALUE     L"delete   reservedoptionvalue"

#define CMD_SCOPE_SET_COMMENT                    L"set      comment"
#define CMD_SCOPE_SET_NAME                       L"set      name"
#define CMD_SCOPE_SET_OPTIONVALUE                L"set      optionvalue"
#define CMD_SCOPE_SET_RESERVEDOPTIONVALUE        L"set      reservedoptionvalue"
#define CMD_SCOPE_SET_STATE                      L"set      state"
#define CMD_SCOPE_SET_SUPERSCOPE                 L"set      superscope"
#define CMD_SCOPE_SET_SCOPE                      L"set      scope"

#define CMD_SCOPE_SHOW_CLIENTS                   L"show     clients"
#define CMD_SCOPE_SHOW_CLIENTSV5                 L"show     clientsv5"
#define CMD_SCOPE_SHOW_IPRANGE                   L"show     iprange"
#define CMD_SCOPE_SHOW_EXCLUDERANGE              L"show     excluderange"
#define CMD_SCOPE_SHOW_RESERVEDIP                L"show     reservedip"
#define CMD_SCOPE_SHOW_OPTIONVALUE               L"show     optionvalue"
#define CMD_SCOPE_SHOW_RESERVEDOPTIONVALUE       L"show     reservedoptionvalue"
#define CMD_SCOPE_SHOW_SCOPE                     L"show     scope"
#define CMD_SCOPE_SHOW_STATE                     L"show     state"
#define CMD_SCOPE_SHOW_MIBINFO                   L"show     mibinfo"

#define HLP_SCOPE_HELP1                          76001
#define HLP_SCOPE_HELP1_EX                       26002
#define HLP_SCOPE_HELP2                          76004
#define HLP_SCOPE_HELP2_EX                       76005
#define HLP_SCOPE_HELP3                          76006
#define HLP_SCOPE_HELP3_EX                       76007
#define HLP_SCOPE_HELP4                          76008
#define HLP_SCOPE_HELP4_EX                       76009
#define HLP_SCOPE_LIST                           76010
#define HLP_SCOPE_LIST_EX                        76011
#define HLP_SCOPE_DUMP                           76012
#define HLP_SCOPE_DUMP_EX                        76013


#define HLP_SCOPE_ADD_IPRANGE                    81001
#define HLP_SCOPE_ADD_IPRANGE_EX                 81002
#define HLP_SCOPE_ADD_EXCLUDERANGE               81003
#define HLP_SCOPE_ADD_EXCLUDERANGE_EX            81004
#define HLP_SCOPE_ADD_RESERVEDIP                 81005
#define HLP_SCOPE_ADD_RESERVEDIP_EX              81006

#define HLP_SCOPE_DELETE_IPRANGE                 82001
#define HLP_SCOPE_DELETE_IPRANGE_EX              82002
#define HLP_SCOPE_DELETE_EXCLUDERANGE            82003
#define HLP_SCOPE_DELETE_EXCLUDERANGE_EX         82004
#define HLP_SCOPE_DELETE_RESERVEDIP              82005
#define HLP_SCOPE_DELETE_RESERVEDIP_EX           82006
#define HLP_SCOPE_DELETE_OPTIONVALUE             82007
#define HLP_SCOPE_DELETE_OPTIONVALUE_EX          82008
#define HLP_SCOPE_DELETE_RESERVEDOPTIONVALUE     82009
#define HLP_SCOPE_DELETE_RESERVEDOPTIONVALUE_EX  82010

#define HLP_SCOPE_CHECK_DATABASE                 83001
#define HLP_SCOPE_CHECK_DATABASE_EX              83002

#define HLP_SCOPE_SET_COMMENT                    84001
#define HLP_SCOPE_SET_COMMENT_EX                 84002
#define HLP_SCOPE_SET_NAME                       84003
#define HLP_SCOPE_SET_NAME_EX                    84004
#define HLP_SCOPE_SET_STATE                      84005
#define HLP_SCOPE_SET_STATE_EX                   84006
#define HLP_SCOPE_SET_OPTIONVALUE                84007
#define HLP_SCOPE_SET_OPTIONVALUE_EX             84008
#define HLP_SCOPE_SET_RESERVEDOPTIONVALUE        84009
#define HLP_SCOPE_SET_RESERVEDOPTIONVALUE_EX     84010
#define HLP_SCOPE_SET_SCOPE                      84011
#define HLP_SCOPE_SET_SCOPE_EX                   84012
#define HLP_SCOPE_SET_SUPERSCOPE                 84013
#define HLP_SCOPE_SET_SUPERSCOPE_EX              84014


#define HLP_SCOPE_SHOW_CLIENTS                   85001
#define HLP_SCOPE_SHOW_CLIENTS_EX                85002
#define HLP_SCOPE_SHOW_CLIENTSV5                 85003
#define HLP_SCOPE_SHOW_CLIENTSV5_EX              85004
#define HLP_SCOPE_SHOW_RESERVEDIP                85005
#define HLP_SCOPE_SHOW_RESERVEDIP_EX             85006
#define HLP_SCOPE_SHOW_MIBINFO                   85007
#define HLP_SCOPE_SHOW_MIBINFO_EX                85008
#define HLP_SCOPE_SHOW_IPRANGE                   85009
#define HLP_SCOPE_SHOW_IPRANGE_EX                85010
#define HLP_SCOPE_SHOW_EXCLUDERANGE              85011
#define HLP_SCOPE_SHOW_EXCLUDERANGE_EX           85012
#define HLP_SCOPE_SHOW_OPTIONVALUE               85013
#define HLP_SCOPE_SHOW_OPTIONVALUE_EX            85014
#define HLP_SCOPE_SHOW_SCOPE                     85015
#define HLP_SCOPE_SHOW_SCOPE_EX                  85016
#define HLP_SCOPE_SHOW_RESERVEDOPTIONVALUE       85017
#define HLP_SCOPE_SHOW_RESERVEDOPTIONVALUE_EX    85018
#define HLP_SCOPE_SHOW_STATE                     85019
#define HLP_SCOPE_SHOW_STATE_EX                  85020


#define DMP_SCOPE_ADD_IPRANGE                    91101
#define DMP_SCOPE_ADD_EXCLUDERANGE               91102
#define DMP_SCOPE_ADD_RESERVEDIP                 91103

#define DMP_SCOPE_DELETE_IPRANGE                 91201
#define DMP_SCOPE_DELETE_EXCLUDERANGE            91202
#define DMP_SCOPE_DELETE_RESERVEDIP              91203
#define DMP_SCOPE_DELETE_OPTIONVALUE             91204
#define DMP_SCOPE_DELETE_RESERVEDOPTIONVALUE     91005

#define DMP_SCOPE_CHECK_DATABASE                 91301

#define DMP_SCOPE_SET_COMMENT                    91401
#define DMP_SCOPE_SET_SUPERSCOPE                 91402
#define DMP_SCOPE_SET_STATE                      91403
#define DMP_SCOPE_SET_SCOPE                      91404
#define DMP_SCOPE_SET_NAME                       91405
#define DMP_SCOPE_SET_OPTIONVALUE                91406
#define DMP_SCOPE_SET_RESERVEDOPTIONVALUE        91407
#define DMP_SCOPE_SET_OPTIONVALUE_CLASS          91408
#define DMP_SCOPE_SET_RESERVEDOPTIONVALUE_CLASS  91409
#define DMP_SCOPE_SET_OPTIONVALUE_USER           91410
#define DMP_SCOPE_SET_OPTIONVALUE_VENDOR         91411
#define DMP_SCOPE_SET_RESERVEDOPTIONVALUE_USER   91412
#define DMP_SCOPE_SET_RESERVEDOPTIONVALUE_VENDOR 91413


#define DMP_SCOPE_SHOW_CLIENTS                   91501
#define DMP_SCOPE_SHOW_CLIENTSV5                 91502
#define DMP_SCOPE_SHOW_EXCLUDERANGE              91503
#define DMP_SCOPE_SHOW_MIBINFO                   91504
#define DMP_SCOPE_SHOW_IPRANGE                   91505
#define DMP_SCOPE_SHOW_RESERVEDIP                91506
#define DMP_SCOPE_SHOW_OPTIONVALUE               91507
#define DMP_SCOPE_SHOW_SCOPE                     91508
#define DMP_SCOPE_SHOW_RESERVEDOPTIONVALUE       91509
#define DMP_SCOPE_SHOW_STATE                     91510


#define EMSG_SCOPE_ERROR_SUCCESS                 92000
#define EMSG_SCOPE_INCOMPLETE_COMMAND            92001
#define EMSG_SCOPE_UNABLE_TO_CREATE_FILE         92002
#define EMSG_SCOPE_INVALID_SCOPE_NAME            92008
#define EMSG_SCOPE_UNKNOWN_OPTION_TYPE           92009
#define EMSG_SCOPE_VALUE_OUT_OF_RANGE            92010
#define EMSG_SCOPE_NO_SCOPENAME                  92013
#define ERROR_OUT_OF_MEMORY                      92014
#define EMSG_SCOPE_INVALID_IPADDRESS             92015
#define EMSG_DHCP_UNKNOWN_SERVER_ATTRIB         92017
#define EMSG_DHCP_UNKNOWN_OPTION_DATATYPE       92018
#define EMSG_DHCP_LARGE_OPTION_VALUE            92019
#define EMSG_DHCP_VERSION_NOT_SUPPORTED         92020
#define EMSG_DHCP_NO_OPTION_VALUE               92021
#define EMSG_DHCP_FAILED_ENUM_OPTION            92022
#define EMSG_DHCP_FAILED_GETVERSION             92923
#define EMSG_DHCP_UNKNOWN_FORCEFLAG             92023
#define EMSG_DHCP_UNKNOWN_RANGETYPE             92024
#define EMSG_SCOPE_INVALID_HARDWAREADDRESS      92025
#define EMSG_DHCP_CLIENT_NAME_TOOLONG           92026
#define EMSG_DHCP_CLIENT_COMMENT_TOOLONG        92027
#define EMSG_DHCP_INVALID_RESERVATION_TYPE      92028
#define EMSG_DHCP_FAILED_SCAN                   92029
#define EMSG_DHCP_INVALID_DEFAULTSCOPE_PARAM    92030
#define EMSG_DHCP_INVALID_GLOBAL_OPTION         92031
#define EMSG_DHCP_COMMAND_FAILED                92032
#define EMSG_DHCP_COMMAND_FAILED_STRING         92033
#define EMSG_DHCP_COMMAND_PART_FAILED           92034
#define EMSG_SCOPE_INTERNAL_ERROR               92035
#define EMSG_SCOPE_DISPLAY_CLIENTS              92036
#define ERROR_INVALID_COMPUTER_NAME             92037
#define EMSG_SCOPE_INVALID_IPRANGE              92038
#define EMSG_SCOPE_INVALID_STARTADDRESS         92039
#define EMSG_SCOPE_INVALID_ENDADDRESS           92040

#define EMSG_SCOPE_ADD_IPRANGE                   93001
#define EMSG_SCOPE_ADD_EXCLUDERANGE              93002
#define EMSG_SCOPE_ADD_RESERVEDIP                93003

#define EMSG_SCOPE_DELETE_IPRANGE                93101
#define EMSG_SCOPE_DELETE_EXCLUDERANGE           93102
#define EMSG_SCOPE_DELETE_RESERVEDIP             93103
#define EMSG_SCOPE_DELETE_OPTIONVALUE            93104
#define EMSG_SCOPE_DELETE_RESERVEDOPTIONVALUE    93105

#define EMSG_SCOPE_CHECK_DATABASE                93201

#define EMSG_SCOPE_SET_COMMENT                   93301
#define EMSG_SCOPE_SET_NAME                      93302
#define EMSG_SCOPE_SET_SCOPE                     93303
#define EMSG_SCOPE_SET_OPTIONVALUE               93304
#define EMSG_SCOPE_SET_RESERVEDOPTIONVALUE       93305
#define EMSG_SCOPE_SET_STATE                     93306
#define EMSG_SCOPE_SET_SUPERSCOPE                93307

#define EMSG_SCOPE_SHOW_CLIENTS                  93401
#define EMSG_SCOPE_SHOW_CLIENTSV5                93402
#define EMSG_SCOPE_SHOW_IPRANGE                  93403
#define EMSG_SCOPE_SHOW_MIBINFO                  93404
#define EMSG_SCOPE_SHOW_EXCLUDERANGE             93405
#define EMSG_SCOPE_SHOW_RESERVEDIP               93406
#define EMSG_SCOPE_SHOW_OPTIONVALUE              93407
#define EMSG_SCOPE_SHOW_SCOPE                    93408
#define EMSG_SCOPE_SHOW_RESERVEDOPTIONVALUE      93409
#define EMSG_SCOPE_SHOW_STATE                    93410
#define EMSG_SCOPE_DEFAULT_LEASE_TIME            93411
#define EMSG_SCOPE_INVALID_EXCLUDERANGE          93412
#define EMSG_DHCP_RECONCILE_SUCCESS              93413

#define MSG_SCOPE_OPTION_INFO                    320150
#define MSG_SCOPE_OPTION_ID                      320151
#define MSG_SCOPE_OPTION_NAME                    320152
#define MSG_SCOPE_OPTION_COMMENT                 320153
#define MSG_SCOPE_OPTION_TYPE1                   320154
#define MSG_SCOPE_OPTION_COUNT                   320155
#define MSG_SCOPE_OPTION_READ                    320156
#define MSG_SCOPE_OPTION_TOTAL                   320157
#define MSG_SCOPE_OPTION_PROPS                   320158
#define MSG_SCOPE_OPTIONS                        320159
#define MSG_SCOPE_CLASS_VENDOR                   320160
#define MSG_SCOPE_CLASS_USER                     320161
#define MSG_SCOPE_RANGE_START                    320162
#define MSG_SCOPE_RANGE_END                      320163
#define MSG_SCOPE_IPRANGE                        320164
#define MSG_SCOPE_EXCLUDERANGE                   320165
#define MSG_SCOPE_RESERVEDIP                     320166
#define MSG_DHCP                                 320167
#define MSG_SCOPE_DHCPBOOTP                      320168
#define MSG_SCOPE_BOOTP                          320169
#define MSG_SCOPE_IPADDRESS                      320170
#define MSG_SCOPE_FIX_REGISTRY                   320171
#define MSG_SCOPE_FIX_DATABASE                   320172
#define MSG_SCOPE_FIX_UNKNOWN                    320173
#define MSG_SCOPE_CLIENT_INFO                    320174
#define MSG_SCOPE_CLIENT_NAME                    320175
#define MSG_SCOPE_CLIENT_HWADDRESS               320176
#define MSG_SCOPE_CLIENT_COMMENT                 320177
#define MSG_SCOPE_CLIENT_TYPE                    320178
#define MSG_SCOPE_CLIENT_HWADDRESS_FORMAT        320179
#define MSG_SCOPE_CLIENT_IPADDRESS               320180
#define MSG_SCOPE_CLIENT_SUBNET_MASK             320181
#define MSG_SCOPE_CLIENT_DURATION                320182
#define MSG_SCOPE_CLIENT_DURATION_STR            320183
#define MSG_SCOPE_CLIENT_DURATION_DATE_STARTS    320184
#define MSG_SCOPE_OWNER_NAME                     320185
#define MSG_SCOPE_OWNER_NETBIOSNAME              320186
#define MSG_SCOPE_OWNER_IPADDRESS                320187
#define MSG_SCOPE_CLIENT_STATE                   320188
#define MSG_SCOPE_CLIENT                         320189
#define MSG_SCOPE_SUPERSCOPE_NAME                320190
#define MSG_SCOPE_SUPERSCOPE_SUBNET              320191
#define MSG_SCOPE_SUPERSCOPE_GROUP               320192
#define MSG_SCOPE_MULTICAST_CLIENT_COUNT         320193
#define MSG_SCOPE_MULTICAST_SCOPES               320194
#define MSG_SCOPE_MULTICAST_SCOPEID              320195
#define MSG_SCOPE_SERVER_INFO                    320196
#define MSG_SCOPE_SERVER_INFO_ARRAY              320197
#define MSG_SCOPE_CLASS_INFO                     320198
#define MSG_SCOPE_CLASS_INFO_ARRAY               320199
#define MSG_SCOPE_CLASS_DATA                     320200
#define MSG_SCOPE_CLASS_DATA_FORMAT              320201
#define MSG_SCOPE_CLIENT_READ                    320202
#define MSG_SCOPE_CLIENT_COUNT                   320203
#define MSG_SCOPE_SERVERS_DELETING               320204
#define MSG_SCOPE_SERVERS_ADDING                 320205
#define MSG_SCOPE_RESERVEDIP_HWADDRESS			 320206
#define MSG_SCOPE_DHCP                           320207
#define MSG_SCOPE_STATE_ACTIVE                   320208
#define MSG_SCOPE_SERVER                         320209
#define MSG_SCOPE_CLIENTS_COUNT                  320210
#define MSG_SCOPE_CLIENTSV5_COUNT                320211
#define MSG_SCOPE_IPRANGE_COUNT                  320212
#define MSG_SCOPE_EXCLUDERANGE_COUNT             320213
#define MSG_SCOPE_RESERVEDIP_COUNT               320214
#define MSG_SCOPE_OPTION_ALL                     320215
#define MSG_SCOPE_OPTION_CLASS                   320216
#define MSG_SCOPE_RESERVEDOPTION_ALL             320217
#define MSG_SCOPE_RESERVEDOPTION_CLASS           320218
#define MSG_SCOPE_IPRANGE_TABLE                  320219
#define MSG_SCOPE_IPRANGE_INFO_DHCP              320220
#define MSG_SCOPE_EXCLUDERANGE_TABLE             320221
#define MSG_SCOPE_EXCLUDERANGE_INFO              320222
#define MSG_SCOPE_RESERVEDIP_TABLE               320223
#define MSG_SCOPE_RESERVEDIP_INFO                320224
#define MSG_SCOPE_CLIENT_TABLE                   320225
#define MSG_SCOPE_CHANGE_CONTEXT                 320226
#define MSG_SCOPE_CLIENT_DURATION_DATE_EXPIRES   320227
#define MSG_SCOPE_STATE_NOTACTIVE                320228
#define MSG_SCOPE_CLIENT_INFO_NEVER              320229
#define MSG_SCOPE_CLIENT_INFO_INACTIVE           320230
#define MSG_MSCOPE_CLIENT_INFO                   320231
#define MSG_SCOPE_IPRANGE_INFO_DHCPONLY          320232
#define MSG_SCOPE_IPRANGE_INFO_DHCPBOOTP         320233
#define MSG_SCOPE_IPRANGE_INFO_BOOTP             320234
#define MSG_SCOPE_IPRANGE_INFO_UNKNOWN           320235
#define MSG_SCOPE_STATE_ACTIVE_SWITCHED          320236
#define MSG_SCOPE_STATE_NOTACTIVE_SWITCHED       320237
#define MSG_SCOPE_CLIENT_TABLE2                  320238
#define MSG_SCOPE_CLIENT_INFO2_NEVER             320239
#define MSG_SCOPE_CLIENT_INFO2_INACTIVE          320240
#define MSG_SCOPE_CLIENT_INFO2                  320241

#define MSG_MSCOPE_MIB                             351041
#define MSG_MSCOPE_MIB_DISCOVERS                   351042
#define MSG_MSCOPE_MIB_OFFERS                      351043
#define MSG_MSCOPE_MIB_REQUESTS                    351044
#define MSG_MSCOPE_MIB_RENEWS                      351045
#define MSG_MSCOPE_MIB_ACKS                        351055
#define MSG_MSCOPE_MIB_NAKS                        351056
#define MSG_MSCOPE_MIB_DECLINES                    351057
#define MSG_MSCOPE_MIB_RELEASES                    351058
#define MSG_MSCOPE_MIB_SERVERSTARTTIME             351059
#define MSG_MSCOPE_MIB_SCOPES                      351060
#define MSG_MSCOPE_MIB_SCOPES_SUBNET               351061
#define MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMADDRESSESINUSE  351062
#define MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMADDRESSESFREE   351063
#define MSG_MSCOPE_MIB_SCOPES_SUBNET_NUMPENDINGOFFERS   351064
#define MSG_MSCOPE_MIB_INFORMS                     351065
#define MSG_MSCOPE_MIB_RECONFIGURES                351066
#define MSG_MSCOPE_OPTION_ALL                      351067
#define MSG_MSCOPE_CHANGE_CONTEXT                  351068


#define CMD_MSCOPE_LIST                           L"list"
#define CMD_MSCOPE_HELP1                          L"help"
#define CMD_MSCOPE_HELP2                          L"/?"
#define CMD_MSCOPE_HELP3                          L"-?"
#define CMD_MSCOPE_HELP4                          L"?"
#define CMD_MSCOPE_DUMP                           L"dump"

#define CMD_MSCOPE_ADD_IPRANGE                    L"add      iprange"
#define CMD_MSCOPE_ADD_EXCLUDERANGE               L"add      excluderange"
    
#define CMD_MSCOPE_CHECK_DATABASE                 L"initiate reconcile"

#define CMD_MSCOPE_DELETE_IPRANGE                 L"delete   iprange"
#define CMD_MSCOPE_DELETE_EXCLUDERANGE            L"delete   excluderange"
#define CMD_MSCOPE_DELETE_OPTIONVALUE             L"delete   optionvalue"
    
#define CMD_MSCOPE_SET_COMMENT                    L"set      comment"
#define CMD_MSCOPE_SET_NAME                       L"set      name"
#define CMD_MSCOPE_SET_STATE                      L"set      state"
#define CMD_MSCOPE_SET_MSCOPE                     L"set      mscope"
#define CMD_MSCOPE_SET_OPTIONVALUE                L"set      optionvalue"
#define CMD_MSCOPE_SET_TTL                        L"set      ttl"
#define CMD_MSCOPE_SET_LEASE                      L"set      lease"
#define CMD_MSCOPE_SET_EXPIRY                     L"set      scopelife"


#define CMD_MSCOPE_SHOW_CLIENTS                   L"show     clients"
#define CMD_MSCOPE_SHOW_IPRANGE                   L"show     iprange"
#define CMD_MSCOPE_SHOW_EXCLUDERANGE              L"show     excluderange"
#define CMD_MSCOPE_SHOW_MSCOPE                    L"show     mscope"
#define CMD_MSCOPE_SHOW_STATE                     L"show     state"
#define CMD_MSCOPE_SHOW_MIBINFO                   L"show     mibinfo"
#define CMD_MSCOPE_SHOW_OPTIONVALUE               L"show     optionvalue"
#define CMD_MSCOPE_SHOW_TTL                       L"show     ttl"
#define CMD_MSCOPE_SHOW_LEASE                     L"show     lease"
#define CMD_MSCOPE_SHOW_EXPIRY                    L"show     scopelife"


#define HLP_MSCOPE_HELP1                          326002
#define HLP_MSCOPE_HELP2                          326004
#define HLP_MSCOPE_HELP2_EX                       326005
#define HLP_MSCOPE_HELP3                          326006
#define HLP_MSCOPE_HELP3_EX                       326007
#define HLP_MSCOPE_HELP4                          326008
#define HLP_MSCOPE_HELP4_EX                       326009
#define HLP_MSCOPE_LIST                           326010
#define HLP_MSCOPE_LIST_EX                        326011
#define HLP_MSCOPE_DUMP                           326012
#define HLP_MSCOPE_DUMP_EX                        326013


#define HLP_MSCOPE_ADD_IPRANGE                    331001
#define HLP_MSCOPE_ADD_IPRANGE_EX                 331002
#define HLP_MSCOPE_ADD_EXCLUDERANGE               331003
#define HLP_MSCOPE_ADD_EXCLUDERANGE_EX            331004

#define HLP_MSCOPE_DELETE_IPRANGE                 332001
#define HLP_MSCOPE_DELETE_IPRANGE_EX              332002
#define HLP_MSCOPE_DELETE_EXCLUDERANGE            332003
#define HLP_MSCOPE_DELETE_EXCLUDERANGE_EX         332004
#define HLP_MSCOPE_DELETE_OPTIONVALUE             332005
#define HLP_MSCOPE_DELETE_OPTIONVALUE_EX          332006

#define HLP_MSCOPE_CHECK_DATABASE                 333001
#define HLP_MSCOPE_CHECK_DATABASE_EX              333002

#define HLP_MSCOPE_SET_MSCOPE                     334001
#define HLP_MSCOPE_SET_MSCOPE_EX                  334002
#define HLP_MSCOPE_SET_STATE                      334003
#define HLP_MSCOPE_SET_STATE_EX                   334004
#define HLP_MSCOPE_SET_NAME                       334005
#define HLP_MSCOPE_SET_NAME_EX                    334006
#define HLP_MSCOPE_SET_COMMENT                    334007
#define HLP_MSCOPE_SET_COMMENT_EX                 334008
#define HLP_MSCOPE_SET_OPTIONVALUE                334009
#define HLP_MSCOPE_SET_OPTIONVALUE_EX             334010
#define HLP_MSCOPE_SET_TTL                        334011
#define HLP_MSCOPE_SET_TTL_EX                     334012
#define HLP_MSCOPE_SET_LEASE                      334013
#define HLP_MSCOPE_SET_LEASE_EX                   334014
#define HLP_MSCOPE_SET_EXPIRY                     334015
#define HLP_MSCOPE_SET_EXPIRY_EX                  334016



#define HLP_MSCOPE_SHOW_MSCOPE                    335001
#define HLP_MSCOPE_SHOW_MSCOPE_EX                 335002
#define HLP_MSCOPE_SHOW_IPRANGE                   335003
#define HLP_MSCOPE_SHOW_IPRANGE_EX                335004
#define HLP_MSCOPE_SHOW_EXCLUDERANGE              335005
#define HLP_MSCOPE_SHOW_EXCLUDERANGE_EX           335006
#define HLP_MSCOPE_SHOW_MIBINFO                   335007
#define HLP_MSCOPE_SHOW_MIBINFO_EX                335008
#define HLP_MSCOPE_SHOW_CLIENTS                   335009
#define HLP_MSCOPE_SHOW_CLIENTS_EX                335010
#define HLP_MSCOPE_SHOW_STATE                     335011
#define HLP_MSCOPE_SHOW_STATE_EX                  335012
#define HLP_MSCOPE_SHOW_OPTIONVALUE               335013
#define HLP_MSCOPE_SHOW_OPTIONVALUE_EX            335014
#define HLP_MSCOPE_SHOW_TTL                       335015
#define HLP_MSCOPE_SHOW_TTL_EX                    335016
#define HLP_MSCOPE_SHOW_LEASE                     335017
#define HLP_MSCOPE_SHOW_LEASE_EX                  335018
#define HLP_MSCOPE_SHOW_EXPIRY                    335019
#define HLP_MSCOPE_SHOW_EXPIRY_EX                 335020



#define DMP_MSCOPE_ADD_IPRANGE                    341101
#define DMP_MSCOPE_ADD_EXCLUDERANGE               341102

#define DMP_MSCOPE_DELETE_IPRANGE                 341201
#define DMP_MSCOPE_DELETE_EXCLUDERANGE            341202

#define DMP_MSCOPE_CHECK_DATABASE                 341301

#define DMP_MSCOPE_SET_MSCOPE                     341401
#define DMP_MSCOPE_SET_NAME                       341402
#define DMP_MSCOPE_SET_COMMENT                    341403
#define DMP_MSCOPE_SET_STATE                      341404

#define DMP_MSCOPE_SHOW_STATE                     341501
#define DMP_MSCOPE_SHOW_IPRANGE                   341502
#define DMP_MSCOPE_SHOW_EXCLUDERANGE              341503
#define DMP_MSCOPE_SHOW_MIBINFO                   341504
#define DMP_MSCOPE_SHOW_MSCOPE                    341505
#define DMP_MSCOPE_SHOW_CLIENTS                   341506

#define EMSG_MSCOPE_ADD_IPRANGE                   393001
#define EMSG_MSCOPE_ADD_EXCLUDERANGE              393002

#define EMSG_MSCOPE_DELETE_IPRANGE                393101
#define EMSG_MSCOPE_DELETE_EXCLUDERANGE           393102
#define EMSG_MSCOPE_DELETE_OPTIONVALUE            393103

#define EMSG_MSCOPE_CHECK_DATABASE                393201

#define EMSG_MSCOPE_SET_COMMENT                   393301
#define EMSG_MSCOPE_SET_NAME                      393302
#define EMSG_MSCOPE_SET_MSCOPE                    393303
#define EMSG_MSCOPE_SET_STATE                     393304
#define EMSG_MSCOPE_SET_OPTIONVALUE               393305
#define EMSG_MSCOPE_SET_TTL                       393396
#define EMSG_MSCOPE_SET_LEASE                     393397
#define EMSG_MSCOPE_SET_EXPIRY                    393398


#define EMSG_MSCOPE_SHOW_CLIENTS                  393401
#define EMSG_MSCOPE_SHOW_IPRANGE                  393402
#define EMSG_MSCOPE_SHOW_MIBINFO                  393403
#define EMSG_MSCOPE_SHOW_EXCLUDERANGE             393404
#define EMSG_MSCOPE_SHOW_MSCOPE                   393405
#define EMSG_MSCOPE_SHOW_STATE                    393406
#define EMSG_MSCOPE_SHOW_OPTIONVALUE              393407
#define EMSG_MSCOPE_SHOW_TTL                      393408
#define EMSG_MSCOPE_SHOW_LEASE                    393409
#define EMSG_MSCOPE_SHOW_EXPIRY                   393410

#define EMSG_MSCOPE_NO_MSCOPENAME                 393411
#define EMSG_MSCOPE_INVALID_MSCOPE_NAME           393412
#define EMSG_MSCOPE_LEASE_NOTSET                  393413
#define EMSG_MSCOPE_IPRANGE_VERIFY                390414

#define MSG_MSCOPE_MSCOPE                         380209
#define MSG_MSCOPE_CLIENTS_COUNT                  380210
#define MSG_MSCOPE_IPRANGE_COUNT                  380212
#define MSG_MSCOPE_EXCLUDERANGE_COUNT             380213
#define MSG_MSCOPE_STATE_ACTIVE                   380214
#define MSG_MSCOPE_STATE_NOTACTIVE                380215
#define MSG_MSCOPE_MIB_MSCOPENAME                 380216
#define MSG_MSCOPE_MIB_MSCOPEID                   380217
#define MSG_MSCOPE_TTL                            380218
#define MSG_MSCOPE_LEASE                          380219
#define MSG_MSCOPE_EXPIRY                         380220
#define MSG_MSCOPE_INFINITE_EXPIRATION            380221
#define MSG_MSCOPE_INFINITE_LEASE                 380222

#define HLP_SRVR_PROMPT_PASSWORD                  400000

#endif //__STDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\common.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
#ifndef _COMMON_H_
#define _COMMON_H_

#define MAX_IP_STRING_LEN   15

#ifdef UNICODE
#define STRICMP(x, y)    _wcsicmp(x, y)
#else
#define STRICMP(x, y)    _stricmp(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRTOUL(x, y, z)    wcstoul(x, y, z)
#else
#define STRTOUL(x, y, z)    strtoul(x, y, z)
#endif  //UNICODE

#ifdef UNICODE
#define STRCHR(x, y)        wcschr(x, y)
#else
#define STRCHR(x, y)        strchr(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRCAT(x, y)        wcscat(x, y)
#else
#define STRCAT(x, y)        strcat(x, y)
#endif  //UNICODE

#ifdef UNICODE
#define STRLEN(x)        wcslen(x)
#else
#define STRCAT(x)        strlen(x)
#endif  //UNICODE

#ifdef UNICODE
#define ATOI(x)        _wtoi(x)
#else
#define ATOI(x)        atoi(x)
#endif  //UNICODE

#ifdef NT5
#define CHKNULL(Str) ((Str)?(Str):TEXT("<None>"))
#endif  //NT5

#ifdef UNICODE
#define IpAddressToString   DhcpIpAddressToDottedStringW
#else
#define IpAddressToString   DhcpIpAddressToDottedString
#endif //UNICODE

#ifdef UNICODE
#define StringToIpAddress   DhcpDottedStringToIpAddressW
#else
#define StringToIpAddress   DhcpDottedStringToIpAddress
#endif //UNICODE

#undef DhcpAllocateMemory
#undef DhcpFreeMemory

#ifndef _DEBUG
#define DEBUG(s)
#define DEBUG1(s1,s2)
#define DEBUG2(s1,s2)
#else
#define DEBUG(s) wprintf(L"%s\n", L##s)
#define DEBUG1(s1,s2) wprintf(L##s1, L##s2)
#define DEBUG2(s1,s2) wprintf(L##s1, L##s2)
#endif

#define SRVRMON_VERSION_50      5
#define DHCPMON_VERSION_50      5
#define SCOPEMON_VERSION_50     5

#define is                      ==
#define isnot                   !=
#define or                      ||
#define and                     &&

#define CLASS_ID_VERSION        0x5
#define MAX_STRING_LEN          256

#define REG_VALUE_ENTRY_PT        L"EntryPoint"
#define REG_VALUE_DUMP_FN         L"DumpFunction"
#define REG_KEY_DHCPSCOPE_HELPER  L"SOFTWARE\\Microsoft\\Netsh\\Dhcp\\Server\\Scope"
#define REG_KEY_DHCPSRVR_HELPER   L"SOFTWARE\\Microsoft\\Netsh\\Dhcp\\Server"
#define REG_KEY_DHCPMGR_HELPER    L"SOFTWARE\\Microsoft\\Netsh\\Dhcp"

#define MaxIfDisplayLength 1024
#define ADDR_LENGTH          24
#define ADDR_LEN              4

#define DEFAULT_DHCP_LEASE         8*24*60*60
#define DEFAULT_BOOTP_LEASE        30*24*60*60
#define DEFAULT_MULTICAST_TTL      0x20
#define INFINIT_TIME               0x7FFFFFFF  // time_t is int
#define INFINIT_LEASE              0xFFFFFFFF  // in secs. (unsigned int.)


typedef struct _COMMAND_OPTION_TYPE
{
    LPWSTR                  pwszTagID;
    DHCP_OPTION_DATA_TYPE   DataType;
    LPWSTR                  pwcTag;
} COMMAND_OPTION_TYPE, *PCOMMAND_OPTION_TYPE;

extern COMMAND_OPTION_TYPE TagOptionType[ 8 ];/* = 
    { TAG_OPTION_BYTE,          DhcpByteOption,             L"BYTE" },
    { TAG_OPTION_WORD,          DhcpWordOption,             L"WORD" },
    { TAG_OPTION_DWORD,         DhcpDWordOption,            L"DWORD" },
    { TAG_OPTION_DWORDDWORD,    DhcpDWordDWordOption,       L"DWORDDWORD" },
    { TAG_OPTION_IPADDRESS,     DhcpIpAddressOption,        L"IPADDRESS" },
    { TAG_OPTION_STRING,        DhcpStringDataOption,       L"STRING" },
    { TAG_OPTION_BINARY,        DhcpBinaryDataOption,       L"BINARY" },
    { TAG_OPTION_ENCAPSULATED,  DhcpEncapsulatedDataOption, L"ENCAPSULATED" }
*/
#define DISPLAYLEN_PHYSADDR 3*MAXLEN_PHYSADDR + 8

#define PRINT(s) wprintf(L"%s\n",L##s)
#define PRINT1(s,s1) wprintf(L##s , L##s1)

#ifdef UNICODE
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    MultiByteToWideChar(CP_ACP,                            \
                        0,                                 \
                        (pszAddr),                         \
                        -1,                                \
                        (ptszUnicode),                     \
                        ADDR_LENGTH)
#else
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    strcpy((ptszUnicode),(pszAddr))
#endif //UNICODE

#ifdef UNICODE
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    MultiByteToWideChar(CP_ACP,                             \
                        0,                                  \
                        (__szTemp),                         \
                        -1,                                 \
                        (ptszUnicode),                      \
                        3*__i);                             \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#else
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    strncpy((ptszUnicode),__szTemp,3*__i);                  \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#endif //UNICODE

#define     GetDispString(gModule, val, str, count, table)                           \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for( ; __dwInd < (count); __dwInd += 2 )                                \
    {                                                                       \
        if ( (val) != (table)[ __dwInd ] ) { continue; }                    \
        (str) = MakeString( (gModule), (table)[ __dwInd + 1 ] );                       \
        break;                                                              \
    }                                                                       \
    if ( __dwInd >= (count) ) { (str) = MakeString( (gModule), STRING_UNKNOWN ); }     \
}

#define FREE_STRING_NOT_NULL(ptszString) if (ptszString) FreeString(ptszString)

#define ERROR_CONFIG                    1
#define ERROR_ADMIN                     2
#define ERROR_UNIDENTIFIED_MIB 2312
#define ERROR_TOO_FEW_ARGS     (ERROR_UNIDENTIFIED_MIB+1)

#define MAX_NUM_INDICES 6

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define IP_TO_WSTR(str,addr) swprintf((str),L"%d.%d.%d.%d", \
				    (addr)[0],    \
				    (addr)[1],    \
				    (addr)[2],    \
				    (addr)[3])




#define GET_TOKEN_PRESENT(tokenMask) (dwBitVector & tokenMask)
#define SET_TOKEN_PRESENT(tokenMask) (dwBitVector |= tokenMask)

#define SetErrorType(pdw)   *(pdw) = IsRouterRunning()?ERROR_ADMIN:ERROR_CONFIG
#define INFINITE_EXPIRATION 0x7FFFFFFF


#define MSCOPE_START_RANGE      StringToIpAddress(L"224.0.0.0")
#define MSCOPE_END_RANGE        StringToIpAddress(L"239.255.255.255")

WCHAR  StringToHex(LPCWSTR pwcString);
LPSTR  StringToHexString(LPCSTR pszStr);

DHCP_IP_ADDRESS
DhcpDefaultSubnetMask(
    DHCP_IP_ADDRESS IpAddress
    );

DWORD
FormatDateTimeString( FILETIME ftTime,
                      BOOL    fShort,
                      LPWSTR  pwszBuffer,
                      DWORD  *pdwBuffLen);

LPWSTR
GetDateTimeString(FILETIME  TimeStamp,
                  BOOL      fShort,
                  int      *piType
                  );

PVOID
DhcpAllocateMemory(
    IN  DWORD Size
    );

VOID
DhcpFreeMemory(
    IN  PVOID Memory
    );


DATE_TIME
DhcpCalculateTime(
    IN  DWORD RelativeTime
    );

LPWSTR
DhcpOemToUnicodeN(
    IN      LPCSTR  Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    );

LPWSTR
DhcpOemToUnicode(
    IN      LPCSTR Ansi,
    IN OUT  LPWSTR Unicode
    );

LPSTR
DhcpUnicodeToOem(
    IN  LPCWSTR Unicode,
    OUT LPSTR   Ansi
    );

VOID
DhcpHexToString(
    OUT LPWSTR  Buffer,
    IN  const BYTE * HexNumber,
    IN  DWORD Length
    );

VOID
DhcpHexToAscii(
    IN  LPSTR Buffer,
    IN  LPBYTE HexNumber,
    IN  DWORD Length
    );

VOID
DhcpDecimalToString(
    IN  LPWSTR Buffer,
    IN  BYTE Number
    );

DWORD
DhcpDottedStringToIpAddress(
    IN  LPSTR String
    );

LPSTR
DhcpIpAddressToDottedString(
    IN  DWORD IpAddress
    );

DWORD
DhcpStringToHwAddress(
    OUT LPSTR  AddressBuffer,
    IN  LPCSTR AddressString
    );

DWORD
DhcpDottedStringToIpAddressW(
    IN  LPCWSTR pwszString
);

LPWSTR
DhcpIpAddressToDottedStringW(
    IN  DWORD   IpAddress
);

LPWSTR
DhcpRegIpAddressToKey(
    IN  DHCP_IP_ADDRESS IpAddress,
    IN  LPCWSTR KeyBuffer
    );

DWORD
DhcpRegKeyToIpAddress(
    IN  LPCWSTR Key
    );

LPWSTR
DhcpRegOptionIdToKey(
    IN  DHCP_OPTION_ID OptionId,
    IN  LPCWSTR KeyBuffer
    );

DHCP_OPTION_ID
DhcpRegKeyToOptionId(
    IN  LPCWSTR Key
    );

#if DBG



VOID
DhcpPrintRoutine(
    IN DWORD  DebugFlag,
    IN LPCSTR Format,
    ...
);

VOID
DhcpAssertFailed(
    IN LPCSTR FailedAssertion,
    IN LPCSTR FileName,
    IN DWORD LineNumber,
    IN LPSTR Message
    );

#define DhcpPrint(_x_)   DhcpPrintRoutine _x_


#define DhcpAssert(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#define DhcpVerify(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#else

#define DhcpAssert(_x_)
#define DhcpDumpMessage(_x_, _y_)
#define DhcpVerify(_x_) (_x_)

#endif // not DBG

DWORD
CreateDumpFile(
    IN  PWCHAR  pwszName,
    OUT PHANDLE phFile
    );


VOID
CloseDumpFile(
    IN HANDLE  hFile
    );


BOOL
IsIpAddress(
    IN LPCWSTR pwszAddress
);

BOOL
IsValidServer(
    IN LPCWSTR  pwszServer
);

BOOL
IsLocalServer( 
    IN LPCWSTR  pwszServer
);

BOOL
IsValidScope(
    IN LPCWSTR  pwszServer,
    IN LPCWSTR  pwszAddress
);

BOOL
IsValidMScope(
    IN LPCWSTR  pwszServer,  
    IN LPCWSTR  pwszMScope
);

BOOL
IsPureHex(
    IN LPCWSTR  pwszString
);

DWORD
DhcpDumpServer(
               IN LPCWSTR  pwszIpAddress,
               IN DWORD    dwMajor,
               IN DWORD    dwMinor
               );

PBYTE
GetLangTagA();

VOID
DhcpDumpScriptHeader();

VOID
DhcpDumpServerScriptHeader(IN LPCWSTR pwszServer);

VOID
DhcpDumpServerClass(
                    IN LPCWSTR          pwszServer,
                    IN DHCP_CLASS_INFO ClassInfo);

DWORD
DhcpDumpServerOptiondefV5(IN LPCWSTR             pwszServer,
                          IN LPDHCP_ALL_OPTIONS OptionsAll
                         );

DWORD
DhcpDumpServerOptiondef(IN LPCWSTR               pwszServer,
                        LPDHCP_OPTION_ARRAY  OptionArray
                       );

DWORD
DhcpDumpServerOptionValuesV5(IN LPCWSTR          pwszServer,
                             IN LPCWSTR          pwszScope,
                             IN LPCWSTR          pwszReserved,
                             IN LPDHCP_ALL_OPTION_VALUES OptionValues
                            );

DWORD
DhcpDumpServerOptionValue(IN LPCWSTR             pwszServer,
                          IN LPCWSTR             pwszScope,
                          IN LPCWSTR             pwszReserved,
                          IN LPCWSTR             pwcUser,
                          IN LPCWSTR             pwcVendor,
                          IN BOOL               fIsV5,
                          IN DHCP_OPTION_VALUE  OptionValue);

DWORD
DhcpDumpReservedOptionValues(
                             IN LPCWSTR     pwszServer,
                             IN DWORD      dwMajor,
                             IN DWORD      dwMinor,
                             IN LPCWSTR     pwszScope,
                             IN LPCWSTR     pwszReservedIp
                             );

DWORD
DhcpDumpScope(IN LPCWSTR  pwszServerIp,
              IN DWORD   dwMajor,
              IN DWORD   dwMinor,
              IN DWORD   ScopeIp);

VOID
DhcpDumpSuperScopes( IN LPCWSTR pwszServer, 
		     IN DWORD dwMajor, 
		     IN DWORD dwMinor );


DWORD
DhcpDumpServerMScope(IN LPCWSTR pwszServer,
                     IN DWORD  dwMajor,
                     IN DWORD  dwMinor,
                     IN LPCWSTR pwszMScope
                     );

VOID
DhcpDumpServerClassHeader();

VOID
DhcpDumpServerClassFooter();

VOID
DhcpDumpServerOptiondefHeader();

VOID
DhcpDumpServerOptiondefFooter();

VOID
DhcpDumpServerOptionvalueHeader();

VOID
DhcpDumpServerOptionvalueFooter();

VOID
DhcpDumpServerScopeHeader();

VOID
DhcpDumpServerScopeFooter();

VOID
DhcpDumpServerMScopeHeader();

VOID
DhcpDumpServerMScopeFooter();

VOID
DhcpDumpServerConfig(IN LPCWSTR pwszServer);



VOID
DhcpDumpScriptFooter();

VOID
DhcpDumpServerScriptFooter();

NS_CONTEXT_DUMP_FN DhcpDump;

BOOL
IsPureNumeric(IN LPCWSTR pwszStr);

LPWSTR
MakeDayTimeString(
               IN DWORD dwTime
);

#endif //_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\dhcpdefs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\defs.h

Abstract:

    global definitions

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#ifndef _DEBUG
#define DEBUG(s)
#define DEBUG1(s1,s2)
#define DEBUG2(s1,s2)
#else
#define DEBUG(s) wprintf(L"%s\n", L##s)
#define DEBUG1(s1,s2) wprintf(L##s1, L##s2)
#define DEBUG2(s1,s2) wprintf(L##s1, L##s2)
#endif

#define is ==
#define isnot !=
#define or ||
#define and &&

#define REG_VALUE_ENTRY_PT        L"EntryPoint"
#define REG_VALUE_DUMP_FN         L"DumpFunction"
#define REG_KEY_DHCPMGR_HELPER    L"SOFTWARE\\Microsoft\\Netsh\\Dhcp"

#define MaxIfDisplayLength 1024
#define ADDR_LENGTH          24
#define ADDR_LEN              4

#define DISPLAYLEN_PHYSADDR 3*MAXLEN_PHYSADDR + 8

#define PRINT(s) wprintf(L"%s\n",L##s)
#define PRINT1(s,s1) wprintf(L##s , L##s1)

#ifdef UNICODE
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    MultiByteToWideChar(CP_ACP,                            \
                        0,                                 \
                        (pszAddr),                         \
                        -1,                                \
                        (ptszUnicode),                     \
                        ADDR_LENGTH)
#else
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    strcpy((ptszUnicode),(pszAddr))
#endif //UNICODE

#ifdef UNICODE
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    MultiByteToWideChar(CP_ACP,                             \
                        0,                                  \
                        (__szTemp),                         \
                        -1,                                 \
                        (ptszUnicode),                      \
                        3*__i);                             \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#else
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    strncpy((ptszUnicode),__szTemp,3*__i);                  \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#endif //UNICODE

#define     GetDispString(gModule, val, str, count, table)                           \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for( ; __dwInd < (count); __dwInd += 2 )                                \
    {                                                                       \
        if ( (val) != (table)[ __dwInd ] ) { continue; }                    \
        (str) = MakeString( (gModule), (table)[ __dwInd + 1 ] );                       \
        break;                                                              \
    }                                                                       \
    if ( __dwInd >= (count) ) { (str) = MakeString( (gModule), STRING_UNKNOWN ); }     \
}

#define FREE_STRING_NOT_NULL(ptszString) if (ptszString) FreeString(ptszString)

#define ERROR_CONFIG                    1
#define ERROR_ADMIN                     2
#define ERROR_UNIDENTIFIED_MIB 2312
#define ERROR_TOO_FEW_ARGS     (ERROR_UNIDENTIFIED_MIB+1)

#define MAX_NUM_INDICES 6

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define IP_TO_WSTR(str,addr) swprintf((str),L"%d.%d.%d.%d", \
				    (addr)[0],    \
				    (addr)[1],    \
				    (addr)[2],    \
				    (addr)[3])




#define GET_TOKEN_PRESENT(tokenMask) (dwBitVector & tokenMask)
#define SET_TOKEN_PRESENT(tokenMask) (dwBitVector |= tokenMask)

#define SetErrorType(pdw)   *(pdw) = IsRouterRunning()?ERROR_ADMIN:ERROR_CONFIG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\scopemon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.c

Abstract:

    SRVR Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/
#include "precomp.h"

//
// The DHCP manager's commands are broken into 2 sets
//      - The commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        SHOW or SET.  This is not for any technical reason - only for
//        staying with the semantics used in netsh with which it will be 
//		  integrated
//      - The commands which are supported by the subcontext commands of 
//        the server. The subcontext supported by DHCP is Server.
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// NOTE: Since we have only one entry per group, currently, we really didnt
// need command groups. This is done for later extensibility.
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//


extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;

extern BOOL     g_fMScope;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;
extern PWCHAR   g_pwszServer;
extern WCHAR    g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR     g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
CHAR     g_ScopeIpAddressAnsiString[MAX_IP_STRING_LEN+1];
WCHAR    g_ScopeIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
DHCP_IP_ADDRESS g_ScopeIpAddress = 0;
BOOL     g_fScope;

extern LPWSTR   g_pwszServer;
extern DHCP_IP_ADDRESS g_ServerIpAddress;


ULONG   g_ulScopeInitCount = 0;

CMD_ENTRY  g_ScopeAddCmdTable[] = {
    CREATE_CMD_ENTRY(SCOPE_ADD_EXCLUDERANGE, HandleScopeAddExcluderange),
    CREATE_CMD_ENTRY(SCOPE_ADD_IPRANGE, HandleScopeAddIprange),
    CREATE_CMD_ENTRY(SCOPE_ADD_RESERVEDIP, HandleScopeAddReservedip),
};

CMD_ENTRY  g_ScopeCheckCmdTable[] = {
    CREATE_CMD_ENTRY(SCOPE_CHECK_DATABASE, HandleScopeCheckDatabase),
};

CMD_ENTRY  g_ScopeDeleteCmdTable[] = {
    CREATE_CMD_ENTRY(SCOPE_DELETE_EXCLUDERANGE, HandleScopeDeleteExcluderange),
    CREATE_CMD_ENTRY(SCOPE_DELETE_IPRANGE, HandleScopeDeleteIprange),
    CREATE_CMD_ENTRY(SCOPE_DELETE_OPTIONVALUE, HandleScopeDeleteOptionvalue),
    CREATE_CMD_ENTRY(SCOPE_DELETE_RESERVEDIP, HandleScopeDeleteReservedip),
    CREATE_CMD_ENTRY(SCOPE_DELETE_RESERVEDOPTIONVALUE, HandleScopeDeleteReservedoptionvalue),
};


CMD_ENTRY g_ScopeSetCmdTable[] = {
    CREATE_CMD_ENTRY(SCOPE_SET_COMMENT, HandleScopeSetComment),
    CREATE_CMD_ENTRY(SCOPE_SET_NAME, HandleScopeSetName),
    CREATE_CMD_ENTRY(SCOPE_SET_OPTIONVALUE, HandleScopeSetOptionvalue),
    CREATE_CMD_ENTRY(SCOPE_SET_RESERVEDOPTIONVALUE, HandleScopeSetReservedoptionvalue),
    CREATE_CMD_ENTRY(SCOPE_SET_SCOPE, HandleScopeSetScope),
    CREATE_CMD_ENTRY(SCOPE_SET_STATE, HandleScopeSetState),
    CREATE_CMD_ENTRY(SCOPE_SET_SUPERSCOPE, HandleScopeSetSuperscope),
};

CMD_ENTRY g_ScopeShowCmdTable[] = {
    CREATE_CMD_ENTRY(SCOPE_SHOW_CLIENTS, HandleScopeShowClients),
    CREATE_CMD_ENTRY(SCOPE_SHOW_CLIENTSV5, HandleScopeShowClientsv5),
    CREATE_CMD_ENTRY(SCOPE_SHOW_EXCLUDERANGE, HandleScopeShowExcluderange),
    CREATE_CMD_ENTRY(SCOPE_SHOW_IPRANGE, HandleScopeShowIprange),
//    CREATE_CMD_ENTRY(SCOPE_SHOW_MIBINFO, HandleScopeShowMibinfo),
    CREATE_CMD_ENTRY(SCOPE_SHOW_OPTIONVALUE, HandleScopeShowOptionvalue),
    CREATE_CMD_ENTRY(SCOPE_SHOW_RESERVEDIP, HandleScopeShowReservedip),
    CREATE_CMD_ENTRY(SCOPE_SHOW_RESERVEDOPTIONVALUE, HandleScopeShowReservedoptionvalue),
    CREATE_CMD_ENTRY(SCOPE_SHOW_SCOPE, HandleScopeShowScope),
    CREATE_CMD_ENTRY(SCOPE_SHOW_STATE, HandleScopeShowState),
};


CMD_GROUP_ENTRY g_ScopeCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_ScopeAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_ScopeDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_CHECK, g_ScopeCheckCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_ScopeSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_ScopeShowCmdTable),
};


CMD_ENTRY g_ScopeCmds[] = 
{
    CREATE_CMD_ENTRY(DHCP_LIST, HandleScopeList),
    CREATE_CMD_ENTRY(DHCP_DUMP, HandleScopeDump),
    CREATE_CMD_ENTRY(DHCP_HELP1, HandleScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP2, HandleScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP3, HandleScopeHelp),
    CREATE_CMD_ENTRY(DHCP_HELP4, HandleScopeHelp),
};



ULONG g_ulScopeNumTopCmds = sizeof(g_ScopeCmds)/sizeof(CMD_ENTRY);
ULONG g_ulScopeNumGroups = sizeof(g_ScopeCmdGroups)/sizeof(CMD_GROUP_ENTRY);

DWORD
WINAPI
ScopeCommit(
    IN  DWORD   dwAction
)
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. Srvr current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}


DWORD
WINAPI
ScopeMonitor(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    )
{
    DWORD           dwError = NO_ERROR;
    DWORD           dwIndex, i, j, k;
    BOOL            bFound = FALSE;
    PFN_HANDLE_CMD  pfnHandler = NULL;
    DWORD           dwNumMatched;
    DWORD           dwCmdHelpToken = 0;
    DWORD           dwIsScope = 0;
    PWCHAR          pwcContext = NULL;
    WCHAR           pwszScopeIP[MAX_IP_STRING_LEN+1] = {L'\0'};
    BOOL            fTemp = FALSE;
    if( dwArgCount < 2 )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_NO_SCOPENAME);
        return ERROR_INVALID_PARAMETER;
    }

    dwIndex = 1;

  
    //Is it Scope IpAddress?
    if( IsValidScope(g_ServerIpAddressUnicodeString, ppwcArguments[dwIndex]) )
    {
        if( g_fScope is TRUE and
            dwArgCount > 2 )
        {
            wcscpy(pwszScopeIP, g_ScopeIpAddressUnicodeString);
            fTemp = TRUE;
        }
        if( SetScopeInfo(ppwcArguments[dwIndex]) is FALSE )
        {
            DisplayMessage(g_hModule, EMSG_SCOPE_INVALID_SCOPE_NAME);
            dwError = ERROR_INVALID_PARAMETER;
            goto CleanUp;
        }

        g_fScope = TRUE;
        pwcNewContext[wcslen(pwcNewContext) - wcslen(ppwcArguments[dwIndex]) - 1] = L'\0';
        dwIndex++;
        dwIsScope++;

        if( fTemp is FALSE )
        {
            DisplayMessage(g_hModule,
                           MSG_SCOPE_CHANGE_CONTEXT,
                           g_ScopeIpAddressUnicodeString);
        }
    }

    if( wcslen(g_ScopeIpAddressUnicodeString) is 0 )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_NO_SCOPENAME);

        dwError = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    //No more arguments. Context switch.
    if( dwIndex >= dwArgCount )
    {
        dwError = ERROR_CONTEXT_SWITCH;
        //wcscpy( pwcNewContext, L"dhcp server scope");
        goto CleanUp;
    }

    //Is it a top level(non Group command)?

    for(i=0; i<g_ulScopeNumTopCmds; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_ScopeCmds[i].pwszCmdToken))
        {
            bFound = TRUE;

            pfnHandler = g_ScopeCmds[i].pfnCmdHandler;

            dwCmdHelpToken = g_ScopeCmds[i].dwCmdHlpToken;
            dwIndex++;
            break;
        }
    }


    if(bFound)
    {
        if(dwArgCount > 3 && IsHelpToken(ppwcArguments[dwIndex]))
        {
            DisplayMessage(g_hModule, dwCmdHelpToken);
            
            dwError = NO_ERROR;

            goto CleanUp;
        }
        
        dwIndex++;

        dwError = (*pfnHandler)(pwszMachine, ppwcArguments, dwIndex, dwArgCount,
                                dwFlags, pvData, &bFound);
        
        goto CleanUp;
    }

    if( g_fScope is FALSE )
    {
        DisplayMessage(g_hModule, EMSG_SCOPE_NO_SCOPENAME);
        dwError = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    bFound = FALSE;


    //It is not a non Group Command. Then is it a config command for the manager?
    for(i = 0; (i < g_ulScopeNumGroups) and !bFound; i++)
    {
        if(MatchToken(ppwcArguments[dwIndex],
                      g_ScopeCmdGroups[i].pwszCmdGroupToken))
        {

            //
            // Command matched entry i, so look at the table of sub commands 
            // for this command
            //
            
            if( dwArgCount > dwIndex+1 )
            {
                for (j = 0; j < g_ScopeCmdGroups[i].ulCmdGroupSize; j++)
                {
                    if (MatchCmdLine(ppwcArguments+dwIndex,
                                      dwArgCount - 1,
                                      g_ScopeCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                      &dwNumMatched))
                    {
                        bFound = TRUE;
                
                        pfnHandler = g_ScopeCmdGroups[i].pCmdGroup[j].pfnCmdHandler;
                
                        dwCmdHelpToken = g_ScopeCmdGroups[i].pCmdGroup[j].dwCmdHlpToken;

                        dwIndex++;
                        //
                        // break out of the for(j) loop
                        //
                        break;
                    }
                }

            }
            if(!bFound)
            {
                //
                // We matched the command group token but none of the
                // sub commands
                //

                DisplayMessage(g_hModule, 
                               EMSG_SCOPE_INCOMPLETE_COMMAND);

                for (j = 0; j < g_ScopeCmdGroups[i].ulCmdGroupSize; j++)
                {
                    DisplayMessage(g_hModule, 
                             g_ScopeCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);
                    
                    DisplayMessage(g_hModule,
                                   MSG_DHCP_FORMAT_LINE);
                }

                dwError = ERROR_INVALID_PARAMETER;
                goto CleanUp;
            }
            else
            {
                //
                // quit the for(i)
                //

                break;
            }
        }
    }

    if (!bFound)
    {
        //
        // Command not found. 
        //
        if( _wcsicmp(ppwcArguments[dwIndex], L"..") is 0 )
        {
            memset(g_ScopeIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
            memset(g_ScopeIpAddressAnsiString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(CHAR));
            g_ScopeIpAddress = 0;
            g_fScope = FALSE;
        }

        dwError = ERROR_CMD_NOT_FOUND;
        goto CleanUp;
    }

    //
    // See if it is a request for help.
    //

    dwNumMatched += dwIsScope;

    if (dwNumMatched < (dwArgCount - 1) &&
        IsHelpToken(ppwcArguments[dwNumMatched + 1]))
    {
        DisplayMessage(g_hModule, dwCmdHelpToken);

        dwError = NO_ERROR;
        goto CleanUp;
    }
    
    //
    // Call the parsing routine for the command
    //

    dwError = (*pfnHandler)(pwszMachine, ppwcArguments+1, 
                            dwIndex, 
                            dwArgCount-1 - dwIndex, 
                            dwFlags, pvData, &bFound);

CleanUp:
    if( fTemp )
    {
        fTemp = SetScopeInfo(pwszScopeIP);
    }
    return dwError;
}



DWORD
WINAPI
ScopeUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}


BOOL
SetScopeInfo(
    IN  LPWSTR  pwszScope
)
{
    DWORD   dwError = NO_ERROR;
    DHCP_IP_ADDRESS IpAddress = StringToIpAddress(pwszScope);
    LPDHCP_SUBNET_INFO  SubnetInfo = NULL;
    LPSTR Tmp;
    
    dwError = DhcpGetSubnetInfo(
                            g_ServerIpAddressUnicodeString,
                            IpAddress,
                            &SubnetInfo);

    if( dwError isnot NO_ERROR )
    {
        return FALSE;
    }

    DhcpRpcFreeMemory(SubnetInfo);
    SubnetInfo = NULL;
    memset(g_ScopeIpAddressUnicodeString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(WCHAR));
    wcscpy(g_ScopeIpAddressUnicodeString, pwszScope);
    memset(g_ScopeIpAddressAnsiString, 0x00, (MAX_IP_STRING_LEN+1)*sizeof(CHAR));
    Tmp = DhcpUnicodeToOem(g_ScopeIpAddressUnicodeString, NULL);
    if( NULL == Tmp ) {
        return FALSE;
    }
    
    strcpy(g_ScopeIpAddressAnsiString, Tmp );
    
    g_ScopeIpAddress = IpAddress;
    
    return TRUE;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\dhcp\srvrhndl.c ===
//
// Copyright (C) 1999 Microsoft Corporation
//

#include "precomp.h"
#include <dhcpexim.h>

extern ULONG g_ulSrvrNumTopCmds;
extern ULONG g_ulSrvrNumGroups;
extern ULONG g_ulSrvrNumSubContext;

extern CMD_GROUP_ENTRY                  g_SrvrCmdGroups[];
extern CMD_ENTRY                        g_SrvrCmds[];
extern DHCPMON_SUBCONTEXT_TABLE_ENTRY   g_SrvrSubContextTable[];

extern LPWSTR  g_pwszServer;

CHAR   g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1] = {'\0'};
WCHAR  g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1] = {L'\0'};

DWORD  g_dwIPCount = 0;
LPWSTR *g_ppServerIPList = NULL;

LPWSTR  g_UserClass = NULL;
BOOL    g_fUserClass = FALSE;
LPWSTR  g_VendorClass = NULL;
BOOL    g_fIsVendor = FALSE;


COMMAND_OPTION_TYPE TagOptionType[] = 
{
    { TAG_OPTION_BYTE,          DhcpByteOption,             L"BYTE" },
    { TAG_OPTION_WORD,          DhcpWordOption,             L"WORD" },
    { TAG_OPTION_DWORD,         DhcpDWordOption,            L"DWORD" },
    { TAG_OPTION_DWORDDWORD,    DhcpDWordDWordOption,       L"DWORDDWORD" },
    { TAG_OPTION_IPADDRESS,     DhcpIpAddressOption,        L"IPADDRESS" },
    { TAG_OPTION_STRING,        DhcpStringDataOption,       L"STRING" },
    { TAG_OPTION_BINARY,        DhcpBinaryDataOption,       L"BINARY" },
    { TAG_OPTION_ENCAPSULATED,  DhcpEncapsulatedDataOption, L"ENCAPSULATED" }
};

DWORD
HandleSrvrList(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    i, j;

    for(i = 0; i < g_ulSrvrNumTopCmds-2; i++)
    {
        DisplayMessage(g_hModule, g_SrvrCmds[i].dwShortCmdHelpToken);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    for(i = 0; i < g_ulSrvrNumGroups; i++)
    {
        for(j = 0; j < g_SrvrCmdGroups[i].ulCmdGroupSize; j++)
        {
            DisplayMessage(g_hModule, g_SrvrCmdGroups[i].pCmdGroup[j].dwShortCmdHelpToken);

            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
        }
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    for(i=0; i < g_ulSrvrNumSubContext; i++)
    {
        DisplayMessage(g_hModule, g_SrvrSubContextTable[i].dwShortCmdHlpToken);
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}


DWORD
HandleSrvrHelp(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
       DWORD    i, j;

    for(i = 0; i < g_ulSrvrNumTopCmds-2; i++)
    {
        if(g_SrvrCmds[i].dwCmdHlpToken != MSG_DHCP_NULL)
        {
            DisplayMessage(g_hModule, g_SrvrCmds[i].dwShortCmdHelpToken);
        }
    }

    for(i = 0; i < g_ulSrvrNumGroups; i++)
    {
        DisplayMessage(g_hModule, g_SrvrCmdGroups[i].dwShortCmdHelpToken);
    }

    for (i = 0; i < g_ulSrvrNumSubContext; i++)
    {
        DisplayMessage(g_hModule,  g_SrvrSubContextTable[i].dwShortCmdHlpToken);
        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return NO_ERROR;
}

DWORD
HandleSrvrContexts(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return NO_ERROR;
}

DWORD
HandleSrvrDump(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD       Error = NO_ERROR;

    Error = DhcpDumpServer(g_ServerIpAddressUnicodeString,
                           g_dwMajorVersion,
                           g_dwMinorVersion);

    return Error;
                            
}

DWORD
HandleSrvrAddClass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    DHCP_CLASS_INFO     ClassInfo;
    DWORD               dwIndex = dwArgCount - dwCurrentIndex;
    BOOL                fBinary = FALSE;
    LPBYTE              pbData = NULL;
    DWORD               dwLen = 0;

    if( dwArgCount < 3 ) 
    {                      // wrong usage
        DisplayMessage(g_hModule, HLP_SRVR_ADD_CLASS_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    ClassInfo.ClassName = ppwcArguments[dwCurrentIndex];
    ClassInfo.ClassComment = ppwcArguments[dwCurrentIndex+1];
   
    ClassInfo.IsVendor = FALSE;

    if( dwArgCount > 3 )
    {
        WCHAR   wcType = ppwcArguments[dwCurrentIndex+3][0];

        if( wcType is L'0' )
            ClassInfo.IsVendor = FALSE;
        else if( wcType is L'1' )
            ClassInfo.IsVendor = TRUE;
        else if( ppwcArguments[dwCurrentIndex+3][0] is L'B' or
                 ppwcArguments[dwCurrentIndex+3][0] is L'b' )
        {
            fBinary = TRUE;
        }
        else
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        
        if( dwArgCount > 4 )
        {
            if( ppwcArguments[dwCurrentIndex+4][0] is L'B' or
                ppwcArguments[dwCurrentIndex+4][0] is L'b' )
            {
                fBinary = TRUE;
            }
            else
            {
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }

    }
    else
    {
        ClassInfo.IsVendor = FALSE;
        fBinary = FALSE;
    }

    if( fBinary is FALSE )
    {
        LPSTR   pszTemp = NULL;
        DWORD   i = 0;
       

        pszTemp = DhcpUnicodeToOem(ppwcArguments[dwCurrentIndex+2], NULL);

        if( pszTemp is NULL )
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        dwLen = strlen(pszTemp);

        pbData = DhcpAllocateMemory(dwLen);
        
        
        if( pbData is NULL )
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            DhcpFreeMemory(pszTemp);
            pszTemp = NULL;
            goto ErrorReturn;
        }

        for( i=0; i<dwLen; i++ )
        {
            pbData[i] = pszTemp[i];
        }
    
        DhcpFreeMemory(pszTemp);
        pszTemp = NULL;
        
    }
    else
    {
        LPSTR   pszTemp = NULL,
                pszBin = NULL;
        DWORD   i = 0;
        
        pszTemp = DhcpUnicodeToOem(ppwcArguments[dwCurrentIndex+2], NULL);

        if( pszTemp is NULL )
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorReturn;
        }

        pszBin = StringToHexString(pszTemp);

        if( strlen(pszTemp)%2 )
            dwLen = strlen(pszTemp)/2 + 1;
        else
            dwLen = strlen(pszTemp)/2;

        DhcpFreeMemory(pszTemp);
        pszTemp = NULL;

        if( pszBin is NULL )
        {
            pbData = NULL;
        }
        else
        {
            pbData = DhcpAllocateMemory(dwLen);
        
            if( pbData is NULL )
            {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                DhcpFreeMemory(pszBin);
                pszBin = NULL;
                goto ErrorReturn;
            }
            for( i=0; i<dwLen; i++ )
            {
                pbData[i] = pszBin[i];
            }
        }    
        
        DhcpFreeMemory(pszBin);
        pszBin = NULL;
        
    }
    
    ClassInfo.ClassDataLength = dwLen;
    ClassInfo.ClassData = pbData;
   
    ClassInfo.Flags = 0;

    Error = DhcpCreateClass(
        g_ServerIpAddressUnicodeString,
        0,
        &ClassInfo
    );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    
    if( pbData )
    {
        DhcpFreeMemory(pbData);
        pbData = NULL;
    }
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_ADD_CLASS, 
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrAddMscope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD            Error = NO_ERROR;
    DHCP_MSCOPE_INFO MScopeInfo;
    LPWSTR           UnicodeMScopeName = NULL;
    LPWSTR           UnicodeMScopeDesc = NULL;
    DWORD            MScopeId;
    LPWSTR           UnicodeLangTag = NULL;
    PBYTE            LangTag;
    DWORD            dwTTL    = 32;


    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    memset(&MScopeInfo, 0x00, sizeof(DHCP_MSCOPE_INFO));

    //
    // Expected Parameters are : <MScopeName [MScopeDescription] [TTL]>
    //

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_ADD_MSCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    MScopeId = 0xFFFFFFFF;
    
    UnicodeMScopeName = ppwcArguments[dwCurrentIndex];

    if ( dwArgCount > 1 )
    {

        UnicodeMScopeDesc = ppwcArguments[dwCurrentIndex+1];
    }

    if( dwArgCount > 2 )
    {
        if( IsPureNumeric( ppwcArguments[dwCurrentIndex+2] ) is FALSE )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        dwTTL = STRTOUL(ppwcArguments[dwCurrentIndex+2], NULL, 10);
        if( dwTTL <= 0 )
            dwTTL = 0;
        if( dwTTL > 255 )
            dwTTL = 255;
    }

    LangTag = GetLangTagA();
    UnicodeLangTag = DhcpOemToUnicode(LangTag, NULL);

    MScopeInfo.MScopeName = UnicodeMScopeName;
    MScopeInfo.MScopeId = MScopeId;
    MScopeInfo.MScopeComment = UnicodeMScopeDesc;
    MScopeInfo.PrimaryHost.IpAddress =
        StringToIpAddress(g_ServerIpAddressUnicodeString);

    MScopeInfo.PrimaryHost.NetBiosName = NULL;
    MScopeInfo.PrimaryHost.HostName = NULL;
    MScopeInfo.MScopeState = DhcpSubnetEnabled;
    MScopeInfo.MScopeFlags = 0;
    MScopeInfo.MScopeAddressPolicy = 0;
    MScopeInfo.TTL = (BYTE)dwTTL;
    MScopeInfo.LangTag = UnicodeLangTag;
    MScopeInfo.ExpiryTime = DhcpCalculateTime(INFINIT_LEASE);

    Error = DhcpSetMScopeInfo(
                g_ServerIpAddressUnicodeString,
                UnicodeMScopeName,
                &MScopeInfo,
                TRUE); // new scope

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   MSG_SRVR_MSCOPE_ADD);
                   

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_ADD_MSCOPE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleSrvrAddOptiondef(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                     Error = NO_ERROR;
    DHCP_OPTION               OptionInfo;
    DHCP_OPTION_ID            OptionID;
    DHCP_OPTION_DATA_TYPE     OptionType;
    LPWSTR                    UnicodeOptionName = NULL;
    LPWSTR                    UnicodeOptionValueString = NULL;
    LPWSTR                    OptionTypeString = NULL;
    DHCP_OPTION_DATA_ELEMENT  OptionData;
    DWORD                     dwIndex = 0;

    LPWSTR                    pwcTag = NULL;
    LPWSTR                    pwcUser = NULL;
    LPWSTR                    pwcVendor = NULL;
    LPWSTR                    pwcComment = NULL;
    LPWSTR                    pwcTemp = NULL;
    
    BOOL                      fUser = FALSE;
    BOOL                      fVendor = FALSE;
    BOOL                      fComment = FALSE;
    BOOL                      fDefValue = FALSE;
    BOOL                      fIsArray = FALSE;
    BOOL                      fValidType = FALSE;

    DWORD                     i = 0;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    memset(&OptionInfo, 0x00, sizeof(DHCP_OPTION));
    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&OptionData, 0x00, sizeof(DHCP_OPTION_DATA_ELEMENT));

    //
    // Expected Parameters are :
    //  <OptionID OptionName DefValueType DefValue>
    //

    if( dwArgCount < 3 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_ADD_OPTIONDEF_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
   
    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );
    
    dwIndex++;

    OptionInfo.OptionID = OptionID;

    OptionInfo.OptionName = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;
    
    OptionTypeString = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;

    OptionInfo.OptionType = DhcpUnaryElementTypeOption;

    if( dwArgCount > dwIndex  )
    {
        if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex+dwIndex]) )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        if( 0 is wcstol(ppwcArguments[dwCurrentIndex+dwIndex], NULL, 10) )
        {
            OptionInfo.OptionType = DhcpUnaryElementTypeOption;
        }
        else
        {
            OptionInfo.OptionType = DhcpArrayTypeOption;
            fIsArray = TRUE;
        }
        dwIndex++;
    }
    

    //
    //Check to see if VendorClass is specified or not
    //
    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else if ( MatchToken(pwcTag, TOKEN_OPTION_COMMENT) )
        {
            if( fComment is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcComment = NULL;
                else
                {
                    pwcComment = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcComment is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcComment, pwcStr);
                }
                fComment = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }
    
    if( fComment is TRUE )
    {
        OptionInfo.OptionComment = pwcComment;
    }
    else
    {
        OptionInfo.OptionComment = NULL;
    }

    //Check if OptionType supplied is valid

    //Find out the OptionType
    for(i=0; i < sizeof(TagOptionType)/sizeof(COMMAND_OPTION_TYPE); i++)
    {
        if( MatchToken(OptionTypeString, TagOptionType[i].pwszTagID) )
        {
            OptionType = TagOptionType[i].DataType;
            fValidType = TRUE;
            break;
        }
    }
    
    if( fValidType is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( fIsArray && OptionType >= DhcpStringDataOption ) {
        //
        // Do not allow arrays with strings etc
        //

        DisplayMessage( g_hModule, EMSG_SRVR_STRING_ARRAY_OPTIONS );
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    if( dwArgCount > dwIndex ) 
    {
        if( fIsArray )
        {
            Error = SetOptionDataTypeArray(
                OptionType,
                ppwcArguments + dwCurrentIndex,
                dwIndex, dwArgCount,
                &OptionInfo.DefaultValue
                );
        }
        else
        {

            Error = SetOptionDataType(
                OptionType,
                ppwcArguments[dwCurrentIndex+dwIndex],
                &OptionData,
                &UnicodeOptionValueString
            );

            OptionInfo.DefaultValue.NumElements = 1;
            OptionInfo.DefaultValue.Elements = &OptionData;

        }

        dwIndex++;
        fDefValue = TRUE;
    }
    else
    {
       Error = SetOptionDataType(
            OptionType,
            NULL,
            &OptionData,
            &UnicodeOptionValueString
        ); 

        OptionInfo.DefaultValue.NumElements = 1;
        OptionInfo.DefaultValue.Elements = &OptionData;

    }

    if( Error isnot NO_ERROR )
    {

        goto ErrorReturn;
    }

    if( OptionData.OptionType is DhcpStringDataOption )
    {
        OptionInfo.OptionType = DhcpUnaryElementTypeOption;
    }

    if( g_dwMajorVersion < CLASS_ID_VERSION )
    {
        Error = DhcpCreateOption(
                                g_ServerIpAddressUnicodeString,
                                OptionID,
                                &OptionInfo);
        if( Error isnot NO_ERROR )
            goto ErrorReturn;

    }
    else
    {
        Error = DhcpCreateOptionV5(
                                g_ServerIpAddressUnicodeString,
                                fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR  : 0,
                                OptionID,
                                pwcUser,
                                pwcVendor,
                                &OptionInfo);

        if( Error isnot NO_ERROR )
            goto ErrorReturn;
    }
CommonReturn:
    
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    if( pwcTemp )
    {
        DhcpFreeMemory(pwcTemp);
        pwcTemp = NULL;
    }

    return( Error );
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_ADD_OPTIONDEF,
                        Error);
                   
    goto CommonReturn;
}

DWORD
HandleSrvrAddScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD            Error = NO_ERROR;
    DHCP_SUBNET_INFO SubnetInfo;
    LPWSTR           UnicodeSubnetName = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    memset(&SubnetInfo, 0x00, sizeof(DHCP_SUBNET_INFO));
    
    if( dwArgCount < 3 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_ADD_SCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    SubnetInfo.SubnetAddress =
        StringToIpAddress(ppwcArguments[dwCurrentIndex]);
    SubnetInfo.SubnetMask =
        StringToIpAddress(ppwcArguments[dwCurrentIndex+1]);

    if( SubnetInfo.SubnetAddress is INADDR_NONE or
        SubnetInfo.SubnetMask is INADDR_NONE )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    UnicodeSubnetName = ppwcArguments[dwCurrentIndex+2];

    SubnetInfo.SubnetName = UnicodeSubnetName;
    if( dwArgCount > 3 ) 
    {
#ifdef UNICODE
        SubnetInfo.SubnetComment = ppwcArguments[dwCurrentIndex+3];
#else
        SubnetInfo.SubnetComment = DhcpOemToUnicode( ppwcArguments[dwCurrentIndex+3], NULL);
#endif //UNICODE
    }
    else
    {
        SubnetInfo.SubnetComment = NULL;
    }
    SubnetInfo.PrimaryHost.IpAddress =
        StringToIpAddress(g_ServerIpAddressUnicodeString);

    SubnetInfo.PrimaryHost.NetBiosName = NULL;
    SubnetInfo.PrimaryHost.HostName = NULL;
    SubnetInfo.SubnetState = DhcpSubnetEnabled;

    Error = DhcpCreateSubnet(
                g_ServerIpAddressUnicodeString,
                SubnetInfo.SubnetAddress,
                &SubnetInfo );

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:

#ifndef UNICODE
    if( UnicodeSubnetName != NULL ) 
    {
        DhcpFreeMemory( UnicodeSubnetName );
        UnicodeSubnetName = NULL;
    }

    if( SubnetInfo.SubnetComment isnot NULL )
    {
        DhcpFreeMemory( SubnetInfo.SubnetComment );
        SubnetInfo.SubnetComment = NULL;
    }

#endif //UNICODE

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_ADD_SCOPE,
                        Error);

    goto CommonReturn;
}

DWORD
HandleSrvrDeleteClass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD          Error = ERROR_SUCCESS;
    LPWSTR         ClassName = NULL;

    if( dwArgCount < 1 )
    {        
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_CLASS_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;

    }
    
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }
 

    ClassName = ppwcArguments[dwCurrentIndex];

    Error = DhcpDeleteClass(
        g_ServerIpAddressUnicodeString,
        0,
        ClassName
    );
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_DELETE_CLASS,
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrDeleteMscope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD            Error = NO_ERROR;
    DHCP_MSCOPE_INFO MScopeInfo;
    LPWSTR           UnicodeMScopeName = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    //
    // Expected Parameters are : <MScopeName>
    //

    memset(&MScopeInfo, 0x00, sizeof(DHCP_MSCOPE_INFO));

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_MSCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    

    UnicodeMScopeName = ppwcArguments[dwCurrentIndex];

    Error = DhcpDeleteMScope(
                g_ServerIpAddressUnicodeString,
                UnicodeMScopeName,
                TRUE); 

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_DELETE_MSCOPE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrDeleteOptiondef(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD          Error = ERROR_SUCCESS;
    DHCP_OPTION_ID OptionID;

    LPWSTR         pwcTag = NULL;
    LPWSTR         pwcUser = NULL;   
    LPWSTR         pwcVendor = NULL;
    LPWSTR         pwcTemp = NULL;

    BOOL           fUser = FALSE;
    BOOL           fVendor = FALSE;

    DWORD          dwIndex = 0;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    //
    // Expected Parameters are :
    //  <OptionID>
    //
    
    if( dwArgCount < 1 ) 
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_OPTIONDEF_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;

    }

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );


    //
    //Check to see if VendorClass or UserClass is specified or not
    //
    dwIndex = 1;
    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }
    

    if( g_dwMajorVersion < CLASS_ID_VERSION )
    {
        Error = DhcpRemoveOption(
                                g_ServerIpAddressUnicodeString,
                                OptionID);
        if( Error isnot NO_ERROR )
            goto ErrorReturn;
    }

    else
    {
        Error = DhcpRemoveOptionV5( 
                                g_ServerIpAddressUnicodeString,
                                fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                OptionID,
                                pwcUser,
                                pwcVendor
                                );
        if( Error isnot NO_ERROR )
            goto ErrorReturn;
    }

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    if( pwcUser && pwcUser != g_UserClass  )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    return Error;

ErrorReturn:

    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_DELETE_OPTIONDEF,
                        Error);

    goto CommonReturn;
}

DWORD
HandleSrvrDeleteOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                   Error = ERROR_SUCCESS;
    DHCP_OPTION_ID          OptionID;
    DHCP_OPTION_SCOPE_INFO  ScopeInfo;

    LPWSTR         pwcTag = NULL;
    LPWSTR         pwcUser = NULL;   
    LPWSTR         pwcVendor = NULL;
    LPWSTR         pwcTemp = NULL;

    BOOL           fUser = FALSE;
    BOOL           fVendor = FALSE;

    DWORD          dwIndex = 0;


    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    //
    // Expected Parameters are :
    //  <OptionID>
    //
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( FALSE is IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = STRTOUL( ppwcArguments[dwCurrentIndex], NULL, 10 );

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    //
    //Check to see if VendorClass or UserClass is specified or not
    //
    
    dwIndex = 1;
    while( TRUE )
    {
        LPWSTR      pwcStr = NULL;
        if( dwArgCount <= dwIndex )
            break;

        if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER)  )
            break;

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }
    

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {

        Error = DhcpRemoveOptionValueV5(
                                   g_ServerIpAddressUnicodeString,
                                   fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                   OptionID,
                                   pwcUser,
                                   pwcVendor,
                                   &ScopeInfo
                                   );
    }
    else
    {
        Error = DhcpRemoveOptionValue(
                                   g_ServerIpAddressUnicodeString,
                                   OptionID,
                                   &ScopeInfo);
    }


    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    if( pwcVendor && pwcVendor != g_VendorClass )
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }
    
    if( pwcUser  && pwcUser != g_UserClass )
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_DELETE_OPTIONVALUE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrDeleteScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                      Error = ERROR_SUCCESS;
    DHCP_IP_ADDRESS            SubnetAddress;
    DHCP_FORCE_FLAG            ForceFlag;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    memset(&SubnetAddress, 0x00, sizeof(DHCP_IP_ADDRESS));
    memset(&ForceFlag, 0x00, sizeof(DHCP_FORCE_FLAG));

    if( dwArgCount < 2 ) 
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_SCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    SubnetAddress = StringToIpAddress( ppwcArguments[dwCurrentIndex] );

    if( SubnetAddress is INADDR_NONE )
    {
        DisplayMessage(g_hModule,
                       EMSG_SCOPE_INVALID_IPADDRESS);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+1], TEXT("DhcpFullForce") ) ) 
    {
        ForceFlag = DhcpFullForce;
    } 
    else if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+1], TEXT("DhcpNoForce") ) ) 
    {
        ForceFlag = DhcpNoForce;
    } 
    else 
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_UNKNOWN_FORCEFLAG,
                       ppwcArguments[dwCurrentIndex+1]);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Error = DhcpDeleteSubnet(
        g_ServerIpAddressUnicodeString,
        SubnetAddress,
        ForceFlag
    );
    
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

CommonReturn:

    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_DELETE_SCOPE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrDeleteSuperscope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    
    WCHAR  *pwszSuperScope = NULL;
    DWORD  Error = NO_ERROR;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }
    
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_DELETE_SUPERSCOPE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    pwszSuperScope = ppwcArguments[dwCurrentIndex];
    
    Error = DhcpDeleteSuperScopeV4( g_ServerIpAddressUnicodeString,
                                    pwszSuperScope );
        
    if( Error isnot NO_ERROR )
        goto ErrorReturn;
    
CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_DELETE_SUPERSCOPE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrRedoAuth(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD           Error = NO_ERROR;
    PDHCP_ATTRIB    pStatusAttrib = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    Error = DhcpServerRedoAuthorization(
                  g_ServerIpAddressUnicodeString,
                  0
                  );
        if( Error is NO_ERROR )
            goto CommonReturn;
        else
            goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_REDO_AUTH,
                        Error);

    goto CommonReturn;

}

DWORD
HandleSrvrExport(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD           Error = NO_ERROR;
    PDHCP_ATTRIB    pStatusAttrib = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_EXPORT_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( !IsLocalServer(g_pwszServer) )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_EXIM_LOCAL);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    Error = CmdLineDoExport(
        &ppwcArguments[dwCurrentIndex], dwArgCount );

    if( ERROR_BAD_ARGUMENTS == Error )
    {
        DisplayMessage(g_hModule, HLP_SRVR_EXPORT_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( Error is NO_ERROR )
        goto CommonReturn;
    else
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_EXPORT,
                        Error);

    goto CommonReturn;

}

DWORD
HandleSrvrImport(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD           Error = NO_ERROR;
    PDHCP_ATTRIB    pStatusAttrib = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_IMPORT_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( !IsLocalServer(g_pwszServer) )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_EXIM_LOCAL);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Error = CmdLineDoImport(
        &ppwcArguments[dwCurrentIndex], dwArgCount );

    if( ERROR_BAD_ARGUMENTS == Error )
    {
        DisplayMessage(g_hModule, HLP_SRVR_IMPORT_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( Error is NO_ERROR )
        goto CommonReturn;
    else
        goto ErrorReturn;

CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_IMPORT,
                        Error);

    goto CommonReturn;

}

DWORD
HandleSrvrInitiateReconcile(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_IP_ARRAY     SubnetIps = NULL;
    DHCP_RESUME_HANDLE  Resume = 0;
    DWORD               dwRead = 0,
                        dwTotal = 0,
                        dwCount = 0;
    BOOL                fFix = FALSE;

    if( dwArgCount > 0 ) 
    {
        //
        // parse fix parameter.
        //

        if( STRICMP(ppwcArguments[dwCurrentIndex], TEXT("fix") ) ) 
        {
            fFix = TRUE;
        }
    }


    while(TRUE)
    {
        DWORD   dw = 0;

        Error = DhcpEnumSubnets(g_ServerIpAddressUnicodeString,
                                &Resume,
                                ~0,
                                &SubnetIps,
                                &dwRead,
                                &dwTotal);

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            Error = NO_ERROR;
            break;
        }

        if( Error isnot NO_ERROR and
            Error isnot ERROR_MORE_DATA )
        {
            goto ErrorReturn;
        }

        for( dw=0; dw<dwRead && dw<SubnetIps->NumElements; dw++ )
        {
            DWORD dwError = NO_ERROR;
            LPDHCP_SCAN_LIST ScanList = NULL;

            dwError = DhcpScanDatabase(
                                        g_ServerIpAddressUnicodeString,
                                        SubnetIps->Elements[dw],
                                        fFix,
                                        &ScanList
                                      );

            if( dwError isnot NO_ERROR ) 
            {
                DisplayErrorMessage(g_hModule,
                                    EMSG_SRVR_RECONCILE_SCOPE,
                                    dwError,
                                    IpAddressToString(SubnetIps->Elements[dw]));
                continue;
            }
            else
            {
                DWORD dwMsgId;
                
                if( fFix ) {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_RECONCILE_SCOPE,
                                   IpAddressToString(SubnetIps->Elements[dw]));
                }
            }
            
            //
            // display bad entries.
            //

            if( (ScanList isnot NULL) and
                (ScanList->NumScanItems isnot 0) and
                (ScanList->ScanItems isnot NULL) ) 
            {

                LPDHCP_SCAN_ITEM ScanItem;
                LPDHCP_SCAN_ITEM ScanItemEnd;
                DWORD i = 1;

                if( !fFix ) {
                    DisplayMessage(
                        g_hModule,
                        MSG_SRVR_RECONCILE_SCOPE_NEEDFIX,
                        IpAddressToString(SubnetIps->Elements[dw])
                        );
                }
                
                ScanItemEnd =
                    ScanList->ScanItems +
                    ScanList->NumScanItems;

                for( ScanItem = ScanList->ScanItems;
                        ScanItem < ScanItemEnd; ScanItem++ ) 
                {

                    DisplayMessage(g_hModule, MSG_SCOPE_IPADDRESS,
                        i++,
                        IpAddressToString(ScanItem->IpAddress) );

                    if( ScanItem->ScanFlag == DhcpRegistryFix ) 
                    {
                        DisplayMessage(g_hModule, MSG_SCOPE_FIX_REGISTRY);
                    }
                    else if( ScanItem->ScanFlag == DhcpDatabaseFix ) 
                    {
                        DisplayMessage(g_hModule, MSG_SCOPE_FIX_DATABASE);
                    }
                    else 
                    {
                        DisplayMessage(g_hModule, MSG_SCOPE_FIX_UNKNOWN);
                    }
                }
            }
            else
            {
                if( !fFix ) {
                    DisplayMessage(
                        g_hModule,
                        MSG_SRVR_RECONCILE_SCOPE_NOFIX,
                        IpAddressToString(SubnetIps->Elements[dw])
                        );
                }
            }                

            
            if( ScanList )
            {
                DhcpRpcFreeMemory(ScanList);
                ScanList = NULL;
            }

        }


        if( Error is ERROR_MORE_DATA )
        {
            continue;
        }
        else
        {
            break;
        }
    }

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);
CommonReturn:
    if( SubnetIps )
    {
        DhcpRpcFreeMemory(SubnetIps);
        SubnetIps = NULL;
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_INITIATE_RECONCILE,
                        Error);
    goto CommonReturn;

}


DWORD
HandleSrvrSetBackupinterval(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_BACKUPINTERVAL_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPINTERVAL,
                            Error);
        return Error;
    }

     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPINTERVAL,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));


    ConfigInfo->BackupInterval = ATOI(ppwcArguments[dwCurrentIndex]);

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_BackupInterval,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPINTERVAL,
                            Error);
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }

    return Error;
}

DWORD
HandleSrvrSetBackuppath(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_BACKUPPATH_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPPATH,
                            Error);
        return Error;
    }

     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPPATH,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));


    ConfigInfo->BackupPath = ppwcArguments[dwCurrentIndex];

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_BackupPath,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_BACKUPPATH,
                            Error);
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    return Error;
}

DWORD
HandleSrvrSetDatabasecleanupinterval(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_DATABASECLEANUPINTERVAL_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASECLEANUPINTERVAL,
                            Error);
        return Error;

    }

     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASECLEANUPINTERVAL,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));


    ConfigInfo->DatabaseCleanupInterval = ATOI(ppwcArguments[dwCurrentIndex]);

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_DatabaseCleanupInterval,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASECLEANUPINTERVAL,
                            Error);
                       
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    return Error;
}

DWORD
HandleSrvrSetDatabaseloggingflag(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;
    DWORD                        dwFlag = 0;


    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_DATABASELOGGINGFLAG_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASELOGGINGFLAG,
                            Error);
        return Error;
    }

     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASELOGGINGFLAG,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));

    dwFlag = ATOI(ppwcArguments[dwCurrentIndex]);

    if( dwFlag isnot 0 and
        dwFlag isnot 1 )
    {
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASELOGGINGFLAG,
                            Error);
        return Error;
    }


    ConfigInfo->DatabaseLoggingFlag = dwFlag;

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_DatabaseLoggingFlag,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASELOGGINGFLAG,
                            Error);
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    
    return Error;
   
}

DWORD
HandleSrvrSetDatabasename(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_DATABASENAME_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASENAME,
                            Error);
        return Error;
    }

     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASENAME,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));


    ConfigInfo->DatabaseName = ppwcArguments[dwCurrentIndex];

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_DatabaseName,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASENAME,
                            Error);
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    return Error;

}

DWORD
HandleSrvrSetDatabasepath(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;
    LPDHCP_SERVER_CONFIG_INFO    ConfigInfo5 = NULL;
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }


    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_DATABASEPATH_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASEPATH,
                            Error);
        return Error;
    }

    if( g_dwMajorVersion < CLASS_ID_VERSION )
    {
        ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

        if( ConfigInfo == NULL ) 
        {
            DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
            Error = ERROR_NOT_ENOUGH_MEMORY;
            DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASEPATH,
                            Error);
            return Error;
        }

        memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));


        ConfigInfo->DatabasePath = ppwcArguments[dwCurrentIndex];


        Error = DhcpServerSetConfigV4(
                    g_ServerIpAddressUnicodeString,
                    Set_DatabasePath,
                    ConfigInfo );

        if( Error is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_NEED_RESTART);

            DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
        }
        else
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_DATABASEPATH,
                                Error);
        }

        if(ConfigInfo)
        {
            DhcpFreeMemory(ConfigInfo);
            ConfigInfo = NULL;
        }
        
        return Error;
    }
    else
    {
        ConfigInfo5 = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO) );

        if( ConfigInfo5 == NULL ) 
        {
            DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
            Error = ERROR_NOT_ENOUGH_MEMORY;
            DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASEPATH,
                            Error);
            return Error;
        }

        memset(ConfigInfo5, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO));


        ConfigInfo5->DatabasePath = ppwcArguments[dwCurrentIndex];


        Error = DhcpServerSetConfig(
                    g_ServerIpAddressUnicodeString,
                    Set_DatabasePath,
                    ConfigInfo5 );

        if( Error is NO_ERROR )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_NEED_RESTART);

            DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
        }
        else
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_DATABASEPATH,
                                Error);
        }

        if(ConfigInfo)
        {
            DhcpFreeMemory(ConfigInfo);
            ConfigInfo = NULL;
        }
        
        return Error;
    }

}

DWORD
HandleSrvrSetDatabaserestoreflag(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;
    DWORD                        dwFlag = 0;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_DATABASERESTOREFLAG_EX);
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASERESTOREFLAG,
                            Error);
        return Error;
    }
     
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        DisplayMessage(g_hModule, MSG_DHCP_NOT_ENOUGH_MEMORY);
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASERESTOREFLAG,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));

        

    dwFlag = ATOI(ppwcArguments[dwCurrentIndex]);

    if( dwFlag isnot 0 and
        dwFlag isnot 1 )
    {
        Error = ERROR_INVALID_PARAMETER;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASERESTOREFLAG,
                            Error);
        return Error;
    }

    ConfigInfo->RestoreFlag = dwFlag;

    Error = DhcpServerSetConfigV4(
                g_ServerIpAddressUnicodeString,
                Set_RestoreFlag,
                ConfigInfo );

    if( Error is NO_ERROR )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    else
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASERESTOREFLAG,
                            Error);
    }

    if(ConfigInfo)
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }

    return Error;

}

DWORD
HandleSrvrSetOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{

    DWORD                     Error = NO_ERROR;
    DHCP_OPTION_ID            OptionID;
    DHCP_OPTION_SCOPE_INFO    ScopeInfo;
    DHCP_OPTION_DATA          OptionValue;
    DHCP_OPTION_DATA_ELEMENT  OptionData;
    DHCP_OPTION_DATA_TYPE     OptionType;
    LPWSTR                    UnicodeOptionValueString = NULL;
    LPWSTR                    OptionTypeString = NULL;
    LPDHCP_OPTION             OptionInfo = NULL;
    DWORD                     dwIndex = 0;
    
    LPWSTR                    pwcTag = NULL;
    LPWSTR                    pwcUser = NULL;
    LPWSTR                    pwcVendor = NULL;
    LPWSTR                    pwcTemp = NULL;
    DWORD                     dwClass = 0;
    DWORD                     i = 0;
    BOOL                      fUser = FALSE;
    BOOL                      fVendor = FALSE;
    BOOL                      fValidType = FALSE;

    memset(&OptionID, 0x00, sizeof(DHCP_OPTION_ID));
    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    memset(&OptionValue, 0x00, sizeof(DHCP_OPTION_DATA));
    memset(&OptionData, 0x00, sizeof(DHCP_OPTION_DATA_ELEMENT));
    

 
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount < 3 ) 
    {
        DisplayMessage(g_hModule, HLP_SRVR_SET_OPTIONVALUE_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    OptionID = wcstoul(ppwcArguments[dwCurrentIndex], NULL, 10 );

    dwIndex++;

    OptionTypeString = ppwcArguments[dwCurrentIndex+dwIndex];

    dwIndex++;
    //
    //Check to see if VendorClass or UserClass is specified or not
    //


    while( NULL isnot wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
    {
        LPWSTR  pwcStr = NULL;
        if( dwArgCount <= dwIndex + 1 )
        {
            DisplayMessage(g_hModule, HLP_SRVR_SET_OPTIONVALUE_EX);
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }

        pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
        if( pwcTemp is NULL )
        {
            Error = ERROR_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

        pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
        if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
        {
            if( fUser is TRUE ) //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcUser = NULL;
                else
                {
                    pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcUser is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcUser, pwcStr);
                }
                fUser = TRUE;
            }
        }
        else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
        {
            if( fVendor is TRUE )   //If already set
            {
                DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
            else
            {
                pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                if( pwcStr is NULL )
                    pwcVendor = NULL;
                else
                {
                    pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                    if( pwcVendor is NULL )
                    {
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    wcscpy(pwcVendor, pwcStr);
                }
                fVendor = TRUE;
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
            return ERROR_INVALID_PARAMETER;
        }

        if( pwcTemp )
        {
            DhcpFreeMemory(pwcTemp);
            pwcTemp = NULL;
        }
        
        dwIndex++;
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionInfoV5(g_ServerIpAddressUnicodeString,
                                    fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                    OptionID,
                                    NULL,
                                    pwcVendor,
                                    &OptionInfo);
    
        if( Error isnot NO_ERROR or OptionInfo is NULL )
            goto ErrorReturn;
    }
    else
    {
        Error = DhcpGetOptionInfo(g_ServerIpAddressUnicodeString,
                                  OptionID,
                                  &OptionInfo);

        if( Error isnot NO_ERROR or OptionInfo is NULL )
            goto ErrorReturn;
    }

    //Check if OptionType supplied is the same as defined.

    //Find out the OptionType
    for(i=0; i < sizeof(TagOptionType)/sizeof(COMMAND_OPTION_TYPE); i++)
    {
        if( MatchToken(OptionTypeString, TagOptionType[i].pwszTagID) )
        {
            OptionType = TagOptionType[i].DataType;
            fValidType = TRUE;
            break;
        }
    }
    
    if( fValidType is FALSE )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( OptionInfo->DefaultValue.NumElements and
        OptionType isnot OptionInfo->DefaultValue.Elements[0].OptionType )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_INVALID_OPTIONTYPE);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }


    switch(OptionInfo->OptionType)
    {

    case DhcpArrayTypeOption:
        {
            Error = SetOptionDataTypeArray(
                    OptionType,
                    ppwcArguments+dwCurrentIndex,
                    dwIndex,
                    dwArgCount,
                    &OptionValue);
            
            if( Error isnot NO_ERROR )
            {
                goto ErrorReturn;
            }
            break;
                
        }
    case DhcpUnaryElementTypeOption:
    default:
        {
            Error = SetOptionDataType(
                        OptionType,
                        ppwcArguments[dwCurrentIndex+dwIndex],
                        &OptionData,
                        &UnicodeOptionValueString);

	    // Option 28 (Broadcast IP) can have 255.255.255.255
	    // Others should not.
	    
	    if ( 28 != OptionID ) {
		if ( INADDR_NONE == OptionData.Element.IpAddressOption ) {
		    Error = ERROR_INVALID_PARAMETER;
		}
	    } // if 

            if( Error isnot NO_ERROR ) 
            {
                goto ErrorReturn;
            }
            OptionValue.NumElements = 1;
            OptionValue.Elements = &OptionData;
            break;
        }
    }

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    ScopeInfo.ScopeInfo.GlobalScopeInfo = NULL;

    Error = SetOptionValue(
        g_ServerIpAddressUnicodeString,
        fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
        (DHCP_OPTION_ID)OptionID,
        pwcUser,
        pwcVendor,
        &ScopeInfo,
        &OptionValue
    );
    if( Error isnot ERROR_SUCCESS )
        goto ErrorReturn;

CommonReturn:


    if( OptionValue.Elements and
        OptionInfo->OptionType is DhcpArrayTypeOption )
    {
       DhcpFreeMemory(OptionValue.Elements);
       OptionValue.Elements = NULL;
    }

    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SET_OPTIONVALUE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrSetServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD   Error = NO_ERROR;
    if( dwArgCount < 1 )
    {
        if( FALSE is SetServerInfo(NULL) )
        {
            Error = GetLastError();
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_SERVER,
                                Error);
            return Error;
        }
        else
        {
            g_fServer = TRUE;
            DisplayMessage(g_hModule,
                           EMSG_DHCP_ERROR_SUCCESS);
            return NO_ERROR;
        }
    }
    else
    {
        if( FALSE is SetServerInfo(ppwcArguments[dwCurrentIndex]) )
        {
            Error = GetLastError();
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_SERVER,
                                Error);
            return Error;
        }
        else
        {
            g_fServer = TRUE;
            DisplayMessage(g_hModule,
                           EMSG_DHCP_ERROR_SUCCESS);
            return NO_ERROR;
        }

    }
  
}

DWORD
HandleSrvrSetUserclass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( g_UserClass )
    {
        memset(g_UserClass, 0x00, (wcslen(g_UserClass)+1)*sizeof(WCHAR));
        DhcpFreeMemory(g_UserClass);
        g_UserClass = NULL;
    }

    g_fUserClass = FALSE;

    if( dwArgCount > 0 )
    {
        g_UserClass = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex])+1)*sizeof(WCHAR));
        if( g_UserClass is NULL )
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_USERCLASS,
                                ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        wcscpy(g_UserClass, ppwcArguments[dwCurrentIndex]);
        g_fUserClass = TRUE;
    }

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);

    return NO_ERROR;
}

DWORD
HandleSrvrSetVendorclass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( g_VendorClass )
    {
        memset(g_VendorClass, 0x00, (wcslen(g_VendorClass)+1)*sizeof(WCHAR));
        DhcpFreeMemory(g_VendorClass);
        g_VendorClass = NULL;
    }

    g_fIsVendor = FALSE;

    if( dwArgCount > 0 )
    {
        g_VendorClass = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex])+1)*sizeof(WCHAR));
        if( g_VendorClass is NULL )
        {
            DisplayErrorMessage(g_hModule,
                                EMSG_SRVR_SET_VENDORCLASS,
                                ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy(g_VendorClass, ppwcArguments[dwCurrentIndex]);
        g_fIsVendor = TRUE;
    }

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);

    return NO_ERROR;
}

DWORD
GetPassword(
    IN OUT LPWSTR buf,
    IN ULONG buflen
    )
{
    WCHAR ch, *bufPtr = buf;
    DWORD len, c;
    int err, mode;

    buflen -= 1;    /* make space for null terminator */
    len = 0;               /* GP fault probe (a la API's) */

    if(!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode)) {
        return GetLastError();
    }

    DisplayMessage(g_hModule, HLP_SRVR_PROMPT_PASSWORD);
    
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == L'\r' ) || (ch == 0xffff))       /* end of the line */
            break;

        if ( ch == 0x8 ) {  /* back up one or two */
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != buf) {
                bufPtr--;
                (len)--;
            }
        }
        else {

            *bufPtr = ch;

            if (len < buflen)
                bufPtr++ ;                   /* don't overflow buf */
            (len)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */
    putchar(L'\n');

    return((len <= buflen) ? 0 : ERROR_BUFFER_OVERFLOW);    

}

VOID
Scramble(
    IN OUT LPWSTR Pwd
    )
{
    UNICODE_STRING Str;
    UCHAR Seed = DHCP_ENCODE_SEED;
    
    Str.Length = (USHORT)(wcslen(Pwd)*sizeof(WCHAR));
    Str.MaximumLength = Str.Length;
    Str.Buffer = (PVOID)Pwd;

    RtlRunEncodeUnicodeString(&Seed, &Str);
}

DWORD
HandleSrvrSetDnsCredentials(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD Error = NO_ERROR;
    WCHAR Password[500];
    DWORD Size = sizeof(Password)/sizeof(Password[0]);

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount != 3 ) {
        DisplayMessage( g_hModule, HLP_SRVR_SET_DNSCREDENTIALS_EX );
        Error = ERROR_INVALID_PARAMETER;
    } else {
        if( 0 == STRICMP(ppwcArguments[dwCurrentIndex+2], TEXT("*"))) {
            Error = GetPassword(Password, Size);
        } else {
            if( wcslen(ppwcArguments[dwCurrentIndex+2]) >= Size ) {
                Error = ERROR_BUFFER_OVERFLOW;
            } else {
                wcscpy(Password, ppwcArguments[dwCurrentIndex+2]);
            }
        }

        if( NO_ERROR == Error ) {
            Scramble(Password);

            Error = DhcpServerSetDnsRegCredentials(
                g_ServerIpAddressUnicodeString,
                ppwcArguments[dwCurrentIndex],
                ppwcArguments[dwCurrentIndex+1],
                Password );
        }
    }
    
    if( RPC_S_PROCNUM_OUT_OF_RANGE == Error ) {
        DisplayMessage(
            g_hModule, EMSG_SRVR_NEED_DNS_CREDENTIALS_SUPPORT );
        return ERROR_CAN_NOT_COMPLETE;
    }    
    
    if( NO_ERROR == Error ) {
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    } else {
        DisplayErrorMessage(
            g_hModule, EMSG_SRVR_SET_DNSCREDENTIALS, Error );
    }

    return Error;
}

DWORD
HandleSrvrDeleteDnsCredentials(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD Error = NO_ERROR;
    
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount != 1 || 0 !=
        STRICMP(ppwcArguments[dwCurrentIndex], TEXT("DhcpFullForce")) ) {
        DisplayMessage( g_hModule,
                        HLP_SRVR_DELETE_DNSCREDENTIALS_EX );
        Error = ERROR_INVALID_PARAMETER;
    } else {
        Error = DhcpServerSetDnsRegCredentials(
            g_ServerIpAddressUnicodeString, L"", L"", L"" );
    }

    if( RPC_S_PROCNUM_OUT_OF_RANGE == Error ) {
        DisplayMessage(
            g_hModule, EMSG_SRVR_NEED_DNS_CREDENTIALS_SUPPORT );
        return ERROR_CAN_NOT_COMPLETE;
    }    
    
    if( NO_ERROR == Error ) {
        DisplayMessage(g_hModule, EMSG_DHCP_ERROR_SUCCESS);
    } else {
        DisplayErrorMessage(
            g_hModule, EMSG_SRVR_SET_DNSCREDENTIALS, Error );
    }

    return Error;
}

DWORD
HandleSrvrSetAuditlog(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD   Error = NO_ERROR;
    DWORD   DiskCheckInterval = 0, 
            MaxLogFileSize = 0,
            MinSpaceOnDisk = 0;
    LPWSTR  pwszLogDir = NULL;
    LPWSTR  pwszNewDir = NULL;

    HANDLE  hFile = NULL;

    if( dwArgCount < 1 ) 
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SET_AUDITLOG_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    pwszNewDir = ppwcArguments[dwCurrentIndex];
    
    if( IsLocalServer(g_pwszServer) )
    {
        if( INVALID_HANDLE_VALUE is ( hFile = CreateFile(pwszNewDir,
                                                         GENERIC_READ,
                                                         0,
                                                         NULL,
                                                         OPEN_EXISTING,
                                                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                                                         NULL) ) )
        {
            Error = GetLastError();
            if( ERROR_SHARING_VIOLATION == Error )
            {
                //
                // This indicates that the file does exist..
                //

                hFile = NULL;
                Error = NO_ERROR ;
            }
            else
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_INVALID_DIRECTORY,
                               pwszNewDir);
                Error = ERROR_INVALID_PARAMETER;
                goto ErrorReturn;
            }
        }
        else
        {
            CloseHandle(hFile);
            hFile = NULL;
        }
    }

    Error = DhcpAuditLogGetParams( g_ServerIpAddressUnicodeString,
                                   0,
                                   &pwszLogDir,
                                   &DiskCheckInterval,
                                   &MaxLogFileSize,
                                   &MinSpaceOnDisk);


    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    Error = DhcpAuditLogSetParams( g_ServerIpAddressUnicodeString,
                                   0,
                                   pwszNewDir,
                                   DiskCheckInterval,
                                   MaxLogFileSize,
                                   MinSpaceOnDisk);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    if( pwszLogDir is NULL )
        pwszLogDir = L"None";

    DisplayMessage(g_hModule,
                   MSG_SRVR_CHANGE_AUDIT_SETTINGS,
                   pwszLogDir,
                   pwszNewDir);

    DisplayMessage(g_hModule,
                   MSG_SRVR_NEED_RESTART);

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);
CommonReturn:

    if( pwszLogDir )
    {
        DhcpRpcFreeMemory(pwszLogDir);
        pwszLogDir = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SET_AUDITLOG,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrSetDnsconfig(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                  Error = NO_ERROR;
    DHCP_OPTION_SCOPE_INFO ScopeInfo = {0};
    LPDHCP_OPTION_VALUE    OptionValue = NULL;
    DHCP_OPTION_VALUE      DummyValue;
    DHCP_OPTION_DATA_ELEMENT OptionElement;
    DHCP_OPTION_DATA       OptionData = { 1, &OptionElement };
    DWORD   dwValue = 0;
    
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SET_DNSCONFIG_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    ScopeInfo.ScopeType = DhcpGlobalOptions ;
    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionValueV5(g_ServerIpAddressUnicodeString,
                                     0,
                                     81,    //DYNDNS option
                                     NULL,
                                     NULL,
                                     &ScopeInfo,
                                     &OptionValue);

        if( ERROR_FILE_NOT_FOUND == Error )
        {
            dwValue = DNS_FLAG_ENABLED | DNS_FLAG_CLEANUP_EXPIRED;
            Error = NO_ERROR;
            OptionValue = NULL;
        }
    }
    else
    {
        Error = DhcpGetOptionValue(g_ServerIpAddressUnicodeString,
                                   81,
                                   &ScopeInfo,
                                   &OptionValue);
    }

    if( Error is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_NO_SETDNSCONFIG);
        return Error;
    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    if( NULL != OptionValue )
    {
        dwValue = OptionValue->Value.Elements->Element.DWordOption;
    }
    
    if( wcslen(ppwcArguments[dwCurrentIndex]) isnot 1 )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( ppwcArguments[dwCurrentIndex][0] is L'1' )
    {
        dwValue |= DNS_FLAG_ENABLED;
    }

    else if ( ppwcArguments[dwCurrentIndex][0] is L'0' )
    {
        dwValue &= ~DNS_FLAG_ENABLED;
    }

    else
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if( dwArgCount > 1 )
    {
        if( wcslen(ppwcArguments[dwCurrentIndex+1]) isnot 1 )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        if( ppwcArguments[dwCurrentIndex+1][0] is L'1' )
        {
            dwValue |= DNS_FLAG_UPDATE_BOTH_ALWAYS;
        }
        
        else if( ppwcArguments[dwCurrentIndex+1][0] is L'0' )
        {
            dwValue &= ~DNS_FLAG_UPDATE_BOTH_ALWAYS;
        }
        
        else
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    if( dwArgCount > 2 )
    {
        if( wcslen(ppwcArguments[dwCurrentIndex+2]) isnot 1 )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        if( ppwcArguments[dwCurrentIndex+2][0] is L'1' )
        {
            dwValue |= DNS_FLAG_CLEANUP_EXPIRED;
        }
        
        else if( ppwcArguments[dwCurrentIndex+2][0] is L'0' )
        {
            dwValue &= ~DNS_FLAG_CLEANUP_EXPIRED;
        }

        else
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    if( dwArgCount > 3 )
    {
        if( wcslen(ppwcArguments[dwCurrentIndex+3]) isnot 1 )
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        if( ppwcArguments[dwCurrentIndex+3][0] is L'1' )
        {
            dwValue |= DNS_FLAG_UPDATE_DOWNLEVEL;
        }
        else if( ppwcArguments[dwCurrentIndex+3][0] is L'0' )
        {
            dwValue &= ~DNS_FLAG_UPDATE_DOWNLEVEL;
        }
        else
        {
            Error = ERROR_INVALID_PARAMETER;
            goto ErrorReturn;
        }
    }

    if( NULL == OptionValue ) {
        OptionValue = & DummyValue;
        OptionValue->OptionID = 81; //DYNDNS option
        OptionValue->Value = OptionData;
        OptionValue->Value.Elements->OptionType = DhcpDWordOption;
    }
    
    OptionValue->Value.Elements->Element.DWordOption = dwValue;
    
    ScopeInfo.ScopeType = DhcpGlobalOptions ;

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpSetOptionValueV5(g_ServerIpAddressUnicodeString,
                                     0,
                                     81,    //DYNDNS option
                                     NULL,
                                     NULL,
                                     &ScopeInfo,
                                     &OptionValue->Value);
    }
    else
    {
        Error = DhcpSetOptionValue(g_ServerIpAddressUnicodeString,
                                   81,
                                   &ScopeInfo,
                                   &OptionValue->Value);
    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);

CommonReturn:

    if( OptionValue )
    {
        DhcpRpcFreeMemory(OptionValue);
        OptionValue = NULL;
    }
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_DNSCONFIG,
                        Error);
    goto CommonReturn;

}

DWORD
HandleSrvrSetDetectconflictretry(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                         Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4  ConfigInfo = NULL;
    
    if( dwArgCount < 1 )
    {
        DisplayMessage(g_hModule,
                       HLP_SRVR_SET_DETECTCONFLICTRETRY_EX);
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    ConfigInfo = DhcpAllocateMemory( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( ConfigInfo == NULL ) 
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SET_DATABASERESTOREFLAG,
                            Error);
        return Error;
    }

    memset(ConfigInfo, 0x00, sizeof(DHCP_SERVER_CONFIG_INFO_V4));

    if( IsPureNumeric(ppwcArguments[dwCurrentIndex]) )
    {
        ConfigInfo->dwPingRetries = STRTOUL(ppwcArguments[dwCurrentIndex], NULL, 10);
        
        if( ConfigInfo->dwPingRetries > 5 )
        {
            ConfigInfo->dwPingRetries = 5;
        }
    }
    else
    {
        Error = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    
    Error = DhcpServerSetConfigV4(g_ServerIpAddressUnicodeString,
                                  Set_PingRetries,
                                  ConfigInfo);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);


CommonReturn:

    if( ConfigInfo )
    {
        DhcpFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SET_DETECTCONFLICTRETRY,
                        Error);
    goto CommonReturn;                                
    
}


DWORD
HandleSrvrShowAll(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD Error = NO_ERROR;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    Error = HandleSrvrShowMibinfo(pwszMachine, ppwcArguments, dwCurrentIndex, dwArgCount, dwFlags, pvData, pbDone);
    Error = HandleSrvrShowServerconfig(pwszMachine, ppwcArguments, dwCurrentIndex, dwArgCount, dwFlags, pvData, pbDone);
    Error = HandleSrvrShowServerstatus(pwszMachine, ppwcArguments, dwCurrentIndex, dwArgCount, dwFlags, pvData, pbDone);

    return Error;
}

VOID
DisplayBindingInfo(DHCP_BIND_ELEMENT Element)
{
    WCHAR           wc[1024] = {L'\0'};
    
    if( Element.fBoundToDHCPServer )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_BOUNDTOSERVER_TRUE);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_BOUNDTOSERVER_FALSE);
    }

    DisplayMessage(g_hModule,
                   MSG_SRVR_PRIMARY_ADDRESS,
                   IpAddressToString(ntohl(Element.AdapterPrimaryAddress)));

    DisplayMessage(g_hModule,
                   MSG_SRVR_SUBNET_ADDRESS,
                   IpAddressToString(ntohl(Element.AdapterSubnetAddress)));

    DisplayMessage(g_hModule,
                   MSG_SRVR_IF_DESCRIPTION,
                   Element.IfDescription);

    DhcpHexToString(wc, Element.IfId, Element.IfIdSize);

    DisplayMessage(g_hModule,
                   MSG_SRVR_IFID,
                   wc);
    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);
                   

                   
}

DWORD
HandleSrvrShowBindings(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                          Error = NO_ERROR;
    LPDHCP_BIND_ELEMENT_ARRAY      Elements = NULL;
    LPDHCP_ATTRIB                  Attrib = NULL;
    DWORD                          i=0;

    Error = DhcpServerQueryAttribute(g_ServerIpAddressUnicodeString,
                                     0,
                                     DHCP_ATTRIB_BOOL_IS_BINDING_AWARE,
                                     &Attrib);

    if( Error isnot NO_ERROR )
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SHOW_BINDINGS,
                            Error);
        return Error;
    }                      
    
    if( Attrib->DhcpAttribBool is FALSE )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_BINDINGS_SUPPORT);
        return Error;
    }

    DhcpRpcFreeMemory(Attrib);
    Attrib = NULL;

    Error = DhcpGetServerBindingInfo(g_ServerIpAddressUnicodeString,
                                     0,
                                     &Elements);

    if( Error isnot NO_ERROR )
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SHOW_BINDINGS,
                            Error);
        return Error;
    }

    if( Elements->NumElements is 0 )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_NO_BINDINGS);
        if( Elements )
        {
            DhcpRpcFreeMemory(Elements);
            Elements = NULL;
        }
        return Error;
    }

    for( i=0; i<Elements->NumElements; i++ )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_BINDINGS,
                       i);
        DisplayBindingInfo(Elements->Elements[i]);
    }
    
    DisplayMessage(g_hModule,
                   EMSG_SRVR_ERROR_SUCCESS);
    return Error;
}


DWORD
HandleSrvrShowClass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                          Error = NO_ERROR;
    DWORD                          nRead, nTotal, nCount;
    DHCP_RESUME_HANDLE             ResumeHandle;
    LPDHCP_CLASS_INFO_ARRAY        ClassInfoArray = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    ClassInfoArray = NULL;
    ResumeHandle = 0;
    nRead = nTotal = nCount = 0;
    
    while(TRUE)
    {
        Error = DhcpEnumClasses(
                    g_ServerIpAddressUnicodeString,
                    0,
                    &ResumeHandle,
                    ~0,
                    &ClassInfoArray,
                    &nRead,
                    &nTotal
                );

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_CLASS_COUNT,
                           nCount);

            Error = NO_ERROR;

            break;
        }

        if( ERROR_MORE_DATA isnot Error and 
            NO_ERROR isnot Error ) 
        {
            goto ErrorReturn;
        }
        
        nCount += nRead;

        if( ClassInfoArray isnot NULL )
        {
            PrintClassInfoArray(ClassInfoArray);
            DhcpRpcFreeMemory(ClassInfoArray);
            ClassInfoArray = NULL;
        }
        if( Error is NO_ERROR )
        {
            break;
        }
        else
        {
            continue;    
        }

    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule, 
                        EMSG_SRVR_SHOW_CLASS, 
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrShowMibinfo(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_MIB_INFO     MibInfo = NULL;
    DWORD               i = 0;
    LPSCOPE_MIB_INFO    ScopeInfo = NULL;
    FILETIME            ftTime={0};
    LPWSTR              pwszTime = NULL;


    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    DisplayMessage(g_hModule, MSG_SRVR_MIB);
    
    Error = DhcpGetMibInfo(
                g_ServerIpAddressUnicodeString,
                &MibInfo );

    if( Error isnot NO_ERROR )
    {
        goto ErrorReturn;
    }


    DhcpAssert( MibInfo != NULL );

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_DISCOVERS, 
                   MibInfo->Discovers);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_OFFERS, 
                   MibInfo->Offers);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_REQUESTS, 
                   MibInfo->Requests);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_ACKS, 
                   MibInfo->Acks);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_NAKS, 
                   MibInfo->Naks);

    DisplayMessage(g_hModule,
                   MSG_SRVR_MIB_DECLINES,
                   MibInfo->Declines);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_MIB_RELEASES, 
                   MibInfo->Releases);

    ftTime = *(FILETIME *)(&MibInfo->ServerStartTime);
    
    i = 0;
    
    pwszTime = GetDateTimeString(ftTime,
                                 FALSE,
                                 &i);

    DisplayMessage(g_hModule,
                   MSG_SRVR_MIB_SERVERSTARTTIME,
                   pwszTime ? pwszTime : L" ");

    if( pwszTime )
    {
        DhcpFreeMemory(pwszTime);
        pwszTime = NULL;
    }

    DisplayMessage(g_hModule, MSG_SRVR_MIB_SCOPES, MibInfo->Scopes);

    ScopeInfo = MibInfo->ScopeInfo;

    for ( i = 0; i < MibInfo->Scopes; i++ ) 
    {
        DisplayMessage(g_hModule, 
                       MSG_SRVR_MIB_SCOPES_SUBNET,
                       IpAddressToString(ScopeInfo[i].Subnet));

        DisplayMessage(g_hModule,
                       MSG_SRVR_MIB_SCOPES_SUBNET_NUMADDRESSESINUSE,
                       ScopeInfo[i].NumAddressesInuse );

        DisplayMessage(g_hModule,
                       MSG_SRVR_MIB_SCOPES_SUBNET_NUMADDRESSESFREE,
                       ScopeInfo[i].NumAddressesFree );

        DisplayMessage(g_hModule,
                       MSG_SRVR_MIB_SCOPES_SUBNET_NUMPENDINGOFFERS,
                       ScopeInfo[i].NumPendingOffers );
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
CommonReturn:
    if( MibInfo )
    {
        DhcpRpcFreeMemory( MibInfo );
        MibInfo = NULL;
    }
    return Error;

ErrorReturn:
    DisplayMessage(g_hModule,
                   EMSG_SRVR_SHOW_MIBINFO,
                   Error);
    goto CommonReturn;
}

DWORD
HandleSrvrShowMscope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    DHCP_RESUME_HANDLE  ResumeHandle = 0;
    LPDHCP_MSCOPE_TABLE MScopeTable = NULL;
    DWORD               ClientsRead = 0;
    DWORD               ClientsTotal = 0;
    DWORD               i, nCount = 0;
    LPWSTR              UnicodeMScopeName = NULL;
    BOOL                fTable = FALSE;
    
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    while(TRUE)
    {

        MScopeTable = NULL;
        Error = DhcpEnumMScopes(
                    g_ServerIpAddressUnicodeString,
                    &ResumeHandle,
                    (DWORD)(-1),
                    &MScopeTable,
                    &ClientsRead,
                    &ClientsTotal );

        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_MULTICAST_CLIENT_COUNT,
                           nCount);
            Error = NO_ERROR;
            break;
        }

        if( Error isnot NO_ERROR and 
            Error isnot ERROR_MORE_DATA )
        {
            goto ErrorReturn;
        }

        DhcpAssert( MScopeTable != NULL );
        DhcpAssert( MScopeTable->NumElements == ClientsRead );

        if( fTable is FALSE )
        {           
            DisplayMessage(g_hModule, MSG_SRVR_MSCOPE_TABLE);
            fTable = TRUE;
        }

        nCount += ClientsRead;

        for( i = 0; i < ClientsRead; i++ ) 
        {
            LPDHCP_MSCOPE_INFO MScopeInfo = NULL;
            WCHAR Name[35] = {L'\0'};
            WCHAR Id[17] = {L'\0'};
            WCHAR Comment[21]={L'\0'};
            DWORD dw = 0, dwError = NO_ERROR;

            dwError = DhcpGetMScopeInfo(
                                      g_ServerIpAddressUnicodeString,
                                      MScopeTable->pMScopeNames[i],
                                      &MScopeInfo);


            if( dwError isnot NO_ERROR )
            {
                Error = dwError;
                goto ErrorReturn;
            }
            
            if( IsBadStringPtr(MScopeInfo->MScopeName, MAX_MSG_LENGTH) is FALSE )
            {
                for(dw=0; ( ( dw<34 ) && ( dw<wcslen(MScopeInfo->MScopeName) ) ); dw++)
                {
                    Name[dw] = MScopeInfo->MScopeName[dw];
                }
            }
            
            Name[34] = L'\0';

            for( dw = wcslen(Name); dw < 35; dw++ )
                Name[dw] = L' ';

            Name[34] = L'\0';

            if( IsBadStringPtr(MScopeInfo->MScopeComment, MAX_MSG_LENGTH) is FALSE )
            {
                for( dw=0; dw < 20 && dw < wcslen(MScopeInfo->MScopeComment); dw++ )
                    Comment[dw] = MScopeInfo->MScopeComment[dw];
            }

            Comment[20] = L'\0';

            for( dw=wcslen(Comment); dw < 20 ; dw++)
                Comment[dw] = L' ';
            
            Comment[19] = L'\0';
            
            wsprintf(Id, L" %u", MScopeInfo->MScopeId);

            Id[16] = L'\0';

            for( dw=wcslen(Id); dw < 16; dw++)
                Id[dw] = L' ';

            Id[16] = L'\0';
            
            if( MScopeInfo->MScopeState is DhcpSubnetEnabled )
            {
                DisplayMessage(g_hModule, 
                               MSG_SRVR_MSCOPE_INFO_ACTIVE,
                               Name,
                               Id,
                               Comment);

            }
            else
            {
                DisplayMessage(g_hModule, 
                               MSG_SRVR_MSCOPE_INFO_NOTACTIVE,
                               Name,
                               Id,
                               Comment);
            }

            DhcpRpcFreeMemory(MScopeInfo);
            MScopeInfo = NULL;

        }
        
        DhcpRpcFreeMemory( MScopeTable );
        MScopeTable = NULL;

        if( Error is ERROR_MORE_DATA ) 
        {
            continue;
        }
        else
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_MULTICAST_CLIENT_COUNT,
                           nCount);
            break;
        }
    }

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
CommonReturn:

    return( Error );

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_MSCOPE,
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrShowOptiondef(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD               Error = NO_ERROR;
    LPDHCP_OPTION_ARRAY OptionsArray = NULL;
    LPDHCP_ALL_OPTIONS  OptionsAll = NULL;
    DHCP_RESUME_HANDLE  ResumeHandle = 0;
    DWORD               OptionsRead  = 0;
    DWORD               OptionsTotal = 0;
    DWORD               nCount = 0;
    LPWSTR              pwcTag = NULL;
    LPWSTR              pwcUser = NULL;
    LPWSTR              pwcVendor = NULL;
    LPWSTR              pwcTemp = NULL;
    
    BOOL                fUser = FALSE;
    BOOL                fVendor = FALSE;
    BOOL                fTable = FALSE;

    DWORD               dwIndex=0;
    enum                {all=0, user, vendor, both}eDisplay;

    
    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    if( dwArgCount > 0 )
    {
        if( _wcsicmp(ppwcArguments[dwCurrentIndex], L"all") is 0 )
        {
            eDisplay = all;
        }
        else
        {
            while( TRUE )
            {
                LPWSTR  pwcStr = NULL;
        
                if( dwArgCount <= dwIndex )
                    break;
                if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
                    break;
    
                pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
                if( pwcTemp is NULL )
                {
                    Error = ERROR_OUT_OF_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

                pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
                if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
                {
                    if( fUser is TRUE ) //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcUser = NULL;
                        else
                        {
                            pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcUser is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcUser, pwcStr);
                            eDisplay = user;
                        }
                        fUser = TRUE;
                    }
                }
                else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
                {
                    if( fVendor is TRUE )   //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcVendor = NULL;
                        else
                        {
                            pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcVendor is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcVendor, pwcStr);
                            eDisplay = vendor;
                        }
                        fVendor = TRUE;
                    }
                }
                else
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
                    return ERROR_INVALID_PARAMETER;
                }

                if( pwcTemp )
                {
                    DhcpFreeMemory(pwcTemp);
                    pwcTemp = NULL;
                }
        
                dwIndex++;
            }
        }
    }

    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }


    if( fUser && fVendor )
    {
        eDisplay = both;
    }

    switch(eDisplay)
    {
    case all:
        {
            while(TRUE)
            {
                Error = DhcpGetAllOptions(
                            g_ServerIpAddressUnicodeString,
                            0,
                            &OptionsAll);

                if( Error is NO_ERROR or
                    Error is ERROR_MORE_DATA )
                {
                    PrintAllOptions(OptionsAll);
                    if( Error is NO_ERROR )
                        break;
                    else
                    {
                        DhcpRpcFreeMemory(OptionsAll);
                        OptionsAll = NULL;
                        continue;
                    }
                }
                else
                    goto ErrorReturn;
            }
            break;
        }
    default:
        {
            nCount = 0;

            while(TRUE)
            {
                if( g_dwMajorVersion >= CLASS_ID_VERSION )
                {
                    Error = DhcpEnumOptionsV5(
                                            g_ServerIpAddressUnicodeString,
                                            fVendor ? DHCP_FLAGS_OPTION_IS_VENDOR : 0,
                                            pwcUser,
                                            pwcVendor,
                                            &ResumeHandle,
                                            ~0,
                                            &OptionsArray,
                                            &OptionsRead,
                                            &OptionsTotal
                                            );


                }
                else
                {
                    Error = DhcpEnumOptions(
                                            g_ServerIpAddressUnicodeString,
                                            &ResumeHandle,
                                            ~0,
                                            &OptionsArray,
                                            &OptionsRead,
                                            &OptionsTotal);
                
                }

                if( Error is ERROR_NO_MORE_ITEMS )
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTION_TOTAL,
                                   nCount);
                    Error = NO_ERROR;

                    break;
                }


                if( Error isnot NO_ERROR and
                    Error isnot ERROR_MORE_DATA 
                  )
                {
                    goto ErrorReturn;
                } 

                nCount += OptionsRead;

                {

                    DWORD           i = 0;
                    LPDHCP_OPTION   Options;
                    DWORD           NumOptions = 0;

                

                    if( g_dwMajorVersion >= CLASS_ID_VERSION )
                    {
                        if( pwcUser isnot NULL )
                        {
                            DisplayMessage(g_hModule, 
                                           MSG_SRVR_USER_CLASS,
                                           pwcUser);
                        }

                        if( pwcVendor )
                        {
                            DisplayMessage(g_hModule,
                                           MSG_SRVR_VENDOR_CLASS,
                                           pwcVendor);
                        }
                    }

                    DisplayMessage(g_hModule,
                                   MSG_DHCP_FORMAT_LINE);


                    Options = OptionsArray->Options;
                    NumOptions = OptionsArray->NumElements;

                    if( fTable is FALSE )
                    {
                        if( pwcUser is NULL &&
                            pwcVendor is NULL )
                            DisplayMessage(g_hModule, MSG_SRVR_OPTION_NONVENDOR);
                        DisplayMessage(g_hModule, MSG_SRVR_OPTIONDEF_TABLE);
                        fTable = TRUE;
                    }
                    for( i = 0; i < NumOptions; i++, Options++ ) 
                    {
                        PrintOptionInfo( Options );
                    }
                    DhcpRpcFreeMemory( OptionsArray );
                    OptionsArray = NULL;
                }
                
                if( Error is ERROR_MORE_DATA )
                {
                    continue;
                }
                else
                {
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_OPTION_TOTAL,
                                   nCount);
                    break;
                                   
                }
                    
            }
            break;
        }
    }
CommonReturn:
    if( Error is ERROR_SUCCESS )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);

    if( pwcUser  && pwcUser != g_UserClass ) 
    {
        DhcpFreeMemory(pwcUser);
        pwcUser = NULL;
    }
    if( pwcVendor  && pwcVendor != g_VendorClass ) 
    {
        DhcpFreeMemory(pwcVendor);
        pwcVendor = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_OPTIONDEF,
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrShowOptionvalue(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                       Error = NO_ERROR;
    DWORD                       Major;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    DHCP_OPTION_SCOPE_INFO      ScopeInfo;
    LPDHCP_OPTION_VALUE_ARRAY   OptionArray = NULL;
    DHCP_RESUME_HANDLE          Resume = 0;
    LPWSTR                      pwcTag = NULL;
    LPWSTR                      pwcUser = NULL;
    LPWSTR                      pwcVendor = NULL;
    LPWSTR                      pwcTemp = NULL;

    BOOL                        fUser = FALSE;
    BOOL                        fVendor = FALSE;

    DWORD                       dwRead = 0;
    DWORD                       dwTotal = 0;
    DWORD                       dwCount = 0;

    DWORD                       dwIndex=0;

    enum                        { all=0, user, vendor, both}eDisplay;


    memset(&ScopeInfo, 0x00, sizeof(DHCP_OPTION_SCOPE_INFO));
    
    eDisplay = all;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    ScopeInfo.ScopeType = DhcpGlobalOptions;
    
    if( dwArgCount > 0 )
    {
        if( _wcsicmp(ppwcArguments[dwCurrentIndex], L"all") is 0 )
        {
            eDisplay = all;
        }
        else
        {
            while( TRUE )
            {
                LPWSTR  pwcStr = NULL;
        
                if( dwArgCount <= dwIndex )
                    break;
                if( NULL is wcsstr(ppwcArguments[dwCurrentIndex+dwIndex], DHCP_ARG_DELIMITER) )
                    break;
    
                pwcTemp = DhcpAllocateMemory((wcslen(ppwcArguments[dwCurrentIndex+dwIndex])+1)*sizeof(WCHAR));
                if( pwcTemp is NULL )
                {
                    Error = ERROR_OUT_OF_MEMORY;
                    goto ErrorReturn;
                }
                wcscpy(pwcTemp, ppwcArguments[dwCurrentIndex+dwIndex]);

                pwcTag = wcstok(pwcTemp, DHCP_ARG_DELIMITER);
        
                if( MatchToken(pwcTag, TOKEN_USER_CLASS) )
                {
                    if( fUser is TRUE ) //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcUser = NULL;
                        else
                        {
                            pwcUser = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcUser is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcUser, pwcStr);
                        }
                        eDisplay = user;
                        fUser = TRUE;
                    }
                }
                else if( MatchToken(pwcTag, TOKEN_VENDOR_CLASS) )
                {
                    if( fVendor is TRUE )   //If already set
                    {
                        DisplayMessage(g_hModule, EMSG_DHCP_DUPLICATE_TAG, pwcTag);
                        Error = ERROR_INVALID_PARAMETER;
                        goto ErrorReturn;
                    }
                    else
                    {
                        pwcStr = wcstok(NULL, DHCP_ARG_DELIMITER);
                        if( pwcStr is NULL )
                            pwcVendor = NULL;
                        else
                        {
                            pwcVendor = DhcpAllocateMemory((wcslen(pwcStr)+1)*sizeof(WCHAR));
                            if( pwcVendor is NULL )
                            {
                                Error = ERROR_INVALID_PARAMETER;
                                goto ErrorReturn;
                            }
                            wcscpy(pwcVendor, pwcStr);
                        }
                        eDisplay = vendor;
                        fVendor = TRUE;
                    }
                }
                else
                {
                    DisplayMessage(g_hModule, EMSG_DHCP_INVALID_TAG, pwcTag);
                    return ERROR_INVALID_PARAMETER;
                }

                if( pwcTemp )
                {
                    DhcpFreeMemory(pwcTemp);
                    pwcTemp = NULL;
                }
        
                dwIndex++;
            }

        }
    }


    if( fUser )
    {
        if( pwcUser is NULL )
        {
            fUser = FALSE;
        }
    }
    else
    {
        pwcUser = g_UserClass;
        fUser = g_fUserClass;
    }

    if( fVendor )
    {
        if( pwcVendor is NULL )
        {
            fVendor = FALSE;
        }
    }
    else
    {
        pwcVendor = g_VendorClass;
        fVendor = g_fIsVendor;
    }    

    if( fUser && fVendor )
    {
        eDisplay = both;
    }

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        switch( eDisplay )
        {
        case all:
        default:
            {
                Error = DhcpGetAllOptionValues(
                            g_ServerIpAddressUnicodeString,
                            DHCP_OPT_ENUM_IGNORE_VENDOR,
                            &ScopeInfo,
                            &OptionValues
                            );


                if( Error isnot NO_ERROR )
                    goto ErrorReturn;
            
                if( OptionValues )
                {
                    dwCount += PrintAllOptionValues(OptionValues);
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }

                break;
            }
        case user:
            {
                Error = DhcpGetAllOptionValues(
                                g_ServerIpAddressUnicodeString,
                                DHCP_OPT_ENUM_IGNORE_VENDOR,
                                &ScopeInfo,
                                &OptionValues);

                if( Error isnot NO_ERROR )
                    goto ErrorReturn;

                if( OptionValues )
                {
                    dwCount += PrintUserOptionValues(OptionValues, pwcUser, NULL);
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
                break;
            }
        case vendor:
            {
                Error = DhcpGetAllOptionValues(
                                g_ServerIpAddressUnicodeString,
                                DHCP_OPT_ENUM_IGNORE_VENDOR,
                                &ScopeInfo,
                                &OptionValues);

                if( Error isnot NO_ERROR )
                    goto ErrorReturn;

                if( OptionValues )
                {
                    dwCount += PrintUserOptionValues(OptionValues, pwcUser, pwcVendor);
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
                break;
            }
        case both:
            {
                Error = DhcpGetAllOptionValues(
                                g_ServerIpAddressUnicodeString,
                                DHCP_OPT_ENUM_IGNORE_VENDOR,
                                &ScopeInfo,
                                &OptionValues);

                if( Error isnot NO_ERROR )
                    goto ErrorReturn;

                if( OptionValues )
                {
                    dwCount += PrintUserOptionValues(OptionValues, pwcUser, pwcVendor);
                    DhcpRpcFreeMemory(OptionValues);
                    OptionValues = NULL;
                }
                break;
            }
        }
    }
    else
    {
        Error = ShowOptionValues4(g_ServerIpAddressUnicodeString,
                                  &ScopeInfo,
                                  &dwCount);

        if( Error isnot NO_ERROR )
            goto ErrorReturn;
    }
CommonReturn:
    if( Error is ERROR_SUCCESS )
    {
        if( dwCount is 0 )
        {
            DisplayMessage(g_hModule,
                           MSG_DHCP_NO_OPTIONVALUE_SET);
        }

        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    }
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_OPTIONVALUE,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrShowScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                               Error = NO_ERROR;
    ULONG                               nRead, nTotal, i, nCount;
    ULONG                               Resume = 0;
    LPDHCP_IP_ARRAY                     IpArray = NULL;
    LPDHCP_SUBNET_INFO                  ScopeInfo = NULL;
    DHCP_HOST_INFO                      HostInfo;
    BOOL                                fHost = FALSE,
                                        fTable = FALSE;
;;

    memset( &HostInfo, 0x00, sizeof(DHCP_HOST_INFO));

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }



    nRead = nTotal = i = nCount = 0;

       
    while(TRUE)
    {

        Error = DhcpEnumSubnets(
                    g_ServerIpAddressUnicodeString,
                    &Resume,
                    ~0,
                    &IpArray,
                    &nRead,
                    &nTotal
                    );
        
        if( Error is ERROR_NO_MORE_ITEMS )
        {
            DisplayMessage(g_hModule, 
                           MSG_SRVR_SCOPE_COUNT, 
                           nCount);

            Error = NO_ERROR;

            break;
        }
        if( Error isnot NO_ERROR and
            Error isnot ERROR_MORE_DATA )
            goto ErrorReturn;
        

        DhcpAssert( IpArray isnot NULL );
        
        nCount += nRead;

        if( fTable is FALSE )
        {
            DisplayMessage(g_hModule, MSG_SRVR_SCOPE_TABLE);
            fTable = TRUE;
        }
        for( i = 0; ( i < nRead ) and ( i < IpArray->NumElements ) ; i++ )
        {
            DWORD dwError = NO_ERROR;

            dwError = DhcpGetSubnetInfo(
                          g_ServerIpAddressUnicodeString,
                          IpArray->Elements[i],
                          &ScopeInfo);

            if( dwError isnot NO_ERROR )
            {
                Error = dwError;
                goto ErrorReturn;
            }


            DhcpAssert( ScopeInfo isnot NULL );

            
            if( fHost is FALSE )
            {
                HostInfo = ScopeInfo->PrimaryHost;
                fHost = TRUE;
            }
            {
                WCHAR   Ip[17] = {L'\0'};
                WCHAR   Mask[17] = {L'\0'};
                WCHAR   Name[22] = {L'\0'};
                WCHAR   Comment[15] = {L'\0'};
                DWORD   dw = 0;

                wsprintf( Ip, L" %s", IpAddressToString(ScopeInfo->SubnetAddress));
                for( dw=wcslen(Ip); dw<17; dw++)
                    Ip[dw] = L' ';
                Ip[16] = L'\0';


                wsprintf( Mask, L" %s", IpAddressToString(ScopeInfo->SubnetMask));
                for( dw=wcslen(Mask); dw<17; dw++)
                    Mask[dw] = L' ';
                Mask[16] = L'\0';

                if( IsBadStringPtr(ScopeInfo->SubnetName, MAX_MSG_LENGTH) is FALSE )
                {
                    for( dw=0; (dw < 21) && (dw<wcslen(ScopeInfo->SubnetName)) ; dw++)
                    {
                        Name[dw] = ScopeInfo->SubnetName[dw];
                    }
                }
                
                Name[21] = L'\0';

                for( dw = wcslen(Name); dw<22 ; dw++)
                    Name[dw] = L' ';

                Name[21] = L'\0';

                if( IsBadStringPtr(ScopeInfo->SubnetComment, MAX_MSG_LENGTH) is FALSE )
                {
                    for( dw=0; (dw < 14) && (dw<wcslen(ScopeInfo->SubnetComment)) ; dw++)
                    {
                        Comment[dw] = ScopeInfo->SubnetComment[dw];
                    }
                }
                
                Comment[14] = L'\0';

                for( dw = wcslen(Comment); dw<15 ; dw++)
                    Comment[dw] = L' ';

                Comment[14] = L'\0';

                switch( ScopeInfo->SubnetState ) {
                case DhcpSubnetEnabled:
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_SCOPE_INFO_ACTIVE,
                                   Ip,
                                   Mask,
                                   Name,
                                   Comment);
                    break;
                case DhcpSubnetDisabled :
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_SCOPE_INFO_NOTACTIVE,
                                   Ip,
                                   Mask,
                                   Name,
                                   Comment);
                    break;
                case DhcpSubnetEnabledSwitched :
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_SCOPE_INFO_ACTIVE_SWITCHED,
                                   Ip,
                                   Mask,
                                   Name,
                                   Comment);
                    break;
                case DhcpSubnetDisabledSwitched :
                    DisplayMessage(g_hModule,
                                   MSG_SRVR_SCOPE_INFO_NOTACTIVE_SWITCHED,
                                   Ip,
                                   Mask,
                                   Name,
                                   Comment);
                    break;                    
                }
            }    
            DhcpRpcFreeMemory(ScopeInfo);
            ScopeInfo = NULL;
        }
        
        DhcpRpcFreeMemory(IpArray);
        IpArray = NULL;
        
        if( Error is ERROR_MORE_DATA )
            continue;
        else
        {
            DisplayMessage(g_hModule,
                           MSG_DHCP_FORMAT_LINE);
            DisplayMessage(g_hModule, 
                           MSG_SRVR_SCOPE_COUNT, 
                           nCount);
            break;
        }
    }

CommonReturn:
    if( Error is NO_ERROR )
        DisplayMessage(g_hModule, EMSG_SRVR_ERROR_SUCCESS);
    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_SCOPE,
                        Error);
    goto CommonReturn;
}


DWORD
HandleSrvrShowServer(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( ( g_ServerIpAddressUnicodeString is NULL ) and ( g_pwszServer is NULL ) )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_SRVR_COMPUTER_NAME, g_pwszServer, g_ServerIpAddressUnicodeString);
    }
    
    return NO_ERROR;
}

DWORD
HandleSrvrShowServerconfig(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                        Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_SRVR_SERVERCONFIG);
    
    Error = DhcpServerGetConfigV4(
                g_ServerIpAddressUnicodeString,
                &ConfigInfo );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( Error isnot NO_ERROR ) 
    {
        DisplayErrorMessage(g_hModule, 
                            EMSG_SRVR_SHOW_SERVERCONFIG,
                            Error);
        return Error;
    }


    DhcpAssert( ConfigInfo != NULL );

    DisplayMessage(g_hModule,
                   MSG_SRVR_DBPROPERTIES);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_DATABASENAME_VALUE, 
                   ConfigInfo->DatabaseName);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_DATABASEPATH_VALUE, 
                   ConfigInfo->DatabasePath);
    
    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_BACKUPPATH_VALUE, 
                   ConfigInfo->BackupPath);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_BACKUPINTERVAL_VALUE, 
                   ConfigInfo->BackupInterval);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_DATABASELOGGINGFLAG_VALUE, 
                   ConfigInfo->DatabaseLoggingFlag);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_RESTOREFLAG_VALUE, 
                   ConfigInfo->RestoreFlag);

    DisplayMessage(g_hModule, 
                   MSG_SRVR_SERVERCONFIG_DATABASECLEANUPINTERVAL_VALUE, 
                   ConfigInfo->DatabaseCleanupInterval);


    DhcpRpcFreeMemory( ConfigInfo );
    ConfigInfo = NULL;

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);

    return Error;

}


DWORD
HandleSrvrShowServerstatus(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD           Error = NO_ERROR;
    PDHCP_ATTRIB    pStatusAttrib = NULL;

    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    DisplayMessage(g_hModule, MSG_SRVR_SERVER_STATUS);

    Error = DhcpServerQueryAttribute(
        g_ServerIpAddressUnicodeString,
        0,
        DHCP_ATTRIB_BOOL_IS_ROGUE,
        &pStatusAttrib
    );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( NO_ERROR isnot Error ) 
    {
        DisplayErrorMessage(g_hModule,
                            EMSG_SRVR_SHOW_SERVERSTATUS,
                            Error);
        return Error;
    }

    PrintDhcpAttrib(pStatusAttrib);

    if( pStatusAttrib ) 
    {
        DhcpRpcFreeMemory(pStatusAttrib);
    }

    pStatusAttrib = NULL;

    Error = DhcpServerQueryAttribute(
                g_ServerIpAddressUnicodeString,
                0,
                DHCP_ATTRIB_BOOL_IS_DYNBOOTP,
                &pStatusAttrib
            );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( NO_ERROR isnot Error ) 
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_SHOW_SERVERSTATUS,
                       g_pwszServer,
                       Error);
        return Error;        
    }

    PrintDhcpAttrib(pStatusAttrib);

    if( pStatusAttrib ) 
    {
        DhcpRpcFreeMemory(pStatusAttrib);
    }

    pStatusAttrib = NULL;

    Error = DhcpServerQueryAttribute(
                g_ServerIpAddressUnicodeString,
                0,
                DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC,
                &pStatusAttrib
            );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( NO_ERROR isnot Error ) 
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_SHOW_SERVERSTATUS,
                       g_pwszServer,
                       Error);
        return Error;        
    }

    PrintDhcpAttrib(pStatusAttrib);
    if( pStatusAttrib ) 
        DhcpRpcFreeMemory(pStatusAttrib);

    pStatusAttrib = NULL;
    
    Error = DhcpServerQueryAttribute(
                g_ServerIpAddressUnicodeString,
                0,
                DHCP_ATTRIB_BOOL_IS_BINDING_AWARE,
                &pStatusAttrib
            );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( NO_ERROR isnot Error ) 
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_SHOW_SERVERSTATUS,
                       g_pwszServer,
                       Error);
        return Error;        
    }

    PrintDhcpAttrib(pStatusAttrib);
    
    if( pStatusAttrib ) 
        DhcpRpcFreeMemory(pStatusAttrib);

    pStatusAttrib = NULL;
    
    Error = DhcpServerQueryAttribute(
                g_ServerIpAddressUnicodeString,
                0,
                DHCP_ATTRIB_BOOL_IS_ADMIN,
                &pStatusAttrib
            );

    if( Error is ERROR_NO_MORE_ITEMS )
    {
        DisplayMessage(g_hModule, EMSG_DHCP_NO_MORE_ITEMS);
        return Error;
    }

    if( NO_ERROR isnot Error ) 
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_SHOW_SERVERSTATUS,
                       g_pwszServer,
                       Error);
        return Error;        
    }

    PrintDhcpAttrib(pStatusAttrib);
    
    if( pStatusAttrib ) 
        DhcpRpcFreeMemory(pStatusAttrib);

    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
    
    pStatusAttrib = NULL;

    return Error;
    
}


DWORD
HandleSrvrShowUserclass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( g_UserClass is NULL )
    {
        DisplayMessage(g_hModule, MSG_SRVR_CLASSNAME_NONE, g_pwszServer);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_SRVR_CLASSNAME, g_UserClass, g_pwszServer);
    }
    return NO_ERROR;
}


DWORD
HandleSrvrShowVendorclass(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    if( g_VendorClass is NULL )
    {
        DisplayMessage(g_hModule, MSG_SRVR_VENDORNAME_NONE, g_pwszServer);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_SRVR_VENDORNAME, g_VendorClass, g_pwszServer);
    }
    return NO_ERROR;
}

DWORD
HandleSrvrShowDnsCredentials(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    WCHAR Name[256], Domain[256];
    DWORD Error = NO_ERROR;


    if( g_ServerIpAddressUnicodeString is NULL )
    {
        DisplayMessage(g_hModule, EMSG_SRVR_NO_COMPUTER_NAME);
        return Error;
    }
    

    ZeroMemory(Name,sizeof(Name));
    ZeroMemory(Domain,sizeof(Domain));
    Error = DhcpServerQueryDnsRegCredentials(
        g_ServerIpAddressUnicodeString,
        sizeof(Name), (LPWSTR)Name, sizeof(Domain),
        (LPWSTR)Domain );

    if( RPC_S_PROCNUM_OUT_OF_RANGE == Error ) {
        DisplayMessage(
            g_hModule, EMSG_SRVR_NEED_DNS_CREDENTIALS_SUPPORT );
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    if( NO_ERROR != Error ) {
        DisplayErrorMessage(
            g_hModule, EMSG_SRVR_SHOW_DNSCREDENTIALS, Error );
    } else {
        DisplayMessage(
            g_hModule, MSG_SRVR_DNS_CREDENTIALS, Name, Domain );
    }

    return Error;
}

DWORD
HandleSrvrShowVersion(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DisplayMessage(g_hModule,
                   MSG_SRVR_VERSION,
                   g_ServerIpAddressUnicodeString,
                   g_dwMajorVersion,
                   g_dwMinorVersion);
    return NO_ERROR;
}

DWORD
HandleSrvrShowAuditlog(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD   Error = NO_ERROR;
    DWORD   DiskCheckInterval = 0, 
            MaxLogFileSize = 0,
            MinSpaceOnDisk = 0;
    LPWSTR  pwszLogDir = NULL;

    Error = DhcpAuditLogGetParams( g_ServerIpAddressUnicodeString,
                                   0,
                                   &pwszLogDir,
                                   &DiskCheckInterval,
                                   &MaxLogFileSize,
                                   &MinSpaceOnDisk);


    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   MSG_SRVR_AUDIT_SETTINGS,
                   pwszLogDir,
                   DiskCheckInterval,
                   MaxLogFileSize,
                   MinSpaceOnDisk);

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);
CommonReturn:

    if( pwszLogDir )
    {
        DhcpRpcFreeMemory(pwszLogDir);
        pwszLogDir = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_AUDITLOG,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrShowDnsconfig(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                  Error = NO_ERROR;
    DHCP_OPTION_SCOPE_INFO ScopeInfo = {0};
    DHCP_OPTION_ID         OptionId = 81;
    LPDHCP_OPTION_VALUE    OptionValue = NULL;

    DWORD   dwValue = 0;
    
    ScopeInfo.ScopeType = DhcpGlobalOptions;

    if( g_dwMajorVersion >= CLASS_ID_VERSION )
    {
        Error = DhcpGetOptionValueV5(g_ServerIpAddressUnicodeString,
                                     0,
                                     OptionId,    //DYNDNS option
                                     NULL,
                                     NULL,
                                     &ScopeInfo,
                                     &OptionValue);

        if( ERROR_FILE_NOT_FOUND == Error ) {
            dwValue = DNS_FLAG_ENABLED | DNS_FLAG_CLEANUP_EXPIRED;
            Error = NO_ERROR;
            OptionValue = NULL;
        }
    }
    else
    {
        Error = DhcpGetOptionValue(g_ServerIpAddressUnicodeString,
                                   OptionId,//81,
                                   &ScopeInfo,
                                   &OptionValue);
    }
    
    if( Error is ERROR_FILE_NOT_FOUND )
    {
        DisplayMessage(g_hModule,
                       EMSG_SRVR_NO_SHOWDNSCONFIG);
        return Error;
    }
    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    if( OptionValue ) {
        dwValue = OptionValue->Value.Elements->Element.DWordOption;
    }
    
    if( dwValue & DNS_FLAG_ENABLED )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_DNS_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_DNS_DISABLED);

        DisplayMessage(g_hModule,
                       EMSG_DHCP_ERROR_SUCCESS);
        goto CommonReturn;
    }

    DisplayMessage(g_hModule,
                   MSG_SRVR_UPDATE_LOOKUP);

    if( dwValue & DNS_FLAG_UPDATE_BOTH_ALWAYS )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_UPDATE_DOWNLEVEL_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_UPDATE_DOWNLEVEL_DISABLED);
    }

    DisplayMessage(g_hModule,
                   MSG_SRVR_DNS_OPTIONS);

    if( dwValue & DNS_FLAG_CLEANUP_EXPIRED )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_CLEANUP_EXPIRED_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_CLEANUP_EXPIRED_DISABLED);
    }

    if( dwValue & DNS_FLAG_UPDATE_DOWNLEVEL )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_UPDATE_BOTH_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_UPDATE_BOTH_DISABLED);
    }
    
    DisplayMessage(g_hModule,
                   MSG_DHCP_FORMAT_LINE);
    
    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);

CommonReturn:

    if( OptionValue )
    {
        DhcpRpcFreeMemory(OptionValue);
        OptionValue = NULL;
    }

    return Error;
ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_DNSCONFIG,
                        Error);
    goto CommonReturn;
}

DWORD
HandleSrvrShowDetectconflictretry(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD                           Error = NO_ERROR;
    LPDHCP_SERVER_CONFIG_INFO_V4    ConfigInfo = NULL;
    
    Error = DhcpServerGetConfigV4(g_ServerIpAddressUnicodeString,
                                  &ConfigInfo);

    if( Error isnot NO_ERROR )
        goto ErrorReturn;

    DisplayMessage(g_hModule,
                   MSG_SRVR_PING_RETRY,
                   ConfigInfo->dwPingRetries);

    DisplayMessage(g_hModule,
                   EMSG_DHCP_ERROR_SUCCESS);

CommonReturn:
    if( ConfigInfo )
    {
        DhcpRpcFreeMemory(ConfigInfo);
        ConfigInfo = NULL;
    }
    return Error;

ErrorReturn:
    DisplayErrorMessage(g_hModule,
                        EMSG_SRVR_SHOW_DETECTCONFLICTRETRY,
                        Error);
    goto CommonReturn;
}

VOID
PrintClassInfo(                                   // print info on a single class
    LPDHCP_CLASS_INFO      Class
)
{
    DWORD   i;

    if( Class->IsVendor )
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_CLASS_INFO_VENDOR,
                       Class->ClassName, 
                       Class->ClassComment, 
                       Class->Flags);
    }
    else
    {
        DisplayMessage(g_hModule,
                       MSG_SRVR_CLASS_INFO,
                       Class->ClassName, 
                       Class->ClassComment, 
                       Class->Flags);
    }

    DisplayMessage(g_hModule, MSG_SRVR_CLASS_DATA);
    for( i = 0; i < Class->ClassDataLength; i ++ )
        DisplayMessage(g_hModule, 
                       MSG_SRVR_CLASS_DATA_FORMAT, 
                       Class->ClassData[i]);
    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
}

VOID
PrintClassInfoArray(                              // print array of classes
    LPDHCP_CLASS_INFO_ARRAY Classes
)
{
    DWORD   i;

    DisplayMessage(g_hModule,
                   MSG_SRVR_CLASS_INFO_ARRAY, 
                   Classes->NumElements);

    for( i = 0; i < Classes->NumElements; i ++ )
        PrintClassInfo(&Classes->Classes[i]);
}


DWORD
_CreateOption(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DHCP_OPTION           *OptionInfo
)
{
    DWORD                          MajorVersion, MinorVersion;
    DWORD                          Error;

#ifdef NT5
    if( g_dwMajorVersion >= CLASS_ID_VERSION ) 
    {

        return DhcpCreateOptionV5(
            ServerAddress,
            0,
            OptionId,
            ClassName,
            VendorName,
            OptionInfo
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpCreateOption(
        ServerAddress,
        OptionId,
        OptionInfo
    );

}


DWORD
SetOptionDataType(
    DHCP_OPTION_DATA_TYPE  OptionType,
    LPTSTR OptionValueString,
    LPDHCP_OPTION_DATA_ELEMENT OptionData,
    LPWSTR *UnicodeOptionValueString
)
{
    DWORD                 OptionValue;

    OptionData->OptionType = OptionType;
    
    if( OptionValueString is NULL )
    {
        return NO_ERROR;
    }

    if( DhcpStringDataOption != OptionType && 0 == wcslen(OptionValueString) ) {
        return NO_ERROR;
    }

    switch( OptionType ) 
    {
    case DhcpByteOption:
        {

            if( IsPureHex( OptionValueString ) is FALSE )
            {
                return ERROR_INVALID_PARAMETER;
            }

            OptionValue = (BYTE)STRTOUL( OptionValueString, NULL, 16 );

            if( OptionValue > 0xFF ) 
            {
                DisplayMessage(g_hModule,
                               EMSG_SRVR_VALUE_OUT_OF_RANGE);

                return( ERROR_INVALID_PARAMETER );
            }

            OptionData->Element.ByteOption = (BYTE)OptionValue;
            break;
        }
    case DhcpWordOption:
        if( FALSE is IsPureNumeric( OptionValueString ) )
        {
            return ERROR_INVALID_PARAMETER;
        }
        OptionValue = (WORD)STRTOUL( OptionValueString, NULL, 10 );

        if( OptionValue > 0xFFFF ) 
        {
            DisplayMessage(g_hModule,
                           EMSG_SRVR_VALUE_OUT_OF_RANGE);

            return( ERROR_INVALID_PARAMETER );
        }

        OptionData->Element.WordOption = (WORD)OptionValue;
        break;

    case DhcpDWordOption:

        if( FALSE is IsPureNumeric(OptionValueString) )
        {
            return ERROR_INVALID_PARAMETER;
        }

        OptionValue = STRTOUL( OptionValueString, NULL, 10 );
        OptionData->Element.DWordOption = (DWORD)OptionValue;
        break;


    case DhcpIpAddressOption:
        OptionData->Element.IpAddressOption =
            StringToIpAddress(OptionValueString);
        break;

    case DhcpStringDataOption:
        {
#ifdef UNICODE
            *UnicodeOptionValueString = OptionValueString;
#else
            *UnicodeOptionValueString =
                DhcpOemToUnicode( OptionValueString, NULL );
#endif //UNICODE
            if( UnicodeOptionValueString == NULL ) 
            {
                return( ERROR_NOT_ENOUGH_MEMORY );
            }
        OptionData->Element.StringDataOption = *UnicodeOptionValueString;
        break;
        }


    case DhcpBinaryDataOption:
    case DhcpEncapsulatedDataOption:
        {
            PUCHAR Bytes;
            ULONG Length, i;        

            Length = (wcslen(OptionValueString))/2;
            if( Length * 2 != wcslen(OptionValueString) ) {
                return ERROR_INVALID_PARAMETER;
            }

            for( i = 0; i < Length * 2 ; i ++ ) {
                 if( !iswxdigit(OptionValueString[i]) ) {
                      return ERROR_INVALID_PARAMETER;
                 }
            }

            Bytes = DhcpAllocateMemory(Length);
            if( NULL == Bytes ) {
                  return ERROR_NOT_ENOUGH_MEMORY;
            }
            (*UnicodeOptionValueString) = (LPWSTR)(Bytes);
            OptionData->Element.BinaryDataOption.DataLength = Length;
            OptionData->Element.BinaryDataOption.Data = Bytes;

            while( Length -- ) {
                WCHAR OneByte[3] = {0, 0, 0 };

                OneByte[0] = OptionValueString[0];
                OneByte[1] = OptionValueString[1];
                OptionValueString += 2;

                *Bytes++ = (BYTE)(STRTOUL(OneByte, NULL, 16));
            }
            break;
        }
    default:
        {
            DhcpAssert(FALSE);
            
            DisplayMessage(g_hModule,
                           EMSG_SRVR_UNKNOWN_OPTION_TYPE);

            DisplayMessage(g_hModule,
                           HLP_SRVR_ADD_OPTIONDEF);

            return( ERROR_INVALID_PARAMETER );
        }
    }

    return( ERROR_SUCCESS );
}

DWORD
_EnumOptions(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
)
{

#ifdef NT5
 

    if( g_dwMajorVersion >= CLASS_ID_VERSION ) 
    {

        return DhcpEnumOptionsV5(
            ServerAddress,
            0,
            ClassName,
            VendorName,
            ResumeHandle,
            PreferredMaximum,
            Options,
            OptionsRead,
            OptionsTotal
        );
    }

    // incorrect version, just do like before..
#endif

    return DhcpEnumOptions(
        ServerAddress,
        ResumeHandle,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );

}


VOID
PrintOptionInfo(
    IN LPDHCP_OPTION OptionInfo
)
{
    #define OPTION_ID_LEN         14
    #define OPTION_ARRAY_TYPE_LEN 14
    #define OPTION_TYPE_LEN       20
    #define BUFFER_LEN            20
    #define OPTION_NAME_LEN       50

    WCHAR  wcOptionID[ OPTION_ID_LEN ];
    WCHAR  wcArrayType[ OPTION_ARRAY_TYPE_LEN ];
    WCHAR  wcOptionType[ OPTION_TYPE_LEN ];
    WCHAR  Buffer[ BUFFER_LEN ];
    WCHAR  wcOptionName[  OPTION_NAME_LEN ];

    DWORD  dwLen = 0, dw = 0;
    
    if( OptionInfo is NULL )
        return;

    wsprintf( wcOptionID, L"   %s   ", _itow((int)OptionInfo->OptionID, Buffer, 10) );
    
    dwLen = wcslen(wcOptionID);
    
    for(dw = dwLen; dw < OPTION_ID_LEN ; dw++ )
    {
        wcOptionID[dw] = L' ';
    }
    wcOptionID[ OPTION_ID_LEN - 1 ] = L'\0';

    wcscpy(wcOptionName, L" ");

    wcsncat(wcOptionName, 
            OptionInfo->OptionName, 
            (( OPTION_NAME_LEN - 1 ) < wcslen(OptionInfo->OptionName) ) ?
	    ( OPTION_NAME_LEN - 1 ) : wcslen(OptionInfo->OptionName));
    
    dwLen = wcslen(wcOptionName);
    
    if ( dwLen < OPTION_NAME_LEN ) {
	for(dw = dwLen; dw < OPTION_NAME_LEN ; dw++ ) {
		wcOptionName[dw] = L' ';
	}
    }
    wcOptionName[ OPTION_NAME_LEN - 1 ] = L'\0';

    if( OptionInfo->OptionType is DhcpUnaryElementTypeOption )
    {
        wsprintf(wcArrayType, L"%s", L"    UNARY    ");
    }
    else if( OptionInfo->OptionType is DhcpArrayTypeOption )
    {
        wsprintf(wcArrayType, L"%s", L"    ARRAY    ");
    }
    else
    {
        wsprintf(wcArrayType, L"%s", L"    UNKNOWN  ");
    }

    wcOptionType[ OPTION_TYPE_LEN - 1 ] = L'\0';

    if( OptionInfo->DefaultValue.NumElements ) {
	dw = OptionInfo->DefaultValue.Elements[ 0 ].OptionType;
	wsprintf( wcOptionType, L"  %s", TagOptionType[ dw ].pwcTag );
    }

    DisplayMessage(g_hModule, 
                   MSG_SRVR_OPTIONDEF_INFO,
                   wcOptionID,
                   wcOptionName,
                   wcArrayType,
                   wcOptionType);

} // PrintOptionInfo()

VOID
PrintOptionValue(
    IN LPDHCP_OPTION_DATA OptionValue
)
{
    DWORD NumElements;
    DHCP_OPTION_DATA_TYPE OptionType;
    DWORD i;

    if( OptionValue is NULL )
        return;

    DisplayMessage(g_hModule, MSG_SRVR_OPTION);
    NumElements = OptionValue->NumElements;

    DisplayMessage(g_hModule, 
                   MSG_SRVR_OPTION_COUNT, 
                   NumElements );

    if( NumElements == 0 ) {
        return;
    }

    OptionType = OptionValue->Elements[0].OptionType;

    DisplayMessage( g_hModule, MSG_SRVR_OPTION_TYPE,
		    TagOptionType[ OptionType ].pwcTag );

    if( OptionType is DhcpBinaryDataOption )
    {
        DisplayMessage(g_hModule, MSG_SRVR_OPTION_TYPE, L"BINARY");
    }

    for( i = 0; i < OptionValue->NumElements; i++ ) 
    {
        DhcpAssert( OptionType == OptionValue->Elements[i].OptionType );

        DisplayMessage(g_hModule, 
                       MSG_SRVR_OPTION_VALUE);

        switch( OptionType ) {
        case DhcpByteOption:
            DisplayMessage(g_hModule, 
                           MSG_SRVR_OPTION_VALUE_NUM, 
                           (DWORD)OptionValue->Elements[i].Element.ByteOption );
            break;

        case DhcpWordOption:
            DisplayMessage(g_hModule, 
                           MSG_SRVR_OPTION_VALUE_NUM, 
                           (DWORD)OptionValue->Elements[i].Element.WordOption );
            break;

        case DhcpDWordOption:
            DisplayMessage(g_hModule, 
                           MSG_SRVR_OPTION_VALUE_NUM,
                           OptionValue->Elements[i].Element.DWordOption );
            break;

        case DhcpDWordDWordOption:
            DisplayMessage(g_hModule, 
                           MSG_SRVR_OPTION_VALUE_LONGNUM,
                           OptionValue->Elements[i].Element.DWordDWordOption.DWord1,
                           OptionValue->Elements[i].Element.DWordDWordOption.DWord2 );

            break;

        case DhcpIpAddressOption:
            DisplayMessage(g_hModule, 
                           MSG_SRVR_OPTION_VALUE_STRING,
                           IpAddressToString((DWORD)OptionValue->Elements[i].Element.IpAddressOption));
            break;

        case DhcpStringDataOption:
            if( *OptionValue->Elements[i].Element.StringDataOption ) {
                DisplayMessage(g_hModule, 
                               MSG_SRVR_OPTION_VALUE_STRING,
                               OptionValue->Elements[i].Element.StringDataOption );
            }
            
            break;

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption: 
            {
                DWORD j;
                DWORD Length;

                Length = OptionValue->Elements[i].Element.BinaryDataOption.DataLength;
                for( j = 0; j < Length; j++ ) {
                    DisplayMessage(g_hModule, 
                                   MSG_SRVR_OPTION_VALUE_BINARY,
                                   OptionValue->Elements[i].Element.BinaryDataOption.Data[j] );
                }
                DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                break;
            }
        default:
            DisplayMessage(g_hModule, MSG_SRVR_OPTION_TYPE_UNKNOWN);
            break;
        }
    }
}

DWORD
PrintAllOptionValues(
    IN LPDHCP_ALL_OPTION_VALUES OptValues
)
{
    DWORD    i, dwCount = 0;
    BOOL     fUser = FALSE,
             fVendor = FALSE;
    for( i = 0; i < OptValues->NumElements ; i ++ ) 
    {

        if( OptValues->Options[i].OptionsArray is NULL )
        {
            continue;
        }
        if( OptValues->Options[i].IsVendor ) 
        {
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
            DisplayMessage(g_hModule, MSG_SRVR_CLASS_VENDOR, CHKNULL(OptValues->Options[i].VendorName));
            fVendor = TRUE;
        }
        if( OptValues->Options[i].ClassName ) 
        {
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
            DisplayMessage(g_hModule, MSG_SRVR_CLASS_USER, OptValues->Options[i].ClassName);
            fUser = TRUE;
        }
        else if ( fVendor is FALSE )
        {
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
            DisplayMessage(g_hModule, MSG_SRVR_STANDARD_OPTION);
        }

        if( fUser is FALSE and
            fVendor is FALSE )
        {
            DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
            DisplayMessage(g_hModule, MSG_SRVR_CLASS_NONE);
        }
        PrintOptionValuesArray(OptValues->Options[i].OptionsArray);
        dwCount++;
    }
    return dwCount;
}


DWORD
PrintUserOptionValues(
    IN LPDHCP_ALL_OPTION_VALUES OptValues,
    IN LPWSTR                   pwcUser,
    IN LPWSTR                   pwcVendor
)
{
    DWORD    i,
             dwCount = 0;
    BOOL     fUser = FALSE,
             fVendor = FALSE;

    for( i = 0; i < OptValues->NumElements; i++ ) 
    {
        if( OptValues->Options[i].OptionsArray is NULL )
        {
            continue;
        }
        if( pwcVendor is NULL )
        {
            if( OptValues->Options[i].ClassName isnot NULL and
                ( _wcsicmp(OptValues->Options[i].ClassName, pwcUser) is 0 ) and
                OptValues->Options[i].IsVendor is FALSE )
            {
           
                DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                if( fUser is FALSE )
                {
                    DisplayMessage(g_hModule, MSG_SRVR_STANDARD_OPTION);
                    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                    DisplayMessage(g_hModule, MSG_SRVR_CLASS_USER, OptValues->Options[i].ClassName);
                    fUser = TRUE;
                }
                PrintOptionValuesArray(OptValues->Options[i].OptionsArray);
                dwCount+=OptValues->Options[i].OptionsArray->NumElements;
            }
        }
        else
        {
            if( pwcUser )
            {
                if( OptValues->Options[i].ClassName and
                    ( _wcsicmp(OptValues->Options[i].ClassName, pwcUser) is 0 ) and
                    OptValues->Options[i].VendorName isnot NULL and
                    ( _wcsicmp(OptValues->Options[i].VendorName, pwcVendor) is 0 )and
                    OptValues->Options[i].IsVendor is TRUE )
                {

                    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                    if( fUser is FALSE )
                    {
                        DisplayMessage(g_hModule, MSG_SRVR_CLASS_VENDOR, CHKNULL(OptValues->Options[i].VendorName));
                        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                        DisplayMessage(g_hModule, MSG_SRVR_CLASS_USER, OptValues->Options[i].ClassName);
                        fUser = TRUE;
                    }
                    PrintOptionValuesArray(OptValues->Options[i].OptionsArray);
                    dwCount+=OptValues->Options[i].OptionsArray->NumElements;
                }
            }
            else
            {
                if( OptValues->Options[i].VendorName isnot NULL and
                    ( _wcsicmp(OptValues->Options[i].VendorName, pwcVendor) is 0 ) and
                    OptValues->Options[i].IsVendor is TRUE )
                {
                    DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                    if( fUser is FALSE )
                    {
                        DisplayMessage(g_hModule, MSG_SRVR_CLASS_VENDOR, CHKNULL(OptValues->Options[i].VendorName));
                        DisplayMessage(g_hModule, MSG_DHCP_FORMAT_LINE);
                        fUser = TRUE;
                    }
                    if( OptValues->Options[i].ClassName )
                    {
                        DisplayMessage(g_hModule, MSG_SRVR_CLASS_USER, OptValues->Options[i].ClassName);
                    }
                    PrintOptionValuesArray(OptValues->Options[i].OptionsArray);
                    dwCount+=OptValues->Options[i].OptionsArray->NumElements;
                }
            }
        }
    }

    return dwCount;
                   
}

VOID
PrintOptionArray(
    IN LPDHCP_OPTION_ARRAY    OptArray
)
{
    DWORD    i;

    if( OptArray is NULL )
        return;

    for( i = 0; i < OptArray->NumElements ; i ++ ) {
        PrintOptionInfo( &OptArray->Options[i] );
    }
}

VOID
PrintAllOptions(
    IN      LPDHCP_ALL_OPTIONS     Options
)
{
    DWORD                          i =0;

    if( Options is NULL )
        return;

    DisplayMessage(g_hModule, MSG_SRVR_OPTION_NONVENDOR);
    DisplayMessage(g_hModule, MSG_SRVR_OPTIONDEF_TABLE);



    PrintOptionArray(Options->NonVendorOptions);

    for( i = 0; i < Options->NumVendorOptions; i ++ ) 
    {
        if( i>0 )
        {
            if( wcscmp(CHKNULL(Options->VendorOptions[i-1].VendorName), CHKNULL(Options->VendorOptions[i].VendorName)) )
            {
                DisplayMessage(g_hModule, MSG_SRVR_OPTION_VENDOR, CHKNULL(Options->VendorOptions[i].VendorName));
                DisplayMessage(g_hModule, MSG_SRVR_OPTIONDEF_TABLE);
            }
        }
        else
        {
            DisplayMessage(g_hModule, MSG_SRVR_OPTION_VENDOR, CHKNULL(Options->VendorOptions[i].VendorName));
            DisplayMessage(g_hModule, MSG_SRVR_OPTIONDEF_TABLE);
        }
        PrintOptionInfo(&(Options->VendorOptions[i].Option));
    }

}



VOID
PrintOptionValue1(
    IN LPDHCP_OPTION_VALUE    OptVal
)
{
    if( OptVal is NULL )
        return;
    DisplayMessage(g_hModule, MSG_SRVR_OPTION_ID, OptVal->OptionID);

    PrintOptionValue(&OptVal->Value);
}

VOID
PrintOptionValuesArray(
    IN LPDHCP_OPTION_VALUE_ARRAY OptValArray
)
{
    DWORD    i;

    if( NULL == OptValArray ) 
        return;
    for( i = 0; i < OptValArray->NumElements ; i ++ ) {
        PrintOptionValue1( &OptValArray->Values[i] );
    }
}

DWORD
SetOptionValue(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
)
{
       
#ifdef NT5

    if( g_dwMajorVersion >= CLASS_ID_VERSION ) 
    {

        return DhcpSetOptionValueV5(
            ServerAddress,
            Flags,
            OptionId,
            ClassName,
            VendorName,
            ScopeInfo,
            OptionValue
        );
    }

#endif

    return DhcpSetOptionValue(
        ServerAddress,
        OptionId,
        ScopeInfo,
        OptionValue
    );
    
}

VOID
PrintDhcpAttrib(                                  // print a server attrib
    LPDHCP_ATTRIB ServerAttrib
)
{
    LPWSTR      pwszAttrib = NULL;
    BOOL        AttribBool = ServerAttrib->DhcpAttribBool;

    if( NULL == ServerAttrib ) 
        return;

    switch(ServerAttrib->DhcpAttribId )
    {
    case DHCP_ATTRIB_BOOL_IS_ROGUE:
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_SERVER_ATTRIB_ISROUGE);
            AttribBool = !AttribBool;
            break;
        }
    case DHCP_ATTRIB_BOOL_IS_DYNBOOTP:
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_SERVER_ATTRIB_ISDYNBOOTP);
            break;
        }
    case DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC:
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_SERVER_ATTRIB_ISPARTDSDC);
            break;
        }
    case DHCP_ATTRIB_BOOL_IS_BINDING_AWARE:
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_SERVER_ATTRIB_ISBINDING);
            break;
        }
    case DHCP_ATTRIB_BOOL_IS_ADMIN:
    default:
        {
            DisplayMessage(g_hModule,
                           MSG_SRVR_SERVER_ATTRIB_ISADMIN);
            break;
        }
    }

    switch( ServerAttrib->DhcpAttribType ) 
    {
    case DHCP_ATTRIB_TYPE_BOOL :
        if( AttribBool )
        {
            DisplayMessage(g_hModule, MSG_SRVR_TRUE);
        }
        else
        {
            DisplayMessage(g_hModule, 
                           MSG_SRVR_FALSE);
        }
        break;
    case DHCP_ATTRIB_TYPE_ULONG:
        DisplayMessage(g_hModule, MSG_SRVR_SERVER_ATTRIB_TYPE_ULONG, ServerAttrib->DhcpAttribUlong);
        break;
    default:
        DisplayMessage(g_hModule, EMSG_SRVR_UNKNOWN_SERVER_ATTRIB);
        break;
    }
}


DWORD
SetOptionDataTypeArray(
    DHCP_OPTION_DATA_TYPE OptionType,
    LPTSTR                *OptionValues,
    DWORD                 dwStartCount, //first optionvalue = dwStartCount 
    DWORD                 dwEndCount, //last optionvalue = dwEndCount - 1
    LPDHCP_OPTION_DATA  pOptionData
)
{
    LPDHCP_OPTION_DATA_ELEMENT  lpElemArray = NULL;
    DWORD                       i = 0, dwCount=0;
    
    if( pOptionData is NULL )
        return ERROR_INVALID_PARAMETER;

    while( FALSE is IsBadStringPtr(OptionValues[dwStartCount+i], MAX_STRING_LEN) and
           dwStartCount + i < dwEndCount )
    {
        if( wcslen(OptionValues[dwStartCount+i]) is 0 )
            break;
        i++;
    }

    pOptionData->NumElements = i;

    pOptionData->Elements = DhcpAllocateMemory(pOptionData->NumElements*sizeof(DHCP_OPTION_DATA_ELEMENT));

    if( pOptionData->Elements is NULL )
        return ERROR_OUT_OF_MEMORY;

      
    switch(OptionType)
    {
    case DhcpByteOption:
        {
            for( i = 0; i < pOptionData->NumElements; i++ )
            {
                if( IsPureHex(OptionValues[dwStartCount+i]) is FALSE )
                {
                    return ERROR_INVALID_PARAMETER;
                }
                pOptionData->Elements[i].OptionType = OptionType;
                pOptionData->Elements[i].Element.ByteOption = (BYTE)STRTOUL(OptionValues[dwStartCount+i], NULL, 16);
            }
            break;
        }
    case DhcpWordOption:
        {
            for( i = 0; i < pOptionData->NumElements; i++ )
            {
                pOptionData->Elements[i].OptionType = OptionType;
                if( FALSE is IsPureNumeric(OptionValues[dwStartCount+i]) )
                {
                    return ERROR_INVALID_PARAMETER;
                }
                pOptionData->Elements[i].Element.WordOption = (WORD)STRTOUL(OptionValues[dwStartCount+i], NULL, 10);
            }
            break;
        }
    case DhcpDWordOption:
        {
            for( i = 0; i < pOptionData->NumElements; i++ )
            {
                pOptionData->Elements[i].OptionType = OptionType;
                
                if( FALSE is IsPureNumeric(OptionValues[dwStartCount+i]) )
                {
                    return ERROR_INVALID_PARAMETER;
                }

                pOptionData->Elements[i].Element.DWordOption = (DWORD)STRTOUL(OptionValues[dwStartCount+i], NULL, 10);
            }
            break;
        }
    case DhcpStringDataOption:
        {
            for( i = 0; i < pOptionData->NumElements; i++ )
            {
                pOptionData->Elements[i].OptionType = OptionType;
                pOptionData->Elements[i].Element.StringDataOption = OptionValues[dwStartCount+i];
            }
            break;
        }
    case DhcpIpAddressOption:
        {
            DWORD   dwIp = 0;
            for( i = 0; i < pOptionData->NumElements; i++ )
            {
                pOptionData->Elements[i].OptionType = OptionType;
                dwIp = StringToIpAddress(OptionValues[dwStartCount+i]);
                if( dwIp is INADDR_NONE )
                {
                    return ERROR_INVALID_PARAMETER;
                }

                pOptionData->Elements[i].Element.IpAddressOption = StringToIpAddress(OptionValues[dwStartCount+i]);
            }
            break;
        }
    default:
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    return NO_ERROR;

}



DWORD
ShowOptionValues4(
    IN      LPWSTR                      pwszIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO    ScopeInfo,
    IN      LPDWORD                     pdwCount
)
{
    DWORD                       Error = NO_ERROR;
    LPDHCP_OPTION_ARRAY         OptionsArray = NULL;
    LPDHCP_ALL_OPTION_VALUES    OptionValues = NULL;
    LPDHCP_OPTION_VALUE         OptionValue = NULL;
    DHCP_RESUME_HANDLE          ResumeHandle = 0;
    DWORD                       nRead = 0,
                                dwCount = 0,
                                nTotal = 0,
                                dw = 0;

    *pdwCount = 0;

    while(TRUE)
    {
         Error = DhcpEnumOptions(
                        pwszIpAddress,
                        &ResumeHandle,
                        ~0,
                        &OptionsArray,
                        &nRead,
                        &nTotal);
    
        if( Error is ERROR_NO_MORE_ITEMS )
        {
            Error = NO_ERROR;
            break;
        }

        if( Error isnot NO_ERROR  &&
            Error isnot ERROR_MORE_DATA )
            goto Return;

        for( dw = 0; dw < nRead; dw++ )
        {
            DHCP_OPTION_ID OptionId = OptionsArray->Options[dw].OptionID;
            DWORD          dwError = NO_ERROR;
            dwError = DhcpGetOptionValue(
                                         pwszIpAddress,
                                         OptionId,
                                         ScopeInfo,
                                         &OptionValue);
                           
            if( dwError isnot NO_ERROR )
            {
                continue;
            }
    
            if( OptionValue )
            {
                PrintOptionValue1(OptionValue);
                dwCount++;
                DhcpRpcFreeMemory(OptionValue);
                OptionValue = NULL;
            }
        }

        if( OptionsArray )
        {
            DhcpRpcFreeMemory(OptionsArray);
            OptionsArray = NULL;
        }

        if( Error is NO_ERROR )
            break;
        else
            continue;
    }
Return:
    *pdwCount = dwCount;
    return Error;
}


//
// Need to support these routines for displaying error messages ..
//

VOID
DhcpEximErrorClassConflicts(
    IN LPWSTR SvcClass,
    IN LPWSTR ConfigClass
    )
{
    DisplayMessage(
        g_hModule,
        MSG_SRVR_IMPORT_CLASS_CONFLICT,
        SvcClass, ConfigClass );
}        

VOID
DhcpEximErrorOptdefConflicts(
    IN LPWSTR SvcOptdef,
    IN LPWSTR ConfigOptdef
    )
{
    DisplayMessage(
        g_hModule,
        MSG_SRVR_IMPORT_OPTDEF_CONFLICT,
        SvcOptdef, ConfigOptdef );
}        

VOID
DhcpEximErrorOptionConflits(
    IN LPWSTR SubnetName OPTIONAL,
    IN LPWSTR ResAddress OPTIONAL,
    IN LPWSTR OptId,
    IN LPWSTR UserClass OPTIONAL,
    IN LPWSTR VendorClass OPTIONAL
    )
{
    DWORD MsgId;
    
    if( NULL == SubnetName ) {
        MsgId = MSG_SRVR_IMPORT_OPTION_CONFLICT;
    } else if( NULL == ResAddress ) {
        MsgId = MSG_SRVR_IMPORT_SUBNET_OPTION_CONFLICT;
    } else {
        MsgId = MSG_SRVR_IMPORT_RES_OPTION_CONFLICT;
    }

    if( NULL == UserClass ) UserClass = L"";
    if( NULL == VendorClass ) VendorClass = L"";
    
    DisplayMessage(
        g_hModule,
        MsgId, OptId, UserClass, VendorClass, SubnetName,
        ResAddress );
}        

VOID
DhcpEximErrorSubnetNotFound(
    IN LPWSTR SubnetAddress
    )
{
    DisplayMessage(
        g_hModule,
        MSG_SRVR_EXPORT_SUBNET_NOT_FOUND, SubnetAddress );
}        

VOID
DhcpEximErrorSubnetAlreadyPresent(
    IN LPWSTR SubnetAddress,
    IN LPWSTR SubnetName OPTIONAL
    )
{
    if( NULL == SubnetName ) SubnetName = L"";
    DisplayMessage(
        g_hModule,
        MSG_SRVR_IMPORT_SUBNET_CONFLICT,
        SubnetAddress, SubnetName );
}        

VOID
DhcpEximErrorDatabaseEntryFailed(
    IN LPWSTR ClientAddress,
    IN LPWSTR ClientHwAddress,
    IN DWORD Error,
    OUT BOOL *fAbort
    )
{
    WCHAR ErrStr[30];

    wsprintf(ErrStr, L"%ld", Error );

    (*fAbort) = FALSE; // continue on errors
    DisplayMessage(
        g_hModule,
        MSG_SRVR_IMPORT_DBENTRY_CONFLICT,
        ClientAddress, ClientHwAddress, ErrStr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\dhcphandle.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
FN_HANDLE_CMD   HandleDhcpList;
FN_HANDLE_CMD   HandleDhcpHelp;

FN_HANDLE_CMD   HandleDhcpContexts;

FN_HANDLE_CMD   HandleDhcpDump;

FN_HANDLE_CMD   HandleDhcpAddServer;

//FN_HANDLE_CMD   HandleDhcpAddHelper;


FN_HANDLE_CMD   HandleDhcpDeleteServer;

//FN_HANDLE_CMD   HandleDhcpDeleteHelper;


FN_HANDLE_CMD   HandleDhcpShowServer;

//FN_HANDLE_CMD   HandleDhcpShowHelper;

DWORD
CreateDumpFile(
    IN  PWCHAR  pwszName,
    OUT PHANDLE phFile
);

VOID
CloseDumpFile(
    HANDLE  hFile
);


// print server information
VOID
PrintServerInfo(
    LPDHCP_SERVER_INFO  Server
);



VOID
PrintServerInfoArray(
    LPDHCP_SERVER_INFO_ARRAY Servers
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\dhcpmon.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.h

Abstract:

    DHCP Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/



extern HANDLE   g_hModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;

extern ULONG    g_ulInitCount;
extern ULONG    g_ulNumTopCmds;
extern ULONG    g_ulNumGroups;

extern LPWSTR  g_pwszServer;
extern LPSTR   g_ServerNameAnsi;
extern WCHAR   g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR    g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR   g_ScopeIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR    g_ScopeIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern LPWSTR  g_MScopeNameUnicodeString;
extern LPSTR   g_MScopeNameAnsiString;

extern LPWSTR  g_UserClass;
extern BOOL    g_fUserClass;
extern LPWSTR  g_VendorClass;
extern BOOL    g_fIsVendor;

DWORD
WINAPI
DhcpCommit(
    IN  DWORD   dwAction
);

BOOL 
WINAPI
DhcpDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
);

NS_CONTEXT_ENTRY_FN DhcpMonitor;

DWORD
WINAPI
DhcpUnInit(
    IN  DWORD   dwReserved
);

BOOL
SetServerInfo(
    IN  LPCWSTR  pwszServerInfo
);

BOOL
IsHelpToken(
    PWCHAR  pwszToken
);

BOOL
IsReservedKeyWord(
    PWCHAR  pwszToken
);

DWORD
DisplayErrorMessage(
    HANDLE  hModule,
    DWORD   dwMsgID,
    DWORD   dwErrID,
    ...
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\scopehndl.h ===
#ifndef _MSCOPEHNDL_H_
#define _MSCOPEHNDL_H_

FN_HANDLE_CMD HandleScopeList;
FN_HANDLE_CMD HandleScopeHelp;
FN_HANDLE_CMD HandleScopeContexts;
FN_HANDLE_CMD HandleScopeDump;

FN_HANDLE_CMD HandleScopeAddIprange;
FN_HANDLE_CMD HandleScopeAddExcluderange;
FN_HANDLE_CMD HandleScopeAddReservedip;

FN_HANDLE_CMD HandleScopeCheckDatabase;

FN_HANDLE_CMD HandleScopeDeleteIprange;
FN_HANDLE_CMD HandleScopeDeleteExcluderange;
FN_HANDLE_CMD HandleScopeDeleteReservedip;
FN_HANDLE_CMD HandleScopeDeleteOptionvalue;
FN_HANDLE_CMD HandleScopeDeleteReservedoptionvalue;

FN_HANDLE_CMD HandleScopeSetState;
FN_HANDLE_CMD HandleScopeSetScope;
FN_HANDLE_CMD HandleScopeSetOptionvalue;
FN_HANDLE_CMD HandleScopeSetReservedoptionvalue;
FN_HANDLE_CMD HandleScopeSetName;
FN_HANDLE_CMD HandleScopeSetComment;
FN_HANDLE_CMD HandleScopeSetSuperscope;

FN_HANDLE_CMD HandleScopeShowClients;
FN_HANDLE_CMD HandleScopeShowClientsv5;
FN_HANDLE_CMD HandleScopeShowIprange;
FN_HANDLE_CMD HandleScopeShowExcluderange;
FN_HANDLE_CMD HandleScopeShowReservedip;
FN_HANDLE_CMD HandleScopeShowOptionvalue;
FN_HANDLE_CMD HandleScopeShowReservedoptionvalue;
FN_HANDLE_CMD HandleScopeShowState;
FN_HANDLE_CMD HandleScopeShowMibinfo;
FN_HANDLE_CMD HandleScopeShowScope;

DWORD
ProcessBootpParameters(
    DWORD                    cArgs,
    LPTSTR                   *ppszArgs,
    DHCP_IP_RESERVATION_V4   *pReservation
);

DWORD
RemoveOptionValue(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
);

VOID
PrintRange(
    DHCP_SUBNET_ELEMENT_TYPE Type,
    DHCP_IP_ADDRESS Start,
    DHCP_IP_ADDRESS End,
    ULONG BootpAllocated,
    ULONG MaxBootpAllowed,
    BOOL  fExclude
);


VOID
PrintClientInfo(
    LPDHCP_CLIENT_INFO_V4 ClientInfo,
    DWORD Level
);

#ifdef NT5
VOID
PrintClientInfoV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
);

VOID
PrintClientInfoShortV5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
);

VOID
PrintClientInfoShort1V5(
    LPDHCP_CLIENT_INFO_V5 ClientInfo
);
#endif //NT5


VOID
PrintClientInfoShort(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
);


VOID
PrintClientInfoShort1(
    LPDHCP_CLIENT_INFO_V4 ClientInfo
);
#endif //_SCOPEHNDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\scopemon.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.h

Abstract:

    DHCP Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/


#define MAX_IP_STRING_LEN   15

extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern BOOL     g_fScope;
extern PWCHAR   g_pwszServer;
extern DWORD    g_dwMajorVersion;
extern DWORD    g_dwMinorVersion;
extern DHCP_IP_ADDRESS g_ServerIpAddress;
extern ULONG    g_ulInitCount;
extern ULONG    g_ulNumTopCmds;
extern ULONG    g_ulNumGroups;

extern CHAR   g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR   g_ScopeIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ScopeIpAddressUnicodeString[MAX_IP_STRING_LEN+1];

DHCP_IP_ADDRESS g_ScopeIpAddress;


DWORD
WINAPI
ScopeCommit(
    IN  DWORD   dwAction
);

NS_CONTEXT_ENTRY_FN ScopeMonitor;


DWORD
WINAPI
ScopeUnInit(
    IN  DWORD   dwReserved
);

BOOL
SetScopeInfo(
    IN  LPWSTR  pwszScope
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\dhcpmgr.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
#ifndef _DHCPMGR_H_
#define _DHCPMGR_H_


#define MAX_MSG_LENGTH  5120

#define MAX_HELPER_NAME MAX_DLL_NAME
#define MAX_NAME_LEN    MAX_DLL_NAME
#define MAX_ENTRY_PT_NAME MAX_DLL_NAME

#if 0

typedef struct _DHCPMON_ATTRIBUTES
{
    //Major version of the server
    DWORD                   dwMajorVersion; 
    //Minor version of the server
    DWORD                   dwMinorVersion; 
    //NetShell attributes
    NETSH_ATTRIBUTES        NetshAttrib;    
    //Server IPAddress Unicode String
    WCHAR                   wszServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];   
    //Server IPAddress ANSI String
    CHAR                    szServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
    //ServerNameString in UNICODE
    LPWSTR                  pwszServerUnicodeName;
    //Server IP Address
    DHCP_IP_ADDRESS         ServerIpAddress;
    //This module's handle
    HANDLE                  hParentModule;
    //Handle of DHCPSAPI.DLL if loaded.
    HANDLE                  hDhcpsapiModule;
}DHCPMON_ATTRIBUTES, *PDHCPMON_ATTRIBUTES;

typedef
DWORD
(WINAPI *PDHCPMON_HELPER_INIT_FN)(
    IN  PWCHAR                      pwszRouter,
    IN  PDHCPMON_ATTRIBUTES         pUtilityTable,
    OUT PNS_HELPER_ATTRIBUTES       pHelperTable
);

typedef struct _DHCPMON_HELPER_TABLE_ENTRY
{
    //
    // Name of the helper - this is also the name of the context
    // and the name of the key in the registry
    //

    WCHAR                   pwszHelper[MAX_NAME_LEN];  // Helper Name

    //
    // Name of the DLL servicing the context
    //

    WCHAR                   pwszDLLName[MAX_NAME_LEN]; // Corresponding DLL

    //
    // TRUE if loaded
    //

    BOOL                    bLoaded;                   // In memory or not

    //
    // Handle to DLL instance if loaded
    //

    HANDLE                  hDll;                      // DLL handle if loaded

    //
    // Name of the entry point for the helper
    //

    WCHAR                   pwszInitFnName[MAX_NAME_LEN];  // Entry Fn name

    //
    // Pointers to functions
    //

    PNS_HELPER_UNINIT_FN    pfnUnInitFn;   
    PNS_HELPER_DUMP_FN      pfnDumpFn;     

}DHCPMON_HELPER_TABLE_ENTRY,*PDHCPMON_HELPER_TABLE_ENTRY;

#endif //0


typedef struct _DHCPMON_SUBCONTEXT_TABLE_ENTRY
{
    //
    // Name of the context
    //

    LPWSTR                  pwszContext;
    //
    //Short command help
    DWORD                   dwShortCmdHlpToken;
    
    //Detail command help
    DWORD                   dwCmdHlpToken;

    PNS_CONTEXT_ENTRY_FN    pfnEntryFn;    

}DHCPMON_SUBCONTEXT_TABLE_ENTRY,*PDHCPMON_SUBCONTEXT_TABLE_ENTRY;



#endif //_DHCPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\srvrmon.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.h

Abstract:

    DHCP Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/

#define MAX_OPTION_NAME_LEN         35
#define MAX_OPTION_ID_LEN           14
#define MAX_OPTION_ARRAY_TYPE_LEN   13

extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern BOOL     g_fServer;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;
extern PWCHAR   g_pwszServer;

extern ULONG    g_ulInitCount;
extern ULONG    g_ulNumTopCmds;
extern ULONG    g_ulNumGroups;

extern DWORD    g_dwMajorVersion;
extern DWORD    g_dwMinorVersion;
 
extern CHAR   g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];

extern DWORD  g_dwIPCount;
extern LPWSTR *g_ppServerIPList;

DWORD
WINAPI
SrvrCommit(
    IN  DWORD   dwAction
);

NS_CONTEXT_ENTRY_FN SrvrMonitor;

DWORD
WINAPI
SrvrUnInit(
    IN  DWORD   dwReserved
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\mscopehndl.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
#ifndef _SCOPEHNDL_H_
#define _SCOPEHNDL_H_


FN_HANDLE_CMD HandleMScopeList;
FN_HANDLE_CMD HandleMScopeHelp;
FN_HANDLE_CMD HandleMScopeContexts;
FN_HANDLE_CMD HandleMScopeDump;

FN_HANDLE_CMD HandleMScopeAddIprange;
FN_HANDLE_CMD HandleMScopeAddExcluderange;

FN_HANDLE_CMD HandleMScopeCheckDatabase;

FN_HANDLE_CMD HandleMScopeDeleteIprange;
FN_HANDLE_CMD HandleMScopeDeleteExcluderange;
FN_HANDLE_CMD HandleMScopeDeleteOptionvalue;

FN_HANDLE_CMD HandleMScopeSetName;
FN_HANDLE_CMD HandleMScopeSetComment;
FN_HANDLE_CMD HandleMScopeSetMScope;
FN_HANDLE_CMD HandleMScopeSetState;
FN_HANDLE_CMD HandleMScopeSetOptionvalue;
FN_HANDLE_CMD HandleMScopeSetTTL;
FN_HANDLE_CMD HandleMScopeSetLease;
FN_HANDLE_CMD HandleMScopeSetExpiry;


FN_HANDLE_CMD HandleMScopeShowClients;
FN_HANDLE_CMD HandleMScopeShowIprange;
FN_HANDLE_CMD HandleMScopeShowExcluderange;
FN_HANDLE_CMD HandleMScopeShowMibinfo;
FN_HANDLE_CMD HandleMScopeShowMScope;
FN_HANDLE_CMD HandleMScopeShowOptionvalue;
FN_HANDLE_CMD HandleMScopeShowState;
FN_HANDLE_CMD HandleMScopeShowLease;
FN_HANDLE_CMD HandleMScopeShowTTL;
FN_HANDLE_CMD HandleMScopeShowExpiry;



VOID
PrintMClientInfoShort(
    LPDHCP_MCLIENT_INFO ClientInfo
);

VOID
PrintMClientInfo(
    LPDHCP_MCLIENT_INFO ClientInfo
);

#endif //_SCOPEHNDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\mscopemon.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    Routing\Netsh\dhcp\dhcpmon.h

Abstract:

    DHCP Command dispatcher.

Created by:

    Shubho Bhattacharya(a-sbhatt) on 11/14/98

--*/


#define MAX_IP_STRING_LEN   15

extern HANDLE   g_hModule;
extern HANDLE   g_hParentModule;
extern HANDLE   g_hDhcpsapiModule;
extern BOOL     g_bCommit;
extern BOOL     g_hConnect;
extern BOOL     g_fScope;
extern PWCHAR   g_pwszServer;
extern DWORD    g_dwMajorVersion;
extern DWORD    g_dwMinorVersion;
extern DHCP_IP_ADDRESS g_ServerIpAddress;
extern ULONG    g_ulInitCount;
extern ULONG    g_ulNumTopCmds;
extern ULONG    g_ulNumGroups;

/*
extern CHAR   g_ServerIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ServerIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern CHAR   g_ScopeIpAddressAnsiString[MAX_IP_STRING_LEN+1];
extern WCHAR  g_ScopeIpAddressUnicodeString[MAX_IP_STRING_LEN+1];
extern LPSTR  g_MScopeNameAnsiString;
extern LPWSTR g_MScopeNameUnicodeString;
*/

DWORD       g_dwMScopeID;

DWORD
WINAPI
MScopeCommit(
    IN  DWORD   dwAction
);

NS_CONTEXT_ENTRY_FN MScopeMonitor;

DWORD
WINAPI
MScopeUnInit(
    IN  DWORD   dwReserved
);

BOOL
SetMScopeInfo(
    IN  LPWSTR  pwszMScope
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\netsh\inc\srvrhndl.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
FN_HANDLE_CMD  HandleSrvrList;
FN_HANDLE_CMD  HandleSrvrHelp;
FN_HANDLE_CMD  HandleSrvrContexts;
FN_HANDLE_CMD  HandleSrvrDump;

FN_HANDLE_CMD  HandleSrvrAddClass;
FN_HANDLE_CMD  HandleSrvrAddMscope;
FN_HANDLE_CMD  HandleSrvrAddOptiondef;
FN_HANDLE_CMD  HandleSrvrAddScope;

FN_HANDLE_CMD  HandleSrvrDeleteClass;
FN_HANDLE_CMD  HandleSrvrDeleteMscope;
FN_HANDLE_CMD  HandleSrvrDeleteOptiondef;
FN_HANDLE_CMD  HandleSrvrDeleteOptionvalue;
FN_HANDLE_CMD  HandleSrvrDeleteScope;
FN_HANDLE_CMD  HandleSrvrDeleteSuperscope;
FN_HANDLE_CMD  HandleSrvrDeleteDnsCredentials;

FN_HANDLE_CMD  HandleSrvrRedoAuth;
FN_HANDLE_CMD  HandleSrvrInitiateReconcile;
FN_HANDLE_CMD  HandleSrvrExport;
FN_HANDLE_CMD  HandleSrvrImport;

FN_HANDLE_CMD  HandleSrvrSetBackupinterval;
FN_HANDLE_CMD  HandleSrvrSetBackuppath;
FN_HANDLE_CMD  HandleSrvrSetDatabasecleanupinterval;
FN_HANDLE_CMD  HandleSrvrSetDatabaseloggingflag;
FN_HANDLE_CMD  HandleSrvrSetDatabasename;
FN_HANDLE_CMD  HandleSrvrSetDatabasepath;
FN_HANDLE_CMD  HandleSrvrSetDatabaserestoreflag;
FN_HANDLE_CMD  HandleSrvrSetOptionvalue;
FN_HANDLE_CMD  HandleSrvrSetServer;
FN_HANDLE_CMD  HandleSrvrSetUserclass;
FN_HANDLE_CMD  HandleSrvrSetVendorclass;
FN_HANDLE_CMD  HandleSrvrSetDnsCredentials;
FN_HANDLE_CMD  HandleSrvrSetAuditlog;
FN_HANDLE_CMD  HandleSrvrSetDnsconfig;
FN_HANDLE_CMD  HandleSrvrSetDetectconflictretry;

FN_HANDLE_CMD  HandleSrvrShowAll;
FN_HANDLE_CMD  HandleSrvrShowBindings;
FN_HANDLE_CMD  HandleSrvrShowClass;
FN_HANDLE_CMD  HandleSrvrShowHelper;
FN_HANDLE_CMD  HandleSrvrShowMibinfo;
FN_HANDLE_CMD  HandleSrvrShowMscope;
FN_HANDLE_CMD  HandleSrvrShowOptiondef;
FN_HANDLE_CMD  HandleSrvrShowOptionvalue;
FN_HANDLE_CMD  HandleSrvrShowScope;
FN_HANDLE_CMD  HandleSrvrShowServer;
FN_HANDLE_CMD  HandleSrvrShowServerconfig;
FN_HANDLE_CMD  HandleSrvrShowServerstatus;
FN_HANDLE_CMD  HandleSrvrShowUserclass;
FN_HANDLE_CMD  HandleSrvrShowVendorclass;
FN_HANDLE_CMD  HandleSrvrShowDnsCredentials;
FN_HANDLE_CMD  HandleSrvrShowVersion;
FN_HANDLE_CMD  HandleSrvrShowAuditlog;
FN_HANDLE_CMD  HandleSrvrShowDnsconfig;
FN_HANDLE_CMD  HandleSrvrShowDetectconflictretry;

DWORD
CreateDumpFile(
    IN  PWCHAR  pwszName,
    OUT PHANDLE phFile
);

VOID
CloseDumpFile(
    HANDLE  hFile
);

DWORD
SrvrDottedStringToIpAddressW(
    LPWSTR pwszString
);

LPWSTR
SrvrIpAddressToDottedStringW(
    DWORD   IpAddress
);


VOID
PrintClassInfo(                                   // print info on a single class
    LPDHCP_CLASS_INFO   Class
);

VOID
PrintClassInfoArray(                              // print array of classes
    LPDHCP_CLASS_INFO_ARRAY Classes
);

DWORD
SetOptionDataType(
    DHCP_OPTION_DATA_TYPE       OptionType,
    LPTSTR                      OptionValueString,
    LPDHCP_OPTION_DATA_ELEMENT  OptionData,
    LPWSTR                      *UnicodeOptionValueString
);

DWORD
SetOptionDataTypeArray(
    DHCP_OPTION_DATA_TYPE OptionType,
    LPTSTR              *OptionValues,
    DWORD               dwStartCount, //first optionvalue = dwStartCount 
    DWORD               dwEndCount, //last optionvalue = dwEndCount - 1
    LPDHCP_OPTION_DATA  pOptionData
);

DWORD
_EnumOptions(
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
);

VOID
PrintOptionInfo(
    IN LPDHCP_OPTION OptionInfo
);

VOID
PrintOptionValue(
    IN LPDHCP_OPTION_DATA OptionValue
);

DWORD
PrintAllOptionValues(
    IN LPDHCP_ALL_OPTION_VALUES OptValues
);

DWORD
PrintUserOptionValues(
    IN LPDHCP_ALL_OPTION_VALUES OptValues,
    IN LPWSTR                   pwcUser,
    IN LPWSTR                   pwcVendor
);

VOID
PrintOptionValuesArray(
    IN LPDHCP_OPTION_VALUE_ARRAY OptValArray
);

VOID
PrintOptionArray(
    IN LPDHCP_OPTION_ARRAY    OptArray
);

VOID
PrintOptionValue1(
    IN LPDHCP_OPTION_VALUE    OptVal
);

VOID
PrintAllOptions(
    IN      LPDHCP_ALL_OPTIONS     Options
);

DWORD
SetOptionValue(
    IN      LPWSTR                      ServerAddress,
    IN      DWORD                       Flags,
    IN      DHCP_OPTION_ID              OptionId,
    IN      LPWSTR                      ClassName,
    IN      LPWSTR                      VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO    ScopeInfo,
    IN      LPDHCP_OPTION_DATA          OptionValue
);

DWORD
ShowOptionValues4(
    IN      LPWSTR                      pwszServer,
    IN      LPDHCP_OPTION_SCOPE_INFO    ScopeInfo,
    IN      LPDWORD                     pdwCount
);

VOID
PrintDhcpAttrib(                                  // print a server attrib
    LPDHCP_ATTRIB ServerAttrib
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\binl.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    binl.h

Abstract:

    This file is the central include file for the BINL service.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

//
//  NT public header files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <winsock2.h>
#include <align.h>
#include <dsgetdc.h>
#include <winldap.h>
#include <dsrole.h>
#include <rpc.h>
#include <ntdsapi.h>

#include <lm.h>
#include <security.h>   // General definition of a Security Support Provider
#include <spseal.h>
#include <userenv.h>
#include <setupapi.h>

//
// C Runtime library includes.
//

#include <stdlib.h>
#include <stdio.h>
#include <shlwapi.h>    // shell team special string manipulators

//
// tcp services control hander file
//

#include <tcpsvcs.h>

//
//  Local header files
//

#include <dhcp.h>
#include <dhcplib.h>
#include <dhcpbinl.h>
#include <dhcprog.h>
#include <oscpkt.h>
#include <dnsapi.h>
#include <remboot.h>

#include "binldef.h"
#include "osc.h"
#include "netinf.h"
#include "global.h"
#include "debug.h"
#include "binlmsg.h"
#include "proto.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\cache.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cache.c

Abstract:

    This module contains the code to cache BINL client information across
    requests for the BINL server.

Author:

    Andy Herron (andyhe)  5-Mar-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

ULONG BinlCacheCount = 0;
ULONG BinlCacheEntriesInUse = 0;

VOID
BinlFreeCacheEntry (
    PMACHINE_INFO CacheEntry
    );

DWORD
BinlCreateOrFindCacheEntry (
    PCHAR Guid,
    BOOLEAN CreateIfNotExist,
    PMACHINE_INFO *CacheEntry
    )
//
//  This searches the list of cached entries for the matching GUID.  If it is
//  found and is in use, we return an error as another thread is working on
//  the same request.  If it is found and not in use, we mark it in use and
//  return it.  If it is not found, we add it and return it.
//
{
    PLIST_ENTRY listEntry;
    PMACHINE_INFO currentEntry = NULL;
    DWORD expireTickCount;

    EnterCriticalSection( &BinlCacheListLock );

    //
    //  For now, we don't bother with a scavenger thread.  Just free them up
    //  as we come across them.
    //

    if (BinlCacheExpireMilliseconds > 0) {

        expireTickCount = GetTickCount() - BinlCacheExpireMilliseconds;

    } else {

        expireTickCount = 0;
    }

    if (BinlCurrentState == BINL_STOPPED) {

        //
        //  if we're in the midst of shutting down, ignore the request.  We
        //  do the check while holding the lock to synchronize with any thread
        //  calling BinlCloseCache.
        //

        LeaveCriticalSection( &BinlCacheListLock );
        *CacheEntry = NULL;

        //
        //  We return the EVENT_SERVER_SHUTDOWN to tell the calling thread
        //  not to bother with this request.
        //

        return EVENT_SERVER_SHUTDOWN;
    }

    listEntry = BinlCacheList.Flink;

    while ( listEntry != &BinlCacheList ) {

        LONG isEqual;

        currentEntry = (PMACHINE_INFO) CONTAINING_RECORD(
                                            listEntry,
                                            MACHINE_INFO,
                                            CacheListEntry );

        //
        //  lazy free.. check to see if we should free this entry because
        //  it's time to live has expired.
        //

        if ((currentEntry->InProgress == FALSE) &&
            (expireTickCount > 0) &&
            (currentEntry->TimeCreated < expireTickCount)) {

            listEntry = listEntry->Flink;
            BinlFreeCacheEntry( currentEntry );

            BinlPrintDbg((DEBUG_BINL_CACHE, "removed cache entry %x", currentEntry ));
            continue;
        }

        //
        // search for the given guid.  The list is sorted by GUID so when
        // we hit a guid that is greater than current, we stop searching.
        //

        isEqual = memcmp( Guid, currentEntry->Guid, BINL_GUID_LENGTH );

        if (isEqual < 0) {

            listEntry = listEntry->Flink;
            continue;
        }

        if (isEqual == 0) {

            DWORD rc = ERROR_SUCCESS;

            //
            //  If another thread is using this entry, then we should ignore
            //  the request we're currently working on as the other thread will
            //  respond.

            if (currentEntry->InProgress == TRUE) {

                LeaveCriticalSection( &BinlCacheListLock );
                *CacheEntry = NULL;
                return ERROR_BINL_CLIENT_EXISTS;
            }

            //
            //  Also, if the entry is not ours to handle, then we return the
            //  error here.  We don't return ERROR_BINL_INVALID_BINL_CLIENT
            //  because that will tell GetBootParameters to process it as a
            //  new client.  Instead, we return ERROR_BINL_CLIENT_EXISTS so
            //  that the caller will simply return the error.  A bit ugly,
            //  but necessary.
            //

            if (currentEntry->MyClient == FALSE) {

                if (currentEntry->EntryExists)  {
                    LeaveCriticalSection( &BinlCacheListLock );
                    *CacheEntry = NULL;
                    return ERROR_BINL_CLIENT_EXISTS;
                }
                
                //
                //  we return the empty entry since we might now be
                //  creating the account.
                //
                rc = ERROR_BINL_INVALID_BINL_CLIENT;
            }

            //
            //  since we're now using an entry, reset the event saying all
            //  threads are done.
            //

            BinlCacheEntriesInUse++;

            currentEntry->InProgress = TRUE;
            *CacheEntry = currentEntry;

            LeaveCriticalSection( &BinlCacheListLock );

            return rc;
        }

        //
        //  we're at the first entry that is greater than the guid in question.
        //

        break;
    }

    if (! CreateIfNotExist) {

        LeaveCriticalSection( &BinlCacheListLock );
        *CacheEntry = NULL;
        return ERROR_BINL_INVALID_BINL_CLIENT;
    }

    //  currentEntry is not valid, but listEntry is.
    //
    //  Add a new entry at the end of listEntry.  Either listEntry points to
    //  the first entry that is larger than our guid or it points to the root
    //  of the list (in which case we add it at the end).
    //

    currentEntry = BinlAllocateMemory( sizeof( MACHINE_INFO ) );

    if (currentEntry == NULL) {

        *CacheEntry = NULL;
        LeaveCriticalSection( &BinlCacheListLock );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    currentEntry->TimeCreated = GetTickCount();
    currentEntry->InProgress = TRUE;

    // leave MyClient and EntryExists as FALSE

    memcpy( currentEntry->Guid, Guid, BINL_GUID_LENGTH );
    InsertTailList( listEntry, &currentEntry->CacheListEntry );
    InitializeListHead( &currentEntry->DNsWithSameGuid );

    BinlCacheEntriesInUse++;
    BinlCacheCount++;
    *CacheEntry = currentEntry;

    //
    //  If we're at the max, then go through the entire list to free the
    //  oldest.  We do this here because the loop below doesn't go through
    //  the whole list.
    //

    if (BinlCacheCount > BinlGlobalCacheCountLimit) {

        PMACHINE_INFO entryToDelete = NULL;
        DWORD earliestTime;

        listEntry = BinlCacheList.Flink;

        while ( listEntry != &BinlCacheList ) {

            currentEntry = (PMACHINE_INFO) CONTAINING_RECORD(
                                                listEntry,
                                                MACHINE_INFO,
                                                CacheListEntry );

            listEntry = listEntry->Flink;

            if (currentEntry->InProgress == FALSE) {

                //
                //  if this one is expired, stop here as we have one to free
                //

                if ((expireTickCount > 0) &&
                    (currentEntry->TimeCreated < expireTickCount)) {

                    entryToDelete = currentEntry;
                    break;
                }

                //
                //  if this one is earlier than the one we previously found,
                //  remember it.
                //

                if ((( entryToDelete == NULL) ||
                     ( currentEntry->TimeCreated < earliestTime)) ) {

                    entryToDelete = currentEntry;
                    earliestTime = currentEntry->TimeCreated;
                }
            }
        }
        if (entryToDelete) {
            BinlFreeCacheEntry( entryToDelete );
            BinlPrintDbg((DEBUG_BINL_CACHE, "removed cache entry %x", entryToDelete ));
        }
    }

    LeaveCriticalSection( &BinlCacheListLock );

    return ERROR_SUCCESS;
}

VOID
BinlDoneWithCacheEntry (
    PMACHINE_INFO CacheEntry,
    BOOLEAN FreeIt
    )
{
    EnterCriticalSection( &BinlCacheListLock );

    //
    //  This one is no longer actively used.  See if it's time to set the
    //  event to tell the terminating thread that everyone is done.
    //

    CacheEntry->InProgress = FALSE;

    BinlCacheEntriesInUse--;

    if ((BinlCacheEntriesInUse == 0) && BinlCloseCacheEvent) {

        SetEvent( BinlCloseCacheEvent );
    }

    if (FreeIt) {

        BinlFreeCacheEntry( CacheEntry );
    }

    LeaveCriticalSection( &BinlCacheListLock );

    BinlPrintDbg((DEBUG_BINL_CACHE, "binl done with cache entry 0x%x, FreeIt == %s\n", 
                  CacheEntry,
                  (FreeIt == TRUE) ? "TRUE" : "FALSE" ));
    return;
}

VOID
BinlFreeCacheEntry (
    PMACHINE_INFO CacheEntry
    )
//
//  The lock must be held while coming in here.  It will be not be freed.
//
{
    PLIST_ENTRY p;
    PDUP_GUID_DN dupDN;

    //
    //  We're done with this entry.  Simply remove it from the list, free it,
    //  and update the global count.  The lock is held, so party on.
    //

    BinlPrintDbg((DEBUG_BINL_CACHE, "binl freeing cache entry at 0x%x\n", CacheEntry ));    

    RemoveEntryList( &CacheEntry->CacheListEntry );

    if ( CacheEntry->dwFlags & MI_NAME_ALLOC ) {
        BinlFreeMemory( CacheEntry->Name );
    }
    if ( CacheEntry->dwFlags & MI_SETUPPATH_ALLOC ) {
        BinlFreeMemory( CacheEntry->SetupPath );
    }
    if ( CacheEntry->dwFlags & MI_HOSTNAME_ALLOC ) {
        BinlFreeMemory( CacheEntry->HostName );
    }
    if ( CacheEntry->dwFlags & MI_BOOTFILENAME_ALLOC ) {
        BinlFreeMemory( CacheEntry->BootFileName );
    }
    if ( CacheEntry->dwFlags & MI_SAMNAME_ALLOC ) {
        BinlFreeMemory( CacheEntry->SamName );
    }
    if ( CacheEntry->dwFlags & MI_DOMAIN_ALLOC ) {
        BinlFreeMemory( CacheEntry->Domain );
    }
    if ( CacheEntry->dwFlags & MI_SIFFILENAME_ALLOC ) {
        BinlFreeMemory( CacheEntry->ForcedSifFileName );
    }
    if ( CacheEntry->dwFlags & MI_MACHINEDN_ALLOC ) {
        BinlFreeMemory( CacheEntry->MachineDN );
    }

    while (!IsListEmpty(&CacheEntry->DNsWithSameGuid)) {

        p = RemoveHeadList(&CacheEntry->DNsWithSameGuid);

        dupDN = CONTAINING_RECORD(p, DUP_GUID_DN, ListEntry);
        BinlFreeMemory( dupDN );
    }

    BinlFreeMemory( CacheEntry );
    BinlCacheCount--;

    return;
}

VOID
BinlCloseCache (
    VOID
    )
//
//  This routine closes down all entries in the DS cache.  It waits until all
//  threads are done with entries before it returns.  It waits for the
//  BinlCloseCacheEvent to be set if threads are waiting.
//
{
    PLIST_ENTRY listEntry;

    EnterCriticalSection( &BinlCacheListLock );

    listEntry = BinlCacheList.Flink;

    while ( listEntry != &BinlCacheList ) {

        DWORD Error;

        PMACHINE_INFO cacheEntry;

        //
        //  For each entry in the list, if it's not in use we free it.  If it
        //  is in use, we wait for the thread to finish with it.
        //

        cacheEntry = (PMACHINE_INFO) CONTAINING_RECORD(
                                            listEntry,
                                            MACHINE_INFO,
                                            CacheListEntry );

        if (cacheEntry->InProgress != TRUE) {

            listEntry = listEntry->Flink;
            BinlFreeCacheEntry( cacheEntry );
            continue;
        }

        if (BinlCloseCacheEvent) {

            ResetEvent( BinlCloseCacheEvent );
        }

        LeaveCriticalSection( &BinlCacheListLock );

        //
        //  Wait for the event signalling that all threads are done with
        //  the cache
        //

        if (BinlCloseCacheEvent) {

            Error = WaitForSingleObject( BinlCloseCacheEvent, THREAD_TERMINATION_TIMEOUT );

        } else {

            //
            //  well, the event that we would wait on isn't there and there's
            //  still a worker thread using a cache entry, so we just wait
            //  and then recheck.  Yup, this is ugly.
            //

            Sleep( 10*1000 );
        }

        EnterCriticalSection( &BinlCacheListLock );
        listEntry = BinlCacheList.Flink;
    }

    LeaveCriticalSection( &BinlCacheListLock );
}

// cache.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\binlt.c ===
/*
Module Name:

    btest.c

Abstract:

    This module sends sample BINL packets to the BINL server of your choice.

    -b Use broadcast rather than directed datagram to <ServerName>
    -s <Servername> To specify a BINL server of your choice. Default is COLINW2

Author:

    Colin Watson Apr 29 1997

Revision History:

*/

#include <binl.h>
#pragma hdrstop
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <tdiinfo.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <nb30.h>

#include <binldef.h>

#define MAX_MSGLEN 80
#define MAX_ADDLEN 80
#define MAX_MSLOTNAME 80

typedef struct _OPTION2 {
    BYTE OptionType;
    BYTE OptionLength;
    BYTE OptionValue[];
} OPTION2, *POPTION2, *LPOPTION2;

BOOL __stdcall
CtrlCHandler (
    DWORD dwEvent
    );

void __stdcall
Udp (
    );

void __stdcall
Usage (
    CHAR *pszProgramName
    );

void __stdcall
PrintError (
    LPSTR lpszRoutine,
    LPSTR lpszCallName,
    DWORD dwError
    );

void __stdcall
DoStartup ( void );

void __stdcall
DoCleanup ( void );

VOID
GetHardwareAddress(
    PUCHAR Address
    );

VOID
DumpMessage(
    LPDHCP_MESSAGE BinlMessage
    );

//
// Global Variables
//

// If Startup was successful, fStarted is used to keep track.
BOOL fStarted = FALSE;

BOOL fBroadcast = FALSE;

// Global socket descriptor
SOCKET sock = INVALID_SOCKET;

LPSTR ServerName = "COLINW2";

ULONG ServerAddress;
ULONG ClientAddress;

void __cdecl
main (
    INT argc,
    CHAR **argv
    )
{
    int i;

    //
    // Install the CTRL+BREAK Handler
    //
    if ( FALSE == SetConsoleCtrlHandler ( (PHANDLER_ROUTINE) CtrlCHandler,
                                          TRUE
                                          ) ){
        PrintError ( "main", "SetConsoleCtrlHandler", GetLastError ( ) );
    }

    //
    // allow the user to override settings with command line switches
    //
    for ( i = 1; i < argc; i++ )
    {
        if ( ( *argv[i] == '-' ) || ( *argv[i] == '/' ) )
        {
            switch ( tolower ( *( argv[i]+1 ) ) )
            {
            //
            //  Broadcast
            //
            case 'b':
                fBroadcast = TRUE;
                break;
            //
            // ServerName.
            //
            case 's':
                ServerName = argv[++i];
                break;

            //
            // Help.
            //
            case 'h':
            case '?':
            default:
                Usage ( argv[0] );
            }
        }
        else
            //
            // Help.
            //
            Usage ( argv[0] );
    }

    //
    // Print a Summary of the switches specfied
    // Helpful for debugging
    //
    fprintf ( stdout, "SUMMARY:\n" );
    if (fBroadcast) {
        fprintf ( stdout, "Broadcast test\n" );
    } else {
        fprintf ( stdout, "Unicast to BINL server %s\n", ServerName );
    }

    DoStartup ( );
    Udp();

    return;
}

//
// CtrlCHandler () intercepts the CTRL+BREAK or CTRL+C events and calls the
// cleanup routines.
//
BOOL __stdcall
CtrlCHandler (
    DWORD dwEvent
        )
{
    if ( ( CTRL_C_EVENT == dwEvent ) || ( CTRL_BREAK_EVENT == dwEvent ) )
    {
        DoCleanup ( );
    }

    return FALSE;
}

void __stdcall
Discover(
    )
{
    // IP address structures needed to fill the source and destination
    // addresses.
    SOCKADDR_IN saUdpServ, saUdpCli;

    INT err;
    DWORD nSize;

    UCHAR MessageBuffer[DHCP_MESSAGE_SIZE];
    PDHCP_MESSAGE Message = (PDHCP_MESSAGE)&MessageBuffer[0];

    //  Data used for building Messages
    LPOPTION            Option;

    UCHAR MagicCookie[] = {DHCP_MAGIC_COOKIE_BYTE1,
                            DHCP_MAGIC_COOKIE_BYTE2,
                            DHCP_MAGIC_COOKIE_BYTE3,
                            DHCP_MAGIC_COOKIE_BYTE4};
    #define COOKIESIZE (4)

    OPTION2 DiscoverOption = {OPTION_MESSAGE_TYPE, 1, DHCP_DISCOVER_MESSAGE};
    #define DISCOVEROPTIONSIZE (DiscoverOption.OptionLength + 2)

    OPTION2 ClientOption = {OPTION_CLIENT_CLASS_INFO,9,"PXEClient"};
    // Size must ignore null at end of the string.
    #define CLIENTOPTIONSIZE (ClientOption.OptionLength + 2)

    OPTION2 NITOption = {OPTION_NETWORK_INTERFACE_TYPE,3,1,2,0};
    // Size must ignore null at end of the string.
    #define NITOPTIONSIZE (NITOption.OptionLength + 2)

    OPTION2 SAOption = {OPTION_SYSTEM_ARCHITECTURE,1,0};
    // Size must ignore null at end of the string.
    #define SAOPTIONSIZE (SAOption.OptionLength + 2)

    OPTION2 EndOption = {OPTION_END,0};
    // Size must ignore null at end of the string.
    #define ENDOPTIONSIZE (1)

    do {
sendagain:
        //
        // Fill an IP address structure, to send an IP broadcast.
        //
        saUdpServ.sin_family = AF_INET;
        if (fBroadcast) {
            saUdpServ.sin_addr.s_addr = htonl ( INADDR_BROADCAST );
        } else {
            saUdpServ.sin_addr.s_addr = ServerAddress;
        }
        saUdpServ.sin_port = htons ( DHCP_SERVR_PORT );

        //  Practice with a dummy BINL Discover packet
        ZeroMemory(MessageBuffer, sizeof(MessageBuffer));
        Message->Operation = BOOT_REQUEST;
        Option = &Message->Option;

        GetHardwareAddress(Message->HardwareAddress);
        Message->HardwareAddressType = 1;
        Message->HardwareAddressLength = 6;
        Message->TransactionID = 0x12345678;

        memcpy(Option, &MagicCookie, COOKIESIZE);
        Option = (LPOPTION)((PUCHAR)Option + COOKIESIZE);

        memcpy(Option, &DiscoverOption, DISCOVEROPTIONSIZE);
        Option = (LPOPTION)((PUCHAR)Option + DISCOVEROPTIONSIZE);

        memcpy(Option, &ClientOption, CLIENTOPTIONSIZE);
        Option = (LPOPTION)((PUCHAR)Option + CLIENTOPTIONSIZE);

        memcpy(Option, &NITOption, NITOPTIONSIZE);
        Option = (LPOPTION)((PUCHAR)Option + NITOPTIONSIZE);

        memcpy(Option, &SAOption, SAOPTIONSIZE);
        Option = (LPOPTION)((PUCHAR)Option + SAOPTIONSIZE);

        memcpy(Option, &EndOption, ENDOPTIONSIZE);
        Option = (LPOPTION)((PUCHAR)Option + ENDOPTIONSIZE);

        err = sendto ( sock,
                       (PUCHAR)Message,
                       (PUCHAR)Option - (PUCHAR)Message,
                       0,
                       (SOCKADDR *) &saUdpServ,
                       sizeof ( SOCKADDR_IN )
                       );

        if ( SOCKET_ERROR == err )
        {
            PrintError ( "Udp", "sendto", WSAGetLastError ( ) );
        }

        fprintf ( stdout, "%d bytes of data sent\n", err );

        Sleep(1000);    // Give server a few seconds to respond.

        do {

            err = ioctlsocket( sock, FIONREAD, &nSize);

            if ( SOCKET_ERROR == err )
            {
                PrintError ( "Udp", "recvfrom", WSAGetLastError ( ) );
            }

            if (!nSize) {
                goto sendagain; //  we have processed all the DHCP/BINL responses
            }

            //
            // receive a datagram on the bound port number.
            //

            nSize = sizeof ( SOCKADDR_IN );
            err = recvfrom ( sock,
                             (PUCHAR)Message,
                             DHCP_MESSAGE_SIZE,
                             0,
                             (SOCKADDR FAR *) &saUdpCli,
                             &nSize
                             );

            if ( SOCKET_ERROR == err )
            {
                PrintError ( "Udp", "recvfrom", WSAGetLastError ( ) );
            }

            if (Message->TransactionID == 0x12345678) {
                goto processit;
            }
        } while ( 1 );  //  while there are datagrams queued

    } while (1);

processit:

    //
    // print the sender's information.
    //
    fprintf ( stdout, "A Udp Datagram of length %d bytes received from ", err );
    fprintf ( stdout, "\n\tIP Adress->%s ", inet_ntoa ( saUdpCli.sin_addr ) );
    fprintf ( stdout, "\n\tPort Number->%d\n", ntohs ( saUdpCli.sin_port ) );

    DumpMessage(Message);
}

void __stdcall
Request(
    )
{
    // IP address structures needed to fill the source and destination
    // addresses.
    SOCKADDR_IN saUdpServ, saUdpCli;

    INT err;
    DWORD nSize;

    UCHAR MessageBuffer[DHCP_MESSAGE_SIZE];
    PDHCP_MESSAGE Message = (PDHCP_MESSAGE)&MessageBuffer[0];

    //  Data used for building Messages
    LPOPTION            Option;

    UCHAR MagicCookie[] = {DHCP_MAGIC_COOKIE_BYTE1,
                            DHCP_MAGIC_COOKIE_BYTE2,
                            DHCP_MAGIC_COOKIE_BYTE3,
                            DHCP_MAGIC_COOKIE_BYTE4};
    #define COOKIESIZE (4)

    OPTION2 RequestOption = {OPTION_MESSAGE_TYPE, 1, DHCP_REQUEST_MESSAGE};
    #define REQUESTOPTIONSIZE (RequestOption.OptionLength + 2)

    OPTION2 ClientOption = {OPTION_CLIENT_CLASS_INFO,9,"PXEClient"};
    // Size must ignore null at end of the string.
    #define CLIENTOPTIONSIZE (ClientOption.OptionLength + 2)

    OPTION2 NITOption = {OPTION_NETWORK_INTERFACE_TYPE,3,1,2,0};
    // Size must ignore null at end of the string.
    #define NITOPTIONSIZE (NITOption.OptionLength + 2)

    OPTION2 SAOption = {OPTION_SYSTEM_ARCHITECTURE,1,0};
    // Size must ignore null at end of the string.
    #define SAOPTIONSIZE (SAOption.OptionLength + 2)

    OPTION2 EndOption = {OPTION_END,0};
    // Size must ignore null at end of the string.
    #define ENDOPTIONSIZE (1)

    do {
sendagain:
        //
        // Fill an IP address structure, to send an IP broadcast.
        //
        saUdpServ.sin_family = AF_INET;
        if (fBroadcast) {
            saUdpServ.sin_addr.s_addr = htonl ( INADDR_BROADCAST );
        } else {
            saUdpServ.sin_addr.s_addr = ServerAddress;
        }
        //saUdpServ.sin_port = htons ( BINL_DEFAULT_PORT );
        saUdpServ.sin_port = htons ( 0xaee8 );

        //  Practice with a dummy BINL Request packet
        ZeroMemory(MessageBuffer, sizeof(MessageBuffer));
        Message->Operation = BOOT_REQUEST;
        Option = &Message->Option;

        GetHardwareAddress(Message->HardwareAddress);
        Message->HardwareAddressType = 1;
        Message->HardwareAddressLength = 6;
        Message->TransactionID = 0x56781234;
        Message->YourIpAddress = ClientAddress;

        memcpy(Option, &MagicCookie, COOKIESIZE);
        Option = (LPOPTION)((PUCHAR)Option + COOKIESIZE);

        memcpy(Option, &RequestOption, REQUESTOPTIONSIZE);
        Option = (LPOPTION)((PUCHAR)Option + REQUESTOPTIONSIZE);

        memcpy(Option, &ClientOption, CLIENTOPTIONSIZE);
        Option = (LPOPTION)((PUCHAR)Option + CLIENTOPTIONSIZE);

        memcpy(Option, &NITOption, NITOPTIONSIZE);
        Option = (LPOPTION)((PUCHAR)Option + NITOPTIONSIZE);

        memcpy(Option, &SAOption, SAOPTIONSIZE);
        Option = (LPOPTION)((PUCHAR)Option + SAOPTIONSIZE);

        memcpy(Option, &EndOption, ENDOPTIONSIZE);
        Option = (LPOPTION)((PUCHAR)Option + ENDOPTIONSIZE);

        err = sendto ( sock,
                       (PUCHAR)Message,
                       (PUCHAR)Option - (PUCHAR)Message,
                       0,
                       (SOCKADDR *) &saUdpServ,
                       sizeof ( SOCKADDR_IN )
                       );

        if ( SOCKET_ERROR == err )
        {
            PrintError ( "Udp", "sendto", WSAGetLastError ( ) );
        }

        fprintf ( stdout, "%d bytes of data sent\n", err );

        Sleep(1000);    // Give server a few seconds to respond.

        do {

            err = ioctlsocket( sock, FIONREAD, &nSize);

            if ( SOCKET_ERROR == err )
            {
                PrintError ( "Udp", "recvfrom", WSAGetLastError ( ) );
            }

            if (!nSize) {
                goto sendagain; //  we have processed all the DHCP/BINL responses
            }

            //
            // receive a datagram on the bound port number.
            //

            nSize = sizeof ( SOCKADDR_IN );
            err = recvfrom ( sock,
                             (PUCHAR)Message,
                             DHCP_MESSAGE_SIZE,
                             0,
                             (SOCKADDR FAR *) &saUdpCli,
                             &nSize
                             );

            if ( SOCKET_ERROR == err )
            {
                PrintError ( "Udp", "recvfrom", WSAGetLastError ( ) );
            }

            if (Message->TransactionID == 0x56781234) {
                goto processit;
            }
        } while ( 1 );  //  while there are datagrams queued

    } while (1);

processit:

    //
    // print the sender's information.
    //
    fprintf ( stdout, "A Udp Datagram of length %d bytes received from ", err );
    fprintf ( stdout, "\n\tIP Adress->%s ", inet_ntoa ( saUdpCli.sin_addr ) );
    fprintf ( stdout, "\n\tPort Number->%d\n", ntohs ( saUdpCli.sin_port ) );

    DumpMessage(Message);
}

void __stdcall
Udp(
    )
{
    INT err;
    LPHOSTENT pServerHostEntry;
    char MyName[80];

    // IP address structures needed to fill the source and destination
    // addresses.
    SOCKADDR_IN saUdpServ, saUdpCli;

    //
    // Initialize the global socket descriptor.
    //
    sock = socket ( AF_INET, SOCK_DGRAM, 0 );

    if ( INVALID_SOCKET ==  sock)
    {
        PrintError ( "Udp", "socket", WSAGetLastError() );
    }

    if (fBroadcast) {
        err = setsockopt ( sock,
                           SOL_SOCKET,
                           SO_BROADCAST,
                           (CHAR *) &fBroadcast,
                           sizeof ( BOOL )
                           );

        if ( SOCKET_ERROR == err )
        {
            PrintError ( "Udp", "setsockopt", WSAGetLastError ( )  );
        }
    } else {
        // Convert ServerName to an IP address
        ServerAddress = inet_addr(ServerName);  //  Dotted form of address

        if ((ServerAddress == INADDR_NONE) &&
            (memcmp(ServerName, "255.255.255.255", sizeof("255.255.255.255")))) {
            //  must be a servername
            pServerHostEntry = gethostbyname(ServerName);
            if (pServerHostEntry) {
                ServerAddress = *((PULONG)(pServerHostEntry->h_addr));
            } else {
                PrintError ( "Udp", "gethostbyname", WSAGetLastError ( )  );
                return;
            }

        }
    }

    //
    // bind to a local socket and an interface.
    //
    saUdpCli.sin_family = AF_INET;
    saUdpCli.sin_addr.s_addr = htonl ( INADDR_ANY );
    saUdpCli.sin_port = htons ( DHCP_CLIENT_PORT );

    err = bind ( sock, (SOCKADDR *) &saUdpCli, sizeof (SOCKADDR_IN) );

    if ( SOCKET_ERROR == err )
    {
        PrintError ( "Udp", "bind", WSAGetLastError ( ) );
    }

    //  Find my (clients) IP address.
    if (gethostname(MyName, sizeof(MyName)) != SOCKET_ERROR ){
        PHOSTENT Host;
        Host = gethostbyname(MyName);
        if (Host) {
            ClientAddress = *(PDHCP_IP_ADDRESS)Host->h_addr;
        }
    }

    Discover();

    Request();

    //
    // Call the cleanup routine.
    //
    DoCleanup ( );

    return;
}


//
// Usage () lists the available command line options.
//
void __stdcall
Usage (
    CHAR *pszProgramName
        )
{
    fprintf ( stderr, "Usage:  %s\n", pszProgramName );
    fprintf ( stderr, "\t-b Use broadcast to DHCP/BINL socket\n" );
    fprintf ( stderr,
        "\t-s <ServerName>, Use directed datagram to ServerName default - COLINW2)\n" );
        exit ( 1 );
}


//
// PrintError () is a function available globally for printing the error and
// doing the cleanup.
//
void __stdcall
PrintError (
    LPSTR lpszRoutine,
        LPSTR lpszCallName,
        DWORD dwError
        )
{

    fprintf ( stderr,
              "The Call to %s() in routine() %s failed with error %d\n",
              lpszCallName,
              lpszRoutine,
              dwError
              );

    DoCleanup ( );

    exit ( 1 );
}

//
// DoStartup () initializes the Winsock DLL with Winsock version 1.1
//
void __stdcall
DoStartup ( void )
{
  WSADATA wsaData;

  INT iRetVal;

    iRetVal = WSAStartup ( MAKEWORD ( 1,1 ), &wsaData );

    if ( 0 != iRetVal)
    {
        PrintError ( "DoStartup", "WSAStartup", iRetVal );
    }

    //
    // Set the global flag.
    //
    fStarted = TRUE;

    return;
}

//
// DoCleanup () will close the global socket which was opened successfully by
// a call to socket (). Additionally, it will call WSACleanup (), if a call
// to WSAStartup () was made successfully.
//
void __stdcall
DoCleanup ( void )
{
    if ( INVALID_SOCKET != sock )
    {
        closesocket ( sock );
    }

    if ( TRUE == fStarted )
    {
        WSACleanup ( );
    }

    fprintf ( stdout, "DONE\n" );

    return;
}

#define ClearNcb( PNCB ) {                                          \
    ZeroMemory( PNCB , sizeof (NCB) );                           \
    MoveMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    MoveMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }

#define SPACES "                "

VOID
GetHardwareAddress(
    PUCHAR Address
    ) {
    NCB myncb;
    ADAPTER_STATUS adapterstatus;
    UCHAR lanNumber;

    LANA_ENUM Enum;
    ClearNcb( &myncb );
    myncb.ncb_command = NCBENUM;
    myncb.ncb_lana_num = 0;
    myncb.ncb_length = sizeof(Enum);
    myncb.ncb_buffer = (PUCHAR)&Enum;
    Netbios( &myncb );
    if (( myncb.ncb_retcode != NRC_GOODRET ) ||
        ( !Enum.length )) {
        return;
    }

    lanNumber = Enum.lana[0];

    ClearNcb( &myncb );
    myncb.ncb_command = NCBRESET;
    myncb.ncb_lsn = 0;           // Request resources
    myncb.ncb_lana_num = lanNumber;
    myncb.ncb_callname[0] = 0;   // 16 sessions
    myncb.ncb_callname[1] = 0;   // 16 commands
    myncb.ncb_callname[2] = 0;   // 8 names
    Netbios( &myncb );

    if ( myncb.ncb_retcode != NRC_GOODRET ) return;

    ClearNcb( &myncb );
    myncb.ncb_command = NCBASTAT;
    myncb.ncb_lana_num = lanNumber;
    myncb.ncb_buffer = (PUCHAR)&adapterstatus;
    myncb.ncb_length = sizeof(adapterstatus);
    myncb.ncb_callname[0] = '*';

    Netbios( &myncb );
    if ( myncb.ncb_retcode != NRC_GOODRET ) return;

    CopyMemory(Address, &adapterstatus.adapter_address[0], 6);
}

VOID
DumpMessage(
    LPDHCP_MESSAGE BinlMessage
    )
/*++

Routine Description:

    This function dumps a DHCP packet in human readable form.

Arguments:

    BinlMessage - A pointer to a DHCP message.

Return Value:

    None.

--*/
{
    LPOPTION option;
    BYTE i;

    fprintf ( stdout,"Binl message: \n\n");

    fprintf ( stdout,"Operation              :");
    if ( BinlMessage->Operation == BOOT_REQUEST ) {
        fprintf ( stdout, "BootRequest\n");
    } else if ( BinlMessage->Operation == BOOT_REPLY ) {
        fprintf ( stdout, "BootReply\n");
    } else {
        fprintf ( stdout, "Unknown\n");
    }

    fprintf ( stdout,"Hardware Address type  : %d\n", BinlMessage->HardwareAddressType);
    fprintf ( stdout,"Hardware Address Length: %d\n", BinlMessage->HardwareAddressLength);
    fprintf ( stdout,"Hop Count              : %d\n", BinlMessage->HopCount );
    fprintf ( stdout,"Transaction ID         : %lx\n", BinlMessage->TransactionID );
    fprintf ( stdout,"Seconds Since Boot     : %d\n", BinlMessage->SecondsSinceBoot );
    fprintf ( stdout,"Client IP Address      : " );
    fprintf ( stdout,"%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->ClientIpAddress ) );

    fprintf ( stdout,"Your IP Address        : " );
    fprintf ( stdout,"%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->YourIpAddress ) );

    fprintf ( stdout,"Server IP Address      : " );
    fprintf ( stdout,"%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->BootstrapServerAddress ) );

    fprintf ( stdout,"Relay Agent IP Address : " );
    fprintf ( stdout,"%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->RelayAgentIpAddress ) );

    fprintf ( stdout,"Hardware Address       : ");
    for ( i = 0; i < BinlMessage->HardwareAddressLength; i++ ) {
        fprintf ( stdout,"%2.2x", BinlMessage->HardwareAddress[i] );
    }

    if (BinlMessage->HostName[0]) {
        fprintf( stdout, "\nHostName \"%s\"\n", BinlMessage->HostName);
    }
    if (BinlMessage->BootFileName[0]) {
        fprintf( stdout, "BootFileName \"%s\"\n", BinlMessage->BootFileName);
    }

    option = &BinlMessage->Option;

    fprintf ( stdout,"\nMagic Cookie: ");
    for ( i = 0; i < 4; i++ ) {
        fprintf ( stdout,"%d ", *((LPBYTE)option)++ );
    }
    fprintf ( stdout,"\n\n");

    fprintf ( stdout,"Options:\n");
    while ( option->OptionType != 255 ) {
        fprintf ( stdout,"\tType = %d ", option->OptionType );
        for ( i = 0; i < option->OptionLength; i++ ) {
            fprintf ( stdout,"%2.2x", option->OptionValue[i] );
        }
        fprintf ( stdout,"\n");

        if ( option->OptionType == OPTION_PAD ||
             option->OptionType == OPTION_END ) {

            option = (LPOPTION)( (LPBYTE)(option) + 1);

        } else {

            option = (LPOPTION)( (LPBYTE)(option) + option->OptionLength + 2);

        }

        if ( (LPBYTE)option - (LPBYTE)BinlMessage > DHCP_MESSAGE_SIZE ) {
            fprintf ( stdout,"End of message, but no trailer found!\n");
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\binltest.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    binltest.c

Abstract:

    Test program to run binl service as a process.

Author:

    Colin Watson (colinw)  17-Apr-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include <binl.h>
#pragma hdrstop

VOID
DisplayUsage(
    VOID
    )
{
    printf( "Usage:  binltest\n");
    return;
}

VOID __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD Error;

    if( argc != 1 ) {
        DisplayUsage();
        return;
    }

    ServiceEntry(2,NULL, NULL); //  Impossible parameters signal running in binltest

    printf( "Binl returned\n");

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\binldef.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    binldef.h

Abstract:

    This file contains manifest constants and internal data structures
    for the BINL service.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _BINL_
#define _BINL_

#if DBG
#define STATIC
#else
#define STATIC static
#endif // DBG

//
// Globals
//
extern DWORD BinlRepeatSleep;


//  Connection information to a DC in our domain
extern PLDAP DCLdapHandle;
extern PWCHAR * DCBase;

//  Connection information to the Global Catalog for our enterprise
extern PLDAP GCLdapHandle;
extern PWCHAR * GCBase;



//
// useful macros
//

#define WSTRSIZE( wsz ) (( wcslen( wsz ) + 1 ) * sizeof( WCHAR ))
#define STRSIZE( sz ) (( strlen( sz ) + 1 ) * sizeof( char ))
#define SWAP( p1, p2 )  \
{                       \
    VOID *pvTemp = p1;  \
    p1 = p2;            \
    p2 = pvTemp;        \
}

//
// calculates the size of a field
//

#define GET_SIZEOF_FIELD( struct, field ) ( sizeof(((struct*)0)->field))


//
// Constants
//

#define BINL_SERVER       L"BINLSVC"

//
// Timeouts, this is the length of time we wait for our threads to terminate.
//

#define THREAD_TERMINATION_TIMEOUT      INFINITE        // wait a long time,
                                                        // but don't AV

#define BINL_HYPERMODE_TIMEOUT           60*1000        // in msecs. 1 min
#define BINL_HYPERMODE_RETRY_COUNT       30             // do it for 30 mins

//
// message queue length.
//

#define BINL_RECV_QUEUE_LENGTH              50
#define BINL_MAX_PROCESSING_THREADS         20
//
// macros
//

#define LOCK_INPROGRESS_LIST()   EnterCriticalSection(&BinlGlobalInProgressCritSect)
#define UNLOCK_INPROGRESS_LIST() LeaveCriticalSection(&BinlGlobalInProgressCritSect)

#define LOCK_RECV_LIST()   EnterCriticalSection(&BinlGlobalRecvListCritSect)
#define UNLOCK_RECV_LIST() LeaveCriticalSection(&BinlGlobalRecvListCritSect)

//
// An endpoint represents a socket and the addresses associated with
// the socket.
//

typedef struct _ENDPOINT {
    SOCKET  Socket;
    DWORD   Port;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS SubnetMask;
    DHCP_IP_ADDRESS SubnetAddress;
} ENDPOINT, *LPENDPOINT, *PENDPOINT;


//
// A request context, one per processing thread.
//

typedef struct _BINL_REQUEST_CONTEXT {

    //
    // list pointer.
    //

    LIST_ENTRY ListEntry;


    //
    // pointer to a received buffer.
    //

    LPBYTE ReceiveBuffer;

    //
    // A buffer to send response.
    //

    LPBYTE SendBuffer;

    //
    // The actual amount of data received in the buffer.
    //

    DWORD ReceiveMessageSize;

    //
    // The actual amount of data send in the buffer.
    //

    DWORD SendMessageSize;

    //
    // The source of the current message
    //

    PENDPOINT ActiveEndpoint;
    struct sockaddr SourceName;
    DWORD SourceNameLength;
    DWORD TimeArrived;

    BYTE MessageType;

} BINL_REQUEST_CONTEXT, *LPBINL_REQUEST_CONTEXT, *PBINL_REQUEST_CONTEXT;


#define BOOT_FILE_SIZE          128
#define BOOT_SERVER_SIZE        64
#define BOOT_FILE_SIZE_W        ( BOOT_FILE_SIZE * sizeof( WCHAR ))
#define BOOT_SERVER_SIZE_W      ( BOOT_SERVER_SIZE * sizeof( WCHAR ))

//
// Registry data
//

#define BINL_PARAMETERS_KEY       L"System\\CurrentControlSet\\Services\\Binlsvc\\Parameters"
#define BINL_PORT_NAME            L"Port"
#define BINL_DEFAULT_PORT         4011
#define BINL_DEBUG_KEY            L"Debug"
#if DBG
#define BINL_REPEAT_RESPONSE      L"RepeatResponse"
#endif // DBG
#define BINL_LDAP_OPT_REFERRALS   L"LdapOptReferrals"
#define BINL_MIN_RESPONSE_TIME    L"ResponseDelay"
#define BINL_LDAP_SEARCH_TIMEOUT  L"LdapTimeout"
#define BINL_CACHE_EXPIRE         L"CacheExpire"
#define BINL_CACHE_MAX_COUNT      L"CacheMaxCount"
#define BINL_ALLOW_NEW_CLIENTS    L"AllowNewClients"
#define BINL_DEFAULT_CONTAINER    L"DefaultContainer"
#define BINL_DEFAULT_DOMAIN       L"DefaultDomain"
#define BINL_DEFAULT_DS           L"DefaultServer"
#define BINL_DEFAULT_GC           L"DefaultGCServer"
#define BINL_CLIENT_TIMEOUT       L"ClientTimeout"
#define BINL_SCAVENGER_SLEEP      L"ScavengerSleep"
#define BINL_SCAVENGER_SIFFILE    L"SifFileSleep"
#define BINL_DEFAULT_LANGUAGE     L"DefaultLanguage"
#define BINL_UPDATE_PARAMETER_POLL L"UpdateParameterPoll"
#define BINL_DS_ERROR_COUNT_PARAMETER L"MaxDSErrorsToLog"
#define BINL_DS_ERROR_SLEEP       L"DSErrorInterval"
#define BINL_ASSIGN_NEW_CLIENTS_TO_SERVER L"AssignNewClientsToServer"

#define BINL_SCP_CREATED          L"ScpCreated"
#define BINL_SCP_NEWCLIENTS       L"netbootAllowNewClients"
#define BINL_SCP_LIMITCLIENTS     L"netbootLimitClients"
#define BINL_SCP_CURRENTCLIENTCOUNT L"netbootCurrentClientCount"
#define BINL_SCP_MAXCLIENTS       L"netbootMaxClients"
#define BINL_SCP_ANSWER_REQUESTS  L"netbootAnswerRequests"
#define BINL_SCP_ANSWER_VALID     L"netbootAnswerOnlyValidClients"
#define BINL_SCP_NEWMACHINENAMEPOLICY L"netbootNewMachineNamingPolicy"
#define BINL_SCP_NEWMACHINEOU     L"netbootNewMachineOU"
#define BINL_SCP_NETBOOTSERVER    L"netbootServer"










typedef struct _DHCP_BINARY_DATA {
    DWORD DataLength;

#if defined(MIDL_PASS)
    [size_is(DataLength)]
#endif // MIDL_PASS
        BYTE *Data;

} DHCP_BINARY_DATA, *LPDHCP_BINARY_DATA;

//
// Structure that defines the state of a client.
//
// The reason we use a separate Positive and Negative RefCount is so that
// we don't have to re-acquire the global ClientsCriticalSection when
// we are done with a CLIENT_STATE, just to decrement the ref count.
// Instead we guard the NegativeRefCount with just the CLIENT_STATE's
// CriticalSection. Then we compare Positive and Negative and if they
// are equal we delete the CLIENT_STATE. Even if PositiveRefCount is
// being added to just as we do this comparison, it won't ever be equal
// to Negative RefCount unless we really are the last thread to use the
// CLIENT_STATE.
//
// Padding is in the structure so that the first two elements, which are
// guarded by ClientsCriticalSection, aren't in the same quadword as
// anything else.
//

// search and replace structure
typedef struct {
    LPSTR  pszToken;
    struct {
        LPSTR  pszStringA;
        LPWSTR pszStringW;
    };
} SAR, * LPSAR;

#define MAX_VARIABLES 64

typedef struct _CLIENT_STATE {
    LIST_ENTRY Linkage;     // in ClientsQueue
    ULONG PositiveRefCount; // guarded by global ClientsCriticalSection
    ULONG Padding;
    CRITICAL_SECTION CriticalSection;  // prevents two messages processed at once
    ULONG NegativeRefCount; // guarded by our CriticalSection; delete when equal to PositiveRC
    ULONG RemoteIp;         // IP address of the client
    CtxtHandle ServerContextHandle;
    PLDAP AuthenticatedDCLdapHandle;  // returned by ldap_bind (with credentials)
    HANDLE UserToken;                 // returned by LogonUser with same credentials
    ULONG ContextAttributes;
    UCHAR Seed;                       // seed used for run encoding-decoding
    BOOL NegotiateProcessed;
    BOOL CustomInstall;         // true if custom, false if auto
    BOOL AuthenticateProcessed; // if TRUE, then AuthenticateStatus is valid
    BOOL CriticalSectionHeld;   // just a quick check, not 100% accurate.
    BOOL InitializeOnFirstRequest; // call OscInitializeClientVariables on initial request?
    SECURITY_STATUS AuthenticateStatus;
    ULONG LastSequenceNumber;
    PUCHAR LastResponse;          // buffer holding the last packet sent
    ULONG LastResponseAllocated;  // size LastResponse is allocated at
    ULONG LastResponseLength;     // size of current data in LastResponse
    DWORD LastUpdate;             // Last time this client state was entered

    ULONG  nVariables;            // current number of defined varaibles
    SAR    Variables[ MAX_VARIABLES ]; // "variables" that are replaced in OSCs and SIFs
    INT    nCreateAccountCounter; // Counts up each time a different computer name was tired
    BOOL   fCreateNewAccount;     // FALSE if a pre-staged account exists
    BOOL   fAutomaticMachineName; // TRUE is BINL generated the machine name
    BOOL   fHaveSetupMachineDN;   // TRUE if we've already called OscCheckMachineDN
    WCHAR  MachineAccountPassword[LM20_PWLEN+1];
    DWORD  MachineAccountPasswordLength;
} CLIENT_STATE, *PCLIENT_STATE;

//
//  The structure that tracks info based on GUID.
//
//  Because checking the DS is a expensive, we track the results we received
//  from the DS per GUID in this structure.  This also allows us to ignore
//  duplicate requests from clients when we're already working on them.
//
//  These cache entries are very short lived, on the order of a minute or so.
//  We'd hold them longer except we have no idea when they get stale in the DS.
//
//  The list of cache entries is protected by BinlCacheListLock.  An entry
//  is in use when the InProgress flag is set.  If this flag is set, it means
//  that a thread is actively using it and the entry shouldn't be touched.
//
//  If the hostname is not filled in and the NotMyClient flag is set to FALSE,
//  then the entry, though allocated, hasn't been fully filled in.
//
//  The XXX_ALLOC bits indicate that the corresponding field was allocated
//  and needs to be freed when the cache entry is freed.
//

#define BINL_GUID_LENGTH 16

#define MI_NAME               0x00000001
#define MI_SETUPPATH          0x00000002
#define MI_HOSTNAME           0x00000004
#define MI_BOOTFILENAME       0x00000008

#define MI_SAMNAME            0x00000010
#define MI_PASSWORD           0x00000020
#define MI_DOMAIN             0x00000040
#define MI_HOSTIP             0x00000080

#define MI_MACHINEDN          0x00000100

#define MI_NAME_ALLOC         0x00010000
#define MI_SETUPPATH_ALLOC    0x00020000
#define MI_HOSTNAME_ALLOC     0x00040000
#define MI_BOOTFILENAME_ALLOC 0x00080000

#define MI_SAMNAME_ALLOC      0x00100000
#define MI_DOMAIN_ALLOC       0x00400000
#define MI_SIFFILENAME_ALLOC  0x00800000

#define MI_MACHINEDN_ALLOC    0x01000000

#define MI_ALL_ALLOC          0x03ff0000

#define MI_GUID               0x80000000  // UpdateCreate forces a new guid to be written

typedef struct _MACHINE_INFO {

    LIST_ENTRY  CacheListEntry;     // global is BinlCacheList
    DWORD       TimeCreated;        // from GetTickCount

    BOOLEAN     InProgress;         // is a thread currently working on this?
    BOOLEAN     MyClient;           // do we not respond to this client?
    BOOLEAN     EntryExists;        // does the entry exist in the DS?

    DWORD       dwFlags;            // "MI_" bits saying what information is currently valid
    UCHAR       Guid[BINL_GUID_LENGTH]; // client's GUID
    PWCHAR      Name;               // client's name
    PWCHAR      MachineDN;          // client's FQ Distinguished Name
    PWCHAR      SetupPath;          // client's orginal installation path
    PWCHAR      HostName;           // client's host server name
    DHCP_IP_ADDRESS HostAddress;    // address of host - this is filled when HostName is filled
    PWCHAR      BootFileName;       // client's boot filename
    PWCHAR      SamName;            // client's SAM name
    PWCHAR      Password;           // client's password (for setting only)
    ULONG       PasswordLength;     // client's password length (for setting only)
    PWCHAR      Domain;             // client's domain
    LIST_ENTRY  DNsWithSameGuid;    // list of DNs with same GUID, except for MachineDN above.
    PWCHAR      ForcedSifFileName;  // client's sif file it must use.

} MACHINE_INFO, *PMACHINE_INFO;

//
//  Structure that tracks duplicate DNs for this machine account. The structure
//  is allocated with room for the two strings at the end.
//

typedef struct _DUP_GUID_DN {

    LIST_ENTRY ListEntry;
    ULONG      DuplicateDNOffset;  // offset from the start of DuplicateName to DuplicateDN
    WCHAR      DuplicateName[1];   // name of the duplicate account (without final '$')
    // WCHAR   DuplicateDN[];      // this follows at DuplicateDNOffset

} DUP_GUID_DN, *PDUP_GUID_DN;


//
// The largest size of any client architecture name
// (current choices: i386 alpha mips ia64 ppc arci386) --
// assume it won't exceed 8 chars for now.
//

#define MAX_ARCHITECTURE_LENGTH      8


#define DHCP_OPTION_CLIENT_ARCHITECTURE_X86       0
#define DHCP_OPTION_CLIENT_ARCHITECTURE_NEC98     1 
#define DHCP_OPTION_CLIENT_ARCHITECTURE_IA64      2
#define DHCP_OPTION_CLIENT_ARCHITECTURE_ALPHA     3
#define DHCP_OPTION_CLIENT_ARCHITECTURE_ARCX86    4
#define DHCP_OPTION_CLIENT_ARCHITECTURE_INTELLEAN 5

#endif _BINL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\client.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This module contains the code to process OS Chooser message
    for the BINL server.

Author:

    Adam Barr (adamba)  9-Jul-1997
    Geoff Pease (gpease) 10-Nov-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop
#include "mbstring.h"

//
// List of maximums for certain variables. OscAddVariableX will fail if
// the limits are exceeded; it is up to the caller of the function to know
// if the variable being added might hit a limit and check for failure.
//

typedef struct OSC_VARIABLE_MAXIMUM {
    LPSTR VariableName;
    ULONG MaximumLength;
} OSC_VARIABLE_MAXIMUM, *POSC_VARIABLE_MAXIMUM;

OSC_VARIABLE_MAXIMUM OscMaximums[] = {
    //
    // This set of variables come from locations we don't completely control,
    // so we need to check the return code from OscAddVariable each time.
    //
    { "BOOTFILE",  127 },   // with NULL, must fit in 128-byte field of CREATE_DATA.
                            // Normally this will be empty or come from a .sif;
                            // an admin may customize the .sif or modify the
                            // DS attribute directly.
    { "MACHINENAME", 63 },  // used in path with SERVERNAME; comes from a screen
                            // input with a max length of 63, or else is generated
                            // by the GenerateMachineName() function. 63 is equal
                            // to DNS_MAX_LABEL_LENGTH.
    { "SIFFILE", 127 },     // with NULL, must fit in 128-byte field of CREATE_DATA.
                            // Normally this will be \RemoteInstall\tmp\[GUID].sif,
                            // but the path may be longer.
    { "INSTALLPATH", 127 }, // used in paths with MACHINETYPE and SERVERNAME. This
                            // will depend on where the build is installed
                            // with RISETUP.
    //
    // The ones after this will be correct when we add them, but a rogue
    // client might send in bogus values. So the general checking code in
    // OscProcessScreenArguments will catch invalid ones.
    //
    { "MACHINETYPE", MAX_ARCHITECTURE_LENGTH },
                            // current max value. This is sent up by oschooser
                            // and should correspond to where RISETUP puts
                            // the platform-specific files.
    { "SERVERNAME", 63 },   // used in paths with MACHINENAME and INSTALLPATH,
                            // set by calling GetComputerNameEX(ComputerNameNetBIOS)
    { "NETBIOSNAME", 31 },  // with NULL, must fit in 32-byte field of CREATE_DATA.
                            // This is gotten by calling DnsHostnameToComputerNameW(),
                            // if that fails the name is truncated to 15 chars
    { "LANGUAGE", 32 },     // reasonable max value; this is obtained by calling
                            // GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SENGLANGUAGE),
                            // but can be over-ridden in the registry. It is used in
                            // paths with IntelliMirrorPathW and some other constants,
                            // but no other variables. Eventually this becomes
                            // a part of INSTALLPATH and sometimes BOOTFILE.
    { "GUID", 32 },         // 16 bytes in hex format
    { "MAC", 12 },          // 6 bytes in hex format
    //
    // NOTE: If we get an error condition, we add the variable SUBERROR
    // to the client state. So don't put a limit on SUBERROR size, since
    // that might cause an infinite loop.
    //
};

#define OSC_VARIABLE_MAXIMUM_COUNT (sizeof(OscMaximums) / sizeof(OSC_VARIABLE_MAXIMUM))

//
//  We need to eliminate the chance of denial of service attacks so we'll limit
//  the number of concurrent clients we support.
//

#define BINL_MAX_CLIENT_RECORDS 1000
LONG BinlGlobalClientLimit = BINL_MAX_CLIENT_RECORDS;

DWORD
OscUpdatePassword(
    IN PCLIENT_STATE ClientState,
    IN PWCHAR SamAccountName,
    IN PWCHAR Password,
    IN LDAP * LdapHandle,
    IN PLDAPMessage LdapMessage
    )
/*++

Routine Description:

    Sets the password for the client. NOTE: WE MUST BE BETWEEN CALLS TO
    OSCIMPERSONATE/OSCREVERT.

Arguments:

    ClientState - The client state. AuthenticatedDCLdapHandle must be valid
        and we must be impersonating the client.

    SamAccountName - The name of the machine account. This is the
        "samAccountName" value from the DS, which includes the final $.

    Password - The NULL-terminated Unicode password.

    LdapHandle - The handle to the DS.

    LdapMessage - The result of an ldap search for this client.

Return Value:

    Status of the operation.

--*/

{
    BOOL bResult;
    LDAP * serverLdap;
    PWCHAR serverHostName;
    USER_INFO_1003 userInfo1003;
    PWCHAR backslashServerName;
    PWCHAR p;
    ULONG serverHostNameLength;
    DWORD paramError;
    NET_API_STATUS netStatus;

    //
    // Change the password in the DS.
    //

    serverLdap = ldap_conn_from_msg (LdapHandle, LdapMessage);
    if (serverLdap == NULL) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "OscUpdatePassword ldap_conn_from_msg is NULL\n" ));
        return E_HANDLE;
    }

    serverHostName = NULL;
    if (LDAP_SUCCESS != ldap_get_option(serverLdap, LDAP_OPT_HOST_NAME, &serverHostName)) {
        BinlPrintDbg(( DEBUG_ERRORS,
                       "OscUpdatePassword ldap_get_option failed\n" ));
        return E_HANDLE;
    }
    

    userInfo1003.usri1003_password = Password;

    serverHostNameLength = wcslen(serverHostName) + 1;

    //
    // Allocate room for the name with two extra characters
    // for the leading \\.
    //

    backslashServerName = BinlAllocateMemory((serverHostNameLength+2) * sizeof(WCHAR));
    if (backslashServerName == NULL) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "OscUpdatePassword could not allocate serverHostNameW\n" ));
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

    wcscpy(backslashServerName, L"\\\\");
    wcscpy(backslashServerName+2, serverHostName);

    //
    // TEMP: Serialize all calls to the NetUserSetInfo/
    // NetUserModalsGet. See discussion in bug 319962.
    // This code was put back in when the fix for a
    // problem described as "RPC is ignoring the security
    // context of the caller when choosing which named
    // pipe to send an RPC call over" turned out to cause
    // a BVT break.
    //
    EnterCriticalSection(&HackWorkaroundCriticalSection);

    netStatus = NetUserSetInfo(
                    backslashServerName,
                    SamAccountName,
                    1003,
                    (LPBYTE)&userInfo1003,
                    &paramError);

    LeaveCriticalSection(&HackWorkaroundCriticalSection);

    BinlFreeMemory(backslashServerName);

    if (netStatus != NERR_Success) {

        HANDLE TempToken;

        BinlPrint(( DEBUG_ERRORS,
            "OscUpdatePassword NetUserSetInfo returned %lx\n", netStatus ));

        //
        // If NetUserSetInfo failed, try a LogonUser to see if the
        // password is already set to the value we want -- if so,
        // we can still succeed.
        //

        bResult = LogonUser(
                      SamAccountName,
                      OscFindVariableW( ClientState, "MACHINEDOMAIN" ),
                      Password,
                      LOGON32_LOGON_NETWORK,
                      LOGON32_PROVIDER_WINNT40,
                      &TempToken);

        if (bResult) {
            CloseHandle(TempToken);
        } else {
            DWORD TempError = GetLastError();
            if (TempError != ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT) {
                return netStatus;  // return the original error
            }
        }

        //
        // Fall through and return ERROR_SUCCESS.
        //
    }

    return ERROR_SUCCESS;

}

//
// Free client state information
//
VOID
FreeClient(
    PCLIENT_STATE client
    )
{
    ULONG i;
    TraceFunc("FreeClient( )\n");

    BinlPrintDbg(( DEBUG_OSC, "Freeing client state for %s\n", inet_ntoa(*(struct in_addr *)&(client->RemoteIp)) ));

    DeleteCriticalSection(&client->CriticalSection);

    if (client->LastResponse)
        BinlFreeMemory(client->LastResponse);

    OscFreeClientVariables(client);

    InterlockedIncrement( &BinlGlobalClientLimit );

    if (client->NegotiateProcessed) {
        DeleteSecurityContext( &client->ServerContextHandle );
    }

    if (client->AuthenticatedDCLdapHandle) {
        ldap_unbind(client->AuthenticatedDCLdapHandle);
    }

    if (client->UserToken) {
        CloseHandle(client->UserToken);
    }

    BinlFreeMemory(client);
}

VOID
OscFreeClientVariables(
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function frees all variables in a client state.

Arguments:

    clientState - the client state pointer.

Return Value:

    None.

--*/
{
    ULONG i;

    for( i = 0; i < clientState->nVariables; i++ )
    {
        BinlFreeMemory(clientState->Variables[i].pszToken);
        if (clientState->Variables[i].pszStringA) {
            BinlFreeMemory(clientState->Variables[i].pszStringA);
            clientState->Variables[i].pszStringA = NULL;
        }
        if (clientState->Variables[i].pszStringW) {
            BinlFreeMemory(clientState->Variables[i].pszStringW);
            clientState->Variables[i].pszStringW = NULL;
        }
    }

    clientState->nVariables = 0;
    clientState->fHaveSetupMachineDN = FALSE;
    clientState->fCreateNewAccount = FALSE;
    clientState->fAutomaticMachineName = FALSE;
}

BOOLEAN
OscInitializeClientVariables(
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function cleans out any variables in the client state,
    then initializes some default values, which may later be
    overwritten by variables from client screens.

    This function is called when a client state is created, and
    when it is re-used from cache.

Arguments:

    clientState - the client state pointer.

Return Value:

    None.

--*/
{
    BOOLEAN retVal = TRUE;
    //
    // First clean out any variables in the client state.
    //
    OscFreeClientVariables(clientState);

    //
    // Now add the variables.
    //

    EnterCriticalSection( &gcsParameters );

    if (BinlGlobalDefaultLanguage) {
        OscAddVariableW( clientState, "LANGUAGE",     BinlGlobalDefaultLanguage );
    } else {
        OscAddVariableW( clientState, "LANGUAGE",     DEFAULT_LANGUAGE );
    }
    if (BinlGlobalDefaultOrgname) {
        OscAddVariableW( clientState, "ORGNAME",      BinlGlobalDefaultOrgname );
    } else {
        OscAddVariableW( clientState, "ORGNAME",      DEFAULT_ORGNAME );
    }
    if (BinlGlobalDefaultTimezone) {
        OscAddVariableW( clientState, "TIMEZONE",     BinlGlobalDefaultTimezone );
    } else {
        OscAddVariableW( clientState, "TIMEZONE",     DEFAULT_TIMEZONE );
    }

    if (BinlGlobalOurDomainName == NULL || BinlGlobalOurServerName == NULL) {

        LeaveCriticalSection( &gcsParameters );
        BinlPrintDbg((DEBUG_OSC_ERROR, "!! Error we don't have a FQDN for ourselves.\n" ));
        retVal = FALSE;
        goto Cleanup;

    }
    OscAddVariableW( clientState, "SERVERDOMAIN", BinlGlobalOurDomainName );

    // Add the Server's name variable

    OscAddVariableW( clientState, "SERVERNAME", BinlGlobalOurServerName );

    LeaveCriticalSection( &gcsParameters );

    OscAddVariableA( clientState, "SUBERROR", " " );

    clientState->fHaveSetupMachineDN = FALSE;
    clientState->fCreateNewAccount = FALSE;
    clientState->fAutomaticMachineName = FALSE;

    clientState->InitializeOnFirstRequest = FALSE;

Cleanup:

    //
    // If this fails, clean up anything we set here.
    //

    if (!retVal) {
        OscFreeClientVariables(clientState);
    }

    return retVal;

}

DWORD
OscFindClient(
    ULONG RemoteIp,
    BOOL Remove,
    PCLIENT_STATE * pClientState
    )
/*++

Routine Description:

    This function looks up a client in our client database, using
    their IP address. If Remove is TRUE, it removes the entry if
    found. Otherwise, if not found, it creates a new entry.

Arguments:

    RemoteIp - the remote IP address.

    Remove - TRUE if the client should be removed if found.

    pClientState - Returns the CLIENT_STATE.

Return Value:

    ERROR_SUCCESS if it finds the client and it is not in use.
    ERROR_NOT_ENOUGH_SERVER_MEMORY if a client state could not be allocated.
    ERROR_BUSY if the client state is already being used by another thread.

--*/
{
    LONG oldCount;
    PLIST_ENTRY p;
    DWORD Error = ERROR_SUCCESS;
    PCLIENT_STATE TempClient = NULL;

    TraceFunc("OscFindClient( )\n");

    EnterCriticalSection(&ClientsCriticalSection);

    for (p = ClientsQueue.Flink;
         p != &ClientsQueue;
         p = p->Flink) {

        TempClient = CONTAINING_RECORD(p, CLIENT_STATE, Linkage);

        if (TempClient->RemoteIp == RemoteIp) {

            //
            // Found it!
            //
            if (Remove) {
                RemoveEntryList(&TempClient->Linkage);
                TraceFunc("Client removed.\n");
            }

            break;
        }
    }

    if (p == &ClientsQueue) {
        TempClient = NULL;
    }

    if (!TempClient && (!Remove)) {

        //
        // Not found, allocate a new one.
        //

        oldCount = InterlockedDecrement( &BinlGlobalClientLimit );

        if (oldCount <= 0) {

            InterlockedIncrement( &BinlGlobalClientLimit );
            BinlPrintDbg(( DEBUG_OSC_ERROR, "Way too many clients, 0x%x clients\n", BINL_MAX_CLIENT_RECORDS));
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            TempClient = NULL;

        } else {

            TraceFunc("Creating new client...\n");

            TempClient = BinlAllocateMemory(sizeof(CLIENT_STATE));

            if (TempClient == NULL) {

                InterlockedIncrement( &BinlGlobalClientLimit );
                BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not get client state for %s\n", inet_ntoa(*(struct in_addr *)&RemoteIp) ));
                Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;

            } else {
                TempClient->NegotiateProcessed = FALSE;
                TempClient->AuthenticateProcessed = FALSE;
                TempClient->LastSequenceNumber = 0;
                TempClient->LastResponse = NULL;
                TempClient->LastResponseAllocated = 0;
                TempClient->PositiveRefCount = 1;
                TempClient->NegativeRefCount = 0;
                TempClient->AuthenticatedDCLdapHandle = NULL;

                TempClient->UserToken = NULL;
                TempClient->LastUpdate = GetTickCount();
                TempClient->nCreateAccountCounter = 0;

                TempClient->nVariables = 0;

                //
                // Fill in some standard variables.
                //

                if (!OscInitializeClientVariables(TempClient)) {

                    InterlockedIncrement( &BinlGlobalClientLimit );
                    BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not initialize client state for %s\n", inet_ntoa(*(struct in_addr *)&RemoteIp) ));
                    BinlFreeMemory(TempClient);
                    TempClient = NULL;
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;

                } else {

                    InitializeCriticalSection(&TempClient->CriticalSection);
                    TempClient->CriticalSectionHeld = FALSE;
                    TempClient->RemoteIp = RemoteIp;

                    OscGenerateSeed(&TempClient->Seed);

                    InsertHeadList(&ClientsQueue, &TempClient->Linkage);

                    BinlPrintDbg(( DEBUG_OSC, "Allocating new client state for %s\n", inet_ntoa(*(struct in_addr *)&RemoteIp) ));
                }
            }
        }
    }

    if (TempClient) {
        //
        // Do a quick check to see if another client is using this. This
        // check is not synchronized with the setting of this variable to
        // FALSE, and it's possible two clients could slip through, but
        // that is OK since this is not fatal (each thread still needs
        // to actually get the critical section to do anything).
        //
        if (TempClient->CriticalSectionHeld && (!Remove)) {
            Error = ERROR_BUSY;
            TempClient = NULL;
        } else {
            ++TempClient->PositiveRefCount;   // need to do this inside ClientsCriticalSection
        }
    }

    LeaveCriticalSection(&ClientsCriticalSection);

    *pClientState = TempClient;
    return Error;

}


VOID
OscFreeClients(
    VOID
    )
/*++

Routine Description:

    This function frees the clients list for OS chooser. It is
    intended to be called only when the service is shutting down,
    so the critical section does not matter.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLIST_ENTRY p;
    PCLIENT_STATE TempClient;

    TraceFunc("OscFreeClients( )\n");

    while (!IsListEmpty(&ClientsQueue)) {

        p = RemoveHeadList(&ClientsQueue);

        TempClient = CONTAINING_RECORD(p, CLIENT_STATE, Linkage);

        FreeClient(TempClient);

    }

}

VOID
SearchAndReplace(
    LPSAR psarList,
    LPSTR *pszString,
    DWORD ArraySize,
    DWORD dwSize,
    DWORD dwExtraSize )
/*++

Routine Description:


    Searches and replaces text in a ASCII (8-bit) string.

Arguments:

    psarList - SearchAndReplace structure with the list of tokens and
        and the strings that are going replace the tokens.

    pszString - the text to search and replace.

    dwSize - length of the text in pszString.

    dwExtraSize - if the buffer is reallocated, how much extra room to allocate

Return Value:

    None.

--*/
{
    LPSTR psz = *pszString;

    TraceFunc("SearchAndReplace( )\n");

    if ( !psarList || !*pszString )
        return;

    while ( *psz )
    {
        if ( *psz == '%' )
        {
            LPSAR psar = psarList;
            ULONG count = 0;
            LPSTR pszEnd;
            UCHAR ch;

            psz++;  // move forward

            //
            // Find the end of the %MACRO%
            //
            pszEnd = psz;
            while ( *pszEnd && *pszEnd !='%' )
                pszEnd++;

            //
            // Terminate but remember the character (NULL or '%')
            //
            ch = *pszEnd;
            *pszEnd = 0;

            //
            // Loop trying to match the %MACRO% when a Token
            //
            while( count++ < ArraySize ) {

                if ( lstrcmpiA( psz, psar->pszToken ) == 0 )
                {   // match, so replace
                    DWORD dwString;
                    DWORD dwToken;

                    if ( psar->pszStringA == NULL )
                    {
                        // need to translate the string from UNICODE to ANSI
                        DWORD dwLen;
                        ANSI_STRING aString;
                        UNICODE_STRING uString;

                        uString.Buffer = psar->pszStringW;
                        uString.Length = (USHORT)( wcslen( psar->pszStringW ) * sizeof(WCHAR) );

                        dwLen = RtlUnicodeStringToAnsiSize(&uString);  // includes NULL termination

                        psar->pszStringA = BinlAllocateMemory( dwLen );

                        if (psar->pszStringA == NULL) {
                            BinlAssert( !"Out of memory!" );
                            psar++;
                            continue; // abort this replace
                        }

                        aString.Buffer = psar->pszStringA;
                        aString.MaximumLength = (USHORT)dwLen;

                        RtlUnicodeStringToAnsiString(
                            &aString,
                            &uString,
                            FALSE);

                    }

                    dwString = strlen( psar->pszStringA );
                    dwToken  = strlen( psar->pszToken );

                    psz--;  // move back

                    if ( 2 + dwToken < dwString )
                    {
                        // "%MACRO%" is smaller than "ReplaceString"
                        // Check to see if we need to grow the buffer...
                        LPSTR pszEnd = &psz[2 + dwToken];
                        DWORD dwLenEnd = strlen( pszEnd ) + 1;
                        DWORD dwLenBegin = (DWORD)( psz - *pszString );
                        DWORD dwNewSize = dwLenBegin + dwString + dwLenEnd;

                        //
                        // Does the new string fit in the old space?
                        //
                        if ( dwSize < dwNewSize )
                        {
                            //
                            // No. Make some space
                            //
                            LPSTR pszNewString;

                            dwNewSize += 1024; // with some extra to grow

                            pszNewString =  BinlAllocateMemory( dwNewSize + dwExtraSize );
                            if ( !pszNewString )
                            {
                                BinlAssert( !"Out of memory!" );
                                return; // abort the rest
                            }

                            MoveMemory( pszNewString, *pszString, dwSize );

                            dwSize = dwNewSize;
                            psz = pszNewString + ( psz - *pszString );
                            BinlFreeMemory( *pszString );
                            *pszString = pszNewString;
                        }

                        MoveMemory( &psz[dwString], &psz[ 2 + dwToken ], dwLenEnd );
                    }

                    CopyMemory( psz, psar->pszStringA, dwString );

                    if ( 2 + dwToken > dwString )
                    {
                        strcpy( &psz[ dwString ], &psz[ 2 + dwToken ] );
                    }

                    pszEnd = NULL;  // match, NULL so we don't put the temp char back
                    psz++;          // move forward
                    break;
                }

                psar++;
            }

            //
            // If no match, put the character back
            //
            if ( pszEnd != NULL )
            {
                *pszEnd = ch;
            }
        }
        else
        {
            psz++;
        }
    }
}

LPSTR
FindSection(
    LPSTR sectionName,
    LPSTR sifFile
    )

/*++

Routine Description:


    This routine is for use by ProcessUniqueUdb. It scans in memory
    starting at sifFile, looking for a SIF section named "sectionName".
    Specifically it searches for a line whose first non-blank characters
    are "[sectionName]".

Arguments:

    sectionName - The section name to look for, an ANSI string.

    sifFile - The SIF file in memory, which is NULL-terminated ANSI string.

Return Value:

    A pointer to the start of the section -- the first character of the
        line after the one with [sectionName] in it.

--*/

{
    LPSTR curSifFile;
    DWORD lenSectionName;
    LPSTR foundSection = NULL;

    lenSectionName = strlen(sectionName);

    curSifFile = sifFile;

    while (*curSifFile != '\0') {

        //
        // At this point in the while, curSifFile points to the beginning
        // of a line.
        //

        //
        // First find the first non-blank character.
        //

        while ((*curSifFile != '\0') && (*curSifFile == ' ')) {
            ++curSifFile;
        }
        if (*curSifFile == '\0') {
            break;
        }

        if (*curSifFile == '[') {
            if ((memcmp(sectionName, curSifFile+1, lenSectionName) == 0) &&
                (curSifFile[lenSectionName+1] == ']')) {

                //
                // Found it, scan to start of next line.
                //
                while ((*curSifFile != '\0') && (*curSifFile != '\n')) {
                    ++curSifFile;
                }
                if (*curSifFile == '\0') {
                    break;
                }
                foundSection = curSifFile + 1;  // +1 to skip past the '\n'
                break;
            }
        }

        //
        // Now scan to the start of the next line, defined as the
        // character after a \n.
        //
        while ((*curSifFile != L'\0') && (*curSifFile != L'\n')) {
            ++curSifFile;
        }
        if (*curSifFile == L'\0') {
            break;
        }
        ++curSifFile;   // skip past the '\n'
    }

    return foundSection;
}

BOOLEAN
FindLineInSection(
    PCHAR SectionStart,
    PWCHAR lineToMatch,
    PCHAR *existingLine,
    DWORD *existingLineLen
    )

/*++

Routine Description:


    This routine is for use by ProcessUniqueUdb. It scans in memory
    starting at SectionStart, which is assumed to be the first line of
    a section of a .sif file. It looks for a line that is for the same
    value as lineToMatch, which will be of the form "value=name".
    If it is found, it returns the line that it was found on.

Arguments:

    SectionStart - The section of the .sif, in ANSI.

    lineToMatch - The value=name pair to match, in UNICODE.

    existingLine - Returns the existing line (in SectionStart), in ANSI.

    existingLineLen - Returns the length of the existing line, including
        final \r\n. Length is in characters, not bytes.

Return Value:

    TRUE of the line is found, FALSE otherwise.

--*/
{
    LPWSTR endOfValue;
    LPSTR curSection;
    LPSTR curLine;
    LPSTR endOfLine;
    DWORD valueLength, ansiValueLength;
    BOOLEAN foundLine = FALSE;
    LPSTR valueToMatch = NULL;
    ANSI_STRING aString;
    UNICODE_STRING uString;


    //
    // First look at lineToMatch to see what we are looking
    // for. This is the text up to the first =, or all of it if there
    // is no =. Once found, we convert it to ANSI for comparisons.
    //

    endOfValue = wcschr(lineToMatch, L'=');
    if (endOfValue == NULL) {
        endOfValue = lineToMatch + wcslen(lineToMatch);
    }

    valueLength = (DWORD)(endOfValue - lineToMatch);


    //
    // Copy the sectionName to ANSI for comparisons.
    //

    uString.Buffer = lineToMatch;
    uString.Length = (USHORT)(valueLength*sizeof(WCHAR));

    ansiValueLength = RtlUnicodeStringToAnsiSize(&uString);  // includes final '\0'
    valueToMatch = BinlAllocateMemory(ansiValueLength);
    if (valueToMatch == NULL) {
        return FALSE;
    }

    aString.Buffer = valueToMatch;
    aString.MaximumLength = (USHORT)ansiValueLength;
    RtlUnicodeStringToAnsiString(
        &aString,
        &uString,
        FALSE);

    --ansiValueLength;  // remove final '\0' from the count

    //
    // now scan each line of SectionStart, until we find the beginning
    // of another section, a \0, or the matching line.
    //

    curSection = SectionStart;

    while (*curSection != '\0') {

        //
        // At this point in the while, curSection points to the beginning
        // of a line. Save the start of the current line.
        //

        curLine = curSection;

        //
        // First find the first non-blank character.
        //

        while ((*curSection != '\0') && (*curSection == ' ')) {
            ++curSection;
        }

        //
        // If we hit \0, we didn't find it.
        //
        if (*curSection == '\0') {
            break;
        }

        //
        // If we hit a line starting with [, we didn't find it.
        //
        if (*curSection == '[') {
            break;
        }

        //
        // If we hit a line starting with what we expect, followed
        // by an =, \0, or a blank, we found it.
        //

        if (strncmp(curSection, valueToMatch, ansiValueLength) == 0) {
            if ((curSection[ansiValueLength] == '=') ||
                (curSection[ansiValueLength] == '\0') ||
                (curSection[ansiValueLength] == ' ')) {

                *existingLine = curLine;
                endOfLine = strchr(curLine, '\n');
                if (endOfLine == NULL) {
                    *existingLineLen = strlen(curLine);
                } else {
                    *existingLineLen = (DWORD)(endOfLine + 1 - curLine);
                }
                foundLine = TRUE;
                break;
            }
        }

        //
        // Now scan to the start of the next line, defined as the
        // character after a \n.
        //
        while ((*curSection != L'\0') && (*curSection != L'\n')) {
            ++curSection;
        }
        if (*curSection == L'\0') {
            break;
        }
        ++curSection;   // skip past the '\n'
    }

    if (valueToMatch != NULL) {
        BinlFreeMemory(valueToMatch);
    }

    return foundLine;
}

VOID
ProcessUniqueUdb(
    LPSTR *sifFilePtr,
    DWORD sifFileLen,
    LPWSTR UniqueUdbPath,
    LPWSTR UniqueUdbId
    )

/*++

Routine Description:


    Overlays data from a unique.udb file based on the tag specified. The
    file to overlay on is in memory at *pszString. *pszString is reallocated
    if necessary.

Arguments:

    sifFile - The file to overlay data on.

    sifFileLen - The current size of the data at *pszString (including final NULL).

    UniqueUdbPath - The path to the unique.udb file.

    UniqueUdbId - The ID in unique.udb to use.

Return Value:

    None.

--*/
{
    PWCHAR TmpBuffer = NULL;
    DWORD len, sifFileAlloc, lineLen;
    LONG sizeToAdd;
    LPSTR sifFile = *sifFilePtr;
    PWCHAR sectionList = NULL;
    PWCHAR sectionLoc, sectionCur;
    PWCHAR sectionName = NULL;
    PCHAR ansiRealSectionName = NULL;
    PCHAR sectionStart;
    PWCHAR profileSectionCur;
    PWCHAR realSectionName;
    PCHAR existingLine;
    DWORD existingLineLen;
    DWORD lenRealSectionName;
    PCHAR insertionPoint;
    ANSI_STRING aString;
    UNICODE_STRING uString;

#define TMP_BUFFER_SIZE 2048


    TraceFunc("ProcessUniqueUdb( )\n");

    TmpBuffer = BinlAllocateMemory(TMP_BUFFER_SIZE * sizeof(WCHAR));
    if (TmpBuffer == NULL) {
        return;
    }

    //
    // See if the ID appears in the [UniqueIds] section of the unique.udb file.
    //

    TmpBuffer[0] = L'\0';
    GetPrivateProfileString( L"UniqueIds",  // section name
                             UniqueUdbId,   // line name
                             L"",   // default
                             TmpBuffer,
                             TMP_BUFFER_SIZE,
                             UniqueUdbPath );

    if (TmpBuffer[0] == L'\0') {
        return;
    }

    //
    // sifFileAlloc is the size allocated for sifFile, whereas
    // sifFileLen is the amount actually used. They should only
    // be different while we are actively shuffling things
    // around.
    //

    sifFileAlloc = sifFileLen;

    //
    // Save the tmpbuffer result.
    //

    len = wcslen(TmpBuffer) + 1;
    sectionList = BinlAllocateMemory(len * sizeof(WCHAR));
    if (sectionList == NULL) {
        return;
    }

    wcscpy(sectionList, TmpBuffer);

    //
    // Now for each section identified in sectionList, scan for
    // the section to overlay.
    //

    sectionLoc = sectionList;
    while (TRUE) {

        //
        // First skip leading blanks
        //

        while (*sectionLoc && !iswalnum(*sectionLoc)) {
            //
            // Make sure we are not at a comment.
            //
            if (*sectionLoc == L';') {
                goto Cleanup;
            }
            ++sectionLoc;
        }
        if (!*sectionLoc) {
            goto Cleanup;
        }


        //
        // Now save sectionCur as the current section name
        // and skip to the end of it. Section names can be
        // any alphanumeric character, '.', or '_'.
        //
        sectionCur = sectionLoc;
        while((iswalnum(*sectionLoc)) ||
              (*sectionLoc == '.') ||
              (*sectionLoc == '_')) {
            ++sectionLoc;
        }

        //
        // Construct the new section name to look for. This will
        // be [UNIQUEUDBID:RealSectionName].
        //

        len = wcslen(UniqueUdbId) + (sectionLoc - sectionCur) + 2;  // one for :, one for NULL
        sectionName = BinlAllocateMemory(len * sizeof(WCHAR));
        if (sectionName == NULL) {
            goto Cleanup;
        }

        wcscpy(sectionName, UniqueUdbId);
        wcscat(sectionName, L":");
        len = wcslen(sectionName);
        realSectionName = sectionName + len;
        memcpy(realSectionName, sectionCur, (sectionLoc - sectionCur) * sizeof(WCHAR));
        realSectionName[sectionLoc - sectionCur] = L'\0';


        //
        // Copy the sectionName to ANSI for comparisons.
        //

        uString.Buffer = realSectionName;
        uString.Length = (USHORT)(wcslen(realSectionName)*sizeof(WCHAR));

        lenRealSectionName = RtlUnicodeStringToAnsiSize(&uString);  // includes final '\0'
        ansiRealSectionName = BinlAllocateMemory(lenRealSectionName);
        if (ansiRealSectionName == NULL) {
            goto Cleanup;
        }

        aString.Buffer = ansiRealSectionName;
        aString.MaximumLength = (USHORT)lenRealSectionName;
        RtlUnicodeStringToAnsiString(
            &aString,
            &uString,
            FALSE);
        --lenRealSectionName;  // remove final '\0' from count

        //
        // See if there is a section with that name.
        //

        TmpBuffer[0] = L'\0';
        GetPrivateProfileSection( sectionName,
                                  TmpBuffer,
                                  TMP_BUFFER_SIZE,
                                  UniqueUdbPath );

        if (TmpBuffer[0] == L'\0') {
            continue;
        }

        //
        // Got the contents of the section, now process it.
        //

        sectionStart = FindSection(ansiRealSectionName, sifFile);

        sizeToAdd = 0;  // amount we need to extend the buffer by.

        if (sectionStart == NULL) {

            //
            // No section, so need to add room for it.
            //
            // We put a CR-LF combo, then the section name in [], then
            // another CR-LF.
            //

            sizeToAdd = lenRealSectionName + 6;

        }

        //
        // Now scan through the entries in the profile section.
        //

        profileSectionCur = TmpBuffer;

        while (*profileSectionCur != L'\0') {

            uString.Buffer = profileSectionCur;
            uString.Length = (USHORT)(wcslen(profileSectionCur) * sizeof(WCHAR));

            //
            // Figure out how long profileSectionCur will be as an
            // ANSI string (may have DBCS data in it).
            //

            lineLen = RtlUnicodeStringToAnsiSize(&uString); // includes \0 termination
            --lineLen;  // remove the \0 from the count

            //
            // If there is no existing section we have to add it;
            // if not, see if there is a line for this already.
            //

            if (sectionStart == NULL) {
                sizeToAdd += lineLen + 2;  // +2 is for CR-LF
            } else {
                if (FindLineInSection(sectionStart,
                                      profileSectionCur,
                                      &existingLine,
                                      &existingLineLen)) {
                    //
                    // Need to remove current line.
                    //
                    memmove(existingLine, existingLine + existingLineLen,
                                sifFileLen - ((existingLine - sifFile) + existingLineLen));

                    sizeToAdd += lineLen + 2 - existingLineLen;
                    sifFileLen -= existingLineLen;

                } else {

                    sizeToAdd += lineLen + 2;
                }
            }

            profileSectionCur += wcslen(profileSectionCur) + 1;
        }

        //
        // Now we need to reallocate the buffer if needed.
        //

        if (sizeToAdd > 0) {

            //
            // No. Make some space
            //
            LPSTR pszNewString;

            pszNewString =  BinlAllocateMemory( sifFileAlloc + sizeToAdd );
            if ( !pszNewString )
            {
                return; // abort the rest
            }

            MoveMemory( pszNewString, sifFile, sifFileLen);

            BinlFreeMemory( sifFile );
            //
            // Adjust sectionStart to be within the new buffer.
            //
            if (sectionStart != NULL) {
                sectionStart = pszNewString + (sectionStart - sifFile);
            }
            sifFile = pszNewString;
            *sifFilePtr = pszNewString;
            sifFileAlloc += sizeToAdd;
        }

        //
        // Add the section header if necessary.
        //

        if (sectionStart == NULL) {
            strcpy(sifFile + sifFileLen - 1, "\r\n[");
            sifFileLen += 3;
            strcpy(sifFile + sifFileLen - 1, ansiRealSectionName);
            sifFileLen += lenRealSectionName;
            strcpy(sifFile + sifFileLen - 1, "]\r\n");
            sifFileLen += 3;
            sectionStart = sifFile + sifFileLen - 1;
        }

        //
        // Now add the items from the profile section. We know that
        // they do not exist in the file and that we have reallocated
        // the file buffer to be large enough.
        //

        profileSectionCur = TmpBuffer;
        insertionPoint = sectionStart;

        while (*profileSectionCur != L'\0') {

            uString.Buffer = profileSectionCur;
            uString.Length = (USHORT)(wcslen(profileSectionCur)*sizeof(WCHAR));

            lineLen = RtlUnicodeStringToAnsiSize(&uString);  // includes final '\0'
            --lineLen;  // remove final '\0' from count

            //
            // move anything we need to down and insert the new line.
            //

            memmove(insertionPoint + lineLen + 2, insertionPoint, sifFileLen - (insertionPoint - sifFile));

            aString.Buffer = insertionPoint;
            aString.MaximumLength = (USHORT)(lineLen+1);
            RtlUnicodeStringToAnsiString(
                &aString,
                &uString,
                FALSE);
            memcpy(insertionPoint + lineLen, "\r\n", 2);
            sifFileLen += lineLen + 2;
            insertionPoint += lineLen + 2;

            profileSectionCur += wcslen(profileSectionCur) + 1;
        }

    }

Cleanup:

    if (sectionList != NULL) {
        BinlFreeMemory(sectionList);
    }
    if (sectionName != NULL) {
        BinlFreeMemory(sectionName);
    }
    if (ansiRealSectionName != NULL) {
        BinlFreeMemory(ansiRealSectionName);
    }
    if (TmpBuffer != NULL) {
        BinlFreeMemory(TmpBuffer);
    }

    ASSERT (sifFileLen <= sifFileAlloc);
}
//
// OscFindVariableA( )
//
LPSTR
OscFindVariableA(
    PCLIENT_STATE clientState,
    LPSTR variableName )        // variable name are always ASCII until OSChooser
                                // can handle Unicode.
{
    ULONG i;
    static CHAR szNullStringA[1] = { '\0' };
    LPSTR overrideValue;

    //
    // First check to see if this a query we are supposed to override.
    //
    if (strcmp(variableName, "SIF") == 0) {

        overrideValue = OscFindVariableA(clientState, "FORCESIFFILE");

        if ((overrideValue != NULL) && (strlen(overrideValue) != 0)) {
            return overrideValue;
        }

    }

    for( i = 0; i < clientState->nVariables; i++ )
    {
        if ( strcmp( clientState->Variables[i].pszToken, variableName ) == 0 )
        {
            if ( clientState->Variables[i].pszStringA == NULL )
            {
                DWORD dwLen;
                ANSI_STRING aString;
                UNICODE_STRING uString;

                uString.Buffer = clientState->Variables[i].pszStringW;
                uString.Length = (USHORT)( wcslen( clientState->Variables[i].pszStringW ) * sizeof(WCHAR) );

                dwLen = RtlUnicodeStringToAnsiSize( &uString );  // includes NULL termination

                clientState->Variables[i].pszStringA = BinlAllocateMemory( dwLen );
                if ( !(clientState->Variables[i].pszStringA) )
                    break;  // out of memory

                aString.Buffer = clientState->Variables[i].pszStringA;
                aString.MaximumLength = (USHORT)dwLen;

                RtlUnicodeStringToAnsiString(
                    &aString,
                    &uString,
                    FALSE);
            }

            return clientState->Variables[i].pszStringA;
        }
    }

    return szNullStringA;
}

//
// OscFindVariableW( )
//
LPWSTR
OscFindVariableW(
    PCLIENT_STATE clientState,
    LPSTR variableName  )       // variable name are always ASCII until OSChooser
                                // can handle Unicode.
{
    ULONG i;
    static WCHAR szNullStringW[1] = { L'\0' };
    LPWSTR overrideValue;

    //
    // First check to see if this a query we are supposed to override.
    //
    if (strcmp(variableName, "SIF") == 0) {

        overrideValue = OscFindVariableW(clientState, "FORCESIFFILE");

        if ((overrideValue != NULL) && (wcslen(overrideValue) != 0)) {
            return overrideValue;
        }

    }

    for( i = 0; i < clientState->nVariables; i++ )
    {
        if ( strcmp( clientState->Variables[i].pszToken, variableName ) == 0 )
        {
            if ( clientState->Variables[i].pszStringW == NULL )
            {
                DWORD dwLen = _mbslen( clientState->Variables[i].pszStringA ) + 1;
                ANSI_STRING aString;
                UNICODE_STRING uString;

                clientState->Variables[i].pszStringW = BinlAllocateMemory( dwLen * sizeof(WCHAR) );
                if ( !(clientState->Variables[i].pszStringW) )
                    break;  // out of memory

                uString.Buffer = clientState->Variables[i].pszStringW;
                uString.MaximumLength = (USHORT)(dwLen * sizeof(WCHAR));

                aString.Buffer = clientState->Variables[i].pszStringA;
                aString.Length = (USHORT)strlen( clientState->Variables[i].pszStringA );

                RtlAnsiStringToUnicodeString(
                    &uString,
                    &aString,
                    FALSE);
            }

            return clientState->Variables[i].pszStringW;
        }
    }

    return szNullStringW;
}

//
// OscCheckVariableLength( )
//
BOOLEAN
OscCheckVariableLength(
    PCLIENT_STATE clientState,
    LPSTR        variableName,
    ULONG        variableLength )
{
    ULONG i;

    for (i = 0; i < OSC_VARIABLE_MAXIMUM_COUNT; i++) {
        if (strcmp(OscMaximums[i].VariableName, variableName) == 0) {
            if (variableLength > OscMaximums[i].MaximumLength) {
                BinlPrintDbg((DEBUG_OSC_ERROR, "Variable %s was %d bytes, only %d allowed\n",
                           variableName,
                           variableLength,
                           OscMaximums[i].MaximumLength));
                OscAddVariableA( clientState, "SUBERROR", variableName );
                return FALSE;
            } else {
                return TRUE;
            }
        }
    }

    //
    // If we don't find it in our list of maximums, it is OK.
    //

    return TRUE;
}

//
// OscAddVariableA( )
//
DWORD
OscAddVariableA(
    PCLIENT_STATE clientState,
    LPSTR        variableName,  // variable name are always ASCII until OSChooser
                                // can handle Unicode.
    LPSTR        variableValue )
{
    ULONG i;

    if ( variableValue == NULL )
        return E_POINTER;  // no value to add... abort

    if (!OscCheckVariableLength(clientState, variableName, strlen(variableValue))) {
        return E_INVALIDARG;
    }

    for( i = 0; i < clientState->nVariables; i++ )
    {

        if ( strcmp( clientState->Variables[i].pszToken, variableName ) == 0 )
        {
            ULONG l = strlen( variableValue );

            if ( clientState->Variables[i].pszStringW != NULL )
            {
                BinlFreeMemory( clientState->Variables[i].pszStringW );
                clientState->Variables[i].pszStringW = NULL;
            }

            if ( clientState->Variables[i].pszStringA != NULL )
            { // found a previous one

                // Don't replace values with ""
                if ( variableValue[0] == '\0' ) {
                    break;
                } else {
                    // replace it with the new one
                    if ( l <= strlen( clientState->Variables[i].pszStringA ) )
                    {
                        strcpy( clientState->Variables[i].pszStringA, variableValue );
                    }
                    else
                    {
                        // need more space, delete the old
                        BinlFreeMemory( clientState->Variables[i].pszStringA );
                        clientState->Variables[i].pszStringA = NULL;
                    }
                }
            }

            break;
        }
    }

    //
    // Limit the number of variables we can have. Everything else is ignored.
    //
    if ( clientState->nVariables == MAX_VARIABLES &&
         clientState->nVariables == i )
        return E_OUTOFMEMORY;

    //
    // Adding a new one
    //
    if ( clientState->nVariables == i )
    {
        clientState->Variables[i].pszToken = BinlStrDupA( variableName );

        if (clientState->Variables[i].pszToken == NULL) {
            return E_OUTOFMEMORY;
        }

        clientState->nVariables++;
    }

    //
    // If this is a new one or a new Value for an existing variable
    // that does not fit in the old values space, create a dup of the
    // value.
    //
    if ( clientState->Variables[i].pszStringA == NULL )
    {
        BinlAssert( variableValue != NULL );
        clientState->Variables[i].pszStringA = BinlStrDupA( variableValue );

        if (clientState->Variables[i].pszStringA == NULL) {

            if ((i + 1) == clientState->nVariables) {
                clientState->nVariables--;
                BinlFreeMemory(clientState->Variables[i].pszToken);
            }

            return E_OUTOFMEMORY;
        }

        //
        // The "OPTIONS" variable can have a lot of stuff in it and will
        // blow up the BinlPrint(). Just avoid the whole mess by not
        // printing it
        //

        if ( lstrcmpA( clientState->Variables[i].pszToken, "OPTIONS" ) != 0 ) {
            BinlPrintDbg((DEBUG_OSC, "Add Var:'%s' = '%s'\n",
                       clientState->Variables[i].pszToken,
                       clientState->Variables[i].pszStringA ));
        }
    }

    //
    // it will be converted to UNICODE when OscFindVariableW( ) is called
    //

    return ERROR_SUCCESS;
}

//
// OscAddVariableW( )
//
DWORD
OscAddVariableW(
    PCLIENT_STATE clientState,
    LPSTR        variableName,  // variable name are always ASCII until OSChooser
                                // can handle Unicode.
    LPWSTR       variableValue )
{
    ULONG i;

    if ( variableValue == NULL )
        return E_POINTER;  // no value to add... abort

    if (!OscCheckVariableLength(clientState, variableName, wcslen(variableValue))) {
        return E_INVALIDARG;
    }

    for( i = 0; i < clientState->nVariables; i++ )
    {
        if ( strcmp( clientState->Variables[i].pszToken, variableName ) == 0 )
        {
            if ( clientState->Variables[i].pszStringA != NULL )
            {
                BinlFreeMemory( clientState->Variables[i].pszStringA );
                clientState->Variables[i].pszStringA = NULL;
            }

            if ( clientState->Variables[i].pszStringW != NULL )
            { // found a previous one

                // Don't replace values with ""
                if ( variableValue[0] == L'\0' ) {
                    break;
                } else {
                    // replace it with the new one
                    ULONG Length = wcslen( variableValue );
                    if ( Length < wcslen( clientState->Variables[i].pszStringW ) )
                    {
                        wcscpy( clientState->Variables[i].pszStringW, variableValue );
                    }
                    else
                    {
                        // need more space, delete the old
                        BinlFreeMemory( clientState->Variables[i].pszStringW );
                        clientState->Variables[i].pszStringW = NULL;
                    }
                }
            }

            break;
        }
    }

    //
    // Limit the number of variables we can have. Everything else is ignored.
    //
    if ( clientState->nVariables == MAX_VARIABLES &&
         clientState->nVariables == i )
        return E_OUTOFMEMORY;   // out of space

    //
    // Adding a new one
    //
    if ( clientState->nVariables == i )
    {
        clientState->Variables[i].pszToken = BinlStrDupA( variableName );

        if (clientState->Variables[i].pszToken == NULL) {
            return E_OUTOFMEMORY;
        }

        clientState->nVariables++;
    }

    //
    // If this is a new one or a new Value for an existing variable
    // that does not fit in the old values space, create a dup of the
    // value.
    //
    if ( clientState->Variables[i].pszStringW == NULL )
    {
        BinlAssert( variableValue != NULL );
        clientState->Variables[i].pszStringW = BinlStrDupW( variableValue);

        if (clientState->Variables[i].pszStringW == NULL) {

            if ((i + 1) == clientState->nVariables) {
                clientState->nVariables--;
                BinlFreeMemory(clientState->Variables[i].pszToken);
            }

            return E_OUTOFMEMORY;
        }


        BinlPrintDbg((DEBUG_OSC, "Add Var:'%s' = '%ws'\n",
                   clientState->Variables[i].pszToken,
                   clientState->Variables[i].pszStringW ));
    }

    //
    // it will be converted to ASCII when OscFindVariableA( ) is called
    //

    return ERROR_SUCCESS;
}

//
// OscResetVariable( )
//
VOID
OscResetVariable(
    PCLIENT_STATE clientState,
    LPSTR        variableName
    )
{
    ULONG i;
    BOOLEAN found = FALSE;

    for( i = 0; i < clientState->nVariables; i++ ) {
        if ( strcmp( clientState->Variables[i].pszToken, variableName ) == 0 ) {

            if ( clientState->Variables[i].pszStringA != NULL ) {

                BinlFreeMemory( clientState->Variables[i].pszStringA );
                clientState->Variables[i].pszStringA = NULL;
            }

            if ( clientState->Variables[i].pszStringW != NULL ) { // found a previous one

                BinlFreeMemory( clientState->Variables[i].pszStringW );
                clientState->Variables[i].pszStringW = NULL;
            }
            BinlPrintDbg((DEBUG_OSC, "Deleted Var:'%s'\n",
                       clientState->Variables[i].pszToken ));
            BinlFreeMemory( clientState->Variables[i].pszToken );
            found = TRUE;
            break;
        }
    }

    if (found) {

        //
        // move all existing ones up.
        //

        while (i < clientState->nVariables) {

            clientState->Variables[i].pszToken = clientState->Variables[i+1].pszToken;
            clientState->Variables[i].pszStringA = clientState->Variables[i+1].pszStringA;
            clientState->Variables[i].pszStringW = clientState->Variables[i+1].pszStringW;
            i++;
        }
        clientState->nVariables--;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains debugging macros for the BINL server.

Author:

    Madan Appiah  (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:


--*/

#include "binl.h"
#pragma hdrstop

const char g_szTrue[] = "True";
const char g_szFalse[] = "False";

VOID
DebugInitialize (
    VOID
    )
{
    DWORD dwErr;
    HKEY KeyHandle;

    InitializeCriticalSection(&BinlGlobalDebugFileCritSect);
    BinlGlobalDebugFileHandle = NULL;

    BinlGlobalDebugFileMaxSize = DEFAULT_MAXIMUM_DEBUGFILE_SIZE;
    BinlGlobalDebugSharePath = NULL;

    // Read DebugFlags value
    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                BINL_PARAMETERS_KEY,
                0,
                KEY_QUERY_VALUE,
                &KeyHandle );
    if ( dwErr == ERROR_SUCCESS ) {
        BinlGlobalDebugFlag = ReadDWord( KeyHandle, BINL_DEBUG_KEY, 0 );
        BinlPrintDbg(( DEBUG_OPTIONS, "Debug Flags = 0x%08x.\n", BinlGlobalDebugFlag ));
        RegCloseKey( KeyHandle );
    }

#if DBG
    // break in the debugger if we are asked to do so.
    if(BinlGlobalDebugFlag & DEBUG_STARTUP_BRK) {
        BinlPrintDbg(( 0, "Stopping at DebugInitialize()'s DebugBreak( ).\n" ));
        DebugBreak();
    }
#endif

    //
    // Open debug log file.
    //

    if ( BinlGlobalDebugFlag & DEBUG_LOG_IN_FILE ) {
        BinlOpenDebugFile( FALSE );  // not a reopen.
    }

} // DebugInitialize

VOID
DebugUninitialize (
    VOID
    )
{
    EnterCriticalSection( &BinlGlobalDebugFileCritSect );
    if ( BinlGlobalDebugFileHandle != NULL ) {
        CloseHandle( BinlGlobalDebugFileHandle );
        BinlGlobalDebugFileHandle = NULL;
    }

    if( BinlGlobalDebugSharePath != NULL ) {
        BinlFreeMemory( BinlGlobalDebugSharePath );
        BinlGlobalDebugSharePath = NULL;
    }

    LeaveCriticalSection( &BinlGlobalDebugFileCritSect );

    DeleteCriticalSection( &BinlGlobalDebugFileCritSect );

} // DebugUninitialize

VOID
BinlOpenDebugFile(
    IN BOOL ReopenFlag
    )
/*++

Routine Description:

    Opens or re-opens the debug file

Arguments:

    ReopenFlag - TRUE to indicate the debug file is to be closed, renamed,
        and recreated.

Return Value:

    None

--*/

{
    WCHAR LogFileName[500];
    WCHAR BakFileName[500];
    DWORD FileAttributes;
    DWORD PathLength;
    DWORD WinError;

    //
    // Close the handle to the debug file, if it is currently open
    //

    EnterCriticalSection( &BinlGlobalDebugFileCritSect );
    if ( BinlGlobalDebugFileHandle != NULL ) {
        CloseHandle( BinlGlobalDebugFileHandle );
        BinlGlobalDebugFileHandle = NULL;
    }
    LeaveCriticalSection( &BinlGlobalDebugFileCritSect );

    //
    // make debug directory path first, if it is not made before.
    //
    if( BinlGlobalDebugSharePath == NULL ) {

        if ( !GetWindowsDirectoryW(
                LogFileName,
                sizeof(LogFileName)/sizeof(WCHAR) ) ) {
            BinlPrintDbg((DEBUG_ERRORS, "Window Directory Path can't be "
                        "retrieved, %lu.\n", GetLastError() ));
            return;
        }

        //
        // check debug path length.
        //

        PathLength = wcslen(LogFileName) * sizeof(WCHAR) +
                        sizeof(DEBUG_DIR) + sizeof(WCHAR);

        if( (PathLength + sizeof(DEBUG_FILE) > sizeof(LogFileName) )  ||
            (PathLength + sizeof(DEBUG_BAK_FILE) > sizeof(BakFileName) ) ) {

            BinlPrintDbg((DEBUG_ERRORS, "Debug directory path (%ws) length is too long.\n",
                        LogFileName));
            goto ErrorReturn;
        }

        wcscat(LogFileName, DEBUG_DIR);

        //
        // copy debug directory name to global var.
        //

        BinlGlobalDebugSharePath =
            BinlAllocateMemory( (wcslen(LogFileName) + 1) * sizeof(WCHAR) );

        if( BinlGlobalDebugSharePath == NULL ) {
            BinlPrintDbg((DEBUG_ERRORS, "Can't allocate memory for debug share "
                                    "(%ws).\n", LogFileName));
            goto ErrorReturn;
        }

        wcscpy(BinlGlobalDebugSharePath, LogFileName);
    }
    else {
        wcscpy(LogFileName, BinlGlobalDebugSharePath);
    }

    //
    // Check this path exists.
    //

    FileAttributes = GetFileAttributesW( LogFileName );

    if( FileAttributes == 0xFFFFFFFF ) {

        WinError = GetLastError();
        if( WinError == ERROR_FILE_NOT_FOUND ) {

            //
            // Create debug directory.
            //

            if( !CreateDirectoryW( LogFileName, NULL) ) {
                BinlPrintDbg((DEBUG_ERRORS, "Can't create Debug directory (%ws), "
                            "%lu.\n", LogFileName, GetLastError() ));
                goto ErrorReturn;
            }

        }
        else {
            BinlPrintDbg((DEBUG_ERRORS, "Can't Get File attributes(%ws), "
                        "%lu.\n", LogFileName, WinError ));
            goto ErrorReturn;
        }
    }
    else {

        //
        // if this is not a directory.
        //

        if(!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            BinlPrintDbg((DEBUG_ERRORS, "Debug directory path (%ws) exists "
                         "as file.\n", LogFileName));
            goto ErrorReturn;
        }
    }

    //
    // Create the name of the old and new log file names
    //

    (VOID) wcscpy( BakFileName, LogFileName );
    (VOID) wcscat( LogFileName, DEBUG_FILE );
    (VOID) wcscat( BakFileName, DEBUG_BAK_FILE );


    //
    // If this is a re-open,
    //  delete the backup file,
    //  rename the current file to the backup file.
    //

    if ( ReopenFlag ) {

        if ( !DeleteFile( BakFileName ) ) {
            WinError = GetLastError();
            if ( WinError != ERROR_FILE_NOT_FOUND ) {
                BinlPrintDbg((DEBUG_ERRORS,
                    "Cannot delete %ws (%ld)\n",
                    BakFileName,
                    WinError ));
                BinlPrintDbg((DEBUG_ERRORS, "   Try to re-open the file.\n"));
                ReopenFlag = FALSE;     // Don't truncate the file
            }
        }
    }

    if ( ReopenFlag ) {
        if ( !MoveFile( LogFileName, BakFileName ) ) {
            BinlPrintDbg((DEBUG_ERRORS,
                    "Cannot rename %ws to %ws (%ld)\n",
                    LogFileName,
                    BakFileName,
                    GetLastError() ));
            BinlPrintDbg((DEBUG_ERRORS,
                "   Try to re-open the file.\n"));
            ReopenFlag = FALSE;     // Don't truncate the file
        }
    }

    //
    // Open the file.
    //

    EnterCriticalSection( &BinlGlobalDebugFileCritSect );
    BinlGlobalDebugFileHandle = CreateFileW( LogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  ReopenFlag ? CREATE_ALWAYS : OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );


    if ( BinlGlobalDebugFileHandle == INVALID_HANDLE_VALUE ) {
        BinlPrintDbg((DEBUG_ERRORS,  "cannot open %ws ,\n",
                    LogFileName ));
        LeaveCriticalSection( &BinlGlobalDebugFileCritSect );
        goto ErrorReturn;
    } else {
        // Position the log file at the end
        (VOID) SetFilePointer( BinlGlobalDebugFileHandle,
                               0,
                               NULL,
                               FILE_END );
    }

    LeaveCriticalSection( &BinlGlobalDebugFileCritSect );
    return;

ErrorReturn:
    BinlPrintDbg((DEBUG_ERRORS,
            "   Debug output will be written to debug terminal.\n"));
    return;
}


VOID
BinlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length;
    DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    LPSTR Text;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (BinlGlobalDebugFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &BinlGlobalDebugFileCritSect );
    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // If the log file is getting huge,
        //  truncate it.
        //

        if ( BinlGlobalDebugFileHandle != NULL &&
             !TruncateLogFileInProgress ) {

            //
            // Only check every 50 lines,
            //

            LineCount++;
            if ( LineCount >= 50 ) {
                DWORD FileSize;
                LineCount = 0;

                //
                // Is the log file too big?
                //

                FileSize = GetFileSize( BinlGlobalDebugFileHandle, NULL );
                if ( FileSize == 0xFFFFFFFF ) {
                    (void) DbgPrint( "[BinlServer] Cannot GetFileSize %ld\n",
                                     GetLastError() );
                } else if ( FileSize > BinlGlobalDebugFileMaxSize ) {
                    TruncateLogFileInProgress = TRUE;
                    LeaveCriticalSection( &BinlGlobalDebugFileCritSect );
                    BinlOpenDebugFile( TRUE );
                    BinlPrint(( DEBUG_MISC,
                              "Logfile truncated because it was larger than %ld bytes\n",
                              BinlGlobalDebugFileMaxSize ));
                    EnterCriticalSection( &BinlGlobalDebugFileCritSect );
                    TruncateLogFileInProgress = FALSE;
                }

            }
        }

        //  Indicate this is a BINL server's message.

        length += (ULONG) sprintf( &OutputBuffer[length], "[BinlServer] " );

        //
        // Put the thread id at the begining of the line.
        //
        if (BinlGlobalDebugFlag & DEBUG_THREAD) {
            DWORD threadId = GetCurrentThreadId();
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%08x ", threadId );
        }

        //
        // Put the timestamp at the begining of the line.
        //
        if (BinlGlobalDebugFlag & DEBUG_TIMESTAMP) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }

        //
        // Indicate the type of message on the line
        //
        switch (DebugFlag) {
            case DEBUG_OPTIONS:
                Text = "OPTIONS";
                break;

            case DEBUG_ERRORS:
                Text = "ERRORS";
                break;

            case DEBUG_STOC:
                Text = "STOC";
                break;

            case DEBUG_INIT:
                Text = "INIT";
                break;

            case DEBUG_SCAVENGER:
                Text = "SCAVENGER";
                break;

            case DEBUG_REGISTRY:
                Text = "REGISTRY";
                break;

            case DEBUG_NETINF:
                Text = "NETINF";
                break;

            case DEBUG_MISC:
                Text = "MISC";
                break;

            case DEBUG_MESSAGE:
                Text = "MESSAGE";
                break;

            case DEBUG_LOG_IN_FILE:
                Text = "LOG_IN_FILE";
                break;

            default:
                Text = NULL;
                break;
        }

        if ( Text != NULL ) {
            length += (ULONG) sprintf( &OutputBuffer[length], "[%s] ", Text );
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );

    va_end(arglist);

    // Add in the fix for notepad users and fixing the assert
    BinlAssert(length < MAX_PRINTF_LEN - 1);
    if(BeginningOfLine){
        OutputBuffer[length-1] = '\r';
        OutputBuffer[length] = '\n';
        length++;
        OutputBuffer[length] = '\0';
    }



    //
    // Output to the debug terminal,
    //  if the log file isn't open or we are asked to do so.
    //

    if ( (BinlGlobalDebugFileHandle == NULL) ||
         !(BinlGlobalDebugFlag & DEBUG_LOG_IN_FILE) ) {

        //
        // Don't use DbgPrint(OutputBuffer) here because the buffer
        // might contain strings that printf will try to interpret
        // (e.g., NewMachineNamingPolicy = %1Fist%Last%#).
        //

        (void) DbgPrint( "%s", (PCH)OutputBuffer);

    //
    // Write the debug info to the log file.
    //

    } else {
        if ( !WriteFile( BinlGlobalDebugFileHandle,
                         OutputBuffer,
                         lstrlenA( OutputBuffer ),
                         &BytesWritten,
                         NULL ) ) {
            (void) DbgPrint( "%s", (PCH) OutputBuffer);
        }

    }

    LeaveCriticalSection( &BinlGlobalDebugFileCritSect );

}

#if DBG

VOID
BinlAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{
    RtlAssert(
            FailedAssertion,
            FileName,
            (ULONG) LineNumber,
            (PCHAR) Message);

    BinlPrintDbg(( 0, "Assert @ %s \n", FailedAssertion ));
    BinlPrintDbg(( 0, "Assert Filename, %s \n", FileName ));
    BinlPrintDbg(( 0, "Line Num. = %ld.\n", LineNumber ));
    BinlPrintDbg(( 0, "Message is %s\n", Message ));
#if DBG
    DebugBreak( );
#endif
}

VOID
BinlDumpMessage(
    DWORD BinlDebugFlag,
    LPDHCP_MESSAGE BinlMessage
    )
/*++

Routine Description:

    This function dumps a DHCP packet in human readable form.

Arguments:

    BinlDebugFlag - debug flag that indicates what we are debugging.

    BinlMessage - A pointer to a DHCP message.

Return Value:

    None.

--*/
{
    LPOPTION option;
    BYTE i;

    BinlPrintDbg(( BinlDebugFlag, "Binl message: \n\n"));

    BinlPrintDbg(( BinlDebugFlag, "Operation              :"));
    if ( BinlMessage->Operation == BOOT_REQUEST ) {
        BinlPrintDbg(( BinlDebugFlag,  "BootRequest\n"));
    } else if ( BinlMessage->Operation == BOOT_REPLY ) {
        BinlPrintDbg(( BinlDebugFlag,  "BootReply\n"));
    } else {
        BinlPrintDbg(( BinlDebugFlag,  "Unknown %x\n", BinlMessage->Operation));
        return;
    }

    BinlPrintDbg(( BinlDebugFlag, "Hardware Address type  : %d\n", BinlMessage->HardwareAddressType));
    BinlPrintDbg(( BinlDebugFlag, "Hardware Address Length: %d\n", BinlMessage->HardwareAddressLength));
    BinlPrintDbg(( BinlDebugFlag, "Hop Count              : %d\n", BinlMessage->HopCount ));
    BinlPrintDbg(( BinlDebugFlag, "Transaction ID         : %lx\n", BinlMessage->TransactionID ));
    BinlPrintDbg(( BinlDebugFlag, "Seconds Since Boot     : %d\n", BinlMessage->SecondsSinceBoot ));
    BinlPrintDbg(( BinlDebugFlag, "Client IP Address      : " ));
    BinlPrintDbg(( BinlDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->ClientIpAddress ) ));

    BinlPrintDbg(( BinlDebugFlag, "Your IP Address        : " ));
    BinlPrintDbg(( BinlDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->YourIpAddress ) ));

    BinlPrintDbg(( BinlDebugFlag, "Server IP Address      : " ));
    BinlPrintDbg(( BinlDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->BootstrapServerAddress ) ));

    BinlPrintDbg(( BinlDebugFlag, "Relay Agent IP Address : " ));
    BinlPrintDbg(( BinlDebugFlag, "%s\n",
        inet_ntoa(*(struct in_addr *)&BinlMessage->RelayAgentIpAddress ) ));

    BinlPrintDbg(( BinlDebugFlag, "Hardware Address       : "));
    for ( i = 0; i < BinlMessage->HardwareAddressLength; i++ ) {
        BinlPrintDbg(( BinlDebugFlag, "%2.2x", BinlMessage->HardwareAddress[i] ));
    }

    option = &BinlMessage->Option;

    BinlPrintDbg(( BinlDebugFlag, "\n\n"));
    BinlPrintDbg(( BinlDebugFlag, "Magic Cookie: "));
    for ( i = 0; i < 4; i++ ) {
        BinlPrintDbg(( BinlDebugFlag, "%d ", *((LPBYTE)option)++ ));
    }
    BinlPrintDbg(( BinlDebugFlag, "\n\n"));

    BinlPrintDbg(( BinlDebugFlag, "Options:\n"));
    while ( option->OptionType != 255 ) {
        BinlPrintDbg(( BinlDebugFlag, "\tType = %d ", option->OptionType ));
        for ( i = 0; i < option->OptionLength; i++ ) {
            BinlPrintDbg(( BinlDebugFlag, "%2.2x", option->OptionValue[i] ));
        }
        BinlPrintDbg(( BinlDebugFlag, "\n"));

        if ( option->OptionType == OPTION_PAD ||
             option->OptionType == OPTION_END ) {

            option = (LPOPTION)( (LPBYTE)(option) + 1);

        } else {

            option = (LPOPTION)( (LPBYTE)(option) + option->OptionLength + 2);

        }

        if ( (LPBYTE)option - (LPBYTE)BinlMessage > DHCP_MESSAGE_SIZE ) {
            BinlPrintDbg(( BinlDebugFlag, "End of message, but no trailer found!\n"));
            break;
        }
    }
}
#endif // DBG


DWORD
BinlReportEventW(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //

    EventlogHandle = RegisterEventSourceW(NULL, BINL_SERVER);

    if (EventlogHandle == NULL) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //

    if( !ReportEventW(
            EventlogHandle,
            (WORD)EventType,
            0,            // event category
            EventID,
            NULL,
            (WORD)NumStrings,
            DataLength,
            Strings,
            Data
            ) ) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {

        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


DWORD
BinlReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    Source - Points to a null-terminated string that specifies the name
             of the module referenced. The node must exist in the
             registration database, and the module name has the
             following format:

                \EventLog\System\Lanmanworkstation

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //

    EventlogHandle = RegisterEventSourceW(
                    NULL,
                    BINL_SERVER
                    );

    if (EventlogHandle == NULL) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //

    if( !ReportEventA(
            EventlogHandle,
            (WORD)EventType,
            0,            // event category
            EventID,
            NULL,
            (WORD)NumStrings,
            DataLength,
            Strings,
            Data
            ) ) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {

        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}

VOID
BinlServerEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    )
/*++

Routine Description:

    Logs an event in EventLog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event


    ErrorCode - Error Code to be Logged.

Return Value:

    None.

--*/

{
    DWORD Error;
    LPSTR Strings[1];
    CHAR ErrorCodeOemString[32 + 1];

    wsprintfA( ErrorCodeOemString, "%lu", ErrorCode );

    Strings[0] = ErrorCodeOemString;

    Error = BinlReportEventA(
                EventID,
                EventType,
                1,
                sizeof(ErrorCode),
                Strings,
                &ErrorCode );

    if( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_ERRORS,
            "BinlReportEventW failed, %ld.\n", Error ));
    }

    return;
}


#if DBG==1

//
// Memory allocation and tracking
//

LPVOID g_TraceMemoryTable = NULL;
CRITICAL_SECTION g_TraceMemoryCS;


#define DEBUG_OUTPUT_BUFFER_SIZE 1024

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    struct _MEMORYBLOCK *pNext;
    LPCSTR pszModule;
    LPCSTR pszComment;
    LPCSTR pszFile;
    DWORD   dwBytes;
    UINT    uFlags;
    UINT    uLine;    
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPSTR
dbgmakefilelinestring(
    LPSTR  pszBuf,
    LPCSTR pszFile,
    UINT    uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = (LPVOID) UintToPtr( uLine );

    FormatMessageA(
        FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        "%1(%2!u!):",
        0,                          // error code
        0,                          // default language
        (LPSTR) pszBuf,             // output buffer
        DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
        (va_list*) &args );         // arguments

    return pszBuf;
}

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCSTR pszFile,
    UINT    uLine,
    LPCSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc(
                                                    GMEM_FIXED,
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;

        EnterCriticalSection( &g_TraceMemoryCS );

        pmb->pNext         = g_TraceMemoryTable;
        g_TraceMemoryTable = pmb;

        BinlPrintDbg((DEBUG_MEMORY, "DebugAlloc: 0x%08x alloced (%s)\n", hglobal, pmb->pszComment ));

        LeaveCriticalSection( &g_TraceMemoryCS );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete(
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead;
        LPMEMORYBLOCK pmbLast = NULL;

        EnterCriticalSection( &g_TraceMemoryCS );
        pmbHead = g_TraceMemoryTable;

        while ( pmbHead && pmbHead->hglobal != hglobal )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead )
        {
            HGLOBAL *p;
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                g_TraceMemoryTable = pmbHead->pNext;
            }

            BinlPrintDbg((DEBUG_MEMORY, "DebugFree: 0x%08x freed (%s)\n", hglobal,
                pmbHead->pszComment ));

            p = (HGLOBAL)((LPBYTE)hglobal + pmbHead->dwBytes - sizeof(HGLOBAL));
            if ( *p != hglobal )
            {
                BinlPrintDbg(((DEBUG_ERRORS|DEBUG_MEMORY), "DebugFree: Heap check FAILED for %0x08x %u bytes (%s).\n",
                    hglobal, pmbHead->dwBytes, pmbHead->pszComment));
                BinlPrintDbg(((DEBUG_ERRORS|DEBUG_MEMORY), "DebugFree: %s, Line: %u\n",
                    pmbHead->pszFile, pmbHead->uLine ));
                BinlAssert( *p == hglobal );
            }

            memset( hglobal, 0xFE, pmbHead->dwBytes );
            memset( pmbHead, 0xFD, sizeof(sizeof(MEMORYBLOCK)) );

            LocalFree( pmbHead );
        }
        else
        {
            HGLOBAL *p;

            BinlPrintDbg(((DEBUG_ERRORS|DEBUG_MEMORY), "DebugFree: 0x%08x not found in memory table\n", hglobal ));
            memset( hglobal, 0xFE, (int)LocalSize( hglobal ));
        }

        LeaveCriticalSection( &g_TraceMemoryCS );

    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc(
    LPCSTR pszFile,
    UINT    uLine,
    LPCSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment )
{
    HGLOBAL hglobal;
    DWORD dwBytesToAlloc = ROUND_UP_COUNT( dwBytes + sizeof(HGLOBAL), ALIGN_WORST);

    HGLOBAL *p;
    hglobal = GlobalAlloc( uFlags, dwBytesToAlloc );
    if (hglobal == NULL) {
        return NULL;
    }
    p = (HGLOBAL)((LPBYTE)hglobal + dwBytesToAlloc - sizeof(HGLOBAL));
    *p = hglobal;

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytesToAlloc, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree(
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb;

    EnterCriticalSection( &g_TraceMemoryCS );

    pmb = g_TraceMemoryTable;
    while ( pmb )
    {
        LPMEMORYBLOCK pTemp;
        LPVOID args[ 5 ];
        CHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        CHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE )
        {
            BinlPrintRoutine( 0, "\n***************************** Memory leak detected *****************************\n\n");
          //BinlPrintRoutine( 0, "1234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            BinlPrintRoutine( 0, "Filename(Line Number):                    Module     Addr/HGLOBAL  Size   String\n");
            fFoundLeak = TRUE;
        }

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) &szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = (LPVOID) ULongToPtr( pmb->dwBytes );
        args[4] = (LPVOID) pmb->pszModule;

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) )
        {
            FormatMessageA(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                "%2!-40s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n",
                0,                          // error code
                0,                          // default language
                (LPSTR) &szOutput,         // output buffer
                DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
                (va_list*) &args );           // arguments
        }
        else
        {
            FormatMessageA(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                "%2!-40s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n",
                0,                          // error code
                0,                          // default language
                (LPSTR) &szOutput,         // output buffer
                DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
                (va_list*) &args );           // arguments
        }

        BinlPrintRoutine( 0,  szOutput );

        pTemp = pmb;
        pmb = pmb->pNext;
        memset( pTemp, 0xFD, sizeof(MEMORYBLOCK) );
        LocalFree( pTemp );
    }

    if ( fFoundLeak == TRUE )
    {
        BinlPrintRoutine( 0, "\n***************************** Memory leak detected *****************************\n\n");
    }

    LeaveCriticalSection( &g_TraceMemoryCS );

    //BinlAssert( !fFoundLeak );
}

VOID
DumpBuffer(
    PVOID Buffer,
    ULONG BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    ULONG i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    PUCHAR BufferPtr = Buffer;


    DbgPrint("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            DbgPrint("%02x ", (UCHAR)BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            DbgPrint("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            DbgPrint("  %s\n", TextBuffer);
        }

    }

    DbgPrint("------------------------------------\n");
}


#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\debug.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the binl server.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32

Revision History:


--*/

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\binlsvc.log"
#define DEBUG_BAK_FILE      L"\\binlsvc.bak"

//
// LOW WORD bit mask (0x0000FFFF) for low frequency debug output.
//

#define DEBUG_ADDRESS           0x00000001  // subnet address
#define DEBUG_OPTIONS           0x00000008  // binl option

#define DEBUG_ERRORS            0x00000010  // hard error
#define DEBUG_STOC              0x00000020  // protocol error
#define DEBUG_INIT              0x00000040  // init error
#define DEBUG_SCAVENGER         0x00000080  // sacvenger error

#define DEBUG_TIMESTAMP         0x00000100  // debug message timing
#define DEBUG_REGISTRY          0x00000400  // Registry operation
#define DEBUG_NETINF            0x00000800  // NETINF error

#define DEBUG_MISC              0x00008000  // misc info.

//
// HIGH WORD bit mask (0x0000FFFF) for high frequency debug output.
// ie more verbose.
//

#define DEBUG_MESSAGE           0x00010000  // binl message output.
#define DEBUG_OSC               0x00040000  // OSChooser message output.
#define DEBUG_OSC_ERROR         0x00080000  // OSChooser error output.

#define DEBUG_BINL_CACHE        0x00100000  // Binl client cache output.
#define DEBUG_ROGUE             0x00200000  // rogue processing.
#define DEBUG_POLICY            0x00400000  // group policy filtering.

#define DEBUG_THREAD            0x04000000  // debug message contains threadid
#define DEBUG_MEMORY            0x08000000  // Memory Allocation Tracking Spew

#define DEBUG_FUNC              0x10000000  // function entry

#define DEBUG_STARTUP_BRK       0x40000000  // breakin debugger during startup.
#define DEBUG_LOG_IN_FILE       0x80000000  // log debug output in a file.

VOID
DebugInitialize(
    VOID
    );

VOID
DebugUninitialize(
    VOID
    );

VOID
BinlOpenDebugFile(
    IN BOOL ReopenFlag
    );

VOID
BinlServerEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    );

extern const char g_szTrue[];
extern const char g_szFalse[];

#define BOOLTOSTRING( _f ) ( _f ? g_szTrue : g_szFalse )

VOID
BinlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define BinlPrint(_x_) BinlPrintRoutine _x_;

#if DBG

VOID
BinlDumpMessage(
    DWORD BinlDebugFlag,
    LPDHCP_MESSAGE BinlMessage
    );

VOID
BinlAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define BinlAssert(Predicate) \
    { \
    if (!(Predicate)) {\
            BinlAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
        } \
    }

#define BinlAssertMsg(Predicate, Message) \
    { \
    if (!(Predicate)) {\
            BinlAssertFailed( #Predicate, __FILE__, __LINE__, #Message ); \
        } \
    }

#define BinlPrintDbg(_x_) BinlPrintRoutine _x_;

#define TraceFunc( _func )  BinlPrintDbg(( DEBUG_FUNC, "%s", _func ));

//
// Leak detection
//
#define INITIALIZE_TRACE_MEMORY     InitializeCriticalSection( &g_TraceMemoryCS );
#define UNINITIALIZE_TRACE_MEMORY   DebugMemoryCheck( ); DeleteCriticalSection( &g_TraceMemoryCS );

CRITICAL_SECTION g_TraceMemoryCS;

HGLOBAL
DebugAlloc(
    LPCSTR pszFile,
    UINT    uLine,
    LPCSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment );

void
DebugMemoryDelete(
    HGLOBAL hglobal );

HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCSTR pszFile,
    UINT    uLine,
    LPCSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment );

HGLOBAL
DebugFree(
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

#else   // not DBG

#define INITIALIZE_TRACE_MEMORY
#define UNINITIALIZE_TRACE_MEMORY

#define BinlPrintDbg(_x_)
#define TraceFunc( _func )
#define BinlAssert(_x_)
#define BinlAssertMsg(_x_, _y_)
#define BinlDumpMessage(_x_, _y_)
#define DebugMemoryAdd( x1, x2, x3, x4, x5, x6, x7 )

#endif // not DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\global.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    global.h

Abstract:

    This module contains definitions for global server data.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef  GLOBAL_DATA_ALLOCATED
    #ifdef  GLOBAL_DATA_ALLOCATE
        #undef GLOBAL_DATA
    #endif
#endif

#ifndef GLOBAL_DATA
#define GLOBAL_DATA

//
// main.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef  GLOBAL_DATA_ALLOCATE
#undef EXTERN
#define EXTERN
#define GLOBAL_DATA_ALLOCATED
#undef INIT_GLOBAL
#define INIT_GLOBAL(v) =v
#else
#define EXTERN extern
#define INIT_GLOBAL(v)
#endif

//
// process global data passed to this service from tcpsvcs.exe
//

EXTERN PTCPSVCS_GLOBAL_DATA TcpsvcsGlobalData;

//
// Service variables
//
EXTERN SERVICE_STATUS BinlGlobalServiceStatus;
EXTERN SERVICE_STATUS_HANDLE BinlGlobalServiceStatusHandle;

//
// Process data.
//

#define BINL_STOPPED 0
#define BINL_STARTED 1
EXTERN DWORD BinlCurrentState INIT_GLOBAL(BINL_STOPPED);

EXTERN HANDLE BinlGlobalProcessTerminationEvent INIT_GLOBAL(NULL);
EXTERN HANDLE BinlGlobalProcessorHandle;
EXTERN HANDLE BinlGlobalMessageHandle;

EXTERN LIST_ENTRY BinlGlobalFreeRecvList;
EXTERN LIST_ENTRY BinlGlobalActiveRecvList;
EXTERN CRITICAL_SECTION BinlGlobalRecvListCritSect;
EXTERN HANDLE BinlGlobalRecvEvent INIT_GLOBAL(NULL);

EXTERN int DHCPState INIT_GLOBAL(DHCP_STOPPED);

EXTERN BOOL BinlGlobalSystemShuttingDown;

//  Temporary defaults until GPT lookup available
EXTERN PWCHAR BinlGlobalDefaultContainer INIT_GLOBAL(NULL);
EXTERN PWCHAR DefaultDomain INIT_GLOBAL(NULL);

#define DEFAULT_MAXIMUM_DEBUGFILE_SIZE 20000000

EXTERN DWORD BinlGlobalDebugFlag;
EXTERN CRITICAL_SECTION BinlGlobalDebugFileCritSect;
EXTERN HANDLE BinlGlobalDebugFileHandle;
EXTERN DWORD BinlGlobalDebugFileMaxSize;
EXTERN LPWSTR BinlGlobalDebugSharePath;

EXTERN DWORD BinlLdapOptReferrals INIT_GLOBAL(0);

//
// misc
//

//
//  We don't wait forever for the DS to come back with a reply.
//

#define BINL_LDAP_SEARCH_TIMEOUT_SECONDS        30
#define BINL_LDAP_SEARCH_MIN_TIMEOUT_MSECS      500

EXTERN struct l_timeval  BinlLdapSearchTimeout;

EXTERN DWORD BinlGlobalIgnoreBroadcastFlag;     // whether to ignore the broadcast
                                                // bit in the client requests or not

EXTERN HANDLE g_hevtProcessMessageComplete;
EXTERN DWORD g_cMaxProcessingThreads;
EXTERN DWORD g_cProcessMessageThreads;
EXTERN CRITICAL_SECTION g_ProcessMessageCritSect;

EXTERN CRITICAL_SECTION gcsDHCPBINL;
EXTERN CRITICAL_SECTION gcsParameters;

EXTERN LPENDPOINT BinlGlobalEndpointList INIT_GLOBAL(NULL);
EXTERN DWORD BinlGlobalNumberOfNets;

EXTERN DWORD g_Port;

EXTERN BOOL AllowNewClients INIT_GLOBAL(TRUE);
EXTERN BOOL LimitClients INIT_GLOBAL(FALSE);
EXTERN BOOL AssignNewClientsToServer INIT_GLOBAL(FALSE);

//
//  As part of rogue detection, the default for servers should be to not answer
//  for new clients.  We'll get the ability to answer clients out of
//  the directory.
//

EXTERN BOOL AnswerRequests INIT_GLOBAL(TRUE);
EXTERN BOOL AnswerOnlyValidClients INIT_GLOBAL(TRUE);

EXTERN WCHAR NewMachineNamingPolicyDefault[] INIT_GLOBAL(L"%Username%#");
EXTERN PWCHAR NewMachineNamingPolicy INIT_GLOBAL(NULL);
EXTERN DWORD CurrentClientCount INIT_GLOBAL(0);
EXTERN DWORD BinlMaxClients INIT_GLOBAL(0);
EXTERN DWORD BinlClientTimeout INIT_GLOBAL(0);
EXTERN DWORD BinlUpdateFromDSTimeout INIT_GLOBAL(4*60*60*1000); // milliseconds (4 hours)
EXTERN DWORD BinlHyperUpdateCount INIT_GLOBAL(0);
EXTERN BOOL BinlHyperUpdateSatisfied INIT_GLOBAL(FALSE);

EXTERN BOOL BinlParametersRead INIT_GLOBAL(FALSE);

EXTERN PWCHAR BinlGlobalSCPPath INIT_GLOBAL(NULL);
EXTERN PWCHAR BinlGlobalServerDN INIT_GLOBAL(NULL);
EXTERN PWCHAR BinlGlobalGroupDN INIT_GLOBAL(NULL);

EXTERN CRITICAL_SECTION ClientsCriticalSection;
EXTERN LIST_ENTRY ClientsQueue;
EXTERN CRITICAL_SECTION HackWorkaroundCriticalSection;

//
//  By default, we cache DS responses for 25 seconds.  It's relatively short
//  because we have no way of cheeply getting notified of DS changes.
//

#define BINL_CACHE_EXPIRE_DEFAULT (25*1000)

//
//  We maintain a list of BINL_CACHE_ENTRY structures for short term caching.
//  The root of the list is in BinlCacheList and the lock that protects the
//  list is BinlCacheListLock.  We expire these cache entries after a given
//  time period has expired (BinlCacheExpireMilliseconds holds it).
//

EXTERN LIST_ENTRY BinlCacheList;
EXTERN CRITICAL_SECTION BinlCacheListLock;
EXTERN ULONG BinlCacheExpireMilliseconds;

//
//  When waiting for the threads to be done with the cache, we wait on the
//  BinlCloseCacheEvent event.
//

EXTERN HANDLE BinlCloseCacheEvent INIT_GLOBAL(NULL);

//
//  default for max number to cache is 250.  This seems reasonable number to
//  cache for at most BinlCacheExpireMilliseconds.
//

#define BINL_CACHE_COUNT_LIMIT_DEFAULT 250

EXTERN ULONG BinlGlobalCacheCountLimit;
EXTERN DWORD BinlGlobalScavengerSleep; // in milliseconds

#if DBG
EXTERN BOOL BinlGlobalRunningAsProcess;
#endif

EXTERN ULONG BinlMinDelayResponseForNewClients;

//
// Remote boot path - as in "D:\RemoteInstall" with no trailing slash
//
EXTERN WCHAR IntelliMirrorPathW[ MAX_PATH ];
EXTERN CHAR IntelliMirrorPathA[ MAX_PATH ];

//
// Default language to look for oschooser screens/setups in.
//
EXTERN PWCHAR BinlGlobalDefaultLanguage INIT_GLOBAL(NULL);

EXTERN DHCP_ROGUE_STATE_INFO DhcpRogueInfo;
EXTERN BOOL BinlGlobalHaveCalledRogueInit INIT_GLOBAL(FALSE);
EXTERN BOOL BinlGlobalAuthorized INIT_GLOBAL(FALSE);
EXTERN BOOL BinlRogueLoggedState INIT_GLOBAL(FALSE);

EXTERN HANDLE BinlRogueTerminateEventHandle INIT_GLOBAL(NULL);
EXTERN HANDLE RogueUnauthorizedHandle INIT_GLOBAL(NULL);
EXTERN HANDLE BinlRogueThread INIT_GLOBAL(NULL);

//
//  PNP globals.
//

EXTERN PDNS_ADDRESS_INFO BinlDnsAddressInfo INIT_GLOBAL(NULL);
EXTERN ULONG BinlDnsAddressInfoCount INIT_GLOBAL(0);
EXTERN BOOL BinlIsMultihomed INIT_GLOBAL(FALSE);
EXTERN DHCP_IP_ADDRESS BinlGlobalMyIpAddress INIT_GLOBAL(0);
EXTERN SOCKET BinlPnpSocket INIT_GLOBAL(INVALID_SOCKET);

EXTERN WSAOVERLAPPED BinlPnpOverlapped;
EXTERN HANDLE BinlGlobalPnpEvent INIT_GLOBAL(NULL);

//
// The four strings below are protected by the gcsParameters critical section.
//

EXTERN PWCHAR BinlGlobalOurDnsName INIT_GLOBAL(NULL);   // our dns name
EXTERN PWCHAR BinlGlobalOurDomainName INIT_GLOBAL(NULL);// our netbios domain name
EXTERN PWCHAR BinlGlobalOurServerName INIT_GLOBAL(NULL);// our netbios server name
EXTERN PWCHAR BinlGlobalOurFQDNName INIT_GLOBAL(NULL);  // our distinguished name
EXTERN HANDLE BinlGlobalLsaDnsNameNotifyEvent INIT_GLOBAL(NULL);
EXTERN BOOL BinlGlobalHaveOutstandingLsaNotify INIT_GLOBAL(FALSE);

//
// Default organization to use in .sifs.
//
EXTERN PWCHAR BinlGlobalDefaultOrgname INIT_GLOBAL(NULL);

//
// Default timezone index to use in .sifs
//
EXTERN PWCHAR BinlGlobalDefaultTimezone INIT_GLOBAL(NULL);

//
// Default DS servers
//
EXTERN PWCHAR BinlGlobalDefaultDS INIT_GLOBAL(NULL);
EXTERN PWCHAR BinlGlobalDefaultGC INIT_GLOBAL(NULL);

//
//  The number of times we'll retry before giving up on the DS.
//

#define LDAP_SERVER_DOWN_LIMIT 4  // number of times to retry
#define LDAP_BUSY_LIMIT 15      // number of times to retry
#define LDAP_BUSY_DELAY 250     // milliseconds to wait

EXTERN ULONG BinlGlobalLdapErrorCount INIT_GLOBAL(0);
EXTERN ULONG BinlGlobalMaxLdapErrorsLogged INIT_GLOBAL(0);
EXTERN ULONG BinlGlobalLdapErrorScavenger INIT_GLOBAL(0);

//
// Used to crack names
//
EXTERN HANDLE BinlOscClientDSHandle INIT_GLOBAL(NULL);

#endif // GLOBAL_DATA*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\infutil.c ===
/*
Module Name:

    infutil.c

Abstract:

    This module implements utility routines to parse net card INF files.

Author:

    Andy Herron Mar 24 1998

Revision History:

*/

#include "binl.h"
#pragma hdrstop

#include "netinfp.h"

const WCHAR NetInfHexToCharTable[17] = L"0123456789ABCDEF";

ULONG
NetInfCloseNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards
    )
/*++

Routine Description:

    This function just dereferences the block for the 'alive' reference.
    This may cause it to be deleted.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    BinlAssert( pNetCards->ReferenceCount > 0 );

    DereferenceNetcardInfo( pNetCards );
    return ERROR_SUCCESS;
}


VOID
DereferenceNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards
    )
/*++

Routine Description:

    This function frees all memory, handles, etc that is stored in the
    NETCARD_INF_BLOCK passed in.  Note that all NETCARD_RESPONSE_DATABASE
    entries are simply dereferenced, not freed here.  This is because we don't
    want to require that all threads are done with these records before we
    close down the pNetCards block.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    ULONG i;

    EnterCriticalSection( &NetInfLock );

    pNetCards->ReferenceCount--;

    if (pNetCards->ReferenceCount > 0) {

        LeaveCriticalSection( &NetInfLock );
        return;
    }

    //  only remove it from the global list if it was put on the list.  It
    //  might not be on the list if it's not called within BINL (i.e. RISETUP
    //  is just enumerating files).

    if (pNetCards->InfBlockEntry.Flink != NULL) {
        RemoveEntryList( &pNetCards->InfBlockEntry );
    }

    LeaveCriticalSection( &NetInfLock );

    EnterCriticalSection( &pNetCards->Lock );

    //
    //  No thread after this should call FindNetcardInfo to search the table,
    //  since the caller just closed it.
    //
    //  Free all entries allocated for this block.  We just dereference in case
    //  any thread is using a specific entry.
    //

    for (i = 0; i < NETCARD_HASH_TABLE_SIZE; i++) {

        PLIST_ENTRY listHead = &pNetCards->NetCardEntries[i];

        while (IsListEmpty( listHead ) == FALSE) {

            PNETCARD_RESPONSE_DATABASE pInfEntry;
            PLIST_ENTRY listEntry = RemoveHeadList( listHead );

            pInfEntry = (PNETCARD_RESPONSE_DATABASE) CONTAINING_RECORD(
                                                    listEntry,
                                                    NETCARD_RESPONSE_DATABASE,
                                                    NetCardEntry );
            NetInfDereferenceNetcardEntry( pInfEntry );
        }
    }

    LeaveCriticalSection( &pNetCards->Lock );

    DeleteCriticalSection( &pNetCards->Lock );
    BinlFreeMemory( pNetCards );

    return;
}

VOID
NetInfDereferenceNetcardEntry (
    PNETCARD_RESPONSE_DATABASE pInfEntry
    )
/*++

Routine Description:

    This function frees all memory, handles, etc that is stored in the
    NETCARD_INF_BLOCK passed in.  Note that all NETCARD_RESPONSE_DATABASE
    entries are simply dereferenced, not freed here.  This is because we don't
    want to require that all threads are done with these records before we
    close down the pNetCards block.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    LONG result;

    result = InterlockedDecrement( &pInfEntry->ReferenceCount );

    if (result > 0) {
        return;
    }

    BinlAssert( result == 0 );

    //
    //  Time to free this one.  It should've already been pulled from the list.
    //

    //
    //  free the list of registry parameters we have stored off for it.
    //

    while (! IsListEmpty( &pInfEntry->Registry )) {

        PNETCARD_REGISTRY_PARAMETERS regParam;
        PLIST_ENTRY listEntry = RemoveHeadList( &pInfEntry->Registry );

        regParam = (PNETCARD_REGISTRY_PARAMETERS) CONTAINING_RECORD(
                                                    listEntry,
                                                    NETCARD_REGISTRY_PARAMETERS,
                                                    RegistryListEntry );
        if (regParam->Parameter.Buffer) {

            BinlFreeMemory( regParam->Parameter.Buffer );
        }
        if (regParam->Value.Buffer) {

            BinlFreeMemory( regParam->Value.Buffer );
        }

        BinlFreeMemory( regParam );
    }

    //
    //  free the list of registry parameters we have stored off for it.
    //

    while (! IsListEmpty( &pInfEntry->FileCopyList )) {

        PNETCARD_FILECOPY_PARAMETERS fileEntry;
        PLIST_ENTRY listEntry = RemoveHeadList( &pInfEntry->FileCopyList );

        fileEntry = (PNETCARD_FILECOPY_PARAMETERS) CONTAINING_RECORD(
                                                    listEntry,
                                                    NETCARD_FILECOPY_PARAMETERS,
                                                    FileCopyListEntry );
        if (fileEntry->SourceFile.Buffer) {

            BinlFreeMemory( fileEntry->SourceFile.Buffer );
        }
        if (fileEntry->DestFile.Buffer) {

            BinlFreeMemory( fileEntry->DestFile.Buffer );
        }

        BinlFreeMemory( fileEntry );
    }

    if (pInfEntry->DriverName != NULL) {

        BinlFreeMemory( pInfEntry->DriverName );
    }

    if (pInfEntry->ServiceName != NULL) {

        BinlFreeMemory( pInfEntry->ServiceName );
    }

    //
    //  if the section name is the same as the extended section name, then
    //  they will be the same pointer.  let's not free it twice.
    //

    if (pInfEntry->SectionNameExt != NULL &&
        pInfEntry->SectionNameExt != pInfEntry->SectionName) {

        BinlFreeMemory( pInfEntry->SectionNameExt );
    }

    if (pInfEntry->SectionName != NULL) {

        BinlFreeMemory( pInfEntry->SectionName );
    }

    if (pInfEntry->HardwareId != NULL) {

        BinlFreeMemory( pInfEntry->HardwareId );
    }

    if (pInfEntry->DriverDescription != NULL) {

        BinlFreeMemory( pInfEntry->DriverDescription );
    }

    BinlFreeMemory( pInfEntry );

    return;
}


ULONG
FindNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards,
    ULONG CardInfoVersion,
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PNETCARD_RESPONSE_DATABASE *pInfEntry
    )
/*++

Routine Description:

    This function searches the drivers we've found and returns a pointer to
    an entry that most closely matches the client's request.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

       The NetCards structure has been referenced by the caller of this
       API and won't be going away from under us!

    CardInfoVersion - Version of the structure passed by the client.

    CardIdentity - has the values the app is looking for.  we try our best to
        find one that matches.

    pInfEntry - the entry that was found if successful. NULL if in error.

Return Value:

    ERROR_SUCCESS, ERROR_NOT_ENOUGH_MEMORY, or ERROR_NOT_SUPPORTED

--*/
{
    ULONG err;
    PWCHAR listOfPossibleCardIdentifiers = NULL;
    LIST_ENTRY listEntry;
    PWCHAR searchString;
    PNETCARD_RESPONSE_DATABASE pEntry = NULL;

    *pInfEntry = NULL;

    if (CardInfoVersion != OSCPKT_NETCARD_REQUEST_VERSION) {

        BinlPrint(( DEBUG_NETINF, "Not supporting CardInfoVersion %u\n", CardInfoVersion ));
        return ERROR_NOT_SUPPORTED;
    }

    err = CreateListOfCardIdentifiers( CardIdentity,
                                       &listOfPossibleCardIdentifiers );

    if (err != ERROR_SUCCESS) {

        goto exitFind;
    }
    BinlAssert( listOfPossibleCardIdentifiers != NULL);

    //
    //  The search strings are ordered from most specific to least specific
    //  so we have to search for them ordered top to bottom.
    //

    searchString = listOfPossibleCardIdentifiers;

    while (*searchString != L'\0') {

        PLIST_ENTRY listEntry;
        PLIST_ENTRY listHead;
        ULONG hwLength = lstrlenW( searchString );
        ULONG hashValue;

        COMPUTE_STRING_HASH( searchString, &hashValue );

        listHead = &pNetCards->NetCardEntries[HASH_TO_INF_INDEX(hashValue)];
        listEntry = listHead->Flink;

        while ( listEntry != listHead ) {

            pEntry = (PNETCARD_RESPONSE_DATABASE) CONTAINING_RECORD(
                                                    listEntry,
                                                    NETCARD_RESPONSE_DATABASE,
                                                    NetCardEntry );

            err = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                                  0,
                                  searchString,
                                  hwLength,
                                  pEntry->HardwareId,
                                  -1
                                  );
            if (err == 2) {

                break;      // a match was found.
            }

            pEntry = NULL;

            if (err == 3) {

                break;      // it's greater therefore entry isn't present
            }

            listEntry = listEntry->Flink;
        }

        if (pEntry != NULL) {

            // we found one that matches it.  reference it and return

            InterlockedIncrement( &pEntry->ReferenceCount );
            err = ERROR_SUCCESS;
            *pInfEntry = pEntry;
            break;
        }

        searchString += lstrlenW( searchString ) + 1;  // point to next after null
    }

exitFind:

    if (pEntry == NULL) {

        err = ERROR_NOT_SUPPORTED;

    } else {

        BinlAssert( err == ERROR_SUCCESS );
    }

    if (listOfPossibleCardIdentifiers) {
        BinlFreeMemory( listOfPossibleCardIdentifiers );
    }

    return err;
}

ULONG
CreateListOfCardIdentifiers (
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PWCHAR *CardIdentifiers
    )
/*++

Routine Description:

    This function creates the list of card identifiers for the given card.
    It generates a buffer that looks like this :

    "PCI\VEN_8086&DEV_1229&SUBSYS_00018086&REV_05"
    "PCI\VEN_8086&DEV_1229&SUBSYS_00018086"
    "PCI\VEN_8086&DEV_1229&REV_05"
    "PCI\VEN_8086&DEV_1229"
    empty string

    Note that if we support more than just PCI, we'll have to change this
    function.

Arguments:

    CardIdentity - Holds the values we're looking for that identify this card.

    CardIdentifiers - where we put the resulant strings.

Return Value:

    Windows Error.

--*/
{
    ULONG err = ERROR_SUCCESS;
    ULONG spaceRequired;
    PWCHAR nextField;

    if (CardIdentity->NicType == NETINF_BUS_TYPE_PCI) {

        UCHAR ch;

        WCHAR vendorBuff[5];
        WCHAR deviceBuff[5];
        WCHAR subsysBuff[9];
        WCHAR revBuff[3];

        // "PCI\VEN_8086&DEV_1229&SUBSYS_00018086&REV_05"
        // "PCI\VEN_8086&DEV_1229&SUBSYS_00018086"
        // "PCI\VEN_8086&DEV_1229&REV_05"
        // "PCI\VEN_8086&DEV_1229"

        spaceRequired = ((( sizeof( L"PCI\\1234&1234&" ) - 1 ) +
                          ( sizeof( NETINF_VENDOR_STRING ) - 1 ) +
                          ( sizeof( NETINF_DEVICE_STRING ) - 1 ) ) * 4 +
                         (( sizeof( L"12&" ) - 1 ) +
                          ( sizeof( NETINF_REVISION_STRING ) - 1 ) ) * 2 +
                         (( sizeof( L"12345678&" ) - 1 ) +
                          ( sizeof( NETINF_IOSUBS_STRING ) - 1 )) * 2 );

        spaceRequired += sizeof(WCHAR); // allocate 1 more for trailing null

        *CardIdentifiers = BinlAllocateMemory( spaceRequired );

        if (*CardIdentifiers == NULL) {

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        nextField = *CardIdentifiers;

        //
        //  Convert the numeric values to their char equivalents
        //

        ConvertHexToBuffer( &vendorBuff[0], CardIdentity->pci.Vendor_ID );
        vendorBuff[4] = '\0';
        ConvertHexToBuffer( &deviceBuff[0], CardIdentity->pci.Dev_ID );
        deviceBuff[4] = '\0';

        revBuff[0] = NetInfHexToCharTable[ ( CardIdentity->pci.Rev & 0xF0 ) >> 4 ];
        revBuff[1] = NetInfHexToCharTable[ ( CardIdentity->pci.Rev & 0x0F ) ];
        revBuff[2] = '\0';

        ConvertHexToBuffer( &subsysBuff[0], HIWORD( CardIdentity->pci.Subsys_ID ) );
        ConvertHexToBuffer( &subsysBuff[4], LOWORD( CardIdentity->pci.Subsys_ID ) );
        subsysBuff[8] = '\0';

        //
        //  Now create the strings in most specific to least specific order
        //

        // "PCI\VEN_8086&DEV_1229&SUBSYS_00018086&REV_05"
        lstrcpyW( nextField, L"PCI\\" );
        lstrcatW( nextField, NETINF_VENDOR_STRING );
        lstrcatW( nextField, vendorBuff );
        lstrcatW( nextField, L"&" );
        lstrcatW( nextField, NETINF_DEVICE_STRING );
        lstrcatW( nextField, deviceBuff );
        lstrcatW( nextField, L"&" );
        lstrcatW( nextField, NETINF_IOSUBS_STRING );
        lstrcatW( nextField, subsysBuff );
        lstrcatW( nextField, L"&" );
        lstrcatW( nextField, NETINF_REVISION_STRING );
        lstrcatW( nextField, revBuff );
        nextField += lstrlenW( nextField ) + 1;  // point to next after null

        // "PCI\VEN_8086&DEV_1229&SUBSYS_00018086"
        lstrcpyW( nextField, L"PCI\\" );
        lstrcatW( nextField, NETINF_VENDOR_STRING );
        lstrcatW( nextField, vendorBuff );
        lstrcatW( nextField, L"&" );
        lstrcatW( nextField, NETINF_DEVICE_STRING );
        lstrcatW( nextField, deviceBuff );
        lstrcatW( nextField, L"&" );
        lstrcatW( nextField, NETINF_IOSUBS_STRING );
        lstrcatW( nextField, subsysBuff );
        nextField += lstrlenW( nextField ) + 1;  // point to next after null

        // "PCI\VEN_8086&DEV_1229&REV_05"
        lstrcpyW( nextField, L"PCI\\" );
        lstrcatW( nextField, NETINF_VENDOR_STRING );
        lstrcatW( nextField, vendorBuff );
        lstrcatW( nextField, L"&" );
        lstrcatW( nextField, NETINF_DEVICE_STRING );
        lstrcatW( nextField, deviceBuff );
        lstrcatW( nextField, L"&" );
        lstrcatW( nextField, NETINF_REVISION_STRING );
        lstrcatW( nextField, revBuff );
        nextField += lstrlenW( nextField ) + 1;  // point to next after null

        // "PCI\VEN_8086&DEV_1229"

        lstrcpyW( nextField, L"PCI\\" );
        lstrcatW( nextField, NETINF_VENDOR_STRING );
        lstrcatW( nextField, vendorBuff );
        lstrcatW( nextField, L"&" );
        lstrcatW( nextField, NETINF_DEVICE_STRING );
        lstrcatW( nextField, deviceBuff );
        nextField += lstrlenW( nextField ) + 1;  // point to next after null

        //
        //  to mark the end of the multi-sz, stick on another null terminator
        //

        *(nextField++) = L'\0';

    } else {

        *CardIdentifiers = NULL;
        err = ERROR_NOT_SUPPORTED;
    }

    return err;
}

VOID
ConvertHexToBuffer(
    PWCHAR Buff,
    USHORT Value
    )
{
    UCHAR ch;

    ch = HIBYTE( Value );
    *(Buff+0) = NetInfHexToCharTable[ ( ch & 0xF0 ) >> 4 ];
    *(Buff+1) = NetInfHexToCharTable[ ( ch & 0x0F ) ];
    ch = LOBYTE( Value );
    *(Buff+2) = NetInfHexToCharTable[ ( ch & 0xF0 ) >> 4 ];
    *(Buff+3) = NetInfHexToCharTable[ ( ch & 0x0F ) ];

    return;
}



ULONG
GetSetupLineWideText (
    PINFCONTEXT InfContext,
    HINF InfHandle,
    PWCHAR Section,
    PWCHAR Key,
    PWCHAR *String,
    PULONG SizeOfAllocation OPTIONAL
    )
{
    ULONG sizeRequired = 0;

    if (SetupGetLineTextW( InfContext,
                           InfHandle,
                           Section,
                           Key,
                           NULL,
                           0,
                           &sizeRequired) == FALSE) {

        return GetLastError();
    }

    if (*String == NULL ||
        SizeOfAllocation == NULL ||
        *SizeOfAllocation < sizeRequired) {

        if (*String != NULL) {
            BinlFreeMemory( *String );
            *String = NULL;
        }

        *String = (PWCHAR) BinlAllocateMemory( sizeRequired * sizeof(WCHAR));

        if (*String == NULL) {

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (SizeOfAllocation != NULL) {
            *SizeOfAllocation = sizeRequired;
        }
    }

    if (SetupGetLineTextW( InfContext,
                           InfHandle,
                           Section,
                           Key,
                           *String,
                           sizeRequired,
                           NULL) == FALSE) {

        return GetLastError();
    }

    return ERROR_SUCCESS;
}

ULONG
GetSetupWideTextField (
    PINFCONTEXT InfContext,
    DWORD  FieldIndex,
    PWCHAR *String,
    PULONG SizeOfAllocation
    )
{
    ULONG sizeRequired = 0;

    if (SetupGetStringFieldW( InfContext,
                              FieldIndex,
                              NULL,
                              0,
                              &sizeRequired) == FALSE) {

        return GetLastError();
    }

    if (*String == NULL ||
        SizeOfAllocation == NULL ||
        *SizeOfAllocation < sizeRequired) {

        if (*String != NULL) {
            BinlFreeMemory( *String );
            *String = NULL;
        }

        *String = (PWCHAR) BinlAllocateMemory( sizeRequired * sizeof(WCHAR));

        if (*String == NULL) {

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (SizeOfAllocation != NULL) {

            *SizeOfAllocation = sizeRequired;
        }
    }

    if (SetupGetStringFieldW( InfContext,
                              FieldIndex,
                              *String,
                              sizeRequired,
                              NULL) == FALSE) {

        return GetLastError();
    }

    return ERROR_SUCCESS;
}


ULONG
CheckHwDescription (
    PWCHAR HardwareID
    )
/*++

Routine Description:

    This function parses the HardwareID field of the driver's detail record
    and determines a) if we can support it and b) fills in all the values.

    Note that if we support more than just PCI, we'll have to change this
    function.

Arguments:

    HardwareID - uppercased hardware id representing the driver's configuration

    Identifiers - the fields we need to fill in.

Return Value:

    ERROR_NOT_SUPPORTED, ERROR_SUCCESS, or ERROR_INVALID_PARAMETER

--*/
{
    ULONG err = ERROR_SUCCESS;
    PWCHAR hwPointer = HardwareID;
    USHORT busType;
    USHORT Vendor;      // Vendor_ID to check
    USHORT Device;      // Dev_ID to check
    ULONG Subsystem;    // Subsys_ID to check
    USHORT Revision;    // Revision to check
    BOOLEAN RevPresent; // Revision present
    BOOLEAN SubPresent; // Subsystem present

    //
    //  for now, PCI is the only one supported.
    //

    if (IsSubString( L"PCI\\", hwPointer, FALSE )) {

        hwPointer += (sizeof( "pci\\" ) - 1);
        busType = NETINF_BUS_TYPE_PCI;

    } else {

        return ERROR_NOT_SUPPORTED;
    }

    //
    //  we parse the HardwareID as it's passed to us in the
    //  SP_DRVINFO_DETAIL_DATA structure.  It is of the form :
    //
    //  pci\ven_8086&dev_1229&rev_01&subsys_00018086
    //
    //  where the vendor will always be present and the device, revision,
    //  and subsystem may or may not be present.
    //

    if (busType == NETINF_BUS_TYPE_PCI) {

        while (*hwPointer != L'\0') {

            if (IsSubString( NETINF_VENDOR_STRING, hwPointer, FALSE )) {

                hwPointer += ((sizeof(NETINF_VENDOR_STRING)/sizeof(WCHAR)) - 1);

                err = GetHexValueFromHw( &hwPointer, NULL, &Vendor );

                if (err != ERROR_SUCCESS) {
                    goto cardSyntaxError;
                }
            } else if (IsSubString( NETINF_DEVICE_STRING, hwPointer, FALSE )) {

                hwPointer += ((sizeof(NETINF_DEVICE_STRING)/sizeof(WCHAR)) - 1);

                err = GetHexValueFromHw( &hwPointer, NULL, &Device );

                if (err != ERROR_SUCCESS) {
                    goto cardSyntaxError;
                }
            } else if (IsSubString( NETINF_REVISION_STRING, hwPointer, FALSE )) {

                hwPointer += ((sizeof(NETINF_REVISION_STRING)/sizeof(WCHAR)) - 1);

                err = GetHexValueFromHw( &hwPointer, NULL, &Revision );

                if (err != ERROR_SUCCESS) {
                    goto cardSyntaxError;
                }
                RevPresent = TRUE;

            } else if (IsSubString( NETINF_IOSUBS_STRING, hwPointer, FALSE )) {

                hwPointer += ((sizeof(NETINF_IOSUBS_STRING)/sizeof(WCHAR)) - 1);

                err = GetHexValueFromHw( &hwPointer, &Subsystem, NULL);

                if (err != ERROR_SUCCESS) {
                    goto cardSyntaxError;
                }
                SubPresent = TRUE;

            } else {

                //
                //  we hit something else.  hmmm.. bail on this one.
                //

                goto cardSyntaxError;
            }
        }

    } else {

        // we should never get here unless we start supporting ISAPNP,
        // PCMCIA, etc

cardSyntaxError:

        BinlPrint(( DEBUG_NETINF, "Not supporting INF hw string of %S\n", HardwareID ));
        err = ERROR_NOT_SUPPORTED;
    }

    if ((err == ERROR_SUCCESS) &&
        ((Vendor == 0) ||
         (Device == 0))) {

        // both vendor and device are required for it to be valid.

        err = ERROR_NOT_SUPPORTED;
    }

    return err;
}

ULONG
GetHexValueFromHw (
    PWCHAR *String,      // this is updated.
    PULONG longValue,
    PUSHORT shortValue
    )
/*++

Routine Description:

    This function parses a hex integer out of the HardwareID field of
    the driver's detail record.  The string is of the form :

    pci\ven_8086&dev_1229&rev_01&subsys_00018086

    so this routine needs to convert the hex chars to a value.

Arguments:

    String - the input string that we manipulate by moving it to the end of
       the integer (we also move it past the '&' if there is one present.

    longValue - integer that we fill in if it's present

    shortValue - ushort that we fill in if it's present


Return Value:

    ERROR_INVALID_PARAMETER or ERROR_SUCCESS

--*/
{
    PWCHAR targetString = *String;
    ULONG value = 0;
    UCHAR ch;
    UCHAR hexChar;
    ULONG length = 0;
    ULONG maxLength = ( (shortValue != NULL) ?
                        (sizeof(USHORT) * 2) :
                        (sizeof(ULONG) * 2) );

    ch = LOBYTE( *targetString );

    while ((length++ < maxLength) && (ch != '\0') && (ch != '&')) {

        //
        //  convert from the ascii char to it's hex representation
        //

        if (ch >= '0' && ch <= '9') {

            hexChar = ch - '0';

        } else if (ch >= 'A' && ch <= 'F') {

            hexChar = ch - 'A' + 10;

        } else if (ch >= 'a' && ch <= 'f') {

            hexChar = ch - 'a' + 10;

        } else {

            break;
        }

        value = ( value << 4 ) | hexChar;

        targetString++;        // on to the next character
        ch = LOBYTE( *targetString );
    }

    if ((ch != '\0') && (ch != '&')) {

        return ERROR_INVALID_PARAMETER;
    }

    // skip all trailing ampersands... we allow more than one just to be
    // generous

    while (*targetString == L'&') {

        targetString++;
    }

    *String = targetString;

    if (longValue) {

        *longValue = value;
    }

    if (shortValue) {

        *shortValue = LOWORD( value );
    }

    return ERROR_SUCCESS;
}


BOOLEAN
IsSubString (
    PWCHAR subString,
    PWCHAR target,
    BOOLEAN ignoreCase
    )
//
//  our local version of memicmp so as not to pull in full c runtimes.
//
{
    LONG subStringLength = lstrlenW( subString );

    if (lstrlenW( target ) < subStringLength) {

        return FALSE;
    }
    return (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                            ignoreCase ? NORM_IGNORECASE : 0,
                            subString,
                            subStringLength,
                            target,
                            subStringLength         // note use same length
                            ) == 2);
}

// infutil.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\ds.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    ds.c

Abstract:

    This module contains the code to process OS Chooser message
    for the BINL server.

Author:

    Adam Barr (adamba)  9-Jul-1997
    Geoff Pease (gpease) 10-Nov-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

#include <math.h>  // pow() function

#include <riname.h>

#include <riname.c>

DWORD
OscGetUserDetails (
    PCLIENT_STATE clientState
    )
//
//  This function fills in USERDOMAIN, USERFIRSTNAME, USERLASTNAME, USEROU in
//  the client state.  Also fills in ROOTDOMAIN for root of enterprise.
//
{
    DWORD  Error = ERROR_SUCCESS;
    DWORD  Count;

    LPWSTR pszUserName = OscFindVariableW( clientState, "USERNAME" );
    LPWSTR pUserDomain = OscFindVariableW( clientState, "USERDOMAIN" );
    LPWSTR pUserOU = OscFindVariableW( clientState, "USEROU" );
    LPWSTR pUserFullName = OscFindVariableW( clientState, "USERFULLNAME" );

    PLDAP LdapHandle;
    PLDAPMessage LdapMessage = NULL;
    WCHAR  Filter[256];
    PWCHAR ldapAttributes[5];
    BOOLEAN impersonating = FALSE;
    PLDAPMessage ldapEntry;
    PWCHAR *ldapConfigContainer = NULL;
    PWCHAR *ldapDomain = NULL;
    PWCHAR *ldapFirstName = NULL;
    PWCHAR *ldapLastName = NULL;
    PWCHAR *ldapDisplayName = NULL;
    PWCHAR *ldapAccountName = NULL;
    BOOLEAN allocatedContainer = FALSE;
    PWCHAR configContainer = NULL;
    BOOLEAN firstNameValid = FALSE;
    BOOLEAN lastNameValid = FALSE;

    BOOLEAN userFullNameSet = FALSE;

    PLDAPControlW controlArray[2];
    LDAPControlW controlNoReferrals;
    ULONG noReferralsPlease;

    PWCHAR ldapUserDN = NULL;
    PWCHAR *explodedDN = NULL;
    PWCHAR dnUsersOU = NULL;

    TraceFunc( "OscGetUserDetails( )\n" );
    if ( pszUserName[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "USERNAME" );
        return ERROR_BINL_MISSING_VARIABLE;
    }

    //
    // If the USERFULLNAME variable already exists, we won't change it below.
    // But if it came back as an empty string, that might actually mean
    // that the variable doesn't exist. In such a case, when SearchAndReplace
    // processes the .SIF file for the client, it will leave occurrences of
    // "%USERFULLNAME%" alone -- it won't replace them with "". We don't want
    // "%USERFULLNAME% to hang around, so we explicitly set it to an empty
    // string if it doesn't already exist or is an empty string. We do the
    // same thing with USERFIRSTNAME, USERLASTNAME, and USERDISPLAYNAME.
    //

    if (pUserFullName[0] != L'\0') {
        userFullNameSet = TRUE;
    } else {
        OscAddVariableW( clientState, "USERFULLNAME", L"" );
    }

    {
        LPWSTR name;
        name = OscFindVariableW( clientState, "USERFIRSTNAME" );
        if (name[0] == L'\0') {
            OscAddVariableW( clientState, "USERFIRSTNAME", L"" );
        }
        name = OscFindVariableW( clientState, "USERLASTNAME" );
        if (name[0] == L'\0') {
            OscAddVariableW( clientState, "USERLASTNAME", L"" );
        }
        name = OscFindVariableW( clientState, "USERDISPLAYNAME" );
        if (name[0] == L'\0') {
            OscAddVariableW( clientState, "USERDISPLAYNAME", L"" );
        }
    }

    if ( pUserOU[0] != L'\0' ) {

        //
        // if we've already found this user's info, bail here with success.
        //
        return ERROR_SUCCESS;
    }

    //
    // if the users domain and the servers domain don't match,
    // then try connecting to the DC for the new domain.  If we
    // don't do this, then we won't necessarily be able to get 
    // the correct information about the user.  By connecting to
    // the new DC, we get the clientState to cache some information
    // about the new domain.
    //
    if (pUserDomain[0] != L'\0' ) {
        PWSTR CrossDC = OscFindVariableW( clientState, "DCNAME" );
        if ( (CrossDC[0] == L'\0') && 
             (_wcsicmp(pUserDomain, BinlGlobalOurDomainName) != 0)) {
            HANDLE hDC;
            PSTR pUserDomainA = OscFindVariableA( clientState, "USERDOMAIN" );
            Error = MyGetDcHandle(clientState, pUserDomainA,&hDC);
            if (Error == ERROR_SUCCESS) {
                DsUnBindA(&hDC);
            }
        }
    }

    Error = OscImpersonate(clientState);
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((DEBUG_ERRORS,
                   "OscGetUserDetails: OscImpersonate failed %lx\n", Error));
        return Error;
    }
    impersonating = TRUE;

    BinlAssert( clientState->AuthenticatedDCLdapHandle != NULL );

    LdapHandle = clientState->AuthenticatedDCLdapHandle;

    //
    //  we first look up the configuration and default container, we'll need
    //  one or the other, based on whether we have a domain name or not.
    //

    ldapAttributes[0] = L"configurationNamingContext";
    ldapAttributes[1] = L"rootDomainNamingContext";
    ldapAttributes[2] = NULL;

    Error = ldap_search_ext_sW(LdapHandle,
                               NULL,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               ldapAttributes,
                               FALSE,
                               NULL,
                               NULL,
                               0,
                               0,
                               &LdapMessage);

    Count = ldap_count_entries( LdapHandle, LdapMessage );

    if (Count > 0) {

        ldapEntry = ldap_first_entry( LdapHandle, LdapMessage );

        if (ldapEntry != NULL) {

            ldapConfigContainer = ldap_get_valuesW( LdapHandle,
                                                    ldapEntry,
                                                    L"configurationNamingContext" );

            ldapDomain = ldap_get_valuesW( LdapHandle,
                                           ldapEntry,
                                           L"rootDomainNamingContext" );

            if (ldapDomain != NULL &&
                *ldapDomain != NULL &&
                **ldapDomain != L'\0') {

                OscAddVariableW( clientState, "ROOTDOMAIN", *ldapDomain );
            }
        }
    } else {
        LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                        LdapGetLastError(),
                        LdapHandle
                        );
    }
    ldap_msgfree( LdapMessage );

    //
    //  we either have the config container or the default domain DN.  If
    //  we only have the config container, go get the correct domain DN.
    //

    if ( pUserDomain[0] != L'\0' ) {

        //
        // Since the user specified a domain, remove the defaulting to the same domain
        // as the RIS server.
        //
        ldapDomain = NULL;

        //
        //  if a domain was specified, then we look it up to find the baseDN
        //
        //  we fail if we didn't get the config container
        //

        if (ldapConfigContainer == NULL ||
            *ldapConfigContainer == NULL ||
            **ldapConfigContainer == L'\0') {

            if (Error == LDAP_SUCCESS) {
                Error = LDAP_NO_SUCH_ATTRIBUTE;
            }
            BinlPrintDbg((DEBUG_ERRORS,
                       "OscGetUserDetails: get config container failed %lx\n", Error));
            Error = LdapMapErrorToWin32( Error );
            goto exitGetUserDetails;
        }

        //
        //  we then tack on "CN=Partitions," to search the partitions container
        //

        Count = lstrlenW( *ldapConfigContainer ) + lstrlenW( L"CN=Partitions," ) + 1;

        configContainer = BinlAllocateMemory( Count * sizeof(WCHAR) );

        if (configContainer == NULL) {

            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            goto exitGetUserDetails;
        }

        lstrcpyW(  configContainer, L"CN=Partitions," );
        lstrcatW(  configContainer, *ldapConfigContainer );

        //
        //  then we find the correct partition, we ignore the enterprise and
        //  enterprise schema entries by specifying a non-empty netbios name.
        //

        ldapAttributes[0] = L"NCName";
        ldapAttributes[1] = NULL;

        wsprintf( Filter, L"(&(objectClass=CrossRef)(netbiosName=*)(|(dnsRoot=%s)(cn=%s)))",
                          pUserDomain, pUserDomain );

        Error = ldap_search_ext_sW(LdapHandle,
                                  configContainer,
                                  LDAP_SCOPE_ONELEVEL,
                                  Filter,
                                  ldapAttributes,
                                  FALSE,
                                  NULL,
                                  NULL,
                                  0,
                                  0,
                                  &LdapMessage);

        Count = ldap_count_entries( LdapHandle, LdapMessage );

        if (Count > 0) {

            PWCHAR *ldapDomainFromPartition = NULL;

            ldapEntry = ldap_first_entry( LdapHandle,
                                          LdapMessage );

            if (ldapEntry != NULL) {

                ldapDomainFromPartition = ldap_get_valuesW( LdapHandle,
                                                            ldapEntry,
                                                            L"NCName" );
                if (ldapDomainFromPartition != NULL) {

                    //
                    //  if we read a valid DN from the partitions container,
                    //  we free the default one and switch over to the
                    //  one we just found.
                    //

                    if (*ldapDomainFromPartition != NULL &&
                        **ldapDomainFromPartition != L'\0') {

                        ldap_value_free( ldapDomain );
                        ldapDomain = ldapDomainFromPartition;

                    } else {

                        ldap_value_free( ldapDomainFromPartition );
                    }

                }

            }

        } else {

            LogLdapError( EVENT_WARNING_LDAP_SEARCH_ERROR, LdapGetLastError(), LdapHandle);

        }

        ldap_msgfree( LdapMessage );

    } else if ((ldapDomain != NULL) && (*ldapDomain != NULL) && (**ldapDomain != L'\0')) {
        
        //
        //  Add the user's domain as a variable to the client state.
        //
        OscAddVariableW( clientState, "USERDOMAIN", *ldapDomain );
        pUserDomain = OscFindVariableW( clientState, "USERDOMAIN" );
    }

    if (ldapDomain == NULL ||
        *ldapDomain == NULL ||
        **ldapDomain == L'\0') {

        if (Error == LDAP_SUCCESS) {
            Error = LDAP_NO_SUCH_ATTRIBUTE;
        }
        BinlPrintDbg((DEBUG_ERRORS,
                   "OscGetUserDetails: get default domain failed %lx\n", Error));
        Error = LdapMapErrorToWin32( Error );
        goto exitGetUserDetails;
    }


    //
    //  go find the user's first name, last name, display name,
    //  and account name from the DS.
    //

    ldapAttributes[0] = &L"givenName";
    ldapAttributes[1] = &L"sn";
    ldapAttributes[2] = &L"displayName";
    ldapAttributes[3] = &L"cn";
    ldapAttributes[4] = NULL;

    wsprintf( Filter, L"(&(objectClass=user)(samAccountName=%s))", pszUserName );

    //
    //  we really don't want it to go chasing referrals over the entire
    //  enterprise since we know what the domain is but we do want to chase
    //  externals.
    //

    noReferralsPlease = (ULONG)((ULONG_PTR)LDAP_CHASE_EXTERNAL_REFERRALS);
    controlNoReferrals.ldctl_oid = LDAP_CONTROL_REFERRALS_W;
    controlNoReferrals.ldctl_value.bv_len =  sizeof(ULONG);
    controlNoReferrals.ldctl_value.bv_val =  (PCHAR) &noReferralsPlease;
    controlNoReferrals.ldctl_iscritical = FALSE;

    controlArray[0] = &controlNoReferrals;
    controlArray[1] = NULL;

    Error = ldap_search_ext_sW(LdapHandle,
                              *ldapDomain,
                              LDAP_SCOPE_SUBTREE,
                              Filter,
                              ldapAttributes,
                              FALSE,
                              NULL,
                              &controlArray[0],
                              0,
                              1,
                              &LdapMessage);

    Count = ldap_count_entries( LdapHandle, LdapMessage );

    if (Count > 0) {

        ldapEntry = ldap_first_entry( LdapHandle, LdapMessage );

        if (ldapEntry != NULL) {

            ldapFirstName = ldap_get_valuesW( LdapHandle,
                                              ldapEntry,
                                             L"givenName" );

            if (ldapFirstName != NULL &&
                *ldapFirstName != NULL &&
                **ldapFirstName != L'\0') {

                OscAddVariableW( clientState, "USERFIRSTNAME", *ldapFirstName );
                firstNameValid = TRUE;
            }

            ldapLastName  = ldap_get_valuesW( LdapHandle,
                                              ldapEntry,
                                              L"sn" );
            if (ldapLastName != NULL &&
                *ldapLastName != NULL &&
                **ldapLastName != L'\0') {

                OscAddVariableW( clientState, "USERLASTNAME", *ldapLastName );
                lastNameValid = TRUE;
            }

            //
            // Now that we have first and last name, set the USERFULLNAME
            // if either is not empty.
            //

            if ((firstNameValid || lastNameValid) && (userFullNameSet == FALSE)) {

                ULONG userFullNameLength = 0;
                PWCHAR userFullName;

                if (firstNameValid) {
                    userFullNameLength = (wcslen(*ldapFirstName) + 1) * sizeof(WCHAR);
                }
                if (lastNameValid) {
                    if (firstNameValid) {
                        userFullNameLength += sizeof(WCHAR);  // for the space
                    }
                    userFullNameLength += (wcslen(*ldapLastName) + 1) * sizeof(WCHAR);
                }

                userFullName = BinlAllocateMemory(userFullNameLength);
                if (userFullName != NULL) {
                    userFullName[0] = L'\0';
                    if (firstNameValid) {
                        wcscat(userFullName, *ldapFirstName);
                    }
                    if (lastNameValid) {
                        if (firstNameValid) {
                            wcscat(userFullName, L" ");
                        }
                        wcscat(userFullName, *ldapLastName);
                    }
                    OscAddVariableW( clientState, "USERFULLNAME", userFullName);
                    BinlFreeMemory(userFullName);
                    userFullNameSet = TRUE;
                }
            }

            ldapDisplayName  = ldap_get_valuesW( LdapHandle,
                                                 ldapEntry,
                                                 L"displayName" );
            if (ldapDisplayName != NULL &&
                *ldapDisplayName != NULL &&
                **ldapDisplayName != L'\0') {

                OscAddVariableW( clientState, "USERDISPLAYNAME", *ldapDisplayName );
                if (!userFullNameSet) {
                    OscAddVariableW( clientState, "USERFULLNAME", *ldapDisplayName );
                    userFullNameSet = TRUE;
                }
            }

            ldapAccountName  = ldap_get_valuesW( LdapHandle,
                                                 ldapEntry,
                                                 L"cn" );
            if (ldapAccountName != NULL &&
                *ldapAccountName != NULL &&
                **ldapAccountName != L'\0') {

                OscAddVariableW( clientState, "USERACCOUNTNAME", *ldapAccountName );
                if (!userFullNameSet) {
                    OscAddVariableW( clientState, "USERFULLNAME", *ldapAccountName );
                    userFullNameSet = TRUE;
                }
            }

            ldapUserDN = ldap_get_dnW( LdapHandle, ldapEntry );

            if (ldapUserDN != NULL) {

                PWCHAR *explodedDN = ldap_explode_dnW( ldapUserDN, 0);

                if (explodedDN != NULL &&
                    *explodedDN != NULL &&
                    *(explodedDN+1) != NULL ) {

                    //
                    //  if there's less than two components, we can't do
                    //  anything with this DN.
                    //

                    PWCHAR component;
                    ULONG requiredSize = 1; // 1 for null terminator

                    //
                    //  we now have an array of strings, each of which
                    //  is a component of the DN.  This is the safe and
                    //  correct way to chop off the first element.
                    //

                    Count = 1;
                    while ((component = explodedDN[Count++]) != NULL) {

                        requiredSize += lstrlenW( component ) + 1;
                    }

                    dnUsersOU = BinlAllocateMemory( requiredSize * sizeof(WCHAR) );

                    if (dnUsersOU != NULL) {

                        lstrcpyW( dnUsersOU, explodedDN[1] );
                        Count = 2;
                        while ((component = explodedDN[Count++]) != NULL) {

                            lstrcatW( dnUsersOU, L"," );
                            lstrcatW( dnUsersOU, component );
                        }

                        OscAddVariableW( clientState, "USEROU", dnUsersOU );

                    } else {

                        BinlPrintDbg((DEBUG_ERRORS,
                           "OscGetUserDetails: unable to allocate %lx for user OU\n",
                            requiredSize * sizeof(WCHAR)));
                    }
                }
            }
        }
    } else {
        LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                        LdapGetLastError(),
                        LdapHandle
                        );
    }

    ldap_msgfree( LdapMessage );

    Error = ERROR_SUCCESS;

exitGetUserDetails:

    if (dnUsersOU != NULL) {
        BinlFreeMemory( dnUsersOU );
    }
    if (explodedDN != NULL) {
        ldap_value_free( explodedDN );
    }
    if (ldapUserDN != NULL) {
        ldap_memfree( ldapUserDN );
    }
    if (ldapConfigContainer != NULL) {
        ldap_value_free( ldapConfigContainer );
    }
    if (ldapDomain != NULL) {
        ldap_value_free( ldapDomain );
    }
    if (ldapFirstName != NULL) {
        ldap_value_free( ldapFirstName );
    }
    if (ldapLastName != NULL) {
        ldap_value_free( ldapLastName );
    }
    if (ldapDisplayName != NULL) {
        ldap_value_free( ldapDisplayName );
    }
    if (ldapAccountName != NULL) {
        ldap_value_free( ldapAccountName );
    }
    if (impersonating) {
        OscRevert( clientState );
    }
    if (configContainer != NULL) {
         BinlFreeMemory( configContainer );
    }
    return Error;
}

DWORD
OscCreateAccount(
    PCLIENT_STATE clientState,
    PCREATE_DATA CreateData
    )
/*++

Routine Description:

    This function creates an account for the client specified by
    RequestContext and writes the response in CreateData, which
    will be sent down to the client.

    It also creates the client's base image directory.

Arguments:

    clientState - client state information

    CreateData - The block of data that will be sent down to the
        client if the account is successfully created.

Return Value:

    None.

--*/
{
    DWORD  Error;
    PWCHAR pMachineName;
    PWCHAR pMachineDN = NULL;
    PWCHAR pMachineOU;
    WCHAR  SetupPath[MAX_PATH];
    PWCHAR pNameDollarSign;
    ULONG  HostNameSize;
    UINT   uSize;
    LPSTR  pGuid;
    PWCHAR pStrings[3];
    
    MACHINE_INFO MachineInfo = { 0 };

    TraceFunc("OscCreateAccount( )\n");

    pMachineName = OscFindVariableW( clientState, "MACHINENAME" );
    pNameDollarSign = OscFindVariableW( clientState, "NETBIOSNAME" );

    //
    // Convert the GUID
    //
    pGuid = OscFindVariableA( clientState, "GUID" );
    Error = OscGuidToBytes( pGuid, MachineInfo.Guid );
    if ( Error != ERROR_SUCCESS )
        goto e0;

    if (clientState->fCreateNewAccount) {

        //
        // Create client's FQDN(DS)
        //
        pMachineOU = OscFindVariableW( clientState, "MACHINEOU" );
        BinlAssert( pMachineOU[0] != L'\0' );
        uSize = wcslen( pMachineName ) * sizeof(WCHAR)
              + wcslen( pMachineOU ) * sizeof(WCHAR)
              + sizeof(L"CN=,"); // includes terminating NULL char
        pMachineDN = (PWCHAR) BinlAllocateMemory( uSize );
        if ( !pMachineDN ) {
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            goto e0;
        }
        wsprintf( pMachineDN, L"CN=%ws,%ws", pMachineName, pMachineOU );
        OscAddVariableW( clientState, "MACHINEDN", pMachineDN );

    } else {

        pMachineDN = OscFindVariableW( clientState, "MACHINEDN" );
    }

    //
    // Create the full setup path
    //
    wsprintf( SetupPath,
              L"\\\\%ws\\REMINST\\%ws",
              OscFindVariableW( clientState, "SERVERNAME" ),
              OscFindVariableW( clientState, "INSTALLPATH" ) );



    EnterCriticalSection( &gcsParameters );

    if ( BinlGlobalOurDnsName == NULL ) {

        LeaveCriticalSection( &gcsParameters );
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto e0;
    }

    MachineInfo.HostName = (PWCHAR) BinlAllocateMemory( ( lstrlenW( BinlGlobalOurDnsName ) + 1 ) * sizeof(WCHAR) );
    if ( !MachineInfo.HostName ) {

        LeaveCriticalSection( &gcsParameters );
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto e0;
    }

    lstrcpyW( MachineInfo.HostName, BinlGlobalOurDnsName );

    LeaveCriticalSection( &gcsParameters );

    //
    // Fill in the rest of the MachineInfo structure
    //
    MachineInfo.Name           = pMachineName;
    MachineInfo.MachineDN      = pMachineDN;
#if 1
    //
    // Don't store BOOTFILE in the cache/DS, since BOOTFILE points to setupldr
    // and we want the cache entry to point to oschooser. If we store an
    // empty string in the cache/DS, then GetBootParametersExt() will replace
    // that with the path to oschooser.
    //
    MachineInfo.BootFileName   = L"";
#else
    MachineInfo.BootFileName   = OscFindVariableW( clientState, "BOOTFILE" );
#endif
    MachineInfo.SetupPath      = SetupPath;
    MachineInfo.SamName        = pNameDollarSign;
    MachineInfo.Password       = clientState->MachineAccountPassword;
    MachineInfo.PasswordLength = clientState->MachineAccountPasswordLength;
    MachineInfo.dwFlags        = MI_NAME
                               | MI_HOSTNAME
                               | MI_BOOTFILENAME
                               | MI_SETUPPATH
                               | MI_SAMNAME
                               | MI_PASSWORD
                               | MI_MACHINEDN
                               | MI_GUID;

    //
    // Create the MAO in the DS
    //
    Error = UpdateAccount( clientState,
                           &MachineInfo,
                           clientState->fCreateNewAccount );  // create it
    if ( Error ) {
        goto e0;
    }

    //
    // Create the response to the client
    //
    Error = OscConstructSecret( 
                    clientState, 
                    clientState->MachineAccountPassword, 
                    clientState->MachineAccountPasswordLength, 
                    CreateData );
    if ( Error != ERROR_SUCCESS ) {
        OscCreateWin32SubError( clientState, Error );
        Error = ERROR_BINL_FAILED_TO_INITIALIZE_CLIENT;
        goto e0;
    }

    BinlPrint(( DEBUG_OSC, "Successfully created account for <%ws>\n", pMachineName ));
    pStrings[0] = pMachineName;
    pStrings[1] = OscFindVariableW( clientState, "USERNAME" );
    BinlReportEventW( EVENT_COMPUTER_ACCOUNT_CREATED_SUCCESSFULLY,
                      EVENTLOG_INFORMATION_TYPE,
                      2,
                      0,
                      pStrings,
                      0 );

e0:
    // No need to call FreeMachineInfo() since all the information
    // in it is either allocated on the stack or is referenced
    // by the clientState, but we do need to free the HostName
    // since it is allocated above.
    if ( MachineInfo.HostName ) {
        BinlFreeMemory( MachineInfo.HostName );
    }

    if ( pMachineDN && clientState->fCreateNewAccount ) {
        BinlFreeMemory( pMachineDN );
    }
    return Error;
}


//
// CheckForDuplicateMachineName( )
//
DWORD
CheckForDuplicateMachineName(
    PCLIENT_STATE clientState,
    LPWSTR pszMachineName )
{
    DWORD Error = ERROR_SUCCESS;
    PLDAPMessage LdapMessage = NULL;
    WCHAR  Filter[128];
    DWORD  count;
    PWCHAR ComputerAttrs[2];
    LPWSTR pDomain = OscFindVariableW( clientState, "MACHINEOU" );
    PWCHAR BaseDN;
    PLDAP LdapHandle;
    ULONG ldapRetryLimit = 0;
    PWCHAR *gcBase;

    PLDAPControlW controlArray[2];
    LDAPControlW controlNoReferrals;
    ULONG noReferralsPlease;

    ComputerAttrs[0] = &L"cn";
    ComputerAttrs[1] = NULL;

    TraceFunc( "CheckForDuplicateMachineName( )\n" );

    if (pDomain[0] == L'\0') {

        pDomain = OscFindVariableW( clientState, "USERDOMAIN" );
        BinlPrintDbg((DEBUG_ERRORS, "CheckforDupMachine: couldn't find root domain, using user's domain %ws\n.", pDomain));
    }

    BaseDN = StrStrIW( pDomain, L"DC=" );

    if (BaseDN == NULL) {
        BaseDN = pDomain;
    }

    LdapHandle = clientState->AuthenticatedDCLdapHandle;

    BinlAssert( LdapHandle != NULL );

    //
    //  According to the DS guys, it's not necessarily the case that CN is
    //  equal to SamAccountName and the latter is the important one.  It has
    //  a dollar sign at the end, so we'll tack that on.
    //

    wsprintf( Filter, L"(&(objectClass=Computer)(samAccountName=%s", pszMachineName );
    lstrcatW( Filter, L"$))" );

    //
    //  we really don't want it to go chasing subordinate referrals over
    //  the entire enterprise since we know what the domain is, therefore
    //  limit it to only external referrals (for child domains).
    //

    noReferralsPlease = (ULONG)((ULONG_PTR) LDAP_CHASE_EXTERNAL_REFERRALS);
    controlNoReferrals.ldctl_oid = LDAP_CONTROL_REFERRALS_W;
    controlNoReferrals.ldctl_value.bv_len =  sizeof(ULONG);
    controlNoReferrals.ldctl_value.bv_val =  (PCHAR) &noReferralsPlease;
    controlNoReferrals.ldctl_iscritical = FALSE;

    controlArray[0] = &controlNoReferrals;
    controlArray[1] = NULL;

Retry:
    Error = ldap_search_ext_s(LdapHandle,
                              BaseDN,
                              LDAP_SCOPE_SUBTREE,
                              Filter,
                              ComputerAttrs,
                              FALSE,
                              NULL,
                              &controlArray[0],
                              0,
                              1,
                              &LdapMessage);
    switch ( Error )
    {
    case LDAP_SUCCESS:
        break;

    case LDAP_BUSY:
        if (++ldapRetryLimit < LDAP_BUSY_LIMIT) {
            Sleep( LDAP_BUSY_DELAY );
            goto Retry;
        }

        // lack of break is on purpose.

    default:
        OscCreateLDAPSubError( clientState, Error );
        LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                        Error,
                        LdapHandle
                        );
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!!LdapError 0x%08x - Failed search to create machine name.\n", Error ));
        goto exitCheck;
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );
    if ( count != 0 ) {
        Error = -1; // signal multiple accounts
        goto exitCheck;
    }

    ldap_msgfree( LdapMessage );
    LdapMessage = NULL;

    //
    //  now we go check the GC.
    //

    gcBase = NULL;

    Error = InitializeConnection( TRUE, &LdapHandle, &gcBase );
    if ( Error != ERROR_SUCCESS ) {

        //
        //  if no GC is present or available, we'll let this call succeed.
        //  Reasoning here is GCs can be flaky creatures.
        //
        Error = ERROR_SUCCESS;
        goto exitCheck;
    }

    ldapRetryLimit = 0;

RetryGC:
    Error = ldap_search_ext_s(LdapHandle,
                              *gcBase,
                              LDAP_SCOPE_SUBTREE,
                              Filter,
                              ComputerAttrs,
                              FALSE,
                              NULL,
                              NULL,
                              0,
                              1,
                              &LdapMessage);
    switch ( Error )
    {
    case LDAP_SUCCESS:
        break;

    case LDAP_BUSY:
        if (++ldapRetryLimit < LDAP_BUSY_LIMIT) {
            Sleep( LDAP_BUSY_DELAY );
            goto RetryGC;
        }

        // lack of break is on purpose.

    default:
        OscCreateLDAPSubError( clientState, Error );
        LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                        Error,
                        LdapHandle
                        );
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!!LdapError 0x%08x - Failed search to create machine name.\n", Error ));
        goto exitCheck;
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );

    if ( count != 0 ) {

        Error = -1; // signal multiple accounts

    } else {

        Error = ERROR_SUCCESS;
    }

exitCheck:

    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
    }
    return Error;
}

//
// GenerateMachineName( )
//

DWORD
GenerateMachineName(
    PCLIENT_STATE clientState
    )
{
    DWORD  Error = ERROR_SUCCESS;
    GENNAME_VARIABLES variables;
    WCHAR  szMachineName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    DWORD  Count = 1;
    LPWSTR missingVariable;
    BOOL usedCounter;

    LPWSTR pszUserName;
    LPWSTR pszFirstName;
    LPWSTR pszLastName;
    LPWSTR pUserOU;
    LPWSTR pszMAC;

    TraceFunc( "GenerateMachineName( )\n" );

    pszUserName = OscFindVariableW( clientState, "USERNAME" );

    if ( pszUserName[0] == L'\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "USERNAME" );
        return ERROR_BINL_MISSING_VARIABLE;
    }

    Error = OscGetUserDetails( clientState );

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((DEBUG_OSC_ERROR,
                   "GenerateMachineName: OscGetUserDetails failed %lx\n", Error));
        return Error;
    }

    pszFirstName = OscFindVariableW( clientState, "USERFIRSTNAME" );
    pszLastName = OscFindVariableW( clientState, "USERLASTNAME" );
    pUserOU = OscFindVariableW( clientState, "USEROU" );
    pszMAC = OscFindVariableW( clientState, "MAC" );

    variables.UserName = pszUserName;
    variables.FirstName = pszFirstName;
    variables.LastName = pszLastName;
    variables.MacAddress = pszMAC;
    variables.AllowCounterTruncation = FALSE;

TryAgain:

    variables.Counter = ++clientState->nCreateAccountCounter;

    EnterCriticalSection( &gcsParameters );

    Error = GenerateNameFromTemplate(
                NewMachineNamingPolicy,
                &variables,
                szMachineName,
                DNS_MAX_LABEL_BUFFER_LENGTH,
                &missingVariable,
                &usedCounter,
                NULL
                );

    LeaveCriticalSection( &gcsParameters );

    if ( (Error != GENNAME_NO_ERROR) && (Error != GENNAME_NAME_TOO_LONG) ) {
        if ( Error == GENNAME_VARIABLE_MISSING ) {
            OscAddVariableW( clientState, "SUBERROR", missingVariable );
            clientState->nCreateAccountCounter = 0;
            return ERROR_BINL_MISSING_VARIABLE;
        }
        BinlAssert( (Error == GENNAME_COUNTER_TOO_HIGH) || (Error = GENNAME_TEMPLATE_INVALID) );
        clientState->nCreateAccountCounter = 0;
        return ERROR_BINL_UNABLE_TO_GENERATE_MACHINE_NAME;
    }

    BinlPrint(( DEBUG_OSC, "Generated MachineName = %ws\n", szMachineName ));

    Error = CheckForDuplicateMachineName( clientState, szMachineName );
    if ( Error == -1 ) {
        if ( usedCounter ) {
            goto TryAgain;
        }
        Error = ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND;
    } else if ( Error == LDAP_SIZELIMIT_EXCEEDED ) {
        BinlPrint(( DEBUG_OSC, "MachineName '%s' has mutliple accounts already.\n", szMachineName ));
        if ( usedCounter ) {
            goto TryAgain;
        }
    } else if ( Error != LDAP_SUCCESS ) {
        Error = ERROR_BINL_UNABLE_TO_GENERATE_MACHINE_NAME;
    } else {
        BinlPrintDbg(( DEBUG_OSC, "MachineName: '%ws'\n", szMachineName ));
        Error = OscAddVariableW( clientState, "MACHINENAME", szMachineName );
        if ( Error == ERROR_SUCCESS ) {

            WCHAR  NameDollarSign[17];  // MACHINENAME(15)+'$'+'\0'
            UINT   uSize;

            clientState->fAutomaticMachineName = TRUE;

            uSize = sizeof(NameDollarSign);
            // DnsHostnameToComputerNameW takes BYTEs in and returns the # of WCHARs out.
            if ( !DnsHostnameToComputerNameW( szMachineName, NameDollarSign, &uSize ) ) {
                // if this fails(?), default to truncating machine name and
                // add '$' to the end
                BinlPrintDbg((DEBUG_OSC_ERROR, "!! Error 0x%08x - DnsHostnameToComputerNameW failed.\n", GetLastError() ));
                BinlPrintDbg((DEBUG_OSC, "WARNING: Truncating machine name to 15 characters to generated NETBIOS name.\n" ));
                memset( NameDollarSign, 0, sizeof(NameDollarSign) );
                wcsncpy( NameDollarSign, szMachineName, 15 );
            }
            wcscat( NameDollarSign, L"$");
            Error = OscAddVariableW( clientState, "NETBIOSNAME", NameDollarSign );
        }
    }

    clientState->nCreateAccountCounter = 0;

    return Error;

    
}

DWORD
OscCheckMachineDN(
    PCLIENT_STATE clientState
    )
//
//  Ensure that the client name, OU, and domain are setup correctly.  If there
//  are duplicate records in the DS with this same guid, we'll return
//  ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND and set %SUBERROR% string to
//  those DNs and return an error.
//
{
    DWORD    dwErr = ERROR_SUCCESS;
    PWCHAR   pwc;                       // parsing pointer
    WCHAR    wch;                       // temp wide char
    PWCHAR   pMachineName;              // Pointer to Machine Name variable value
    PWCHAR   pMachineOU;                // Pointer to where the MAO will be created
    PWCHAR   pDomain;                   // Pointer to Domain variable name
    PCHAR    pGuid;                     // Pointer to Guid variable name
    WCHAR    NameDollarSign[17];  // MACHINENAME(15)+'$'+'\0'
    WCHAR    Path[MAX_PATH];            // general purpose path buffer
    ULONG    i;                         // general counter
    BOOL     b;                         // general purpose BOOLean.
    UINT     uSize;
    UCHAR Guid[ BINL_GUID_LENGTH ];
    PMACHINE_INFO pMachineInfo = NULL;
    USHORT   SystemArchitecture;
    DWORD    DupRecordCount;

    TraceFunc("OscCheckMachineDN( )\n");

    if ( clientState->fHaveSetupMachineDN ) {

        // we've been through this logic before, just exit here with success.
        dwErr = ERROR_SUCCESS;
        goto e0;
    }

    dwErr = OscGetUserDetails( clientState );
    
    if (dwErr != ERROR_SUCCESS) {
        BinlPrintDbg((DEBUG_OSC_ERROR,
                   "OscCheckMachineDN: OscGetUserDetails failed %lx\n", dwErr));
        goto e0;
    }

    pGuid = OscFindVariableA( clientState, "GUID" );
    if ( pGuid[0] == '\0' ) {
        OscAddVariableA( clientState, "SUBERROR", "GUID" );
        dwErr = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    dwErr = OscGuidToBytes( pGuid, Guid );
    if ( dwErr != ERROR_SUCCESS ) {
        goto e0;
    }

    // Do we have a machine name yet?
    clientState->fCreateNewAccount = TRUE;
    pMachineName  = OscFindVariableW( clientState, "MACHINENAME" );
    if ( pMachineName[0] == L'\0' ) {

        clientState->CustomInstall = FALSE;

    } else {

        clientState->CustomInstall = TRUE;
    }

    clientState->fHaveSetupMachineDN = TRUE;


    SystemArchitecture = OscPlatformToArchitecture(clientState);
    

    //
    // See if the client already has an account with a matching GUID
    //
    dwErr = GetBootParameters( Guid,
                               &pMachineInfo,
                               MI_NAME | MI_DOMAIN | MI_MACHINEDN,
                               SystemArchitecture,
                               FALSE );    

    if (( dwErr == ERROR_SUCCESS ) &&
        ( !clientState->CustomInstall )) {

        PWCHAR pszOU;

        //
        // Since we asked for these, they should be set.
        //
        ASSERT ( pMachineInfo->dwFlags & MI_NAME );
        ASSERT ( pMachineInfo->dwFlags & MI_MACHINEDN );

        //
        //  if this is an automatic install, then we simply set the
        //  account info to the account we found.
        //

        // skip the comma
        pszOU = wcschr( pMachineInfo->MachineDN, L',' );
        if (pszOU) {
            pszOU++;
            OscAddVariableW( clientState, "MACHINEOU", pszOU );
        }

        OscAddVariableW( clientState, "MACHINEDN", pMachineInfo->MachineDN );

        dwErr = OscAddVariableW( clientState, "MACHINENAME", pMachineInfo->Name );
        if ( dwErr != ERROR_SUCCESS ) {
            BinlPrintDbg((DEBUG_OSC_ERROR,
                       "!!Error 0x%08x - OscCheckMachineDN: Unable to add MACHINENAME variable\n", dwErr ));
            goto e0;
        }
        clientState->fCreateNewAccount = FALSE;

        if ( pMachineInfo->dwFlags & MI_DOMAIN ) {
            OscAddVariableW( clientState, "MACHINEDOMAIN", pMachineInfo->Domain );
        }
    }

    //
    //  Do we have an OU yet?
    //
    pMachineOU = OscFindVariableW( clientState, "MACHINEOU" );
    if ( pMachineOU[0] == L'\0' ) {

        //
        //  Here's how we determine the OU...
        //
        //  if this is an auto, then MACHINEOU shouldn't already have
        //  been set by now.  If it's custom, then MACHINEOU may be empty
        //  or it may be set to what the user wants it set to.
        //
        //  if it's not already set, then we look at BinlGlobalDefaultContainer.
        //
        //  if this value is equal to the server's DN, then we set it to the
        //  default for this domain.
        //
        //  if BinlGlobalDefaultContainer is empty, then we set it to the
        //  user's OU.
        //

        if ( BinlGlobalServerDN == NULL ) {

            dwErr = ERROR_BINL_NO_DN_AVAILABLE_FOR_SERVER;
            BinlPrintDbg((DEBUG_OSC_ERROR,
                       "!!Error - OscCheckMachineDN: BinlGlobalServerDN is null\n", dwErr ));
            goto e0;
        }

        EnterCriticalSection( &gcsParameters );

        if ( BinlGlobalServerDN &&
             StrCmpI( BinlGlobalDefaultContainer, BinlGlobalServerDN ) == 0) {

            //
            //  If the machine's OU is the same as this server's OU, then we set
            //  it to the default for this server's domain.
            //

            PWCHAR pDomain = StrStrIW( BinlGlobalServerDN, L"DC=" );
            ULONG dwErr;
            if ( pDomain ) {

                dwErr = OscGetDefaultContainerForDomain( clientState, pDomain );

                if (dwErr != ERROR_SUCCESS) {

                    BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not get default MACHINEOU, 0x%x\n",dwErr));
                }
            }
        } else {

            dwErr = OscAddVariableW( clientState, "MACHINEOU", BinlGlobalDefaultContainer );
            if ( dwErr != ERROR_SUCCESS ) {
                LeaveCriticalSection( &gcsParameters );
                BinlPrintDbg(( DEBUG_OSC_ERROR, "!!Error 0x%08x - Could not add MACHINEOU\n", dwErr ));
                goto e0;
            }
        }

        LeaveCriticalSection( &gcsParameters );

        pMachineOU = OscFindVariableW( clientState, "MACHINEOU" );
        if ( pMachineOU[0] == L'\0' ) {

            LPWSTR pUserOU = OscFindVariableW( clientState, "USEROU" );
            //
            //  the machine OU isn't already specified, that means we set it to
            //  the same as the user's OU.
            //

            if ( pUserOU[0] == L'\0' ) {
                BinlPrintDbg(( DEBUG_OSC_ERROR, "Missing UserOU variable\n" ));
                OscAddVariableA( clientState, "SUBERROR", "USEROU" );
                dwErr = ERROR_BINL_MISSING_VARIABLE;
                goto e0;
            }

            dwErr = OscAddVariableW( clientState, "MACHINEOU", pUserOU );
            if ( dwErr != ERROR_SUCCESS ) {
                BinlPrintDbg(( DEBUG_OSC_ERROR, "!!Error 0x%08x - Could not add MACHINEOU\n", dwErr ));
                goto e0;
            }

            pMachineOU = OscFindVariableW( clientState, "MACHINEOU" );
        }
    }

    //
    //  We need to generate the MACHINENAME after MACHINEOU because we need
    //  to know MACHINEOU to know which domain to check for duplicate
    //  machine names.
    //

    pMachineName = OscFindVariableW( clientState, "MACHINENAME" );

    if ( pMachineName[0] == L'\0' ) {

        dwErr = GenerateMachineName( clientState );
        if ( dwErr != ERROR_SUCCESS ) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "!!Error 0x%08x - Failed to generate machine name\n" ));
            goto e0;
        }
        // now we should have one
        pMachineName = OscFindVariableW( clientState, "MACHINENAME" );
    }
    BinlAssertMsg( pMachineName[0] != L'\0', "Missing MACHINENAME" );

    uSize = sizeof(NameDollarSign);
    // DnsHostnameToComputerNameW takes BYTEs in and returns the # of WCHARs out.
    if ( !DnsHostnameToComputerNameW( pMachineName, NameDollarSign, &uSize ) )
    {
        // if this fails(?), default to truncating machine name and
        // add '$' to the end
        BinlPrintDbg((DEBUG_OSC_ERROR, "!! Error 0x%08x - DnsHostnameToComputerNameW failed.\n", GetLastError( ) ));
        BinlPrintDbg((DEBUG_OSC, "WARNING: Truncating machine name to 15 characters to generated NETBIOS name.\n" ));
        memset( NameDollarSign, 0, sizeof(NameDollarSign) );
        wcsncpy( NameDollarSign, pMachineName, 15 );
        // don't return the error...
    }
    wcscat( NameDollarSign, L"$");
    OscAddVariableW( clientState, "NETBIOSNAME", NameDollarSign );

    // Do we have a domain yet?
    pDomain = OscFindVariableW( clientState, "MACHINEDOMAIN" );
    if ( pDomain[0] == L'\0' ) {

        // skip to the first "DC="
        pDomain = StrStrIW( pMachineOU, L"DC=" );
        if ( pDomain ) {

            PDS_NAME_RESULTW pResults;

            dwErr = DsCrackNames( INVALID_HANDLE_VALUE,
                                  DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                  DS_FQDN_1779_NAME,
                                  DS_CANONICAL_NAME,
                                  1,
                                  &pDomain,
                                  &pResults );
            BinlAssertMsg( dwErr == ERROR_SUCCESS, "Error in DsCrackNames" );

            if ( dwErr == ERROR_SUCCESS ) {
                if ( pResults->cItems == 1
                  && pResults->rItems[0].status == DS_NAME_NO_ERROR
                  && pResults->rItems[0].pName ) {    // paranoid
                    pResults->rItems[0].pName[wcslen(pResults->rItems[0].pName)-1] = L'\0';
                    OscAddVariableW( clientState, "MACHINEDOMAIN", pResults->rItems[0].pName );
                }

                DsFreeNameResult( pResults );

                pDomain = OscFindVariableW( clientState, "MACHINEDOMAIN" );
            } else {
                pDomain = NULL;
            }
        }
    }

    // All else fails default to the servers
    if ( !pDomain || pDomain[0] == '\0' )
    {
        OscAddVariableW( clientState,
                         "MACHINEDOMAIN",
                         OscFindVariableW( clientState, "SERVERDOMAIN" ) );
    }

    //
    //  check for duplicate accounts in the ds.  fail if we find any, though
    //  we only fail after we have everything setup in case the user on
    //  custom install wants to ignore the error.  For automatic, it's
    //  currently a fatal error but this could be changed in the osc screens.
    //

    if (( pMachineInfo != NULL ) &&
        ( pMachineInfo->dwFlags & MI_MACHINEDN )) {

        PDUP_GUID_DN dupDN;
        PLIST_ENTRY listEntry;

        if (( pMachineInfo->dwFlags & MI_NAME ) &&
            ( clientState->CustomInstall )) {

            //
            //  if this is a custom install, then we compare the account
            //  the user entered with all the existing accounts we found.
            //  We want to match both machine namd and OU (this is really
            //  just the DN but we have not necessarily constructed that
            //  yet).
            //
            //  First we try the main entry in the cache, then all of
            //  the rest in the DNsWithSameGuid list.
            //

            // skip the comma
            ULONG err;
            PWCHAR MachineDNToUse;
            PWCHAR pszOU = wcschr( pMachineInfo->MachineDN, L',' );
            if (pszOU) {
                pszOU++;
            }

            //
            //  See if the main machine name and OU in the cache
            //  entry match.
            //

            if ((CompareStringW(
                     LOCALE_SYSTEM_DEFAULT,
                     NORM_IGNORECASE,
                     pMachineName,
                     -1,
                     pMachineInfo->Name,
                     -1
                     ) != 2)
                ||
                ((pszOU == NULL) && (pMachineOU[0] != L'\0'))
                ||
                ((pszOU != NULL) &&
                 (CompareStringW(
                      LOCALE_SYSTEM_DEFAULT,
                      NORM_IGNORECASE,
                      pMachineOU,
                      -1,
                      pszOU,
                      -1
                      ) != 2))) {

                //
                // We did not match the main entry in the cache, so
                // keep looking.
                //

                for (listEntry = pMachineInfo->DNsWithSameGuid.Flink;
                     listEntry != &pMachineInfo->DNsWithSameGuid;
                     listEntry = listEntry->Flink) {

                    dupDN = CONTAINING_RECORD(listEntry, DUP_GUID_DN, ListEntry);

                    pszOU = wcschr( &dupDN->DuplicateName[dupDN->DuplicateDNOffset], L',' );
                    if (pszOU) {
                        pszOU++;
                    }

                    if ((CompareStringW(
                             LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             pMachineName,
                             -1,
                             dupDN->DuplicateName,
                             -1
                             ) != 2)
                        ||
                        ((pszOU == NULL) && (pMachineOU[0] != L'\0'))
                        ||
                        ((pszOU != NULL) &&
                         (CompareStringW(
                              LOCALE_SYSTEM_DEFAULT,
                              NORM_IGNORECASE,
                              pMachineOU,
                              -1,
                              pszOU,
                              -1
                              ) != 2))) {

                        //
                        // No match on this one.
                        //

                        continue;

                    } else {

                        //
                        // We found a match. Note which DN to use for
                        // this account.
                        //

                        MachineDNToUse = &dupDN->DuplicateName[dupDN->DuplicateDNOffset];
                        break;
                    }
                }

                //
                // If we got to the end of our list with no match, jump to
                // the error case.
                //

                if (listEntry == &pMachineInfo->DNsWithSameGuid) {
                    goto exitWithDupError;
                }

            } else {

                //
                // The main cache entry matched.
                //

                MachineDNToUse = pMachineInfo->MachineDN;
            }

            //
            //  We didn't jump to exitWithDupError above, so we found a match.
            //  we know that the client is using an existing account, let's
            //  mark the client state as such.  this is the custom case.
            //
            clientState->fCreateNewAccount = FALSE;

            OscAddVariableW( clientState, "MACHINEDN", MachineDNToUse );

            if ( pMachineInfo->dwFlags & MI_DOMAIN ) {
                OscAddVariableW( clientState, "MACHINEDOMAIN", pMachineInfo->Domain );
            }
        }

        if (!IsListEmpty(&pMachineInfo->DNsWithSameGuid)) {

            //
            //  if there's more than one account, we fill in SUBERROR
            //  with a list of the duplicates and return an error.
            //

            PWCHAR dnList;
            ULONG requiredSize;

exitWithDupError:
            //
            // since we tack a <BR> to the end of each string, we'll account
            // for it when we allocate the string as +4 from what we need.
            //
#define     MAX_DUPLICATE_RECORDS_TO_DISPLAY         4

            requiredSize = lstrlenW( pMachineInfo->Name ) + sizeof("<BR>");
            listEntry = pMachineInfo->DNsWithSameGuid.Flink;

            DupRecordCount = 0;
            while (listEntry != &pMachineInfo->DNsWithSameGuid) {                

                dupDN = CONTAINING_RECORD(listEntry, DUP_GUID_DN, ListEntry);
                listEntry = listEntry->Flink;
                DupRecordCount += 1;

                if (DupRecordCount <= MAX_DUPLICATE_RECORDS_TO_DISPLAY) {
                    requiredSize += lstrlenW( &dupDN->DuplicateName[0] ) + sizeof("<BR>");
                } else if (DupRecordCount == MAX_DUPLICATE_RECORDS_TO_DISPLAY+1) {
                    requiredSize += lstrlenW( L"..." ) + sizeof("<BR>");
                }
            }

            dnList = BinlAllocateMemory( requiredSize * sizeof(WCHAR) );

            DupRecordCount = 0;
            if (dnList != NULL) {

                ULONG  nameLength;

                nameLength = lstrlenW(pMachineInfo->Name);

                //
                // The Name field should not end in a '$'.
                //

                ASSERT (!((nameLength > 1) && (pMachineInfo->Name[nameLength-1] == L'$')));

                lstrcpyW( dnList, pMachineInfo->Name );
                lstrcatW( dnList, L"<BR>" );

                listEntry = pMachineInfo->DNsWithSameGuid.Flink;

                while (listEntry != &pMachineInfo->DNsWithSameGuid) {

                    dupDN = CONTAINING_RECORD(listEntry, DUP_GUID_DN, ListEntry);
                    listEntry = listEntry->Flink;

                    DupRecordCount += 1;

                    if (DupRecordCount <= MAX_DUPLICATE_RECORDS_TO_DISPLAY) {
                    
                        nameLength = lstrlenW(dupDN->DuplicateName);
    
                        //
                        // The DuplicateName field should not have the '$' either
                        //
    
                        ASSERT (!((nameLength > 1) && (dupDN->DuplicateName[nameLength-1] == L'$')));
    
                        lstrcatW( dnList, dupDN->DuplicateName );
                        lstrcatW( dnList, L"<BR>" );

                    } else if (DupRecordCount == MAX_DUPLICATE_RECORDS_TO_DISPLAY + 1) {
                        lstrcatW( dnList, L"..." );
                        lstrcatW( dnList, L"<BR>" );
                    }
                }
            } else {
                dnList = pMachineInfo->MachineDN;
            }

            OscAddVariableW( clientState, "SUBERROR", dnList );
            dwErr = ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND;
        }
    } else {
        //
        // We must not exist in the DS yet so there cannot be a duplicate.
        // set the error to successand return.
        //
        dwErr = ERROR_SUCCESS;
    }

e0:
    if ( pMachineInfo ) {
        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }
    return dwErr;
}

DWORD
OscGetDefaultContainerForDomain (
    PCLIENT_STATE clientState,
    PWCHAR DomainDN
    )
{
    PLDAP LdapHandle;
    PLDAPMessage LdapMessage = NULL;
    PWCHAR ldapAttributes[2];
    BOOLEAN impersonating = FALSE;
    PLDAPMessage ldapEntry;
    PWCHAR *ldapWellKnownObjectValues = NULL;
    PWCHAR objectValue;
    PWCHAR guidEnd;
    WCHAR savedChar;
    ULONG Error = LDAP_NO_SUCH_ATTRIBUTE;
    ULONG Count;

    if (clientState->AuthenticatedDCLdapHandle == NULL) {

        Error = OscImpersonate(clientState);
        if (Error != ERROR_SUCCESS) {
            BinlPrintDbg((DEBUG_ERRORS,
                       "OscGetDefaultContainer: OscImpersonate failed %lx\n", Error));
            return Error;
        }
        impersonating = TRUE;
        BinlAssert( clientState->AuthenticatedDCLdapHandle != NULL );
    }

    LdapHandle = clientState->AuthenticatedDCLdapHandle;

    //
    //  we look up the wellKnownObjects in the root of the domain
    //

    ldapAttributes[0] = L"wellKnownObjects";
    ldapAttributes[1] = NULL;

    Error = ldap_search_ext_sW(LdapHandle,
                               DomainDN,
                               LDAP_SCOPE_BASE,
                               L"objectclass=*",
                               ldapAttributes,
                               FALSE,
                               NULL,
                               NULL,
                               0,
                               0,
                               &LdapMessage);

    Count = ldap_count_entries( LdapHandle, LdapMessage );

    Error = LDAP_NO_SUCH_ATTRIBUTE;

    if (Count == 0) {

        BinlPrintDbg((DEBUG_ERRORS,
                   "OscGetDefaultContainer: get default domain failed with no records found\n"));
        LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                        Error,
                        LdapHandle
                        );
        goto exitGetDefaultContainer;
    }

    ldapEntry = ldap_first_entry( LdapHandle, LdapMessage );

    if (ldapEntry == NULL) {

        BinlPrintDbg((DEBUG_ERRORS,
                   "OscGetDefaultContainer: get first entry failed\n"));
        goto exitGetDefaultContainer;
    }

    ldapWellKnownObjectValues = ldap_get_valuesW( LdapHandle,
                                                  ldapEntry,
                                                  L"wellKnownObjects" );
    if (ldapWellKnownObjectValues == NULL) {

        BinlPrintDbg((DEBUG_ERRORS,"OscGetDefaultContainer: get value failed\n"));
        goto exitGetDefaultContainer;
    }

    Count = 0;
    objectValue = NULL;
    while (1) {

        objectValue = ldapWellKnownObjectValues[Count++];

        if (objectValue == NULL) {
            break;
        }

        //
        //  the structure of this particular field is :
        //  L"B:32:GUID:DN" where GUID is AA312825768811D1ADED00C04FD8D5CD
        //

        if (lstrlenW( objectValue ) <
            lstrlenW( COMPUTER_DEFAULT_CONTAINER_IN_B32_FORM )) {

            continue;
        }

        //
        //   see if it matches "B:32:specialGuid:" then DN follows
        //

        guidEnd = objectValue + lstrlenW( COMPUTER_DEFAULT_CONTAINER_IN_B32_FORM );
        savedChar = *guidEnd;
        *guidEnd = L'\0';

        if (lstrcmpiW( objectValue, COMPUTER_DEFAULT_CONTAINER_IN_B32_FORM) != 0) {

            *guidEnd = savedChar;
            continue;
        }

        *guidEnd = savedChar;   // this is the first character of the DN

        //
        //  we have our value, now copy it off.
        //

        OscAddVariableW( clientState, "MACHINEOU", guidEnd );

        Error = ERROR_SUCCESS;
        break;
    }

exitGetDefaultContainer:

    if (ldapWellKnownObjectValues) {
        ldap_value_free( ldapWellKnownObjectValues );
    }
    if (LdapMessage) {
        ldap_msgfree( LdapMessage );
    }
    if (impersonating) {
        OscRevert( clientState );
    }
    return Error;
}

VOID
LogLdapError (
    ULONG LdapEvent,
    ULONG LdapError,
    PLDAP LdapHandle OPTIONAL
    )
{
    PWCHAR Server = NULL;

    if (LdapError != LDAP_SUCCESS) {

        if (LdapHandle != NULL) {

            ldap_get_option( LdapHandle, LDAP_OPT_HOST_NAME, &Server );
        }

        if (++BinlGlobalLdapErrorCount <= BinlGlobalMaxLdapErrorsLogged) {

            PWCHAR strings[2];

            if (Server) {
                strings[0] = Server;
            } else {
                strings[0] = L"?";
            }
            strings[1] = NULL;

            BinlReportEventW( LdapEvent,
                              EVENTLOG_WARNING_TYPE,
                              (Server != NULL) ? 1 : 0,
                              sizeof(LdapError),
                              (Server != NULL) ? strings : NULL,
                              &LdapError
                              );
        }
    }
    return;
}


DWORD 
MyGetDcHandle(
    PCLIENT_STATE clientState,
    PCSTR DomainName,
    PHANDLE Handle
    )
{
    DWORD Error;
    HANDLE hDC;
    PDOMAIN_CONTROLLER_INFOA DCI = NULL;
    DWORD impersonateError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
    
    BinlPrintDbg((
        DEBUG_OSC, 
        "Attempting discovery of DC in %s domain.\n",
        DomainName ));
    
    Error = DsGetDcNameA( 
        NULL, 
        DomainName,
        NULL,
        NULL,
        DS_IS_DNS_NAME | DS_RETURN_DNS_NAME,
        &DCI);
    
    if (Error == ERROR_SUCCESS) {
    
        BinlPrintDbg((
            DEBUG_OSC, 
            "DC is %s, attempting bind.\n",
            DCI->DomainControllerName ));
    
        impersonateError = OscImpersonate(clientState);
    
        Error = DsBindA(DCI->DomainControllerName, NULL, &hDC);
        if (Error != ERROR_SUCCESS) {
            BinlPrintDbg((
                DEBUG_OSC_ERROR, 
                "DsBind failed, ec = %d.\n",
                Error ));
        } else {
            PSTR p = DCI->DomainControllerName;

            *Handle = hDC;

            //
            // if it's got '\\' in the front, then strip those
            // off because ldap_init hates them
            //
            while (*p == '\\') {
                p = p + 1;
            }

            OscAddVariableA( clientState, "DCNAME", p );
        }
    
        NetApiBufferFree(DCI);
    
    } else {
        BinlPrintDbg((
        DEBUG_OSC_ERROR, 
        "DsGetDcNameA failed, ec = %d.\n",
        Error ));
    }

    if (impersonateError == ERROR_SUCCESS) {
        OscRevert(clientState);
    }

    return(Error);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\menu.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    menu.c

Abstract:

    This module contains the code to process OS Chooser message
    for the BINL server.

Author:

    Adam Barr (adamba)  9-Jul-1997
    Geoff Pease (gpease) 10-Nov-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

BOOL
IsIncompatibleRiprepSIF(
    PCHAR Path,
    PCLIENT_STATE clientState
    )
{
    CHAR HalName[32];
    CHAR ImageType[32];
    PCHAR DetectedHalName;
    BOOL RetVal;

    ImageType[0] = '\0';
    HalName[0] = '\0';

    //
    // if it's not an RIPREP image, then just bail out.
    //
    GetPrivateProfileStringA(
                OSCHOOSER_SIF_SECTIONA,
                "ImageType",
                "",
                ImageType,
                sizeof(ImageType)/sizeof(ImageType[0]),
                Path );


    if (0 != StrCmpIA(ImageType,"SYSPREP")) {
        RetVal = FALSE;
        goto exit;
    }
    //
    // retrieve the hal name from the SIF file
    //
    GetPrivateProfileStringA(
                OSCHOOSER_SIF_SECTIONA,
                "HalName",
                "",
                HalName,
                sizeof(HalName)/sizeof(HalName[0]),
                Path );

    //
    // if the hal name isn't present, assume it's an old SIF that
    // doesn't have the hal type in it, and so we just return success
    //
    if (*HalName == '\0') {
        RetVal = FALSE;
        goto exit;
    }

    //
    // retrieve the detected HAL type from earlier
    //
    DetectedHalName = OscFindVariableA( clientState, "HALTYPE" );
    if (StrCmpIA(HalName,DetectedHalName)==0) {
        RetVal = FALSE;
        goto exit;
    }

    //
    // if we got this far, the SIF file is incompatible
    //
    RetVal = TRUE;

exit:
    return(RetVal);
}

DWORD
OscAppendTemplatesMenus(
    PCHAR *GeneratedScreen,
    PDWORD dwGeneratedSize,
    PCHAR DirToEnum,
    PCLIENT_STATE clientState,
    BOOLEAN RecoveryOptionsOnly
    )
{
    DWORD Error = ERROR_SUCCESS;
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    int   x = 1;
    CHAR Path[MAX_PATH];
    WCHAR UnicodePath[MAX_PATH];
    DWORD dwGeneratedCurrentLength;

    TraceFunc("OscAppendTemplatesMenus( )\n");

    BinlAssert( *GeneratedScreen != NULL );

    //
    // The incoming size is the current length of the buffer
    //
    dwGeneratedCurrentLength = *dwGeneratedSize;

    // Resulting string should be something like:
    //      "D:\RemoteInstall\English\Images\nt50.wks\i386\Templates\*.sif"
    if ( _snprintf( Path,
                    sizeof(Path) / sizeof(Path[0]),
                    "%s\\%s\\Templates\\*.sif",
                    DirToEnum,
                    OscFindVariableA( clientState, "MACHINETYPE" )
                    ) == -1 ) {
        Error = ERROR_BAD_PATHNAME;
        goto Cleanup;
    }

    mbstowcs( UnicodePath, Path, strlen(Path) + 1 );

    BinlPrintDbg(( DEBUG_OSC, "Enumerating: %s\n", Path ));

    hFind = FindFirstFile( UnicodePath, (LPVOID) &FindData );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        DWORD dwPathLen;

        dwPathLen = strlen( Path );

        do {
            //
            // If it is not a directory, try to open it
            //
            if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                CHAR  Description[DESCRIPTION_SIZE];
                CHAR  HelpLines[HELPLINES_SIZE];
                PCHAR NewScreen;    // temporary points to newly generated screen
                DWORD dwErr;
                DWORD dwFileNameLen;
                CHAR  NewItems[ MAX_PATH * 2 + 512 ];  // arbitrary size
                DWORD dwNewItemsLength;
                BOOLEAN IsCmdConsSif;
                BOOLEAN IsASRSif;
                BOOLEAN IsRecoveryOption;

                //
                // Resulting string should be something like:
                //      "D:\RemoteInstall\English\Images\nt50.wks\i386\Templates\Winnt.Sif"
                dwFileNameLen = wcslen(FindData.cFileName);
                if (dwPathLen + dwFileNameLen - 4 > sizeof(Path) / sizeof(Path[0])) {
                    continue;  // path too long, skip it
                }
                wcstombs( &Path[dwPathLen - 5], FindData.cFileName, dwFileNameLen + 1 );

                BinlPrintDbg(( DEBUG_OSC, "Found SIF File: %s\n", Path ));

                //
                // Check that the image is the type we are looking for
                //
                IsCmdConsSif = OscSifIsCmdConsA(Path);
                IsASRSif = OscSifIsASR(Path);

                IsRecoveryOption = ( IsCmdConsSif || IsASRSif ) 
                                    ? TRUE 
                                    : FALSE;
                if ((RecoveryOptionsOnly && !IsRecoveryOption) || 
                    (!RecoveryOptionsOnly && IsRecoveryOption)) {
                    continue; // not readable, skip it
                }

                if (IsIncompatibleRiprepSIF(Path,clientState)) {
                    //
                    // skip it
                    //
                    BinlPrintDbg(( 
                        DEBUG_OSC, 
                        "Skipping %s because it's an incompatible RIPREP SIF\n",
                        Path ));
                    continue;
                }

                //
                // Retrieve the description
                //
                dwErr = GetPrivateProfileStringA(OSCHOOSER_SIF_SECTIONA,
                                                 "Description",
                                                 "",
                                                 Description,
                                                 DESCRIPTION_SIZE,
                                                 Path 
                                                );

                if ( dwErr == 0 || Description[0] == L'\0' )
                    continue; // not readible, skip it
                //
                // Retrieve the help lines
                //
                dwErr = GetPrivateProfileStringA(OSCHOOSER_SIF_SECTIONA,
                                                 "Help",
                                                 "",
                                                 HelpLines,
                                                 HELPLINES_SIZE,
                                                 Path 
                                                );
                //
                // Create the new item that look like this:
                // <OPTION VALUE="sif_filename.ext" TIP="Help_Lines"> Description\r\n
                //
                if ( _snprintf( NewItems,
                                sizeof(NewItems) / sizeof(NewItems[0]),
                                "<OPTION VALUE=\"%s\" TIP=\"%s\"> %s\r\n",
                                Path,
                                HelpLines,
                                Description
                                ) == -1 ) {
                    continue;   // path too long, skip it
                }
                dwNewItemsLength = strlen( NewItems );

                //
                // Check to see if we have to grow the buffer...
                //
                if ( dwNewItemsLength + dwGeneratedCurrentLength >= *dwGeneratedSize )
                {
                    //
                    // Grow the buffer (add in some slop too)...
                    //
                    NewScreen = BinlAllocateMemory( dwNewItemsLength + dwGeneratedCurrentLength + GENERATED_SCREEN_GROW_SIZE );
                    if( NewScreen == NULL ) {
                        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    }
                    memcpy( NewScreen, *GeneratedScreen, *dwGeneratedSize );
                    BinlFreeMemory(*GeneratedScreen);
                    *GeneratedScreen = NewScreen;
                    *dwGeneratedSize = dwNewItemsLength + dwGeneratedCurrentLength + GENERATED_SCREEN_GROW_SIZE;
                }

                //
                // Add the new items to the screen
                //
                strcat( *GeneratedScreen, NewItems );
                dwGeneratedCurrentLength += dwNewItemsLength;

                x++;    // move to next line
            }

        } while (FindNextFile( hFind, (LPVOID) &FindData ));

        FindClose( hFind );
    }
    else
    {
        OscCreateWin32SubError( clientState, GetLastError( ) );
        Error = ERROR_BINL_FAILED_TO_GENERATE_SCREEN;
    }

    //
    // We do this so that we only transmitted what is needed
    //
//    *dwGeneratedSize = dwGeneratedCurrentLength + 1;    // plus 1 for the NULL character

Cleanup:

    return Error;
}



//
// SearchAndGenerateOSMenu()
//
DWORD
SearchAndGenerateOSMenu(
    PCHAR *GeneratedScreen,
    PDWORD dwGeneratedSize,
    PCHAR DirToEnum,
    PCLIENT_STATE clientState )
{
    DWORD Error = ERROR_SUCCESS;
    DWORD err; // not a return value
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    int   x = 1;
    CHAR Path[MAX_PATH];
    WCHAR UnicodePath[MAX_PATH];
    BOOLEAN SearchingCmdCons;

    TraceFunc("SearchAndGenerateOSMenu( )\n");

    BinlAssert( *GeneratedScreen != NULL );

    Error = ImpersonateSecurityContext( &clientState->ServerContextHandle );
    if ( Error != STATUS_SUCCESS ) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "ImpersonateSecurityContext: 0x%08x\n", Error ));
        if ( !NT_SUCCESS(Error)) {
            return Error;
        }
    }

    //
    // Resulting string should be something like:
    //      "D:\RemoteInstall\Setup\English\Images\*"
    //
    // We special case the CMDCONS directive to search in the Images directory.
    //
    SearchingCmdCons = (BOOLEAN)(!_stricmp(DirToEnum, "CMDCONS"));
    
    if ( _snprintf( Path,
                    sizeof(Path) / sizeof(Path[0]),
                    "%s\\Setup\\%s\\%s\\*",
                    IntelliMirrorPathA,                 
                    OscFindVariableA( clientState, "LANGUAGE" ),
                    SearchingCmdCons ? REMOTE_INSTALL_IMAGE_DIR_A : 
                    DirToEnum 
                    ) == -1 ) {
        Error = ERROR_BAD_PATHNAME;
        goto Cleanup;
    }

    mbstowcs( UnicodePath, Path, strlen(Path) + 1 );

    hFind = FindFirstFile( UnicodePath, (LPVOID) &FindData );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        DWORD dwPathLen = strlen( Path );

        //
        // Loop enumerating each subdirectory's MachineType\Templates for
        // SIF files.
        //
        do {
            //
            // Ignore current and parent directories, but search other
            // directories.
            //
            if (wcscmp(FindData.cFileName, L".") &&
                wcscmp(FindData.cFileName, L"..") &&
                (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ))
            {
                DWORD dwFileNameLen;

                //
                // Add the sub-directory to the path
                //
                dwFileNameLen = wcslen( FindData.cFileName );
                if (dwPathLen + dwFileNameLen > sizeof(Path)/sizeof(Path[0])) {
                    continue;  // path too long, skip it
                }
                wcstombs( &Path[dwPathLen - 1] , FindData.cFileName, dwFileNameLen + 1);

                BinlPrintDbg(( DEBUG_OSC, "Found OS Directory: %s\n", Path ));
                //
                // Then enumerate the templates and add them to the menu screen
                //
                OscAppendTemplatesMenus( GeneratedScreen, 
                                         dwGeneratedSize, 
                                         Path, 
                                         clientState, 
                                         SearchingCmdCons 
                                       );
            }

        } while (FindNextFile( hFind, (LPVOID) &FindData ));

        FindClose( hFind );
    }
    else
    {
        OscCreateWin32SubError( clientState, GetLastError( ) );
        Error = ERROR_BINL_FAILED_TO_GENERATE_SCREEN;
    }

Cleanup:

    err = RevertSecurityContext( &clientState->ServerContextHandle );
    if ( err != STATUS_SUCCESS ) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "RevertSecurityContext: 0x%08x\n", Error ));
        OscCreateWin32SubError( clientState, err );
        Error = ERROR_BINL_FAILED_TO_GENERATE_SCREEN;
    }

    return Error;
}

//
// FilterFormOptions() - for every option in this form, scan the GPO
// list for oscfilter.ini, in each one see if there is an entry in
// section [SectionName] that indicates if each option should be
// filtered out.
//

#define MAX_INI_SECTION_SIZE  512

typedef struct _FORM_OPTION {
    ULONG Result;
    PCHAR ValueName;
    PCHAR TagStart;
    ULONG TagLength;
    struct _FORM_OPTION * Next;
} FORM_OPTION, *PFORM_OPTION;

DWORD
FilterFormOptions(
    PCHAR  OutMessage,
    PCHAR  FilterStart,
    PULONG OutMessageLength,
    PCHAR SectionName,
    PCLIENT_STATE ClientState )
{
    PCHAR OptionStart, OptionEnd, ValueStart, ValueEnd, CurLoc;
    PCHAR ValueName, EqualSign;
    PFORM_OPTION Options = NULL, TmpOption;
    PCHAR IniSection = NULL;
    ULONG ValueLen;
    BOOLEAN Impersonating = FALSE;
    CHAR IniPath[MAX_PATH];
    PGROUP_POLICY_OBJECT pGPOList = NULL, tmpGPO;
    DWORD Error, BytesRead, i;
    DWORD OptionCount = 0;

    //
    // First scan the form and find all the OPTION tags. For each one,
    // we save a point to the value name, the location and length of the
    // tag, and a place to store the current result for that tag (if
    // the result is 1, then the tag stays, otherwise it is deleted).
    //

    CurLoc = FilterStart;

    while (TRUE) {

        //
        // Find the next option/end-of-option/value/end-of-value
        //

        if (!(OptionStart = StrStrIA(CurLoc, "<OPTION ")) ||
            !(OptionEnd = StrChrA(OptionStart+1, '<' )) ||
            !(ValueStart = StrStrIA(OptionStart, "VALUE=\""))) {
            break;
        }
        ValueStart += sizeof("VALUE=\"") - sizeof("");
        if (!(ValueEnd = StrChrA(ValueStart, '\"'))) {
            break;
        }
        ValueLen = (ULONG)(ValueEnd - ValueStart);

        //
        // Allocate and fill in a FORM_OPTION for this option.
        //

        TmpOption = BinlAllocateMemory(sizeof(FORM_OPTION));
        if (!TmpOption) {
            break;
        }
        TmpOption->ValueName = BinlAllocateMemory(ValueLen + 1);
        if (!TmpOption->ValueName) {
            BinlFreeMemory(TmpOption);
            break;
        }

        TmpOption->Result = 1;
        strncpy(TmpOption->ValueName, ValueStart, ValueLen);
        TmpOption->ValueName[ValueLen] = '\0';
        TmpOption->TagStart = OptionStart;
        TmpOption->TagLength = (ULONG)(OptionEnd - OptionStart);

        ++OptionCount;

        //
        // Now link it at the head of Options.
        //

        TmpOption->Next = Options;
        Options = TmpOption;

        //
        // Continue looking for options.
        //

        CurLoc = OptionEnd;

    }

    if (!Options) {
        goto Cleanup;      // didn't find any, so don't bother filtering
    }

    //
    // Now scan the GPO list.
    //

    Error = OscImpersonate(ClientState);
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((DEBUG_ERRORS,
                   "FilterFormOptions: OscImpersonate failed %lx\n", Error));
        goto Cleanup;
    }

    Impersonating = TRUE;

    if (!GetGPOList(ClientState->UserToken, NULL, NULL, NULL, 0, &pGPOList)) {
        BinlPrintDbg((DEBUG_ERRORS,
                   "FilterFormOptions: GetGPOList failed %lx\n", GetLastError()));
        goto Cleanup;

    }

    IniSection = BinlAllocateMemory(MAX_INI_SECTION_SIZE);
    if (!IniSection) {
        BinlPrintDbg((DEBUG_ERRORS,
                   "FilterFormOptions: Allocate %d failed\n", MAX_INI_SECTION_SIZE));
        goto Cleanup;
    }

    for (tmpGPO = pGPOList; tmpGPO != NULL; tmpGPO = tmpGPO->pNext) {

        //
        // Try to open our .ini file. We read the whole section so
        // that we only go over the network once.
        //

#define OSCFILTER_INI_PATH "\\Microsoft\\RemoteInstall\\oscfilter.ini"

        wcstombs(IniPath, tmpGPO->lpFileSysPath, wcslen(tmpGPO->lpFileSysPath) + 1);
        if (strlen(IniPath) + sizeof(OSCFILTER_INI_PATH) > sizeof(IniPath)/sizeof(IniPath[0])) {
            continue;   // path too long, skip it
        }
        strcat(IniPath, OSCFILTER_INI_PATH);

        memset( IniSection, '\0', MAX_INI_SECTION_SIZE );

        BytesRead = GetPrivateProfileSectionA(
                        SectionName,
                        IniSection,
                        MAX_INI_SECTION_SIZE,
                        IniPath);

        if (BytesRead == 0) {
            BinlPrintDbg((DEBUG_POLICY,
                       "FilterFormOptions: Could not read [%s] section in %s\n", SectionName, IniPath));
            continue;
        }

        BinlPrintDbg((DEBUG_POLICY,
                   "FilterFormOptions: Found [%s] section in %s\n", SectionName, IniPath));

        //
        // GetPrivateProfileSectionA puts a NULL character after every
        // option, but in fact we don't want that since we use StrStrIA
        // below.
        //

        for (i = 0; i < BytesRead; i++) {
            if (IniSection[i] == '\0') {
                IniSection[i] = ' ';
            }
        }

        //
        // We have the section, now walk the list of options seeing if this
        // section has something for that value name.
        //

        for (TmpOption = Options; TmpOption != NULL; TmpOption = TmpOption->Next) {

            if ((ValueName = StrStrIA(IniSection, TmpOption->ValueName)) &&
                (EqualSign = StrChrA(ValueName, '='))) {
                TmpOption->Result = strtol(EqualSign+1, NULL, 10);
                BinlPrintDbg((DEBUG_POLICY,
                           "FilterFormOptions: Found %s = %d\n", TmpOption->ValueName, TmpOption->Result));
            }
        }
    }

    //
    // Now we have figured out the results for all the options in the
    // form, clean up the file if needed.
    //
    // NOTE: We rely on the fact that the option list is sorted from
    // last option to first, so that when we remove an option and
    // slide the rest of the file up, we don't affect any of the
    // TmpOption->TagStart values that we have not yet processed.
    //

    for (TmpOption = Options; TmpOption != NULL; TmpOption = TmpOption->Next) {

        if (TmpOption->Result == 0) {

            *OutMessageLength -= TmpOption->TagLength;

            memmove(
                TmpOption->TagStart,
                TmpOption->TagStart + TmpOption->TagLength,
                *OutMessageLength - (size_t)(TmpOption->TagStart - OutMessage));

            --OptionCount;

        }
    }

Cleanup:

    if (pGPOList) {
        FreeGPOList(pGPOList);
    }

    if (IniSection) {
        BinlFreeMemory(IniSection);
    }

    //
    // Free the options chain.
    //

    while (Options) {
        TmpOption = Options->Next;
        BinlFreeMemory(Options->ValueName);
        BinlFreeMemory(Options);
        Options = TmpOption;
    }

    if (Impersonating) {
        OscRevert(ClientState);
    }

    return OptionCount;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\main.c ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the main routine for the BINL server service.

    Where possible, debugged code has been obtained from the
    DHCP server since BINL processes similarly formatted
    requests.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include <binl.h>
#pragma hdrstop

#define GLOBAL_DATA_ALLOCATE    // allocate global data defined in global.h
#include <global.h>

//
// The following was lifted from \nt\private\ds\src\inc\ntdsa.h
//
#define NTDS_DELAYED_STARTUP_COMPLETED_EVENT TEXT("NtdsDelayedStartupCompletedEvent")

#define BINL_PNP_DELAY_SECONDS 10

#define BINL_LSA_SERVER_NAME_POLICY PolicyNotifyDnsDomainInformation

//
// module variables
//

PSECURITY_DESCRIPTOR s_SecurityDescriptor = NULL;

struct l_timeval BinlLdapSearchTimeout;
ULARGE_INTEGER  BinlSifFileScavengerTime;


#if defined(REGISTRY_ROGUE)
BOOL RogueDetection = FALSE;
#endif

VOID
FreeClient(
    PCLIENT_STATE client
    );


DWORD
UpdateStatus(
    VOID
    )
/*++

Routine Description:

    This function updates the binl service status with the Service
    Controller.

Arguments:

    None.

Return Value:

    Return code from SetServiceStatus.

--*/
{
    DWORD Error = ERROR_SUCCESS;


#if DBG
    if (BinlGlobalRunningAsProcess) {
        return(Error);
    }
#endif

    if ( BinlGlobalServiceStatusHandle != 0 ) {

        if (!SetServiceStatus(
                    BinlGlobalServiceStatusHandle,
                    &BinlGlobalServiceStatus)) {
            Error = GetLastError();
            BinlPrintDbg((DEBUG_ERRORS, "SetServiceStatus failed, %ld.\n", Error ));
        }
    }

    return(Error);
}

//
// BinlReadParameters( )
//
DWORD
BinlReadParameters( )
{
    DWORD dwDSErr;
    DWORD dwErr;
    HKEY KeyHandle;
    UINT uResult;
    PWCHAR LanguageString;
    PWCHAR OrgnameString;
    PWCHAR TimezoneString;
    TIME_ZONE_INFORMATION TimeZoneInformation;
    HKEY KeyHandle2 = NULL;
    DWORD Index;

    //
    // Get any registry overrides
    //
    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                BINL_PARAMETERS_KEY,
                0,
                KEY_QUERY_VALUE,
                &KeyHandle );
    if ( dwErr != ERROR_SUCCESS ) {
        KeyHandle = NULL;
    }

    BinlRegGetValue( KeyHandle, BINL_DEFAULT_CONTAINER ,   REG_SZ, (LPBYTE *)&BinlGlobalDefaultContainer );
    BinlRegGetValue( KeyHandle, BINL_DEFAULT_DOMAIN,       REG_SZ, (LPBYTE *)&DefaultDomain );

    BinlRegGetValue( KeyHandle, BINL_DEFAULT_DS, REG_SZ, (LPBYTE *)&BinlGlobalDefaultDS );
    BinlRegGetValue( KeyHandle, BINL_DEFAULT_GC, REG_SZ, (LPBYTE *)&BinlGlobalDefaultGC );

    AllowNewClients   = ReadDWord( KeyHandle, BINL_ALLOW_NEW_CLIENTS, AllowNewClients );

#if defined(REGISTRY_ROGUE)
    RogueDetection  = ReadDWord( KeyHandle, L"RogueDetection", RogueDetection );
#endif

    BinlClientTimeout = ReadDWord( KeyHandle, BINL_CLIENT_TIMEOUT,    900 );
    BinlPrint((DEBUG_OPTIONS, "Client Timeout = %u seconds\n", BinlClientTimeout ));

    g_Port            = ReadDWord( KeyHandle, BINL_PORT_NAME,         BINL_DEFAULT_PORT );
    BinlPrint((DEBUG_OPTIONS, "Port Number = %u\n", g_Port ));

    //
    // BinlGlobalScavengerSleep and BinlUpdateFromDSTimeout are specified in
    // the registry in seconds, but are maintained internally in milliseconds.
    //

    BinlGlobalScavengerSleep = ReadDWord( KeyHandle, BINL_SCAVENGER_SLEEP, 60 ); // seconds
    BinlGlobalScavengerSleep *= 1000; // convert to milliseconds
    BinlPrint((DEBUG_OPTIONS, "Scavenger Timeout = %u milliseconds\n", BinlGlobalScavengerSleep ));


    Index = ReadDWord( KeyHandle, BINL_SCAVENGER_SIFFILE, 24 ); // hours
    if (Index == 0 ) {
        Index = 24;
    }

    //
    // BinlSifFileScavengerTime is read from the registry in seconds, but is
    // maintained internally as a filetime, which has a resolution of 100 ns 
    // intervals (100 ns == 10^7)
    //    
    BinlSifFileScavengerTime.QuadPart = (ULONGLONG)(Index * 60) * 60 * 1000 * 10000;
    BinlPrint((DEBUG_OPTIONS, "SIF File Scavenger Timeout = %d hours\n", Index ));


    BinlUpdateFromDSTimeout = ReadDWord( KeyHandle, BINL_UPDATE_PARAMETER_POLL, 4 * 60 * 60 ); // seconds
    BinlUpdateFromDSTimeout *= 1000; // convert to milliseconds
    BinlPrint((DEBUG_OPTIONS, "Update from DS Timeout = %u milliseconds\n", BinlUpdateFromDSTimeout ));

    //
    //  Setup the variables which control how many ldap errors we log at most
    //  during a given time period and what the time period is.
    //

    BinlGlobalMaxLdapErrorsLogged = ReadDWord( KeyHandle, BINL_DS_ERROR_COUNT_PARAMETER, 10 );
    BinlGlobalLdapErrorScavenger = ReadDWord( KeyHandle, BINL_DS_ERROR_SLEEP, 10 * 60 );  // seconds, default to 10 minutes
    BinlGlobalLdapErrorScavenger *= 1000; // convert to milliseconds
    BinlPrint((DEBUG_OPTIONS, "DS Error log timeout = %u milliseconds\n", BinlGlobalLdapErrorScavenger ));

    //
    //  get the min time to wait before we respond to a new client
    //
    //  It defaults to 7 because it will then ignore the  first two packets
    //  and respond starting at the third.  After testing, we may change
    //  this to 3.
    //

    BinlMinDelayResponseForNewClients = (DWORD) ReadDWord(  KeyHandle,
                                                            BINL_MIN_RESPONSE_TIME,
                                                            0 );
    BinlPrint((DEBUG_OPTIONS, "New Client Timeout Minimum = %u seconds\n", BinlMinDelayResponseForNewClients ));

    //
    //  Get the max time we'll wait for an ldap request
    //

    BinlLdapSearchTimeout.tv_usec = 0;
    BinlLdapSearchTimeout.tv_sec = (DWORD) ReadDWord( KeyHandle,
                                            BINL_LDAP_SEARCH_TIMEOUT,
                                            BINL_LDAP_SEARCH_TIMEOUT_SECONDS );
    BinlPrint((DEBUG_OPTIONS, "LDAP Search Timeout = %u seconds\n", BinlLdapSearchTimeout.tv_sec ));

    //
    //  We need to give the DS some time to find the entries.  If the user
    //  specified 0 timeout, default to some decent minimum.
    //
    if (BinlLdapSearchTimeout.tv_sec == 0) {

        BinlLdapSearchTimeout.tv_usec = BINL_LDAP_SEARCH_MIN_TIMEOUT_MSECS;
    }

    BinlCacheExpireMilliseconds = (ULONG) ReadDWord( KeyHandle, BINL_CACHE_EXPIRE, BINL_CACHE_EXPIRE_DEFAULT);
    BinlPrint(( DEBUG_OPTIONS, "Cache Entry Expire Time = %u milliseconds\n", BinlCacheExpireMilliseconds ));

    BinlGlobalCacheCountLimit = (ULONG) ReadDWord( KeyHandle, BINL_CACHE_MAX_COUNT, BINL_CACHE_COUNT_LIMIT_DEFAULT);
    BinlPrint(( DEBUG_OPTIONS, "Maximum Cache Count = %u entries\n", BinlGlobalCacheCountLimit ));

#if DBG
    //
    // Test for repeat ACKs - 0 = disabled
    //
    BinlRepeatSleep = (DWORD) ReadDWord( KeyHandle, BINL_REPEAT_RESPONSE, 0 );
#endif

    //
    // Turn on/off LDAP_OPT_REFERRALS
    //
    BinlLdapOptReferrals = (DWORD) ReadDWord( KeyHandle, BINL_LDAP_OPT_REFERRALS, (ULONG) ((ULONG_PTR)LDAP_OPT_OFF) );

    //
    // Determine whether to assign new client accounts to the creating server.
    //
    AssignNewClientsToServer = (DWORD) ReadDWord( KeyHandle, BINL_ASSIGN_NEW_CLIENTS_TO_SERVER, AssignNewClientsToServer );
    BinlPrint(( DEBUG_OPTIONS, "Assign new clients to this server = %u\n", AssignNewClientsToServer ));


    if (KeyHandle) {
        RegCloseKey(KeyHandle);
    }

    //
    // Determine the default language.
    //

    LanguageString = NULL;

    uResult = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SENGLANGUAGE, NULL, 0);
    if (uResult != 0) {
        LanguageString = BinlAllocateMemory(uResult * sizeof(WCHAR) );
        if (LanguageString != NULL) {
            uResult = GetLocaleInfo(
                        LOCALE_SYSTEM_DEFAULT,
                        LOCALE_SENGLANGUAGE,
                        LanguageString,
                        uResult );
            if (uResult == 0) {
                BinlFreeMemory( LanguageString );
                LanguageString = NULL;
            }
        }
    }

    //
    // Determine the default organization to put in .sif files.
    //

    OrgnameString = NULL;

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion",
                0,
                KEY_QUERY_VALUE,
                &KeyHandle );
    if ( dwErr == ERROR_SUCCESS ) {
        dwErr = BinlRegGetValue(
                    KeyHandle,
                    L"RegisteredOrganization",
                    REG_SZ,
                    (LPBYTE *)&OrgnameString );
        if ( dwErr != ERROR_SUCCESS ) {
            ASSERT( OrgnameString == NULL );
        }
        RegCloseKey(KeyHandle);
    }

    //
    // Determine the default timezone to put in .sif files.
    //

    TimezoneString = NULL;

    if (GetTimeZoneInformation(&TimeZoneInformation) != TIME_ZONE_ID_INVALID) {

        //
        // We need to find the value of
        // "Software\\Microsoft\\Windows NT\\CurrentVersion\Time Zones\
        // {TimeZoneInformation.StandardName}\Index.
        //

        dwErr = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones",
                    0,
                    KEY_READ,
                    &KeyHandle );
        if (dwErr == ERROR_SUCCESS) {

            dwErr = RegOpenKeyEx(
                        KeyHandle,
                        TimeZoneInformation.StandardName,
                        0,
                        KEY_QUERY_VALUE,
                        &KeyHandle2);

            //
            // In Far East NT, the TimeZoneInformation.StandardName gets a
            // localized string of the English time zone name, but the subkey
            // name remains in English. For example, if the time zone is
            // "Pacific Standard Time", TimeZoneInformation.StandardName will
            // be the localized string for this English string, but the subkey
            // name will still be "Pacific Standard Time".
            //
            // So if we pass this Localized string to RegOpenKeyEx(), we may
            // get error value (0x00000002).
            //
            // The above code works fine in US Build, but for FE build, we
            // have to add a code block to get the correct Key.
            //

            if ( dwErr != ERROR_SUCCESS ) {

                //
                // This is for FE builds. Normally, in US Build, code will
                // not go to here.
                //

                WCHAR   pszSubKeyName[MAX_PATH];
                WCHAR   pszAlternateName[MAX_PATH];
                DWORD   cbName;
                LONG    lRetValue;
                DWORD   dwIndex;

                dwIndex = 0;

                //
                // The alternate name is the name returned by
                // GetTimeZoneInformation with "Standard Time"
                // added at the end -- NT4 upgraded machines
                // may return the old names.
                //

                wcscpy(pszAlternateName, TimeZoneInformation.StandardName);
                wcscat(pszAlternateName, L" Standard Time");

                cbName = MAX_PATH;

                lRetValue = RegEnumKeyEx(
                                         KeyHandle,
                                         dwIndex,
                                         pszSubKeyName,
                                         &cbName,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL );

                KeyHandle2 = NULL;

                while ( lRetValue != ERROR_NO_MORE_ITEMS ) {


                    if ( KeyHandle2 != NULL ) {
                       RegCloseKey( KeyHandle2 );
                       KeyHandle2 = NULL;
                    }

                    dwErr = RegOpenKeyEx(
                                        KeyHandle,
                                        pszSubKeyName,
                                        0,
                                        KEY_QUERY_VALUE,
                                        &KeyHandle2);
                    if ( dwErr == ERROR_SUCCESS ) {

                        WCHAR   StdName[MAX_PATH];
                        DWORD   cb;

                        cb = MAX_PATH;
                        dwErr = RegQueryValueEx(KeyHandle2,
                                                TEXT("Std"),
                                                NULL,
                                                NULL,
                                                (PBYTE)StdName,
                                                &cb);

                        if (!lstrcmp(StdName,TimeZoneInformation.StandardName) ||
                            !lstrcmp(StdName,pszAlternateName) ){

                             // get the right key.

                             break;
                        }
                    }

                    dwIndex ++;

                    cbName = MAX_PATH;

                    lRetValue = RegEnumKeyEx(
                                         KeyHandle,
                                         dwIndex,
                                         pszSubKeyName,
                                         &cbName,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL);

                } // while

                if ( lRetValue == ERROR_NO_MORE_ITEMS ) {
                   dwErr = ERROR_NO_MORE_ITEMS;
                }
            }

            if (dwErr == ERROR_SUCCESS) {

                BinlRegGetValue( KeyHandle2,
                                 L"Index",
                                 REG_DWORD,
                                 (LPBYTE *)&Index );
                TimezoneString = BinlAllocateMemory(24);  // enough for a big number
                if (TimezoneString != NULL) {
                    wsprintf(TimezoneString, L"%d", Index);
                }
            }

            if ( KeyHandle2 != NULL ) {
               RegCloseKey( KeyHandle2 );
               KeyHandle2 = NULL;
            }

            RegCloseKey(KeyHandle);
        }
    }

    EnterCriticalSection(&gcsParameters);
    if ( LanguageString != NULL ) {
        if ( BinlGlobalDefaultLanguage != NULL ) {
            BinlFreeMemory( BinlGlobalDefaultLanguage );
        }
        BinlGlobalDefaultLanguage = LanguageString;
    }
    if ( OrgnameString != NULL ) {
        if ( BinlGlobalDefaultOrgname != NULL ) {
            BinlFreeMemory( BinlGlobalDefaultOrgname );
        }
        BinlGlobalDefaultOrgname = OrgnameString;
    }
    if ( TimezoneString != NULL ) {
        if (BinlGlobalDefaultTimezone != NULL) {
            BinlFreeMemory( BinlGlobalDefaultTimezone );
        }
        BinlGlobalDefaultTimezone = TimezoneString;
    }
    LeaveCriticalSection(&gcsParameters);

    //
    // dwDSErr is the status code that we will return. We don't care whether
    // the registry reads work -- we assume that they always will. We do care
    // whether we were able to contact the DS.
    //
    //
    //  We do the DS query after we've read the parameters so that we setup
    //  the ldap timeouts, chase referrals, etc parameters correctly before
    //  we try to do the search.
    //

    dwDSErr = GetBinlServerParameters( FALSE );
    if ( dwDSErr != ERROR_SUCCESS ) {
        BinlPrint(( DEBUG_ERRORS, "!!Error 0x%08x - there was an error getting the settings from the DS.\n", dwDSErr ));
    }

    //
    // Return the status of the DS access.
    //

    return(dwDSErr);
}



DWORD
GetSCPName(
    PWSTR *ScpName
    )
{

    DWORD dwError;
    PWSTR psz;
    WCHAR MachineDN[ MAX_PATH ];
    
    WCHAR IntellimirrorSCP[ 64 ] = L"-Remote-Installation-Services";

    DWORD dwPathLength;

    //
    // Figure out the machine DN
    //
    wcscpy( MachineDN, BinlGlobalOurFQDNName );
    psz = MachineDN;
    while ( *psz && *psz != L',' )
        psz++;

    if ( *psz == L',' ) {
        *psz = TEXT('\0');  // terminate
        
    } else {
        wcscpy( MachineDN, L"UNKNOWN" );
    }

    //
    // Make space
    //
    dwPathLength = (wcslen( MachineDN ) +            // CN=SERVER
                    wcslen( IntellimirrorSCP ) +     // CN=SERVER-IntelliMirror-Service
                    1 +                                 // CN=SERVER-IntelliMirror-Service,
                    wcslen( BinlGlobalOurFQDNName ) +   // CN=SERVER-IntelliMirror-Service,CN=SERVE
                    1 )                                 // CN=SERVER-IntelliMirror-Service,CN=SERVE
                    * sizeof(WCHAR);

    *ScpName = (LPWSTR) BinlAllocateMemory( dwPathLength );
    if ( !*ScpName ) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // Create string
    //
    wsprintf( *ScpName, L"%s%s,%s", MachineDN, IntellimirrorSCP, BinlGlobalOurFQDNName );
    dwError = ERROR_SUCCESS;

exit:
    return(dwError);
}

    
DWORD
CreateSCPIfNeeded(
    PBOOL CreatedTheSCP
    )
/*++

Routine Description:

    Creates the SCP for BINL if necessary.
    
    It does this by checking the local registry for a flag (ScpCreated) which
    indicates whether the SCP needs to be created.  This flag may created by
    RISETUP or by BINL.  If the SCP needs to be created, then the registry is
    queried for the SCP data.  If the data isn't present, then we assume that
    RISETUP hasn't been run yet, and we do not try to create the SCP.  If SCP
    creation is successful, the "ScpCreated" registry flag is set.
    
    KB.  This is all done because the system context that BINL runs in should
    have permission to create the SCP underneath the MAO.  The user running
    RISETUP may not have sufficient permissions to be able to create the SCP.

Arguments:

    CreatedTheSCP - set to TRUE if we actually create the SCP.

Return Value:

    ERROR_SUCCESS indicates success.  A WIN32 error code if SCP creation fails.

--*/
{
    DWORD dwErr;
    HKEY KeyHandle;
    DWORD Created = 0;
    DWORD i;
    PWSTR ScpName;
    PWSTR ScpDataKeys[] = {
            BINL_SCP_NEWCLIENTS,
            BINL_SCP_LIMITCLIENTS,
            BINL_SCP_CURRENTCLIENTCOUNT,
            BINL_SCP_MAXCLIENTS,       
            BINL_SCP_ANSWER_REQUESTS,
            BINL_SCP_ANSWER_VALID,   
            BINL_SCP_NEWMACHINENAMEPOLICY,
            BINL_SCP_NEWMACHINEOU,        
            BINL_SCP_NETBOOTSERVER };

#define SCPDATACOUNT (sizeof(ScpDataKeys) / sizeof(PWSTR))
#define MACHINEOU_INDEX     7
#define NETBOOTSERVER_INDEX 8

    PWSTR ScpDataValues[SCPDATACOUNT];

    PLDAP LdapHandle = NULL;
    PLDAPMessage LdapMessage;
    PLDAPMessage CurrentEntry;
    LDAPMod mods[1+SCPDATACOUNT];
    PLDAPMod pmods[2+SCPDATACOUNT];
    LPWSTR attr_values[SCPDATACOUNT+1][2];    

    *CreatedTheSCP = FALSE;

    //
    // Try to get the ScpCreated flag
    //
    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                BINL_PARAMETERS_KEY,
                0,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &KeyHandle );
    if ( dwErr != ERROR_SUCCESS ) {
        dwErr = ERROR_SUCCESS;
        BinlPrintDbg(( DEBUG_INIT, "SCP Created key not in registry, won't try to create SCP.\n" ));
        goto e0;
    }

    dwErr = BinlRegGetValue( 
                KeyHandle, 
                BINL_SCP_CREATED , 
                REG_DWORD, 
                (LPBYTE *)&Created );
    if (dwErr == ERROR_SUCCESS && Created != 0) {
        //
        // we think the SCP has already been created...we're done.
        //
        BinlPrintDbg(( DEBUG_INIT, "SCP Created flag set to 1, we won't try to create SCP.\n" ));
        dwErr = ERROR_SUCCESS;
        goto e1;
    }

    //
    // The SCP hasn't been created.  See if all of the required parameters for 
    // creating the SCP are in the registry.
    //
    RtlZeroMemory( ScpDataValues, sizeof(ScpDataValues) );
    for (i = 0; i < SCPDATACOUNT ; i++) {
        dwErr = BinlRegGetValue( 
                    KeyHandle, 
                    ScpDataKeys[i], 
                    REG_SZ, 
                    (LPBYTE *)&ScpDataValues[i] );

        if (dwErr != ERROR_SUCCESS) {
            //
            // one of the required parameters isn't present.  this means that
            // RISETUP wasn't run yet.
            //
            BinlPrintDbg(( 
                DEBUG_INIT, "Can't retrieve SCP value %s [ec = 0x%08x, we won't try to create SCP.\n",
                ScpDataKeys[i],
                dwErr ));
            dwErr = ERROR_SUCCESS;
            goto e2;
        }
    }

    //
    // great, we have all of the data.  Now do some touchup on the pieces that
    // may have changed
    //
    if (wcscmp(ScpDataValues[MACHINEOU_INDEX],BinlGlobalOurFQDNName)) {
        BinlFreeMemory( ScpDataValues[MACHINEOU_INDEX] );
        ScpDataValues[MACHINEOU_INDEX] = BinlAllocateMemory((wcslen(BinlGlobalOurFQDNName)+1)*sizeof(WCHAR));
        if (!ScpDataValues[MACHINEOU_INDEX]) {
            BinlPrintDbg(( DEBUG_INIT, "Can't allocate memory for SCP, we can't create SCP.\n" ));
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto e2;
        }
        wcscpy(ScpDataValues[MACHINEOU_INDEX],BinlGlobalOurFQDNName);
    }

    if (wcscmp(ScpDataValues[NETBOOTSERVER_INDEX],BinlGlobalOurFQDNName)) {
        BinlFreeMemory( ScpDataValues[NETBOOTSERVER_INDEX] );
        ScpDataValues[NETBOOTSERVER_INDEX] = BinlAllocateMemory((wcslen(BinlGlobalOurFQDNName)+1)*sizeof(WCHAR));
        if (!ScpDataValues[NETBOOTSERVER_INDEX]) {
            BinlPrintDbg(( DEBUG_INIT, "Can't allocate memory for SCP, we can't create SCP.\n" ));
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto e2;
        }
        wcscpy(ScpDataValues[NETBOOTSERVER_INDEX],BinlGlobalOurFQDNName);
    }

    //
    // generate the SCP name
    //
    dwErr = GetSCPName(&ScpName);
    if (dwErr != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_INIT, "Can't get the SCP name, ec=0x08x, we can't create SCP.\n",dwErr ));
        goto e2;
    }    

    //
    // create the SCP -- set the timeout to something reasonable since the timeout isn't initialized
    // from the registry yet at this point
    //
    BinlLdapSearchTimeout.tv_sec = BINL_LDAP_SEARCH_TIMEOUT_SECONDS;
    BinlLdapSearchTimeout.tv_usec = 0;
    dwErr = InitializeConnection( FALSE, &LdapHandle, NULL );
    if ( dwErr != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "Can't InitializeConnection, ec=0x08x, we can't create SCP.\n",dwErr ));
        goto e2;
    }
    
    
    //
    // setup all of the attributes for the object.
    //
    mods[0].mod_op = LDAP_MOD_ADD;
    mods[0].mod_type = L"objectClass";
    mods[0].mod_values = attr_values[0];
    attr_values[0][0] = L"IntellimirrorSCP";
    attr_values[0][1] = NULL;
    pmods[0] = &mods[0];
    pmods[SCPDATACOUNT+1] = NULL;

    for( i = 0; i < SCPDATACOUNT ; i++ ) {
        mods[i+1].mod_op = LDAP_MOD_ADD;
        mods[i+1].mod_type = ScpDataKeys[i];
        mods[i+1].mod_values = attr_values[i+1];
        attr_values[i+1][0] = ScpDataValues[i];
        attr_values[i+1][1] = NULL;

        pmods[i+1] = &mods[i+1];
                
    }
    
    dwErr = ldap_add_s( LdapHandle, ScpName, pmods );
    if ( dwErr != LDAP_SUCCESS ) {
        
        if (dwErr == LDAP_ALREADY_EXISTS ) {
            //
            // if the SCP already exists, don't overwrite any data.  Set our flag in
            // the registry so we don't try to do this next time we start.
            //
            dwErr = ERROR_SUCCESS;
            goto SetSCPCreatedFlag;
           
        } else {
            BinlPrintDbg(( DEBUG_INIT, "ldap_add_s failed, ec=0x08x, we can't create SCP.\n",dwErr ));
            goto e3;
        }
    }

    *CreatedTheSCP = TRUE;


SetSCPCreatedFlag:
    //
    // we're done.  set the flag so we don't try to do this in the future.
    //
    Created = 1;
    RegSetValueEx( KeyHandle, BINL_SCP_CREATED, 0, REG_DWORD, (LPBYTE)&Created, sizeof(DWORD) );
    
e3:
    if ( dwErr != LDAP_SUCCESS ) {   
        //
        // just delete the object if this failed
        //
        ldap_delete( LdapHandle, ScpName );
    }
    
    ldap_unbind( LdapHandle );
    
e2:
    for (i = 0; i < SCPDATACOUNT ; i++) {
        if (ScpDataValues[i]) {
            BinlFreeMemory( ScpDataValues[i]);
        }
    }
e1:
    RegCloseKey(KeyHandle);
e0:
    return(dwErr);
}

DWORD
InitializeData(
    VOID
    )
{
    DWORD Length;
    DWORD dwErr;
    int i;
    DWORD ValueSize;

    //
    //  We can operate on all NICs with all IP addresses with a single socket.
    //  If we want control to limit BINL to particular NICs or IP addresses then
    //  we will need multiple sockets and use the bindings in the registry.
    //
    BinlGlobalNumberOfNets = 2;
    BinlGlobalEndpointList =
        BinlAllocateMemory( sizeof(ENDPOINT) * BinlGlobalNumberOfNets );

    if( BinlGlobalEndpointList == NULL ) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    BinlGlobalEndpointList[0].Socket = 0;
    BinlGlobalEndpointList[1].Socket = 0;
    BinlGlobalIgnoreBroadcastFlag = FALSE;
    BinlGlobalLdapErrorCount = 0;

    InitializeCriticalSection(&g_ProcessMessageCritSect);

    InitializeListHead(&BinlGlobalActiveRecvList);
    InitializeListHead(&BinlGlobalFreeRecvList);
    InitializeCriticalSection(&BinlGlobalRecvListCritSect);
    g_cMaxProcessingThreads = BINL_MAX_PROCESSING_THREADS;
    g_cProcessMessageThreads = 0;

    InitializeListHead(&BinlCacheList);
    InitializeCriticalSection( &BinlCacheListLock );

    //
    // initialize (free) receive message queue.
    //

    for( i = 0; i < BINL_RECV_QUEUE_LENGTH; i++ )
    {
        PBINL_REQUEST_CONTEXT pRequestContext =
            BinlAllocateMemory( sizeof(BINL_REQUEST_CONTEXT) );

        if( !pRequestContext )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        //
        // allocate memory for the receive buffer, plus one byte
        // so we can ensure there is a NULL after the message.
        //

        pRequestContext->ReceiveBuffer =
            BinlAllocateMemory( DHCP_RECV_MESSAGE_SIZE + 1 );

        if( !pRequestContext->ReceiveBuffer )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        //
        // add this entry to free list.
        //

        LOCK_RECV_LIST();
        InsertTailList( &BinlGlobalFreeRecvList,
                        &pRequestContext->ListEntry );
        UNLOCK_RECV_LIST();
    }


    //
    // create an event to notifiy the message processing thread about the
    // arrival of a new message.
    //

    BinlGlobalRecvEvent = CreateEvent(
                                NULL,       // no security descriptor
                                FALSE,      // AUTOMATIC reset
                                FALSE,      // initial state: not signalled
                                NULL);      // no name

    if ( !BinlGlobalRecvEvent) {
        dwErr = GetLastError();
        goto Error;
    }

    BinlCloseCacheEvent = CreateEvent(
                                NULL,       // no security descriptor
                                TRUE,       // MANUAL reset
                                FALSE,      // initial state: not signalled
                                NULL);      // no name
    if ( !BinlCloseCacheEvent) {
        dwErr = GetLastError();
        goto Error;
    }

    //
    //  initialize our notify event handle to LSA for server name change operations
    //

    BinlGlobalLsaDnsNameNotifyEvent =
        CreateEvent(
            NULL,      // no security descriptor
            FALSE,     // auto reset
            FALSE,     // initial state: not signalled
            NULL);     // no name

    if ( BinlGlobalLsaDnsNameNotifyEvent == NULL ) {
        dwErr = GetLastError();
        BinlPrintDbg((DEBUG_INIT, "Can't create LSA notify event, "
                    "%ld.\n", dwErr));
        goto Error;
    }

    dwErr = LsaRegisterPolicyChangeNotification(    BINL_LSA_SERVER_NAME_POLICY,
                                                    BinlGlobalLsaDnsNameNotifyEvent
                                                    );
    if (dwErr == ERROR_SUCCESS) {

        BinlGlobalHaveOutstandingLsaNotify = TRUE;

    } else {

        //
        //  we won't fail for now as in 99.99% of the cases the machine name
        //  won't be changing therefore this is not critical.
        //

        BinlPrintDbg((DEBUG_INIT, "Can't start LSA notify, 0x%08x.\n", dwErr));
    }

    dwErr = GetOurServerInfo();
    if (dwErr != ERROR_SUCCESS) {
        goto Error;
    }

    dwErr = GetIpAddressInfo( 0 );

    if (dwErr != ERROR_SUCCESS) {
        goto Error;
    }

Cleanup:
    return(dwErr);

Error:
    BinlPrintDbg(( DEBUG_ERRORS, "!!Error 0x%08x - Could not initialize BINL service.\n", dwErr ));
    BinlServerEventLog(
        EVENT_SERVER_INIT_DATA_FAILED,
        EVENTLOG_ERROR_TYPE,
        dwErr );
    goto Cleanup;
}

DWORD
ReadDWord(
    HKEY KeyHandle,
    LPTSTR lpValueName,
    DWORD DefaultValue
    )
/*++

Routine Description:

    Read a DWORD value from the registry. If there is a problem then
    return the default value.

--*/
{
    DWORD Value;
    DWORD ValueSize = sizeof(Value);
    DWORD ValueType;

    if ((KeyHandle) &&
        (RegQueryValueEx(
                KeyHandle,
                lpValueName,
                0,
                &ValueType,
                (PUCHAR)&Value,
                &ValueSize ) == ERROR_SUCCESS )) {

        return Value;
    } else {
        return DefaultValue;
    }
}


DWORD
BinlRegGetValue(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    LPBYTE * BufferPtr
    )
/*++

Routine Description:

    This function retrieves the value of the specified value field. This
    function allocates memory for variable length field such as REG_SZ.
    For REG_DWORD data type, it copies the field value directly into
    BufferPtr. Currently it can handle only the following fields :

    REG_DWORD,
    REG_SZ,
    REG_BINARY

Arguments:

    KeyHandle : handle of the key whose value field is retrieved.

    ValueName : name of the value field.

    ValueType : Expected type of the value field.

    BufferPtr : Pointer to DWORD location where a DWORD datatype value
                is returned or a buffer pointer for REG_SZ or REG_BINARY
                datatype value is returned.

                If "ValueName" is not found, then "BufferPtr" will not be
                touched.

Return Value:

    Registry Errors.

--*/
{
    DWORD dwErr;
    DWORD LocalValueType;
    DWORD ValueSize;
    LPBYTE DataBuffer;
    LPBYTE AllotedBuffer = NULL;
    LPDHCP_BINARY_DATA BinaryData = NULL;

    //
    // Query DataType and BufferSize.
    //

    if ( !KeyHandle ) {
        dwErr = ERROR_INVALID_HANDLE;
        goto Error;
    }

    dwErr = RegQueryValueEx(
                KeyHandle,
                ValueName,
                0,
                &LocalValueType,
                NULL,
                &ValueSize );

    if ( dwErr != ERROR_SUCCESS ) {
        goto Error;
    }

    if ( LocalValueType != ValueType ) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Error;
    }

    switch( ValueType ) {
    case REG_DWORD:
        BinlAssert( ValueSize == sizeof(DWORD) );

        DataBuffer = (LPBYTE)BufferPtr;
        break;

    case REG_SZ:
    case REG_MULTI_SZ:
    case REG_EXPAND_SZ:
    case REG_BINARY:
        if( ValueSize == 0 ) {
            goto Cleanup; // no key
        }

        AllotedBuffer = DataBuffer = BinlAllocateMemory( ValueSize );

        if( DataBuffer == NULL ) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        break;

    default:
        BinlPrint(( DEBUG_REGISTRY, "Unexpected ValueType in"
                        "BinlRegGetValue function, %ld\n", ValueType ));
        dwErr= ERROR_INVALID_PARAMETER;
        goto Error;
    }

    //
    // retrieve data.
    //

    dwErr = RegQueryValueEx(
                KeyHandle,
                ValueName,
                0,
                &LocalValueType,
                DataBuffer,
                &ValueSize );

    if( dwErr != ERROR_SUCCESS ) {
        goto Error;
    }

    switch( ValueType ) {
    case REG_SZ:
    case REG_MULTI_SZ:
    case REG_EXPAND_SZ:
        BinlAssert( ValueSize != 0 );
        *BufferPtr = DataBuffer;
        break;

    case REG_BINARY:
        BinaryData = BinlAllocateMemory(sizeof(DHCP_BINARY_DATA));

        if( BinaryData == NULL ) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        BinaryData->DataLength = ValueSize;
        BinaryData->Data = DataBuffer;
        *BufferPtr = (LPBYTE)BinaryData;

    default:
        break;
    }

Cleanup:
    return(dwErr);

Error:
    if ( BinaryData )
        BinlFreeMemory( BinaryData );

    if ( AllotedBuffer )
        BinlFreeMemory( AllotedBuffer );

    goto Cleanup;
}


VOID
ServiceControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the binl service.

Arguments:

    Opcode - Supplies a value which specifies the action for the
        service to perform.

Return Value:

    None.

--*/
{
    DWORD Error;

    //
    //  Use critical section to stop DHCP telling us it is starting or stopping
    //  while we change state ourselves.
    //

    EnterCriticalSection(&gcsDHCPBINL);
    switch (Opcode) {

    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        BinlCurrentState = BINL_STOPPED;

        if (BinlGlobalServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) {

            if( Opcode == SERVICE_CONTROL_SHUTDOWN ) {

                //
                // set this flag, so that service shut down will be
                // faster.
                //

                BinlGlobalSystemShuttingDown = TRUE;
            }

            BinlPrintDbg(( DEBUG_MISC, "Service is stop pending.\n"));

            BinlGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            BinlGlobalServiceStatus.dwCheckPoint = 1;

            //
            // Send the status response.
            //

            UpdateStatus();

            if (! SetEvent(BinlGlobalProcessTerminationEvent)) {

                //
                // Problem with setting event to terminate binl
                // service.
                //

                BinlPrintDbg(( DEBUG_ERRORS, "BINL Server: Error "
                                "setting DoneEvent %lu\n",
                                    GetLastError()));

                BinlAssert(FALSE);
            }

            LeaveCriticalSection(&gcsDHCPBINL);

            return;
        }
        break;

    case SERVICE_CONTROL_PAUSE:

        BinlGlobalServiceStatus.dwCurrentState = SERVICE_PAUSED;
        BinlPrint(( DEBUG_MISC, "Service is paused.\n"));
        break;

    case SERVICE_CONTROL_CONTINUE:

        BinlCurrentState = BINL_STARTED;
        BinlGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
        BinlPrint(( DEBUG_MISC, "Service is Continued.\n"));
        break;

    case SERVICE_CONTROL_INTERROGATE:
        BinlPrint(( DEBUG_MISC, "Service is interrogated.\n"));
        BinlReadParameters( );
        break;

    case BINL_SERVICE_REREAD_SETTINGS:   // custom message
        BinlPrint(( DEBUG_MISC, "Service received paramchange message.\n"));
        Error = BinlReadParameters( );
        //
        // Cause the service to poll frequently for a while and then return to
        // normal polling. If we managed to read the DS above, then we don't
        // need to succeed again, but if we failed above, then we want to keep
        // trying until we succeed at least once.
        //
        BinlHyperUpdateCount = BINL_HYPERMODE_RETRY_COUNT;
        BinlHyperUpdateSatisfied = (BOOL)(Error == ERROR_SUCCESS);
        break;

    default:
        BinlPrintDbg(( DEBUG_MISC, "Service received unknown control.\n"));
        break;
    }

    //
    // Send the status response.
    //

    UpdateStatus();

    LeaveCriticalSection(&gcsDHCPBINL);
}

DWORD
BinlInitializeEndpoint(
    PENDPOINT pEndpoint,
    PDHCP_IP_ADDRESS pIpAddress,
    DWORD Port
    )
/*++

Routine Description:

    This function initializes an endpoint by creating and binding a
    socket to the local address.

Arguments:

    pEndpoint - Receives a pointer to the newly created socket

    pIpAddress - The IP address to initialize to INADDR_ANY if NULL.

    Port - The port to bind to.

Return Value:

    The status of the operation.

--*/
{
    DWORD Error;
    SOCKET Sock;
    DWORD OptValue;

#define SOCKET_RECEIVE_BUFFER_SIZE      1024 * 64   // 64K max.

    struct sockaddr_in SocketName;

    pEndpoint->Port = Port;

    //
    // Create a socket
    //

    Sock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( Sock == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Make the socket share-able
    //

    OptValue = TRUE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_REUSEADDR,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = TRUE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_BROADCAST,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = SOCKET_RECEIVE_BUFFER_SIZE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_RCVBUF,
                (LPBYTE)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    SocketName.sin_family = PF_INET;
    SocketName.sin_port = htons( (unsigned short)Port );
    if (pIpAddress) {
        SocketName.sin_addr.s_addr = *pIpAddress;
    } else {
        SocketName.sin_addr.s_addr = INADDR_ANY;
    }
    RtlZeroMemory( SocketName.sin_zero, 8);

    //
    // Bind this socket to the server port
    //

    Error = bind(
               Sock,
               (struct sockaddr FAR *)&SocketName,
               sizeof( SocketName )
               );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    pEndpoint->Socket = Sock;

    //
    //  if this is 4011, then we setup for the pnp notification.
    //

    if ((Port == g_Port) &&
        (BinlGlobalPnpEvent != NULL) &&
        (BinlPnpSocket == INVALID_SOCKET)) {

        BinlPnpSocket = Sock;

        Error = BinlSetupPnpWait( );

        if (Error != 0) {
            BinlPrintDbg(( DEBUG_ERRORS, "BinlInitializeEndpoint could not set pnp event, %ld.\n", Error ));
        }
    }

    if (!pIpAddress) {

        PHOSTENT Host = gethostbyname(NULL);        // winsock2 allows us to do this.

        if (Host) {

            pEndpoint->IpAddress = *(PDHCP_IP_ADDRESS)Host->h_addr;

        } else {

            Error = WSAGetLastError();
            BinlPrintDbg(( DEBUG_ERRORS, "BinlInitializeEndpoint could not get ip addr, %ld.\n", Error ));

            pEndpoint->IpAddress = 0;
        }

    } else {

        pEndpoint->IpAddress = *pIpAddress;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // if we aren't successful, close the socket if it is opened.
        //

        if( Sock != INVALID_SOCKET ) {
            closesocket( Sock );
        }

        BinlPrintDbg(( DEBUG_ERRORS,
            "BinlInitializeEndpoint failed, %ld.\n", Error ));
    }

    return( Error );
}

DWORD
WaitForDsStartup(
    VOID
    )
{
    const DWORD dwMaxWaitForDS = 5*60*1000;
    HANDLE hDsStartupCompletedEvent = NULL;
    DWORD i;
    DWORD err = ERROR_DS_UNAVAILABLE;
    DWORD waitStatus;
    DWORD waitTime = BinlGlobalServiceStatus.dwWaitHint;
    NT_PRODUCT_TYPE productType;

    //
    // Find out if we're on a DC. If we're not, there's no need to wait for
    // the DS.
    //
    // RtlGetNtProductType shouldn't fail. If it does, just assume we're
    // not on a DC.
    //

    if (!RtlGetNtProductType(&productType) || (productType != NtProductLanManNt)) {
        return NO_ERROR;
    }

    //
    // Wait up to five minutes for DS to finish startup, if it hasn't done so
    // already.
    //

    for (i = 0; i < dwMaxWaitForDS; i += waitTime) {

        if (hDsStartupCompletedEvent == NULL) {
            hDsStartupCompletedEvent = OpenEvent(SYNCHRONIZE,
                                                 FALSE,
                                                 NTDS_DELAYED_STARTUP_COMPLETED_EVENT);
        }

        if (hDsStartupCompletedEvent == NULL) {

            //
            // DS hasn't even gotten around to creating this event.  This
            // probably means the DS isn't *going* to be started, but let's
            // not jump to conclusions.
            //

            BinlPrint((DEBUG_INIT, "DS startup has not begun; sleeping...\n"));
            Sleep(waitTime);

        } else {

            //
            // DS startup has begun.
            //

            waitStatus = WaitForSingleObject(hDsStartupCompletedEvent, waitTime);

            if (waitStatus == WAIT_OBJECT_0) {

                //
                // DS startup completed (or failed).
                //

                BinlPrint((DEBUG_INIT, "DS startup completed.\n"));
                err = NO_ERROR;
                break;

            } else if (WAIT_TIMEOUT == waitStatus) {

                //
                // DS startup still in progress.
                //

                BinlPrint((DEBUG_INIT, "DS is starting...\n"));

            } else {

                //
                // Wait failure. Ignore the error.
                //

                BinlPrint((DEBUG_INIT, "Failed to wait on DS event handle;"
                            " waitStatus = %d, GLE = %d.\n", waitStatus, GetLastError()));
            }
        }

        UpdateStatus();
    }

    if (hDsStartupCompletedEvent != NULL) {
        CloseHandle(hDsStartupCompletedEvent);
    }

    return err;
}

DWORD
Initialize(
    VOID
    )
/*++

Routine Description:

    This function initialize the binl service global data structures and
    starts up the service.

Arguments:

    None.

Return Value:

    The initialization status.

    0 - Success.
    Positive - A windows error occurred.
    Negative - A service specific error occured.

--*/
{
    DWORD threadId;
    DWORD Error;
    WSADATA wsaData;

    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //

    BinlGlobalServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    BinlGlobalServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    BinlGlobalServiceStatus.dwControlsAccepted = 0;
    BinlGlobalServiceStatus.dwCheckPoint = 1;
    BinlGlobalServiceStatus.dwWaitHint = 60000; // 60 secs.
    BinlGlobalServiceStatus.dwWin32ExitCode = ERROR_SUCCESS;
    BinlGlobalServiceStatus.dwServiceSpecificExitCode = 0;

    //
    // Initialize binl to receive service requests by registering the
    // control handler.
    //
#if DBG
    if (!BinlGlobalRunningAsProcess) {
#endif
    BinlGlobalServiceStatusHandle = RegisterServiceCtrlHandler(
                                      BINL_SERVER,
                                      ServiceControlHandler );

    if ( BinlGlobalServiceStatusHandle == 0 ) {
        Error = GetLastError();
        BinlPrintDbg((DEBUG_INIT, "RegisterServiceCtrlHandlerW failed, "
                    "%ld.\n", Error));

        BinlServerEventLog(
            EVENT_SERVER_FAILED_REGISTER_SC,
            EVENTLOG_ERROR_TYPE,
            Error );

        return(Error);
    }
#if DBG
    } // if (!BinlGlobalRunningAsProcess)
#endif

    //
    // Tell Service Controller that we are start pending.
    //

    UpdateStatus();

    //
    // Create the process termination event.
    //

    BinlGlobalProcessTerminationEvent =
        CreateEvent(
            NULL,      // no security descriptor
            TRUE,      // MANUAL reset
            FALSE,     // initial state: not signalled
            NULL);     // no name

    if ( BinlGlobalProcessTerminationEvent == NULL ) {
        Error = GetLastError();
        BinlPrintDbg((DEBUG_INIT, "Can't create ProcessTerminationEvent, "
                    "%ld.\n", Error));
        return(Error);
    }

    BinlGlobalPnpEvent =
        CreateEvent(
            NULL,      // no security descriptor
            FALSE,     // auto reset
            FALSE,     // initial state: not signalled
            NULL);     // no name

    if ( BinlGlobalPnpEvent == NULL ) {
        Error = GetLastError();
        BinlPrintDbg((DEBUG_INIT, "Can't create PNP event, "
                    "%ld.\n", Error));
        return(Error);
    }

    //
    // create the ProcessMessage termination event
    //

    g_hevtProcessMessageComplete = CreateEvent(
                                        NULL,
                                        FALSE,
                                        FALSE,
                                        NULL
                                        );

    if ( !g_hevtProcessMessageComplete )
    {
        Error = GetLastError();

        BinlPrintDbg( (DEBUG_INIT,
                    "Initialize(...) CreateEvent returned error %x\n",
                    Error )
                );

        return Error;
    }

    BinlPrint(( DEBUG_INIT, "Initializing .. \n", 0 ));

    //
    // Wait for the DS to start up.
    //

    Error = WaitForDsStartup();
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "Wait for DS failed, %ld.\n", Error ));

        BinlServerEventLog(
            EVENT_SERVER_DS_WAIT_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

        return(Error);
    }

    Error = WSAStartup( WS_VERSION_REQUIRED, &wsaData);
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "WSAStartup failed, %ld.\n", Error ));

        BinlServerEventLog(
            EVENT_SERVER_INIT_WINSOCK_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

        return(Error);
    }

    Error = InitializeData();
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "Data initialization failed, %ld.\n",
                        Error ));

        BinlServerEventLog(
            EVENT_SERVER_INIT_DATA_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

        return(Error);
    }

    //
    // if the SCP hasn't been created yet, then try to create it now.  
    // We do this before trying the read the SCP from the DS
    // -- failure to read the SCP will mean that BINL won't startup properly
    //
    Error = CreateSCPIfNeeded(&BinlParametersRead);
    if (Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "Create SCP failed, %ld.\n", Error ));

        BinlServerEventLog(
            ERROR_BINL_SCP_CREATION_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

    }

    if (BinlParametersRead) {
        //
        // this means that we created the SCP.  When we try to read the SCP 
        // from the DS, it will probably fail the first time.
        //
        BinlPrint(( DEBUG_INIT, "BINLSVC created the SCP.\n" ));
    }

    BinlParametersRead = FALSE;

    Error = BinlReadParameters( );
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "Read parameters failed, %ld.\n",
                        Error ));

        //
        // Tell the scavenger to be hyper about reading parameters. Also, log
        // an event indicating that we're in hyper mode and not truly
        // initialized yet.
        //
        // In spite of this failure, we DO NOT fail to initialize BINLSVC.
        // We assume that we'll eventually be able to read our parameters.
        //

        BinlHyperUpdateCount = 1;
        BinlHyperUpdateSatisfied = FALSE;

        BinlServerEventLog(
            EVENT_SERVER_INIT_PARAMETERS_FAILED,
            EVENTLOG_WARNING_TYPE,
            Error );
    } else {
        BinlParametersRead = TRUE;
    }

    BinlPrintDbg(( DEBUG_INIT, "Data initialization succeeded.\n", 0 ));

    // Get the DHCP UDP socket
    Error = MaybeInitializeEndpoint( &BinlGlobalEndpointList[0],
                                NULL,
                                DHCP_SERVR_PORT);
    if ( Error != ERROR_SUCCESS ) {
        return WSAGetLastError();
    };

    if (g_Port) {
        // Get the BINL UDP socket
        Error = BinlInitializeEndpoint( &BinlGlobalEndpointList[1],
                                    NULL,
                                    g_Port);
        if ( Error != ERROR_SUCCESS ) {
            return WSAGetLastError();
        };
    }

    //
    // Initialize the OSChooser server.
    //

    Error = OscInitialize();
    if ( Error != ERROR_SUCCESS ) {
        BinlPrint(( DEBUG_INIT, "OSChooser initialization failed, %ld.\n",
                        Error ));
        return Error;
    };


    //
    // send heart beat to the service controller.
    //
    //

    BinlGlobalServiceStatus.dwCheckPoint++;
    UpdateStatus();

    //
    // Start a thread to queue the incoming BINL messages
    //

    BinlGlobalMessageHandle = CreateThread(
                          NULL,
                          0,
                          (LPTHREAD_START_ROUTINE)BinlMessageLoop,
                          NULL,
                          0,
                          &threadId );

    if ( BinlGlobalMessageHandle == NULL ) {
        Error =  GetLastError();
        BinlPrint((DEBUG_INIT, "Can't create Message Thread, %ld.\n", Error));
        return(Error);
    }

    //
    // Start a thread to process BINL messages
    //

    BinlGlobalProcessorHandle = CreateThread(
                          NULL,
                          0,
                          (LPTHREAD_START_ROUTINE)BinlProcessingLoop,
                          NULL,
                          0,
                          &threadId );

    if ( BinlGlobalProcessorHandle == NULL ) {
        Error =  GetLastError();
        BinlPrint((DEBUG_INIT, "Can't create ProcessThread, %ld.\n", Error));
        return(Error);
    }

    Error = NetInfStartHandler();

    if ( Error != ERROR_SUCCESS ) {

        BinlPrint((DEBUG_INIT, "Can't start INF Handler thread, %ld.\n", Error));
        return(Error);
    }

    BinlGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
    BinlGlobalServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                                 SERVICE_ACCEPT_SHUTDOWN |
                                                 SERVICE_ACCEPT_PAUSE_CONTINUE;

    UpdateStatus();

    BinlCurrentState = BINL_STARTED;
#if defined(REGISTRY_ROGUE)
    //
    //  for now, temporarily set the rogue logic disabled.  it can be
    //  enabled in the registry
    //

    if (RogueDetection) {
#endif
        //
        //  initialize the rogue thread if DHCP server isn't running.
        //

        BinlRogueLoggedState = FALSE;

        Error = MaybeStartRogueThread();
        if ( Error != ERROR_SUCCESS ) {
            BinlPrint((DEBUG_INIT, "Can't start rogue logic, %ld.\n", Error));
            return(Error);
        }

#if defined(REGISTRY_ROGUE)
    } else {

        // pull this out when we pull out the registry setting

        BinlGlobalAuthorized = TRUE;
    }
#endif
    //
    // finally set the server startup time.
    //

    //GetSystemTime(&BinlGlobalServerStartTime);

    return ERROR_SUCCESS;
}

VOID
Shutdown(
    IN DWORD ErrorCode
    )
/*++

Routine Description:

    This function shuts down the binl service.

Arguments:

    ErrorCode - Supplies the error code of the failure

Return Value:

    None.

--*/
{
    DWORD   Error;

    BinlPrint((DEBUG_MISC, "Shutdown started ..\n" ));

    //
    // LOG an event if this is not a normal shutdown.
    //

    if( ErrorCode != ERROR_SUCCESS ) {

        BinlServerEventLog(
            EVENT_SERVER_SHUTDOWN,
            EVENTLOG_ERROR_TYPE,
            ErrorCode );
    }

    //
    // Service is shuting down, may be due to some service problem or
    // the administrator is stopping the service. Inform the service
    // controller.
    //

    BinlGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    BinlGlobalServiceStatus.dwCheckPoint = 1;

    //
    // Send the status response.
    //

    UpdateStatus();

    if( BinlGlobalProcessTerminationEvent != NULL ) {

        //
        // set Termination Event so that other threads know about the
        // shut down.
        //

        SetEvent( BinlGlobalProcessTerminationEvent );

        //
        // Close all sockets, so that the BinlProcessingLoop
        // thread will come out of blocking Select() call.
        //
        // Close EndPoint sockets.
        //

        if( BinlGlobalEndpointList != NULL ) {
            DWORD i;

            for ( i = 0; i < BinlGlobalNumberOfNets ; i++ ) {
                MaybeCloseEndpoint(&BinlGlobalEndpointList[i]);
            }

            BinlFreeMemory( BinlGlobalEndpointList );
        }

        BinlPnpSocket = INVALID_SOCKET;

        //
        // Wait for the threads to terminate, don't wait forever.
        //

        if( BinlGlobalProcessorHandle != NULL ) {
            WaitForSingleObject(
                BinlGlobalProcessorHandle,
                THREAD_TERMINATION_TIMEOUT );
            CloseHandle( BinlGlobalProcessorHandle );
            BinlGlobalProcessorHandle = NULL;
        }

        //
        // wait for the receive thread to complete.
        //

        if( BinlGlobalMessageHandle != NULL ) {
            WaitForSingleObject(
                BinlGlobalMessageHandle,
                THREAD_TERMINATION_TIMEOUT );
            CloseHandle( BinlGlobalMessageHandle );
            BinlGlobalMessageHandle = NULL;
        }

        while ( !IsListEmpty( &BinlGlobalFreeRecvList ) )
        {
            BINL_REQUEST_CONTEXT *pRequestContext;
            pRequestContext =
                (BINL_REQUEST_CONTEXT *)
                    RemoveHeadList( &BinlGlobalFreeRecvList );

            BinlFreeMemory( pRequestContext->ReceiveBuffer );
            BinlFreeMemory( pRequestContext );
        }

        while ( !IsListEmpty( &BinlGlobalActiveRecvList ) )
        {
            BINL_REQUEST_CONTEXT *pRequestContext;
            pRequestContext =
                (BINL_REQUEST_CONTEXT *)
                    RemoveHeadList( &BinlGlobalActiveRecvList );

            BinlFreeMemory( pRequestContext->ReceiveBuffer );
            BinlFreeMemory( pRequestContext );
        }

        if ( BinlIsProcessMessageExecuting() )
        {
            //
            // wait for the thread pool to shutdown
            //

            Error = WaitForSingleObject(
                g_hevtProcessMessageComplete,
                THREAD_TERMINATION_TIMEOUT
                );

            BinlAssert( WAIT_OBJECT_0 == Error );
        }

        //
        //  We free the ldap connections after all the threads are done because
        //  the connection BaseDN strings may be in use by the threads and
        //  we're about to free them in FreeConnections.
        //

        FreeConnections();

        CloseHandle( g_hevtProcessMessageComplete );
        g_hevtProcessMessageComplete = NULL;

    }

    BinlPrintDbg((DEBUG_MISC, "Client requests cleaned up.\n" ));

    //
    // send heart beat to the service controller.
    //
    //

    BinlGlobalServiceStatus.dwCheckPoint++;
    UpdateStatus();

    //
    // send heart beat to the service controller and
    // reset wait time.
    //

    BinlGlobalServiceStatus.dwWaitHint = 60 * 1000; // 1 mins.
    BinlGlobalServiceStatus.dwCheckPoint++;
    UpdateStatus();

    FreeIpAddressInfo();

    //
    // cleanup other data.
    //

    StopRogueThread( );

    OscUninitialize();

    WSACleanup();

    DeleteCriticalSection( &BinlCacheListLock );

    NetInfCloseHandler();

    if ( BinlGlobalSCPPath ) {
        BinlFreeMemory( BinlGlobalSCPPath );
        BinlGlobalSCPPath = NULL;
    }

    if ( BinlGlobalServerDN ) {
        BinlFreeMemory( BinlGlobalServerDN );
        BinlGlobalServerDN = NULL;
    }

    if ( BinlGlobalGroupDN ) {
        BinlFreeMemory( BinlGlobalGroupDN );
        BinlGlobalGroupDN = NULL;
    }

    if ( BinlGlobalDefaultLanguage ) {
        BinlFreeMemory( BinlGlobalDefaultLanguage );
        BinlGlobalDefaultLanguage = NULL;
    }

    EnterCriticalSection( &gcsParameters );

    if ( BinlGlobalDefaultContainer ) {
        BinlFreeMemory( BinlGlobalDefaultContainer );
        BinlGlobalDefaultContainer = NULL;
    }

    if ( NewMachineNamingPolicy != NULL ) {
        BinlFreeMemory( NewMachineNamingPolicy );
        NewMachineNamingPolicy = NULL;
    }

    if ( BinlGlobalOurDnsName ) {
        BinlFreeMemory( BinlGlobalOurDnsName );
        BinlGlobalOurDnsName = NULL;
    }

    if ( BinlGlobalOurDomainName ) {
        BinlFreeMemory( BinlGlobalOurDomainName );
        BinlGlobalOurDomainName = NULL;
    }

    if ( BinlGlobalOurServerName ) {
        BinlFreeMemory( BinlGlobalOurServerName );
        BinlGlobalOurServerName = NULL;
    }

    if ( BinlGlobalOurFQDNName ) {
        BinlFreeMemory( BinlGlobalOurFQDNName );
        BinlGlobalOurFQDNName = NULL;
    }

    LeaveCriticalSection( &gcsParameters );

    if (BinlGlobalHaveOutstandingLsaNotify) {
        Error = LsaUnregisterPolicyChangeNotification(
                                BINL_LSA_SERVER_NAME_POLICY,
                                BinlGlobalLsaDnsNameNotifyEvent
                                );

        if (Error != ERROR_SUCCESS) {

            BinlPrintDbg((DEBUG_INIT, "Can't close LSA notify, 0x%08x.\n", Error));
        }
        BinlGlobalHaveOutstandingLsaNotify = FALSE;
    }

    if (BinlGlobalLsaDnsNameNotifyEvent != NULL) {
        CloseHandle( BinlGlobalLsaDnsNameNotifyEvent );
        BinlGlobalLsaDnsNameNotifyEvent = NULL;
    }

    if ( BinlGlobalDefaultOrgname ) {
        BinlFreeMemory( BinlGlobalDefaultOrgname );
        BinlGlobalDefaultOrgname = NULL;
    }

    if ( BinlGlobalDefaultTimezone ) {
        BinlFreeMemory( BinlGlobalDefaultTimezone );
        BinlGlobalDefaultTimezone = NULL;
    }

    if ( BinlGlobalDefaultDS ) {
        BinlFreeMemory( BinlGlobalDefaultDS );
        BinlGlobalDefaultDS = NULL;
    }

    if ( BinlGlobalDefaultGC ) {
        BinlFreeMemory( BinlGlobalDefaultGC );
        BinlGlobalDefaultGC = NULL;
    }

    BinlPrint((DEBUG_MISC, "Shutdown Completed.\n" ));

    DebugUninitialize( );

    //
    // don't use BinlPrint past this point
    //

    BinlGlobalServiceStatus.dwCurrentState = SERVICE_STOPPED;
    BinlGlobalServiceStatus.dwControlsAccepted = 0;
    if ( ErrorCode >= 20000 && ErrorCode <= 20099 ) {
        // Indicate that it is a BINL specific error code
        BinlGlobalServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        BinlGlobalServiceStatus.dwServiceSpecificExitCode = ErrorCode;
    } else {
        BinlGlobalServiceStatus.dwWin32ExitCode = ErrorCode;
        BinlGlobalServiceStatus.dwServiceSpecificExitCode = 0;
    }

    BinlGlobalServiceStatus.dwCheckPoint = 0;
    BinlGlobalServiceStatus.dwWaitHint = 0;

    UpdateStatus();
}

VOID
ServiceEntry(
    DWORD NumArgs,
    LPWSTR *ArgsArray,
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    )
/*++

Routine Description:

    This is the main routine of the BINL server service.  After
    the service has been initialized, this thread will wait on
    BinlGlobalProcessTerminationEvent for a signal to terminate the service.

Arguments:

    NumArgs - Supplies the number of strings specified in ArgsArray.

    ArgsArray -  Supplies string arguments that are specified in the
        StartService API call.  This parameter is ignored.

Return Value:

    None.

--*/
{
    DWORD Error;

    UNREFERENCED_PARAMETER(NumArgs);
    UNREFERENCED_PARAMETER(ArgsArray);

    DebugInitialize( );

#if DBG
    //
    //  If we are running as a test process instead of as a service then
    //  recored it now so that we avoid calling into the service controller
    //  and failing.
    //

    if ((NumArgs == 2) &&
        (ArgsArray == NULL)) {
        BinlGlobalRunningAsProcess = TRUE;
    } else {
        BinlGlobalRunningAsProcess = FALSE;
    }
#endif

    //
    // copy the process global data pointer to service global variable.
    //

    TcpsvcsGlobalData = pGlobalData;

    Error = Initialize();

    if ( Error == ERROR_SUCCESS) {

        //
        // If we were able to read our parameters from the DS, log an event
        // indicating that we're ready to roll. If not, hold off on logging the
        // event -- the scavenger will do it when it manages to get to the DS.
        //

        if ( BinlParametersRead ) {
            BinlServerEventLog(
                EVENT_SERVER_INIT_AND_READY,
                EVENTLOG_INFORMATION_TYPE,
                Error );
        }

        //
        // perform Scavenge task until we are told to stop.
        //

        Error = Scavenger();
    }

    Shutdown( Error );
    return;
}

VOID
BinlMessageLoop(
    LPVOID Parameter
    )
/*++

Routine Description:

    This function is the message queuing thread.  It loops
    to receive messages that are arriving to all opened sockets and
    queue them in the message queue. The queue length is fixed, so if the
    queue becomes full, it deletes the oldest message from the queue to
    add the new one.

    The message processing thread pops out messages (last one first) and
    process them. New messages are processed first because the
    corresponding clients will least likely time-out, and hence the
    throughput will be better. Also the processing thread throws
    messages that are already timed out, this will stop server starving
    problem.

Arguments:

    Parameter - pointer to the parameter passed.

Return Value:

    None.

--*/
{
    DWORD                 Error,
                          SendResponse,
                          Signal;

    BINL_REQUEST_CONTEXT *pRequestContext;

    while ( 1 ) {

        //
        // dequeue an entry from the free list.
        //

        LOCK_RECV_LIST();
        if( !IsListEmpty( &BinlGlobalFreeRecvList ) ) {

            pRequestContext =
                (BINL_REQUEST_CONTEXT *)
                    RemoveHeadList( &BinlGlobalFreeRecvList );
        }
        else {

            //
            // active message queue should be non-empty.
            //

            BinlAssert( IsListEmpty( &BinlGlobalActiveRecvList ) == FALSE );

            BinlPrintDbg(( DEBUG_MISC, "A Message has been overwritten.\n"));

            //
            // dequeue an old entry from the queue.
            //

            pRequestContext =
                (BINL_REQUEST_CONTEXT *)
                    RemoveHeadList( &BinlGlobalActiveRecvList );
        }
        UNLOCK_RECV_LIST();

        //
        // wait for message to arrive from of the open socket port.
        //

MessageWait:

        Error = BinlWaitForMessage( pRequestContext );

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_SEM_TIMEOUT ) {

                //
                // if we are asked to exit, do so.
                //

                Error = WaitForSingleObject( BinlGlobalProcessTerminationEvent, 0 );

                if ( Error == ERROR_SUCCESS ) {

                    //
                    // The termination event has been signalled
                    //

                    //
                    // delete pRequestContext before exiting
                    //
#if 0
                    BinlFreeMemory( pRequestContext->ReceiveBuffer );
                    BinlFreeMemory( pRequestContext );
#endif

                    ExitThread( 0 );
                }

                BinlAssert( Error == WAIT_TIMEOUT );
                goto MessageWait;
            }
            else {

                BinlPrintDbg(( DEBUG_ERRORS,
                    "BinlWaitForMessage failed, error = %ld\n", Error ));

                goto MessageWait;
            }
        }

        //
        // time stamp the received message.
        //

        pRequestContext->TimeArrived = GetTickCount();

        //
        // queue the message in active queue.
        //

        LOCK_RECV_LIST();

        //
        // before adding this message, check the active list is empty, if
        // so, signal the processing thread after adding this new message.
        //

        Signal = IsListEmpty( &BinlGlobalActiveRecvList );
        InsertTailList( &BinlGlobalActiveRecvList, &pRequestContext->ListEntry );

        if( Signal == TRUE ) {

            if( !SetEvent( BinlGlobalRecvEvent) ) {

                //
                // Problem with setting the event to indicate the message
                // processing queue the arrival of a new message.
                //

                BinlPrintDbg(( DEBUG_ERRORS,
                    "Error setting BinlGlobalRecvEvent %ld\n",
                                    GetLastError()));

                BinlAssert(FALSE);
            }
        }
        UNLOCK_RECV_LIST();
    }

    //
    // Abnormal thread termination.
    //
    ExitThread( 1 );
}

DWORD
BinlStartWorkerThread(
    BINL_REQUEST_CONTEXT **ppContext
    )
{
    BYTE  *pbSendBuffer    = NULL,
          *pbReceiveBuffer = NULL;

    DWORD  dwResult;

    BINL_REQUEST_CONTEXT *pNewContext,
                         *pTempContext;

    DWORD   dwID;
    HANDLE  hThread;

    pNewContext = BinlAllocateMemory( sizeof( *pNewContext ) );

    if ( !pNewContext )
    {
        goto t_cleanup;
    }

    pbSendBuffer = BinlAllocateMemory( DHCP_SEND_MESSAGE_SIZE );

    if ( !pbSendBuffer )
    {
        goto t_cleanup;
    }

    pbReceiveBuffer = BinlAllocateMemory( DHCP_RECV_MESSAGE_SIZE + 1 );

    if ( !pbReceiveBuffer )
    {
        goto t_cleanup;
    }

    //
    // Pass the input context to the worker thread and return the new
    // context to the caller.  This saves a memory copy.
    //

    SWAP( *ppContext, pNewContext );

    (*ppContext)->ReceiveBuffer = pbReceiveBuffer;
    pNewContext->SendBuffer   = pbSendBuffer;

    EnterCriticalSection( &g_ProcessMessageCritSect );

    ++g_cProcessMessageThreads;

    BinlAssert( g_cProcessMessageThreads <= g_cMaxProcessingThreads );

    hThread = CreateThread(
                     NULL,
                     0,
                     (LPTHREAD_START_ROUTINE) ProcessMessage,
                     pNewContext,
                     0,
                     &dwID
                     );

    if ( hThread )
    {
        //
        // success
        //

        CloseHandle( hThread );
        LeaveCriticalSection( &g_ProcessMessageCritSect );
        return ERROR_SUCCESS;
    }

    --g_cProcessMessageThreads;
    LeaveCriticalSection( &g_ProcessMessageCritSect );

    //
    // CreateThread failed. Swap restores the context pointers.
    //

    SWAP( *ppContext, pNewContext );

    BinlPrintDbg( (DEBUG_ERRORS,
                "BinlStartWorkerThread: CreateThread failed: %d\n" )
             );


t_cleanup:

    if ( pbReceiveBuffer )
    {
        BinlFreeMemory( pbReceiveBuffer );
    }

    if ( pbSendBuffer )
    {
        BinlFreeMemory( pbSendBuffer );
    }

    if ( pNewContext )
    {
        BinlFreeMemory( pNewContext );
    }

    BinlPrintDbg( ( DEBUG_ERRORS,
                "BinlStartWorkerThread failed.\n"
                ) );

    return ERROR_NOT_ENOUGH_MEMORY;
}

#define PROCESS_TERMINATE_EVENT     0
#define PROCESS_MESSAGE_RECVD       1
#define PROCESS_EVENT_COUNT         2

VOID
BinlProcessingLoop(
    VOID
    )
/*++

Routine Description:

    This function is the starting point for the main processing thread.
    It loops to process queued messages, and sends replies.

Arguments:

    RequestContext - A pointer to the request context block for
        for this thread to use.

Return Value:

    None.

--*/
{
    DWORD                 Error,
                          Result;

    HANDLE                WaitHandle[PROCESS_EVENT_COUNT];

    BINL_REQUEST_CONTEXT *pRequestContext;

    WaitHandle[PROCESS_MESSAGE_RECVD]   = BinlGlobalRecvEvent;
    WaitHandle[PROCESS_TERMINATE_EVENT] = BinlGlobalProcessTerminationEvent;

    while ( 1 ) {

        //
        // wait for one of the following event to occur :
        //  1. if we are notified about the incoming message.
        //  2. if we are asked to terminate
        //

        Result = WaitForMultipleObjects(
                    PROCESS_EVENT_COUNT,    // num. of handles.
                    WaitHandle,             // handle array.
                    FALSE,                  // wait for any.
                    INFINITE );              // timeout in msecs.

        if (Result == PROCESS_TERMINATE_EVENT) {

            //
            // The termination event has been signalled
            //

            break;
        }

        if ( Result != PROCESS_MESSAGE_RECVD) {

            BinlPrintDbg(( DEBUG_ERRORS,
                "WaitForMultipleObjects returned invalid result, %ld.\n",
                    Result ));

            //
            // go back to wait.
            //

            continue;
        }

        //
        // process all queued messages.
        //

        while(  TRUE )
        {
            if ( BinlIsProcessMessageBusy() )
            {
                //
                // All worker threads are active, so  break to the outer loop.
                // When a worker thread is finished it will set the
                // PROCESS_MESSAGE_RECVD event.

                BinlPrintDbg( (DEBUG_STOC,
                            "BinlProcessingLoop: All worker threads busy.\n" )
                         );

                break;
            }

            LOCK_RECV_LIST();

            if( IsListEmpty( &BinlGlobalActiveRecvList ) ) {

                //
                // no more message.
                //

                UNLOCK_RECV_LIST();
                break;
            }

            //
            // pop out a message from the active list ( *last one first* ).
            //

            pRequestContext =
                (BINL_REQUEST_CONTEXT *) RemoveHeadList(&BinlGlobalActiveRecvList );
            UNLOCK_RECV_LIST();

            //
            // if the message is too old, or if the maximum number of worker threads
            // are running, discard the message.
            //

            if( GetTickCount() - pRequestContext->TimeArrived <
                    WAIT_FOR_RESPONSE_TIME * 1000 )
            {
                Error = BinlStartWorkerThread( &pRequestContext );

                if ( ERROR_SUCCESS != Error )
                {
                    BinlPrintDbg( (DEBUG_ERRORS,
                                "BinlProcessingLoop: BinlStartWorkerThread failed: %d\n",
                                Error )
                             );
                }

            } // if ( ( GetTickCount() < pRequestContext->TimeArrived...
            else
            {
                BinlPrintDbg(( DEBUG_ERRORS, "A message has been timed out.\n" ));
            }

            //
            // return this context to the free list
            //

            LOCK_RECV_LIST();

            InsertTailList(
                &BinlGlobalFreeRecvList,
                &pRequestContext->ListEntry );

            UNLOCK_RECV_LIST();

         } // while (TRUE)
    } // while( 1 )

    //
    // Abnormal thread termination.
    //
    ExitThread( 1 );
}

BOOL
BinlIsProcessMessageExecuting(
    VOID
    )
{
    BOOL f;

    EnterCriticalSection( &g_ProcessMessageCritSect );
    f = g_cProcessMessageThreads;
    LeaveCriticalSection( &g_ProcessMessageCritSect );

    return f;
}

BOOL
BinlIsProcessMessageBusy(
    VOID
    )
{

    BOOL f;

    EnterCriticalSection( &g_ProcessMessageCritSect );
    f = ( g_cProcessMessageThreads == g_cMaxProcessingThreads );
    LeaveCriticalSection( &g_ProcessMessageCritSect );

    return f;
}

#undef PROCESS_TERMINATE_EVENT
#undef PROCESS_EVENT_COUNT

#define PROCESS_TERMINATE_EVENT     0
#define PROCESS_PNP_EVENT           1
#define PROCESS_LSA_EVENT           2
#define PROCESS_EVENT_COUNT         3

DWORD
Scavenger(
    VOID
    )
/*++

Routine Description:

    This function runs as an independant thread.  It periodically wakes
    up. Currently we have no work for it to do but I'm sure we will in the future.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL fLeftCriticalSection = FALSE;
    DWORD TimeOfLastScavenge = GetTickCount();
    DWORD TimeOfLastDSScavenge = GetTickCount();
    DWORD TimeOfLastParameterCheck = 0;
    DWORD                 Error,
                          Result;
    HANDLE                WaitHandle[PROCESS_EVENT_COUNT];
    DWORD secondsSinceLastScavenge;

    WaitHandle[PROCESS_TERMINATE_EVENT] = BinlGlobalProcessTerminationEvent;
    WaitHandle[PROCESS_PNP_EVENT] = BinlGlobalPnpEvent;
    WaitHandle[PROCESS_LSA_EVENT] = BinlGlobalLsaDnsNameNotifyEvent;

    while ((!BinlGlobalSystemShuttingDown) &&
    (BinlGlobalServiceStatus.dwCurrentState != SERVICE_STOP_PENDING))
    {
        DWORD CurrentTime;
        PLIST_ENTRY p;

        //
        // wait for one of the following event to occur :
        //  1. if we are notified about a pnp change.
        //  2. if we are asked to terminate
        //

        Result = WaitForMultipleObjects(
                    PROCESS_EVENT_COUNT,    // num. of handles.
                    WaitHandle,             // handle array.
                    FALSE,                  // wait for any.
                    BINL_HYPERMODE_TIMEOUT );  // timeout in msecs.

        if (Result == PROCESS_TERMINATE_EVENT) {

            //
            // The termination event has been signalled
            //

            break;

        } else if (Result == PROCESS_PNP_EVENT) {

            //
            // The pnp notify event has been signalled
            //

            GetIpAddressInfo( BINL_PNP_DELAY_SECONDS * 1000 );

            Error = BinlSetupPnpWait( );

            if (Error != 0) {
                BinlPrintDbg(( DEBUG_ERRORS, "BinlScavenger could not set pnp event, %ld.\n", Error ));
            }
        } else if (Result == PROCESS_LSA_EVENT) {

            Error = GetOurServerInfo( );
            if (Error != ERROR_SUCCESS) {
                BinlPrintDbg(( DEBUG_ERRORS, "BinlScavenger could not get server name info, 0x%08x.\n", Error ));
            }
        }

        //
        // Capture the current time (in milliseconds).
        //

        CurrentTime = GetTickCount( );

        secondsSinceLastScavenge = CurrentTime - TimeOfLastScavenge;

        //
        // If we haven't scavenged recently, do so now.
        //

        if ( secondsSinceLastScavenge >= BinlGlobalScavengerSleep ) {
            HANDLE hFind;
            WCHAR SifFilePath[MAX_PATH];
            WIN32_FIND_DATA FindData;
            ULARGE_INTEGER CurrentTimeConv,FileTime;
            FILETIME CurrentFileTime;
            PWSTR ptr;

            TimeOfLastScavenge = CurrentTime;
            BinlPrintDbg((DEBUG_SCAVENGER, "Scavenging Clients...\n"));

            fLeftCriticalSection = FALSE;
            EnterCriticalSection(&ClientsCriticalSection);

            for (p = ClientsQueue.Flink; p != &ClientsQueue; p = p->Flink)
            {
                PCLIENT_STATE TempClient;

                TempClient = CONTAINING_RECORD(p, CLIENT_STATE, Linkage);

                if ( CurrentTime - TempClient->LastUpdate > BinlClientTimeout * 1000 )
                {
                    BOOL FreeClientState;

                    BinlPrintDbg((DEBUG_SCAVENGER, "Savenger deleting client = 0x%08x\n", TempClient ));

                    RemoveEntryList(&TempClient->Linkage);
                    TempClient->PositiveRefCount++; // one for CS

                    LeaveCriticalSection(&ClientsCriticalSection);
                    fLeftCriticalSection = TRUE;

                    EnterCriticalSection(&TempClient->CriticalSection);

                    TempClient->NegativeRefCount += 2;  // one for CS and one of Logoff

                    //
                    // FreeClientState will be TRUE if the two refcounts are equal.
                    // Otherwize another thread is being held by the clientState's CS
                    // and it will take care of deleting the CS when it's done.
                    //
                    FreeClientState = (BOOL)(TempClient->PositiveRefCount == TempClient->NegativeRefCount);

                    LeaveCriticalSection(&TempClient->CriticalSection);

                    if (FreeClientState)
                    {
                        FreeClient(TempClient);
                    }

                    break;
                }
            }

            if ( !fLeftCriticalSection ) {
                LeaveCriticalSection(&ClientsCriticalSection);
            }

            BinlPrintDbg((DEBUG_SCAVENGER, "Scavenging Clients Complete\n"));
        

            //
            // scavenge the SIF files
            //
            BinlPrintDbg((DEBUG_SCAVENGER, "Scavenging SIF Files...\n"));
            GetSystemTimeAsFileTime( &CurrentFileTime );
            CurrentTimeConv.LowPart = CurrentFileTime.dwLowDateTime;
            CurrentTimeConv.HighPart = CurrentFileTime.dwHighDateTime;
            if ( _snwprintf( SifFilePath,
                             sizeof(SifFilePath) / sizeof(SifFilePath[0]),
                             L"%ws\\%ws\\",
                             IntelliMirrorPathW,
                             TEMP_DIRECTORY ) != -1 ) {
                ptr = SifFilePath + wcslen(SifFilePath);
                wcscat(SifFilePath,L"*.sif");
                hFind = FindFirstFile(SifFilePath,&FindData);
                if (hFind != INVALID_HANDLE_VALUE) {
                    do {
                        FileTime.LowPart = FindData.ftCreationTime.dwLowDateTime;
                        FileTime.HighPart = FindData.ftCreationTime.dwHighDateTime;

                        FileTime.QuadPart += BinlSifFileScavengerTime.QuadPart;
                        
                        //
                        // if the file has been on the server long enough,
                        // we delete it
                        //
                        if (_wcsicmp(FindData.cFileName,L".") != 0 &&
                            _wcsicmp(FindData.cFileName,L"..") != 0 &&
                            CurrentTimeConv.QuadPart > FileTime.QuadPart) {
                            *ptr = L'\0';
                            wcscat(SifFilePath,FindData.cFileName);

                            BinlPrintDbg((DEBUG_SCAVENGER, 
                                          "Attempting to scavenge SIF File %S...\n", 
                                          SifFilePath));
                            SetFileAttributes(SifFilePath,FILE_ATTRIBUTE_NORMAL);
                            if (!DeleteFile(SifFilePath)) {
                                BinlPrintDbg((DEBUG_SCAVENGER,
                                              "Failed to scavenge SIF File %S, ec = %d\n",
                                              SifFilePath,
                                              GetLastError() ));
                            }
                        }

                    } while ( FindNextFile(hFind,&FindData) );

                    FindClose( hFind );
                }

            }

            BinlPrintDbg((DEBUG_SCAVENGER, "Scavenging SIF Files Complete\n"));
        }

        secondsSinceLastScavenge = CurrentTime - TimeOfLastDSScavenge;

        if ( secondsSinceLastScavenge >= BinlGlobalLdapErrorScavenger) {

            TimeOfLastDSScavenge = CurrentTime;

            if (BinlGlobalLdapErrorCount >= BinlGlobalMaxLdapErrorsLogged) {

                ULONG seconds = BinlGlobalLdapErrorScavenger / 1000;
                PWCHAR strings[2];
                WCHAR secondsString[10];

                swprintf(secondsString, L"%d", seconds);

                strings[0] = secondsString;
                strings[1] = NULL;

                BinlReportEventW( EVENT_WARNING_LDAP_ERRORS,
                                  EVENTLOG_WARNING_TYPE,
                                  1,
                                  sizeof(BinlGlobalLdapErrorCount),
                                  strings,
                                  &BinlGlobalLdapErrorCount
                                  );
            }
            BinlGlobalLdapErrorCount = 0;
        }

        //
        // If we haven't read our parameters recently, do so now.
        //
        // "Recently" is normally a long time period -- defaulting to four hours.
        // But when we are in "hyper" mode, we read our parameters every minute.
        // There are two reasons to be in "hyper" mode:
        //
        // 1. We were not able to read our parameters during initialization. We
        //    need to get the parameters quickly so that we can truly consider
        //    ourselves initialized. In this case, BinlHyperUpdateCount will
        //    always be 1.
        //
        // 2. We were told by the admin UI that our parameters had changed. We
        //    need to read the parameters a number of times over a period of
        //    time because of DS propagation delays. In this case,
        //    BinlHyperUpdateCount starts at BINL_HYPERMODE_RETRY_COUNT (30),
        //    and is decremented each time we attempt to read our parameters.
        //
        // If we are not in hyper mode, then we try to read our parameters and
        // we don't care if we fail. If we are in hyper mode, then we decrement
        // BinlHyperUpdateCount each time we try to read our parameters, and we
        // stay in hyper mode until BinlHyperUpdateCount is decremented to 0.
        // But we don't let the count go to 0 until we have successfully read
        // our parameters at least once while in hyper mode.

        if ( (CurrentTime - TimeOfLastParameterCheck) >=
             ((BinlHyperUpdateCount != 0) ? BINL_HYPERMODE_TIMEOUT : BinlUpdateFromDSTimeout) ) {

            TimeOfLastParameterCheck = CurrentTime;
            BinlPrintDbg((DEBUG_SCAVENGER, "Reading parameters...\n"));

            Error = BinlReadParameters( );

            //
            // If we're not in hyper mode, we don't care if reading the
            // parameters failed. But if we're in hyper mode, we have
            // to do some extra work.
            //

            if ( BinlHyperUpdateCount != 0 ) {

                //
                // If the read worked, then we set BinlHyperUpdateSatisfied.
                // Also, if this is the first time we've managed to read
                // our parameters, we log an event indicating that we're
                // ready.
                //

                if ( Error == ERROR_SUCCESS ) {
                    BinlHyperUpdateSatisfied = TRUE;
                    if ( !BinlParametersRead ) {
                        BinlParametersRead = TRUE;
                        BinlServerEventLog(
                            EVENT_SERVER_INIT_AND_READY,
                            EVENTLOG_INFORMATION_TYPE,
                            Error );
                    }
                }

                //
                // Decrement the update count. However, if we have not yet
                // managed to read our parameters while in hyper mode, don't
                // let the count go to 0.
                //

                BinlHyperUpdateCount--;
                if ( (BinlHyperUpdateCount == 0) && !BinlHyperUpdateSatisfied ) {
                    BinlHyperUpdateCount = 1;
                }
                BinlPrintDbg((DEBUG_SCAVENGER, "Hypermode count: %u\n", BinlHyperUpdateCount ));
            }

            BinlPrintDbg((DEBUG_SCAVENGER, "Reading parameters complete\n"));
        }
    }
    if (BinlGlobalPnpEvent != NULL) {
        CloseHandle( BinlGlobalPnpEvent );
        BinlGlobalPnpEvent = NULL;
    }
    return( ERROR_SUCCESS );
}

VOID
TellBinlState(
    int NewState
        )
/*++

Routine Description:

    This routine is called by DHCP when it starts (when we need to stop
    listening on the DHCP socket) and when it stops (when we need to start).

Arguments:

    NewState - Supplies DHCP's state.

Return Value:

    None.

--*/
{
    BOOLEAN haveLock = TRUE;

    EnterCriticalSection(&gcsDHCPBINL);

    //
    //  If BinlGlobalEndpointList is NULL then BINL isn't started so just
    //  record the NewState
    //

    if (NewState == DHCP_STARTING) {

        if (DHCPState == DHCP_STOPPED) {

            //  DHCP is going from stopped to running.

            DHCPState = NewState;

            //  BINL needs to close the DHCP socket so that DHCP can receive datagrams

            if (BinlCurrentState != BINL_STOPPED) {

                MaybeCloseEndpoint( &BinlGlobalEndpointList[0]);

                LeaveCriticalSection(&gcsDHCPBINL);
                haveLock = FALSE;
                StopRogueThread( );
            }

        } else {

            BinlAssert( DHCPState == DHCP_STARTING );
        }

    } else if (NewState == DHCP_STOPPED) {

        if (DHCPState == DHCP_STARTING) {

            //  DHCP is going from running to stopped.

            DHCPState = NewState;

            if (BinlCurrentState != BINL_STOPPED) {

                MaybeInitializeEndpoint( &BinlGlobalEndpointList[0],
                                            NULL,
                                            DHCP_SERVR_PORT);

                LeaveCriticalSection(&gcsDHCPBINL);
                haveLock = FALSE;
                MaybeStartRogueThread( );
            }
        } else {

            BinlAssert( DHCPState == DHCP_STOPPED );
        }

    } else if (NewState == DHCP_AUTHORIZED) {

        HandleRogueAuthorized( );

    } else if (NewState == DHCP_NOT_AUTHORIZED) {

        HandleRogueUnauthorized( );

    } else {

        BinlPrintDbg((DEBUG_ERRORS, "TellBinlState called with 0x%x\n", NewState ));
    }

    if (haveLock) {
        LeaveCriticalSection(&gcsDHCPBINL);
    }
    return;
}

BOOL
BinlState (
        VOID
        )
/*++

Routine Description:

    This routine is called by DHCP when it starts (when we need to stop
    listening on the DHCP socket) and when it stops (when we need to start).

Arguments:

    None.

Return Value:

    TRUE if BINL running.

--*/
{
    return (BinlCurrentState == BINL_STARTED)?TRUE:FALSE;
}

BOOLEAN
BinlDllInitialize(
    IN HINSTANCE DllHandle,
    IN ULONG Reason,
    IN LPVOID lpReserved OPTIONAL
    )
{

    //
    // Handle attaching binlsvc.dll to a new process.
    //

    //DebugBreak( );

    if (Reason == DLL_PROCESS_ATTACH) {

        INITIALIZE_TRACE_MEMORY;

        //
        // Initialize critical sections.
        //

        InitializeCriticalSection( &gcsDHCPBINL );
        InitializeCriticalSection( &gcsParameters );

        // don't call in here with thread attach/detach notices please...

        DisableThreadLibraryCalls( DllHandle );

    //
    // When DLL_PROCESS_DETACH and lpReserved is NULL, then a FreeLibrary
    // call is being made.  If lpReserved is Non-NULL, and ExitProcess is
    // in progress.  These cleanup routines will only be called when
    // a FreeLibrary is being called.  ExitProcess will automatically
    // clean up all process resources, handles, and pending io.
    //
    } else if ((Reason == DLL_PROCESS_DETACH) &&
               (lpReserved == NULL)) {

        UNINITIALIZE_TRACE_MEMORY;

        DeleteCriticalSection( &gcsParameters );
        DeleteCriticalSection( &gcsDHCPBINL );
    }

    return TRUE;

}

VOID
SendWakeup(
           PENDPOINT pEndpoint
           )
/*++

Routine Description:

    Send a loopback packet to the BINL socket. This will cause the
    select to change so that it includes or excludes the DHCP socket
    as appropriate.

Arguments:

    pEndpoint - Supplies the socket to send the packet on.

Return Value:

    None.

--*/
{
    DHCP_MESSAGE SendBuffer;
    SOCKADDR_IN saUdpServ;

    RtlZeroMemory(&SendBuffer, sizeof(SendBuffer));
    //  We ignore anything that is not BOOT_REQUEST
    SendBuffer.Operation = ~BOOT_REQUEST;

    saUdpServ.sin_family = AF_INET;
        saUdpServ.sin_addr.s_addr = htonl ( INADDR_LOOPBACK );
    saUdpServ.sin_port = htons ( (USHORT)g_Port );

    BinlPrintDbg((DEBUG_MISC, "Sending dummy packet\n"));

    sendto( pEndpoint->Socket,
        (char *)&SendBuffer,
        sizeof(SendBuffer),
        0,
        (const struct sockaddr *)&saUdpServ,
        sizeof ( SOCKADDR_IN )
        );
}

DWORD
MaybeInitializeEndpoint(
    PENDPOINT pEndpoint,
    PDHCP_IP_ADDRESS pIpAddress,
    DWORD Port
    )
/*++

Routine Description:

    This function initializes an endpoint by creating and binding a
    socket to the local address if DHCP is not running.

Arguments:

    pEndpoint - Receives a pointer to the newly created socket

    pIpAddress - The IP address to initialize to INADDR_ANY if NULL.

    Port - The port to bind to.

Return Value:

    The status of the operation.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    EnterCriticalSection(&gcsDHCPBINL);

    if (DHCPState == DHCP_STOPPED) {

        Error = BinlInitializeEndpoint( pEndpoint,
                                    pIpAddress,
                                    Port);

        BinlPrintDbg((DEBUG_MISC, "Opened Socket  %lx\n", pEndpoint->Socket ));

        //
        //  We may have a thread already doing a select and listening to
        //  the BINL socket. Send a dummy packet so that it will do a new
        //  select that includes this socket.
        //

        if ( Error == ERROR_SUCCESS ) {
            SendWakeup(pEndpoint);
        }
    }

    LeaveCriticalSection(&gcsDHCPBINL);
    return Error;
}

VOID
MaybeCloseEndpoint(
    PENDPOINT pEndpoint
    )
/*++

Routine Description:

    This function closes an endpoint if it is open. Usually caused
    when DHCP starts/

Arguments:

    pEndpoint - Pointer to the socket

Return Value:

    None.

--*/
{
    EnterCriticalSection(&gcsDHCPBINL);

    if( pEndpoint->Socket != 0 ) {
        //
        //  Set pEndpoint->Socket to 0 first so that the wait loop gets only
        //  one error when we close the socket. Otherwise there is a race until
        //  we get it set to 0 where the wait loop will loop quickly failing.
        //

        SOCKET  Socket = pEndpoint->Socket;
        BinlPrintDbg((DEBUG_MISC, "Close Socket  %lx\n", Socket ));
        pEndpoint->Socket = 0;
        closesocket( Socket );
    }

    LeaveCriticalSection(&gcsDHCPBINL);
}


//
// Create a copy of a string by allocating heap memory.
//
LPSTR
BinlStrDupA( LPCSTR pStr )
{
    DWORD dwLen = (strlen( pStr ) + 1) * sizeof(CHAR);
    LPSTR psz = BinlAllocateMemory( dwLen );
    if (psz) {
        memcpy( psz, pStr, dwLen );
    }
    return psz;
}

LPWSTR
BinlStrDupW( LPCWSTR pStr )
{
    DWORD dwLen = (wcslen( pStr ) + 1) * sizeof(WCHAR);
    LPWSTR psz = (LPWSTR) BinlAllocateMemory( dwLen );
    if (psz) {
        memcpy( psz, pStr, dwLen );
    }
    return psz;
}

NTSTATUS
BinlSetupPnpWait (
    VOID
    )
{
    NTSTATUS Error;
    ULONG bytesRequired = 0;

    BinlAssert(BinlPnpSocket != INVALID_SOCKET);

    memset((PCHAR) &BinlPnpOverlapped, '\0', sizeof( WSAOVERLAPPED ));
    BinlPnpOverlapped.hEvent = BinlGlobalPnpEvent;

    Error = WSAIoctl( BinlPnpSocket,
                      SIO_ADDRESS_LIST_CHANGE,
                      NULL,
                      0,
                      NULL,
                      0,
                      &bytesRequired,
                      &BinlPnpOverlapped,
                      NULL
                      );
    if (Error != 0) {
        Error = WSAGetLastError();
        //
        //  a return code of ERROR_IO_PENDING is perfectly valid here.
        //
        if (Error == ERROR_IO_PENDING) {
            Error = 0;
        }
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\infdir.c ===
/*
Module Name:

    infdir.c

Abstract:

    This module implements utility routines to manipulate structures used to
    maintain track INF directories.  These directories hold INF files that
    we put parse and put change notifies on to track updates.

Author:

    Andy Herron Apr 08 1998

Revision History:

*/

#include "binl.h"
#pragma hdrstop

#include "netinfp.h"

BOOLEAN StartedNetInfHandler = FALSE;
CRITICAL_SECTION NetInfLock;
LIST_ENTRY NetInfGlobalInfList;

ULONG
NetInfStartHandler (
    VOID
    )
/*++

Routine Description:

    This function just dereferences the block for the 'alive' reference.
    This may cause it to be deleted.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    if (StartedNetInfHandler == FALSE) {

        StartedNetInfHandler = TRUE;
        InitializeCriticalSection( &NetInfLock );
        InitializeListHead(&NetInfGlobalInfList);
    }
    return ERROR_SUCCESS;
}

ULONG
NetInfCloseHandler (
    VOID
    )
/*++

Routine Description:

    This function just dereferences the block for the 'alive' reference.
    This may cause it to be deleted.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    if (StartedNetInfHandler) {

        EnterCriticalSection( &NetInfLock );

        while (IsListEmpty( &NetInfGlobalInfList ) == FALSE) {

            PNETCARD_INF_BLOCK pEntry;
            PLIST_ENTRY listEntry = RemoveHeadList( &NetInfGlobalInfList );

            pEntry = (PNETCARD_INF_BLOCK) CONTAINING_RECORD(
                                                    listEntry,
                                                    NETCARD_INF_BLOCK,
                                                    InfBlockEntry );
            NetInfCloseNetcardInfo( pEntry );
        }

        StartedNetInfHandler = FALSE;

        LeaveCriticalSection( &NetInfLock );

        DeleteCriticalSection( &NetInfLock );
    }
    return ERROR_SUCCESS;
}

ULONG
NetInfFindNetcardInfo (
    PWCHAR InfDirectory,
    ULONG Architecture,
    ULONG CardInfoVersion,
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PWCHAR *FullDriverBuffer OPTIONAL,
    PNETCARD_RESPONSE_DATABASE *pInfEntry
    )
/*++

Routine Description:

    This function searches the drivers we've found and returns a pointer to
    an entry that most closely matches the client's request.

Arguments:

    InfDirectory - directory that is target client's setup directory that
        contains all INF files for the client's NT installation.

    Architecture - PROCESSOR_ARCHITECTURE_XXXXX

    CardInfoVersion - Version of the structure passed by the client.

    CardIdentity - has the values the app is looking for.  we try our best to
        find one that matches.

    FullDriverBuffer - where we put the fully qualified file path specification
        for the driver we find, if they want it.

    pInfEntry - the entry that was found if successful. NULL if in error.

Return Value:

    ERROR_SUCCESS, ERROR_NOT_ENOUGH_MEMORY, or ERROR_NOT_SUPPORTED

--*/
{
    ULONG err = ERROR_NOT_SUPPORTED;        // start off with not found
    LONG result;
    PLIST_ENTRY listEntry;
    UNICODE_STRING infDirString;
    PNETCARD_INF_BLOCK pNetCards = NULL;
    WCHAR SetupPath[MAX_PATH];

    *pInfEntry = NULL;

    if (InfDirectory == NULL) {

        return ERROR_NOT_SUPPORTED;
    }

    //
    //  we find out what the relative path within the IMIRROR directory is
    //  for this client's setup files.
    //

    if ((*InfDirectory != L'\\') ||
        (*(InfDirectory+1) != L'\\') ) {

useWholePath:

        //
        // Make sure there is room for InfDirectory + '\' (1 byte)
        // + architecture (MAX_ARCHITECTURE_LENGTH bytes) + '\0' (1 byte).

        if (wcslen(InfDirectory) + MAX_ARCHITECTURE_LENGTH + 2 >=
                sizeof(SetupPath) / sizeof(SetupPath[0])) {
            return ERROR_BAD_PATHNAME;
        }
        lstrcpyW( SetupPath, InfDirectory );

    } else {

        PWCHAR beginRelativePath = InfDirectory + 2;    // skip leading slashes

        //
        // skip computer name
        //

        while ((*beginRelativePath != L'\0') &&
               (*beginRelativePath != L'\\')) {

            beginRelativePath++;
        }

        //
        //  we should be at the start of the sharename.
        //

        if (*beginRelativePath != L'\\') {

            goto useWholePath;
        }

        beginRelativePath++;

        //
        // skip share name
        //

        while ((*beginRelativePath != L'\0') &&
               (*beginRelativePath != L'\\')) {

            beginRelativePath++;
        }

        //
        //  we should be at the start of the relative directory
        //

        if (*beginRelativePath != L'\\') {

            goto useWholePath;
        }

        //
        // Make sure there is room for IntelliMirrorPathW +
        // beginRelativePath + '\' (1 byte) + architecture
        // (MAX_ARCHITECTURE_LENGTH bytes) + '\0' (1 byte).
        //

        if (wcslen(IntelliMirrorPathW) + wcslen(beginRelativePath) + MAX_ARCHITECTURE_LENGTH + 2 >=
                sizeof(SetupPath) / sizeof(SetupPath[0])) {
            return ERROR_BAD_PATHNAME;
        }
        lstrcpyW( SetupPath, IntelliMirrorPathW );
        lstrcatW( SetupPath, beginRelativePath );
    }

    RtlInitUnicodeString( &infDirString, SetupPath );
    RtlUpcaseUnicodeString( &infDirString, &infDirString, FALSE );

    //  convert the path to uppercase to speed our searches

    if (Architecture == PROCESSOR_ARCHITECTURE_ALPHA) {

        lstrcatW( SetupPath, L"\\ALPHA" );

    } else if (Architecture == PROCESSOR_ARCHITECTURE_ALPHA64) {

        lstrcatW( SetupPath, L"\\AXP64" );

    } else if (Architecture == PROCESSOR_ARCHITECTURE_IA64) {

        lstrcatW( SetupPath, L"\\IA64" );

    } else if (Architecture == PROCESSOR_ARCHITECTURE_MIPS) {

        lstrcatW( SetupPath, L"\\MIPS" );

    } else if (Architecture == PROCESSOR_ARCHITECTURE_PPC) {

        lstrcatW( SetupPath, L"\\PPC" );

    } else { // if (Architecture == PROCESSOR_ARCHITECTURE_INTEL) {

        lstrcatW( SetupPath, L"\\I386" );
    }

    RtlInitUnicodeString( &infDirString, SetupPath );

    EnterCriticalSection( &NetInfLock );

    //
    //  Find the NETCARD_INF_BLOCK block for this inf directory.  If it
    //  doesn't exist, try to create the block.
    //

    listEntry = NetInfGlobalInfList.Flink;

    while ( listEntry != &NetInfGlobalInfList ) {

        pNetCards = (PNETCARD_INF_BLOCK) CONTAINING_RECORD(
                                                listEntry,
                                                NETCARD_INF_BLOCK,
                                                InfBlockEntry );

        err = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                              0,
                              SetupPath,
                              infDirString.Length / sizeof(WCHAR),
                              &pNetCards->InfDirectory[0],
                              -1
                              );
        if (err == 2) {

            break;      // a match was found.
        }

        pNetCards = NULL;

        if (err == 3) {

            break;      // it's greater, add it before listEntry
        }

        listEntry = listEntry->Flink;
    }

    if (pNetCards == NULL) {

        // we didn't find one.   let's create it and parse the INFs.

        err = NetInfAllocateNetcardInfo( SetupPath,
                                         Architecture,
                                         &pNetCards );

        if (err != ERROR_SUCCESS) {

            //
            //  log an error here that we couldn't get INF file info.
            //

            PWCHAR strings[2];

            strings[0] = SetupPath;
            strings[1] = NULL;

            BinlReportEventW(   ERROR_BINL_ERR_IN_SETUP_PATH,
                                EVENTLOG_WARNING_TYPE,
                                1,
                                sizeof(ULONG),
                                strings,
                                &err
                                );
            BinlAssert( pNetCards == NULL );
            LeaveCriticalSection( &NetInfLock );
            return err;
        }

        BinlAssert( pNetCards != NULL );

        //
        //  Now we plop it in the list right in front of listEntry
        //
        //  Either listEntry is equal to the head of the list or
        //  it's equal to some entry that is larger (sort wise) than the
        //  inf path passed in.  In either case, we can simply insert
        //  this new entry onto the tail of listEntry.
        //

        InsertTailList( listEntry, &pNetCards->InfBlockEntry );

        EnterCriticalSection( &pNetCards->Lock );
        LeaveCriticalSection( &NetInfLock );

        //
        //  Fill in the list with the list of cards to support
        //

        err = GetNetCardList( pNetCards );
        pNetCards->StatusFromScan = err;

        if (err != ERROR_SUCCESS) {

            PWCHAR strings[2];

            LeaveCriticalSection( &pNetCards->Lock );
            NetInfCloseNetcardInfo( pNetCards );
            DereferenceNetcardInfo( pNetCards );

            strings[0] = SetupPath;
            strings[1] = NULL;

            BinlReportEventW(   ERROR_BINL_ERR_IN_SETUP_PATH,
                                EVENTLOG_WARNING_TYPE,
                                1,
                                sizeof(ULONG),
                                strings,
                                &err
                                );
            return err;
        }

    } else {

        BinlAssert( pNetCards->ReferenceCount > 0 );
        pNetCards->ReferenceCount++;

        LeaveCriticalSection( &NetInfLock );
        EnterCriticalSection( &pNetCards->Lock );

        err = pNetCards->StatusFromScan;
    }

    //
    //  if the thread that is scanning the INFs hits an error, then all threads
    //  that were waiting on that directory to be scanned should get the same
    //  error.  we use StatusFromScan to hold this.
    //

    if (err == ERROR_SUCCESS) {

        err = FindNetcardInfo( pNetCards, CardInfoVersion, CardIdentity, pInfEntry );
    }

    LeaveCriticalSection( &pNetCards->Lock );


    if ((err == ERROR_SUCCESS) &&
        (*pInfEntry != NULL) &&
        (FullDriverBuffer != NULL)) {

        ULONG sizeToAllocate;

        //
        //  the caller wanted a copy of the fully qualified file name.  we
        //  have all that info here.  Allocate what we need plus two, one for
        //  the null, the other for the backslash.
        //

        sizeToAllocate = (lstrlenW( SetupPath ) + 2) * sizeof(WCHAR);
        sizeToAllocate += lstrlenW( (*pInfEntry)->DriverName ) * sizeof(WCHAR);

        *FullDriverBuffer = BinlAllocateMemory( sizeToAllocate );

        if (*FullDriverBuffer) {

            lstrcpyW( *FullDriverBuffer, SetupPath );
            lstrcatW( *FullDriverBuffer, L"\\" );
            lstrcatW( *FullDriverBuffer, (*pInfEntry)->DriverName );
        }
    }
    DereferenceNetcardInfo( pNetCards );

    return err;
}

ULONG
NetInfEnumFiles (
    PWCHAR FlatDirectory,
    ULONG Architecture,
    LPVOID Context,
    PNETINF_CALLBACK CallBack
    )
/*++

Routine Description:

    This function searches the drivers we've found and returns a pointer to
    an entry that most closely matches the client's request.

Arguments:

    FlatDirectory - directory that is target client's setup directory that
        contains all INF files for the client's NT installation.

    Architecture - PROCESSOR_ARCHITECTURE_XXXXX

    CallBack - function to call with names of files


Return Value:

    ERROR_SUCCESS, ERROR_NOT_ENOUGH_MEMORY, or ERROR_NOT_SUPPORTED

--*/
{
    ULONG err = ERROR_NOT_SUPPORTED;        // start off with not found
    UNICODE_STRING infDirString;
    PNETCARD_INF_BLOCK pNetCards = NULL;
    WCHAR SetupPath[MAX_PATH];

    if (FlatDirectory == NULL) {

        return ERROR_NOT_SUPPORTED;
    }

    if (lstrlenW(FlatDirectory) > MAX_PATH - 1) {

        return ERROR_INVALID_PARAMETER;
    }

    lstrcpyW( SetupPath, FlatDirectory );

    RtlInitUnicodeString( &infDirString, SetupPath );
    RtlUpcaseUnicodeString( &infDirString, &infDirString, FALSE );

    if (StartedNetInfHandler == FALSE) {

        err = NetInfStartHandler();

        if (err != ERROR_SUCCESS) {
            return err;
        }
    }

    err = NetInfAllocateNetcardInfo( SetupPath,
                                     Architecture,
                                     &pNetCards );

    if (err != ERROR_SUCCESS) {

        return err;
    }

    BinlAssert( pNetCards != NULL );

    pNetCards->FileListCallbackFunction = CallBack;
    pNetCards->FileListCallbackContext = Context;

    //
    //  Fill in the list with the list of cards to support
    //

    err = GetNetCardList( pNetCards );

    DereferenceNetcardInfo( pNetCards );    // one for dereference
    DereferenceNetcardInfo( pNetCards );    // and one to delete it.

    //
    //  note that we won't bother to call NetInfCloseHandler here because
    //  we have no idea if the caller on another thread has setup any
    //  other NETCARD_INF_BLOCKs.  So rather than corrupt the list and AV,
    //  we'll just leak the lock.  Not a big deal in RIPREP since it doesn't
    //  handle more than one.  Not an issue for BINL processing INF files.
    //

    return err;
}

// infdir.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\message.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    message.c

Abstract:

    This module contains the code to process a BINL request message
    for the BINL server.

Author:

    Colin Watson (colinw)  2-May-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

#if DBG
DWORD BinlRepeatSleep;
#endif

const WCHAR IntelOSChooser[] = L"OSChooser\\i386\\startrom.com";
const WCHAR IA64OSChooser[]  = L"OSChooser\\ia64\\oschoice.efi";

//  Connection information to a DC in our domain
PLDAP DCLdapHandle = NULL;
PWCHAR * DCBase = NULL;

//  Connection information to the Global Catalog for our enterprise
PLDAP GCLdapHandle = NULL;
PWCHAR * GCBase = NULL;

DWORD
GetGuidFromPacket(
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions,
    OUT PUCHAR Guid,
    OUT PDWORD GuidLength OPTIONAL,
    OUT PMACHINE_INFO *MachineInfo
    );

LPOPTION
AppendClientRequestedParameters(
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask,
    LPBYTE RequestedList,
    DWORD ListLength,
    LPOPTION Option,
    LPBYTE OptionEnd,
    CHAR *ClassIdentifier,
    DWORD ClassIdentifierLength,
    BOOL  fSwitchedSubnet
    );

DWORD
RecognizeClient(
    PUCHAR          pGuid,
    PMACHINE_INFO * pMachineInfo,
    DWORD           dwRequestedInfo,
    ULONG           SecondsSinceBoot,
    USHORT          SystemArchitecture
    );

DWORD
GetBootParametersExt(
    PMACHINE_INFO   pMachineInfo,
    DWORD           dwRequestedInfo,
    USHORT          SystemArchitecture,
    BOOL            fGlobal);

VOID
HandleLdapFailure(
    DWORD LdapError,
    DWORD EventId,
    BOOL GlobalCatalog,
    PLDAP *LdapHandle,
    BOOL HaveLock
    );

VOID
FreeConnection(
    PLDAP * LdapHandle,
    PWCHAR ** Base
    );


DWORD
ProcessMessage(
    LPBINL_REQUEST_CONTEXT RequestContext
    )
/*++

Routine Description:

    This function dispatches the processing of a received BINL message.
    The handler functions will create the response message if necessary.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

Return Value:

    Windows Error.

--*/
{
    DWORD               Error;
    BOOL                fSendResponse,
                        fSubnetsListEmpty,
                        fReadyToTerminate,
                        fAllThreadsBusy;

    DHCP_SERVER_OPTIONS dhcpOptions;
                        LPDHCP_MESSAGE      binlReceiveMessage;

    TraceFunc("ProcessMessage( )\n" );


    //
    // Simply ignore messages when the service is paused.
    //

    if( BinlGlobalServiceStatus.dwCurrentState == SERVICE_PAUSED )
    {
        Error = ERROR_BINL_SERVICE_PAUSED;
        goto t_done;
    }

    binlReceiveMessage = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;

    //
    // If it is an OSChooser message, then process that separately
    // since they don't conform to the DHCP layout.  This will send
    // any messages that it needs to.
    //

    if (binlReceiveMessage->Operation == OSC_REQUEST)
    {
        Error = OscProcessMessage(RequestContext);
        goto t_done;
    }

    RtlZeroMemory( &dhcpOptions, sizeof( dhcpOptions ) );

    //BinlDumpMessage(DEBUG_MESSAGE, binlReceiveMessage);

    Error = ExtractOptions(
                binlReceiveMessage,
                &dhcpOptions,
                RequestContext->ReceiveMessageSize );

    if( Error != ERROR_SUCCESS ) {
        goto t_done;
    }

    if (!dhcpOptions.MessageType) {
        goto t_done;    //  BOOTP request
    }

#if 0
    if (dhcpOptions.SystemArchitecture 
            != DHCP_OPTION_CLIENT_ARCHITECTURE_X86) {
        BinlPrintDbg((
            DEBUG_OPTIONS,
            "ProcessMessage: Client ignored - unsupported architecture type %d \n",
            dhcpOptions.SystemArchitecture ) );
        goto t_done;
    }
#endif
    
    if ( ( !AnswerRequests ) &&
         ( RequestContext->ActiveEndpoint->Port == DHCP_SERVR_PORT )) {

        //
        //  this is not the 4011 port, therefore it must be the DHCP port.
        //  We're configured to not answer requests on this port right now
        //  therefore we'll toss this packet.
        //

        BinlPrint((DEBUG_OPTIONS, "Client ignored - Not answering requests (AnswerRequests == FALSE)\n" ));
        goto t_done;
    }

    if (BinlGlobalAuthorized == FALSE) {

        BinlPrint((DEBUG_ROGUE, "BINL has not passed rogue detection. Ignoring packet.\n" ));

        //
        //  We'll possibly log an event here since we don't log an event
        //  at startup saying what our rogue state is.
        //

        LogCurrentRogueState( TRUE );
        goto t_done;
    }

    //
    // Dispatch based on Message Type
    //

    RequestContext->MessageType = *dhcpOptions.MessageType;

    switch( *dhcpOptions.MessageType ) {

    case DHCP_DISCOVER_MESSAGE:
        Error = ProcessBinlDiscover( RequestContext, &dhcpOptions );
        fSendResponse = TRUE;
        break;

    case DHCP_INFORM_MESSAGE:
        Error = ProcessBinlInform( RequestContext, &dhcpOptions );
        fSendResponse = TRUE;
        break;

    case DHCP_REQUEST_MESSAGE:
        Error = ProcessBinlRequest( RequestContext, &dhcpOptions );
        fSendResponse = TRUE;
        break;

    default:
        BinlPrintDbg(( DEBUG_STOC,
            "Received a invalid message type, %ld.\n",
                *dhcpOptions.MessageType ));

        Error = ERROR_BINL_INVALID_BINL_MESSAGE;
        break;
    }

    if ( ERROR_SUCCESS == Error && fSendResponse )
    {
        /*
         BinlDumpMessage(
                DEBUG_MESSAGE,
                (LPDHCP_MESSAGE)RequestContext->SendBuffer
                );
        */

        BinlSendMessage( RequestContext );
    }

t_done:

    //
    // delete the context structure for this thread
    //

    BinlFreeMemory( RequestContext->ReceiveBuffer );
    BinlFreeMemory( RequestContext->SendBuffer );
    BinlFreeMemory( RequestContext );

    EnterCriticalSection( &g_ProcessMessageCritSect );

    //
    // Check to see if all worker threads were busy
    //

    fAllThreadsBusy = ( g_cProcessMessageThreads ==
                            g_cMaxProcessingThreads );

    --g_cProcessMessageThreads;

    //
    // Check to see if this is the last worker thread
    //

    fReadyToTerminate = !g_cProcessMessageThreads;

    LeaveCriticalSection( &g_ProcessMessageCritSect );


    //
    // If all the worker threads were busy, then BinlProcessingLoop
    // is waiting for a thread to complete.  Set BinlGlobalRecvEvent
    // so BinlProcessingLoop can continue.
    //

    if ( fAllThreadsBusy )
    {
        BinlPrintDbg( ( DEBUG_STOC,
                    "ProcessMessage: Alerting BinlProcessingLoop\n" )
                    );

        SetEvent( BinlGlobalRecvEvent );
    }

    if ( fReadyToTerminate &&
         WaitForSingleObject( BinlGlobalProcessTerminationEvent,
                              0 ) == WAIT_OBJECT_0 )
    {
        //
        // there are no other ProcessMessage threads running, and
        // the service is waiting to shutdown.
        //

        BinlPrintDbg( (DEBUG_MISC,
                    "ProcessMessage: shutdown complete.\n" )
                 );

        BinlAssert( g_hevtProcessMessageComplete );
        SetEvent( g_hevtProcessMessageComplete );
    }

    //
    // thread exit
    //

    BinlPrintDbg( ( DEBUG_STOC,
                "ProcessMessage exited\n" )
                );

    return Error;
}

DWORD
GetGuidFromPacket(
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions,
    OUT PUCHAR Guid,
    OUT PDWORD GuidLength OPTIONAL,
    OUT PMACHINE_INFO *MachineInfo
    )
{
    DWORD gLength = BINL_GUID_LENGTH;
    const LONG AllFs[] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
    const LONG AllZeros[] = { 0x0, 0x0, 0x0, 0x0 };
    DWORD err;
    ULONG SecondsSinceBoot;

    TraceFunc("GetGuidFromPacket( )\n" );

    BinlAssert(sizeof(AllZeros) == BINL_GUID_LENGTH );
    BinlAssert(sizeof(AllFs) == BINL_GUID_LENGTH);

    if (DhcpOptions->GuidLength == 0) {
        DWORD bytesToCopy;
useNicAddress:
        memset(Guid, 0x0, BINL_GUID_LENGTH);
        if (DhcpReceiveMessage->HardwareAddressLength > BINL_GUID_LENGTH) {
            bytesToCopy = BINL_GUID_LENGTH;
        } else {
            bytesToCopy = DhcpReceiveMessage->HardwareAddressLength;
        }
        memcpy(Guid + BINL_GUID_LENGTH - bytesToCopy,
               DhcpReceiveMessage->HardwareAddress,
               bytesToCopy
              );
    } else {
        if (DhcpOptions->GuidLength > BINL_GUID_LENGTH) {
            memcpy(Guid, DhcpOptions->Guid + DhcpOptions->GuidLength - BINL_GUID_LENGTH, BINL_GUID_LENGTH);
        } else {
            gLength = DhcpOptions->GuidLength;
            memcpy(Guid, DhcpOptions->Guid, gLength);
        }
        if (!memcmp(Guid, (PUCHAR)AllFs, BINL_GUID_LENGTH) ||
            !memcmp(Guid, (PUCHAR)AllZeros, BINL_GUID_LENGTH)) {

            //
            //  if they specified all 00s or all FFs, use the NIC address.
            //

            goto useNicAddress;
        }
    }

    if (GuidLength) {
        *GuidLength = gLength;
    }

    //
    //  we return STATUS_SUCCESS if we can handle this client.
    //
    //  If a cache entry is found here, then it will be marked as InProgress as
    //  a side effect of finding it.  We need to call BinlDoneWithCacheEntry
    //  when we're done with the entry.
    //
    //  SecondsSinceBoot may have been sent on the network in network order.
    //  To correct this we assume the lower of the two bytes is the high byte.
    //  So if the high byte is more than the low one, we flip them.
    //

    SecondsSinceBoot = DhcpReceiveMessage->SecondsSinceBoot;
    if ((SecondsSinceBoot >> 8) > (SecondsSinceBoot % 256)) {
        SecondsSinceBoot = (SecondsSinceBoot >> 8) +
                        ((SecondsSinceBoot % 256) << 8);
    }

    err = RecognizeClient(  Guid,
                            MachineInfo,
                            MI_HOSTNAME | MI_BOOTFILENAME,
                            SecondsSinceBoot,
                            DhcpOptions->SystemArchitecture );

    if ( err == ERROR_BINL_INVALID_GUID ) {
        PWCHAR pwch;

        //
        // Log an event with the hardware address of the offending client
        //
        pwch = (PWCHAR)BinlAllocateMemory((10 * DhcpReceiveMessage->HardwareAddressLength + 1) * sizeof(WCHAR));

        if (pwch != NULL) {
            INT i;

            *pwch = UNICODE_NULL;
            for (i=0 ; i < DhcpReceiveMessage->HardwareAddressLength; i++) {
                WCHAR Buffer[5];
                swprintf(Buffer, L" 0x%2x", (ULONG)(DhcpReceiveMessage->HardwareAddress[i]));
                wcscat(pwch, Buffer);
            }

            BinlReportEventW(EVENT_SERVER_CLIENT_WITHOUT_GUID,
                             EVENTLOG_INFORMATION_TYPE,
                             1,
                             0,
                             &pwch,
                             NULL
                            );

            BinlFreeMemory( pwch );
        }
    }
    return err;
}

DWORD
ProcessBinlDiscoverInDhcp(
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions
    )
{
    DWORD Error;
    UCHAR Guid[BINL_GUID_LENGTH];
    PMACHINE_INFO machineInfo = NULL;

    TraceFunc("ProcessBinlDiscoverInDhcp( )\n" );

    if ( !AnswerRequests ) {
        BinlPrint((DEBUG_OPTIONS, "Client ignored - Not answering requests (AnswerRequests == FALSE)\n" ));
        return ERROR_BINL_INVALID_BINL_CLIENT;
    }

    if (BinlGlobalAuthorized == FALSE) {

        BinlPrint((DEBUG_ROGUE, "BINL has not passed rogue detection. Ignoring packet.\n" ));

        //
        //  We'll possibly log an event here since we don't log an event
        //  at startup saying what our rogue state is.
        //

        LogCurrentRogueState( TRUE );
        return ERROR_BINL_INVALID_BINL_CLIENT;
    }

    //
    //  If a cacheEntry is found here, then it will be marked as InProgress as
    //  a side effect of finding it.  We need to call BinlDoneWithCacheEntry
    //  when we're done with the entry.
    //

    Error = GetGuidFromPacket(  DhcpReceiveMessage,
                                DhcpOptions,
                                Guid,
                                NULL,
                                &machineInfo
                                );
    if (machineInfo != NULL) {

        BinlDoneWithCacheEntry( machineInfo, FALSE );
    }

    if( Error != ERROR_SUCCESS ) {
        BinlPrint(( DEBUG_STOC, "BinlDiscover failed with Dhcp server, 0x%x\n", Error ));
    }

    return( Error );
}


DWORD
ProcessBinlDiscover(
    LPBINL_REQUEST_CONTEXT RequestContext,
    LPDHCP_SERVER_OPTIONS DhcpOptions
    )
/*++

Routine Description:

    This function will create the response message if necessary.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    dhcpOptions - Interesting options extracted from the request.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    LPDHCP_MESSAGE dhcpReceiveMessage;
    LPDHCP_MESSAGE dhcpSendMessage;

    BYTE messageType;

    LPOPTION Option;
    LPBYTE OptionEnd;

    PMACHINE_INFO pMachineInfo = NULL;
    UCHAR Guid[ BINL_GUID_LENGTH ];
    DHCP_IP_ADDRESS ipaddr;

    TraceFunc("ProcessBinlDiscover( )\n" );

    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;

    //
    // If the client specified a server identifier option, we should
    // drop this packet unless the identified server is this one.
    //

    ipaddr = BinlGetMyNetworkAddress( RequestContext );

    if ( ipaddr == 0 ) {

        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }

    if ( DhcpOptions->Server != NULL ) {

        if ( *DhcpOptions->Server != ipaddr ) {

            Error = ERROR_BINL_INVALID_BINL_CLIENT;
            goto Cleanup;
        }
    }

    //
    //  If a cacheEntry is found here, then it will be marked as InProgress as
    //  a side effect of finding it.  We need to call BinlDoneWithCacheEntry
    //  when we're done with the entry.
    //

    Error = GetGuidFromPacket(  dhcpReceiveMessage,
                                DhcpOptions,
                                Guid,
                                NULL,
                                &pMachineInfo
                                );
    if (Error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    // Generate and send a reply.
    //

    dhcpReceiveMessage->BootFileName[ BOOT_FILE_SIZE - 1 ] = '\0';

    dhcpSendMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;
    RtlZeroMemory( RequestContext->SendBuffer, DHCP_SEND_MESSAGE_SIZE );

    dhcpSendMessage->Operation = BOOT_REPLY;
    dhcpSendMessage->TransactionID = dhcpReceiveMessage->TransactionID;
    dhcpSendMessage->ClientIpAddress = dhcpReceiveMessage->ClientIpAddress;
    dhcpSendMessage->YourIpAddress = dhcpReceiveMessage->YourIpAddress;

    if (pMachineInfo != NULL && pMachineInfo->HostAddress != 0) {

        dhcpSendMessage->BootstrapServerAddress = pMachineInfo->HostAddress;

    } else {

        dhcpSendMessage->BootstrapServerAddress = ipaddr;
    }

    dhcpSendMessage->RelayAgentIpAddress = dhcpReceiveMessage->RelayAgentIpAddress;
    dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved;

    dhcpSendMessage->HardwareAddressType = dhcpReceiveMessage->HardwareAddressType;
    dhcpSendMessage->HardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
    RtlCopyMemory(dhcpSendMessage->HardwareAddress,
                    dhcpReceiveMessage->HardwareAddress,
                    dhcpReceiveMessage->HardwareAddressLength );

    Option = &dhcpSendMessage->Option;
    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );

    //
    // Append OPTIONS.
    //

    messageType = DHCP_OFFER_MESSAGE;
    Option = DhcpAppendOption(
                 Option,
                 OPTION_MESSAGE_TYPE,
                 &messageType,
                 1,
                 OptionEnd
                 );

    Option = DhcpAppendOption(
                 Option,
                 OPTION_SERVER_IDENTIFIER,
                 &ipaddr,
                 sizeof(ipaddr),
                 OptionEnd );

    Option = DhcpAppendOption(
                Option,
                OPTION_CLIENT_CLASS_INFO,
                "PXEClient",
                9,
                OptionEnd
                );

    //
    // Finally, add client requested parameters.
    //

    if ( DhcpOptions->ParameterRequestList != NULL ) {

        Option = AppendClientRequestedParameters(
                    0,
                    0,
                    DhcpOptions->ParameterRequestList,
                    DhcpOptions->ParameterRequestListLength,
                    Option,
                    OptionEnd,
                    DhcpOptions->ClassIdentifier,
                    DhcpOptions->ClassIdentifierLength,
                    FALSE
                    );
    }

    Option = DhcpAppendOption(
                 Option,
                 OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    BinlAssert( RequestContext->SendMessageSize <= DHCP_SEND_MESSAGE_SIZE );

    Error = ERROR_SUCCESS;

Cleanup:
    if ( pMachineInfo ) {
        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    if( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_STOC, "!! Error 0x%08x - DhcpDiscover failed.\n", Error ));
    }

    return( Error );
}

DWORD
ProcessBinlRequestInDhcp(
    LPDHCP_MESSAGE DhcpReceiveMessage,
    LPDHCP_SERVER_OPTIONS DhcpOptions,
    PCHAR HostName,
    PCHAR BootFileName,
    DHCP_IP_ADDRESS *BootstrapServerAddress,
    LPOPTION *Option,
    PBYTE OptionEnd
    )
/*++

Routine Description:

    This function will create the response message if necessary.

Arguments:

    dhcpOptions - Interesting options extracted from the request.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    PMACHINE_INFO pMachineInfo = NULL;
    BOOLEAN includePXE = TRUE;
    DHCP_IP_ADDRESS ipaddr;

    UCHAR Guid[BINL_GUID_LENGTH];
    DWORD GuidLength;

    TraceFunc("ProcessBinlRequestInDhcp( )\n" );

    if ( !AnswerRequests ) {
        BinlPrint((DEBUG_OPTIONS, "Client ignored - Not answering requests (AnswerRequests == FALSE)\n" ));
        return ERROR_BINL_INVALID_BINL_CLIENT;
    }

    if (BinlGlobalAuthorized == FALSE) {

        BinlPrint((DEBUG_ROGUE, "BINL has not passed rogue detection. Ignoring packet.\n" ));

        //
        //  We'll possibly log an event here since we don't log an event
        //  at startup saying what our rogue state is.
        //

        LogCurrentRogueState( TRUE );
        return ERROR_BINL_INVALID_BINL_CLIENT;
    }

    //
    //  If a cache entry is found here, then it will be marked as InProgress as
    //  a side effect of finding it.  We need to call BinlDoneWithCacheEntry
    //  when we're done with the entry.
    //

    Error = GetGuidFromPacket(  DhcpReceiveMessage,
                                DhcpOptions,
                                Guid,
                                &GuidLength,
                                &pMachineInfo
                                );

    if (Error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    if (pMachineInfo->HostName == NULL) {
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }

    wcstombs( HostName,     pMachineInfo->HostName,     wcslen(pMachineInfo->HostName) + 1);
    wcstombs( BootFileName, pMachineInfo->BootFileName, wcslen(pMachineInfo->BootFileName) + 1);

    BinlPrintDbg(( DEBUG_MISC, "HostName: %s\n", HostName ));
    BinlPrintDbg(( DEBUG_MISC, "BootFileName: %s\n", BootFileName ));

    //
    //  if the server is our own, then the machineInfo->HostAddress will be
    //  0 and the DHCP server will fill in the correct one for us so long as
    //  we return success.
    //

    memcpy( BootstrapServerAddress,
            &pMachineInfo->HostAddress,
            sizeof( DHCP_IP_ADDRESS ) );

    if (DhcpOptions->GuidLength != 0) {
        *Option = DhcpAppendOption(
                     *Option,
                     OPTION_CLIENT_GUID,
                     DhcpOptions->Guid,
                     DhcpOptions->GuidLength,
                     OptionEnd );
    } else {
        UCHAR TmpBuffer[17];

        TmpBuffer[0] = '\0';
        memcpy(TmpBuffer + 1, Guid, GuidLength);
        *Option = DhcpAppendOption(
                     *Option,
                     OPTION_CLIENT_GUID,
                     TmpBuffer,
                     17,
                     OptionEnd );

    }

    //
    //  check if OPTION_CLIENT_CLASS_INFO is already specified, if so, then
    //  don't put PXEClient in again
    //

    if (DhcpOptions->ParameterRequestList != NULL) {

        LPBYTE requestList = DhcpOptions->ParameterRequestList;
        ULONG listLength = DhcpOptions->ParameterRequestListLength;

        while (listLength > 0) {

            if (*requestList == OPTION_CLIENT_CLASS_INFO) {

                includePXE = FALSE;
                break;
            }
            listLength--;
            requestList++;
        }
    }

    if (includePXE) {

        *Option = DhcpAppendOption(
                    *Option,
                    OPTION_CLIENT_CLASS_INFO,
                    "PXEClient",
                    9,
                    OptionEnd
                    );
    }
    Error = ERROR_SUCCESS;

Cleanup:

    if (pMachineInfo != NULL) {

        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    if( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_STOC, "!! Error 0x%08x - BINL Request failed.\n", Error ));
    }

    return( Error );
}


DWORD
ProcessBinlRequest(
    LPBINL_REQUEST_CONTEXT RequestContext,
    LPDHCP_SERVER_OPTIONS DhcpOptions
    )
/*++

Routine Description:

    This function will create the response message if necessary.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    dhcpOptions - Interesting options extracted from the request.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    LPDHCP_MESSAGE dhcpReceiveMessage;
    LPDHCP_MESSAGE dhcpSendMessage;

    BYTE messageType;

    LPOPTION Option;
    LPBYTE OptionEnd;

    PMACHINE_INFO pMachineInfo = NULL;
    UCHAR Guid[ BINL_GUID_LENGTH ];

    DHCP_IP_ADDRESS ipaddr;
    DHCP_IP_ADDRESS boostrapIpAddr;

    TraceFunc("ProcessBinlRequest( )\n" );

#if DBG
    if ( BinlRepeatSleep )
    {
        BinlPrintDbg((DEBUG_STOC, "Delay response %u milliseconds.\n", BinlRepeatSleep ));
        Sleep( BinlRepeatSleep );
        BinlPrintDbg((DEBUG_STOC, "Awakening from sleep...\n" ));
    }
#endif // DBG

    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;

    //
    // If the client specified a server identifier option, we should
    // drop this packet unless the identified server is this one.
    //

    ipaddr = BinlGetMyNetworkAddress( RequestContext );

    if ( ipaddr == 0 ) {

        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }

    if ( DhcpOptions->Server != NULL ) {

        if ( *DhcpOptions->Server != ipaddr ) {

            Error = ERROR_BINL_INVALID_BINL_CLIENT;
            goto Cleanup;
        }
    }

    //
    //  If a cacheEntry is found here, then it will be marked as InProgress as
    //  a side effect of finding it.  We need to call BinlDoneWithCacheEntry
    //  when we're done with the entry.
    //

    Error = GetGuidFromPacket(  dhcpReceiveMessage,
                                DhcpOptions,
                                Guid,
                                NULL,
                                &pMachineInfo
                                );
    if (Error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    // Generate and send a reply.
    //

    dhcpReceiveMessage->BootFileName[ BOOT_FILE_SIZE - 1 ] = '\0';

    dhcpSendMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;
    RtlZeroMemory( RequestContext->SendBuffer, DHCP_SEND_MESSAGE_SIZE );

    dhcpSendMessage->Operation = BOOT_REPLY;
    dhcpSendMessage->TransactionID = dhcpReceiveMessage->TransactionID;
    dhcpSendMessage->ClientIpAddress = dhcpReceiveMessage->ClientIpAddress;
    dhcpSendMessage->YourIpAddress = dhcpReceiveMessage->YourIpAddress;

    dhcpSendMessage->RelayAgentIpAddress = dhcpReceiveMessage->RelayAgentIpAddress;
    dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved;

    dhcpSendMessage->HardwareAddressType = dhcpReceiveMessage->HardwareAddressType;
    dhcpSendMessage->HardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
    RtlCopyMemory(dhcpSendMessage->HardwareAddress,
                    dhcpReceiveMessage->HardwareAddress,
                    dhcpReceiveMessage->HardwareAddressLength );

    if (pMachineInfo->HostName == NULL) {
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto Cleanup;
    }

    // Comparing BYTE count to CHAR count
    BinlAssert( sizeof( dhcpSendMessage->HostName ) >= wcslen( pMachineInfo->HostName ) );
    BinlAssert( sizeof( dhcpSendMessage->BootFileName ) >= wcslen( pMachineInfo->BootFileName ) );

    wcstombs( dhcpSendMessage->HostName,     pMachineInfo->HostName,     wcslen(pMachineInfo->HostName) + 1);
    wcstombs( dhcpSendMessage->BootFileName, pMachineInfo->BootFileName, wcslen(pMachineInfo->BootFileName) + 1);

    //
    //  if the machineinfo->HostAddress is zero, then that means the hostname
    //  is the same as ours.  we therefore slap in our own ipaddress in.
    //

    boostrapIpAddr = pMachineInfo->HostAddress;

    if (boostrapIpAddr == 0) {

        boostrapIpAddr = ipaddr;
    }

    dhcpSendMessage->BootstrapServerAddress = boostrapIpAddr;

    BinlPrintDbg(( DEBUG_MISC, "HostName: %s\n", dhcpSendMessage->HostName ));
    BinlPrintDbg(( DEBUG_MISC, "HostAddress: %u.%u.%u.%u\n",
        dhcpSendMessage->BootstrapServerAddress & 0xFF,
        (dhcpSendMessage->BootstrapServerAddress >> 8) & 0xFF,
        (dhcpSendMessage->BootstrapServerAddress >> 16) & 0xFF,
        (dhcpSendMessage->BootstrapServerAddress >> 24) & 0xFF ));
    BinlPrintDbg(( DEBUG_MISC, "BootFileName: %s\n", dhcpSendMessage->BootFileName ));

    Option = &dhcpSendMessage->Option;
    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );

    //
    // Append OPTIONS.
    //

    messageType = DHCP_ACK_MESSAGE;
    Option = DhcpAppendOption(
                 Option,
                 OPTION_MESSAGE_TYPE,
                 &messageType,
                 1,
                 OptionEnd
                 );

    Option = DhcpAppendOption(
                 Option,
                 OPTION_SERVER_IDENTIFIER,
                 &ipaddr,
                 sizeof(ipaddr),
                 OptionEnd );

    if (DhcpOptions->GuidLength != 0) {
        Option = DhcpAppendOption(
                     Option,
                     OPTION_CLIENT_GUID,
                     DhcpOptions->Guid,
                     (UCHAR)DhcpOptions->GuidLength,
                     OptionEnd );
    } else {
        UCHAR TmpBuffer[17];

        TmpBuffer[0] = '\0';
        memcpy(TmpBuffer + 1, pMachineInfo->Guid, BINL_GUID_LENGTH);
        Option = DhcpAppendOption(
                     Option,
                     OPTION_CLIENT_GUID,
                     TmpBuffer,
                     17,
                     OptionEnd );

    }

    Option = DhcpAppendOption(
                Option,
                OPTION_CLIENT_CLASS_INFO,
                "PXEClient",
                9,
                OptionEnd
                );

    //
    // Finally, add client requested parameters.
    //

    if ( DhcpOptions->ParameterRequestList != NULL ) {

        Option = AppendClientRequestedParameters(
                    0,
                    0,
                    DhcpOptions->ParameterRequestList,
                    DhcpOptions->ParameterRequestListLength,
                    Option,
                    OptionEnd,
                    DhcpOptions->ClassIdentifier,
                    DhcpOptions->ClassIdentifierLength,
                    FALSE
                    );
    }

    Option = DhcpAppendOption(
                 Option,
                 OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    BinlAssert( RequestContext->SendMessageSize <= DHCP_SEND_MESSAGE_SIZE );

    Error = ERROR_SUCCESS;

Cleanup:
    if ( pMachineInfo ) {
        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    if( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_STOC, "!! Error 0x%08x - BINL Request failed.\n", Error ));
    }

    return( Error );
}

DWORD
ProcessBinlInform(
    IN      LPBINL_REQUEST_CONTEXT RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions
    )
/*++

Routine Description:

    This function will create the response message to the inform packet iff
    the query is asking for our domain name.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    dhcpOptions - Interesting options extracted from the request.

Return Value:

    Windows Error.

--*/
{
    DWORD       Error;
    LPDHCP_MESSAGE dhcpReceiveMessage;
    LPDHCP_MESSAGE dhcpSendMessage;
    LPOPTION    Option;
    LPBYTE      OptionEnd;
    PCHAR       domain = NULL;
    DHCP_IP_ADDRESS ipaddr;

    TraceFunc("ProcessBinlInform( )\n" );

    dhcpReceiveMessage  = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;
    dhcpSendMessage     = (LPDHCP_MESSAGE)RequestContext->SendBuffer;

    ipaddr = BinlGetMyNetworkAddress( RequestContext );

    if ( ipaddr == 0 ) {

        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto exit_inform;
    }

    if ( ! DhcpOptions->DSDomainNameRequested ) {

        BinlPrintDbg((DEBUG_STOC, "Ignoring inform as no domain name option present.\n"));
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto exit_inform;
    }

    domain = GetDhcpDomainName();

    if (domain == NULL) {

        BinlPrintDbg((DEBUG_STOC, "Couldn't get domain name!\n"));
        Error = ERROR_BINL_INVALID_BINL_CLIENT;
        goto exit_inform;
    }

    // if the client IP address is not zero, we may AV in dhcpssvc because
    // it updates a global counter tracking informs.  Always have this as 0.

    Option = FormatDhcpInformAck(                      // Here come the actual formatting of the ack!
        dhcpReceiveMessage,
        dhcpSendMessage,
        0,              // on a ack to an inform query for name, IP address not needed.
        ipaddr
    );
    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    // our enterprise name was requested, append it

    Option = DhcpAppendEnterpriseName(
        Option,
        domain,
        OptionEnd
    );

    // also, make the server send out a broadcast: if someone is using a bad
    // ipaddr, we should make sure we reach him

    dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved = htons(DHCP_BROADCAST);

    //
    // Finally, add client requested parameters.
    //

    if ( DhcpOptions->ParameterRequestList != NULL ) {

        Option = AppendClientRequestedParameters(
                    0,
                    0,
                    DhcpOptions->ParameterRequestList,
                    DhcpOptions->ParameterRequestListLength,
                    Option,
                    OptionEnd,
                    DhcpOptions->ClassIdentifier,
                    DhcpOptions->ClassIdentifierLength,
                    FALSE
                    );
    }

    Option = DhcpAppendOption(
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    BinlAssert( RequestContext->SendMessageSize <= DHCP_SEND_MESSAGE_SIZE );

    Error = ERROR_SUCCESS;

exit_inform:

    if (domain != NULL) {
        LocalFree( domain );
    }
    return Error;
}

LPOPTION
ConsiderAppendingOption(
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask,
    LPOPTION Option,
    BYTE OptionType,
    LPBYTE OptionEnd,
    CHAR *ClassIdentifier,
    DWORD ClassIdentifierLength,
    BOOL  fSwitchedSubnet
    )
/*++

Routine Description:

    This function conditionally appends an option value to a response
    message.  The option is appended if the server has a valid value
    to append.

Arguments:

    IpAddress - The IP address of the client.

    SubnetMask - The subnet mask of the client.

    Option - A pointer to the place in the message buffer to append the
        option.

    OptionType - The option number to consider appending.

    OptionEnd - End of Option Buffer

Return Value:

    A pointer to end of the appended data.

--*/
{
    LPBYTE optionValue = NULL;
    DWORD optionSize;
    DWORD status;
    DWORD dwUnused;

    TraceFunc( "ConsiderAppendingOption( )\n" );

    switch ( OptionType ) {

    //
    // Options already handled.
    //

    case OPTION_SUBNET_MASK:
    case OPTION_REQUESTED_ADDRESS:
    case OPTION_LEASE_TIME:
    case OPTION_OK_TO_OVERLAY:
    case OPTION_MESSAGE_TYPE:
    case OPTION_RENEWAL_TIME:
    case OPTION_REBIND_TIME:
    case OPTION_CLIENT_CLASS_INFO:
    case OPTION_VENDOR_SPEC_INFO:

    //
    // Options it is illegal to ask for.
    //

    case OPTION_PAD:
    case OPTION_PARAMETER_REQUEST_LIST:
    case OPTION_END:

    // Options for DHCP server, not for BINL
    case OPTION_ROUTER_ADDRESS:
        BinlPrintDbg(( DEBUG_ERRORS,
            "Unrecognized option %d\n", OptionType));
    default:

        break;
    }

    return Option;
}

LPOPTION
AppendClientRequestedParameters(
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask,
    LPBYTE RequestedList,
    DWORD ListLength,
    LPOPTION Option,
    LPBYTE OptionEnd,
    CHAR *ClassIdentifier,
    DWORD ClassIdentifierLength,
    BOOL  fSwitchedSubnet
    )
/*++

Routine Description:

Arguments:

Return Value:

    A pointer to the end of appended data.

--*/
{
    while ( ListLength > 0) {
        Option = ConsiderAppendingOption(
                     IpAddress,
                     SubnetMask,
                     Option,
                     *RequestedList,
                     OptionEnd,
                     ClassIdentifier,
                     ClassIdentifierLength,
                     fSwitchedSubnet
                     );
        ListLength--;
        RequestedList++;
    }

    return Option;
}


DWORD
RecognizeClient(
    PUCHAR          pGuid,
    PMACHINE_INFO * ppMachineInfo,
    DWORD           dwRequestedInfo,
    ULONG           SecondsSinceBoot,
    USHORT          SystemArchitecture
    )
/*++

Routine Description:

    This function only return ERROR_SUCCESS if we need to process the message
    from this client.  It may optionally return a cache entry if we actually
    go off to the DS to get the entry.

Arguments:

    Guid - Client identifier, sent to us by them.

    SecondsSinceBoot - from the client.  If we don't know this client and
        this value is small then maybe this client is owned by another BINL
        server. Give the other server time to respond before we send
        OSChooser.

        This gets around the problem (mostly) of two BINL servers that are
        talking to two different DCs with a replication delay between them
        where the client gets sent OSCHOOSER multiple times.

        Alas, if DHCP is running on the same box and we're multihomed, we
        can't delay as that will force the client to go to 4011.  If the
        client does that, then we'll probably return the wrong address.

    ppMachineInfo - what we found.  May be null if we didn't actually go off to
        the DS.
        
    SystemArchitecture - architecture for the client

Return Value:


--*/
{
    HKEY KeyHandle;
    DWORD Error;

    BinlAssertMsg(dwRequestedInfo == (MI_HOSTNAME | MI_BOOTFILENAME),
                  "!! You must modify RecognizeClient() to generate new data\n" );
    BinlAssert(ppMachineInfo);

    TraceFunc( "RecognizeClient( )\n" );

    //
    // Attempt to get the boot parameters. This might fail if
    // the server can't handle any more clients.
    //

    if ( AnswerOnlyValidClients ) {

        //
        //  if we're only responding to existing clients, then call off to
        //  the DS to get the info.
        //

        Error = GetBootParameters( pGuid,
                                   ppMachineInfo,
                                   dwRequestedInfo,
                                   SystemArchitecture,
                                   FALSE );

    } else {

        //
        //  if we are answering new clients but only if it's after a
        //  certain timeout, then call off to the DS to get the info.
        //
        //  Allow OSCHOOSER as a valid response, since AnswerOnlyValidClients is FALSE
        //

        Error = GetBootParameters( pGuid,
                                   ppMachineInfo,
                                   dwRequestedInfo,
                                   SystemArchitecture,
                                   (BOOLEAN) (SecondsSinceBoot >= BinlMinDelayResponseForNewClients) );
    }

    if ( Error == ERROR_SUCCESS ) {

        BinlPrint((DEBUG_OPTIONS, "Recognizing client.\n" ));

        BinlAssert( *ppMachineInfo != NULL );

        if ( (*ppMachineInfo)->MyClient == FALSE ) {

            //
            //  the cache entry is telling us not to handle this client.
            //

            BinlPrint((DEBUG_OPTIONS, "Binl cache entry says not to respond.\n" ));

            Error = ERROR_BINL_INVALID_BINL_CLIENT;

            BinlDoneWithCacheEntry( *ppMachineInfo, FALSE );
            *ppMachineInfo = NULL;
        }
    } else {

        if ( AnswerOnlyValidClients ) {
            BinlPrint((DEBUG_OPTIONS, "Client ignored - Not answering for unknown clients (AnswerOnlyValid TRUE)\n" ));
        } else {
            BinlPrint((DEBUG_OPTIONS, "Client ignored - Not answering requests from boot %u < %u\n",
                                        SecondsSinceBoot,
                                        BinlMinDelayResponseForNewClients
                                        ));
        }
    }

    return Error;
}

DWORD
UpdateAccount(
    PCLIENT_STATE ClientState,
    PMACHINE_INFO pMachineInfo,
    BOOL          fCreate
    )
/*++

Routine Description:

    Create a new computer object. BINL must impersonate the client so that the
    appropriate access checks are performed on the DS.

Arguments:

    LdapHandle   - User credentially created LDAP connection
    pMachineInfo - Information to be used to populate the new MAO

Return Value:

    Win32 error code or ERROR_SUCCESS.

--*/
{
    WCHAR BootFilePath[MAX_PATH];
    ULONG LdapError = LDAP_SUCCESS; // not returned
    DWORD Error = ERROR_SUCCESS;    // this is the returned ERROR_BINL code
    ULONG iModCount, i,q;
    ULONG LdapMessageId;
    ULONG LdapMessageType;
    PLDAPMessage LdapMessage = NULL;
    BOOLEAN Impersonating = FALSE;

    LDAP_BERVAL guid_attr_value;
    PLDAP_BERVAL guid_attr_values[2];
    LDAP_BERVAL password_attr_value;
    PLDAP_BERVAL password_attr_values[2];

    DWORD dwRequiredFlags = MI_SAMNAME
                          | MI_BOOTFILENAME
                          | MI_HOSTNAME
                          | MI_SETUPPATH
                          | MI_PASSWORD;

    PWCHAR attr_values[6][2];            

    PLDAPMod ldap_mods[6];
    LDAPMod SamAccountName;
    LDAPMod ObjectTypeComputer;
    LDAPMod FilePath;
    LDAPMod SetupPathMod;
    LDAPMod UserAccountControl;
    LDAPMod UnicodePwd;
    LDAPMod NicGuid;

    BOOLEAN invalidateCache = FALSE;
    BOOLEAN updateCache = FALSE;

    TraceFunc( "UpdateAccount( )\n" );

    //
    // First impersonate the client.
    //

    Error = OscImpersonate(ClientState);
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg((DEBUG_ERRORS,
                   "UpdateAccount: OscImpersonate failed %lx\n", Error));
        goto Cleanup;
    }

tryagain:
    Impersonating = TRUE;

    //
    // now initialize all of the properties we want to set on the MAO.
    //

    // Make sure we have all the information we need.
    if ( ! (pMachineInfo->dwFlags & MI_MACHINEDN) ||  pMachineInfo->MachineDN == NULL ) {
        BinlAssertMsg( 0, "Missing the Machine's DN" );
        OscAddVariableA( ClientState, "SUBERROR", "MACHINEDN" );
        Error = ERROR_BINL_MISSING_VARIABLE;
        goto Cleanup;
    }
    BinlAssert( !fCreate || (( pMachineInfo->dwFlags & dwRequiredFlags ) == dwRequiredFlags ) );
#if DBG
    // We must have both of these or none of these.
    if ( ( pMachineInfo->dwFlags & MI_HOSTNAME ) || ( pMachineInfo->dwFlags & MI_BOOTFILENAME ) ) {
        BinlAssert( ( pMachineInfo->dwFlags & (MI_HOSTNAME | MI_BOOTFILENAME) ) == (MI_HOSTNAME | MI_BOOTFILENAME) );
    }
#endif

    iModCount = 0;
     
    if ( AssignNewClientsToServer &&
         (pMachineInfo->dwFlags & (MI_HOSTNAME | MI_BOOTFILENAME)) )
    {
        if ( _snwprintf( BootFilePath,
                         sizeof(BootFilePath) / sizeof(BootFilePath[0]),
                         L"%ws\\%ws",
                         pMachineInfo->HostName,
                         pMachineInfo->BootFileName
                         ) == -1 ) {
            Error = ERROR_BAD_PATHNAME;
            goto Cleanup;
        }
        attr_values[2][0] = BootFilePath;
        attr_values[2][1] = NULL;
        FilePath.mod_op = 0;
        FilePath.mod_type = L"netbootMachineFilePath";
        FilePath.mod_values = attr_values[2];
        ldap_mods[iModCount++] = &FilePath;

    }

    if ( pMachineInfo->dwFlags & MI_SETUPPATH ) {
        attr_values[3][0] = pMachineInfo->SetupPath;
        attr_values[3][1] = NULL;
        SetupPathMod.mod_op = 0;
        SetupPathMod.mod_type = L"netbootInitialization";
        SetupPathMod.mod_values = attr_values[3];
        ldap_mods[iModCount++] = &SetupPathMod;

    }

    if ( pMachineInfo->dwFlags & MI_GUID ) {
        guid_attr_values[0] = &guid_attr_value;
        guid_attr_values[1] = NULL;
        guid_attr_value.bv_val = pMachineInfo->Guid;
        guid_attr_value.bv_len = BINL_GUID_LENGTH;
        NicGuid.mod_op =    LDAP_MOD_BVALUES;
        NicGuid.mod_type =  L"netbootGUID";
        NicGuid.mod_bvalues = guid_attr_values;
        ldap_mods[iModCount++] = &NicGuid;
        
    }

    if ( fCreate && ( pMachineInfo->dwFlags & MI_SAMNAME ) ) {
        attr_values[0][0] = pMachineInfo->SamName;
        attr_values[0][1] = NULL;
        SamAccountName.mod_op = 0;
        SamAccountName.mod_type = L"sAMAccountName";
        SamAccountName.mod_values = attr_values[0];
        ldap_mods[iModCount++] = &SamAccountName;
    }

    attr_values[4][0] = L"4096";  // 0x1000 -- workstation trust account, enabled
    attr_values[4][1] = NULL;
    UserAccountControl.mod_op = 0;
    UserAccountControl.mod_type = L"userAccountControl";
    UserAccountControl.mod_values = attr_values[4];
    ldap_mods[iModCount++] = &UserAccountControl;

    //
    // if we're creating the MAO, then we need to specify the object type
    // as a computer object
    //
    if ( fCreate ) {
        attr_values[1][0] = L"Computer";
        attr_values[1][1] = NULL;
        ObjectTypeComputer.mod_op = 0;
        ObjectTypeComputer.mod_type = L"objectClass";
        ObjectTypeComputer.mod_values = attr_values[1];
        ldap_mods[iModCount++] = &ObjectTypeComputer;
    }

    //
    // Set the operation type depending on the create or modify flag
    //
    for ( i = 0 ; i < iModCount; i++ )
    {
        if ( fCreate ) {
            ldap_mods[i]->mod_op |= LDAP_MOD_ADD;
        } else {
            ldap_mods[i]->mod_op |= LDAP_MOD_REPLACE;
        }
    }

    ldap_mods[iModCount] = NULL; // terminate list

    //
    // The properties are initialized, so now either create or modify the MAO.
    //
    if ( fCreate || iModCount ) {

        if ( fCreate ) {

            BinlPrintDbg((DEBUG_OSC, "UpdateAccount() Creating a new MAO\n" ));
#if DBG
            for (q = 0;q < iModCount; q++) {
                BinlPrintDbg(( DEBUG_OSC, "LDAP Prop %x: Type: %S  Value: %S",
                               q, 
                               ldap_mods[q]->mod_type,
                               *ldap_mods[q]->mod_vals.modv_strvals ));
            }

#endif


            //
            // synchronously Create the object.
            //     

            LdapMessageId = ldap_add( ClientState->AuthenticatedDCLdapHandle, pMachineInfo->MachineDN, ldap_mods );

            if (LdapMessageId == -1) {
    
                Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                LdapError = LdapGetLastError();
                LogLdapError(   EVENT_WARNING_LDAP_ADD_ERROR,
                                LdapError,
                                ClientState->AuthenticatedDCLdapHandle
                                );
                BinlPrintDbg(( DEBUG_ERRORS,
                    "CreateAccount ldap_add failed %x\n", LdapError));
                goto Cleanup;
            }
    
            LdapMessageType = ldap_result(
                                  ClientState->AuthenticatedDCLdapHandle,
                                  LdapMessageId,
                                  LDAP_MSG_ALL,
                                  &BinlLdapSearchTimeout,
                                  &LdapMessage);
    
            if (LdapMessageType != LDAP_RES_ADD) {
    
                BinlPrintDbg(( DEBUG_ERRORS,
                    "CreateAccount ldap_result returned type %lx\n", LdapMessageType));
                OscAddVariableA( ClientState, "SUBERROR", "Unexpected LDAP error" );
                Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                goto Cleanup;
            }
    
            LdapError = ldap_result2error(
                            ClientState->AuthenticatedDCLdapHandle,
                            LdapMessage,
                            0);
    
            if (LdapError != LDAP_SUCCESS) {

                if (LdapError != LDAP_ALREADY_EXISTS) {
                    Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                    LogLdapError(   EVENT_WARNING_LDAP_ADD_ERROR,
                                    LdapError,
                                    ClientState->AuthenticatedDCLdapHandle
                                    );
                    BinlPrintDbg(( DEBUG_ERRORS, "!!LdapError 0x%08x - UpdateAccount ldap_add_s( ) failed\n", LdapError));
                    goto Cleanup;
                } else {
                    BinlPrintDbg((DEBUG_OSC, "UpdateAccount() tried to create an existing account.  Try again, but modify existing MAO.\n" ));
                    fCreate = FALSE;
                    goto tryagain;
                }
            }

            updateCache = TRUE;

        } else {
        
            //
            // We don't strictly need to reset the properties below, as the
            // content under the MAO should be static. But it won't really
            // hurt things to try to reset in case something does change.
            //
            // Note that the reset of these properties may not succeed because
            // the user may not have permissions to modify the MAO, depending 
            // on how the admin locks things down. (The admin can use GPO to
            // allow the user to create MAOs but not modify the objects.)
            //
            
            //
            // asynchronously reset the properties
            //

            BinlPrintDbg((DEBUG_OSC, "UpdateAccount() updating existing MAO\n" ));
    
            LdapMessageId = ldap_modify( ClientState->AuthenticatedDCLdapHandle, pMachineInfo->MachineDN, ldap_mods );
    
            if (LdapMessageId == -1) {
    
                Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                LdapError = LdapGetLastError();
                LogLdapError(   EVENT_WARNING_LDAP_MODIFY_ERROR,
                                LdapError,
                                ClientState->AuthenticatedDCLdapHandle
                                );
                BinlPrintDbg(( DEBUG_ERRORS,
                    "UpdateAccount ldap_modify(userAccountControl) failed %x\n", LdapError));
                goto Cleanup;
            }
    
            LdapMessageType = ldap_result(
                                  ClientState->AuthenticatedDCLdapHandle,
                                  LdapMessageId,
                                  LDAP_MSG_ALL,
                                  &BinlLdapSearchTimeout,
                                  &LdapMessage);
    
            if (LdapMessageType != LDAP_RES_MODIFY) {
    
                BinlPrintDbg(( DEBUG_ERRORS,
                    "CreateAccount ldap_result returned type %lx\n", LdapMessageType));
                OscAddVariableA( ClientState, "SUBERROR", "Unexpected LDAP error" );
                Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                goto Cleanup;
            }
    
            LdapError = ldap_result2error(
                            ClientState->AuthenticatedDCLdapHandle,
                            LdapMessage,
                            0);
    
            if (LdapError != LDAP_SUCCESS) {
                LogLdapError(   EVENT_WARNING_LDAP_MODIFY_ERROR,
                                LdapError,
                                ClientState->AuthenticatedDCLdapHandle
                                );
                BinlPrintDbg(( DEBUG_ERRORS, "CreateAccount ldap_result2error failed %x\n", LdapError));
    
                // if the user doesn't have the rights to change
                // the properties then we'll just silently ignore the error
                //  (though we did just log an error for it).                  
                if ( LdapError != LDAP_INSUFFICIENT_RIGHTS) {
                    Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
                    goto Cleanup;
                }
                LdapError = LDAP_SUCCESS;
            }
    
            updateCache = TRUE;
        }
    }

    //
    // if we've made it this far, we've got a MAO that's setup properly.  
    // Now we need to reset the account password so the domain join is
    // somewhat secure.
    //
    if ( pMachineInfo->dwFlags & MI_PASSWORD ) {    
#ifdef SET_PASSWORD_WITH_LDAP
        iModCount = 0;
        password_attr_values[0] = &password_attr_value;
        password_attr_values[1] = NULL;
        password_attr_value.bv_val = (PUCHAR) pMachineInfo->Password;
        password_attr_value.bv_len = pMachineInfo->PasswordLength;
        UnicodePwd.mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;    // you always "Add" the "unicodePwd"
        UnicodePwd.mod_type = L"unicodePwd";
        UnicodePwd.mod_bvalues = password_attr_values;
    
        ldap_mods[iModCount++] = &UnicodePwd;
        ldap_mods[iModCount] = NULL;    // terminate list

        LdapError = ldap_modify_s( ClientState->AuthenticatedDCLdapHandle, pMachineInfo->MachineDN, ldap_mods );
    
        if (LdapError != LDAP_SUCCESS) {
            LogLdapError(   EVENT_WARNING_LDAP_MODIFY_ERROR,
                            LdapError,
                            ClientState->AuthenticatedDCLdapHandle
                            );
            BinlPrintDbg(( DEBUG_ERRORS, "!!LdapError 0x%08x - UpdateAccount ldap_modify_s( ) failed\n", LdapError));
            goto Cleanup;
        }    
#else
        //
        // At this point we depend on LdapMessage being valid, which will
        // *not* be the case if we are only setting the password. This
        // breaks machine replacement for the moment.
        //
        BinlAssert( LdapMessage != NULL );
    
        Error = OscUpdatePassword(
                    ClientState,
                    pMachineInfo->SamName,
                    pMachineInfo->Password,
                    ClientState->AuthenticatedDCLdapHandle,
                    LdapMessage);
    
        if (Error != ERROR_SUCCESS) {
            goto Cleanup;
        }
#endif

    }

Cleanup:
    //
    // Convert the LdapError to a ERROR_BINL and put the LdapError
    // into SUBERROR.
    //
    if ( LdapError != LDAP_SUCCESS )
    {
        OscCreateLDAPSubError( ClientState, LdapError );
        switch ( LdapError )
        {
        case LDAP_ALREADY_EXISTS:
            Error = ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND;
            break;

        case LDAP_INVALID_DN_SYNTAX:
            Error = ERROR_BINL_INVALID_OR_MISSING_OU;
            break;

        default:
            Error = ERROR_BINL_FAILED_TO_CREATE_CLIENT;
            break;
        }
    }

    if ( updateCache && ( pMachineInfo->dwFlags & MI_GUID ) ) {

        //
        //  update the cached DS information so that it is current.  We do
        //  this because if the account is created in a child domain, we still
        //  have the info cached (even if it hasn't replicated to the GC yet).
        //

        PMACHINE_INFO pCacheEntry = NULL;

        BinlCreateOrFindCacheEntry( pMachineInfo->Guid, TRUE, &pCacheEntry );

        invalidateCache = FALSE;

        // we don't care about the error coming back, only if a record was found.

        if (pCacheEntry != NULL) {

            pCacheEntry->TimeCreated = GetTickCount();
            pCacheEntry->MyClient = TRUE;
            pCacheEntry->EntryExists = TRUE;

            if (pCacheEntry != pMachineInfo) {

                memcpy( &pCacheEntry->HostAddress,
                        &pMachineInfo->HostAddress,
                        sizeof(pMachineInfo->HostAddress));

                if ( pMachineInfo->Name ) {
                    pCacheEntry->Name = BinlStrDup( pMachineInfo->Name );
                    if (!pCacheEntry->Name) {
                        goto noMemory;
                    }
                    pCacheEntry->dwFlags |= MI_NAME_ALLOC | MI_NAME;
                }

                if ( pMachineInfo->MachineDN ) {
                    pCacheEntry->MachineDN = BinlStrDup( pMachineInfo->MachineDN );
                    if (!pCacheEntry->MachineDN) {
                        goto noMemory;
                    }
                    pCacheEntry->dwFlags |= MI_MACHINEDN_ALLOC | MI_MACHINEDN;
                }

                if ( pMachineInfo->SetupPath ) {
                    pCacheEntry->SetupPath = BinlStrDup( pMachineInfo->SetupPath );
                    if (!pCacheEntry->SetupPath) {
                        goto noMemory;
                    }
                    pCacheEntry->dwFlags |= MI_SETUPPATH_ALLOC | MI_SETUPPATH;
                }

                if ( pMachineInfo->HostName ) {
                    pCacheEntry->HostName = BinlStrDup( pMachineInfo->HostName );
                    if (!pCacheEntry->HostName) {
                        goto noMemory;
                    }
                    pCacheEntry->dwFlags |= MI_HOSTNAME_ALLOC | MI_HOSTNAME;
                }

                if ( pMachineInfo->SamName ) {
                    pCacheEntry->SamName = BinlStrDup( pMachineInfo->SamName );
                    if (!pCacheEntry->SamName) {
                        goto noMemory;
                    }
                    pCacheEntry->dwFlags |= MI_SAMNAME_ALLOC | MI_SAMNAME;
                }

                if ( pMachineInfo->Domain ) {
                    pCacheEntry->Domain = BinlStrDup( pMachineInfo->Domain );
                    if (!pCacheEntry->Domain) {
noMemory:
                        invalidateCache = TRUE;
                        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;

                    } else {
                        pCacheEntry->dwFlags |= MI_DOMAIN_ALLOC | MI_DOMAIN;
                    }
                }
            }
            BinlDoneWithCacheEntry( pCacheEntry, invalidateCache );
        }
    }

    if ( invalidateCache && ( pMachineInfo->dwFlags & MI_GUID ) ) {

        //
        //  invalidate the cached DS information if we failed because it's stale.
        //

        PMACHINE_INFO pCacheEntry = NULL;

        BinlCreateOrFindCacheEntry( pMachineInfo->Guid, FALSE, &pCacheEntry );

        // we don't care about the error coming back, only if a record was found.

        if ((pCacheEntry != NULL) &&
            (pCacheEntry != pMachineInfo)) {

            BinlDoneWithCacheEntry( pCacheEntry, TRUE );
        }
    }

    if (LdapMessage != NULL) {
        ldap_msgfree(LdapMessage);
    }

    if (Impersonating) {
        OscRevert(ClientState);
    }

    return Error;
}

DWORD
BinlGenerateNewEntry(
    DWORD                  dwRequestedInfo,
    USHORT                 SystemArchitecture,
    PMACHINE_INFO *        ppMachineInfo )
{
    DWORD Error = ERROR_BINL_INVALID_BINL_CLIENT;

    TraceFunc( "BinlGenerateNewEntry( ... )\n" );

    if ( AllowNewClients ) {

        BinlPrint(( DEBUG_OPTIONS, "Server allows new clients" ));

        if ( ( LimitClients == FALSE ) ||
             ( CurrentClientCount < BinlMaxClients ) ) {

            BinlPrint(( DEBUG_OPTIONS, " and the Server is generating the OS Chooser path response.\n" ));

            if ( dwRequestedInfo & MI_HOSTNAME ) {

                ULONG ulSize;

                if ( (*ppMachineInfo)->dwFlags & MI_HOSTNAME_ALLOC ) {
                    BinlFreeMemory( (*ppMachineInfo)->HostName );
                    (*ppMachineInfo)->HostName = NULL;
                    (*ppMachineInfo)->dwFlags &= ~MI_HOSTNAME_ALLOC;
                }

                EnterCriticalSection( &gcsParameters );

                if (BinlGlobalOurDnsName == NULL) {

                    LeaveCriticalSection( &gcsParameters );
                    return (ERROR_OUTOFMEMORY);
                }

                (*ppMachineInfo)->HostName = (PWCHAR) BinlAllocateMemory( ( lstrlenW( BinlGlobalOurDnsName ) + 1 ) * sizeof(WCHAR) );
                if ( !(*ppMachineInfo)->HostName ) {
                    LeaveCriticalSection( &gcsParameters );
                    return (ERROR_OUTOFMEMORY);
                }

                lstrcpyW( (*ppMachineInfo)->HostName, BinlGlobalOurDnsName );

                LeaveCriticalSection( &gcsParameters );

                (*ppMachineInfo)->dwFlags |= MI_HOSTNAME_ALLOC;

                (*ppMachineInfo)->dwFlags |= MI_HOSTNAME;
            }

            if ( dwRequestedInfo & MI_BOOTFILENAME ) {
                ULONG ulSize;
                PCWSTR OsChooserName = NULL;
                
                switch ( SystemArchitecture ) {
                    case DHCP_OPTION_CLIENT_ARCHITECTURE_X86:
                        OsChooserName = IntelOSChooser;
                        ulSize = (wcslen(OsChooserName)+1)*sizeof(WCHAR);
                        break;
                    case DHCP_OPTION_CLIENT_ARCHITECTURE_IA64:
                        OsChooserName = IA64OSChooser;
                        ulSize = (wcslen(OsChooserName)+1)*sizeof(WCHAR);
                        break;
                    default:
                        BinlAssertMsg( FALSE, "UnsupportedArchitecture" );
                }

                if (OsChooserName) {
                
                    if ( (*ppMachineInfo)->dwFlags & MI_BOOTFILENAME_ALLOC ) {
                        BinlFreeMemory( (*ppMachineInfo)->BootFileName );
                        (*ppMachineInfo)->dwFlags &= ~MI_BOOTFILENAME_ALLOC;
                    }
    
                    (*ppMachineInfo)->BootFileName = BinlAllocateMemory( ulSize * sizeof(WCHAR) );
                    if ( !(*ppMachineInfo)->BootFileName ) {
                        return (ERROR_OUTOFMEMORY);
                    }

                    wcscpy((*ppMachineInfo)->BootFileName, OsChooserName);
                    (*ppMachineInfo)->dwFlags |= MI_BOOTFILENAME | MI_BOOTFILENAME_ALLOC;

                }
            }

            Error = ( ((*ppMachineInfo)->dwFlags & dwRequestedInfo ) == dwRequestedInfo ?
                      ERROR_SUCCESS :
                      ERROR_BINL_FAILED_TO_INITIALIZE_CLIENT );

        } else {

            BinlPrint(( DEBUG_OPTIONS, "... BUT the server has reached MaxClients (%u)\n", BinlMaxClients ));

        }
    } else {

        BinlPrint((DEBUG_OPTIONS, "Server does not allow new clients (AllowNewClients == FALSE )\n" ));
    }

    return Error;
}

DWORD
GetBootParameters(
    PUCHAR          pGuid,
    PMACHINE_INFO * ppMachineInfo,
    DWORD           dwRequestedInfo,
    USHORT          SystemArchitecture,
    BOOL            AllowOSChooser
    )
/*++

Routine Description:

    Use the Directory Service to lookup an entry for this machine using Guid as
    the value to lookup.

    If there is no entry for this machine then return oschooser, but only
    if the AllowOSChooser flag is set.

    If a cache entry is returned, then the cache entry has been marked
    InProgress so we have to call BinlDoneWithCacheEntry when the caller
    is done with it.

Arguments:

    pGuid -  Supplies the machine GUID

    ppMachineInfo - gets filled in with what we discovered
    
    dwRequestedInfo - a bitmask telling us what parameters we're looking for
    
    SystemArchitecture - architecture of the client
    
    AllowOSChooser - signifies that we're allowed to respond to the client with
                     the oschooser

Return Value:

    ERROR_SUCCESS or ERROR_BINL_INVALID_BINL_CLIENT or other error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    BOOLEAN myClient = TRUE;
    BOOLEAN entryExists = FALSE;

    TraceFunc( "GetBootParameters( )\n" );

    BinlAssert( ppMachineInfo );

    {
        LPGUID GuidPtr = (LPGUID) pGuid;
        BinlPrint((DEBUG_MISC, "Client Guid: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
            GuidPtr->Data1, GuidPtr->Data2, GuidPtr->Data3,
            GuidPtr->Data4[0], GuidPtr->Data4[1], GuidPtr->Data4[2], GuidPtr->Data4[3],
            GuidPtr->Data4[4], GuidPtr->Data4[5], GuidPtr->Data4[6], GuidPtr->Data4[7] ));
    }

    if ( ppMachineInfo == NULL ) {
        return E_OUTOFMEMORY;
    }

    if (*ppMachineInfo == NULL) {
        //
        // See if we have any entries in the cache.
        // This also mark any entry found as being used.
        //
        Error = BinlCreateOrFindCacheEntry( pGuid, TRUE, ppMachineInfo );
        if ( Error != ERROR_SUCCESS ) {
            //
            //  if some bizarre error occurred OR if the client simply wasn't
            //  found and we're not sending down OS Chooser, then return the
            //  error here as there's no reason to query the DS.
            //

            if ( (Error != ERROR_BINL_INVALID_BINL_CLIENT ) ||
                 (AllowOSChooser == FALSE) ) {

                return Error;
            }
        }
    }

    // Do we have everything we need?
    if ( ( Error == ERROR_SUCCESS ) &&
         (((*ppMachineInfo)->dwFlags & dwRequestedInfo) == dwRequestedInfo )) {
        BinlPrint((DEBUG_MISC, "cache hit: returning success without querying ds DS\n"));
        return Error;   // Yes, no need to hit the DS.
    }

    //
    //  Initially search for the Computer object in the same domain as ourselves.
    //  This should be quick (because we are probably on a DC) and likely to work
    //  most of the time because the network topology will usually match the domain
    //  structure. If that fails then we fall back to looking at the global catalog.
    //

    if ( Error != ERROR_BINL_INVALID_BINL_CLIENT ) {
        Error = GetBootParametersExt( 
                            *ppMachineInfo, 
                            dwRequestedInfo, 
                            SystemArchitecture, 
                            FALSE);

        if ( Error == ERROR_BINL_INVALID_BINL_CLIENT ) {

            Error = GetBootParametersExt( 
                            *ppMachineInfo, 
                            dwRequestedInfo, 
                            SystemArchitecture, 
                            TRUE );
        }
    }

    if ( Error == ERROR_BINL_INVALID_BINL_CLIENT ) {

        //
        // Backdoor for testing/overiding the DS.
        //
        // If the registry has the GUID of the client, it
        // overrides all the DS settings and answers anyways.
        //
        // NOTE: AllowNewClients must be turned on for OSChooser to
        //       be sent down.
        //

        HKEY KeyHandle;

        if (AllowOSChooser == TRUE) {

            //
            //  if the client is not found in the DS and we're allowed to
            //  answer new clients, then send down OSCHOOSER to get the new
            //  client going.
            //
            BinlPrint((DEBUG_MISC, "generating a new entry because AllowOSChooser is TRUE...\n"));
            Error = BinlGenerateNewEntry( dwRequestedInfo, SystemArchitecture, ppMachineInfo );

            if ( Error != ERROR_SUCCESS ) {
                myClient = FALSE;
            }

        } else {

            //
            //  We're not answering because we didn't find the client
            //  record but the client's SecondsSinceBoot is less than
            //  BinlMinDelayResponseForNewClients.
            //

            Error = ERROR_BINL_INVALID_BINL_CLIENT;
            myClient = FALSE;

            BinlPrint((DEBUG_OPTIONS, "... OS Chooser is not an option at this time... waiting...\n" ));
        }
    }

    //
    // Determine the host servers IP address iff it's not our own machine.
    //
    if ((Error == ERROR_SUCCESS) &&
        ( (*ppMachineInfo)->dwFlags & MI_HOSTNAME )
       && ( (*ppMachineInfo)->HostAddress == 0 )
       && ( (*ppMachineInfo)->HostName )) {

        EnterCriticalSection( &gcsParameters );

        if ( (BinlGlobalOurDnsName != NULL) &&
             (lstrcmpiW( BinlGlobalOurDnsName, (*ppMachineInfo)->HostName ) != 0 )) {

            PCHAR machineName;
            PHOSTENT host;
            ULONG myMachineNameLength;
            PCHAR myMachineName;
            ULONG machineNameLength;

            myMachineNameLength = wcslen( BinlGlobalOurDnsName ) + 1;
            myMachineName = BinlAllocateMemory ( myMachineNameLength * sizeof(WCHAR) );
            if ( myMachineName != NULL ) {

                wcstombs(myMachineName, BinlGlobalOurDnsName, myMachineNameLength );
            }
            LeaveCriticalSection( &gcsParameters );

            machineNameLength = wcslen((*ppMachineInfo)->HostName) + 1;
            machineName = BinlAllocateMemory( machineNameLength );

            //
            //  Only fill in the IP address if the server is different from our
            //  own machine.  If we fail for any reason, we'll just end up using
            //  our own IP address.
            //

            if (machineName != NULL) {

                wcstombs( machineName, (*ppMachineInfo)->HostName, machineNameLength );

                host = gethostbyname( machineName );
                if (host != NULL) {
                    (*ppMachineInfo)->HostAddress = *(PDHCP_IP_ADDRESS)host->h_addr;
                    // Adding stuff for multi-home NIC
                    if (myMachineName != NULL) {

                        PHOSTENT myhost;
                        int i;
                        myhost = gethostbyname( myMachineName );
                        if (myhost != NULL) {
                            i=0;
                            while (((myhost->h_addr_list)[i]) != NULL) {
                                if ((*((PDHCP_IP_ADDRESS)((myhost->h_addr_list)[i])))
                                    == (*ppMachineInfo)->HostAddress) {

                                    (*ppMachineInfo)->HostAddress = (DHCP_IP_ADDRESS)0;
                                    break;
                                }
                                i++;
                            }
                        }
                    }

                } else {
                    Error = ERROR_HOST_UNREACHABLE;
                    myClient = FALSE;
                    entryExists = TRUE;
                }
                BinlFreeMemory( machineName );
            } else {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                myClient = FALSE;
                entryExists = TRUE;
            }
            if ( myMachineName != NULL ) {
                BinlFreeMemory( myMachineName );
            }

        } else {
            LeaveCriticalSection( &gcsParameters );
        }
    }

    if (Error != ERROR_SUCCESS) {

        //
        //  If we didn't find the record, then we mark it that we don't need
        //  to respond and it doesn't exist.  We then mark that we're done with
        //  the entry since we're not passing it back to the caller.
        //
        (*ppMachineInfo)->MyClient = myClient;
        (*ppMachineInfo)->EntryExists = entryExists;

        BinlDoneWithCacheEntry( *ppMachineInfo, FALSE );
        *ppMachineInfo = NULL;

    } else {

        //
        //  we've filled in the interesting fields, therefore mark that the
        //  entry has valid data.
        //

        (*ppMachineInfo)->MyClient = TRUE;
        (*ppMachineInfo)->EntryExists = TRUE;
    }

    return Error;
}

DWORD
GetBootParametersExt(
    PMACHINE_INFO pMachineInfo,
    DWORD         dwRequestedInfo,
    USHORT        SystemArchitecture,
    BOOL          fGlobalSearch)
/*++

Routine Description:

    Use the Directory Service to lookup an entry for this machine using Guid as
    the value to lookup.

    If there is no entry for this machine then return oschooser

Arguments:

    pMachineInfo - identifies the machine in the DS.

    dwRequestedInfo - mask telling what information we should query
    
    SystemArchitecture - architecture of the client

    GlobalSearch - TRUE if GC should be used

Return Value:

    ERROR_SUCCESS or ERROR_BINL_INVALID_BINL_CLIENT

--*/
{
    DWORD dwErr = ERROR_BINL_INVALID_BINL_CLIENT;
    PLDAP LdapHandle = NULL;
    PWCHAR * Base;
    DWORD LdapError;
    DWORD entryCount;
    DWORD ldapRetryLimit = 0;

    PLDAPMessage LdapMessage;

    PWCHAR * FilePath;
    PWCHAR * FilePath2;
    PLDAPMessage CurrentEntry;

    WCHAR Filter[128];
    WCHAR EscapedGuid[64];

    //  Paramters we want from the Computer Object
    PWCHAR ComputerAttrs[7];
    PDUP_GUID_DN dupDN;

    TraceFunc( "GetBootParametersExt( )\n" );

    pMachineInfo->dwFlags &= MI_ALL_ALLOC; // clear all but the ALLOC bits

    // we get all the info, regardless of what was requested.

    ComputerAttrs[0] = &L"netbootMachineFilePath";
    ComputerAttrs[1] = &L"netbootInitialization";
    ComputerAttrs[2] = &L"sAMAccountName";
    ComputerAttrs[3] = &L"dnsHostName";
    ComputerAttrs[4] = &L"distinguishedName";
    ComputerAttrs[5] = &L"netbootSIFFile";
    ComputerAttrs[6] = NULL;

    BinlAssertMsg( !(dwRequestedInfo & MI_PASSWORD), "Can't get the machine's password!" );

    //  Build the filter to find the Computer object with this GUID
    ldap_escape_filter_element(pMachineInfo->Guid, BINL_GUID_LENGTH, EscapedGuid, sizeof(EscapedGuid) );
    
    //
    // Dont' use ';binary' because win2k Active Directory isn't compatible with the
    // binary tag.
    //
    wsprintf( Filter, L"(&(objectClass=computer)(netbootGUID=%ws))", EscapedGuid );

#if 0 && DBG
    {
        LPGUID GuidPtr = (LPGUID) &pMachineInfo->Guid;
        BinlPrint((DEBUG_MISC, "Client Guid: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
            GuidPtr->Data1, GuidPtr->Data2, GuidPtr->Data3,
            GuidPtr->Data4[0], GuidPtr->Data4[1], GuidPtr->Data4[2], GuidPtr->Data4[3],
            GuidPtr->Data4[4], GuidPtr->Data4[5], GuidPtr->Data4[6], GuidPtr->Data4[7] ));
    }
#endif

RetryConnection:
    dwErr = InitializeConnection( fGlobalSearch, &LdapHandle, &Base );
    if ( dwErr != ERROR_SUCCESS ) {
        BinlPrint((DEBUG_ERRORS, 
                   "InitializeConnection failed, ec = %x\n",dwErr));  
        SetLastError( dwErr );
        dwErr = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e0;
    }

    LdapError = ldap_search_ext_s(LdapHandle,
                                  *Base,
                                  LDAP_SCOPE_SUBTREE,
                                  Filter,
                                  ComputerAttrs,
                                  FALSE,
                                  NULL,
                                  NULL,
                                  &BinlLdapSearchTimeout,
                                  0,
                                  &LdapMessage);

    if ( LdapError != LDAP_SUCCESS ) {
        HandleLdapFailure(  LdapError,
                            EVENT_WARNING_LDAP_SEARCH_ERROR,
                            fGlobalSearch,
                            &LdapHandle,
                            FALSE );    // don't have lock
        if (LdapHandle == NULL) {

            if (++ldapRetryLimit < LDAP_SERVER_DOWN_LIMIT) {
                goto RetryConnection;
            }
            dwErr = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
            SetLastError( dwErr );
            goto e0;
        }

        BinlPrint((DEBUG_MISC, 
                   "ldap_search_ext_s %ws failed, ec = %x\n",
                   Filter,
                   LdapError));

    }

    //  Did we get a Computer Object?
    entryCount = ldap_count_entries( LdapHandle, LdapMessage );
    if ( entryCount == 0 ) {
        BinlPrint((DEBUG_MISC, 
                   "ldap_count_entries %ws returned 0 entries\n",
                   Filter ));
        dwErr = ERROR_BINL_INVALID_BINL_CLIENT;
        goto e1; // nope
    }

    // if we get more than more entry back, we will use only the
    // first one.
    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    if (entryCount > 1) {
        BinlLogDuplicateDsRecords( (LPGUID)&pMachineInfo->Guid, LdapHandle, LdapMessage, CurrentEntry );
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"distinguishedName");
    if ( FilePath ) {

        if ( pMachineInfo->dwFlags & MI_MACHINEDN_ALLOC ) {
            BinlFreeMemory( pMachineInfo->MachineDN );
            pMachineInfo->dwFlags &= ~MI_MACHINEDN_ALLOC;
        }

        pMachineInfo->MachineDN = BinlStrDup( *FilePath );
        if ( pMachineInfo->MachineDN ) {

            pMachineInfo->dwFlags |= MI_MACHINEDN | MI_MACHINEDN_ALLOC;
        }
        BinlPrint(( DEBUG_MISC, "MachineDN = %ws\n", pMachineInfo->MachineDN ));
        ldap_value_free( FilePath );
    } else {
        BinlPrint((DEBUG_MISC, 
                   "couldn't get distinguishedName for %ws\n",
                   Filter ));
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"netbootInitialization" );
    if ( FilePath ) {

        if ( pMachineInfo->dwFlags & MI_SETUPPATH_ALLOC ) {
            BinlFreeMemory( pMachineInfo->SetupPath );
            pMachineInfo->dwFlags &= ~MI_SETUPPATH_ALLOC;
        }

        pMachineInfo->SetupPath = BinlStrDup( *FilePath );
        if ( pMachineInfo->SetupPath ) {

            pMachineInfo->dwFlags |= MI_SETUPPATH | MI_SETUPPATH_ALLOC;
            BinlPrintDbg(( DEBUG_MISC, "SetupPath = %ws\n", pMachineInfo->SetupPath ));
        }
        ldap_value_free( FilePath );
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"netbootMachineFilePath" );
    
    if ( FilePath ) {
        PWCHAR psz = StrChr( *FilePath, L'\\' );
        if ( psz ) {
            *psz = L'\0';   // terminate
        }

        if (pMachineInfo->dwFlags & MI_HOSTNAME_ALLOC) {
            BinlFreeMemory( pMachineInfo->HostName );
            pMachineInfo->dwFlags &= ~MI_HOSTNAME_ALLOC;
        }
        pMachineInfo->HostName = BinlStrDup( *FilePath );
        if (pMachineInfo->HostName) {
            BinlPrint(( DEBUG_MISC, "HostName = %ws\n", pMachineInfo->HostName ));
            pMachineInfo->dwFlags |= MI_HOSTNAME | MI_HOSTNAME_ALLOC;
        }

        if ( psz ) {

            *psz = L'\\';       // let's put it back to what it started as.
            psz++;

            if (pMachineInfo->dwFlags & MI_BOOTFILENAME_ALLOC) {
                BinlFreeMemory( pMachineInfo->BootFileName );
                pMachineInfo->dwFlags &= ~MI_BOOTFILENAME_ALLOC;
            }
            pMachineInfo->BootFileName = BinlStrDup( psz );
            if ( pMachineInfo->BootFileName ) {
                pMachineInfo->dwFlags |= MI_BOOTFILENAME | MI_BOOTFILENAME_ALLOC;
                BinlPrintDbg(( DEBUG_MISC, "BootFileName = %ws\n", pMachineInfo->BootFileName ));
            }
        }
        ldap_value_free( FilePath );
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"netbootSIFFile" );
    
    if ( FilePath ) {

        if (pMachineInfo->dwFlags & MI_SIFFILENAME_ALLOC) {
            BinlFreeMemory( pMachineInfo->ForcedSifFileName );
            pMachineInfo->dwFlags &= ~MI_SIFFILENAME_ALLOC;
        }
        pMachineInfo->ForcedSifFileName = BinlStrDup( *FilePath );
        if ( pMachineInfo->ForcedSifFileName ) {
            pMachineInfo->dwFlags |= MI_SIFFILENAME_ALLOC;
            BinlPrintDbg(( DEBUG_MISC, "ForcedSifFileName = %ws\n", pMachineInfo->ForcedSifFileName ));
        }
        ldap_value_free( FilePath );
    }

    if ( !(pMachineInfo->dwFlags & MI_HOSTNAME )
        || ( !pMachineInfo->HostName )
        || ( pMachineInfo->HostName[0] == L'\0') ) {

        if ( pMachineInfo->dwFlags & MI_HOSTNAME_ALLOC ) {
            BinlFreeMemory( pMachineInfo->HostName );
            pMachineInfo->dwFlags &= ~MI_HOSTNAME_ALLOC;
            pMachineInfo->HostName = NULL;
        }
        dwErr = BinlGenerateNewEntry( MI_HOSTNAME, SystemArchitecture, &pMachineInfo );
        if ( dwErr != ERROR_SUCCESS ) {
            goto e1;
        }
    }

    if ( !(pMachineInfo->dwFlags & MI_BOOTFILENAME)
         || ( !pMachineInfo->BootFileName )
         || ( pMachineInfo->BootFileName[0] == L'\0') ) {

        if (pMachineInfo->dwFlags & MI_BOOTFILENAME_ALLOC) {
            BinlFreeMemory( pMachineInfo->BootFileName );
            pMachineInfo->BootFileName = NULL;
            pMachineInfo->dwFlags &= ~MI_BOOTFILENAME_ALLOC;
        }
        dwErr = BinlGenerateNewEntry( MI_BOOTFILENAME, SystemArchitecture, &pMachineInfo );
        if ( dwErr != ERROR_SUCCESS ) {
            goto e1;
        }
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"sAMAccountName" );

    if ( FilePath ) {

        if (pMachineInfo->dwFlags & MI_SAMNAME_ALLOC) {
            BinlFreeMemory( pMachineInfo->SamName );
            pMachineInfo->dwFlags &= ~MI_SAMNAME_ALLOC;
        }

        pMachineInfo->SamName = BinlStrDup( *FilePath );
        if ( pMachineInfo->SamName ) {

            pMachineInfo->dwFlags |= MI_SAMNAME | MI_SAMNAME_ALLOC;
            BinlPrint(( DEBUG_MISC, "SamName = %ws\n", pMachineInfo->SamName ));
        }

        //
        //  For now, the pMachineInfo Name and SamName are the same values,
        //  therefore we won't look them up twice in the ldap message.
        //
#if 0
        ldap_value_free( FilePath );
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"sAMAccountName" );

    if ( FilePath ) {
#endif
        if ( pMachineInfo->dwFlags & MI_NAME_ALLOC ) {
            BinlFreeMemory( pMachineInfo->Name );
            pMachineInfo->dwFlags &= ~MI_NAME_ALLOC;
        }

        pMachineInfo->Name = BinlStrDup( *FilePath );
        if ( pMachineInfo->Name ) {
            if( pMachineInfo->Name[ wcslen(pMachineInfo->Name) - 1 ] == L'$' ) {
                pMachineInfo->Name[ wcslen(pMachineInfo->Name) - 1 ] = L'\0'; // remove '$'
            }
            pMachineInfo->dwFlags |= MI_NAME | MI_NAME_ALLOC;
            BinlPrint(( DEBUG_MISC, "Name = %ws\n", pMachineInfo->Name ));
        }
        ldap_value_free( FilePath );
    }

    FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"dnsHostName" );

    if ( FilePath ) {

        BOOL   fEndofString = FALSE;
        PWCHAR psz = *FilePath;

        // skip host name, we get that from the samName
        while ( *psz && *psz!=L'.' )
            psz++;
        if ( !(*psz) ) {
            fEndofString = TRUE;
        }
        *psz = L'\0'; // terminate

        if ( fEndofString == FALSE ) {
            psz++;

            if (pMachineInfo->Domain) {
                BinlFreeMemory( pMachineInfo->Domain );
            }

            pMachineInfo->Domain = BinlStrDup( psz );
            if ( pMachineInfo->Domain )
            {
                pMachineInfo->dwFlags |= MI_DOMAIN;
                BinlPrint(( DEBUG_MISC, "Domain = %ws\n", pMachineInfo->Domain ));
            }
        }
    }

    //
    // track duplicates that we get back
    //
    //  first we free all duplicates we have already allocated.
    //

    while (!IsListEmpty(&pMachineInfo->DNsWithSameGuid)) {

        PLIST_ENTRY p = RemoveHeadList(&pMachineInfo->DNsWithSameGuid);

        dupDN = CONTAINING_RECORD(p, DUP_GUID_DN, ListEntry);
        BinlFreeMemory( dupDN );
    }

    while (--entryCount > 0) {

        CurrentEntry = ldap_next_entry( LdapHandle, CurrentEntry );

        if (CurrentEntry == NULL) {
            break;
        }

        FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"dnsHostName" );
        if (!FilePath) {
            FilePath = ldap_get_values( LdapHandle, CurrentEntry, L"sAMAccountName");
        }

        if ( FilePath ) {

            ULONG dupLength, dupLength2;

            BinlPrint(( DEBUG_OSC, "Found duplicate DN in %ws\n", *FilePath ));

            FilePath2 = ldap_get_values( LdapHandle, CurrentEntry, L"distinguishedName");

            dupLength = lstrlenW( *FilePath ) + 1;
            if (FilePath2) {
                dupLength2 = lstrlenW( *FilePath2 ) + 1;
            } else {
                dupLength2 = 1;
            }

            dupDN = BinlAllocateMemory( FIELD_OFFSET(DUP_GUID_DN, DuplicateName[0]) +
                        ( (dupLength + dupLength2) * sizeof(WCHAR) ) );
            if ( dupDN ) {

                dupDN->DuplicateDNOffset = dupLength;
                lstrcpyW( &dupDN->DuplicateName[0], *FilePath );
                if (FilePath2) {
                    lstrcpyW( &dupDN->DuplicateName[dupLength], *FilePath2 );
                } else {
                    dupDN->DuplicateName[dupLength] = L'\0';
                }

                //
                // if the last character is a $, then slam in a NULL to end it.
                //

                if (( dupLength > 1 ) &&
                    ( dupDN->DuplicateName[dupLength-2] == L'$' )) {

                    dupDN->DuplicateName[dupLength-2] = L'\0';
                }

                InsertTailList( &pMachineInfo->DNsWithSameGuid, &dupDN->ListEntry );
            }
            ldap_value_free( FilePath );
            if (FilePath2) {
                ldap_value_free( FilePath2 );
            }
        }
    }

e1:
    ldap_msgfree( LdapMessage );
e0:
    return dwErr;
}

DWORD
InitializeConnection(
    BOOL Global,
    PLDAP * LdapHandle,
    PWCHAR ** Base )
/*++

Routine Description:

    Initialize the ldap connection for operating on either the domain or the
    global catalog.

Arguments:

    Global - TRUE if GC should be used

    LdapHandle - Returns the handle for further operations

    OperationalAttributeLdapMessage - Returns message containing Base so that it can be freed later

    Base - DN of where to start searches for computer objects.

Return Value:

    ldap error

--*/
{
    PLDAPMessage OperationalAttributeLdapMessage;
    PWCHAR Attrs[2];
    PLDAPMessage CurrentEntry;
    PWCHAR *LdapValue;
    DWORD LdapError = ERROR_SUCCESS;
    PLDAP *LdapHandleCurrent;
    PWCHAR ** LdapBaseCurrent;
    ULONG temp;

    TraceFunc( "InitializeConnection( )\n" );

    //  Use critical section to avoid two threads initialising the same parameters
    EnterCriticalSection(&gcsDHCPBINL);

    if ( !Global ) {

        LdapHandleCurrent = &DCLdapHandle;
        LdapBaseCurrent = &DCBase;

    } else {

        LdapHandleCurrent = &GCLdapHandle;
        LdapBaseCurrent = &GCBase;
    }

    if ( !(*LdapHandleCurrent) ) {
        if (Global) {

            *LdapHandleCurrent = ldap_initW( BinlGlobalDefaultGC, LDAP_GC_PORT);

            temp = DS_DIRECTORY_SERVICE_REQUIRED |
                    DS_IP_REQUIRED |
                    DS_GC_SERVER_REQUIRED;
        } else {

            *LdapHandleCurrent = ldap_init( BinlGlobalDefaultDS, LDAP_PORT);

            temp = DS_DIRECTORY_SERVICE_REQUIRED |
                    DS_IP_REQUIRED;
        }

        if (!*LdapHandleCurrent) {
            BinlPrint(( DEBUG_ERRORS, "Failed to initialize LDAP connection.\n" ));
            LdapError = LDAP_CONNECT_ERROR;
            LogLdapError( (Global ? EVENT_WARNING_LDAP_INIT_ERROR_GC :
                                    EVENT_WARNING_LDAP_INIT_ERROR_DC),
                            GetLastError(),
                            NULL
                            );
            goto e0;
        }

        ldap_set_option(*LdapHandleCurrent, LDAP_OPT_GETDSNAME_FLAGS, &temp );

        if (Global == FALSE) {

            temp = BinlLdapOptReferrals;
            ldap_set_option(*LdapHandleCurrent, LDAP_OPT_REFERRALS, (void *) &temp );

        } else {

            //
            //  At some future time, the GC is going to return referrals to
            //  authoritative DCs when the GC doesn't contain all the
            //  attributes.  We'll enable referrals so that it "just works".
            //

            temp = (ULONG)((ULONG_PTR)LDAP_OPT_ON);
            ldap_set_option(*LdapHandleCurrent, LDAP_OPT_REFERRALS, (void *) &temp );
        }

        temp = LDAP_VERSION3;
        ldap_set_option(*LdapHandleCurrent, LDAP_OPT_VERSION, &temp );

        LdapError = ldap_connect(*LdapHandleCurrent,0);

        if (LdapError != LDAP_SUCCESS) {
            LogLdapError( (Global ? EVENT_WARNING_LDAP_INIT_ERROR_GC :
                                    EVENT_WARNING_LDAP_INIT_ERROR_DC),
                          LdapError,
                          *LdapHandleCurrent
                          );
            BinlPrint(( DEBUG_ERRORS, "ldap_connect failed: %lx\n", LdapError ));
            goto e1;
        }

        LdapError = ldap_bind_s(*LdapHandleCurrent, NULL, NULL, LDAP_AUTH_SSPI);

        if (LdapError != LDAP_SUCCESS) {
            BinlPrint(( DEBUG_ERRORS, "ldap_bind_s failed: %lx\n", LdapError ));
            LogLdapError(   EVENT_WARNING_LDAP_BIND_ERROR,
                            LdapError,
                            *LdapHandleCurrent
                            );
            goto e1;
        }
    }

    //
    //  Connected to Directory Service. Find out where in the DS we
    //  should start looking for the computer.
    //
    if ( !(*LdapBaseCurrent) )
    {
        DWORD count;
        Attrs[0] = &L"defaultNamingContext";
        Attrs[1] = NULL;

        LdapError = ldap_search_ext_s(*LdapHandleCurrent,
                                      NULL, // base
                                      LDAP_SCOPE_BASE,
                                      L"objectClass=*",// filter
                                      Attrs,
                                      FALSE,
                                      NULL,
                                      NULL,
                                      &BinlLdapSearchTimeout,
                                      0,
                                      &OperationalAttributeLdapMessage);

        if ( LdapError != LDAP_SUCCESS ) {
            BinlPrint(( DEBUG_ERRORS, "ldap_search_ext_s failed: %x\n", LdapError ));

            HandleLdapFailure(  LdapError,
                                EVENT_WARNING_LDAP_SEARCH_ERROR,
                                Global,
                                LdapHandleCurrent,
                                TRUE );    // we have lock
            if (*LdapHandleCurrent == NULL) {
                goto e1;
            }
        }
        count = ldap_count_entries( *LdapHandleCurrent, OperationalAttributeLdapMessage );
        if ( count == 0 ) {
            BinlPrint(( DEBUG_ERRORS, "Failed to find the defaultNamingContext.\n" ));
            LdapError = LDAP_NO_RESULTS_RETURNED;
            LogLdapError(   EVENT_WARNING_LDAP_SEARCH_ERROR,
                            LdapError,
                            *LdapHandleCurrent
                            );
            goto e0;
        }

        //
        //  the DS should always only return us a single root DSE record.
        //  It would be completely broken if it returned more than one.
        //

        BinlAssert( count == 1 );

        CurrentEntry = ldap_first_entry( *LdapHandleCurrent, OperationalAttributeLdapMessage );

        LdapValue = ldap_get_values( *LdapHandleCurrent, CurrentEntry, Attrs[0] );

        if (LdapValue == NULL) {
            BinlPrint(( DEBUG_ERRORS, "Failed to find the defaultNamingContext.\n" ));
            LdapError = LDAP_NO_RESULTS_RETURNED;
            goto e2;
        }

        *LdapBaseCurrent = LdapValue;
e2:
        ldap_msgfree( OperationalAttributeLdapMessage );
    }

e0:
    if ( LdapHandle ) {
        *LdapHandle = *LdapHandleCurrent;
    }

    if ( Base ) {
        *Base = *LdapBaseCurrent;
    }

    LeaveCriticalSection(&gcsDHCPBINL);
    return LdapError;

e1:
    BinlPrint(( DEBUG_ERRORS, "Failed to connect to LDAP server.\n" ));
    if (*LdapHandleCurrent != NULL) {
        ldap_unbind(*LdapHandleCurrent);
        *LdapHandleCurrent = NULL;
    }
    goto e0;
}

VOID
HandleLdapFailure(
    DWORD LdapError,
    DWORD EventId,
    BOOL GlobalCatalog,
    PLDAP *LdapHandle,
    BOOL HaveLock
    )
//
//  This routine is called when one of our global handles (not per user handle)
//  comes back with a serious error.  We reset it to try again later.
//
{
    if ((LdapError == LDAP_UNAVAILABLE) ||
        (LdapError == LDAP_SERVER_DOWN) ||
        (LdapError == LDAP_CONNECT_ERROR) ||
        (LdapError == LDAP_TIMEOUT)) {

        PLDAP *LdapHandleCurrent;
        PWCHAR ** LdapBaseCurrent;

        if (!HaveLock) {
            EnterCriticalSection(&gcsDHCPBINL);
        }

        LdapHandleCurrent = GlobalCatalog ? &GCLdapHandle : &DCLdapHandle;
        LdapBaseCurrent = GlobalCatalog ? &GCBase : &DCBase;

        if (EventId) {
            LogLdapError(   EventId,
                            LdapError,
                            (LdapHandle != NULL ? *LdapHandle : *LdapHandleCurrent)
                            );
        }
        if (LdapHandle) {
            ASSERT( *LdapHandle == *LdapHandleCurrent );
            *LdapHandle = NULL;
        }

        FreeConnection( LdapHandleCurrent, LdapBaseCurrent );
        if (!HaveLock) {
            LeaveCriticalSection(&gcsDHCPBINL);
        }
    }
    return;
}

VOID
FreeConnection(
    PLDAP * LdapHandle,
    PWCHAR ** Base)
/*++

Routine Description:

    Free the ldap connection for operating on either the domain or the
    global catalog.

Arguments:

    LdapHandle - The handle for further operations

    Base - DN of where to start searches for computer objects to be freed.

Return Value:

    None.

--*/
{
    TraceFunc( "FreeConnection( )\n" );

    if (*LdapHandle) {
        ldap_unbind( *LdapHandle );
        *LdapHandle = NULL;
    }

    if (*Base) {
        ldap_value_free(*Base);
        *Base = NULL;
    }
}


VOID
FreeConnections
(
    VOID
    )
/*++

Routine Description:

     Terminate any LDAP requests because we are stopping immediately.  We
     wait until all threads are stopped because the threads may have pointers
     to the values we're going to free.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  clear out the cache, wait until all are marked as not being
    //  processed.  We do this because the threads have pointers to DCBase,
    //  GCBase, etc and if we just blow them away, they may AV.
    //

    BinlCloseCache();

    TraceFunc( "FreeConnections( )\n" );

    FreeConnection( &DCLdapHandle, &DCBase);
    FreeConnection( &GCLdapHandle, &GCBase);
}


DWORD
FindSCPForBinlServer(
    PWCHAR * ResultPath,
    PWCHAR * MachinePath,
    BOOL GlobalSearch)
/*++

Routine Description:

    Use the Directory Service to lookup the settings for this service.

Arguments:

    GlobalSearch - TRUE if GC should be used

Return Value:

    ERROR_SUCCESS or BINL_CANT_FIND_SERVER_MAO or ERROR_OUTOFMEMORY

--*/
{
    DWORD Error;
    PLDAP LdapHandle;
    DWORD LdapError;
    DWORD count;
    ULONG ldapRetryLimit = 0;

    PWCHAR * DsPath;
    PLDAPMessage CurrentEntry;
    PLDAPMessage LdapMessage = NULL;

    PWCHAR ServerDN = NULL;
    BOOL retryDN = TRUE;

    //  Paramters we want from the Computer Object
    PWCHAR ComputerAttrs[2];
    ComputerAttrs[0] = &L"netbootSCPBL";
    ComputerAttrs[1] = NULL;

    TraceFunc( "FindSCPForBinlServer( )\n" );

RetryGetDN:
    EnterCriticalSection( &gcsParameters );

    if (BinlGlobalOurFQDNName == NULL) {

        LeaveCriticalSection( &gcsParameters );
        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        BinlPrintDbg((DEBUG_ERRORS, "!! Error 0x%08x we don't have a FQDN for ourselves.\n", Error ));
        goto e0;
    }

    ServerDN = (PWCHAR) BinlAllocateMemory( (wcslen( BinlGlobalOurFQDNName ) + 1) * sizeof(WCHAR) );
    if ( !ServerDN ) {
        LeaveCriticalSection( &gcsParameters );
        Error = E_OUTOFMEMORY;
        goto e0;
    }

    // It should be something like this:
    // ServerDN = "cn=server,cn=computers,dc=microsoft,dc=com"

    lstrcpyW( ServerDN, BinlGlobalOurFQDNName );
    LeaveCriticalSection( &gcsParameters );

    Error = InitializeConnection(GlobalSearch, &LdapHandle, NULL);
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg(( DEBUG_ERRORS, "!!Error 0x%08x - Ldap Connection Failed.\n", Error ));
        SetLastError( Error );
        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e0;
    }
RetrySearch:
    LdapError = ldap_search_ext_s(LdapHandle,
                                  ServerDN,
                                  LDAP_SCOPE_BASE,
                                  L"objectClass=*",
                                  ComputerAttrs,
                                  FALSE,
                                  NULL,
                                  NULL,
                                  &BinlLdapSearchTimeout,
                                  0,
                                  &LdapMessage);

    //
    //  if the object isn't found, then something is amiss.. go grab the DN
    //  again.
    //

    if ((LdapError == LDAP_NO_SUCH_OBJECT) && retryDN) {

        retryDN = FALSE;

        // if we didn't find an entry or it was busy, retry
        (VOID) GetOurServerInfo();

        BinlFreeMemory( ServerDN );
        ServerDN = NULL;
        goto RetryGetDN;
    }

    if (((LdapError == LDAP_BUSY) || (LdapError == LDAP_NO_SUCH_OBJECT)) &&
         (++ldapRetryLimit < LDAP_BUSY_LIMIT)) {

        Sleep( LDAP_BUSY_DELAY );
        goto RetrySearch;
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );
    if (count == 0) {

        if (LdapError == LDAP_SUCCESS) {
            LdapError = LDAP_TIMELIMIT_EXCEEDED;
        }

        BinlPrintDbg(( DEBUG_ERRORS, "!!LdapError 0x%08x - LDAP search failed... will retry later.\n", LdapError ));

        BinlReportEventW( EVENT_ERROR_LOCATING_SCP,
                          EVENTLOG_ERROR_TYPE,
                          0,
                          sizeof(LdapError),
                          NULL,
                          &LdapError
                          );

        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e1;
    }
    BinlAssertMsg( count == 1, "Count should have been 1." );
    if ( count != 1 ) {
        BinlPrintDbg(( DEBUG_ERRORS, "!!Error - LDAP search returned more than one SCP record for us.\n" ));

        BinlReportEventW( BINL_DUPLICATE_MAO_RECORD,
                          EVENTLOG_ERROR_TYPE,
                          0,
                          sizeof(count),
                          NULL,
                          &count
                          );

        Error = ERROR_BINL_CANT_FIND_SERVER_MAO;
        goto e1;
    }

    //
    // Get the SCP
    //
    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    DsPath = ldap_get_values( LdapHandle, CurrentEntry, L"netbootSCPBL" );
    if ( !DsPath ) {
        BinlPrintDbg(( DEBUG_ERRORS, "!!Error - Could not get 'netbootSCPBL' from the server's MAO\n" ))
        Error = ERROR_BINL_CANT_FIND_SERVER_MAO;
        goto e1;
    }

    *ResultPath = (PWCHAR) BinlAllocateMemory( (wcslen(*DsPath) + 1) * sizeof(WCHAR) );
    if ( *ResultPath == NULL ) {
        BinlPrintDbg(( DEBUG_ERRORS, "!!Error - Out of memory.\n" ));
        Error = ERROR_OUTOFMEMORY;
        goto e2;
    }

    wcscpy( *ResultPath, *DsPath );

    *MachinePath = ServerDN;
    ServerDN = NULL; // prevent freeing

    Error = ERROR_SUCCESS;

e2:
    ldap_value_free(DsPath);

e1:
    ldap_msgfree( LdapMessage );

e0:
    if ( ServerDN )
        BinlFreeMemory( ServerDN );

    return Error;
}

DWORD
UpdateSettingsUsingResults(
    PLDAP        LdapHandle,
    PLDAPMessage LdapMessage,
    LPWSTR       ComputerAttrs[],
    PDWORD       NumberOfAttributesFound OPTIONAL
    )
{
    PLDAPMessage CurrentEntry;
    DWORD        LdapError = LDAP_SUCCESS;
    DWORD        count;
    DWORD        countFound = 0;

    TraceFunc( "UpdateSettingsUsingResults( ... )\n" );

    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    for ( count = 0; ComputerAttrs[count] != NULL; count++ ) {

        PWCHAR * Attribute;

        Attribute = ldap_get_values( LdapHandle, CurrentEntry, ComputerAttrs[count] );

        if (Attribute == NULL) {
#if DBG
            CHAR Temp[MAX_PATH];
            wcstombs( Temp, ComputerAttrs[count], wcslen(ComputerAttrs[count]) + 1 );
            BinlPrintDbg(( DEBUG_OPTIONS, "Did not find attribute '%s'... skipping\n", Temp ));
#endif

            if (count != 1) { // NewMachineOU

                continue; // skip and use default
            }

        } else {

            //
            // Increment the count of attributes found.
            //

            countFound++;
        }

        switch( count )
        {
        case 0: // NewMachineNamingPolicy
            {
                DWORD Length = wcslen( *Attribute ) + 1;
                PWCHAR psz = (PWCHAR) BinlAllocateMemory( Length * sizeof(WCHAR) );
                BinlAssert( StrCmp( ComputerAttrs[0], L"netbootNewMachineNamingPolicy" ) == 0 );
                if ( psz )
                {
                    wcscpy( psz, *Attribute );

                    EnterCriticalSection(&gcsParameters);

                    if ( NewMachineNamingPolicy != NULL )
                    {
                        BinlFreeMemory( NewMachineNamingPolicy );
                    }
                    NewMachineNamingPolicy = psz;

                    LeaveCriticalSection(&gcsParameters);
                }
                BinlPrint(( DEBUG_OPTIONS, "NewMachineNamingPolicy = '%ws'\n", NewMachineNamingPolicy ));
            }
            break;

        case 1: // NewMachineOU
            {
                LPWSTR psz;
                DWORD Length;
                BOOL getServerInfo;

                BinlAssert( StrCmp( ComputerAttrs[1], L"netbootNewMachineOU" ) == 0 );

                if (Attribute == NULL || *Attribute == NULL) {

                    Length = 1;

                } else {

                    Length = wcslen( *Attribute ) + 1;
                }

                psz = (LPWSTR) BinlAllocateMemory( Length * sizeof(WCHAR) );

                if (psz == NULL) {
                    LdapError = LDAP_NO_MEMORY;
                    break;
                }
                if (Length == 1) {

                    *psz = L'\0';

                } else {

                    wcscpy( psz, *Attribute );
                }

                EnterCriticalSection(&gcsParameters);

                getServerInfo = (BOOL)( (BinlGlobalDefaultContainer == NULL) ||
                                        (StrCmp(BinlGlobalDefaultContainer, psz) != 0) );

                if ( BinlGlobalDefaultContainer != NULL )
                {
                    BinlFreeMemory( BinlGlobalDefaultContainer );
                }
                BinlGlobalDefaultContainer = psz;

                LeaveCriticalSection(&gcsParameters);

                if ( getServerInfo ) {

                    ULONG Error = GetOurServerInfo();
                    if (Error != ERROR_SUCCESS) {

                        BinlPrintDbg(( DEBUG_ERRORS, "GetOurServerInfo returned 0x%x, we had a new default container.\n", Error ));
                    }
                }

                BinlPrint(( DEBUG_OPTIONS, "DefaultContainer = %ws\n", BinlGlobalDefaultContainer ));
            }
            break;

        case 2: // MaxClients
            {
                CHAR Temp[10];
                BinlAssert( StrCmp( ComputerAttrs[2], L"netbootMaxClients" ) == 0 );
                wcstombs( Temp, *Attribute, wcslen( *Attribute ) + 1 );
                BinlMaxClients = atoi( Temp );
                BinlPrint(( DEBUG_OPTIONS, "BinlMaxClients = %u\n", BinlMaxClients ));
            }
            break;

        case 3: // CurrentClientCount
            {
                CHAR Temp[10];
                BinlAssert( StrCmp( ComputerAttrs[3], L"netbootCurrentClientCount" ) == 0 );
                wcstombs( Temp, *Attribute, wcslen( *Attribute ) + 1 );
                CurrentClientCount = atoi( Temp );
                BinlPrint(( DEBUG_OPTIONS, "(Last) CurrentClientCount = %u\n", CurrentClientCount ));
            }
            break;

        case 4: // AnswerRequest
            BinlAssert( StrCmp ( ComputerAttrs[4], L"netbootAnswerRequests" ) == 0 );
            if ( wcscmp( *Attribute, L"TRUE" ) == 0 )
            {
                AnswerRequests = TRUE;
            }
            else
            {
                AnswerRequests = FALSE;
            }
            BinlPrint(( DEBUG_OPTIONS, "AnswerRequests = %s\n", BOOLTOSTRING( AnswerRequests ) ));
            break;

        case 5: // AnswerOnlyValidClients
            BinlAssert( StrCmp( ComputerAttrs[5], L"netbootAnswerOnlyValidClients" ) == 0 );
            if ( wcscmp( *Attribute, L"TRUE" ) == 0 ) {
                AnswerOnlyValidClients = TRUE;
            } else {
                AnswerOnlyValidClients = FALSE;
            }
            BinlPrint(( DEBUG_OPTIONS, "AnswerOnlyValidClients = %s\n", BOOLTOSTRING( AnswerOnlyValidClients ) ));
            break;

        case 6: // AllowNewClients
            BinlAssert( StrCmp( ComputerAttrs[6], L"netbootAllowNewClients" ) == 0 );
            if ( wcscmp( *Attribute, L"TRUE" ) == 0 )
            {
                AllowNewClients = TRUE;
            }
            else
            {
                AllowNewClients = FALSE;
            }
            BinlPrint(( DEBUG_OPTIONS, "AllowNewClients = %s\n", BOOLTOSTRING( AllowNewClients ) ));
            break;

        case 7: // LimitClients
            BinlAssert( StrCmp( ComputerAttrs[7], L"netbootLimitClients" ) == 0 );
            if ( wcscmp( *Attribute, L"TRUE" ) == 0 )
            {
                LimitClients = TRUE;
            }
            else
            {
                LimitClients = FALSE;
            }
            BinlPrint(( DEBUG_OPTIONS, "LimitClients = %s\n", BOOLTOSTRING( LimitClients ) ));
            break;

        case 8:  // IntellimirrorOSes
        case 9:  // Tools
        case 10: // LocalInstallOSes
            BinlAssert( StrCmp( ComputerAttrs[8],  L"netbootIntellimirrorOSes" ) == 0 );
            BinlAssert( StrCmp( ComputerAttrs[9],  L"netbootTools" ) == 0 );
            BinlAssert( StrCmp( ComputerAttrs[10], L"netbootLocalInstallOSes" ) == 0 );
            //
            // TODO: Tie these in with OS Chooser - this is still TBD.
            //
            break;

        default:
            // Somethings wrong
            BinlAssert( 0 );
        }

        if (Attribute != NULL) {
            ldap_value_free(Attribute);
        }
    }

    if ( ARGUMENT_PRESENT(NumberOfAttributesFound) ) {
        *NumberOfAttributesFound = countFound;
    }

    return LdapError;
}


DWORD
GetBinlServerParameters(
    BOOL GlobalSearch)
/*++

Routine Description:

    Use the Directory Service to lookup the settings for this service.

Arguments:

    GlobalSearch - TRUE if GC should be used

Return Value:

    ERROR_SUCCESS or BINL_CANT_FIND_SERVER_MAO

--*/
{
    DWORD Error;
    PLDAP LdapHandle;
    DWORD LdapError;
    DWORD count;
    ULONG ldapRetryLimit = 0;

    PLDAPMessage LdapMessage;

    //  Paramters we want from the IntelliMirror-SCP
    //  NOTE: These must be the same ordinals as those used in
    //  UpdateSettingsUsingResults( ).
    PWCHAR ComputerAttrs[12];
    ComputerAttrs[0]  = &L"netbootNewMachineNamingPolicy";
    ComputerAttrs[1]  = &L"netbootNewMachineOU";
    ComputerAttrs[2]  = &L"netbootMaxClients";
    ComputerAttrs[3]  = &L"netbootCurrentClientCount";
    ComputerAttrs[4]  = &L"netbootAnswerRequests";
    ComputerAttrs[5]  = &L"netbootAnswerOnlyValidClients";
    ComputerAttrs[6]  = &L"netbootAllowNewClients";
    ComputerAttrs[7]  = &L"netbootLimitClients";
    ComputerAttrs[8]  = &L"netbootIntellimirrorOSes";
    ComputerAttrs[9]  = &L"netbootTools";
    ComputerAttrs[10] = &L"netbootLocalInstallOSes";
    ComputerAttrs[11] = NULL;

    TraceFunc( "GetBinlServerParameters( )\n" );

    Error = FindSCPForBinlServer( &BinlGlobalSCPPath, &BinlGlobalServerDN, GlobalSearch );
    if ( Error != ERROR_SUCCESS ) {
        BinlPrint(( DEBUG_ERRORS, "!!Error 0x%08x - SCP not found. Default settings being used.\n", Error ));
        goto e0;
    }

    BinlPrint(( DEBUG_OPTIONS, "ServerDN = '%ws'\n", BinlGlobalServerDN ));
    BinlPrint(( DEBUG_OPTIONS, "SCPDN    = '%ws'\n", BinlGlobalSCPPath ));

RetryConnection:
    Error = InitializeConnection( GlobalSearch, &LdapHandle, NULL );
    if ( Error != ERROR_SUCCESS ) {
        SetLastError( Error );
        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e0;
    }

Retry:
    LdapError = ldap_search_ext_s(LdapHandle,
                                  BinlGlobalSCPPath,
                                  LDAP_SCOPE_BASE,
                                  L"objectClass=*",
                                  ComputerAttrs,
                                  FALSE,
                                  NULL,
                                  NULL,
                                  NULL,
                                  0,
                                  &LdapMessage);

    if ((LdapError == LDAP_BUSY) && (++ldapRetryLimit < LDAP_BUSY_LIMIT)) {
        Sleep( LDAP_BUSY_DELAY );
        goto Retry;
    }

    if (LdapError != LDAP_SUCCESS) {
        HandleLdapFailure(  LdapError,
                            EVENT_WARNING_LDAP_SEARCH_ERROR,
                            GlobalSearch,
                            &LdapHandle,
                            FALSE );    // don't have lock
        if (LdapHandle == NULL) {
            if (++ldapRetryLimit < LDAP_SERVER_DOWN_LIMIT) {
                goto RetryConnection;
            }
            goto e0;
        }
    }

    count = ldap_count_entries( LdapHandle, LdapMessage );
    if (count == 0) {

        if (LdapError == LDAP_SUCCESS) {
            LdapError = LDAP_TIMELIMIT_EXCEEDED;
        }
        BinlPrintDbg(( DEBUG_ERRORS, "!!LdapError 0x%08x - Failed to retrieve parameters... will retry later.\n", LdapError ));

        BinlReportEventW( EVENT_ERROR_LOCATING_SCP,
                          EVENTLOG_ERROR_TYPE,
                          0,
                          sizeof(LdapError),
                          NULL,
                          &LdapError
                          );

        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e1;
    }

    BinlAssertMsg( count == 1, "Count should have been one. Is the SCP missing?" );

    //  We did a base level search, we better only have gotten one record back.
    BinlAssert( count == 1 );

    // Retrieve the results into the settings
    LdapError = UpdateSettingsUsingResults( LdapHandle, LdapMessage, ComputerAttrs, &count );
    if ( LdapError == LDAP_SUCCESS )
    {
        BinlReportEventW( count != 0 ? EVENT_SCP_READ_SUCCESSFULLY :
                                       EVENT_SCP_READ_SUCCESSFULLY_EMPTY,
                          count != 0 ? EVENTLOG_INFORMATION_TYPE :
                                       EVENTLOG_WARNING_TYPE,
                          0,
                          0,
                          NULL,
                          NULL
                          );
    }

e1:
    ldap_msgfree( LdapMessage );

e0:
    return Error;
}

VOID
BinlLogDuplicateDsRecords (
    LPGUID Guid,
    LDAP *LdapHandle,
    LDAPMessage *LdapMessage,
    LDAPMessage *CurrentEntry
    )
//
//  Log an error that we've received duplicate records for a client when
//  we looked them up by GUID.
//
//  We log the DNs so that the administrator can look them up.
//
{
    LPWSTR strings[4];
    LPWSTR dn1;
    LPWSTR dn2;
    ULONG strCount = 0;     // up to two strings to log
    PLDAPMessage nextEntry =  ldap_next_entry( LdapHandle, LdapMessage );
    LPWSTR  GuidString;

    if (SUCCEEDED(StringFromIID( (REFIID)Guid, &GuidString ))) {
        strCount += 1;
    }

    dn1 = ldap_get_dnW( LdapHandle, CurrentEntry );

    if (nextEntry != NULL) {

        dn2 = ldap_get_dnW( LdapHandle, nextEntry );

    } else {

        dn2 = NULL;
    }

    if (dn2 != NULL) {
        if (dn1 == NULL) {
            dn1 = dn2;
            dn2 = NULL;
        } else {
            strCount += 1;
        }
    }

    if (dn1 != NULL) {
        strCount += 1;
    }    
        

    BinlPrint(( DEBUG_ERRORS, "Warning - BINL received multiple records for a single GUID.\n" ));

    strings[0] = GuidString;
    strings[1] = dn1;
    strings[2] = dn2;
    strings[3] = NULL;
    
    BinlReportEventW( BINL_DUPLICATE_DS_RECORD,
                      EVENTLOG_WARNING_TYPE,
                      strCount,
                      0,
                      strings,
                      NULL
                      );

    ldap_memfree( dn1 );            // it's ok to call ldap_memfree with null
    ldap_memfree( dn2 );

    CoTaskMemFree( GuidString );
}

#ifndef DSCRACKNAMES_DNS
DWORD
BinlDNStoFQDN(
    PWCHAR   pMachineDNS,
    PWCHAR * ppMachineDN )
{
    DWORD Error;
    DWORD LdapError;
    WCHAR FilterTemplate[] = L"dnsHostName=%ws";
    PWCHAR Filter = NULL;
    PWCHAR ComputerAttrs[2];
    PLDAPMessage CurrentEntry;
    PLDAPMessage LdapMessage;
    LDAP *LdapHandle;
    PWCHAR * Base;
    PWCHAR * MachineDN;
    DWORD count;
    DWORD uSize;
    ULONG ldapRetryLimit = 0;

    TraceFunc( "BinlDNStoFQDN( )\n" );

    BinlAssert( ppMachineDN );
    BinlAssert( pMachineDNS );

    ComputerAttrs[0] = &L"distinguishedName";
    ComputerAttrs[1] = NULL;

    //  Build the filter to find the Computer object
    uSize = sizeof(FilterTemplate)  // include NULL terminater
          + (wcslen( pMachineDNS ) * sizeof(WCHAR));
    Filter = (LPWSTR) BinlAllocateMemory( uSize );
    if ( !Filter ) {
        Error = E_OUTOFMEMORY;
        goto e0;
    }
    wsprintf( Filter, FilterTemplate, pMachineDNS );
    BinlPrintDbg(( DEBUG_MISC, "Searching for %ws...\n", Filter ));

RetryConnection:
    Error = InitializeConnection( FALSE, &LdapHandle, &Base );
    if ( Error != ERROR_SUCCESS ) {
        SetLastError( Error );
        Error = ERROR_BINL_INITIALIZE_LDAP_CONNECTION_FAILED;
        goto e0;
    }

Retry:
    LdapError = ldap_search_ext_s( LdapHandle,
                                   *Base,
                                   LDAP_SCOPE_SUBTREE,
                                   Filter,
                                   ComputerAttrs,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   NULL,
                                   0,
                                   &LdapMessage);
    switch (LdapError)
    {
    case LDAP_SUCCESS:
        break;

    case LDAP_BUSY:
        if (++ldapRetryLimit < LDAP_BUSY_LIMIT) {
            Sleep( LDAP_BUSY_DELAY );
            goto Retry;
        }

        // lack of break is on purpose.

    default:
        BinlPrintDbg(( DEBUG_ERRORS, "!!LdapError 0x%08x - Search failed in DNStoFQDN.\n", LdapError ));

        HandleLdapFailure(  LdapError,
                            EVENT_WARNING_LDAP_SEARCH_ERROR,
                            FALSE,
                            &LdapHandle,
                            FALSE );    // don't have lock
        if (LdapHandle == NULL) {
            if (++ldapRetryLimit < LDAP_SERVER_DOWN_LIMIT) {
                goto RetryConnection;
            }
        }
        if ( LdapMessage ) {
            goto e1;
        } else {
            goto e0;
        }
    }

    //  Did we get a Computer Object?
    count = ldap_count_entries( LdapHandle, LdapMessage );
    if ( count == 0 ) {
        Error = ERROR_BINL_UNABLE_TO_CONVERT;
        goto e1; // nope
    }

    // if we get more than more entry back, we will use only the
    // first one.
    CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

    MachineDN = ldap_get_values( LdapHandle, CurrentEntry, ComputerAttrs[0] );
    if ( !MachineDN ) {
        Error = ERROR_BINL_UNABLE_TO_CONVERT;
        goto e1;
    }

    *ppMachineDN = BinlStrDup( *MachineDN );

    Error = ERROR_SUCCESS;

    ldap_value_free( MachineDN );
e1:
    ldap_msgfree( LdapMessage );
e0:
    return Error;
}
#endif // DSCRACKNAMES_DNS

// message.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\netinf.c ===
/*
Module Name:

    netinfp.c

Abstract:

    This module implements our routines to parse net card INF files.

Author:

    Andy Herron Mar 12 1998

Revision History:

*/

#include "binl.h"
#pragma hdrstop

#include "netinfp.h"

//  for verbose output, define the following
//#define NET_INF_VERBOSE 1

ULONG
NetInfAllocateNetcardInfo (
    PWCHAR InfPath,
    ULONG Architecture,
    PNETCARD_INF_BLOCK *pNetCards
    )
/*++

Routine Description:

    This function is allocates the block that contains all the relavent info
    related to a given setup directory's INF files.


Arguments:

    InfPath - path to INF directory.  default is %systemroot%\inf if NULL.

    pNetCards - A pointer to a pointer that receives the allocated
        NETCARD_INF_BLOCK block allocated.  NULL if we return an error.

Return Value:

    Windows Error.

--*/
{
    ULONG i;
    PNETCARD_INF_BLOCK pBlock;

    *pNetCards = BinlAllocateMemory( sizeof( NETCARD_INF_BLOCK ) +
                                     lstrlenW( InfPath ) * sizeof(WCHAR) );

    if (*pNetCards == NULL) {

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset( (PCHAR) *pNetCards, '\0', sizeof( NETCARD_RESPONSE_DATABASE ) );

    pBlock = *pNetCards;

    pBlock->ReferenceCount = 2; // one for being alive.  one for referenced

    for (i = 0; i < NETCARD_HASH_TABLE_SIZE; i++) {
        InitializeListHead( &pBlock->NetCardEntries[i] );
    }
    InitializeCriticalSection( &pBlock->Lock );
    lstrcpyW( &pBlock->InfDirectory[0], InfPath );
    pBlock->Architecture = Architecture;
    pBlock->FileListCallbackFunction = NULL;
    pBlock->InfBlockEntry.Flink = NULL;

    return ERROR_SUCCESS;
}

ULONG
GetNetCardList (
    PNETCARD_INF_BLOCK pNetCards
    )
/*++

Routine Description:

    We go through all the INF files on the server to pick out the net
    cards supported and the required reg fields to send to the client.

    This function uses the FindFirstFile and SetupOpenInfFile APIs to
    enumerate all the inf files and process all net card INFs.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

Return Value:

    Windows Error.

--*/
{
    ULONG err = ERROR_SUCCESS;
    HINF infHandle;
    WCHAR fileBuffer[ MAX_PATH ];
    HANDLE findHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW findData;
    PWCHAR endOfPath;

    //
    //  We would call SetupGetInfFileList here rather than FindFirstFile,
    //  but then we'd have to open all the INFs three times rather than
    //  once.  Once to figure out how much space the file name buffer requires,
    //  once to fill in the file name buffer, and once to do our own
    //  processing.
    //  We'll skip the first two passes since they're just a waste of time
    //  by calling FindFirstFile.
    //

    lstrcpyW( fileBuffer, pNetCards->InfDirectory );
    lstrcatW( fileBuffer, L"\\*.INF" );

    findHandle = FindFirstFileW( fileBuffer, &findData );

    if (findHandle == INVALID_HANDLE_VALUE) {

        //
        //  we're in trouble.  can't enumerate all the files.
        //

        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF,"FindFirstFile returned 0x%x\n", err ));
        goto exitGetCards;
    }

    lstrcpyW( fileBuffer, pNetCards->InfDirectory );
    lstrcatW( fileBuffer, L"\\" );

    endOfPath = fileBuffer + lstrlenW( fileBuffer );

    do {

        //
        // Skip directories
        //

        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            continue;
        }

        //
        //  try to be resiliant for ill formatted INF files.
        //

        try {

            lstrcpyW( endOfPath, findData.cFileName );

            infHandle = SetupOpenInfFileW( fileBuffer,
                                           L"NET",              // class of inf file
                                           INF_STYLE_WIN4 | INF_STYLE_CACHE_ENABLE,
                                           NULL );

            if (infHandle != INVALID_HANDLE_VALUE) {

                err = ProcessInfFile(   pNetCards,
                                        infHandle,
                                        findData.cFileName );

                SetupCloseInfFile( infHandle );

            } else {

                err = GetLastError();
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            //  log an error here that we trapped out on a bad INF
            //

            PWCHAR strings[3];

            strings[0] = pNetCards->InfDirectory;
            strings[1] = findData.cFileName;
            strings[2] = NULL;

            BinlReportEventW(   ERROR_BINL_ERR_IN_INF,
                                EVENTLOG_WARNING_TYPE,
                                2,
                                0,
                                strings,
                                NULL
                                );

        }
        if (err == ERROR_NOT_ENOUGH_MEMORY) {
            break;
        }

#ifdef NET_INF_VERBOSE
        if (err != ERROR_SUCCESS && err != ERROR_CLASS_MISMATCH) {
            BinlPrintDbg(( DEBUG_NETINF,"ProcessInfFile returned 0x%x for %S\n", err, fileBuffer ));
        }
#endif

        err = ERROR_SUCCESS;
    } while (FindNextFileW(findHandle,&findData));

exitGetCards:

    if (findHandle != INVALID_HANDLE_VALUE) {

        FindClose( findHandle );
    }

    return err;
}


ULONG
ProcessInfFile (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process a given INF file for
    all net card drivers.  Each INF file is first parsed for the MANUFACTURERS
    section.  This section contains all the section keys that contain all
    the devices.  We then enumerate all the devices in each manufacturer's
    section and call off to ParseCardDetails to add it to our list.

    As an example, the net557.inf file looks like this :

    [Manufacturer]
    %Intel%     = Intel
    %ATI%       = ATI
    %Compaq%    = Compaq
    %HPTX%      = HPTX
    %IBM%       = IBM
    %Microdyne% = Microdyne
    %Samsung%   = Samsung

    and the [ATI] section looks like this :

    [ATI]
    ; DisplayName            Section        DeviceID
    %AT2560B.DeviceDesc%   = AT2560B.ndi,   PCI\VEN_1259&DEV_2560&REV_01
    %AT2560C.DeviceDesc%   = AT2560C.ndi,   PCI\VEN_8086&DEV_1229&SUBSYS_25601259
    %AT2560CFX.DeviceDesc% = AT2560CFX.ndi, PCI\VEN_8086&DEV_1229&SUBSYS_25611259

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err = ERROR_SUCCESS;
    INFCONTEXT manufacturerEnumContext;
    INFCONTEXT deviceEnumContext;
    PWCHAR manufacturer = NULL;
    ULONG sizeRequired;
    ULONG sizeAllocated = 0;

    //
    //  We need to enumerate through the Manufacturer section first
    //

    if (SetupFindFirstLineW( InfHandle,
                             L"Manufacturer",
                             NULL,
                             &manufacturerEnumContext
                             ) == FALSE) {
        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF, "SetupFindFirstLine failed with 0x%x in %S for Manufacturer\n",
                 err, InfFileName ));

        //
        //  log an error here that we couldn't parse INF
        //

        {
            PWCHAR strings[3];
            strings[0] = InfFileName;
            strings[1] = L"Manufacturer";
            strings[2] = NULL;

            BinlReportEventW(   ERROR_BINL_ERR_IN_SECTION,
                                EVENTLOG_WARNING_TYPE,
                                2,
                                sizeof(ULONG),
                                strings,
                                &err
                                );
        }

        goto exitProcessInf;
    }

    while (1) {

        err = GetSetupLineWideText( &manufacturerEnumContext,
                                    NULL, NULL, NULL,
                                    &manufacturer,
                                    &sizeAllocated );

        if (err == ERROR_SUCCESS) {

            //
            //  we enumerate through each manufacturer section for drivers
            //
            //  since we need the display name in unicode, we use the wide
            //  APIs.
            //

            if (SetupFindFirstLineW( InfHandle,
                                     manufacturer,
                                     NULL,
                                     &deviceEnumContext ) == TRUE) {
                while (1) {

                    err = ParseCardDetails( pNetCards,
                                            InfHandle,
                                            InfFileName,
                                            &deviceEnumContext );

                    if (err == ERROR_NOT_ENOUGH_MEMORY) {
                        break;
                    }

                    if ( SetupFindNextLine( &deviceEnumContext,
                                            &deviceEnumContext ) == FALSE) {
                        break;
                    }
                }

                err = ERROR_SUCCESS;        // try the next card regardless

            } else {
                err = GetLastError();
                BinlPrintDbg(( DEBUG_NETINF, "SetupFindFirstLine failed with 0x%x in %S for Manufacturer\n",
                         err, InfFileName ));
            }
        } else {
            BinlPrintDbg(( DEBUG_NETINF, "GetSetupLineWideText failed with 0x%x in %S for Manufacturer\n",
                     err, InfFileName ));
        }

        if (err != ERROR_SUCCESS &&
            err != ERROR_NOT_SUPPORTED) {

            // log an error here? (and continue)
        }

        //
        //  if we ran out of memory on the inner loop, bail.
        //

        if (err == ERROR_NOT_ENOUGH_MEMORY) {
            break;
        }

        if ( SetupFindNextLine( &manufacturerEnumContext,
                                &manufacturerEnumContext ) == FALSE) {
            break;
        }
    }

exitProcessInf:

#ifdef NET_INF_VERBOSE
    BinlPrintDbg(( DEBUG_NETINF, "BINL netinf returning 0x%x for %S\n", err, InfFileName ));
#endif

    if (manufacturer) {
        BinlFreeMemory(manufacturer);
    }
    return err;
}

ULONG
ParseCardDetails (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PINFCONTEXT DeviceEnumContext
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We check to see if it's already on the list (by hw
    description) and if it isn't, create a new one, get the rest of the info,
    and put it on the list.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    DeviceEnumContext - current line that has device's hardware, name, section

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err = ERROR_SUCCESS;
    PLIST_ENTRY listEntry, listHead;
    PNETCARD_RESPONSE_DATABASE pEntry = NULL;
    LONG hwLength;
    PWCHAR nextField;
    ULONG sizeRequired;
    UNICODE_STRING hwString;
    PWCHAR sectionToLog = NULL;

    PWCHAR deviceName = NULL;
    PWCHAR deviceSection = NULL;
    PWCHAR deviceHw = NULL;
    ULONG hashValue;

    err = GetSetupWideTextField( DeviceEnumContext,
                                 2,
                                 &deviceHw,
                                 NULL );
    if (err != ERROR_SUCCESS) {
        goto exitParseCardDetails;
    }

    BinlAssert(deviceHw != NULL);

    //  convert it to uppercase to speed our searches

    RtlInitUnicodeString( &hwString, deviceHw );
    RtlUpcaseUnicodeString( &hwString, &hwString, FALSE );

    err = CheckHwDescription( deviceHw );
    if (err != ERROR_SUCCESS) {

        // this should fail if it's not the format we expect.
        goto exitParseCardDetails;
    }

    //
    //  We sort the list by HwDescription so that we only have
    //  one entry for each one.  Ensure that this one is not
    //  already in the list.
    //

    COMPUTE_STRING_HASH( deviceHw, &hashValue );
    listHead = &pNetCards->NetCardEntries[HASH_TO_INF_INDEX(hashValue)];
    listEntry = listHead->Flink;

    hwLength = lstrlenW( deviceHw );
    pEntry = NULL;

    while ( listEntry != listHead ) {

        pEntry = (PNETCARD_RESPONSE_DATABASE) CONTAINING_RECORD(
                                                listEntry,
                                                NETCARD_RESPONSE_DATABASE,
                                                NetCardEntry );

        err = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                              0,
                              deviceHw,
                              hwLength,
                              pEntry->HardwareId,
                              -1
                              );
        if (err == 2) {

            break;      // a match was found.
        }

        pEntry = NULL;

        if (err == 3) {

            break;      // it's greater, add it before listEntry
        }

        listEntry = listEntry->Flink;
    }

    if (pEntry != NULL) {

        //
        //  we've found a dup, don't process this one.
        //

        err = ERROR_SUCCESS;        // no problems here
        pEntry = NULL;
#ifdef NET_INF_VERBOSE
        BinlPrintDbg(( DEBUG_NETINF, "skipping dup of %S\n", deviceHw ));
#endif
        goto exitParseCardDetails;
    }

    //
    //  the inf name and section name are mandatory
    //

    err = GetSetupWideTextField( DeviceEnumContext,
                                 0,
                                 &deviceName,
                                 NULL );
    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to get device name for %S\n", deviceHw ));
        goto exitParseCardDetails;
    }

    err = GetSetupWideTextField( DeviceEnumContext,
                                 1,
                                 &deviceSection,
                                 NULL );
    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to get device section for %S\n", deviceHw ));
        goto exitParseCardDetails;
    }

    sectionToLog = deviceSection;

    if ((*deviceName == L'\0') ||
        (*deviceSection == L'\0')) {

        err = ERROR_NOT_SUPPORTED;
        BinlPrintDbg(( DEBUG_NETINF, "Empty Name or Section not supported for %S\n", deviceHw ));
        goto exitParseCardDetails;
    }

    //
    //  Allocate the buffer space required for the fields we need
    //

    sizeRequired = sizeof( NETCARD_RESPONSE_DATABASE ) +
        ( lstrlenW( InfFileName ) + 2 ) * sizeof(WCHAR);

    pEntry = (PNETCARD_RESPONSE_DATABASE) BinlAllocateMemory( sizeRequired );

    if (pEntry == NULL) {

        //
        //  Doh! we couldn't allocate a simple buffer.  we're done.
        //

        BinlPrintDbg(( DEBUG_NETINF, "failed to allocate new entry for %S\n", deviceHw ));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset( (PCHAR) pEntry, '\0', sizeRequired );

    nextField = (PWCHAR)(PCHAR)(((PCHAR) pEntry) + sizeof( NETCARD_RESPONSE_DATABASE ));

    //
    //  We hold the lock, so we don't need to reference all the
    //  entries.  Just start off the ref count at 1 for an entry
    //  that is alive but not in use.
    //

    pEntry->ReferenceCount = 1;

    pEntry->InfFileName = nextField;
    CopyMemory( nextField, InfFileName, lstrlenW( InfFileName ) * sizeof(WCHAR));

    pEntry->SectionName = deviceSection;
    deviceSection = NULL;

    pEntry->HardwareId = deviceHw;
    deviceHw = NULL;

    InitializeListHead( &pEntry->FileCopyList );

    pEntry->DriverDescription = deviceName;
    deviceName = NULL;

    InitializeListHead( &pEntry->Registry );

    //
    //  There's a few more fields we need to fill in before we're done with
    //  this entry.  We need to get :
    //          DriverName              "e100bnt.sys"
    //          SectionNameExt          "F1100C.ndi.ntx86"
    //          ServiceName             "E100B"
    //          Registry Additions      REG_MULTI_SZ
    //

    //
    //  determine SectionNameExt by first trying to tack on ".ntx86", if that
    //  doesn't work, try tacking on ".nt".  If that doesn't work, there aren't
    //  any extensions.
    //

    err = GetExtendedSectionName(   pNetCards,
                                    InfHandle,
                                    InfFileName,
                                    pEntry );

    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to get extended section for %S\n", deviceHw ));
        goto exitParseCardDetails;
    }

    err = GetServiceAndDriver( pNetCards,
                               InfHandle,
                               InfFileName,
                               pEntry );

    if (err != ERROR_SUCCESS) {
        goto exitParseCardDetails;
    }

    //
    //  this gets both the CopyFiles and the misc registry settings.
    //

    err = GetRegistryParametersForDriver(   pNetCards,
                                            InfHandle,
                                            InfFileName,
                                            pEntry );

    if (err != ERROR_SUCCESS) {
        goto exitParseCardDetails;
    }

    //
    //  Either pInfEntry is NULL, in which case listEntry is equal
    //  to the head of the list, or it's not NULL, in which case
    //  listEntry is equal to that entries listEntry.  In either
    //  case, we can simply insert this new entry onto the tail
    //  of listEntry.
    //

    InsertTailList( listEntry, &pEntry->NetCardEntry );

exitParseCardDetails:

    if (err != ERROR_SUCCESS && err != ERROR_NOT_SUPPORTED) {

        PWCHAR strings[3];
        strings[0] = InfFileName;
        strings[1] = sectionToLog;
        strings[2] = NULL;

        BinlReportEventW(   ERROR_BINL_ERR_IN_SECTION,
                            EVENTLOG_WARNING_TYPE,
                            (sectionToLog == NULL) ? 1 : 2,
                            sizeof(ULONG),
                            strings,
                            &err
                            );
    }

    //
    //  free anything that didn't get used
    //

    if (deviceName) {
        BinlFreeMemory(deviceName);
    }
    if (deviceSection) {
        BinlFreeMemory(deviceSection);
    }
    if (deviceHw) {
        BinlFreeMemory(deviceHw);
    }

    if (pEntry != NULL && err != ERROR_SUCCESS) {

        NetInfDereferenceNetcardEntry( pEntry );
    }


    return err;
}


ULONG
GetExtendedSectionName (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We parse the inf file for the extended section name
    for the specified platform (x86, alpha, ia64, etc).

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    pEntry - entry for which to get section names, base section name present

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err;
    PWCHAR extSectionName;
    ULONG sizeRequired;
    INFCONTEXT context;
    PWCHAR architecture;

    //  allocate space for the longest name we need, we'll shorten it later.

    if (pNetCards->Architecture == PROCESSOR_ARCHITECTURE_ALPHA) {

        architecture = L"alpha";

    } else if (pNetCards->Architecture == PROCESSOR_ARCHITECTURE_IA64) {

        architecture = L"ia64";

    } else if (pNetCards->Architecture == PROCESSOR_ARCHITECTURE_MIPS) {

        architecture = L"mips";

    } else if (pNetCards->Architecture == PROCESSOR_ARCHITECTURE_PPC) {

        architecture = L"ppc";

    } else { // if (pNetCards->Architecture == PROCESSOR_ARCHITECTURE_INTEL) {

        architecture = L"x86";
    }

    sizeRequired = lstrlenW( pEntry->SectionName ) +
                   lstrlenW( architecture ) +
                   sizeof( ".nt" ) + 1;

    extSectionName = (PWCHAR) BinlAllocateMemory( sizeRequired * sizeof(WCHAR) );

    if (extSectionName == NULL) {

        BinlPrintDbg(( DEBUG_NETINF, "failed to allocate ext section buffer for %S\n", pEntry->HardwareId ));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  first try to find the .ntx86 form.
    //

    lstrcpyW( extSectionName, pEntry->SectionName );
    lstrcatW( extSectionName, L".nt" );
    lstrcatW( extSectionName, architecture );

    if (SetupFindFirstLineW(InfHandle,
                            extSectionName,
                            NULL,
                            &context) == TRUE) {

        pEntry->SectionNameExt = extSectionName;
        return ERROR_SUCCESS;
    }

    //
    //  next try to find the .nt form.
    //

    lstrcpyW( extSectionName, pEntry->SectionName );
    lstrcatW( extSectionName, L".nt" );

    if (SetupFindFirstLineW(InfHandle,
                            extSectionName,
                            NULL,
                            &context) == TRUE) {

        pEntry->SectionNameExt = extSectionName;
        return ERROR_SUCCESS;
    }

    BinlFreeMemory( extSectionName );

    pEntry->SectionNameExt = pEntry->SectionName;
    return ERROR_SUCCESS;
}


ULONG
GetServiceAndDriver (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We parse the inf file for the service name and driver
    name for each platform we support (x86 and alpha).

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    pEntry - entry for which to get section names, ext section name present

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err = ERROR_SUCCESS;
    PWCHAR servSectionName = NULL;
    ULONG sizeRequired;
    INFCONTEXT context;
    LONG lineCount;
    PWCHAR serviceString = NULL;
    PWCHAR driverFullName = NULL;
    PWCHAR driverName;
    PWCHAR postSlash;

    //  allocate space for the longest name we need, we'll shorten it later.

    sizeRequired = lstrlenW( pEntry->SectionNameExt ) + sizeof( ".Services" ) + 1;

    servSectionName = (PWCHAR) BinlAllocateMemory( sizeRequired * sizeof(WCHAR) );

    if (servSectionName == NULL) {

        err = ERROR_NOT_ENOUGH_MEMORY;
        BinlPrintDbg(( DEBUG_NETINF, "failed to alloc service section for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    lstrcpyW( servSectionName, pEntry->SectionNameExt );
    lstrcatW( servSectionName, L".Services" );

    lineCount = SetupGetLineCountW( InfHandle, servSectionName);

    if ((lineCount == 0 || lineCount == -1) &&
        (pEntry->SectionNameExt != pEntry->SectionName)) {

        //
        //  hmm.. the service section wasn't there.  for grins, try the
        //  base service name.
        //

        lstrcpyW( servSectionName, pEntry->SectionName );
        lstrcatW( servSectionName, L".Services" );

        lineCount = SetupGetLineCountW( InfHandle, servSectionName);
    }

    if (lineCount == 0 || lineCount == -1) {

        err = GetLastError();
        if (err == ERROR_SUCCESS) {
            err = ERROR_NOT_SUPPORTED;
        }
        BinlPrintDbg(( DEBUG_NETINF, "failed to find service section for %S in %S\n",
                        pEntry->HardwareId, InfFileName ));
        goto exitGetService;
    }

    if (SetupFindFirstLineW( InfHandle,
                            servSectionName,
                            L"AddService",
                            &context ) == FALSE) {

        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF, "failed to find AddService value for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    err = GetSetupWideTextField(&context,
                                1,
                                &pEntry->ServiceName,           // "E100B"
                                NULL );

    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to find service name for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    err = GetSetupWideTextField(&context,
                                3,
                                &serviceString,     // "e100b.Service"
                                NULL );

    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to find service install section for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    //
    //  go get the driver name from the service section
    //

    err = GetSetupLineWideText( NULL,
                                InfHandle,
                                serviceString,
                                L"ServiceBinary",
                                &driverFullName,
                                NULL );

    if (err != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_NETINF, "failed to find driver binary for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    //
    //  The driver comes down as a fully qualified path.  Let's strip off the
    //  path and just store off the filename.
    //

    driverName = postSlash = driverFullName;

    while (*driverName != L'\0') {

        if (*driverName == OBJ_NAME_PATH_SEPARATOR) {

            postSlash = driverName + 1;
        }
        driverName++;
    }

    pEntry->DriverName = BinlAllocateMemory( (lstrlenW( postSlash ) + 1 ) * sizeof(WCHAR));

    if (pEntry->DriverName == NULL) {

        err = ERROR_NOT_ENOUGH_MEMORY;
        BinlPrintDbg(( DEBUG_NETINF, "failed to alloc memory for driver name for %S\n", pEntry->HardwareId ));
        goto exitGetService;
    }

    //
    //  save off the root driver name into the entry
    //

    lstrcpyW( pEntry->DriverName, postSlash );

exitGetService:

    if ( driverFullName ) {
        BinlFreeMemory( driverFullName );
    }
    if ( serviceString )  {
        BinlFreeMemory( serviceString );
    }
    if ( servSectionName ) {
        BinlFreeMemory( servSectionName );
    }
    return err;
}

ULONG
GetRegistryParametersForDriver (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We parse the inf file for the registry parameters
    for each platform we support (x86 and alpha).

    We pass in values to update so that we can use the same code for both
    architectures.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    pEntry - entry for which to get registry settings for

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err = ERROR_SUCCESS;
    INFCONTEXT infContext;
    ULONG  bufferLength;
    PWCHAR keyBuffer = NULL;
    ULONG  keyBufferLength = 0;

    if (SetupFindFirstLineW( InfHandle,
                             pEntry->SectionNameExt,
                             NULL,
                             &infContext) == FALSE) {

        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF, "failed to find section name of %S in %S\n",
                    pEntry->SectionNameExt, InfFileName ));
        goto exitGetRegistry;
    }
    //
    //  process each line in the section by either storing it off if it's one
    //  we don't recognize, ignoring it, or (for AddReg) process each value
    //  as yet another section to process.
    //

    while (1) {

        //
        //  process current line represented by infContext then go back for
        //  another
        //

        err = GetSetupWideTextField(&infContext,
                                    0,
                                    &keyBuffer,
                                    &keyBufferLength );

        if (err != ERROR_SUCCESS) {
            BinlPrintDbg(( DEBUG_NETINF, "failed to find service name for %S\n", pEntry->HardwareId ));
            goto exitGetRegistry;
        }

        if (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                            NORM_IGNORECASE,
                            keyBuffer,
                            -1,
                            L"CopyFiles",
                            -1 ) == 2) {

            // for each value, read off the CopyFiles section

            ULONG limit, i;

            limit = SetupGetFieldCount( &infContext );

            for (i = 1; i <= limit; i++ ) {

                err = GetSetupWideTextField(&infContext,
                                            i,
                                            &keyBuffer,
                                            &keyBufferLength );

                if (err != ERROR_SUCCESS) {
                    break;
                }

                err = ProcessCopyFilesSubsection(   pNetCards,
                                                    InfHandle,
                                                    InfFileName,
                                                    pEntry,
                                                    keyBuffer );
                if (err != ERROR_SUCCESS) {
#ifdef NET_INF_VERBOSE
                    BinlPrintDbg(( DEBUG_NETINF, "failed with 0x%x in section name of %S in %S\n",
                                err, keyBuffer, InfFileName ));
#endif
                    break;
                }
            }

            //
            //  we'll ignore errors during processing subsections for now, as
            //  some sections are reported as not found.
            //

            if (err != ERROR_NOT_ENOUGH_MEMORY) {

                err = ERROR_SUCCESS;
            }

        } else if (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                                   NORM_IGNORECASE,
                                   keyBuffer,
                                   -1,
                                   L"AddReg",
                                   -1 ) == 2) {

            // for each value, read off the registry section

            ULONG limit, i;

            limit = SetupGetFieldCount( &infContext );

            for (i = 1; i <= limit; i++ ) {

                err = GetSetupWideTextField(&infContext,
                                            i,
                                            &keyBuffer,
                                            &keyBufferLength );

                if (err != ERROR_SUCCESS) {
                    break;
                }

                err = ProcessRegistrySubsection(    pNetCards,
                                                    InfHandle,
                                                    InfFileName,
                                                    pEntry,
                                                    keyBuffer );
                if (err != ERROR_SUCCESS) {
#ifdef NET_INF_VERBOSE
                    BinlPrintDbg(( DEBUG_NETINF, "failed with 0x%x in section name of %S in %S\n",
                                err, keyBuffer, InfFileName ));
#endif
                    break;
                }
            }

            //
            //  we'll ignore errors during processing subsections for now, as
            //  some sections are reported as not found.
            //

            if (err != ERROR_NOT_ENOUGH_MEMORY) {

                err = ERROR_SUCCESS;
            }

        } else {

            PWCHAR textLine = NULL;

            //
            //  so far as we know, the only other ones are characteristics and
            //  BusType.  but there could certainly be others.
            //

            err = GetSetupLineWideText( &infContext,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &textLine,
                                        NULL );
            if (err == ERROR_SUCCESS) {

                PNETCARD_REGISTRY_PARAMETERS regParam;

                regParam = (PNETCARD_REGISTRY_PARAMETERS) BinlAllocateMemory(
                                sizeof(NETCARD_REGISTRY_PARAMETERS));

                if (regParam == NULL) {

                    BinlFreeMemory( textLine );
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                RtlInitUnicodeString( &regParam->Parameter, keyBuffer );
                keyBuffer = NULL;
                keyBufferLength = 0;

                RtlInitUnicodeString( &regParam->Value, textLine );

                //
                //  The only ones we know about are BusType, Characteristics,
                //  and
                //  BusType is an integer.  Characteristics (and anything else
                //  just to be safe) is a string.
                //

                if ((CompareStringW( LOCALE_SYSTEM_DEFAULT,
                                    NORM_IGNORECASE,
                                    regParam->Parameter.Buffer,
                                    -1,
                                    L"Characteristics",
                                    -1) == 2) ||
                    (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                                    NORM_IGNORECASE,
                                    regParam->Parameter.Buffer,
                                    -1,
                                    L"BusType",
                                    -1) == 2))  {

                    ULONG tmpValue = 0;

                    regParam->Type = NETCARD_REGISTRY_TYPE_INT;

                    //
                    //  ensure the value is in decimal
                    //

                    err = RtlUnicodeStringToInteger( &regParam->Value, 0, &tmpValue );

                    if (err == STATUS_SUCCESS) {

                        PWCHAR valueBuffer;
                        UNICODE_STRING decimalString;

                        //
                        //  now that we have the value, convert it to decimal
                        //

                        valueBuffer = (PWCHAR) BinlAllocateMemory( 20 * sizeof(WCHAR) );

                        if (valueBuffer == NULL) {

                            BinlFreeMemory( textLine );
                            BinlFreeMemory( regParam->Parameter.Buffer );
                            BinlFreeMemory( regParam );
                            err = ERROR_NOT_ENOUGH_MEMORY;
                            goto exitGetRegistry;
                        }

                        decimalString.Buffer = valueBuffer;
                        decimalString.Length = 0;
                        decimalString.MaximumLength = 20 * sizeof(WCHAR);

                        err = RtlIntegerToUnicodeString( tmpValue, 10, &decimalString );

                        if ( err == STATUS_SUCCESS ) {

                            //
                            //  if it succeeded, reset the value to the new
                            //  buffer, otherwise leave the old one in place.
                            //

                            BinlFreeMemory( textLine );
                            RtlInitUnicodeString( &regParam->Value, valueBuffer );
                        }
                    }

                } else {

                    regParam->Type = NETCARD_REGISTRY_TYPE_STRING;
                }

                InsertTailList( &pEntry->Registry, &regParam->RegistryListEntry );
            }
        }

        if (SetupFindNextLine( &infContext, &infContext ) == FALSE ) {
            break;
        }
    }

    err = ERROR_SUCCESS;

exitGetRegistry:

    if ( keyBuffer ) {
        BinlFreeMemory( keyBuffer );
    }
    return err;
}

ULONG
ProcessRegistrySubsection (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry,
    PWCHAR SectionToParse
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We parse the inf file for the registry section given.
    Note that this is a different format than the extended install section.

    Here's an example of the lines we parse :

    HKR, Ndi\params\NumCoalesce,    type,       0, "int"
    HKR, ,                          MsPciScan,  0, "2"

    Note that we skip everything in the Ndi registry area.

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    pEntry - entry for which to get registry settings for

    SectionToParse - what section in the INF do we start with

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    ULONG err = ERROR_SUCCESS;
    INFCONTEXT infContext;
    ULONG  bufferLength;
    PWCHAR keyBuffer = NULL;
    ULONG  keyBufferLength = 0;
    PWCHAR parameterBuffer = NULL;
    PWCHAR valueBuffer;

    if (SetupFindFirstLineW( InfHandle,
                             SectionToParse,
                             NULL,
                             &infContext) == FALSE) {

        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF, "failed to find section name of %S in %S\n",
                    SectionToParse, InfFileName ));
        goto exitGetRegistry;
    }
    //
    //  process each line in the section by either storing it off if it's one
    //  we don't recognize, ignoring it, or (for AddReg) process each value
    //  as yet another section to process.
    //

    while (1) {

        //
        //  process current line represented by infContext then go back for
        //  another
        //

        err = GetSetupWideTextField(&infContext,
                                    1,
                                    &keyBuffer,
                                    &keyBufferLength );

        if (err != ERROR_SUCCESS) {
            BinlPrintDbg(( DEBUG_NETINF, "failed to find registry value in %S in %S\n", SectionToParse, InfFileName ));
            goto OnToNextValue;
        }

        if (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                            NORM_IGNORECASE,
                            keyBuffer,
                            -1,
                            L"HKR",
                            -1 ) != 2) {


            BinlPrintDbg(( DEBUG_NETINF, "got something other than HKR, %S for %S\n", keyBuffer, InfFileName ));
            goto OnToNextValue;
        }

        err = GetSetupWideTextField(&infContext,
                                    2,
                                    &keyBuffer,
                                    &keyBufferLength );

        if (err != ERROR_SUCCESS) {

            BinlPrintDbg(( DEBUG_NETINF, "failed to get 2nd field in %S in %S\n", SectionToParse, InfFileName ));
            goto OnToNextValue;
        }

        if (IsSubString( L"Ndi", keyBuffer, TRUE )) {

            goto OnToNextValue;
        }

        //
        //  not part of the NDIS settings, we'll save this one off.
        //

        parameterBuffer = NULL;

        err = GetSetupWideTextField(&infContext,
                                    3,
                                    &parameterBuffer,
                                    NULL );

        if (err != ERROR_SUCCESS) {
            BinlPrintDbg(( DEBUG_NETINF, "failed to get 3rd field in %S in %S\n", SectionToParse, InfFileName ));
            goto OnToNextValue;
        }

        //
        //  check for empty parameter strings.  there are some infs that
        //  contain empty parameter names
        //

        valueBuffer = parameterBuffer;

        while (*valueBuffer == L' ') {
            valueBuffer++;
        }

        if (*valueBuffer != L'\0') {

            ULONG fieldFlags;
            ULONG regType;

            valueBuffer = NULL;

            if (SetupGetIntField( &infContext, 4, &fieldFlags) == FALSE) {

                err = GetLastError();
                BinlPrintDbg(( DEBUG_NETINF, "failed to get 4th field in %S in %S\n", parameterBuffer, InfFileName ));
                BinlFreeMemory( parameterBuffer );
                goto OnToNextValue;
            }

            if (fieldFlags == 0) {

                //
                //  the value is a string.
                //

                err = GetSetupWideTextField(&infContext,
                                            5,
                                            &valueBuffer,
                                            NULL );

                if (err != ERROR_SUCCESS) {
                    BinlPrintDbg(( DEBUG_NETINF, "failed to get 5th field in %S in %S\n", parameterBuffer, InfFileName ));
                }

                if (*valueBuffer == L'\0') {

#ifdef NET_INF_VERBOSE
                    BinlPrintDbg(( DEBUG_NETINF, "found empty value for %S in %S\n", parameterBuffer, InfFileName  ));
#endif
                    BinlFreeMemory( valueBuffer );
                    BinlFreeMemory( parameterBuffer );
                    goto OnToNextValue;
                }
                regType = NETCARD_REGISTRY_TYPE_STRING;

            } else if ((fieldFlags == FLG_ADDREG_TYPE_DWORD) ||
                       (fieldFlags == (FLG_ADDREG_TYPE_DWORD | FLG_ADDREG_NOCLOBBER))) {

                ULONG intValue;

                regType = NETCARD_REGISTRY_TYPE_INT;

                //
                //  the value is a dword, let's grab it and store off it's
                //  string representation
                //

                if (SetupGetIntField( &infContext, 5, &intValue) == FALSE) {

                    err = GetLastError();
                    BinlPrintDbg(( DEBUG_NETINF, "failed to get value field in %S in %S\n", parameterBuffer, InfFileName ));

                } else {

                    UNICODE_STRING valueString;
                    WCHAR resultBuffer[16];

                    valueString.Buffer = resultBuffer;
                    valueString.Length = 0;
                    valueString.MaximumLength = 16 * sizeof(WCHAR);

                    err = RtlIntegerToUnicodeString( intValue, 10, &valueString );

                    if (err == ERROR_SUCCESS) {

                        valueBuffer = BinlAllocateMemory( valueString.Length + sizeof(WCHAR) );

                        if (valueBuffer == NULL) {

                            BinlFreeMemory( parameterBuffer );
                            err = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }

                        lstrcpyW( valueBuffer, resultBuffer );
                    }
                }
            } else {

                BinlPrintDbg(( DEBUG_NETINF, "currently don't parse flags=0x%x in %S %S\n", fieldFlags, parameterBuffer, InfFileName ));
                err = ERROR_NOT_SUPPORTED;
            }

            if (err == ERROR_SUCCESS) {

                PNETCARD_REGISTRY_PARAMETERS regParam;

                //
                //  we have a parameter name and an associated value to store
                //  off.  let's allocate the list entry and store it on the list.
                //

                regParam = (PNETCARD_REGISTRY_PARAMETERS) BinlAllocateMemory(
                                sizeof(NETCARD_REGISTRY_PARAMETERS));

                if (regParam == NULL) {

                    BinlFreeMemory( valueBuffer );
                    BinlFreeMemory( parameterBuffer );
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                regParam->Type = regType;
                RtlInitUnicodeString( &regParam->Parameter, parameterBuffer );
                parameterBuffer = NULL;
                RtlInitUnicodeString( &regParam->Value, valueBuffer );
                valueBuffer = NULL;

                InsertTailList( &pEntry->Registry, &regParam->RegistryListEntry );
            }
        }

        if (parameterBuffer) {

            BinlFreeMemory( parameterBuffer );
        }

OnToNextValue:
        if (SetupFindNextLine( &infContext, &infContext ) == FALSE ) {
            break;
        }
    }

    err = ERROR_SUCCESS;

exitGetRegistry:

    if ( keyBuffer ) {
        BinlFreeMemory( keyBuffer );
    }
    return err;
}

ULONG
ProcessCopyFilesSubsection (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry,
    PWCHAR SectionToParse
    )
/*++

Routine Description:

    This function uses the SetupXxxx APIs to process an INF file for a given
    driver instance.  We parse the inf file for the registry section given.
    Note that this is a different format than the extended install section.

    Here's an example of the lines we parse :

    CopyFiles = @elnk90.sys
    CopyFiles = e100b.CopyFiles

    [e100b.CopyFiles]
    e100bnt.sys,,,2
    n100.sys,n100nt.sys,,2

Arguments:

    pNetCards - A pointer to NETCARD_INF_BLOCK block allocated.  Contains all
       the persistant info required for the netcards.

    InfHandle - handle open to INF file, guarenteed to be net driver

    InfFileName - wide form of relative file name we have open.

    pEntry - entry for which to get registry settings for

    SectionToParse - what section in the INF do we start with

Return Value:

    Windows Error.  We stop processing altogether at ERROR_NOT_ENOUGH_MEMORY

--*/
{
    PNETCARD_FILECOPY_PARAMETERS fileCopy;
    ULONG err = ERROR_SUCCESS;
    INFCONTEXT infContext;
    PWCHAR sourceFileBuffer = NULL;
    ULONG  sourceFileBufferLength = 0;
    PWCHAR destFileBuffer = NULL;
    PWCHAR sourceFile;
    ULONG  destFileBufferLength = 0;
    PWCHAR tempPtr;

    if (*SectionToParse == L'@') {

        if (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                            NORM_IGNORECASE,
                            SectionToParse+1,
                            -1,
                            pEntry->DriverName,
                            -1 ) == 2) {

            if (pNetCards->FileListCallbackFunction != NULL) {
                err = (*pNetCards->FileListCallbackFunction)( pNetCards->FileListCallbackContext,
                                                              InfFileName,
                                                              pEntry->DriverName );
            } else {
                err = STATUS_SUCCESS;
            }
            BinlPrintDbg(( DEBUG_NETINF, "Ignoring driver file %S as we already know that.\n", SectionToParse ));
            return err;
        }

        //
        //  the section name itself represents the file to copy
        //

        fileCopy = (PNETCARD_FILECOPY_PARAMETERS) BinlAllocateMemory(
                        sizeof(NETCARD_FILECOPY_PARAMETERS));

        if (fileCopy == NULL) {

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RtlInitUnicodeString( &fileCopy->DestFile, NULL );
        fileCopy->SourceFile.Length = (USHORT)(lstrlenW( SectionToParse+1 ) * sizeof(WCHAR));
        fileCopy->SourceFile.MaximumLength = fileCopy->SourceFile.Length + sizeof(WCHAR);
        fileCopy->SourceFile.Buffer = (PWCHAR) BinlAllocateMemory( fileCopy->SourceFile.MaximumLength );

        if (fileCopy->SourceFile.Buffer == NULL) {

            BinlFreeMemory( fileCopy );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        lstrcpyW( fileCopy->SourceFile.Buffer, SectionToParse+1 );   // skip @

        if (pNetCards->FileListCallbackFunction != NULL) {
            err = (*pNetCards->FileListCallbackFunction)( pNetCards->FileListCallbackContext,
                                                          InfFileName,
                                                          fileCopy->SourceFile.Buffer );
        } else {
            err = STATUS_SUCCESS;
        }

        InsertTailList( &pEntry->FileCopyList, &fileCopy->FileCopyListEntry );
        return err;
    }

    if (SetupFindFirstLineW( InfHandle,
                             SectionToParse,
                             NULL,
                             &infContext) == FALSE) {

        err = GetLastError();
        BinlPrintDbg(( DEBUG_NETINF, "failed to find section name of %S in %S\n",
                    SectionToParse, InfFileName ));
        goto exitGetRegistry;
    }
    //
    //  process each line in the section by storing it off
    //

    while (1) {

        //
        //  process current line represented by infContext then go back for
        //  another
        //

        err = GetSetupWideTextField(&infContext,
                                    1,
                                    &destFileBuffer,
                                    &destFileBufferLength );

        if (err != ERROR_SUCCESS) {
            BinlPrintDbg(( DEBUG_NETINF, "failed to find registry value in %S in %S\n", SectionToParse, InfFileName ));
            goto OnToNextValue;
        }

        if (CompareStringW( LOCALE_SYSTEM_DEFAULT,
                            NORM_IGNORECASE,
                            destFileBuffer,
                            -1,
                            pEntry->DriverName,
                            -1 ) == 2) {

            if (pNetCards->FileListCallbackFunction != NULL) {
                err = (*pNetCards->FileListCallbackFunction)( pNetCards->FileListCallbackContext,
                                                              InfFileName,
                                                              pEntry->DriverName );
                if (err != ERROR_SUCCESS) {
                    goto exitGetRegistry;
                }
            }
            BinlPrintDbg(( DEBUG_NETINF, "Ignoring driver file %S as we already know that.\n", sourceFileBuffer ));
            goto OnToNextValue;
        }

        //
        //  ensure that there's a value there.
        //

        tempPtr = destFileBuffer;

        while (*tempPtr == L' ') {
            tempPtr++;
        }

        if (*tempPtr == L'\0') {
            BinlPrintDbg(( DEBUG_NETINF, "Ignoring null file to copy in %S.\n", InfFileName ));
            goto OnToNextValue;
        }

        err = GetSetupWideTextField(&infContext,
                                    2,
                                    &sourceFileBuffer,
                                    &sourceFileBufferLength );

        if (err != ERROR_SUCCESS) {

            sourceFile = NULL;

        } else {

            tempPtr = sourceFileBuffer;

            while (*tempPtr == L' ') {
                tempPtr++;
            }

            if (*tempPtr == L'\0') {

                sourceFile = NULL;

            } else {

                sourceFile = sourceFileBuffer;
                sourceFileBuffer = NULL;
                sourceFileBufferLength = 0;
            }
        }

        fileCopy = (PNETCARD_FILECOPY_PARAMETERS) BinlAllocateMemory(
                        sizeof(NETCARD_FILECOPY_PARAMETERS));

        if (fileCopy == NULL) {

            err = ERROR_NOT_ENOUGH_MEMORY;
            goto exitGetRegistry;
        }

        err = ERROR_SUCCESS;

        if (sourceFile == NULL) {

            //
            //  if only the dest is given, only fill in the source since
            //  the client code is written that way already.
            //

            RtlInitUnicodeString( &fileCopy->DestFile, NULL );
            RtlInitUnicodeString( &fileCopy->SourceFile, destFileBuffer );

            if (pNetCards->FileListCallbackFunction != NULL) {
                err = (*pNetCards->FileListCallbackFunction)( pNetCards->FileListCallbackContext,
                                                              InfFileName,
                                                              destFileBuffer );
            }

        } else {

            RtlInitUnicodeString( &fileCopy->DestFile, destFileBuffer );
            RtlInitUnicodeString( &fileCopy->SourceFile, sourceFile );

            if (pNetCards->FileListCallbackFunction != NULL) {
                err = (*pNetCards->FileListCallbackFunction)( pNetCards->FileListCallbackContext,
                                                              InfFileName,
                                                              sourceFile );
            }
        }

        sourceFileBuffer = NULL;
        sourceFileBufferLength = 0;
        destFileBuffer = NULL;
        destFileBufferLength = 0;

        InsertTailList( &pEntry->FileCopyList, &fileCopy->FileCopyListEntry );

        if (err != ERROR_SUCCESS) {
            goto exitGetRegistry;
        }

OnToNextValue:
        if (SetupFindNextLine( &infContext, &infContext ) == FALSE ) {
            break;
        }
    }

    err = ERROR_SUCCESS;

exitGetRegistry:

    if ( sourceFileBuffer ) {
        BinlFreeMemory( sourceFileBuffer );
    }
    if ( destFileBuffer ) {
        BinlFreeMemory( destFileBuffer );
    }

    return err;
}


// netinf.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\netinf.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    netinf.h

Abstract:

    This file contains the structures and prototypes necessary for the
    netcard inf parser handler as required by the BINL remote boot server.

Author:

    Andy Herron (andyhe)  12-Mar-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NETINF_
#define _NETINF_

//
//  This is the structure we keep per registry value.  Off of each
//  NETCARD_RESPONSE_DATABASE is a list of these (stored in Registry).
//  It is a parameter that is required in the HKR path for the driver.
//

#define NETCARD_REGISTRY_TYPE_INT    '1'
#define NETCARD_REGISTRY_TYPE_STRING '2'

typedef struct _NETCARD_REGISTRY_PARAMETERS {

    LIST_ENTRY RegistryListEntry;
    UNICODE_STRING Parameter;
    ULONG   Type;
    UNICODE_STRING Value;

} NETCARD_REGISTRY_PARAMETERS, *PNETCARD_REGISTRY_PARAMETERS;

typedef struct _NETCARD_FILECOPY_PARAMETERS {

    LIST_ENTRY FileCopyListEntry;
    UNICODE_STRING SourceFile;

    // if DestFile is null, SourceFile is the file name for the target

    UNICODE_STRING DestFile;

} NETCARD_FILECOPY_PARAMETERS, *PNETCARD_FILECOPY_PARAMETERS;

//
//  this is the main structure that we return for any given net driver
//

typedef struct _NETCARD_RESPONSE_DATABASE {

    ULONG       ReferenceCount;
    LIST_ENTRY  NetCardEntry;
    PWCHAR HardwareId;   // hardware ID to return               ("PCI\\VEN_8086&DEV_1229")
    PWCHAR DriverName;   // driver name to return               ("e100bnt.sys")
    PWCHAR InfFileName; // inf file name to return              ("net557.inf")
    PWCHAR SectionName;  // section name within the inf         ("F1100C.ndi")
    PWCHAR SectionNameExt; // name with architecture extension  ("F1100C.ndi.ntx86")
    PWCHAR ServiceName;  // server name to add for this card    ("E100B")
    PWCHAR DriverDescription;   // description of the driver    ("Intel 82557B-based Ethernet PCI Adapter (10/100)")

    LIST_ENTRY FileCopyList;
    LIST_ENTRY Registry;

} NETCARD_RESPONSE_DATABASE, * PNETCARD_RESPONSE_DATABASE;

ULONG
NetInfStartHandler (
    VOID
    );

ULONG
NetInfCloseHandler (
    VOID
    );

//
//  This finds a specific driver for a given hardware description.
//  Be sure to call NetInfDereferenceNetcardEntry when you're done with the
//  entry.
//

ULONG
NetInfFindNetcardInfo (
    PWCHAR InfDirectory,
    ULONG Architecture,
    ULONG CardInfoVersion,
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PWCHAR *FullDriverBuffer OPTIONAL,
    PNETCARD_RESPONSE_DATABASE *pInfEntry
    );

//
//  After calling NetInfFindNetcardInfo, call NetInfDereferenceNetcardEntry
//  when you're done with the entry so that it can be marked as not in use.
//  Otherwise it'll leak memory when you close call NetInfCloseNetcardInfo.
//

VOID
NetInfDereferenceNetcardEntry (
    PNETCARD_RESPONSE_DATABASE pInfEntry
    );

#endif _NETINF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\netinfp.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    netinfp.h

Abstract:

    This file contains the structures and prototypes necessary for the
    netcard inf parser handler.

Author:

    Andy Herron (andyhe)  12-Mar-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NETINFP_
#define _NETINFP_

#define NETINF_VENDOR_STRING    L"VEN_"
#define NETINF_REVISION_STRING  L"REV_"
#define NETINF_DEVICE_STRING    L"DEV_"
#define NETINF_IOSUBS_STRING    L"SUBSYS_"

#define NETINF_BUS_TYPE_PCI  2
#define NETINF_BUS_TYPE_ISAPNP 3

#define NETCARD_HASH_TABLE_SIZE    17

extern CRITICAL_SECTION NetInfLock;

#define RNDM_CONSTANT   314159269    /* default scrambling constant */
#define RNDM_PRIME     1000000007    /* prime number for scrambling  */

//
// Compute a string hash value that is invariant to case
//
#define COMPUTE_STRING_HASH( _pus, _phash ) {                \
    PWCHAR _p = _pus;                                        \
    ULONG _chHolder =0;                                      \
                                                             \
    while( *_p != L'\0' ) {                                  \
        _chHolder = 37 * _chHolder + (unsigned int) *(_p++); \
    }                                                        \
                                                             \
    *(_phash) = abs(RNDM_CONSTANT * _chHolder) % RNDM_PRIME; \
}

#define HASH_TO_INF_INDEX( _hash )    ((_hash) % NETCARD_HASH_TABLE_SIZE)

//
//  this is the block that we keep for every install directory that we
//  process INF files for.  We then keep the list of configurations as a list
//  off of the NetCardEntryList.
//

typedef struct _NETCARD_INF_BLOCK {

    ULONG               ReferenceCount;
    LIST_ENTRY          InfBlockEntry;      // list entry for global list

    // table of list of NETCARD_RESPONSE_DATABASE, hashed by DeviceHw string
    LIST_ENTRY          NetCardEntries[ NETCARD_HASH_TABLE_SIZE ];

    ULONG               Architecture;
    ULONG               StatusFromScan;
    PNETINF_CALLBACK    FileListCallbackFunction;
    LPVOID              FileListCallbackContext;
    CRITICAL_SECTION    Lock;
    WCHAR               InfDirectory[1];    // inf directory to search

} NETCARD_INF_BLOCK, *PNETCARD_INF_BLOCK;

//
//  NetInfGetAllNetcardInfo parses all the INF files in the given directory
//  and sets up a structure containing all the data.  Be sure to call
//  NetInfCloseNetcardInfo when you're all done with the structure.
//

ULONG
NetInfAllocateNetcardInfo (
    PWCHAR InfPath,
    ULONG Architecture,
    PNETCARD_INF_BLOCK *pNetCards
    );

//
//  This frees all resources associated with the parsing of the INF files.
//  Any entries that are in use will not be deleted until they're explicitely
//  dereferenced using NetInfDereferenceNetcardEntry.
//

ULONG
NetInfCloseNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards
    );


//
//  This finds a specific driver for a given hardware description.
//  Be sure to call NetInfDereferenceNetcardEntry when you're done with the
//  entry.
//

ULONG
FindNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards,
    ULONG CardInfoVersion,
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PNETCARD_RESPONSE_DATABASE *pInfEntry
    );


ULONG
GetSetupLineWideText (
    PINFCONTEXT InfContext,
    HINF InfHandle,
    PWCHAR Section,
    PWCHAR Key,
    PWCHAR *String,
    PULONG SizeOfAllocation OPTIONAL
    );

ULONG
GetSetupWideTextField (
    PINFCONTEXT InfContext,
    DWORD  FieldIndex,
    PWCHAR *String,
    PULONG SizeOfAllocation OPTIONAL
    );

ULONG
GetHexValueFromHw (
    PWCHAR *String,      // this is updated.
    PULONG longValue,
    PUSHORT shortValue
    );

BOOLEAN
IsSubString (
    PWCHAR subString,
    PWCHAR target,
    BOOLEAN ignoreCase
    );

ULONG
CheckHwDescription (
    PWCHAR HardwareID
    );

ULONG
GetNetCardList (
    PNETCARD_INF_BLOCK pNetCards
    );

ULONG
ProcessInfFile (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName
    );

ULONG
ParseCardDetails (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PINFCONTEXT DeviceEnumContext
    );

ULONG
GetExtendedSectionName (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    );

ULONG
GetServiceAndDriver (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    );

ULONG
ProcessCopyFilesSubsection (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry,
    PWCHAR SectionToParse
    );

ULONG
GetRegistryParametersForDriver (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry
    );

ULONG
ProcessRegistrySubsection (
    PNETCARD_INF_BLOCK pNetCards,
    HINF InfHandle,
    PWCHAR InfFileName,
    PNETCARD_RESPONSE_DATABASE pEntry,
    PWCHAR SectionToParse
    );

VOID
DereferenceNetcardInfo (
    PNETCARD_INF_BLOCK pNetCards
    );

ULONG
CreateListOfCardIdentifiers (
    NET_CARD_INFO UNALIGNED * CardIdentity,
    PWCHAR *CardIdentifiers
    );

VOID
ConvertHexToBuffer (
    PWCHAR Buff,
    USHORT Value
    );

#endif _NETINFP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\network.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    network.c

Abstract:

    This module contains the network interface for the BINL server.

Author:

    Colin Watson (colinw)  2-May-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

DWORD
BinlWaitForMessage(
    BINL_REQUEST_CONTEXT *pRequestContext
    )
/*++

Routine Description:

    This function waits for a request on the BINL port on any of the
    configured interfaces.

Arguments:

    RequestContext - A pointer to a request context block for
        this request.

Return Value:

    The status of the operation.

--*/
{
    DWORD       length;
    DWORD       error;
    fd_set      readSocketSet;
    DWORD       i;
    int         readySockets;
    struct timeval timeout = { 0x7FFFFFFF, 0 }; // forever.

    LPOPTION    Option;
    LPBYTE      EndOfScan;
    LPBYTE      MagicCookie;
    BOOLEAN     informPacket;

    #define CLIENTOPTIONSTRING "PXEClient"
    #define CLIENTOPTIONSIZE (sizeof(CLIENTOPTIONSTRING) - 1)

    //
    //  Loop until we get an extended DHCP request or an error
    //

    while (1) {

        //
        // Setup the file descriptor set for select.
        //

        FD_ZERO( &readSocketSet );
        for ( i = 0; i < BinlGlobalNumberOfNets ; i++ ) {
            if (BinlGlobalEndpointList[i].Socket) {
                FD_SET(
                    BinlGlobalEndpointList[i].Socket,
                    &readSocketSet
                    );
            }
        }

        readySockets = select( 0, &readSocketSet, NULL, NULL, &timeout );

        //
        // return to caller when the service is shutting down or select()
        // times out.
        //

        if( (readySockets == 0)  ||
            (WaitForSingleObject( BinlGlobalProcessTerminationEvent, 0 ) == 0) ) {

            return( ERROR_SEM_TIMEOUT );
        }

        if( readySockets == SOCKET_ERROR) {
            continue;   //  Closed the DHCP socket?
        }

        //
        // Time to play 20 question with winsock.  Which socket is ready?
        //

        pRequestContext->ActiveEndpoint = NULL;

        for ( i = 0; i < BinlGlobalNumberOfNets ; i++ ) {
            if ( FD_ISSET( BinlGlobalEndpointList[i].Socket, &readSocketSet ) ) {
                pRequestContext->ActiveEndpoint = &BinlGlobalEndpointList[i];
                break;
            }
        }


        //BinlAssert(pRequestContext->ActiveEndpoint != NULL );
        if ( pRequestContext->ActiveEndpoint == NULL ) {
            return ERROR_SEM_TIMEOUT;
        }


        //
        // Read data from the net.  If multiple sockets have data, just
        // process the first available socket.
        //

        pRequestContext->SourceNameLength = sizeof( struct sockaddr );

        //
        // clean the receive buffer before receiving data in it. We clear
        // out one more byte than we actually hand to recvfrom, so we can
        // be sure the message has a NULL after it (in case we do a
        // wcslen etc. into the received packet).
        //

        RtlZeroMemory( pRequestContext->ReceiveBuffer, DHCP_MESSAGE_SIZE + 1 );
        pRequestContext->ReceiveMessageSize = DHCP_MESSAGE_SIZE;

        length = recvfrom(
                     pRequestContext->ActiveEndpoint->Socket,
                     (char *)pRequestContext->ReceiveBuffer,
                     pRequestContext->ReceiveMessageSize,
                     0,
                     &pRequestContext->SourceName,
                     (int *)&pRequestContext->SourceNameLength
                     );

        if ( length == SOCKET_ERROR ) {
            error = WSAGetLastError();
            BinlPrintDbg(( DEBUG_ERRORS, "Recv failed, error = %ld\n", error ));
        } else {

            //
            // Ignore all messages that do not look like DHCP or doesn't have the
            // option "PXEClient", OR that is not an oschooser message (they
            // all start with 0x81).
            //

            if ( ((LPDHCP_MESSAGE)pRequestContext->ReceiveBuffer)->Operation == OSC_REQUEST) {

                //
                // All OSC request packets have a 4-byte signature (first byte
                // is OSC_REQUEST) followed by a DWORD length (that does not
                // include the signature/length). Make sure the length matches
                // what we got from recvfrom (we allow padding at the end). We
                // use SIGNED_PACKET but any of the XXX_PACKET structures in
                // oscpkt.h would work.
                //

                if (length < FIELD_OFFSET(SIGNED_PACKET, SequenceNumber)) {
                    BinlPrintDbg(( DEBUG_OSC_ERROR, "Discarding runt packet %d bytes\n", length ));
                    continue;
                }

                if ((length - FIELD_OFFSET(SIGNED_PACKET, SequenceNumber)) <
                        ((SIGNED_PACKET UNALIGNED *)pRequestContext->ReceiveBuffer)->Length) {
                    BinlPrintDbg(( DEBUG_OSC_ERROR, "Discarding invalid length message %d bytes (header said %d)\n",
                        length, ((SIGNED_PACKET UNALIGNED *)pRequestContext->ReceiveBuffer)->Length));
                    continue;
                }

                BinlPrintDbg(( DEBUG_MESSAGE, "Received OSC message\n", 0 ));
                error = ERROR_SUCCESS;

            } else {

                if ( length < FIELD_OFFSET(DHCP_MESSAGE, Option) + 4 ) {
                    //
                    // Message isn't long enough to include the magic cookie, ignore it.
                    //
                    continue;
                }

                if ( ((LPDHCP_MESSAGE)pRequestContext->ReceiveBuffer)->Operation != BOOT_REQUEST) {
                    continue; // Doesn't look like an interesting DHCP frame
                }

                //  Stop scanning when there isn't room for a ClientOption, including
                //  the type, length, and the CLIENTOPTIONSTRING.
                EndOfScan = pRequestContext->ReceiveBuffer +
                            pRequestContext->ReceiveMessageSize -
                            (FIELD_OFFSET(OPTION, OptionValue[0]) + CLIENTOPTIONSIZE);

                //
                // check magic cookie.
                //

                MagicCookie = (LPBYTE)&((LPDHCP_MESSAGE)pRequestContext->ReceiveBuffer)->Option;

                if( (*MagicCookie != (BYTE)DHCP_MAGIC_COOKIE_BYTE1) ||
                    (*(MagicCookie+1) != (BYTE)DHCP_MAGIC_COOKIE_BYTE2) ||
                    (*(MagicCookie+2) != (BYTE)DHCP_MAGIC_COOKIE_BYTE3) ||
                    (*(MagicCookie+3) != (BYTE)DHCP_MAGIC_COOKIE_BYTE4))
                {
                    continue; // this is a vendor specific magic cookie.
                }

                Option = (LPOPTION) (MagicCookie + 4);
                informPacket = FALSE;

                while (((LPBYTE)Option <= EndOfScan) &&
                       ((Option->OptionType != OPTION_CLIENT_CLASS_INFO) ||
                        (Option->OptionLength < CLIENTOPTIONSIZE) ||
                        (memcmp(Option->OptionValue, CLIENTOPTIONSTRING, CLIENTOPTIONSIZE) != 0))) {

                    if ( Option->OptionType == OPTION_END ){
                        break;
                    } else if ( Option->OptionType == OPTION_PAD ){
                        Option = (LPOPTION)( (LPBYTE)(Option) + 1);
                    } else {
                        if (( Option->OptionType == OPTION_MESSAGE_TYPE ) &&
                            ( Option->OptionLength == 1 ) &&
                            ( Option->OptionValue[0] == DHCP_INFORM_MESSAGE )) {
                            informPacket = TRUE;
                        }
                        Option = (LPOPTION)( (LPBYTE)(Option) + Option->OptionLength + 2);
                    }
                }

                if ((((LPBYTE)Option > EndOfScan) ||
                     (Option->OptionType == OPTION_END)) &&
                     (informPacket == FALSE)) {
                    continue;   //  Not an extended DHCP packet so ignore it
                }

                BinlPrintDbg(( DEBUG_MESSAGE, "Received message\n", 0 ));
                error = ERROR_SUCCESS;

            }
        }

        pRequestContext->ReceiveMessageSize = length;
        return( error );
    }
}

DWORD
BinlSendMessage(
    LPBINL_REQUEST_CONTEXT RequestContext
    )
/*++

Routine Description:

    This function send a response to a BINL client.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    struct sockaddr_in *source;
    LPDHCP_MESSAGE binlMessage;
    LPDHCP_MESSAGE binlReceivedMessage;
    DWORD MessageLength;
    BOOL  ArpCacheUpdated = FALSE;

    binlMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;
    binlReceivedMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;

    //
    // if the request arrived from a relay agent, then send the reply
    // on server port otherwise leave it as the client's source port.
    //

    source = (struct sockaddr_in *)&RequestContext->SourceName;
    if ( binlReceivedMessage->RelayAgentIpAddress != 0 ) {
        source->sin_port = htons( DHCP_SERVR_PORT );
    }

    //
    // if this request arrived from relay agent then send the
    // response to the address the relay agent says.
    //

    if ( binlReceivedMessage->RelayAgentIpAddress != 0 ) {
        source->sin_addr.s_addr = binlReceivedMessage->RelayAgentIpAddress;
    }
    else {

        //
        // if the client didnt specify broadcast bit and if
        // we know the ipaddress of the client then send unicast.
        //

        //
        // But if IgnoreBroadcastFlag is set in the registry and
        // if the client requested to broadcast or the server is
        // nacking or If the client doesn't have an address yet,
        // respond via broadcast.
        // Note that IgnoreBroadcastFlag is off by default. But it
        // can be set as a workaround for the clients that are not
        // capable of receiving unicast
        // and they also dont set the broadcast bit.
        //

        if ( (RequestContext->MessageType == DHCP_INFORM_MESSAGE) &&
             (ntohs(binlMessage->Reserved) & DHCP_BROADCAST) ) {

            source->sin_addr.s_addr = (DWORD)-1;

        } else if ( BinlGlobalIgnoreBroadcastFlag ) {

            if ((ntohs(binlReceivedMessage->Reserved) & DHCP_BROADCAST) ||
                    (binlReceivedMessage->ClientIpAddress == 0) ||
                    (source->sin_addr.s_addr == 0) ) {

                source->sin_addr.s_addr = (DWORD)-1;

                binlMessage->Reserved = 0;
                    // this flag should be zero in the local response.
            }

        } else {

            if( (ntohs(binlReceivedMessage->Reserved) & DHCP_BROADCAST) ||
                (!source->sin_addr.s_addr ) ){

                source->sin_addr.s_addr = (DWORD)-1;

                binlMessage->Reserved = 0;
                    // this flag should be zero in the local response.
            } else {

                //
                //  Send back to the same IP address that the request came in on (
                //  i.e. source->sin_addr.s_addr)
                //
            }

        }
    }

    BinlPrint(( DEBUG_STOC, "Sending response to = %s, XID = %lx.\n",
        inet_ntoa(source->sin_addr), binlMessage->TransactionID));


    //
    // send minimum DHCP_MIN_SEND_RECV_PK_SIZE (300) bytes, otherwise
    // bootp relay agents don't like the packet.
    //

    MessageLength = (RequestContext->SendMessageSize >
                    DHCP_MIN_SEND_RECV_PK_SIZE) ?
                        RequestContext->SendMessageSize :
                            DHCP_MIN_SEND_RECV_PK_SIZE;
    error = sendto(
                 RequestContext->ActiveEndpoint->Socket,
                (char *)RequestContext->SendBuffer,
                MessageLength,
                0,
                &RequestContext->SourceName,
                RequestContext->SourceNameLength
                );

    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        BinlPrintDbg(( DEBUG_ERRORS, "Send failed, error = %ld\n", error ));
    } else {
        error = ERROR_SUCCESS;
    }

    return( error );
}

NTSTATUS
GetIpAddressInfo (
    ULONG Delay
    )
{
    PDNS_ADDRESS_INFO pAddressInfo = NULL;
    ULONG count;

    //
    //  We can get out ahead of the dns cached info here... let's delay a bit
    //  if the pnp logic told us there was a change.
    //

    if (Delay) {
        Sleep( Delay );
    }

    count = DnsGetIpAddressInfoList( &pAddressInfo );

    if (count == 0) {

        //
        //  we don't know what went wrong, we'll fall back to old APIs.
        //

        DHCP_IP_ADDRESS ipaddr = 0;
        PHOSTENT Host = gethostbyname( NULL );

        if (Host) {

            ipaddr = *(PDHCP_IP_ADDRESS)Host->h_addr;

            if ((Host->h_addr_list[0] != NULL) &&
                (Host->h_addr_list[1] != NULL)) {

                BinlIsMultihomed = TRUE;

            } else {

                BinlIsMultihomed = FALSE;
            }

            BinlGlobalMyIpAddress = ipaddr;

        } else {

            //
            //  what's with the ip stack?  we can't get any type of address
            //  info out of it... for now, we won't answer any if we don't
            //  already have the info we need.
            //

            if (BinlDnsAddressInfo == NULL) {

                BinlIsMultihomed = TRUE;
            }
        }
        return STATUS_SUCCESS;
    }

    EnterCriticalSection(&gcsParameters);

    if (BinlDnsAddressInfo) {
        LocalFree( BinlDnsAddressInfo );
    }

    BinlDnsAddressInfo = pAddressInfo;
    BinlDnsAddressInfoCount = count;

    BinlIsMultihomed = (count != 1);

    if (!BinlIsMultihomed) {

        BinlGlobalMyIpAddress = pAddressInfo->ipAddress;
    }

    LeaveCriticalSection(&gcsParameters);

    return STATUS_SUCCESS;
}

DHCP_IP_ADDRESS
BinlGetMyNetworkAddress (
    LPBINL_REQUEST_CONTEXT RequestContext
    )
{
    ULONG RemoteIp;
    DHCP_IP_ADDRESS ipaddr;
    ULONG i;
    ULONG subnetMask;
    ULONG localAddr;

    BinlAssert( RequestContext != NULL);

    //
    //  If we're not multihomed, then we know the address since there's just one.
    //

    if (!BinlIsMultihomed) {
        return BinlGlobalMyIpAddress;
    }

    RemoteIp = ((struct sockaddr_in *)&RequestContext->SourceName)->sin_addr.s_addr;

    if (RemoteIp == 0) {

        //
        //  If we're multihomed and the client doesn't yet have an IP address,
        //  then we return 0, because we don't know which of our addresses to
        //  use to talk to the client.
        //

        return 0;
    }

    EnterCriticalSection(&gcsParameters);

    if (BinlDnsAddressInfo == NULL) {

        LeaveCriticalSection(&gcsParameters);
        return (BinlIsMultihomed ? 0 : BinlGlobalMyIpAddress);
    }

    ipaddr = 0;

    for (i = 0; i < BinlDnsAddressInfoCount; i++) {

        localAddr = BinlDnsAddressInfo[i].ipAddress;
        subnetMask = BinlDnsAddressInfo[i].subnetMask;

        //
        //  check that the remote ip address may have come from this subnet.
        //  note that the address could be the address of a dhcp relay agent,
        //  which is fine since we're just looking for the address of the
        //  local subnet to broadcast the response on.
        //

        if ((RemoteIp & subnetMask) == (localAddr & subnetMask)) {

            ipaddr = localAddr;
            break;
        }
    }

    LeaveCriticalSection(&gcsParameters);

    return ipaddr;
}


VOID
FreeIpAddressInfo (
    VOID
    )
{
    EnterCriticalSection(&gcsParameters);

    if (BinlDnsAddressInfo != NULL) {
        LocalFree( BinlDnsAddressInfo );
    }
    BinlDnsAddressInfo = NULL;
    BinlDnsAddressInfoCount = 0;

    LeaveCriticalSection(&gcsParameters);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\binl\osc.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    osc.c

Abstract:

    This module contains the code to process OS Chooser message
    for the BINL server.

Author:

    Adam Barr (adamba)  9-Jul-1997
    Geoff Pease (gpease) 10-Nov-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "binl.h"
#pragma hdrstop

#include <dns.h>
#include <aclapi.h>

#ifdef TEST_FAILURE
BOOL FailFirstChallenge = TRUE;
BOOL FailFirstResult = TRUE;
BOOL FailFirstResponse = TRUE;
BOOL FailFirstFragment = TRUE;
#endif

//
// Flag indicating whether OscInitialize has been called.
//

BOOLEAN OscInitialized = FALSE;

//
// The list of clients.
//

LIST_ENTRY ClientsQueue;

//
// This guards access to ClientsQueue.
//

CRITICAL_SECTION ClientsCriticalSection;

//
// This is a temporary hack to serialize all calls to the
// NetUserSetInfo/NetUserModalsGet pair. See discussion in
// bug 319962.
//

CRITICAL_SECTION HackWorkaroundCriticalSection;

//
// CurrentClientCount-er access guard
//

CRITICAL_SECTION g_CurrentClientCountCritSect;

//
// Guards creation of the \remoteinstall\tmp directory.
//
CRITICAL_SECTION g_TmpDirectoryCriticalSection;

//
// Credential handle from SSPI
//

CredHandle CredentialHandle;

//
// Info on the NTLMSSP security package.
//

PSecPkgInfo PackageInfo = NULL;

#if DBG
CHAR OscWatchVariable[32] = "";
#endif

DWORD
OscCheckTmpDirectory(
    VOID
    )
/*++

Routine Description:

    This function verifies that the \remoteinstall\tmp directory
    is there, if not it creates it.

Arguments:

    None.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    WCHAR TmpPath[ MAX_PATH ];
    DWORD FileAttributes;
    BOOL InCriticalSection = FALSE;
    PSID pEveryoneSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL b;

    if ( _snwprintf( TmpPath,
                     sizeof(TmpPath) / sizeof(TmpPath[0]),
                     L"%ws\\%ws",
                     IntelliMirrorPathW,
                     TEMP_DIRECTORY
                     ) == -1 ) {
        Error = ERROR_BAD_PATHNAME;
        goto Cleanup;
    }

    FileAttributes = GetFileAttributes(TmpPath);

    if (FileAttributes == 0xFFFFFFFF) {

        EXPLICIT_ACCESS ea;
        SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
        SECURITY_ATTRIBUTES sa;

        //
        // Get the critical section if we are going to try to create it.
        //

        InCriticalSection = TRUE;
        EnterCriticalSection(&g_TmpDirectoryCriticalSection);

        //
        // Make sure it still needs to be created.
        //

        FileAttributes = GetFileAttributes(TmpPath);
    
        if (FileAttributes == 0xFFFFFFFF) {
    
    
            // Create a well-known SID for the Everyone group.
    
            if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
                             SECURITY_WORLD_RID,
                             0, 0, 0, 0, 0, 0, 0,
                             &pEveryoneSID) ) {
                Error = GetLastError();
                BinlPrintDbg(( DEBUG_INIT, "AllocateAndInitializeSid failed: %lx\n", Error ));
                goto Cleanup;
            }
    
            // Initialize an EXPLICIT_ACCESS structure for an ACE.
            // The ACE will allow Everyone all access to the directory.
    
            ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
            ea.grfAccessPermissions = FILE_GENERIC_READ | FILE_GENERIC_WRITE;
            ea.grfAccessMode = SET_ACCESS;
            ea.grfInheritance= OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
            ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            ea.Trustee.ptstrName  = (LPTSTR) pEveryoneSID;
    
            // Create a new ACL that contains the new ACE.
    
            Error = SetEntriesInAcl(1, &ea, NULL, &pACL);
            if (Error != ERROR_SUCCESS) {
                BinlPrintDbg(( DEBUG_INIT, "SetEntriesInAcl failed lx\n", Error ));
                goto Cleanup;
            }
    
            // Initialize a security descriptor.
    
            pSD = (PSECURITY_DESCRIPTOR) BinlAllocateMemory(SECURITY_DESCRIPTOR_MIN_LENGTH);
            if (pSD == NULL) {
                Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                BinlPrintDbg(( DEBUG_INIT, "Allocate SECURITY_DESCRIPTOR failed\n"));
                goto Cleanup;
            }
    
            if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) {
                Error = GetLastError();
                BinlPrintDbg(( DEBUG_INIT, "InitializeSecurityDescriptor failed: %lx\n", Error ));
                goto Cleanup;
            }
    
            // Add the ACL to the security descriptor.
    
            if (!SetSecurityDescriptorDacl(pSD,
                    TRUE,     // fDaclPresent flag
                    pACL,
                    FALSE))   // not a default DACL
            {
                Error = GetLastError();
                BinlPrintDbg(( DEBUG_INIT, "SetSecurityDescriptorDacl failed: %lx\n", Error ));
                goto Cleanup;
            }
    
            // Initialize a security attributes structure.
    
            sa.nLength = sizeof (SECURITY_ATTRIBUTES);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = FALSE;
    
            b = CreateDirectory(TmpPath, &sa);
            if (!b) {
                Error = GetLastError();
                BinlPrintDbg(( DEBUG_INIT, "CreateDirectory failed: %lx\n", Error ));
                goto Cleanup;
            }

        }
    
    } else if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

        Error = ERROR_FILE_EXISTS;
        goto Cleanup;
    }

Cleanup:

    if (InCriticalSection) {
        LeaveCriticalSection(&g_TmpDirectoryCriticalSection);
    }

    if (pEveryoneSID) {
        FreeSid(pEveryoneSID);
    }
    if (pACL) {
        BinlFreeMemory(pACL);
    }
    if (pSD) {
        BinlFreeMemory(pSD);
    }

    return Error;

}

DWORD
OscInitialize(
    VOID
    )
/*++

Routine Description:

    This function initializes the OSChooser server.

Arguments:

    None.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    SECURITY_STATUS SecStatus;
    ULONG PackageCount;
    TimeStamp Lifetime;
    LPSHARE_INFO_2 psi;
    NET_API_STATUS netStatus;

    TraceFunc("OscInitialize( )\n");

    if ( !OscInitialized ) {

        InitializeListHead(&ClientsQueue);
        InitializeCriticalSection(&ClientsCriticalSection);
        InitializeCriticalSection(&HackWorkaroundCriticalSection);
        InitializeCriticalSection(&g_CurrentClientCountCritSect);
        InitializeCriticalSection(&g_TmpDirectoryCriticalSection);

        CredentialHandle.dwLower = 0;
        CredentialHandle.dwUpper = 0;

        OscInitialized = TRUE;
    }

    //
    // Retrieve the path to the remote install directory
    //
    netStatus = NetShareGetInfo(NULL, L"REMINST", 2, (LPBYTE *)&psi);
    if ( netStatus == ERROR_SUCCESS )
    {
        wcscpy( IntelliMirrorPathW, psi->shi2_path );
        NetApiBufferFree(psi);
    }
    else
    {
        BinlPrintDbg(( DEBUG_MISC, "NetShareGetInfo( ) returned 0x%08x\n", netStatus));
        BinlServerEventLog(
            EVENT_SERVER_OSC_NO_DEFAULT_SHARE_FOUND,
            EVENTLOG_ERROR_TYPE,
            netStatus );
        Error = ERROR_BINL_SHARE_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Translate this to ANSI once, use many...
    //
    wcstombs( IntelliMirrorPathA, IntelliMirrorPathW, wcslen(IntelliMirrorPathW) +1 );

    //
    // Make sure there is a tmp directory below it.
    //

    Error = OscCheckTmpDirectory();
    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_INIT, "OscCheckTempDirectory failed lx\n", Error ));
        goto Cleanup;
    }

    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "EnumerateSecurityPackages failed: %lx\n", SecStatus ));
        Error = ERROR_NO_SUCH_PACKAGE;
        goto Cleanup;
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( NTLMSP_NAME, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "QuerySecurityPackageInfo failed: %lx\n", SecStatus ));
        Error = ERROR_NO_SUCH_PACKAGE;
        goto Cleanup;
    }

    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        BinlPrintDbg(( DEBUG_INIT, "AcquireCredentialsHandle failed: %lx\n", SecStatus ));
        Error = SecStatus;
    }

Cleanup:

    return Error;
}

VOID
OscUninitialize(
    VOID
    )
/*++

Routine Description:

    This function uninitializes the OSChooser server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    SECURITY_STATUS SecStatus;

    TraceFunc("OscUninitialize( )\n");

    if ( OscInitialized ) {

        OscFreeClients();
        DeleteCriticalSection(&ClientsCriticalSection);
        DeleteCriticalSection(&HackWorkaroundCriticalSection);
        DeleteCriticalSection(&g_CurrentClientCountCritSect);
        DeleteCriticalSection(&g_TmpDirectoryCriticalSection);

        SecStatus = FreeCredentialsHandle( &CredentialHandle );

        if ( SecStatus != STATUS_SUCCESS ) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "FreeCredentialsHandle failed: %lx\n", SecStatus ));
        }

        if ( BinlOscClientDSHandle != NULL ) {
            DsUnBind( &BinlOscClientDSHandle );
            BinlOscClientDSHandle = NULL;
        }

        OscInitialized = FALSE;

    }
}

DWORD
OscProcessMessage(
    LPBINL_REQUEST_CONTEXT RequestContext
    )
/*++

Routine Description:

    This function dispatches the processing of a received OS chooser message.
    The handler functions will send response messages if necessary.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

Return Value:

    Windows Error.

--*/
{
    SIGNED_PACKET UNALIGNED * loginMessage = (SIGNED_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    DWORD Error;
    PCLIENT_STATE clientState = NULL;
    ULONG RemoteIp;
    BOOL FreeClientState;
    BOOL IsLogoffMessage;
    BOOL IsNetcardRequestMessage;
    BOOL IsHalRequestMessage;
    BOOL IsNegotiateMessage;
    BOOL IsAuthenicateMessage;

    TraceFunc("OscProcessMessage( )\n");

    BinlPrintDbg(( DEBUG_OSC, "Received message, length %d, data %.3s\n",
            RequestContext->ReceiveMessageSize,
            ((PUCHAR)loginMessage)+1));

    //
    // Extract the IP address of the client.
    //
    RemoteIp = ((struct sockaddr_in *)&RequestContext->SourceName)->sin_addr.s_addr;

    //
    // IsLogoffMessage will be TRUE if the signature is equal to LogoffSignature.
    //
    IsLogoffMessage = (BOOL)(memcmp(loginMessage->Signature, LogoffSignature, 4) == 0);

    //
    // IsNetcardRequestMessage will be TRUE if the signature is equal to NetcardRequestSignature.
    //
    IsNetcardRequestMessage = (BOOL)(memcmp(loginMessage->Signature, NetcardRequestSignature, 4) == 0);

    //
    // IsHalRequestMessage will be TRUE if the signature is equal to HalRequestSignature.
    //
    IsHalRequestMessage = (BOOL)(memcmp(loginMessage->Signature, HalRequestSignature, 4) == 0);

    //
    // IsNegotiateMessage will be TRUE if the signature is equal to a NegotiateSignature.
    //
    IsNegotiateMessage = (BOOL)(memcmp(loginMessage->Signature, NegotiateSignature, 4) == 0);

    //
    // IsAuthenicateMessage will be TRUE if the signature is equal to an AuthenticateSignature
    // or AuthenticateFlippedSignature.
    //
    IsAuthenicateMessage = (BOOL)((memcmp(loginMessage->Signature, AuthenticateSignature, 4) == 0) ||
                                  (memcmp(loginMessage->Signature, AuthenticateFlippedSignature, 4) == 0));


    //
    // All messages except netcard queries need to use a CLIENT_STATE.
    //
    if (!IsNetcardRequestMessage)
    {
        //
        // If IsLogoffMessage is FALSE, this finds an old CLIENT_STATE or creates
        // a new one. If IsLogoffMessage is TRUE, this removes CLIENT_STATE from
        // the database if it finds it.
        // In both cases, if successful, it adds one to the PositiveRefCount.
        //

        Error = OscFindClient(RemoteIp, IsLogoffMessage, &clientState);

        if (Error == ERROR_NOT_ENOUGH_SERVER_MEMORY)
        {
            CLIENT_STATE TempClientState;
            SIGNED_PACKET TempLoginPacket;

            BinlPrint(( DEBUG_OSC_ERROR, "Could not get client state for %s\n", inet_ntoa(*(struct in_addr *)&RemoteIp) ));

            //
            // Send a NAK back to the client. We use a local CLIENT_STATE
            // since this did not allocate one.
            //
            TempClientState.LastResponse = (PUCHAR)&TempLoginPacket;
            TempClientState.LastResponseLength = SIGNED_PACKET_DATA_OFFSET;

            memcpy(TempLoginPacket.Signature, NegativeAckSignature, 4);
            TempLoginPacket.Length = 0;

            Error = SendUdpMessage(RequestContext, &TempClientState, FALSE, FALSE);

            if (Error != ERROR_SUCCESS)
            {
                BinlPrint(( DEBUG_OSC_ERROR, "Could not send NAK message %d\n", Error));
            }

            return ERROR_NOT_ENOUGH_SERVER_MEMORY;
        }
        else if (Error == ERROR_BUSY) {

            //
            // If it is likely that another thread is processing a request
            // for this client, then just exit quietly.
            //

            BinlPrintDbg((DEBUG_OSC, "clientState = 0x%08x busy, exiting\n", clientState ));
            return ERROR_SUCCESS;

        } if ( clientState == NULL ) {

            BinlPrintDbg((DEBUG_OSC, "clientState not found, exiting\n" ));
            return ERROR_SUCCESS;
        }

        EnterCriticalSection(&clientState->CriticalSection);
        clientState->CriticalSectionHeld = TRUE;
        BinlPrintDbg((DEBUG_OSC, "Entering CS for clientState = 0x%08x\n", clientState ));
    }

    if (IsNegotiateMessage)
    {
        //
        // This is an initial negotiate request.
        //
        Error = OscProcessNegotiate( RequestContext, clientState );

    }
    else if (IsAuthenicateMessage)
    {
        //
        // This has the authenticate message.
        //

        Error = OscProcessAuthenticate( RequestContext, clientState );

    }
    else if (memcmp(loginMessage->Signature, RequestUnsignedSignature, 4) == 0)
    {
        //
        // This is an unsigned request.
        //
        // Format is:
        //
        // "RQU"
        // length (not including "RQU" and this)
        // sequence number
        // fragment count/total
        // sign length
        // sign
        // data
        //
        Error = OscProcessRequestUnsigned( RequestContext, clientState );

    }
    else if (memcmp(loginMessage->Signature, RequestSignedSignature, 4) == 0)
    {
        //
        // This is a signed request.
        //
        // Format is:
        //
        // "REQ"
        // length (not including "REQ" and this)
        // sequence number
        // fragment count/total
        // sign length
        // sign
        // data
        //
        Error = OscProcessRequestSigned( RequestContext, clientState );

    }
    else if (memcmp(loginMessage->Signature, SetupRequestSignature, 4) == 0)
    {
        //
        // This is a request by a textmode setup.
        //
        // Format is defined in SPUDP_PACKET in oskpkt.h
        //
        Error = OscProcessSetupRequest( RequestContext, clientState );

    }
    else if (IsLogoffMessage)
    {
        //
        // This is a logoff request. clientState has
        // already been removed from the database.
        //
        Error = OscProcessLogoff( RequestContext, clientState );

    }
    else if (IsNetcardRequestMessage)
    {
        //
        // This is a netcard request, which needs no client state.
        //
        Error = OscProcessNetcardRequest( RequestContext );

    }
    else if (IsHalRequestMessage)
    {
        //
        // This is a hal request
        //
        Error = OscProcessHalRequest( RequestContext, clientState );

    }
    else
    {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Received unknown message!\n" ));
        Error = ERROR_INVALID_FUNCTION;
    }

    if ( clientState ) {

        clientState->LastUpdate = GetTickCount();

        if (!IsNetcardRequestMessage) {

            //
            // We processed a packet, so if we get a first request for this
            // client state (meaning the client has rebooted), we need to
            // reinitialize it.
            //

            clientState->InitializeOnFirstRequest = TRUE;

            ++clientState->NegativeRefCount;

            //
            // FreeClientState will be TRUE if the two refcounts are equal.
            //
            FreeClientState = (BOOL)(clientState->PositiveRefCount == clientState->NegativeRefCount);

            clientState->CriticalSectionHeld = FALSE;
            LeaveCriticalSection(&clientState->CriticalSection);
            BinlPrintDbg((DEBUG_OSC, "Leaving CS for clientState = 0x%08x\n", clientState ));

            if (FreeClientState)
            {
                FreeClient(clientState);
            }
        }
    }

    return Error;
}

DWORD
OscVerifyLastResponseSize(
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function checks that the LastResponse buffer is big enough,
    if not it reallocates it. The algorithm used is to keep increasing
    the size of the buffer, but not to try to shrink it.

Arguments:

    clientState - The client state for the remote. clientState->
        LastResponseLength should be set to the needed size.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;

    TraceFunc("OscVerifyLastResponseSize( )\n");

    if (clientState->LastResponseAllocated < clientState->LastResponseLength) {
        if (clientState->LastResponse) {
            BinlFreeMemory(clientState->LastResponse);
        }
        clientState->LastResponse = BinlAllocateMemory(clientState->LastResponseLength);
        if (clientState->LastResponse == NULL) {
            clientState->LastResponseAllocated = 0;
            BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not grow LastResponse to %ld bytes\n", clientState->LastResponseLength ));
            Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        } else {
            clientState->LastResponseAllocated = clientState->LastResponseLength;
        }
    }
    return Error;
}

DWORD
OscProcessNegotiate(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes a negotiate message.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    SECURITY_STATUS SecStatus;
    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;
    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;
    TimeStamp Lifetime;
    LOGIN_PACKET UNALIGNED * loginMessage = (LOGIN_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    PUCHAR TempChallengeBuffer;
    LOGIN_PACKET UNALIGNED * SendLoginMessage;


    TraceFunc("OscProcessNegotiate( )\n");

    //
    // First free anything we have allocated for this client. We
    // assume that each negotiate is a new request since the client
    // may have rebooted, so we don't resend the last response.
    //

    if (clientState->AuthenticatedDCLdapHandle) {
        //  Reconnecting again. Use new credentials.
        ldap_unbind(clientState->AuthenticatedDCLdapHandle);
        clientState->AuthenticatedDCLdapHandle = NULL;
    }
    if (clientState->UserToken) {
        CloseHandle(clientState->UserToken);
        clientState->UserToken = NULL;
    }

    if (clientState->NegotiateProcessed) {

        BinlPrintDbg(( DEBUG_OSC, "Got negotiate from client, reinitializing negotiate\n" ));

        SecStatus = DeleteSecurityContext( &clientState->ServerContextHandle );

        if ( SecStatus != STATUS_SUCCESS ) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "DeleteSecurityContext failed: %lx\n", SecStatus ));
            // This seems to fail if a previous logon failed, so ignore errors
            // return SecStatus;
        }

        clientState->NegotiateProcessed = FALSE;
    }

    if (clientState->AuthenticateProcessed) {

        BinlPrintDbg(( DEBUG_OSC, "Got negotiate from client, reinitializing authenticate\n"));

        clientState->AuthenticateProcessed = FALSE;
    }

    //
    // Once the client has logged in we need to worry about resending screens
    // if the client issues the request again. 0 is an invalid sequence
    // number, so set this to 0 to ensure that any stale LastResponse is
    // not resent.
    //

    clientState->LastSequenceNumber = 0;

    //
    // Get the ChallengeMessage (ServerSide)
    //

    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    TempChallengeBuffer = (PUCHAR)BinlAllocateMemory(PackageInfo->cbMaxToken);
    if (TempChallengeBuffer == NULL) {
        Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        BinlPrintDbg(( DEBUG_OSC, "Allocate TempChallengeBuffer failed\n"));
        return Error;
    }

    ChallengeBuffer.pvBuffer = TempChallengeBuffer;
    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = loginMessage->Length;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN | SECBUFFER_READONLY;
    NegotiateBuffer.pvBuffer = loginMessage->Data;

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT | ASC_REQ_ALLOW_NON_USER_LOGONS,
                    SECURITY_NATIVE_DREP,
                    &clientState->ServerContextHandle,
                    &ChallengeDesc,
                    &clientState->ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        if ( !NT_SUCCESS(SecStatus) ) {
            BinlPrintDbg(( DEBUG_OSC_ERROR, "AcceptSecurityContext (Challenge): %lx", SecStatus ));
            BinlFreeMemory(TempChallengeBuffer);
            return SecStatus;
        }
    }

    //
    // Send the challenge message back to the client.
    //

    clientState->LastResponseLength = ChallengeBuffer.cbBuffer + LOGIN_PACKET_DATA_OFFSET;
    Error = OscVerifyLastResponseSize(clientState);
    if (Error != ERROR_SUCCESS) {
        BinlFreeMemory(TempChallengeBuffer);
        return Error;
    }

    SendLoginMessage = (LOGIN_PACKET UNALIGNED *)(clientState->LastResponse);

    memcpy(SendLoginMessage->Signature, ChallengeSignature, 4);
    SendLoginMessage->Length = ChallengeBuffer.cbBuffer;
    memcpy(SendLoginMessage->Data, ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer);

    BinlFreeMemory(TempChallengeBuffer);

#ifdef TEST_FAILURE
    if (FailFirstChallenge) {
        BinlPrintDbg(( DEBUG_OSC, "NOT Sending CHL, %d bytes\n", clientState->LastResponseLength));
        FailFirstChallenge = FALSE;
        Error = ERROR_SUCCESS;
    } else
#endif
    Error = SendUdpMessage(RequestContext, clientState, FALSE, FALSE);

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not send CHAL message %d\n", Error));
    }

    clientState->NegotiateProcessed = TRUE;

    return Error;

}


DWORD
OscProcessAuthenticate(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes an authenticate message.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    SECURITY_STATUS SecStatus;
    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;
    TimeStamp Lifetime;
    LOGIN_PACKET UNALIGNED * loginMessage = (LOGIN_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    ULONG FlipServerListLength;
    LOGIN_PACKET UNALIGNED * SendLoginMessage;
    UCHAR TempServerList[MAX_FLIP_SERVER_COUNT*4];

    TraceFunc("OscProcessAuthenticate( )\n");

    //
    // Make sure we have gotten a negotiate.
    //

    if (!clientState->NegotiateProcessed) {

        BinlPrintDbg(( DEBUG_OSC_ERROR, "Received AUTH without NEG?\n"));
        return ERROR_INVALID_DATA;

    }

    //
    // If we have already responsed to this, just resend with the
    // same status.
    //

    if (clientState->AuthenticateProcessed) {

        SecStatus = clientState->AuthenticateStatus;

        BinlPrintDbg(( DEBUG_OSC, "Got authenticate from client, resending\n"));

    } else {

        //
        // Finally authenticate the user (ServerSide)
        //

        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = loginMessage->Length;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN | SECBUFFER_READONLY;
        AuthenticateBuffer.pvBuffer = loginMessage->Data;

        SecStatus = AcceptSecurityContext(
                        NULL,
                        &clientState->ServerContextHandle,
                        &AuthenticateDesc,
                        ASC_REQ_ALLOW_NON_USER_LOGONS,
                        SECURITY_NATIVE_DREP,
                        &clientState->ServerContextHandle,
                        NULL,
                        &clientState->ContextAttributes,
                        &Lifetime );

        FlipServerListLength = 0;

        if ( SecStatus != STATUS_SUCCESS ) {

            BinlPrintDbg(( DEBUG_OSC_ERROR, "AcceptSecurityContext (Challenge): %lx\n", SecStatus ));

        } else {

#if 0
            //
            // Impersonate the client.
            //

            SecStatus = ImpersonateSecurityContext( &clientState->ServerContextHandle );

            if ( SecStatus != STATUS_SUCCESS ) {
                BinlPrintDbg(( DEBUG_OSC_ERROR, "ImpersonateSecurityContext: %lx\n", SecStatus ));
                if ( !NT_SUCCESS(SecStatus) ) {
                    return SecStatus;
                }
            }
#endif
#if 0
            //
            // If the client is not indicating that he has been flipped, then
            // look for a flip list. The client indicates that he has been
            // flipped by using a signature of "AU2" instead of "AUT".
            //

            if (memcmp(loginMessage->Signature, AuthenticateFlippedSignature, 4) != 0) {

                OscGetFlipServerList(
                    TempServerList,
                    &FlipServerListLength
                    );
            }
#endif
#if 0
            //
            // Revert to ourselves.
            //

            SecStatus = RevertSecurityContext( &clientState->ServerContextHandle );

            if ( SecStatus != STATUS_SUCCESS ) {
                BinlPrintDbg(( DEBUG_OSC_ERROR, "RevertSecurityContext: %lx\n", SecStatus ));
                if ( !NT_SUCCESS(SecStatus) ) {
                    return SecStatus;
                }
            }
#endif
        }

        //
        // Send the result back to the client. If there is a flip server
        // list, it has already been stored after g_LoginMessage->Status and
        // FlipServerListLength reflects its length.
        //

        clientState->LastResponseLength = LOGIN_PACKET_DATA_OFFSET + sizeof(ULONG) + FlipServerListLength;
        Error = OscVerifyLastResponseSize(clientState);
        if (Error != ERROR_SUCCESS) {
            return Error;
        }

        SendLoginMessage = (LOGIN_PACKET UNALIGNED *)(clientState->LastResponse);

        memcpy(SendLoginMessage->Signature, ResultSignature, 4);
        SendLoginMessage->Length = 4 + FlipServerListLength;
        SendLoginMessage->Status = SecStatus;
        memcpy((PUCHAR)(&SendLoginMessage->Status) + sizeof(ULONG), TempServerList, FlipServerListLength);

        clientState->AuthenticateProcessed = TRUE;
        clientState->AuthenticateStatus = SecStatus;
    }

#ifdef TEST_FAILURE
    if (FailFirstResult) {
        BinlPrintDbg(( DEBUG_OSC, "NOT Sending OK, %d bytes\n", clientState->LastResponseLength));
        FailFirstResult = FALSE;
        Error = ERROR_SUCCESS;
    } else
#endif
    Error = SendUdpMessage(RequestContext, clientState, FALSE, FALSE);

    if (Error != ERROR_SUCCESS) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not send OK message %d\n", Error));
    }

    return Error;

}


//
//
//
DWORD
OscProcessScreenArguments(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PUCHAR *NameLoc
    )
{
    SIGNED_PACKET UNALIGNED * signedMessage = (SIGNED_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;
    PCHAR packetEnd = signedMessage->Data + signedMessage->Length - SIGNED_PACKET_EMPTY_LENGTH;
    DWORD Error = ERROR_SUCCESS;
    PCHAR Args;
    BOOLEAN GuidSent = FALSE;
    PDS_NAME_RESULTA pResults = NULL;

    TraceFunc("OscProcessScreenArguments( )\n");

    //
    // Find out the screen name and how long it is
    //
    *NameLoc = signedMessage->Data;
    Args = FindNext( *NameLoc, '\n', packetEnd );
    if ( Args == NULL )
    {
        BinlPrintDbg((DEBUG_OSC, "Could not determine the screen name."));
        *NameLoc = NULL;
        Error = ERROR_INVALID_DATA;
    }
    else
    {
        *Args = '\0';   // terminate

        //
        // The name can't have a ".." part in it.
        //

        if ((memcmp(*NameLoc, "..\\", 3) == 0) ||
            (strstr(*NameLoc, "\\..\\") != NULL)) {

            BinlPrintDbg((DEBUG_OSC, "Name <%s> has .. in it.", *NameLoc));
            *NameLoc = NULL;
            Error = ERROR_INVALID_DATA;

        } else {

            Args++;         // skip the NULL char

            //
            // Munge any variables that might have been passed back with it.
            // They come in like this:
            //    NextScreenName\nvariable=response\n....\nvariable=response\n\0
            //
            // If no arguments, it comes like:
            //    NextScreenName\n\0
            //
            while ( *Args )
            {
                PCHAR NextArg;
                PCHAR Response;
                PCHAR EncodedResponse;

                //
                // Find the variable name
                //
                Response = FindNext( Args, '=', packetEnd );
                if ( Response == NULL )
                {
                    BinlPrintDbg((DEBUG_OSC, "Could not find <variable>.\n" ));
                    Error = ERROR_INVALID_DATA;
                    break;
                }

                //
                // Find the variable response value
                //
                NextArg = FindNext( Response, '\n', packetEnd );
                if ( NextArg == NULL )
                {
                    BinlPrintDbg((DEBUG_OSC, "Could not find <response>.\n" ));
                    Error = ERROR_INVALID_DATA;
                    break;
                }

                //
                // Terminate strings
                //
                *NextArg = '\0';
                *Response = '\0';

                //
                // Point to response
                //
                Response++;
                NextArg++;

                //
                //
                // Add them to the Variable table.
                // If the variable starts with a '*', encode it first.
                //
                if (Args[0] == '*') {
                    Error = OscRunEncode(clientState, Response, &EncodedResponse);
                    if (Error == ERROR_SUCCESS) {
                        Error = OscAddVariableA( clientState, Args, EncodedResponse );
                        BinlFreeMemory(EncodedResponse);
                    }
                } else {

                    //
                    // Check whether this is the GUID variable. If it is, we'll
                    // need to do some special processing later. See below.
                    //

                    if ( Response[0] != '\0'
                      && StrCmpIA( Args, "GUID" ) == 0 )
                    {
                        GuidSent = TRUE;
                    }

                    // HACKHACK: Special case "MACHINEOU" for translation from canonical form
                    //           to 1779 so we can use it later.
                    if ( Response[0] != '\0'
                      && StrCmpIA( Args, "MACHINEOU" ) == 0 )
                    {
                        BOOL FirstTime = TRUE;
invalid_ds_handle:
                        // Make sure the handle is initialized
                        if ( BinlOscClientDSHandle == NULL )
                        {
                            HANDLE hTemp;
                            Error = DsBind(NULL, NULL, &hTemp);
                            InterlockedCompareExchangePointer( (void**)&BinlOscClientDSHandle, hTemp, NULL );
                            if ( BinlOscClientDSHandle != hTemp )
                            {
                                DsUnBind( &hTemp );
                            }
                        }

                        if ( Error == ERROR_SUCCESS )
                        {
                            Error = DsCrackNamesA( BinlOscClientDSHandle,
                                                   DS_NAME_NO_FLAGS,
                                                   DS_UNKNOWN_NAME,
                                                   DS_FQDN_1779_NAME,
                                                   1,
                                                   &Response,
                                                   &pResults );
                            BinlAssertMsg( Error == ERROR_SUCCESS, "Error in DsCrackNames\n" );

                            if ( Error == ERROR_SUCCESS ) {
                                if ( pResults->cItems == 1
                                  && pResults->rItems[0].status == DS_NAME_NO_ERROR
                                  && pResults->rItems[0].pName ) {    // paranoid
                                    Response = pResults->rItems[0].pName;
                                } else {
                                    //
                                    // check if we have an "external trust"
                                    // problem.  if that's the case, then we
                                    // need to bind to a DC in the domain we
                                    // care about and retrieve the information
                                    // from there.
                                    //
                                    if (pResults->cItems == 1 && pResults->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY) {
                                        HANDLE hDC;

                                        Error = MyGetDcHandle(clientState, pResults->rItems[0].pDomain,&hDC);
                                        if (Error == ERROR_SUCCESS) {
                                            DsFreeNameResultA( pResults );
                                            pResults = NULL;
                                            Error = DsCrackNamesA( 
                                                       hDC,
                                                       DS_NAME_NO_FLAGS,
                                                       DS_UNKNOWN_NAME,
                                                       DS_FQDN_1779_NAME,
                                                       1,
                                                       &Response,
                                                       &pResults );

                                            DsUnBindA(&hDC);

                                            if (Error != ERROR_SUCCESS) {
                                                BinlPrintDbg((
                                                    DEBUG_OSC_ERROR, 
                                                    "DsCrackNames failed, ec = %d.\n",
                                                    Error ));
                                            }

                                            if (Error == ERROR_SUCCESS ) {
                                                if ( pResults->cItems == 1
                                                  && pResults->rItems[0].status == DS_NAME_NO_ERROR
                                                  && pResults->rItems[0].pName ) {    // paranoid
                                                    Response = pResults->rItems[0].pName;
                                                } else {
                                                    BinlPrintDbg((
                                                        DEBUG_OSC, 
                                                        "pResults->rItems[0].status = %u\n", 
                                                        pResults->rItems[0].status ));
                                                    Error = pResults->rItems[0].status;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }


                        // DsCrackNamesA seems to return either ERROR_INVALID_HANDLE or RPC_S_CALL_FAILED 
                        // if the server is unavailable.  If we get either of these, assume the handle is
                        // stale and needs to be refreshed before we try again.
                        if ( (Error == ERROR_INVALID_HANDLE) || 
                             (Error == RPC_S_CALL_FAILED) ) {
                            HANDLE hTemp;
                            BinlPrintDbg((
                                DEBUG_ERRORS, 
                                "DsCrackNames returned a semi-expected error code.  Need to refresh handle.\n"
                                 ));
                            hTemp = InterlockedExchangePointer( (void**)&BinlOscClientDSHandle, NULL);
                            DsUnBind( &hTemp );
                            if (FirstTime) {
                                FirstTime = FALSE;
                                goto invalid_ds_handle;
                            }
                        }

                        if ( Error != ERROR_SUCCESS ) {
                            OscAddVariableA( clientState, "SUBERROR", Response );
                            return ERROR_BINL_UNABLE_TO_CONVERT_TO_DN;
                        }
                    }

                    Error = OscAddVariableA( clientState, Args, Response );
                    
                }

                if ( Error != ERROR_SUCCESS ) {
                    BinlPrintDbg(( DEBUG_OSC_ERROR,
                                "!!Error 0x%08x - Could not add argument '%s' = '%s'\n",
                                Error, Args, Response));
                    break;
                }

                BinlPrintDbg(( DEBUG_OSC, "Got argument '%s' = '%s'\n", Args, Response));

                if (pResults) {
                    DsFreeNameResultA( pResults );
                    pResults = NULL;
                }

                Args = NextArg;
            }
        }
    }

    //
    // If the GUID was sent in this message, check to see if it's all zeroes
    // or all FFs. If it is, substitute a MAC address-based GUID. This is the
    // same thing that we do when we receive DHCP packets with bogus GUIDs.
    // We need to do this here, otherwise we end up adding the client to the
    // DS with a bogus GUID. It seems that PXE 2.0 clients always send the
    // GUID option even when they have no real machine GUID.
    //
    // Note that we can't do this substitution in the loop above because we
    // might not have process the MAC address variable yet. (Currently
    // OSChooser always puts the MAC address ahead of the GUID in the packet,
    // but we don't want to depend on that.)
    //

    if ( GuidSent ) {

        //
        // A GUID was sent. Retrieve it. It should be there, but if it
        // isn't, just bail.
        //

        LPSTR guid = OscFindVariableA( clientState, "GUID" );
        DWORD length;

        if ( (guid != NULL) && ((length = strlen(guid)) != 0) ) {

            //
            // Check the GUID for all zeroes or all FFs.
            //

            if ( (strspn( guid, "0" ) == length) ||
                 (strspn( guid, "F" ) == length) ) {

                //
                // The GUID is bogus. Substitute a MAC address GUID.
                // We should have the MAC address at this point, but
                // if we don't, just bail.
                //

                LPSTR mac = OscFindVariableA( clientState, "MAC" );

                if ( mac != NULL ) {

                    //
                    // The generated GUID is zeroes followed by the
                    // MAC address. (In other words, the MAC address
                    // is right-justified in a 32-character string.)
                    //

                    UCHAR guidString[(BINL_GUID_LENGTH * 2) + 1];

                    length = strlen(mac);

                    if ( length > BINL_GUID_LENGTH * 2 ) {

                        //
                        // We have an unusually long MAC address.
                        // Use the last 32 characters.
                        //

                        mac = mac + length - (BINL_GUID_LENGTH * 2);
                        length = BINL_GUID_LENGTH * 2;
                    }

                    if ( length < BINL_GUID_LENGTH * 2 ) {

                        //
                        // Write zeroes in front of the MAC address.
                        //

                        memset( guidString, '0', (BINL_GUID_LENGTH * 2) - length );
                    }

                    //
                    // Copy the MAC address into the GUID (including the
                    // null terminator).
                    //

                    strcpy( guidString + (BINL_GUID_LENGTH * 2) - length, mac );

                    //
                    // Set the new GUID.
                    //

                    OscAddVariableA( clientState, "GUID", guidString );
                }
            }
        }
        
    }

    return Error;
}

//
//
//
DWORD
OscProcessRequestUnsigned(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes a request message.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    SIGNED_PACKET UNALIGNED * signedMessage = (SIGNED_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;

    PCHAR RspMessage = NULL;
    ULONG RspMessageLength = 0;
    ULONG k;

    WCHAR FilePath[ MAX_PATH ];
    HANDLE hfile;
    PCHAR NameLoc;

    TraceFunc("OscProcessRequestUnsigned( )\n");

    //
    // All clients start with at least one unsigned request. When we get an
    // unsigned request, the client may have rebooted and be asking for a
    // different screen with the same sequence number. To avoid having
    // to check for this, we don't bother resending unsigned screens. We
    // do save the incoming sequence number since we use that for sending
    // the response.
    //

    clientState->LastSequenceNumber = signedMessage->SequenceNumber;

    //
    // We have a valid request for a screen, process incoming arguments.
    //

    Error = OscProcessScreenArguments( RequestContext, clientState, &NameLoc );
    
    if ( Error != ERROR_SUCCESS ) {

        goto SendScreen;

    } else {
        //
        // If NULL message, then send down the welcome screen.
        //
        if ( NameLoc == NULL || *NameLoc == '\0' )
        {
            if ( _snwprintf( FilePath,
                             sizeof(FilePath) / sizeof(FilePath[0]),
                             L"%ws\\OSChooser\\%s",
                             IntelliMirrorPathW,
                             DEFAULT_SCREEN_NAME
                             ) == -1 ) {
                Error = ERROR_BAD_PATHNAME;
                goto SendScreen;
            }

            BinlPrint(( DEBUG_OSC, "NULL screen name so we are retrieving the Welcome Screen.\n"));

            //
            // This is the first request a client makes, which is a good
            // time to clean up the client state, unless we don't need to
            // (because the client state is new).
            //

            if (clientState->InitializeOnFirstRequest) {
                if (!OscInitializeClientVariables(clientState)) {
                    Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                    goto SendScreen;
                }
            }
        }
        else
        {
            WCHAR NameLocW[ MAX_PATH ];
            ULONG NameLocLength;

            //
            // Create path to possible OSC file. Should look something like:
            //  "D:\RemoteInstall\OSChooser\English\NameLoc.OSC"
            BinlAssert( NameLoc );

            NameLocLength = strlen(NameLoc) + 1;
            if (NameLocLength > MAX_PATH) {
                NameLocLength = MAX_PATH-1;
                NameLocW[ MAX_PATH-1 ] = L'\0';
            }

            mbstowcs( NameLocW, NameLoc, NameLocLength );

            if ( _snwprintf( FilePath,
                             sizeof(FilePath) / sizeof(FilePath[0]),
                             L"%ws\\OSChooser\\%ws\\%ws.OSC",
                             IntelliMirrorPathW,
                             OscFindVariableW( clientState, "LANGUAGE" ),
                             NameLocW
                             ) == -1 ) {
                Error = ERROR_BAD_PATHNAME;
                goto SendScreen;
            }
        }

        BinlPrint(( DEBUG_OSC, "Retrieving screen file: '%ws'\n", FilePath));

    }

    //
    // If we find the file, load it into memory.
    //
    hfile = CreateFile( FilePath, GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if ( hfile != INVALID_HANDLE_VALUE )
    {
        DWORD FileSize;
        //
        // Find out how big this screen is, if bigger than 0xFFFFFFFF we won't
        // display it.
        //
        FileSize = GetFileSize( hfile, NULL );
        if ( FileSize != 0xFFFFffff )
        {
            DWORD dwRead = 0;

            RspMessage = BinlAllocateMemory( FileSize + 3 );
            if ( RspMessage == NULL )
            {
                Error = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            }
            else
            {
                RspMessageLength = 0;
                RspMessage[0] = '\0';

                while ( dwRead != FileSize )
                {
                    BOOL b;
                    DWORD dw;
                    b = ReadFile( hfile, &RspMessage[dwRead], FileSize - dwRead, &dw, NULL );
                    if (!b)
                    {
                        BinlPrintDbg(( DEBUG_OSC_ERROR, "Error reading screen file: Seek=%u, Size=%u, File=%ws\n",
                                    dwRead, FileSize - dwRead, FilePath ));
                        Error = GetLastError( );
                        break;
                    }
                    dwRead += dw;
                }

                RspMessageLength = dwRead;
            }
        }
        else
        {
            BinlPrintDbg((DEBUG_OSC, "!!Error - Could not determine file size.\n"));
            Error = GetLastError();
        }

        CloseHandle( hfile );
    }
    else
    {
        BinlPrintDbg((DEBUG_OSC, "!!Error - Did not find screen file: '%ws'\n", FilePath));
        Error = GetLastError();
        OscAddVariableW( clientState, "SUBERROR", FilePath );
    }

SendScreen:
    //
    // If there were any errors, switch to the error screen.
    //
    if ( Error != ERROR_SUCCESS )
    {
        //
        // Send down message about the failure.
        //
        if ( RspMessage )
        {
            BinlFreeMemory( RspMessage );
            RspMessage = NULL; // paranoid
        }

        BinlPrintDbg((DEBUG_OSC, "!!Error - Sending error screen back to client. Server error=0x%08x\n", Error));

        Error = GenerateErrorScreen( &RspMessage,
                                     &RspMessageLength,
                                     Error,
                                     clientState );
        BinlAssert( Error == ERROR_SUCCESS );
        if ( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // Require them to re-login.
        //
        // clientState->AuthenticateProcessed = FALSE;
    }

    if (RspMessage) {

        // Do replacements for dynamic screens or error screens
        SearchAndReplace( clientState->Variables,
                          &RspMessage,
                          clientState->nVariables,
                          RspMessageLength,
                          0);
        RspMessageLength = strlen( RspMessage ) + 1;
        RspMessage[RspMessageLength-1] = '\0';  // paranoid
    }

    //
    // Send out a signed response
    //
    BinlAssert( RspMessage );
    // BinlPrint((DEBUG_OSC, "Sending Unsigned:\n%s\n", RspMessage));

    OscSendUnsignedMessage( RequestContext, clientState, RspMessage, RspMessageLength );

Cleanup:
    //
    // Free any memory the we allocated for the screen.
    //
    if ( RspMessage ) {
        BinlFreeMemory( RspMessage );
    }

    return Error;
}

//
//
//
OscInstallClient(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCREATE_DATA createData )
{
    DWORD Error;

    //
    // Client wants to create a machine account and run setup.
    //
    Error = OscSetupClient( clientState, TRUE );

    if ( Error == ERROR_SUCCESS  )
    {
        //
        // Only create the account if the setup went OK.
        //
RetryCreateAccount:
        Error = OscCreateAccount( clientState, createData );
        switch ( Error )
        {
        case ERROR_BINL_DUPLICATE_MACHINE_NAME_FOUND:
            if ( clientState->fAutomaticMachineName ) {

                // Try generating another name
                Error = GenerateMachineName( clientState );
                if ( Error == ERROR_SUCCESS ) {
                    goto RetryCreateAccount;
                }
                BinlPrint(( DEBUG_OSC_ERROR, "!!Error 0x%08x - Failed to generate machine name\n" ));
            }
            break;

        default:
            break;
        }
    }

#ifdef SET_ACLS_ON_CLIENT_DIRS
    if ( Error == ERROR_SUCCESS )
    {
        //
        // Change the ACL permission of the client machine's root directory
        //
        Error = OscSetClientDirectoryPermissions( clientState );
    }
#endif // SET_ACLS_ON_CLIENT_DIRS

    if ( Error != ERROR_SUCCESS )
    {
        OscUndoSetupClient( clientState );

        BinlPrint((DEBUG_OSC,
                   "!!Error 0x%08x - Error setting up the client for Setup.\n",
                   Error ));
    }

    return Error;
}

//
// OscGetCreateData( )
//
// Queries the DS to get the information required to create
// the CreateData secret and then builds one.
//
DWORD
OscGetCreateData(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState,
    PCREATE_DATA CreateData)
{
    DWORD Error = ERROR_BINL_INVALID_BINL_CLIENT;
    PCHAR pGuid;
    PWCHAR pGuidW;
    UCHAR Guid[ BINL_GUID_LENGTH ];
    WCHAR  BootFilePath[MAX_PATH];
    PMACHINE_INFO pMachineInfo = NULL;
    WCHAR  MachinePassword[LM20_PWLEN + 1];
    WCHAR  SifPath[MAX_PATH];
    WCHAR  SifFile[(BINL_GUID_LENGTH*2)+(sizeof(TEMP_DIRECTORY)/sizeof(WCHAR))+6];
    DWORD  FileAttributes;
    ULONG  MachinePasswordLength;
    DWORD  dwRequestedInfo = MI_NAME | MI_BOOTFILENAME | MI_MACHINEDN | MI_SAMNAME;
    PWCHAR pszOU;
    USHORT SystemArchitecture;
    DWORD  OldFlags;
    ULONG  lenIntelliMirror = wcslen(IntelliMirrorPathW) + 1;
    
    pGuid = OscFindVariableA( clientState, "GUID" );
    if ( pGuid[0] == '\0' ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: could not find GUID" ));
        OscAddVariableA( clientState, "SUBERROR", "GUID" );
        Error = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    pGuidW = OscFindVariableW( clientState, "GUID" );
    if ( pGuidW[0] == L'\0' ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: could not find GUID (unicode)" ));
        OscAddVariableA( clientState, "SUBERROR", "GUID" );
        Error = ERROR_BINL_MISSING_VARIABLE;
        goto e0;
    }

    Error = OscGuidToBytes( pGuid, Guid );
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: OscGuidToBytes failed" ));
        goto e0;
    }

    SystemArchitecture = OscPlatformToArchitecture(clientState);
    
    Error = GetBootParameters( Guid,
                               &pMachineInfo,
                               dwRequestedInfo,
                               SystemArchitecture,
                               FALSE );
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: GetBootParameters failed %lx", Error ));
        goto e0;
    }

    BinlAssertMsg(( pMachineInfo->dwFlags & dwRequestedInfo )== dwRequestedInfo, "Missing info." );

    //
    // The SIF file is named GUID.sif, and it must exist (the SIF
    // files go in a tmp directory so an admin may have cleaned it
    // out).
    //

    wsprintf( SifFile, L"%ws\\%ws.sif", TEMP_DIRECTORY, pGuidW );

    if ( _snwprintf( SifPath,
                     sizeof(SifPath) / sizeof(SifPath[0]),
                     L"%ws\\%ws",
                     IntelliMirrorPathW,
                     SifFile
                     ) == -1 ) {
        Error = ERROR_BAD_PATHNAME;
        goto e0;
    }

    FileAttributes = GetFileAttributes(SifPath);
    if (FileAttributes == 0xFFFFFFFF) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: SifFile not found" ));
        OscAddVariableW( clientState, "SUBERROR", SifPath );
        Error = ERROR_BINL_SIFFILE_NOT_FOUND;
        goto e0;
    }

    //
    // The bootfile stored in pMachineInfo->BootFileName will point to
    // oschooser, so we parse the SIF to find the setupldr boot file.
    //

    BootFilePath[0] = L'\0';
    GetPrivateProfileString( OSCHOOSER_SIF_SECTIONW,
                             L"LaunchFile",
                             BootFilePath, // default
                             BootFilePath,
                             MAX_PATH,
                             SifPath );

    //
    // This might fail to add if it is too long due to bogus data in the .sif.
    //
    Error = OscAddVariableW( clientState, "BOOTFILE",  BootFilePath );
    if ( Error != ERROR_SUCCESS ) {
        goto e0;
    }

    //
    // This might fail to add if it is too long due to bogus data in the DS.
    //

    if (pMachineInfo->dwFlags & MI_SIFFILENAME_ALLOC) {
        
        Error = OscAddVariableW( clientState, "FORCESIFFILE",  pMachineInfo->ForcedSifFileName );
        if ( Error != ERROR_SUCCESS ) {
            goto e0;
        }

    }
    //
    // These next two shouldn't fail unless someone has modified the DS by
    // hand, since they are checked when the accounts are generated, but
    // best to be safe.
    //
    Error = OscAddVariableW( clientState, "NETBIOSNAME",   pMachineInfo->SamName );
    if ( Error != ERROR_SUCCESS) {
        goto e0;
    }
    Error = OscAddVariableW( clientState, "MACHINENAME",   pMachineInfo->Name );
    if ( Error != ERROR_SUCCESS) {
        goto e0;
    }

    //
    // Shouldn't fail unless the IntelliMirrorPathW is too long.
    //
    Error = OscAddVariableW( clientState, "SIFFILE",       &SifPath[lenIntelliMirror]  );
    if ( Error != ERROR_SUCCESS) {
        goto e0;
    }

    pszOU = wcschr( pMachineInfo->MachineDN, L',' );
    if (pszOU)
    {
        pszOU++;
        Error = OscAddVariableW( clientState, "MACHINEOU", pszOU );
        if ( Error != ERROR_SUCCESS ) {
            goto e0;
        }
    }


    Error = OscSetupMachinePassword( clientState, SifPath );
    if (Error != ERROR_SUCCESS) {
        goto e0;
    }

    //
    // save off the old flags so we can update the machine account information
    //
    OldFlags = pMachineInfo->dwFlags;

    pMachineInfo->dwFlags        = MI_PASSWORD | MI_MACHINEDN;
    pMachineInfo->Password       = clientState->MachineAccountPassword;
    pMachineInfo->PasswordLength = clientState->MachineAccountPasswordLength;

    Error = UpdateAccount( clientState, pMachineInfo, FALSE );
    if ( Error != LDAP_SUCCESS ) {
        BinlPrintDbg(( DEBUG_OSC_ERROR, "!! LdapError 0x%08x - UpdateAccount( ) failed.\n", Error ));
        goto e0;
    }

    pMachineInfo->dwFlags |= OldFlags;  // add them back
    
    Error = OscConstructSecret( 
                    clientState, 
                    clientState->MachineAccountPassword, 
                    clientState->MachineAccountPasswordLength, 
                    CreateData );
    if ( Error != ERROR_SUCCESS ) {
        BinlPrintDbg((DEBUG_OSC_ERROR, "OscGetCreateData: OscConstructSecret failed %lx", Error ));
        goto e0;
    }

e0:
    if (pMachineInfo) {

        BinlDoneWithCacheEntry( pMachineInfo, FALSE );
    }

    return Error;
}

//
//
//
DWORD
OscProcessRequestSigned(
    LPBINL_REQUEST_CONTEXT RequestContext,
    PCLIENT_STATE clientState
    )
/*++

Routine Description:

    This function processes a request message.
    IT IS CALLED WITH clientState->CriticalSection HELD.

Arguments:

    RequestContext - A pointer to the BinlRequestContext block for
        this request.

    clientState - The client state for the remote.

Return Value:

    Windows Error.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    SIGNED_PACKET UNALIGNED * signedMessage = (SIGNED_PACKET UNALIGNED *)RequestContext->ReceiveBuffer;

    PCHAR RspMessage = NULL;
    ULONG RspMessageLength = 0;
    PCHAR RspBinaryData = NULL;
    ULONG RspBinaryDataLength = 0;
    ULONG k;
    DWORD dwErr;

    WCHAR FilePath[ MAX_PATH ];
    CHAR TmpName[ 16 ];
    HANDLE hfile;
    PCHAR NameLoc;

    LPSTR psz;

    TraceFunc("OscProcessRequestSigned( )\n");

    if ( clientState->AuthenticateProcessed == FALSE )
    {
        SIGNED_PACKET UNALIGNED * SendSignedMessage;

        //
        // This may happen if we reboot the server -- send an ERRS
        // and the client should reconnect OK.
        //

        BinlPrintDbg(( DEBUG_OSC_ERROR, "Got REQ but not authenticated, sending UNR\n" ));

        clientState->LastResponseLength = SIGNED_PACKET_ERROR_LENGTH;
        Error = OscVerifyLastResponseSize(clientState);
        if (Error != ERROR_SUCCESS) {
            return Error;
        }

        SendSignedMessage =
            (SIGNED_PACKET UNALIGNED *)(clientState->LastResponse);
        memcpy(SendSignedMessage->Signature, UnrecognizedClientSignature, 4);
        SendSignedMessage->Length = 4;
        SendSignedMessage->SequenceNumber = signedMessage->SequenceNumber;

        Error = SendUdpMessage( RequestContext, clientState, FALSE, FALSE );
        return Error;
    }

    if ( signedMessage->SequenceNumber == clientState->LastSequenceNumber )
    {
        //
        // Is the signature the same as the last one we sent out? If so,
        // then just resend (we'll do that after we leave this if
        // statement).
        //

        if ( clientState->LastResponse )
        {
            BinlPrintDbg(( DEBUG_OSC, "Resending last message\n" ));
        }
        else
        {
            //
            // We were unable to save the last response -- we are hosed!
            //
            BinlPrintDbg(( DEBUG_OSC_ERROR, "Could not resend last message\n" ));
            return ERROR_NOT_ENOUGH_SERVER_MEMORY;
        }

        //
        // Resend last response
        //
        return SendUdpMessage( RequestContext,
                                  clientState,
                                  TRUE,
                                  TRUE );

    }
    else if ( signedMessage->SequenceNumber != ((clientState->LastSequenceNumber % 0x2000) + 1))
    {
        //
        // It's not the next message - ignore it.
        //

        BinlPrintDbg(( DEBUG_OSC, "got bogus sequence number: Got %u. Expected: %u\n",
            signedMessage->SequenceNumber , ((clientState->LastSequenceNumber % 0x2000) + 1)));
        return ERROR_INVALID_DATA;
    }

    //
    // Advance the clientState sequence counter
    //
    clientState->LastSequenceNumber = signedMessage->SequenceNumber;

    //
    // Verify packet signature
    //
    Error = OscVerifySignature( clientState, signedMessage );
    if ( Error != STATUS_SUCCESS )
        return Error;

    //
    // We have a valid request for a screen.
    //
    if (signedMessage->Length == (SIGNED_PACKET_EMPTY_LENGTH))
    {
        //
        // An empty packet indicates to us to send down the Welcome screen.
        //
        if ( _snwprintf( FilePath,
                         sizeof(FilePath) / sizeof(FilePath[0]),
                         L"%ws\\OSChooser\\%s",
                         IntelliMirrorPathW,
                         DEFAULT_SCREEN_NAME
                         ) == -1 ) {
            Error = ERROR_BAD_PATHNAME;

        } else {

            BinlPrintDbg(( DEBUG_OSC, "Retrieving Welcome Screen: %ws\n", FilePath));
        }
    }
    else
    {
        //
        // Process incoming arguments and get the next screen's name
        //
        Error = OscProcessScreenArguments( RequestContext, clientState, &NameLoc );

GrabAnotherScreen:
        //
        // Process special responses.
        //
        // INSTALL:     Indicates that user wants to create a new machine.
        // RESTART:     Indicates the client wants to restart setup.
        //
        if ( Error == ERROR_SUCCESS )
        {
            PWCHAR pCheckDomain = OscFindVariableW( clientState, "CHECKDOMAIN" );
            if (pCheckDomain[0] == L'1')
            {
                //
                // After the first login, the client will set this to
                // tell us to verify that the domain name used in this
                // context matches what the user requested. This will
                // prevent an invalid domain from being let through
                // due to SSPI using the default domain in that case.
                //

                BOOLEAN failedCheck = FALSE;
                DWORD impersonateError;
                PWCHAR pUserDomain = OscFindVariableW( clientState, "USERDOMAIN" );

                if ( pUserDomain[0] != L'\0' )
                {
                    SecPkgCredentials_Names names;
                    SECURITY_STATUS secStatus;
                    PWCHAR backslash;
                    PWSTR netbiosUserDomain = NULL;
                    DWORD Flags;

                    secStatus = QueryContextAttributes(
                                    &clientState->ServerContextHandle,
                                    SECPKG_CRED_ATTR_NAMES,
                                    &names);

                    if (secStatus == STATUS_SUCCESS) {

                        //
                        // The part up to the '\\' is the domain.
                        //

                        backslash = wcschr(names.sUserName, L'\\');
                        if (backslash != NULL) {
                            *backslash = L'\0';
                        }

                        if (ERROR_SUCCESS != GetDomainNetBIOSName(pUserDomain,&netbiosUserDomain)) {
                            Error = ERROR_BINL_USER_LOGIN_FAILED;
                            failedCheck = TRUE;
                        } else {
                        
    
                            //
                            // If the domain names don't match, then the login
                            // succeeded due to the security package trying the
                            // server's domain name. We don't want to let those
                            // through since the LogonUser call will eventually
                            // fail. So fail right here.
                            //
    
                            if (_wcsicmp(netbiosUserDomain, names.sUserName) != 0) {
    
                                Error = ERROR_BINL_USER_LOGIN_FAILED;
                                failedCheck = TRUE;
    
                            }

                        }

                        if (netbiosUserDomain) {
                            BinlFreeMemory( netbiosUserDomain );
                        }

                        FreeContextBuffer(names.sUserName);      