lue = lpConf->DisconnectProviderIndication (connection_handle);

		/*
		**	Once a conference deletes a connection handle there is no
		**	need to continue in the iterator.  Connection Handles
		**	are specific to only one conference. We decided not to
		**	keep a connection handle list in both the controller and
		**	conference for resource reasons.
		*/
		if (error_value == GCC_NO_ERROR)
			break;
	}

	TRACE_OUT(("Controller::ProcessDisconnectProviderIndication: "
				"Sending ConnectionBrokenIndication"));
	g_pControlSap->ConnectionBrokenIndication(connection_handle);

	return error_value;
}

//	Utility functions used by the controller class


/*
 *	GCCController::AllocateConferenceID()	
 *
 *	Private Function Description
 *		This routine is used to generate a unique Conference ID.
 *
 *	Formal Parameters:
 *		None
 *
 *	Return Value
 *		The generated unique conference ID.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCConfID GCCController::AllocateConferenceID(void)
{
	/*
	 *	This loop simply increments a rolling number, looking for the next
	 *	one that is not already in use.
	 */

	do
	{
		m_ConfIDCounter = ((m_ConfIDCounter + 1) % MAXIMUM_CONFERENCE_ID_VALUE) + MINIMUM_CONFERENCE_ID_VALUE;
    }
        while (NULL != m_ConfList2.Find(m_ConfIDCounter));

	return m_ConfIDCounter;
}


/*
 *	GCCController::AllocateQueryID()	
 *
 *	Private Function Description
 *		This routine is used to generate a unique Query ID
 *
 *	Formal Parameters:
 *		None
 *
 *	Return Value
 *		The generated unique query ID.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCConfID GCCController::AllocateQueryID()
{
	GCCConfID   test_query_id, nConfID;
	
	/*
	 *	This loop simply increments a rolling number, looking for the next
	 *	one that is not already in use.
	 */

	while (1)
	{
        m_QueryIDCounter = ((m_QueryIDCounter + 1) % MAXIMUM_QUERY_ID_VALUE) + MINIMUM_QUERY_ID_VALUE;

		// If this handle is not in use, break from the loop and use it.
		m_PendingQueryConfList2.Reset();
		
		/*
		**	Check the outstanding query request list to make sure that no
		**	queries are using this ID.
		*/
		test_query_id = 0;													
		while (GCC_INVALID_CID != (nConfID = m_PendingQueryConfList2.Iterate()))
		{
			if (nConfID == m_QueryIDCounter)
			{
				test_query_id = nConfID;
				break;
			}
		}
		
		//	Break if the ID is not in use.
		if (test_query_id == 0)
			break;
	}

	return m_QueryIDCounter;
}



/*
 *	GCCController::GetConferenceIDFromName()
 *
 *	Private Function Description
 *		This call returns the conference Id associated with a conference
 *		name and modifier.
 *
 *	Formal Parameters:
 *		conference_name		-	(i)	Pointer to conference name structure to
 *									search on.
 *		conference_modifier	-	(i)	The conference name modifier to search on.
 *
 *	Return Value
 *		The conference ID associated with the specified name.
 *		0 if the name does not exists.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		We must iterate on the m_ConfList2 instead of the 
 *		m_ConfPollList here to insure that the list is accurate.  It
 *		is possible for the m_ConfList2 to change while the 
 *		m_ConfPollList is being iterated on followed by something like
 *		a join request.  If you don't use the m_ConfList2 here the name
 *		would still show up even after it had been terminated.
 */
GCCConfID GCCController::GetConferenceIDFromName(
									PGCCConferenceName 		conference_name,
									GCCNumericString		conference_modifier)
{
	GCCConfID   			conference_id = 0;
	LPSTR					pszNumericName;
	LPWSTR					text_name_ptr;
	LPSTR					pszConfModifier;
	PConference				lpConf;

	m_ConfList2.Reset();
	while (NULL != (lpConf = m_ConfList2.Iterate()))
	{
		pszNumericName = lpConf->GetNumericConfName();
		text_name_ptr = lpConf->GetTextConfName();
		pszConfModifier = lpConf->GetConfModifier();

		/*
		**	First check the conference name.  If both names are used we must
		**	determine if there is a match on either name.  If so the 
		**	conference is a match.  We do this because having either correct
		**	name will be interpreted as a match in a join request.
		**		
		*/
		if ((conference_name->numeric_string != NULL) &&
			(conference_name->text_string != NULL))
		{
			if (text_name_ptr != NULL)
			{
				if ((0 != lstrcmpA(pszNumericName, conference_name->numeric_string)) &&
					(0 != My_strcmpW(text_name_ptr, conference_name->text_string)))
					continue;
			}
			else
				continue;
		}
		else if (conference_name->numeric_string != NULL)
		{
			if (0 != lstrcmpA(pszNumericName, conference_name->numeric_string))
				continue;
		}
		else
		{
			if (text_name_ptr != NULL)
			{
				if (0 != My_strcmpW(text_name_ptr, conference_name->text_string))
					continue;
			}
			else
			{
				TRACE_OUT(("GCCController: GetConferenceIDFromName: Text Conference Name is NULL: No Match"));
				continue;
			}
		}

		//	Next check the conference modifier
		TRACE_OUT(("GCCController: GetConferenceIDFromName: Before Modifier Check"));
		if (conference_modifier != NULL)
		{
			if (pszConfModifier != NULL)
			{
				if (0 != lstrcmpA(pszConfModifier, conference_modifier))
				{
					TRACE_OUT(("GCCController: GetConferenceIDFromName: After Modifier Check"));
					continue;
				}
				else
				{
					TRACE_OUT(("GCCController: GetConferenceIDFromName: Name match was found"));
				}
			}
			else
			{
				TRACE_OUT(("GCCController: GetConferenceIDFromName: Conference Modifier is NULL: No Match"));
				continue;
			}
		}
		else if (pszConfModifier != NULL)
			continue;
		
		/*
		**	If we get this far then we have found the correct conference.
		**	Go ahead and get the conference id and then break out of the
		**	search loop.
		*/
		conference_id = lpConf->GetConfID();
		break;
	}

	return (conference_id);
}


//
// Called from the SAP window procedure.
//
void GCCController::
WndMsgHandler ( UINT uMsg )
{
    if (GCTRL_REBUILD_CONF_POLL_LIST == uMsg)
    {
        if (m_fConfListChangePending)
        {
            CConf *pConf;

            m_fConfListChangePending = FALSE;
            m_ConfPollList.Clear();

            //	Delete any outstanding conference objects
            m_ConfDeleteList.DeleteList();

            //	Create a new conference poll list		
            m_ConfList2.Reset();
            while (NULL != (pConf = m_ConfList2.Iterate()))
            {
                m_ConfPollList.Append(pConf);
            }
        }

        //
        // Flush any pending PDU.
        //
        FlushOutgoingPDU();
    }
    else
    {
        ERROR_OUT(("GCCController::WndMsgHandler: invalid msg=%u", uMsg));
    }
}


//
// Rebuild the conf poll list in the next tick.
//
void GCCController::
PostMsgToRebuildConfPollList ( void )
{
    if (NULL != g_pControlSap)
    {
        ::PostMessage(g_pControlSap->GetHwnd(), GCTRL_REBUILD_CONF_POLL_LIST, 0, (LPARAM) this);
    }
    else
    {
        ERROR_OUT(("GCCController::PostMsgToRebuildConfPollList: invalid control sap"));
    }
}


//
// Enumerate all conferences and flush their pending outgoing PDUs to MCS.
//
BOOL GCCController::
FlushOutgoingPDU ( void )
{
    BOOL    fFlushMoreData = FALSE;
    CConf   *pConf;

    m_ConfPollList.Reset();
    while (NULL != (pConf = m_ConfPollList.Iterate()))
    {
        fFlushMoreData |= pConf->FlushOutgoingPDU();
    }

    return fFlushMoreData;
}


//
// Called from MCS work thread.
//
BOOL GCCRetryFlushOutgoingPDU ( void )
{
    BOOL    fFlushMoreData = FALSE;

    //
    // Normally, we should get to here because it is very rarely
    // that there is a backlog in MCS SendData. We are using local memory.
    // It will be interesting to note that we are having a backlog here.
    //
    TRACE_OUT(("GCCRetryFlushOutgoingPDU: ============"));

    //
    // We have to enter GCC critical section because
    // we are called from MCS work thread.
    //
    ::EnterCriticalSection(&g_csGCCProvider);
    if (NULL != g_pGCCController)
    {
        fFlushMoreData = g_pGCCController->FlushOutgoingPDU();
    }
    ::LeaveCriticalSection(&g_csGCCProvider);

    return fFlushMoreData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\invoklst.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	invoklst.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class
 *		CInvokeSpecifierListContainer.  This class manages the data associated
 *		with an Application Invoke Request or Indication.  This includes a list
 *		of applications to be invoked.  The CInvokeSpecifierListContainer data
 *		container utilizes a CSessKeyContainer container to buffer part of the data
 *		associated with each application invoke specifier.  Each application
 *		invoke specifier also includes a capability ID whose data is buffered
 *		internally by the using a CCapIDContainer container.  The list
 *		of application invoke specifiers is maintained internally by the class
 *		through the use of a Rogue Wave list container.
 *
 *	Protected Instance Variables:
 *		m_InvokeSpecifierList
 *			List of structures used to hold the container data internally.
 *		m_pAPEListPDU
 *			Storage for the "PDU" form of the invoke data.
 *		m_fValidAPEListPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" invoke data.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */

#include "ms_util.h"
#include "invoklst.h"

/*
 *	CInvokeSpecifierListContainer ()
 *
 *	Public Function Description:
 *		This constructor is used to create an CInvokeSpecifierListContainer
 * 		object from a list of "API" application protocol entities.
 */
CInvokeSpecifierListContainer::CInvokeSpecifierListContainer(	
						UINT						number_of_protocol_entities,
						PGCCAppProtocolEntity *	 	app_protocol_entity_list,
						PGCCError					pRetCode)
:
    CRefCount(MAKE_STAMP_ID('I','S','L','C')),
    m_fValidAPEListPDU(FALSE),
    m_cbDataSize(0)
{
	UINT					i;
	PGCCAppProtocolEntity	ape;
	INVOKE_SPECIFIER        *specifier_info;

	/*
	 * Initialize instance variables.
	 */
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Go through the list of application protocol entities (APE's), saving the
	 * necessary information in the internal list of info. structures.
	 */
	for (i = 0; i < number_of_protocol_entities; i++)
	{
		/*
		 * Create a new INVOKE_SPECIFIER structure to hold the data for this
		 * APE.  Check to make sure it was successfully created.
		 */
		DBG_SAVE_FILE_LINE
		specifier_info = new INVOKE_SPECIFIER;
		if (specifier_info != NULL)
		{
			/*
			 * Get the APE from the list.
			 */
			ape = app_protocol_entity_list[i];

			/*
			 * Create a new CSessKeyContainer object to hold the session key.
			 * Check to	make sure construction was successful.
			 */
			DBG_SAVE_FILE_LINE
			specifier_info->session_key = new CSessKeyContainer(&ape->session_key, &rc);
			if ((specifier_info->session_key != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * Save the startup channel type and "invoke" flag.
				 */
				specifier_info->startup_channel_type =ape->startup_channel_type;
				specifier_info->must_be_invoked = ape->must_be_invoked;

				/*
				 * Save the capabilities list for this APE in the internal info.
				 * structure.
				 */
				rc = SaveAPICapabilities(specifier_info,
										ape->number_of_expected_capabilities,
										ape->expected_capabilities_list);

				/*
				 * Insert the new invoke specifier info structure pointer into
				 * the internal list if no error condition exists.
				 */
				if (rc == GCC_NO_ERROR)
				{
					m_InvokeSpecifierList.Append(specifier_info);
				}
				else
				{
					ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error saving caps"));
					break;
				}
			}
			else if (specifier_info->session_key == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error creating CSessKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
			else
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error creating CSessKeyContainer"));
				specifier_info->session_key->Release();
				delete specifier_info;
				break;
			}
		}
		else
		{
			ERROR_OUT(("CInvokeSpecifierListContainer::Construc1: Error creating INVOKE_SPECIFIER"));
			break;
		}
	}

	*pRetCode = rc;
}

/*
 *	CInvokeSpecifierListContainer ()
 *
 *	Public Function Description:
 *		This constructor is used to create an CInvokeSpecifierListContainer
 *		object from	a "PDU" ApplicationProtocolEntityList.
 */
CInvokeSpecifierListContainer::CInvokeSpecifierListContainer (
					PApplicationProtocolEntityList	 	protocol_entity_list,
					PGCCError							pRetCode)
:
    CRefCount(MAKE_STAMP_ID('I','S','L','C')),
    m_fValidAPEListPDU(FALSE),
    m_cbDataSize(0)
{
	ApplicationInvokeSpecifier		specifier;
	INVOKE_SPECIFIER                *specifier_info;

	GCCError rc = GCC_NO_ERROR;

	while (protocol_entity_list != NULL)
	{
		/*
		 * Create a new INVOKE_SPECIFIER structure to hold the data for this
		 * APE.  Check to make sure it was successfully created.
		 */
		DBG_SAVE_FILE_LINE
		specifier_info = new INVOKE_SPECIFIER;
		if (specifier_info != NULL)
		{
			specifier = protocol_entity_list->value;

			/*
			 * Create a CSessKeyContainer object to hold the session key
			 * internally.  Check to make sure the object is successfully
			 * created.
			 */
			DBG_SAVE_FILE_LINE
			specifier_info->session_key = new CSessKeyContainer(&specifier.session_key, &rc);
			if ((specifier_info->session_key != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * The session key was saved correctly so check to see if a list
				 * of expected capabilities is present and save them if so.
				 */
				if (specifier.bit_mask & EXPECTED_CAPABILITY_SET_PRESENT)
				{
					rc = SavePDUCapabilities(specifier_info, specifier.expected_capability_set);
					if (rc != GCC_NO_ERROR)
					{
						specifier_info->session_key->Release();
						delete specifier_info;
						break;
					}
				}

				/*
				 * Save the startup channel type.  If the channel type is not
				 * present in the PDU then set the channel type in the info
				 * strucuture equal to MCS_NO_CHANNEL_TYPE_SPECIFIED;
				 */
				if (specifier.bit_mask & INVOKE_STARTUP_CHANNEL_PRESENT)
				{
					switch (specifier.invoke_startup_channel)
                    {
                    case CHANNEL_TYPE_STATIC:
						specifier_info->startup_channel_type = MCS_STATIC_CHANNEL;
                        break;
                    case DYNAMIC_MULTICAST:
						specifier_info->startup_channel_type = MCS_DYNAMIC_MULTICAST_CHANNEL;
                        break;
                    case DYNAMIC_PRIVATE:
						specifier_info->startup_channel_type = MCS_DYNAMIC_PRIVATE_CHANNEL;
                        break;
                    case DYNAMIC_USER_ID:
						specifier_info->startup_channel_type = MCS_DYNAMIC_USER_ID_CHANNEL;
                        break;
					}
				}
				else
				{
					specifier_info->startup_channel_type = MCS_NO_CHANNEL_TYPE_SPECIFIED;
				}

				/*
				 * Insert the new invoke specifier info structure pointer into
				 * the internal list if no error condition exists.
				 */
				m_InvokeSpecifierList.Append(specifier_info);
			}
			else if (specifier_info->session_key == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::Construc2: Error creating CSessKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
			else
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::Construc2: Error creating CSessKeyContainer"));
				specifier_info->session_key->Release();
				delete specifier_info;
				break;
			}

			/*
			 * Retrieve the next APE in the list.
			 */
			protocol_entity_list = protocol_entity_list->next;
		}
		else
		{
			ERROR_OUT(("CInvokeSpecifierListContainer::Construc2: Error creating INVOKE_SPECIFIER"));
			break;
		}
	}

	*pRetCode = rc;
}

/*
 *	~CInvokeSpecifierListContainer	()
 *
 *	Public Function Description
 *		The CInvokeSpecifierListContainer destructor is responsible for
 *		freeing any memory allocated to hold the invoke data.
 *
 */
CInvokeSpecifierListContainer::~CInvokeSpecifierListContainer(void)
{
	INVOKE_SPECIFIER *lpInvSpecInfo;

    /*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidAPEListPDU)
		FreeApplicationInvokeSpecifierListPDU ();

	/*
	 * Delete any data containers held internally in the list of info.
	 * structures by iterating through the internal list.
	 */
	m_InvokeSpecifierList.Reset();
 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
	{
		/*
		 * Delete any CSessKeyContainer objects in the INVOKE_SPECIFIER list.
		 */
		if (NULL != lpInvSpecInfo->session_key)
		{
		    lpInvSpecInfo->session_key->Release();
		}

		/*
		 * Iterate through the capabilities list held in the INVOKE_SPECIFIER
		 * structure.
		 */
		lpInvSpecInfo->ExpectedCapItemList.DeleteList();

		/*
		 * Delete the INVOKE_SPECIFIER structure.
		 */
		delete lpInvSpecInfo;
	}
}

/*
 *	LockApplicationInvokeSpecifierList ()
 *
 *	Public Function Description:
 *		This routine locks the invoke specifier data and determines the amount
 *		of memory necessary to hold the associated data.
 */
UINT CInvokeSpecifierListContainer::LockApplicationInvokeSpecifierList(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of
	 * the memory required to hold the data for the application invoke
	 * specifier.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		INVOKE_SPECIFIER            *lpInvSpecInfo;
		APP_CAP_ITEM                *pExpCapData;

		/*
		 * Set aside memory to hold the pointers to the GCCAppProtocolEntity
		 * structures as well as the structures themselves.  The "sizeof" the
		 * structure must be rounded to an even four-byte boundary.
		 */
		m_cbDataSize = m_InvokeSpecifierList.GetCount() *
				(sizeof(PGCCAppProtocolEntity) + ROUNDTOBOUNDARY(sizeof(GCCAppProtocolEntity)));

		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			/*
			 * Lock the data for the session keys, adding the amount of memory
			 * necessary to hold the session key data to the total memory size.
			 */
			m_cbDataSize += lpInvSpecInfo->session_key->LockSessionKeyData();

			lpInvSpecInfo->ExpectedCapItemList.Reset();

			/*
			 * Set aside memory to hold the pointers to the
			 * GCCApplicationCabability	structures as well as the structures
			 * themselves.  The "sizeof" the structure must be rounded to an
			 * even four-byte boundary.
			 */
			m_cbDataSize += lpInvSpecInfo->ExpectedCapItemList.GetCount() *
					( sizeof(PGCCApplicationCapability) + ROUNDTOBOUNDARY (sizeof(GCCApplicationCapability)) );

			/*
			 * Lock the data for the capability ID's, adding the amount of
			 * memory necessary to hold the capability ID data to the total
			 * memory size.
			 */
			while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
			{
				m_cbDataSize += pExpCapData->pCapID->LockCapabilityIdentifierData();
			}
		}
	}

	return m_cbDataSize;
}

/*
 *	GetApplicationInvokeSpecifierList ()
 *
 *	Public Function Description:
 *		This routine retrieves the invoke specifier data in the form of a
 *		list of application protocol entities which are written into the memory
 *		provided.  This routine is called after "locking" the data.
 */
UINT CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierList(
									USHORT		*number_of_protocol_entities,
									LPBYTE		memory)
{
	PGCCAppProtocolEntity *			ape_list_ptr;
	PGCCAppProtocolEntity 			ape_ptr;
	PGCCApplicationCapability 		capability_ptr;
	UINT							data_length = 0;
	Int								ape_counter = 0;
	Int								capability_counter = 0;
	UINT							cbDataSizeToRet = 0;
	INVOKE_SPECIFIER                *lpInvSpecInfo;
	APP_CAP_ITEM                    *pExpCapData;
	
	/*
	 * If the object has been locked, fill in the output structure and
	 * the data referenced by the structure.  Otherwise, report that the object
	 * key has yet to be locked into the "API" form.
	 */
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.  This value was
		 * calculated on the call to "Lock".
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the number of protocol entities and save a pointer to
		 * the memory location passed in.  This is where the pointers to
		 * the GCCAppProtocolEntity	structures will be written.  The actual
		 * structures will be written into memory immediately following the list
		 * of pointers.
		 */
		*number_of_protocol_entities = (USHORT) m_InvokeSpecifierList.GetCount();

		ape_list_ptr = (PGCCAppProtocolEntity *)memory;

		/*
		 * Save the amount of memory needed to hold the list of structure
		 * pointers.
		 */
		data_length = m_InvokeSpecifierList.GetCount() * sizeof(PGCCAppProtocolEntity);

		/*
		 * Move the memory pointer past the list of APE pointers.  This is where
		 * thefirst APE structure will be written.
		 */
		memory += data_length;

		/*
		 * Iterate through the internal list of INVOKE_SPECIFIER structures,
		 * building "API" GCCAppProtocolEntity structures in memory.
		 */
		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			/*
			 * Save the pointer to the APE structure in the list of pointers.
			 */
			ape_ptr = (PGCCAppProtocolEntity)memory;
			ape_list_ptr[ape_counter++] = ape_ptr;

			/*
			 * Move the memory pointer past the APE structure.  This is where
			 * thesession key data will be written.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCAppProtocolEntity));

			/*
			 * Fill in the APE structure starting with the session key.
			 */
			data_length = lpInvSpecInfo->session_key->GetGCCSessionKeyData(&ape_ptr->session_key, memory);

			/*
			 * Move the memory pointer past the session key data.  This is
			 * where the list of pointers to the GCCApplicationCapability
			 * structures will be written so save the pointer in the APE
			 * structure's capabilities list pointer.
			 */
			memory += data_length;

			ape_ptr->expected_capabilities_list = (PGCCApplicationCapability *)memory;

			/*
			 * Go ahead and fill in the APE's channel type and invoke flag.
			 */
			ape_ptr->must_be_invoked = lpInvSpecInfo->must_be_invoked;
			ape_ptr->startup_channel_type = lpInvSpecInfo->startup_channel_type;
			ape_ptr->number_of_expected_capabilities = (USHORT) lpInvSpecInfo->ExpectedCapItemList.GetCount();

			/*
			 * Move the memory pointer past the list of GCCApplicationCapability
			 * pointers.  This is where the first GCCApplicationCapability
			 * structure will be written.
			 */
			memory += (lpInvSpecInfo->ExpectedCapItemList.GetCount() *
					    sizeof(PGCCApplicationCapability));

			/*
			 * Iterate through the list of capabilities, writing the
			 * GCCApplicationCapability structures into memory.
			 */
			capability_counter = 0;
			lpInvSpecInfo->ExpectedCapItemList.Reset();
			while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
			{
				/*
				 * Save the pointer to the capability structure in the list of
				 * pointers.  Move the memory pointer past the capability
				 * structure.  This is where the data associated with the
				 * capability ID will be written.
				 */
				capability_ptr = (PGCCApplicationCapability)memory;
				ape_ptr->expected_capabilities_list[capability_counter++] = capability_ptr;

				memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationCapability));

				/*
				 * Fill in the capability structure and add the amount of data
				 * written into memory to the total data length.
				 */
				data_length = GetApplicationCapability(pExpCapData, capability_ptr, memory);

				/*
				 * Move the	memory pointer past the capability data.
				 */
				memory += data_length;
			}
		}
	}
	else
	{
		number_of_protocol_entities = 0;
		ERROR_OUT(("CInvokeSpecifierListContainer::GetAppInvokeSpecList: Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnLockApplicationInvokeSpecifierList ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated
 *		with the "API" invoke specifier list once the lock count reaches zero.
 */
void CInvokeSpecifierListContainer::UnLockApplicationInvokeSpecifierList(void)
{
	if (Unlock(FALSE) == 0)
	{
		INVOKE_SPECIFIER            *lpInvSpecInfo;
		APP_CAP_ITEM                *pExpCapData;

		/*
		 * Unlock any container data held internally in the list of info.
		 * structures by iterating through the internal list.
		 */
		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			/*
			 * Unlock any CSessKeyContainer objects.
			 */
			lpInvSpecInfo->session_key->UnLockSessionKeyData();

			/*
			 * Iterate through the capabilities list held in the
			 * INVOKE_SPECIFIER structure.
			 */
			lpInvSpecInfo->ExpectedCapItemList.Reset();
			while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
			{
				/*
				 * Unlock the CCapIDContainer objects.
				 */
				pExpCapData->pCapID->UnLockCapabilityIdentifierData();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	GetApplicationInvokeSpecifierListPDU ()
 *
 *	Public Function Description:
 *		This routine retrieves the "PDU" form of an
 * 		ApplicationProtocolEntityList.
 */
GCCError CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierListPDU(
								PApplicationProtocolEntityList	*protocol_entity_list)
{
	GCCError								rc = GCC_NO_ERROR;
	PApplicationProtocolEntityList			new_pdu_ape_list_ptr;
	PApplicationProtocolEntityList			old_pdu_ape_list_ptr = NULL;
	
	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the input parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * input parameter.
	 */
	if (m_fValidAPEListPDU == FALSE)
	{
		INVOKE_SPECIFIER *lpInvSpecInfo;

		m_fValidAPEListPDU = TRUE;

		/*
		 * Initialize the output parameter to NULL so that the first time
		 * through the loop it will be set equal to the first new APE list
		 * created in the iterator loop.
		 */
		m_pAPEListPDU = NULL;

		/*
		 * Iterate through the list of "INVOKE_SPECIFIER" structures,
		 * converting each into "PDU" form and saving the pointers in the
		 * "ApplicationProtocolEntityList" which is a linked list of
		 * "ApplicationInvokeSpecifiers".
		 */
		m_InvokeSpecifierList.Reset();
	 	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_pdu_ape_list_ptr = new ApplicationProtocolEntityList;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_pdu_ape_list_ptr == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierListPDU: can't allocate ApplicationProtocolEntityList"));
				rc = GCC_ALLOCATION_FAILURE;
				FreeApplicationInvokeSpecifierListPDU ();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first ApplicationProtocolEntityList created.  On
			 * subsequent loops, set the structure's "next" pointer equal to
			 * the new structure.
			 */
			if (m_pAPEListPDU == NULL)
			{
				m_pAPEListPDU = new_pdu_ape_list_ptr;
			}
			else
			{
				old_pdu_ape_list_ptr->next = new_pdu_ape_list_ptr;
			}

			old_pdu_ape_list_ptr = new_pdu_ape_list_ptr;

			/*
			 * Initialize the new "next" pointer to NULL.
			 */
			new_pdu_ape_list_ptr->next = NULL;

			if (ConvertInvokeSpecifierInfoToPDU (lpInvSpecInfo, new_pdu_ape_list_ptr) !=
																		GCC_NO_ERROR)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::GetApplicationInvokeSpecifierListPDU: can't convert UserDataInfo to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * input parameter.
	 */
	*protocol_entity_list = m_pAPEListPDU;

	return rc;
}

/*
 *	FreeApplicationInvokeSpecifierListPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the invoke specifier data held internally
 *		in the "PDU" form of a "ApplicationProtocolEntityList".
 */
void CInvokeSpecifierListContainer::FreeApplicationInvokeSpecifierListPDU(void)
{
	PApplicationProtocolEntityList  pCurr, pNext;
	INVOKE_SPECIFIER                *lpInvSpecInfo;
	APP_CAP_ITEM                    *pExpCapData;

	if (m_pAPEListPDU != NULL)
	{
		m_fValidAPEListPDU = FALSE;

		/*
		 * Loop through the list, freeing the data associated with
		 * each structure contained in the list.
		 */
        for (pCurr = m_pAPEListPDU; NULL != pCurr; pCurr = pNext)
        {
            pNext = pCurr->next;
            delete pCurr;
		}
	}

	/*
	 * Iterate through the internal list, telling each data container object
	 * to free any PDU data which it has allocated.
	 */
	m_InvokeSpecifierList.Reset();
	while (NULL != (lpInvSpecInfo = m_InvokeSpecifierList.Iterate()))
	{
		if (lpInvSpecInfo->session_key != NULL)
        {
			lpInvSpecInfo->session_key->FreeSessionKeyDataPDU();
        }

		/*
		 * Iterate through the
		 * list, freeing the PDU data for the capability ID's.
		 */
		lpInvSpecInfo->ExpectedCapItemList.Reset();
		while (NULL != (pExpCapData = lpInvSpecInfo->ExpectedCapItemList.Iterate()))
		{
			pExpCapData->pCapID->FreeCapabilityIdentifierDataPDU();
		}
	}
}

/*
 *	GCCError	CInvokeSpecifierListContainer::SaveAPICapabilities (
 *						INVOKE_SPECIFIER                *invoke_specifier,
 *						UINT							number_of_capabilities,
 *						PGCCApplicationCapability	* 	capabilities_list)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 * 		This routine is used to save the list of application capabilities passed
 * 		in as "API" data in the internal list of expected capability data
 *		which is held in the internal info structure.
 *
 *	Formal Parameters:
 *		invoke_specifier		(i) Internal structure used to hold invoke data.
 *		number_of_capabilities	(i) Number of capabilities in list.
 *		capabilities_list		(i) List of API capabilities to save.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::SaveAPICapabilities(
						INVOKE_SPECIFIER                *invoke_specifier,
						UINT							number_of_capabilities,
						PGCCApplicationCapability	* 	capabilities_list)
{
	GCCError		rc = GCC_NO_ERROR;
	APP_CAP_ITEM    *pExpCapData;
	UINT			i;

	for (i = 0; i < number_of_capabilities; i++)
	{
		/*
		 * For each capability, create an APP_CAP_ITEM structure
		 * to hold all the necessary data.  This structure will be inserted into
		 * the list held by the internal info. structure.
		 */
		DBG_SAVE_FILE_LINE
		pExpCapData = new APP_CAP_ITEM((GCCCapabilityType) capabilities_list[i]->capability_class.eType);
		if (pExpCapData != NULL)
		{
			/*
			 * Create a new CCapIDContainer object to hold the
			 * identifier data.
			 */
			DBG_SAVE_FILE_LINE
			pExpCapData->pCapID = new CCapIDContainer(&capabilities_list[i]->capability_id, &rc);
			if ((pExpCapData->pCapID != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * The identifier object was successfully created so fill in the
				 * rest of the ApplicationCapabilityData structure.
				 */
                switch (pExpCapData->eCapType)
                {
                case GCC_UNSIGNED_MINIMUM_CAPABILITY:
					pExpCapData->nUnsignedMinimum = capabilities_list[i]->capability_class.nMinOrMax;
                    break;
                case GCC_UNSIGNED_MAXIMUM_CAPABILITY:
					pExpCapData->nUnsignedMaximum = capabilities_list[i]->capability_class.nMinOrMax;
                    break;
				}

				/*
				 * Add this expected capability to the list.
				 */
				invoke_specifier->ExpectedCapItemList.Append(pExpCapData);
			}
			else
            {
				delete pExpCapData;
				rc = GCC_ALLOCATION_FAILURE;
                break;
			}
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
            break;
        }
	}

	return rc;
}

/*
 *	GCCError	CInvokeSpecifierListContainer::SavePDUCapabilities (
 *						INVOKE_SPECIFIER                *invoke_specifier,
 *						PSetOfExpectedCapabilities	 	capabilities_set)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 * 		This routine is used to save the list of application capabilities passed
 * 		in as "PDU" data in the internal list of expected capability data
 *		which is held in the internal info. structure.
 *
 *	Formal Parameters:
 *		invoke_specifier		(i) Internal structure used to hold invoke data.
 *		capabilities_set		(i) List of PDU capabilities to save.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::SavePDUCapabilities(
						INVOKE_SPECIFIER                *invoke_specifier,
						PSetOfExpectedCapabilities	 	capabilities_set)
{
	GCCError		rc = GCC_NO_ERROR;
	APP_CAP_ITEM    *pExpCapData;

	while ((capabilities_set != NULL) && (rc == GCC_NO_ERROR))
	{
		/*
		 * Create and fill in the new expected capability.
		 */
		DBG_SAVE_FILE_LINE
		pExpCapData = new APP_CAP_ITEM((GCCCapabilityType) capabilities_set->value.capability_class.choice);
		if (pExpCapData != NULL)
		{
			/*
			 * Create the CCapIDContainer object used to hold the
			 * capability ID data internally.  Make sure creation is successful.
			 */
			DBG_SAVE_FILE_LINE
			pExpCapData->pCapID = new CCapIDContainer(&capabilities_set->value.capability_id, &rc);
			if	(pExpCapData->pCapID == NULL || rc != GCC_NO_ERROR)
			{
				rc = GCC_ALLOCATION_FAILURE;
				delete pExpCapData;
			}
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }

		/*
		 * The capability ID was saved successfully, so go ahead and insert
		 * the expected capability data structure into the internal list.
		 * Fill in the capability class data.
		 */
		if (rc == GCC_NO_ERROR)
		{
			invoke_specifier->ExpectedCapItemList.Append(pExpCapData);

			/*
			 * Save the capability type and value.
			 */
            switch (capabilities_set->value.capability_class.choice)
            {
            case UNSIGNED_MINIMUM_CHOSEN:
				pExpCapData->nUnsignedMinimum = capabilities_set->value.capability_class.u.unsigned_minimum;
                break;
            case UNSIGNED_MAXIMUM_CHOSEN:
				pExpCapData->nUnsignedMaximum = capabilities_set->value.capability_class.u.unsigned_maximum;
                break;
			}
		}

        capabilities_set = capabilities_set->next;
	}

	return rc;
}

/*
 *	UINT	CInvokeSpecifierListContainer::GetApplicationCapability (
 *					APP_CAP_ITEM			        *capability_info_data,
 *					PGCCApplicationCapability		api_capability,
 *					LPSTR							memory)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 * 		This routine is used to fill in an API GCCApplicationCapability
 *		structure from an internal info structure.
 *
 *	Formal Parameters:
 *		capability_info_data	(i) Internal capability data to convert into
 *										API data.
 *		api_capability			(o) Structure to hold data in API form.
 *		memory					(o) Memory used to hold bulk data referenced by
 *										the API structure.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
UINT CInvokeSpecifierListContainer::GetApplicationCapability(
					APP_CAP_ITEM                    *pExpCapData,
					PGCCApplicationCapability		api_capability,
					LPBYTE							memory)
{
	UINT		data_length = 0;

	/*
	 * Call the CapabilityID object to retrieve the capability ID data.
	 */
	data_length = pExpCapData->pCapID->GetGCCCapabilityIDData(
												&api_capability->capability_id,
												memory);

	/*
	 * Fill in the remaining fields for the GCCApplicationCapability structure.
	 */
	api_capability->capability_class.eType = pExpCapData->eCapType;
    switch (pExpCapData->eCapType)
    {
    case GCC_UNSIGNED_MINIMUM_CAPABILITY:
		api_capability->capability_class.nMinOrMax = pExpCapData->nUnsignedMinimum;
        break;
    case GCC_UNSIGNED_MAXIMUM_CAPABILITY:
		api_capability->capability_class.nMinOrMax = pExpCapData->nUnsignedMaximum;
        break;
	}

	/*
	 * Fill in the number of entities.  Note, however, that this field will not
	 * be used in this context.
	 */
	api_capability->number_of_entities = 0;

	return (data_length);
}

/*
 *	GCCError	CInvokeSpecifierListContainer::ConvertInvokeSpecifierInfoToPDU(	
 *						INVOKE_SPECIFIER                    *specifier_info_ptr,
 *						PApplicationProtocolEntityList		ape_list_ptr)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine converts the invoke specifier from the internal form which
 *		is an "INVOKE_SPECIFIER" structure into the "PDU" structure form of
 *		a "ApplicationInvokeSpecifier".
 *
 *	Formal Parameters:
 *		specifier_info_ptr	(i) Internal structure holding data to convert.
 *		ape_list_ptr		(o) PDU structure to hold converted data.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::ConvertInvokeSpecifierInfoToPDU (	
						INVOKE_SPECIFIER                    *specifier_info_ptr,
						PApplicationProtocolEntityList		ape_list_ptr)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfExpectedCapabilities		new_capability_set_ptr;
	PSetOfExpectedCapabilities		old_capability_set_ptr = NULL;

	/*
	 * Initialize the invoke specifier bit mask to zero.
	 */
	ape_list_ptr->value.bit_mask = 0;

	/*
	 * Fill in the session key PDU data using the CSessKeyContainer object.
	 */
	rc = specifier_info_ptr->session_key->GetSessionKeyDataPDU(&ape_list_ptr->value.session_key);

	/*
	 * Fill in the capabilities list if any exist.
	 */
	if ((rc == GCC_NO_ERROR) && (specifier_info_ptr->ExpectedCapItemList.GetCount() != 0))
	{
		APP_CAP_ITEM *pExpCapData;

		ape_list_ptr->value.bit_mask |= EXPECTED_CAPABILITY_SET_PRESENT;

		/*
		 * Set the pointer to the capability set to NULL so that it will be
		 * set equal to the first SetOfExpectedCapabilities created inside the
		 * iterator loop.
		 */
		ape_list_ptr->value.expected_capability_set = NULL;

		/*
		 * Iterate through the list of APP_CAP_ITEM structures,
		 * converting each into "PDU" form and saving the pointers in the
		 * "SetOfExpectedCapabilities.
		 */
		specifier_info_ptr->ExpectedCapItemList.Reset();
		while (NULL != (pExpCapData = specifier_info_ptr->ExpectedCapItemList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_capability_set_ptr = new SetOfExpectedCapabilities;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_capability_set_ptr == NULL)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::ConvertToPDU: alloc error, cleaning up"));
				rc = GCC_ALLOCATION_FAILURE;
				FreeApplicationInvokeSpecifierListPDU();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfExpectedCapabilities created.  On
			 * subsequent loops, set the structure's "next" pointer equal to
			 * the new structure.
			 */
			if (ape_list_ptr->value.expected_capability_set == NULL)
			{
				ape_list_ptr->value.expected_capability_set = new_capability_set_ptr;
			}
			else
            {
				old_capability_set_ptr->next = new_capability_set_ptr;
            }

			old_capability_set_ptr = new_capability_set_ptr;

			/*
			 * Initialize the new "next" pointer to NULL.
			 */
			new_capability_set_ptr->next = NULL;

			if (ConvertExpectedCapabilityDataToPDU(pExpCapData, new_capability_set_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("CInvokeSpecifierListContainer::ConvertToPDU: Error converting Capability to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	/*
	 * Fill in the channel type if one is specified.
	 */
	if (specifier_info_ptr->startup_channel_type != MCS_NO_CHANNEL_TYPE_SPECIFIED)
	{
		ape_list_ptr->value.bit_mask |= INVOKE_STARTUP_CHANNEL_PRESENT;
	
        switch (specifier_info_ptr->startup_channel_type)
        {
        case MCS_STATIC_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = CHANNEL_TYPE_STATIC;
            break;
        case MCS_DYNAMIC_MULTICAST_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = DYNAMIC_MULTICAST;
            break;
        case MCS_DYNAMIC_PRIVATE_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = DYNAMIC_PRIVATE;
            break;
        case MCS_DYNAMIC_USER_ID_CHANNEL:
			ape_list_ptr->value.invoke_startup_channel = DYNAMIC_USER_ID;
            break;
		}
	}

	/*
	 * Fill in the invoke flag.
	 */
	ape_list_ptr->value.invoke_is_mandatory = (ASN1bool_t)specifier_info_ptr->must_be_invoked;

	return rc;
}

/*
 *	GCCError CInvokeSpecifierListContainer::ConvertExpectedCapabilityDataToPDU(	
 *						APP_CAP_ITEM				        *info_ptr,
 *						PSetOfExpectedCapabilities			pdu_ptr)
 *
 *	Private member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine converts the capability ID from the internal form which
 *		is an APP_CAP_ITEM structure into the "PDU" structure form
 *		of a "SetOfExpectedCapabilities".
 *
 *	Formal Parameters:
 *		info_ptr	(i) Internal structure holding data to convert.
 *		pdu_ptr		(o) PDU structure to hold converted data.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CInvokeSpecifierListContainer::ConvertExpectedCapabilityDataToPDU (	
						APP_CAP_ITEM				        *pExpCapData,
						PSetOfExpectedCapabilities			pdu_ptr)
{
	GCCError		rc = GCC_NO_ERROR;

	/*
	 * Retrieve the capability ID data from the internal
	 * CCapIDContainer object.
	 */
	rc = pExpCapData->pCapID->GetCapabilityIdentifierDataPDU(&pdu_ptr->value.capability_id);

	/*
	 * Fill in the capability class.
	 */
	if (rc == GCC_NO_ERROR)
	{
        switch (pExpCapData->eCapType)
        {
        case GCC_LOGICAL_CAPABILITY:
			pdu_ptr->value.capability_class.choice = LOGICAL_CHOSEN;
            break;
        case GCC_UNSIGNED_MINIMUM_CAPABILITY:
			pdu_ptr->value.capability_class.choice = UNSIGNED_MINIMUM_CHOSEN;
			pdu_ptr->value.capability_class.u.unsigned_minimum = pExpCapData->nUnsignedMinimum;
            break;
        case GCC_UNSIGNED_MAXIMUM_CAPABILITY:
			pdu_ptr->value.capability_class.choice = UNSIGNED_MAXIMUM_CHOSEN;
			pdu_ptr->value.capability_class.u.unsigned_maximum = pExpCapData->nUnsignedMaximum;
            break;
		}
	}

	return rc;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\mcslog.cpp ===
#include "precomp.h"
/**********************************************************************
 * File:     mcslog.c
 * Abstract: global function definitions for protocol logging functions 
 * added into MCSNC.DLL to read the contents of MCS PDU
 * contents sent and received from the T.123 layer.
 * Created:  2/18/96, Venkatesh Gopalakrishnan
 * Copyright (c) 1996 Microsoft Corpration
 ******************************************************************** */

 /* NOTE:  The contents of this file are only included IFF PDULOG is a
  * defined constant.  This constant will be defined in the Win32 Diagnostic
  * build configuration of MCSNC.DLL 
  */

 #ifdef PDULOG
 
 #include "mcslog.h"
 
 /* just threw these in to keep a total count of the number of bytes
  * of ASN.1 coded data sent and received.
  */
 long int recv_pdu_log = 0;
 long int sent_pdu_log = 0;

 /***********************************************************************/
 int InitializeMCSLog()
 {
    FILE *logfile;

	/* this should just reset the file pointer */    
    logfile = fopen(LOG_FILE_NAME,"w");

	// this "fake" starting PDU is put in so that the Intel Protocol Browser
	// dosen't go nuts if it is reading dynamically.
    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     MCS\n");
    pduLog(logfile,"DIRECTION: None\n");
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduLog(logfile,"PDU_TYPE:  Bogus_PDU_to_start_the_logging.\n");
	pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
	
	fclose(logfile);
    return(0);
 }

 /**************************************************************************/
 char *pszTimeStamp()
 {
    char *timestring;
    timestring = (char *) malloc (13*sizeof(char));
    _strtime(timestring);
    return(timestring);
 }

 /**************************************************************************/
 void pduFragmentation(FILE *logfile,unsigned int i)
 {
    pduLog(logfile,"  PDU Fragmentation: ");
    if(i==1) 
    {
        pduLog(logfile,"Complete PDU\n");
    }
    else
    {
        pduLog(logfile,"!!!! Icomplete PDU !!!!\n");
    }
 }

 /**************************************************************************/
 void  pduRawOutput (FILE *logfile,unsigned char *data, unsigned long length) 
 {
       unsigned int i=0,j=0;
       
       pduLog(logfile,"        ");
       for (i=0; i<length; i++) 
       {
            pduLog(logfile,"%02x ",*(data+i));
            j++;
            if (j >= 16) 
            {
                pduLog(logfile,"\n        ");
                j=0;
            }
       }
       pduLog(logfile,"\n");
 }

 /**************************************************************************/ 
 void PrintCharData(FILE *logfile, unsigned char *data, unsigned int length)
 {
	 char print_buffer[255];

	 //strncpy(print_buffer,(const char *) data, length);
	 //CopyTextToChar(print_buffer, (unsigned short *) data, length);
	 //pduLog(logfile,"\tlength = [%d] ; ",length);
	 //pduLog(logfile,"\ttext = %s\n",print_buffer);
	 pduRawOutput(logfile,data,length);
 }

 /**************************************************************************/
 void pduDirection(FILE *logfile,unsigned int direction)
 {
    switch(direction)
    {
        case SENT:
            pduLog(logfile,"DIRECTION: Sent\n");
            break;
        case RECEIVED:
            pduLog(logfile,"DIRECTION: Received\n");
            break;
        default:
            pduLog(logfile,"DIRECTION: Unknown\n");
            break;
     }
 }


/**************************************************************************/
void	pduLog (FILE *pFile, char * format,...)
 {
    char	*argument_ptr;
    
    argument_ptr = (char *) &format + sizeof (format);
    vfprintf (pFile, format, argument_ptr);
 }


 /**************************************************************************/  
 void mcsLog(PPacket packet, PDomainMCSPDU domain_pdu, unsigned int direction)
 {
    FILE *logfile;   
    logfile = fopen(LOG_FILE_NAME,"a+");
    
    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     MCS\n");
    pduDirection(logfile,direction);
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"      %d octets (hex output):\n",packet->GetEncodedDataLength());
    if(direction==RECEIVED)
        recv_pdu_log = recv_pdu_log + packet->GetEncodedDataLength();
    else
        sent_pdu_log = sent_pdu_log + packet->GetEncodedDataLength();
    pduLog(logfile,"      Total Data:  sent = %ld    recv = %ld\n",sent_pdu_log,recv_pdu_log);
    pduRawOutput(logfile,packet->GetEncodedData(1),packet->GetEncodedDataLength());
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduFragmentation(logfile,packet->IsValid());
    pduLogMCSDomainInfo(logfile,domain_pdu);
    pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
 
    fclose(logfile);
 }

 /**************************************************************************/
 void mcsConnectLog(PPacket packet, PConnectMCSPDU connect_pdu, unsigned int direction)
 {
    FILE *logfile;   
    logfile = fopen(LOG_FILE_NAME,"a+");

    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     MCS\n");
    pduDirection(logfile,direction);
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"      %d octets (hex output):\n",packet->GetEncodedDataLength());
    if(direction==RECEIVED)
        recv_pdu_log = recv_pdu_log + packet->GetEncodedDataLength();
    else
        sent_pdu_log = sent_pdu_log + packet->GetEncodedDataLength();
    pduLog(logfile,"      Total Data:  sent = %ld    recv = %ld\n",sent_pdu_log,recv_pdu_log);
    pduRawOutput(logfile,packet->GetEncodedData(1),packet->GetEncodedDataLength());
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduFragmentation(logfile,packet->IsValid());
    pduLogMCSConnectInfo(logfile,connect_pdu);
    pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
 
    fclose(logfile);
 }


 ////////////////////////////////////////////////////////////////////////////
 // Switch cases for MCS Connect PDUs
 ////////////////////////////////////////////////////////////////////////////
 /**************************************************************************/ 
 void   pduLogMCSConnectInfo(FILE *logfile, PConnectMCSPDU connect_pdu)
 {
    switch(connect_pdu->choice)
    {
		case CONNECT_INITIAL_CHOSEN:
            {
                pduLog(logfile,"PDU_TYPE: MCS_ConnectInitialPDU\n");
				pduLogConnectInitial(logfile,connect_pdu);
			}
            break;
		case CONNECT_RESPONSE_CHOSEN:
            {
                pduLog(logfile, "PDU_TYPE: MCS_ConnectResponsePDU\n");
				pduLogConnectResponse(logfile, connect_pdu);
			}
            break;
        case CONNECT_ADDITIONAL_CHOSEN:
            {
                pduLog(logfile,"PDU_TYPE: MCS_ConnectAdditionalPDU\n");
				pduLogConnectAdditional(logfile, connect_pdu);
            }
            break;
        case CONNECT_RESULT_CHOSEN:
            {
				pduLog(logfile,"PDU_TYPE: MCS_ConnectResultPDU\n");
				pduLogConnectResult(logfile, connect_pdu);
            }
            break;
        default:
            {
                pduLog(logfile,"ERROR: Unknown MCS Connect PDU !! << \n");
            }
            break;
	}
 }

 /**************************************************************************/
 void   pduLogMCSDomainInfo(FILE *logfile, PDomainMCSPDU domain_pdu)
 {
    switch(domain_pdu->choice)
    {
        case PLUMB_DOMAIN_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_PlumbDomainIndication\n");
				pduLogPlumbDomainIndication(logfile, domain_pdu);
			}
			break;
		case ERECT_DOMAIN_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ErectDomainIndication\n");
				pduLogErectDomainRequest(logfile, domain_pdu);
			}
			break;
		case MERGE_CHANNELS_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeChannelsRequest\n");
				pduLogMergeChannelsRequest(logfile, domain_pdu);
			}
			break;
		case MERGE_CHANNELS_CONFIRM_CHOSEN:	
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeChannelsConfirm\n");
				pduLogMergeChannelsConfirm(logfile,domain_pdu);
			}
			break;
		case PURGE_CHANNEL_INDICATION_CHOSEN:	
			{
				pduLog(logfile,"PDU_TYPE: MCS_PurgeChannelIndication\n");
				pduLogPurgeChannelIndication(logfile,domain_pdu);
			}
			break;
		case MERGE_TOKENS_REQUEST_CHOSEN:		
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeTokensRequest\n");
				pduLogMergeTokensRequest(logfile,domain_pdu);
			}
			break;
		case MERGE_TOKENS_CONFIRM_CHOSEN:		
			{
				pduLog(logfile,"PDU_TYPE: MCS_MergeTokensConfirm\n");
				pduLogMergeTokensConfirm(logfile,domain_pdu);
			}
			break;
		case PURGE_TOKEN_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_PurgeTokenIndication\n");
				pduLogPurgeTokenIndication(logfile,domain_pdu);
			}
			break;
		case DISCONNECT_PROVIDER_ULTIMATUM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_DisconnectProviderUltimatum\n");
				pduLogDisconnectProviderUltimatum(logfile,domain_pdu);
			}
			break;
		case REJECT_ULTIMATUM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_RejectUltimatum\n");
				pduLogRejectUltimatum(logfile,domain_pdu);
			}
			break;
		case ATTACH_USER_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_AttachUserRequest\n");
				pduLogAttachUserRequest(logfile,domain_pdu);
			}
			break;
		case ATTACH_USER_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_AttachUserConfirm\n");
				pduLogAttachUserConfirm(logfile,domain_pdu);
			}
			break;
		case DETACH_USER_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_DetachUserRequest\n");
				pduLogDetachUserRequest(logfile,domain_pdu);
			}
			break;
		case DETACH_USER_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_DetachUserIndication\n");
				pduLogDetachUserIndication(logfile,domain_pdu);
			}
			break;
		case CHANNEL_JOIN_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelJoinRequest\n");
				pduLogChannelJoinRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_JOIN_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelJoinConfirm\n");
				pduLogChannelJoinConfirm(logfile,domain_pdu);
			}
			break;
		case CHANNEL_LEAVE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelLeaveRequest\n");
				pduLogChannelLeaveRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_CONVENE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelConveneRequest\n");
				pduLogChannelConveneRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_CONVENE_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelConveneConfirm\n");
				pduLogChannelConveneConfirm(logfile,domain_pdu);
			}
			break;
		case CHANNEL_DISBAND_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelDisbandRequest\n");
				pduLogChannelDisbandRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_DISBAND_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelDisbandIndication\n");
				pduLogChannelDisbandIndication(logfile,domain_pdu);
			}
			break;
		case CHANNEL_ADMIT_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelAdmitRequest\n");
				pduLogChannelAdmitRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_ADMIT_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelAdmitIndication\n");
				pduLogChannelAdmitIndication(logfile,domain_pdu);
			}
			break;
		case CHANNEL_EXPEL_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelExpelRequest\n");
				pduLogChannelExpelRequest(logfile,domain_pdu);
			}
			break;
		case CHANNEL_EXPEL_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_ChannelExpelIndication\n");
				pduLogChannelExpelIndication(logfile,domain_pdu);
			}
			break;
		case SEND_DATA_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_SendDataRequest\n");
				pduLogSendDataRequest(logfile,domain_pdu);
			}
			break;
		case SEND_DATA_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_SendDataIndication\n");
				pduLogSendDataIndication(logfile,domain_pdu);
			}
			break;
		case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_UniformSendDataRequest\n");
				pduLogUniformSendDataRequest(logfile,domain_pdu);
			}
			break;
		case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_UniformSendDataIndication\n");
				pduLogUniformSendDataIndication(logfile,domain_pdu);
			}
			break;
		case TOKEN_GRAB_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGrabRequest\n");
				pduLogTokenGrabRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_GRAB_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGrabConfirm\n");
				pduLogTokenGrabConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_INHIBIT_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenInhibitRequest\n");
				pduLogTokenInhibitRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_INHIBIT_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenInhibitConfirm\n");
				pduLogTokenInhibitConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveRequest\n");
				pduLogTokenGiveRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveIndication\n");
				pduLogTokenGiveIndication(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_RESPONSE_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveResponse\n");
				pduLogTokenGiveResponse(logfile,domain_pdu);
			}
			break;
		case TOKEN_GIVE_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenGiveConfirm\n");
				pduLogTokenGiveConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_PLEASE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenPleaseRequest\n");
				pduLogTokenPleaseRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_PLEASE_INDICATION_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenPleaseIndication\n");
				pduLogTokenPleaseIndication(logfile,domain_pdu);
			}
			break;
		case TOKEN_RELEASE_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenReleaseRequest\n");
				pduLogTokenReleaseRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_RELEASE_CONFIRM_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenReleseConfirm\n");
				pduLogTokenReleaseConfirm(logfile,domain_pdu);
			}
			break;
		case TOKEN_TEST_REQUEST_CHOSEN:
			{
				pduLog(logfile,"PDU_TYPE: MCS_TokenTestRequest\n");
				pduLogTokenTestRequest(logfile,domain_pdu);
			}
			break;
		case TOKEN_TEST_CONFIRM_CHOSEN:
            {
				pduLog(logfile,"PDU_TYPE: MCS_TokenTestConfirm\n");	   
				pduLogTokenTestConfirm(logfile,domain_pdu);
			}
            break;
        default: 
            {
                // write something, just so we know we got a PDU.
                pduLog(logfile,"ERROR: we got a MCS PDU, just don't know what it is");
			}
            break;
	}					
}



///////////////////////////////////////////////////////////////////////
// constant string returns
//////////////////////////////////////////////////////////////////////
/**************************************************************************/
void PrintPDUResult(FILE *logfile, unsigned int result)
{
	switch(result)
	{
	case RT_SUCCESSFUL:
		pduLog(logfile,"RT_SUCCESSFUL\n");	
		break;
	case RT_DOMAIN_MERGING:
		pduLog(logfile,"RT_DOMAIN_MERGING\n");
		break;
	case RT_DOMAIN_NOT_HIERARCHICAL:
		pduLog(logfile,"RT_DOMAIN_NOT_HIERARCHICAL\n");
		break;
	case RT_NO_SUCH_CHANNEL:
		pduLog(logfile,"RT_NO_SUCH_CHANNEL\n");
		break;
	case RT_NO_SUCH_DOMAIN:
		pduLog(logfile,"RT_NO_SUCH_DOMAIN\n");
		break;
	case RT_NO_SUCH_USER:	
		pduLog(logfile,"RT_NO_SUCH_USER\n");
		break;
	case RT_NOT_ADMITTED:
		pduLog(logfile,"RT_NOT_ADMITTED\n");
		break;
	case RT_OTHER_USER:
		pduLog(logfile,"RT_OTHER_USER\n");
		break;
	case RT_PARAMETERS_UNACCEPTABLE:
		pduLog(logfile,"RT_PARAMETERS_UNACCEPTABLE\n");
		break;
	case RT_TOKEN_NOT_AVAILABLE:
		pduLog(logfile,"RT_TOKEN_NOT_AVAILABLE\n");
		break;
	case RT_TOKEN_NOT_POSESSED:
		pduLog(logfile,"RT_TOKEN_NOT_POSESSED\n");
		break;
	case RT_TOO_MANY_CHANNELS:
		pduLog(logfile,"RT_TOO_MANY_CHANNELS\n");
		break;
	case RT_TOO_MANY_TOKENS:
		pduLog(logfile,"RT_TOO_MANY_TOKENS\n");
		break;
	case RT_TOO_MANY_USERS:		
		pduLog(logfile,"RT_TOO_MANY_USERS\n");
		break;
	case RT_UNSPECIFIED_FAILURE:
		pduLog(logfile,"RT_UNSPECIFIED_FAILURE\n");
		break;
	case RT_USER_REJECTED:
		pduLog(logfile,"RT_USER_REJECTED\n");
		break;
	default:
		pduLog(logfile,"ERROR: UNKOWN RETURN TYPE <<<\n");
		break;
	}
}

/**************************************************************************/
void PrintPDUPriority(FILE *logfile, unsigned int priority)
{
	switch(priority)
	{
	case TOP_PRI:	
		pduLog(logfile,TOP_STR);
		break;
	case HIGH_PRI:
		pduLog(logfile,HIGH_STR);
		break;
	case MEDIUM_PRI:
		pduLog(logfile,MEDIUM_STR);
		break;
	case LOW_PRI:
		pduLog(logfile,LOW_STR);
		break;
	default:
		pduLog(logfile," >>>> UNKNOWN PRIORITY <<<\n");
		break;
	}
}

/**************************************************************************/
void PrintPDUSegmentation(FILE *logfile, unsigned char segmentation)
{
	if(segmentation==0x80)
		pduLog(logfile,"\tSegmentation: Begin\n");
	else if (segmentation==0x40)
		pduLog(logfile,"\tSegmentation: End\n");
	else
		pduLog(logfile,"\tSegmentation: Unknown\n");
}

/**************************************************************************/
void PrintTokenStatus(FILE *logfile, unsigned int status)
{
	switch(status)
	{
	case 0:
		pduLog(logfile,"\ttoken_status = NOT_IN_USE\n");
		break;
	case 1:
		pduLog(logfile,"\ttoken_status = SELF_GRABBED\n");
		break;
	case 2:
		pduLog(logfile,"\ttoken_status = OTHER_GRABBED\n");
		break;
	case 3:
		pduLog(logfile,"\ttoken_status = SELF_INHIBITED\n");
		break;
	case 4:
		pduLog(logfile,"\ttoken_status = OTHER_INHIBITED\n");
		break;
	case 5:
		pduLog(logfile,"\ttoken_status = SELF_RECIPIENT\n");
		break;
	case 6: 
		pduLog(logfile,"\ttoken_status = SELF_GIVING\n");
		break;
	case 7: 
		pduLog(logfile,"\ttoken_status = OTHER_GIVING\n");
		break;
	default:
		pduLog(logfile,"\tERROR: unknown token status\n");
		break;
	}
}


/**************************************************************************/
void PrintPDUReason(FILE *logfile, unsigned int reason)
{
	pduLog(logfile,"\t\tReason:   ");
	switch(reason)
	{
	case 0:
		pduLog(logfile,"RN_DOMAIN_DISCONNECTED\n");
		break;
	case 1:
		pduLog(logfile,"RN_PROVIDER_INITIATED\n");
		break;
	case 2:
		pduLog(logfile,"RN_TOKEN_PURGED\n");
		break;
	case 3: 
		pduLog(logfile,"RN_USER_REQUESTED\n");
		break;
	case 4: 
		pduLog(logfile,"RN_CHANNEL_PURGED\n");
		break;
	}
}

/**************************************************************************/
void PrintDiagnostic(FILE *logfile, unsigned int diagnostic)
{
	pduLog(logfile,"\t\tDiagnostic:   ");
	switch(diagnostic)
	{
	case 0:
		pduLog(logfile,"dc_inconsistent_merge\n");
		break;
	case 1:
		pduLog(logfile,"dc_forbidden_pdu_downward\n");
		break;
	case 2:
		pduLog(logfile,"dc_forbidden_pdu_upward\n");
		break;
	case 3:
		pduLog(logfile,"dc_invalid_ber_encoding\n");
		break;
	case 4:
		pduLog(logfile,"dc_invalid_per_encoding\n");
		break;
	case 5:
		pduLog(logfile,"dc_misrouted_user\n");
		break;
	case 6:
		pduLog(logfile,"dc_unrequested_confirm\n");
		break;
	case 7:
		pduLog(logfile,"dc_wrong_transport_priority\n");
		break;
	case 8:
		pduLog(logfile,"dc_channel_id_conflict\n");
		break;
	case 9:
		pduLog(logfile,"dc_token_id_conflict\n");
		break;
	case 10:
		pduLog(logfile,"dc_not_user_id_channel\n");
		break;
	case 11:
		pduLog(logfile,"dc_too_many_channels\n");
		break;
	case 12:
		pduLog(logfile,"dc_too_many_tokens\n");
		break;
	case 13:
		pduLog(logfile,"dc_too_many_users\n");
		break;
	default:
		pduLog(logfile,"ERROR: unknown diagnostic\n");
		break;
	}
}



/*****
 ***** Logging functions for individual MCS PDU contents
 *****/
/**************************************************************************/
void pduLogConnectInitial(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile,"\tCalling Domain Selector:");
	PrintCharData(logfile,connect_pdu->u.connect_initial.calling_domain_selector.value,
						 connect_pdu->u.connect_initial.calling_domain_selector.length);
	pduLog(logfile,"\tCalled Domain Selector:");
	PrintCharData(logfile,connect_pdu->u.connect_initial.called_domain_selector.value,
						 connect_pdu->u.connect_initial.called_domain_selector.length);
	PrintT120Boolean(logfile,"\tupward_flag = ",
						 (BOOL) connect_pdu->u.connect_initial.upward_flag);
	pduLog(logfile,"\tTarget Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_initial.target_parameters);
	pduLog(logfile,"\tMinimum Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_initial.minimum_parameters);
	pduLog(logfile,"\tMaximum Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_initial.maximum_parameters);
	pduLog(logfile,"\tUser Data: \n");
	pduRawOutput(logfile,connect_pdu->u.connect_initial.user_data.value,
						 connect_pdu->u.connect_initial.user_data.length);

}

/**************************************************************************/
void pduLogConnectResponse(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile, "\tResult: ");
	PrintPDUResult(logfile, connect_pdu->u.connect_response.result);
	pduLog(logfile, "\tcalled_connect_id = %u \n",
			connect_pdu->u.connect_response.called_connect_id);
	pduLog(logfile, "\tDomain Parameters: \n");
	PrintPDUDomainParameters(logfile, connect_pdu->u.connect_response.domain_parameters);
	pduLog(logfile, "\tUser Data: \n");
	pduRawOutput(logfile,connect_pdu->u.connect_response.user_data.value,
						 connect_pdu->u.connect_response.user_data.length);
}

/**************************************************************************/
void pduLogConnectAdditional(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile, "\tcalled_connect_id = %u\n",
			connect_pdu->u.connect_additional.called_connect_id);
	pduLog(logfile, "Priority: \n");
	PrintPDUPriority(logfile, connect_pdu->u.connect_additional.data_priority);
}

/**************************************************************************/
void pduLogConnectResult(FILE *logfile, PConnectMCSPDU connect_pdu)
{
	pduLog(logfile, "\tResult: ");
	PrintPDUResult(logfile, connect_pdu->u.connect_result.result);
}

/**************************************************************************/
void pduLogPlumbDomainIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile, "\theight_limit = %u\n",
			domain_pdu->u.plumb_domain_indication.height_limit);
}

/**************************************************************************/
void pduLogErectDomainRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile, "\tsub_height = %u\n",
			domain_pdu->u.erect_domain_request.sub_height);
	pduLog(logfile, "\tsub_interval = %u\n",
			domain_pdu->u.erect_domain_request.sub_interval);
}

/**************************************************************************/
void pduLogMergeChannelsRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	int i = 0;
	PSetOfPDUChannelAttributes  channel_attributes;
	PSetOfChannelIDs  channel_ids;

	channel_attributes = domain_pdu->u.merge_channels_request.merge_channels;
	channel_ids = domain_pdu->u.merge_channels_request.purge_channel_ids;

	pduLog(logfile, "  Merge Channels:\n");
	for(i=0; channel_attributes!=NULL; i++)
	{
		pduLog(logfile,"\t*** record [%u] ***\n",i);
		PrintChannelAttributes(logfile, channel_attributes->value);
		channel_attributes = channel_attributes->next;
	}
	pduLog(logfile, "  Purge Channel IDs:\n");
	for(i=0; channel_ids!=NULL; i++)
	{
		pduLog(logfile,"\t\trecord[%u] = %u\n",channel_ids->value);
		channel_ids = channel_ids->next;
	}
}

/**************************************************************************/
void pduLogMergeChannelsConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	unsigned int i = 0;
	PSetOfPDUChannelAttributes  channel_attributes;
	PSetOfChannelIDs  channel_ids;

	channel_attributes = domain_pdu->u.merge_channels_confirm.merge_channels;
	channel_ids = domain_pdu->u.merge_channels_confirm.purge_channel_ids;

	pduLog(logfile, "  Merge Channels:\n");
	for(i=0; channel_attributes!=NULL; i++)
	{
		pduLog(logfile,"\t*** record [%u] ***\n",i);
		PrintChannelAttributes(logfile, channel_attributes->value);
		channel_attributes = channel_attributes->next;
	}
	pduLog(logfile, "  Purge Channel IDs:\n");
	PrintSetOfChannelIDs(logfile,channel_ids);
}

/**************************************************************************/
void pduLogPurgeChannelIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfUserIDs	detach_user_ids;
	PSetOfChannelIDs	purge_channel_ids;

	detach_user_ids = domain_pdu->u.purge_channel_indication.detach_user_ids;
	purge_channel_ids = domain_pdu->u.purge_channel_indication.purge_channel_ids;

	pduLog(logfile, "  Detach User IDs: \n");
	PrintSetOfUserIDs(logfile, detach_user_ids);

	pduLog(logfile, "  Purge Channel IDs: \n");
	PrintSetOfChannelIDs(logfile, purge_channel_ids);
}

/**************************************************************************/
void pduLogMergeTokensRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfPDUTokenAttributes merge_tokens;
	PSetOfTokenIDs purge_token_ids;

	merge_tokens = domain_pdu->u.merge_tokens_request.merge_tokens;
	purge_token_ids = domain_pdu->u.merge_tokens_request.purge_token_ids;

	pduLog(logfile,"   Merge Tokens: \n");
	PrintSetOfTokenAttributes(logfile, merge_tokens);
	pduLog(logfile,"   Purge Token IDs: \n");
	PrintSetOfTokenIDs(logfile, purge_token_ids);
}

/**************************************************************************/
void pduLogMergeTokensConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfPDUTokenAttributes merge_tokens;
	PSetOfTokenIDs purge_token_ids;

	merge_tokens = domain_pdu->u.merge_tokens_request.merge_tokens;
	purge_token_ids = domain_pdu->u.merge_tokens_request.purge_token_ids;

	pduLog(logfile,"   Merge Tokens: \n");
	PrintSetOfTokenAttributes(logfile, merge_tokens);
	pduLog(logfile,"   Purge Token IDs: \n");
	PrintSetOfTokenIDs(logfile, purge_token_ids);
}

/**************************************************************************/
void pduLogPurgeTokenIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PSetOfTokenIDs purge_token_ids;

	purge_token_ids = domain_pdu->u.purge_token_indication.purge_token_ids;

	pduLog(logfile,"   Purge Token IDs: \n");
	PrintSetOfTokenIDs(logfile, purge_token_ids);
}

/**************************************************************************/
void pduLogDisconnectProviderUltimatum(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintPDUReason(logfile, domain_pdu->u.disconnect_provider_ultimatum.reason);
}

/**************************************************************************/           
void pduLogRejectUltimatum(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintDiagnostic(logfile, 
					domain_pdu->u.reject_user_ultimatum.diagnostic);
	pduLog(logfile,"\tInitial Octets: \n");
	pduRawOutput(logfile,
				 domain_pdu->u.reject_user_ultimatum.initial_octets.value,
				 domain_pdu->u.reject_user_ultimatum.initial_octets.length);
}

/**************************************************************************/
void pduLogAttachUserRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile, "placeholder = %c\n",
			domain_pdu->u.attach_user_request.placeholder);
}

/**************************************************************************/
void pduLogAttachUserConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.attach_user_confirm.result);
	pduLog(logfile,"\tinitiator = %u\n",
			domain_pdu->u.attach_user_confirm.initiator);
}

/**************************************************************************/
void pduLogDetachUserRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintPDUReason(logfile,domain_pdu->u.detach_user_request.reason);
	PrintSetOfUserIDs(logfile,
						domain_pdu->u.detach_user_request.user_ids);
}


/**************************************************************************/
void pduLogDetachUserIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	PrintPDUReason(logfile,domain_pdu->u.detach_user_indication.reason);
	PrintSetOfUserIDs(logfile,
						domain_pdu->u.detach_user_indication.user_ids);
}

/**************************************************************************/
void pduLogChannelJoinRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\t\tuser_id = %u\n",
			domain_pdu->u.channel_join_request.initiator);
	pduLog(logfile,"\t\tchannel_id = %u\n",
			domain_pdu->u.channel_join_request.channel_id);
}

/**************************************************************************/
void pduLogChannelJoinConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult:  ");
	PrintPDUResult(logfile,domain_pdu->u.channel_join_confirm.result);
	pduLog(logfile,"\tinitiator userID = %u\n",
				domain_pdu->u.channel_join_confirm.initiator);
	pduLog(logfile,"\trequested channel ID = %u\n",
				domain_pdu->u.channel_join_confirm.requested);
	pduLog(logfile,"\tjoin channel ID = %u\n",
				domain_pdu->u.channel_join_confirm.join_channel_id);
}

/**************************************************************************/
void pduLogChannelLeaveRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tChannel IDs: \n");
	PrintSetOfChannelIDs(logfile, 
						 domain_pdu->u.channel_leave_request.channel_ids);
}

/**************************************************************************/
void pduLogChannelConveneRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator user ID = %u\n",
			domain_pdu->u.channel_convene_request.initiator);
}

/**************************************************************************/
void pduLogChannelConveneConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.channel_convene_confirm.result);
	pduLog(logfile,"\tInitiator user ID = %u\n",
			domain_pdu->u.channel_convene_confirm.initiator);
	pduLog(logfile,"\tPrivate channel ID = %u\n",
			domain_pdu->u.channel_convene_confirm.convene_channel_id);
}

/**************************************************************************/
void pduLogChannelDisbandRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_disband_request.initiator);
	pduLog(logfile,"\tPrivate channel ID = %u\n",
			domain_pdu->u.channel_disband_request.channel_id);
}

/**************************************************************************/
void pduLogChannelDisbandIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_disband_indication.channel_id);
}

/**************************************************************************/
void pduLogChannelAdmitRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_admit_request.initiator);
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_admit_request.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_admit_request.user_ids);
}

/**************************************************************************/
void pduLogChannelAdmitIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_admit_indication.initiator);
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_admit_indication.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_admit_indication.user_ids);
}

/**************************************************************************/
void pduLogChannelExpelRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.channel_expel_request.initiator);
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_expel_request.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_expel_request.user_ids);
}

/**************************************************************************/
void pduLogChannelExpelIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tPrivate Channel ID = %u\n",
			domain_pdu->u.channel_expel_indication.channel_id);
	pduLog(logfile,"\tUser IDs Admitted: \n");
	PrintSetOfUserIDs(logfile,domain_pdu->u.channel_expel_indication.user_ids);
}

/**************************************************************************/
void pduLogSendDataRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.send_data_request.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.send_data_request.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.send_data_request.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.send_data_request.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.send_data_request.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.send_data_request.user_data.value,
			domain_pdu->u.send_data_request.user_data.length);
}

/**************************************************************************/
void pduLogSendDataIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.send_data_indication.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.send_data_indication.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.send_data_indication.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.send_data_indication.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.send_data_indication.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.send_data_indication.user_data.value,
			domain_pdu->u.send_data_indication.user_data.length);
}

/**************************************************************************/
void pduLogUniformSendDataRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.uniform_send_data_request.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.uniform_send_data_request.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.uniform_send_data_request.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.uniform_send_data_request.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.uniform_send_data_request.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.uniform_send_data_request.user_data.value,
			domain_pdu->u.uniform_send_data_request.user_data.length);
}

/**************************************************************************/
void pduLogUniformSendDataIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.uniform_send_data_indication.initiator);
	pduLog(logfile,"\tChannel ID = %u\n",
			domain_pdu->u.uniform_send_data_indication.channel_id);
	pduLog(logfile,"\tPriority: ");
	PrintPDUPriority(logfile,domain_pdu->u.uniform_send_data_indication.data_priority);
	pduLog(logfile,"\tSegmentation: ");
	PrintPDUSegmentation(logfile,domain_pdu->u.uniform_send_data_indication.segmentation);
	pduLog(logfile,"\tUser Data (%u octets):\n",
			domain_pdu->u.uniform_send_data_indication.user_data.length);
	pduRawOutput(logfile,
			domain_pdu->u.uniform_send_data_indication.user_data.value,
			domain_pdu->u.uniform_send_data_indication.user_data.length);
}

/**************************************************************************/
void pduLogTokenGrabRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_grab_request.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_grab_request.token_id);
}

/**************************************************************************/
void pduLogTokenGrabConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_grab_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_grab_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_grab_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_grab_confirm.token_status);
}

/**************************************************************************/
void pduLogTokenInhibitRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_inhibit_request.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_inhibit_request.token_id);
}

/**************************************************************************/
void pduLogTokenInhibitConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_inhibit_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_inhibit_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_inhibit_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_inhibit_confirm.token_status);
}

/**************************************************************************/
void pduLogTokenGiveRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_give_request.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_request.token_id);
	pduLog(logfile,"\tRecipient User ID = %u\n",
			domain_pdu->u.token_give_request.recipient);
}

/**************************************************************************/
void pduLogTokenGiveIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_give_indication.initiator);
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_indication.token_id);
	pduLog(logfile,"\tRecipient User ID = %u\n",
			domain_pdu->u.token_give_indication.recipient);
}

/**************************************************************************/
void pduLogTokenGiveResponse(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_give_response.result);
	pduLog(logfile,"\tRecipient User ID = %u\n",
			domain_pdu->u.token_give_response.recipient);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_response.token_id);
}	

/**************************************************************************/
void pduLogTokenGiveConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_give_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_give_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_give_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_give_confirm.token_status);
}	

/**************************************************************************/
void pduLogTokenPleaseRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_please_request.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_please_request.token_id);
}

/**************************************************************************/
void pduLogTokenPleaseIndication(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_please_indication.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_please_indication.token_id);
}

/**************************************************************************/
void pduLogTokenReleaseRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_release_request.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_release_request.token_id);
}

/**************************************************************************/
void pduLogTokenReleaseConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tResult: ");
	PrintPDUResult(logfile,domain_pdu->u.token_release_confirm.result);
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_release_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_release_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_release_confirm.token_status);
}

/**************************************************************************/
void pduLogTokenTestRequest(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_test_request.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_test_request.token_id);
}

/**************************************************************************/
void pduLogTokenTestConfirm(FILE *logfile, PDomainMCSPDU domain_pdu)
{
	pduLog(logfile,"\tInitiator User ID = %u\n",
			domain_pdu->u.token_test_confirm.initiator);	
	pduLog(logfile,"\tToken ID = %u\n",
			domain_pdu->u.token_test_confirm.token_id);
	PrintTokenStatus(logfile,domain_pdu->u.token_test_confirm.token_status);
}	


//****************************************************************/
/****
 **** Service Functions for logging PDU structures.
 ****/

/**************************************************************************/
void PrintSetOfUserIDs(FILE *logfile, PSetOfUserIDs user_ids)
{
	unsigned int i = 0;
	for(i=0; user_ids!=NULL; i++)
	{
		pduLog(logfile, "\t\trecord[%u] = %u\n",i,user_ids->value);
		user_ids = user_ids->next;
	}
}

/**************************************************************************/
void PrintSetOfTokenAttributes(FILE *logfile, 
							   PSetOfPDUTokenAttributes token_attribute_obj)
{
	unsigned int i = 0;
	for(i=0; token_attribute_obj!=NULL;i++)
	{
		pduLog(logfile,"\t**** record [%u] ****\n",i);
		PrintTokenAttributes(logfile, token_attribute_obj->value);
		token_attribute_obj = token_attribute_obj->next;
	}
}

/**************************************************************************/
void PrintSetOfChannelIDs(FILE *logfile, PSetOfChannelIDs channel_ids)
{
	unsigned int i = 0;
	for(i=0; channel_ids!=NULL; i++)
	{
		pduLog(logfile, "\t\trecord[%u] = %u\n",i,channel_ids->value);
		channel_ids = channel_ids->next;
	}
}

/**************************************************************************/
void PrintSetOfTokenIDs(FILE *logfile, PSetOfTokenIDs token_ids)
{
	unsigned int i = 0;
	for(i=0; token_ids!=NULL; i++)
	{
		pduLog(logfile, "\t\trecord[%u] = %u\n",i,token_ids->value);
		token_ids = token_ids->next;
	}
}

/**************************************************************************/
void PrintChannelAttributes(FILE *logfile, PDUChannelAttributes channel_attributes)
{
	switch(channel_attributes.choice)
	{
	case CHANNEL_ATTRIBUTES_STATIC_CHOSEN:
		pduLog(logfile, "\tStatic Channel Attributes:\n");
		pduLog(logfile, "\t\tchannel_id = %u\n",
					channel_attributes.u.channel_attributes_static.channel_id);
		break;
	case CHANNEL_ATTRIBUTES_USER_ID_CHOSEN: 
		pduLog(logfile, "\tUser ID Channel Attributes:\n");
		PrintT120Boolean(logfile, "\t\tjoined",
							(BOOL) channel_attributes.u.channel_attributes_user_id.joined);
		pduLog(logfile, "\t\tuser_id = %u\n",
							channel_attributes.u.channel_attributes_user_id.user_id);
		break;
	case CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN:
		pduLog(logfile,"\tPrivate Channel Attributes:\n");
		PrintT120Boolean(logfile, "\t\tjoined",
							(BOOL) channel_attributes.u.channel_attributes_private.joined);
		pduLog(logfile,"\t\tchannel_id = %u\n",
							channel_attributes.u.channel_attributes_private.channel_id);
		pduLog(logfile,"\t\tmanager = %u\n",
							channel_attributes.u.channel_attributes_private.manager);
		PrintSetOfUserIDs(logfile, channel_attributes.u.channel_attributes_private.admitted);
		break;
	case CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN:
		pduLog(logfile,"\tAssigned Channel Attributes\n");
		pduLog(logfile,"\t\tchannel_id = %u\n",
						channel_attributes.u.channel_attributes_assigned.channel_id);
		break;
	default:
		pduLog(logfile,"\tERROR -- canot figure out channel attributes\n");
		break;
	}
}

/**************************************************************************/
void PrintTokenAttributes(FILE *logfile, PDUTokenAttributes token_attributes)
{
	switch(token_attributes.choice)
	{
	case GRABBED_CHOSEN:
		pduLog(logfile,"\tGrabbed Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.grabbed.token_id);
		pduLog(logfile,"\t\tgrabber = %u\n",
				token_attributes.u.grabbed.grabber);
		break;
	case INHIBITED_CHOSEN:
		pduLog(logfile,"\tInhibited Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.inhibited.token_id);
		pduLog(logfile,"\t\tInhibitors:\n");
		PrintSetOfUserIDs(logfile,token_attributes.u.inhibited.inhibitors);
		break;
	case GIVING_CHOSEN:
		pduLog(logfile,"\tGiving Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.giving.token_id);
		pduLog(logfile,"\t\tgrabber = %u\n",
				token_attributes.u.giving.grabber);
		pduLog(logfile,"\t\trecipient = %u\n",
				token_attributes.u.giving.recipient);
		break;
	case UNGIVABLE_CHOSEN:
		pduLog(logfile,"\tUngivable Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.ungivable.token_id);
		pduLog(logfile,"\t\tgrabber = %u\n",
				token_attributes.u.ungivable.grabber);
		break;
	case GIVEN_CHOSEN:
		pduLog(logfile,"\tGiven Token Attributes:\n");
		pduLog(logfile,"\t\ttoken_id = %u\n",
				token_attributes.u.given.token_id);
		pduLog(logfile,"\t\trecipient = %u\n",
				token_attributes.u.given.recipient);
		break;
	default:
		pduLog(logfile,"ERROR: cannot determine token attributes\n");
		break;
	}
}

/**************************************************************************/
void PrintPDUDomainParameters(FILE *logfile, PDUDomainParameters domain_params)
{
	pduLog(logfile,"\t\tmax_channel_ids = %u \n",domain_params.max_channel_ids);
	pduLog(logfile,"\t\tmax_user_ids = %u\n",domain_params.max_user_ids);
	pduLog(logfile,"\t\tmax_token_ids = %u\n",domain_params.max_token_ids);
	pduLog(logfile,"\t\tnumber_priorities = %u\n",domain_params.number_priorities);
	pduLog(logfile,"\t\tmin_throughput = %u\n",domain_params.min_throughput);
	pduLog(logfile,"\t\tmax_height = %u\n",domain_params.max_height);
	pduLog(logfile,"\t\tmax_mcspdu_size = %u\n",domain_params.max_mcspdu_size);
	pduLog(logfile,"\t\tprotocol_version = %u\n",domain_params.protocol_version);
}

/**************************************************************************/
void PrintT120Boolean(	FILE *	logfile,
						Char *	print_text,
						BOOL	T120Boolean)
{
	if( T120Boolean == FALSE )
		pduLog(	logfile, "%s = FALSE\n", print_text );
	else
		pduLog(	logfile, "%s = TRUE\n", print_text );
}

/************************************************************************/
BOOL CopyTextToChar(char * print_string,
					       unsigned short * text_string_value,
						   unsigned int text_string_length)
{
	UShort  i;
	
	if(print_string==NULL)
		return(FALSE);

	if((text_string_length <= 0)||(text_string_value == NULL))
		return( FALSE );

	if (*text_string_value == 0x0000)
		return (FALSE);

	for(i=0;i < text_string_length;i++)
	{
		//if((&text_string_value[i]==NULL) || (text_string_value[i]==0x0000))
		//	break;
		print_string[i] = (char) text_string_value[i];
	
	}
	print_string[text_string_length] = '\0';
	
	return(TRUE);
}
/********************************************************************/


#endif //// PDULOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\mcsdllif.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	mcsdllif.cpp
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the MCAT MCS DLL interface class.
 *		This class is designed to work with Microsoft's implementation of the
 *		MCS DLL. All access by GCC to and from this DLL should pass through
 *		this class.
 *
 *		MCS interface objects represent the Service Access Point (SAP)
 *		between GCC and MCS.  Exactly how the interface works is an
 *		implementation matter for those classes that inherit from this one.
 *		This class defines the public member functions that GCC expects to be
 *		able to call upon to utilize MCS.
 *
 *		The public member functions defined here can be broken into two
 *		categories: those that are part of T.122; and those that are not.
 *		The T.122 functions include connect provider request, connect
 *		provider response, disconnect provider request, create domain, delete
 *		domain, send data request, etc.  All other member functions are
 *		considered a local matter from a standards point-of-view.  These
 *		functions include support for initialization and setup, as well as
 *		functions allowing GCC to poll MCS for activity.
 *
 *		This class contains a number of virtual functions which GCC needs to
 *		operate.  Making these functions virtual in the base class allows the
 *		MCS interface to be portable to most any platform.  All the platform
 *		specific code required to access MCS is contained in classes that will
 *		inherit from this one.
 *
 *		Note that this class also handles the connect provider confirms by
 *		keeping a list of all the objects with outstanding connect provider
 *		request.  These are held in the ConfirmObjectList.
 *
 *	Portable
 *		No
 *
 *	Author:
 *		Christos Tsollis
 */

#include "mcsdllif.h"
#include "mcsuser.h"
#include "gcontrol.h"


extern CRITICAL_SECTION g_csGCCProvider;

/*
 *	g_pMCSController
 *		This is a pointer to the one-and-only controller created within the
 *		MCS system.  This object is created during MCSInitialize by the process
 *		that is taking on the responsibilities of the node controller.
 */
extern PController		g_pMCSController;

void CALLBACK	MCSCallBackProcedure (UINT, LPARAM, PVoid);


//	MACROS used with the packet rebuilder
#define		SEND_DATA_PACKET			0
#define		UNIFORM_SEND_DATA_PACKET	1


extern MCSDLLInterface      *g_pMCSIntf;

/*
 *	MCSDLLInterface ( )
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the MCS Interface class. It is responsible
 *		for initializing the MCAT MCS DLL.  Any errors that occur during
 *		initialization are returned in the error_value provided.
 */
MCSDLLInterface::MCSDLLInterface(PMCSError	error_value)
:
	m_ConfirmConnHdlConfList2(),
	m_MCSUserList()
{	
	/*
	**	Create/initialize the MCS Controller object.
	*/
	DBG_SAVE_FILE_LINE
	g_pMCSController = new Controller (error_value);
	
	if (g_pMCSController == NULL) {
		/*
		 *	The allocation of the controller failed.  Report and return
		 *	the appropriate error.
		 */
		WARNING_OUT (("MCSDLLInterface::MCSDLLInterface: controller creation failed"));
		*error_value = MCS_ALLOCATION_FAILURE;
	}
#ifdef _DEBUG
	else if (*error_value != MCS_NO_ERROR) {
		WARNING_OUT (("MCSDLLInterface::MCSDLLInterface: MCS controller is faulty."));
	}
#endif // _DEBUG
}


/*
 *	~MCSDLLInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the MCS Interface class. It is responsible
 *		for cleaning up both itself and the MCAT MCS DLL.
 */
MCSDLLInterface::~MCSDLLInterface ()
{
	/*
	 *	Destroy the controller, which will clean up all resources
	 *	in use at this time.  Then reset the flag indicating that
	 *	MCS is initialized (since it no longer is).
	 */
	TRACE_OUT (("MCSDLLInterface::~MCSDLLInterface: deleting controller"));
	if (NULL != g_pMCSController) {
		g_pMCSController->Release();
	}
 }

/*
 *	MCSError	ConnectProviderRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This T.122 primitive is used to connect two domains. This request
 *		should always be followed by a connect provider confirm.  The
 *		confirm will be sent to be object specified by the confirm object
 *		the is passed into this routine.
 */
MCSError	MCSDLLInterface::ConnectProviderRequest (
							GCCConfID          *calling_domain,
							GCCConfID          *called_domain,
							TransportAddress	calling_address,
							TransportAddress	called_address,
							BOOL				fSecure,
							DBBoolean			upward_connection,
							PUChar				user_data,
							ULong				user_data_length,
							PConnectionHandle	connection_handle,
							PDomainParameters	domain_parameters,
							CConf		        *confirm_object)
{
	MCSError			mcs_error;
	ConnectRequestInfo	connect_request_info;

	/*
	 *	Pack all necessary information into a structure, since it will not
	 *	all fit into the 4 byte parameter that is sent with the message.
	 */
	connect_request_info.calling_domain = calling_domain;
	connect_request_info.called_domain = called_domain;
	connect_request_info.calling_address = calling_address;
	connect_request_info.called_address = called_address;
	connect_request_info.fSecure = fSecure;
	connect_request_info.upward_connection = upward_connection;
	connect_request_info.domain_parameters = domain_parameters;
	connect_request_info.user_data = user_data;
	connect_request_info.user_data_length = user_data_length;
	connect_request_info.connection_handle = connection_handle;

	/*
	 *	Send a connect provider request message to the controller through its
	 *	owner callback function.
	 */
	ASSERT (g_pMCSController);
	mcs_error = g_pMCSController->HandleAppletConnectProviderRequest(&connect_request_info);

	if (mcs_error == MCS_NO_ERROR)
	{
		/*
		**	The confirm object list maintains a list of object
		**	pointers that have outstanding request. When the confirms
		**	come back in, they will be routed to the appropriate object
		**	based on the connection handle.
		*/
		mcs_error = AddObjectToConfirmList (confirm_object,
											*connection_handle);
	}
	else
	{
		WARNING_OUT(("MCSDLLInterface::ConnectProviderRequest: error = %d", mcs_error));
	}

	return (mcs_error);
}

MCSError MCSDLLInterface::ConnectProviderResponse (
					ConnectionHandle	connection_handle,
					GCCConfID          *domain_selector,
					PDomainParameters	domain_parameters,
					Result				result,
					PUChar				user_data,
					ULong				user_data_length)
{
	ConnectResponseInfo		connect_response_info;

	/*
	 *	Pack all necessary information into a structure, since it will not
	 *	all fit into the 4 byte parameter that is sent with the message.
	 */
	connect_response_info.connection_handle = connection_handle;
	connect_response_info.domain_selector = domain_selector;
	connect_response_info.domain_parameters = domain_parameters;
	connect_response_info.result = result;
	connect_response_info.user_data = user_data;
	connect_response_info.user_data_length = user_data_length;

	ASSERT (g_pMCSController);
	/*
	 *	Send a connect provider response message to the controller through its
	 *	owner callback function.
	 */
	return g_pMCSController->HandleAppletConnectProviderResponse(&connect_response_info);
}

/*
 *	MCSError	DisconnectProviderRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to disconnect a node from a particular connection.
 *		This can be either an upward or downward connection
 */
MCSError	MCSDLLInterface::DisconnectProviderRequest (
							ConnectionHandle	connection_handle)
{
	ASSERT (g_pMCSController);
	m_ConfirmConnHdlConfList2.Remove(connection_handle);
	return g_pMCSController->HandleAppletDisconnectProviderRequest(connection_handle);
}

/*
 *	MCSError	AttachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to create a user attachment to MCS. It will result
 *		in an attach user confirm.
 */
MCSError	MCSDLLInterface::AttachUserRequest
(
    GCCConfID          *domain_selector,
    PIMCSSap           *ppMCSSap,
    MCSUser            *user_object
)
{
	MCSError	mcs_error;

	mcs_error = MCS_AttachRequest (ppMCSSap,
									(DomainSelector) domain_selector,
									sizeof(GCCConfID),
									MCSCallBackProcedure,
									(PVoid) user_object,
									ATTACHMENT_DISCONNECT_IN_DATA_LOSS |
									ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);

	if (mcs_error == MCS_NO_ERROR)
		m_MCSUserList.Append(user_object);
	
	return (mcs_error);
}

/*
 *	MCSError	DetachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used when a user of MCS whishes to detach itself from
 *		a domain.
 */
MCSError	MCSDLLInterface::DetachUserRequest (PIMCSSap pMCSSap,
												PMCSUser pMCSUser)
{
	MCSError	mcs_error;
#ifdef DEBUG
	UINT_PTR	storing = (UINT_PTR) this;
#endif // DEBUG
	
	mcs_error = pMCSSap->ReleaseInterface();
	ASSERT ((UINT_PTR) this == storing);
	m_MCSUserList.Remove(pMCSUser);

	return (mcs_error);
}

/*
 *	void	ProcessCallback ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called whenever a callback message is received by
 *		the "C" callback routine. It is responsible for both processing
 *		callback messages and forwarding callback messages on to the
 *		appropriate object.
 */
void	MCSDLLInterface::ProcessCallback (unsigned int	message,
												LPARAM	parameter,
												PVoid	object_ptr)
{
	ConnectionHandle		connection_handle;
	CConf					*pConf;

	/*
	**	Before processing any callbacks from MCS we must enter a critical
	**	section to gaurantee that we do not attempt to process a message
	**	in GCC while its own thread is running.
	*/
	EnterCriticalSection (&g_csGCCProvider);

    if (MCS_SEND_DATA_INDICATION         == message ||
        MCS_UNIFORM_SEND_DATA_INDICATION == message) {

        /*
        **	First check the segmentation flag to make sure we have the
        **	entire packet.  If not we must give the partial packet to
        **	the packet rebuilder and wait for the remainder of the data.
        */
        ASSERT(((PSendData)parameter)->segmentation == (SEGMENTATION_BEGIN | SEGMENTATION_END));

    	if (IsUserAttachmentVaid ((PMCSUser)object_ptr)) {
    		//	Process the entire packet
    		if (message == MCS_SEND_DATA_INDICATION)
    		{
    		    ((PMCSUser)object_ptr)->ProcessSendDataIndication((PSendData) parameter);
    		}
    		else
    		{
    		    ((PMCSUser)object_ptr)->ProcessUniformSendDataIndication((PSendData) parameter);
    		}
    	}
    }
    else {
        //
        // Non-Send-Data callbacks.
        //
        WORD    wHiWordParam = HIWORD(parameter);
        WORD    wLoWordParam = LOWORD(parameter);

        switch (message)
        {
            /*
            **	These messages are handled by the object passed in through
            **	the user data field.
            */
            case MCS_DETACH_USER_INDICATION:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->ProcessDetachUserIndication(
            	                                (Reason) wHiWordParam,
            	                                (UserID) wLoWordParam);
            	}
            	break;

            case MCS_ATTACH_USER_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->ProcessAttachUserConfirm(
            	                                (Result) wHiWordParam,
            	                                (UserID) wLoWordParam);
            	}
            	break;

            case MCS_CHANNEL_JOIN_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->ProcessChannelJoinConfirm(
            	                                (Result) wHiWordParam,
            	                                (ChannelID) wLoWordParam);
            	}
            	break;

            case MCS_CHANNEL_LEAVE_INDICATION:
#if 0 // LONCHANC: MCSUser does not handle this message.
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr))
            	{
            		((PMCSUser)object_ptr)->OwnerCallback(CHANNEL_LEAVE_INDICATION,
            											 NULL,
            											 parameter);
            	}
#endif // 0
            	break;

            case MCS_TOKEN_GRAB_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenGrabConfirm(
                                                (TokenID) wLoWordParam,
                                                (Result) wHiWordParam);
            	}
            	break;

            case MCS_TOKEN_GIVE_INDICATION:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenGiveIndication(
                                                (TokenID) wLoWordParam,
                                                (UserID) wHiWordParam);
            	}
            	break;

            case MCS_TOKEN_GIVE_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenGiveConfirm(
                                                (TokenID) wLoWordParam,
                                                (Result) wHiWordParam);
            	}
            	break;

            case MCS_TOKEN_PLEASE_INDICATION:
#ifdef JASPER
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenPleaseIndication(
                                                (TokenID) wLoWordParam,
                                                (UserID) wHiWordParam);
            	}
#endif // JASPER
            	break;

            case MCS_TOKEN_RELEASE_CONFIRM:
#ifdef JASPER
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenReleaseConfirm(
                                                (TokenID) wLoWordParam,
                                                (Result) wHiWordParam);
            	}
#endif // JASPER
            	break;

            case MCS_TOKEN_TEST_CONFIRM:
            	if (IsUserAttachmentVaid ((PMCSUser)object_ptr) )
            	{
            		((PMCSUser)object_ptr)->ProcessTokenTestConfirm(
                                                (TokenID) wLoWordParam,
                                                (TokenStatus) wHiWordParam);
            	}
            	break;

            /*
            **	These messages are handled by the object that created the
            **	MCS DLL interface.
            */
#ifdef TSTATUS_INDICATION
            case MCS_TRANSPORT_STATUS_INDICATION:
            	if (g_pControlSap != NULL)
            	{
            		g_pControlSap->TransportStatusIndication((PTransportStatus) parameter);
            	}
            	break;
#endif

            case MCS_CONNECT_PROVIDER_INDICATION:
            	g_pGCCController->ProcessConnectProviderIndication((PConnectProviderIndication) parameter);
            	// Cleanup the controller message.
            	delete (PConnectProviderIndication) parameter;
            	break;


            case MCS_DISCONNECT_PROVIDER_INDICATION:
            	connection_handle = (ConnectionHandle) parameter;

                g_pGCCController->ProcessDisconnectProviderIndication(connection_handle);

            	/*
            	**	If no entry exists in the confirm object list, there
            	**	is a problem. All confirms must have an associated
            	**	response.
            	*/
            	if (m_ConfirmConnHdlConfList2.Remove(connection_handle))
            	{
            		DisconnectProviderRequest(connection_handle);
            	}
            	break;

            /*
            **	All connect provider confirms must be matched up with the
            **	connect provider request to determine where to route the
            **	message.
            */
            case MCS_CONNECT_PROVIDER_CONFIRM:
            	connection_handle = ((PConnectProviderConfirm)parameter)->connection_handle;

            	/*
            	**	If no entry exists in the confirm object list, there
            	**	is a problem. All confirms must have an associated
            	**	response.
            	*/
            	if (NULL != (pConf = m_ConfirmConnHdlConfList2.Remove(connection_handle)))
            	{
            		//	Send the confirm to the appropriate object
            		if ((LPVOID) pConf != (LPVOID) LPVOID_NULL)
            		{
            			// confirm_object is a CConf.
            			pConf->ProcessConnectProviderConfirm((PConnectProviderConfirm) parameter);
            		}
            		else
            		{
            			// confirm_object is the GCC Controller.
            			g_pGCCController->ProcessConnectProviderConfirm((PConnectProviderConfirm)parameter);
            		}
            	}
            	else
            	{
            		WARNING_OUT(("MCSDLLInterface: ProcessCallback: Bad Connect"
            					" Provider Confirm received"));
            	}
            	
            	// Cleanup the controller message.
                CoTaskMemFree( ((PConnectProviderConfirm) parameter)->pb_cred );
            	delete (PConnectProviderConfirm) parameter;
            	break;
            	
            default:
            	WARNING_OUT(("MCSDLLInterface: ProcessCallback: Unsupported message"
            				" received from MCS = %d",message));
            	break;
    	}
    }

	//	Leave the critical section after the callback is processed.
	LeaveCriticalSection (&g_csGCCProvider);
}

/*
 *	void CALLBACK	MCSCallBackProcedure (	unsigned int message,
 *												LPARAM		 parameter,
 *												PVoid		 user_defined)
 *
 *	Functional Description:
 *		This routine receives callback messages directly from the MCAT MCS
 *		DLL.
 *
 *	Formal Parameters:
 *		message	(i)
 *			This is the mcs message to be processed
 *		parameter (i)
 *			Varies according to the message. See the MCAT programmers manual
 *		object_ptr (i)
 *			This is the user defined field that was passed to MCS on
 *			initialization.
 *
 *	Return Value:
 *		See ProcessCallback
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CALLBACK	MCSCallBackProcedure (unsigned int message,
										LPARAM		 parameter,
										PVoid		 user_defined)
{
	if (g_pMCSIntf != NULL)
		g_pMCSIntf->ProcessCallback (message, parameter, user_defined);
}


/*
 *	TranslateMCSResultToGCCResult ()
 *
 *	Public Function Description
 *		This routine translate a standard MCS result to a GCC result.
 */
GCCResult
TranslateMCSResultToGCCResult ( Result mcs_result )
{
	GCCResult	gcc_result;

    switch (mcs_result)
    {
    	case RESULT_SUCCESSFUL:
        	gcc_result = GCC_RESULT_SUCCESSFUL;
            break;

        case RESULT_PARAMETERS_UNACCEPTABLE:
        	gcc_result = GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE;
            break;

        case RESULT_USER_REJECTED:
        	gcc_result = GCC_RESULT_USER_REJECTED;
        	break;

		/*
		**	Note that we are making the assumption here that the only token
		**	that GCC deals with is a conductor token.
		*/
	    case RESULT_TOKEN_NOT_AVAILABLE:
			gcc_result = GCC_RESULT_IN_CONDUCTED_MODE;
			break;
			
	    case RESULT_TOKEN_NOT_POSSESSED:
			gcc_result = GCC_RESULT_NOT_THE_CONDUCTOR;
			break;
	
		/****************************************************************/
			
        case RESULT_UNSPECIFIED_FAILURE:
        default:
        	gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
        	break;
    }

    return (gcc_result);
}

/*
 *	MCSError	AddObjectToConfirmList ()
 *
 *	Functional Description:
 *		This function is used to add information about an object to the list
 *		which holds all information required to send connect provider confirms.
 *
 *	Formal Parameters:
 *		confirm_object (i)
 *			This is a pointer to the object the made the connect provider
 *			request.
 *		connection_handle (i)
 *			This is the connection handle returned from the connect provider
 *			request.
 *
 *	Return Value:
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
MCSError	MCSDLLInterface::AddObjectToConfirmList (
									CConf		        *pConf,
									ConnectionHandle	connection_handle)
{
	MCSError			return_value;

	/*
	**	First check to make sure that the list doesn't already contain the
	**	connection.
	*/
	if (m_ConfirmConnHdlConfList2.Find(connection_handle) == FALSE)
	{
		//	Add it to the list
		m_ConfirmConnHdlConfList2.Append(connection_handle, pConf ? pConf : (CConf *) LPVOID_NULL);
		return_value = MCS_NO_ERROR;
	}
	else
		return_value = MCS_INVALID_PARAMETER;

	return (return_value);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\mcslog.h ===
/**********************************************************************
 * File:     mcslog.h
 * Abstract: Function headers for protocol logging functions added
 * into MCSNC.DLL to read the contents of MCS PDU contents
 * sent and received from the T.123 layer.
 * Created:  2/18/96, Venkatesh Gopalakrishnan
 * Copyright (c) 1996 Microsoft Corpration
 ******************************************************************** */
 
 /* NOTE:  The contents of this file are only included IFF PDULOG is a
  * defined constant.  This constant will be defined in the Win32 Diagnostic
  * build configuration of MCSNC.DLL 
  */

 #ifdef PDULOG

 #ifndef _PROTLOG_H
 #define _PROTLOG_H
 

 #include <windows.h>
 #include <time.h>
 #include <stdio.h>
 
 #include "mpdutype.h"
 #include "mcspdu.h"
 
 #define MAXIMUM_PRINT_LENGTH 256
 #define LOG_FILE_NAME "mcslog.txt"
 #define SENT 0
 #define RECEIVED 1


 /* Enumerated Data types and corresponding strings used in
  * MCS PDUs.
  */

#define NOT_IN_USE			0
#define SELF_GRABBED		1
#define OTHER_GRABBED		2
#define SELF_INHIBITED		3
#define OTHER_INHIBITED		4
#define SELF_RECIPIENT		5
#define SELF_GIVING			6
#define OTHER_GIVING		7

#define NOT_IN_USE_STR			"NOT_IN_USE"
#define SELF_GRABBED_STR		"SELF_GRABBED"
#define OTHER_GRABBED_STR		"OTHER_GRABBED"
#define SELF_INHIBITED_STR		"SELF_INHIBITED"
#define OTHER_INHIBITED_STR		"OTHER_INHIBITED"
#define SELF_RECPIENT_STR		"SELF_RECIPIENT"
#define SELF_GIVING_STR			"SELF_GIVING"
#define OTHER_GIVING_STR		"OTHER_GIVING"

#define TOP_PRI			0
#define HIGH_PRI		1
#define MEDIUM_PRI		2
#define LOW_PRI			3

#define TOP_STR					"TOP_PRIORITY\n"
#define HIGH_STR				"HIGH_PRIORITY\n"
#define MEDIUM_STR				"MEDIUM_PRIORITY\n"
#define LOW_STR					"LOW_PRIORITY\n"

#define RT_SUCCESSFUL					0
#define RT_DOMAIN_MERGING				1
#define RT_DOMAIN_NOT_HIERARCHICAL		2
#define RT_NO_SUCH_CHANNEL				3
#define	RT_NO_SUCH_DOMAIN				4
#define RT_NO_SUCH_USER					5
#define RT_NOT_ADMITTED					6
#define RT_OTHER_USER					7
#define	RT_PARAMETERS_UNACCEPTABLE		8
#define RT_TOKEN_NOT_AVAILABLE			9
#define RT_TOKEN_NOT_POSESSED			10
#define RT_TOO_MANY_CHANNELS			11
#define RT_TOO_MANY_TOKENS				12
#define RT_TOO_MANY_USERS				13
#define RT_UNSPECIFIED_FAILURE			14
#define RT_USER_REJECTED				15


/*** 
**** The following function headers are for service functions
**** for logging the value(s) of typical data types found in 
**** several MCS PDU structures.
****/ 
void PrintPDUResult(FILE *logfile, unsigned int result);
void PrintPDUPriority(FILE *logfile, unsigned int priority);
void PrintTokenStatus(FILE *logfile, unsigned int token_status);
void PrintPDUReason(FILE *logfile, unsigned int reason);
void PrintDiagnostic(FILE *logfile, unsigned int diagnostic);
void PrintPDUSegmentation(FILE *logfile, unsigned char segmentation);


void PrintSetOfChannelIDs(FILE *logfile, PSetOfChannelIDs channel_ids);
void PrintSetOfUserIDs(FILE *logfile, PSetOfUserIDs user_ids);
void PrintSetOfTokenIDs(FILE *logfile, PSetOfTokenIDs token_ids);
void PrintSetOfTokenAttributes(FILE *logfile, 
							PSetOfPDUTokenAttributes token_attribute_obj);

void PrintPDUDomainParameters(FILE *logfile, PDUDomainParameters domain_params);
void PrintT120Boolean(FILE *logfile, char * string, BOOL boolean);
void PrintCharData(FILE *logfile, unsigned char *string, unsigned int length);

void PrintChannelAttributes(FILE *logfile, PDUChannelAttributes channel_attributes);
void PrintTokenAttributes(FILE *logfile, PDUTokenAttributes token_attributes);

int InitializeMCSLog();
 /* Description:
  *         Resets the mcs protocol log file and reads any
  *         ini file parameters
  */
  

char *pszTimeStamp(); 
 /* Desicription:
  *         This function is an easy interfact to getting the time the
  *         PDU was encoded or decoded from MCS to T.123 or vice versa.
  */
  
void pduLog(FILE *file, char * format_string,...);
 /* Description:
  *         This function is used to place PDU information in a protocol
  *         log file.  There is currently no return value.  This may change.
  */       

void pduFragmentation(FILE *logfile, unsigned int i);
 /* Description:
  *         This function logs weather or not the PDU is complete
  *         or fragmented.
  */

void pduRawOutput(FILE *logfile, unsigned char * data, unsigned long length);
 /* Description:
  *         This function logs a hex dump of the raw encoded MCS PDU that
  *         is sent over the wire via MCS.
  */
  

void mcsLog(PPacket packet,  PDomainMCSPDU domain_pdu, unsigned int direction);
 /* Description:
  *         This function takes care of the log headers and footers to 
  *         attempt at compatibility with a certain third party mcs log
  *         reader.
  */
void mcsConnectLog(PPacket packet, PConnectMCSPDU connect_pdu, unsigned int direction);
 /* same as above, but for Connect PDUs */

void pduLogMCSDomainInfo(FILE *file, PDomainMCSPDU domain_pdu);
/* Description:
 *         This function takes the mcs pdu structure, and based on
 *         Which type of MCSPDU that it is, logs internal information
 *         in the PDU.
 */
void pduLogMCSConnectInfo(FILE *file, PConnectMCSPDU connect_pdu);
 /* same as above but for Connect PDUs */

void pduDirection(FILE *logfile,unsigned int direction);
 /* Description:
  *         This function logs information whether the mcs pdu was sent
  *         or received.
  */



/*****
 ***** The following headers are for functions that log the output of
 ***** each different type of MCS PDU.  Every MCS PDU is covered here.
 *****/

void pduLogConnectInitial(FILE *file, PConnectMCSPDU connect_pdu);
 /* Description:
  *         This function takes the connect_pdu and writes the component parts
  *         of the mcs ConnectInitial PDU.
  */
void pduLogConnectResponse(FILE *file, PConnectMCSPDU connect_pdu);
void pduLogConnectAdditional(FILE *file, PConnectMCSPDU connect_pdu);
void pduLogConnectResult(FILE *file, PConnectMCSPDU connect_pdu);
void pduLogPlumbDomainIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogErectDomainRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeChannelsRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeChannelsConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogPurgeChannelIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeTokensRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogMergeTokensConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogPurgeTokenIndication(FILE *file, PDomainMCSPDU domain_pdu); 
void pduLogDisconnectProviderUltimatum(FILE *file, PDomainMCSPDU domain_pdu); 
void pduLogRejectUltimatum(FILE *logfile, PDomainMCSPDU domain_pdu);
void pduLogAttachUserRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogAttachUserConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogDetachUserRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogDetachUserIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelJoinRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelJoinConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelLeaveRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelConveneRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelConveneConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelDisbandRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelDisbandIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelAdmitRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelAdmitIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelExpelRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogChannelExpelIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogSendDataRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogSendDataIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogUniformSendDataRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogUniformSendDataIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGrabRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGrabConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenInhibitRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenInhibitConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveResponse(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenGiveConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenPleaseRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenPleaseIndication(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenReleaseRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenReleaseConfirm(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenTestRequest(FILE *file, PDomainMCSPDU domain_pdu);
void pduLogTokenTestConfirm(FILE *file, PDomainMCSPDU domain_pdu);
 
 
BOOL CopyTextToChar(char * print_string, 
						   unsigned short *text_string_value, 
						   unsigned int text_string_length);

 


 #endif  // <<<<<<<<<<<< _PROTLOG_H
 #endif  // <<<<<<<<<<<< PDULOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\nccglbl.hpp ===
/****************************************************************************/
/*                                                                          */
/* NCCGLBL.HPP                                                              */
/*                                                                          */
/* Global header for NCC.                                                   */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  11Sep95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __NCCGLBL_H_
#define __NCCGLBL_H_

#include "sap.h" // for NCUIMSG_BASE

enum
{
    NCMSG_QUERY_REMOTE_FAILURE  = NCMSG_BASE + 0,
    NCMSG_FIRST_ROSTER_RECVD    = NCMSG_BASE + 1,
};


#ifdef _DEBUG
extern BOOL    g_fInterfaceBreak;
__inline void InterfaceEntry(void) { if (g_fInterfaceBreak) DebugBreak(); }
#else
#define InterfaceEntry()    
#endif // _DEBUG


HRESULT GetGCCRCDetails(GCCError gccRC);

HRESULT GetGCCResultDetails(GCCResult gccRC);

GCCResult MapRCToGCCResult(HRESULT rc);

LPWSTR GetNodeName(void);

#endif /* __NCCGLBL_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\mcspdu.c ===
#include <windows.h>
#include "mcspdu.h"

ASN1module_t MCSPDU_Module = NULL;

static int ASN1CALL ASN1Enc_Given(ASN1encoding_t enc, Given *val);
static int ASN1CALL ASN1Enc_Ungivable(ASN1encoding_t enc, Ungivable *val);
static int ASN1CALL ASN1Enc_Giving(ASN1encoding_t enc, Giving *val);
static int ASN1CALL ASN1Enc_Inhibited(ASN1encoding_t enc, Inhibited *val);
static int ASN1CALL ASN1Enc_Grabbed(ASN1encoding_t enc, Grabbed *val);
static int ASN1CALL ASN1Enc_ChannelAttributesAssigned(ASN1encoding_t enc, ChannelAttributesAssigned *val);
static int ASN1CALL ASN1Enc_ChannelAttributesPrivate(ASN1encoding_t enc, ChannelAttributesPrivate *val);
static int ASN1CALL ASN1Enc_ChannelAttributesUserID(ASN1encoding_t enc, ChannelAttributesUserID *val);
static int ASN1CALL ASN1Enc_ChannelAttributesStatic(ASN1encoding_t enc, ChannelAttributesStatic *val);
extern int ASN1CALL ASN1Enc_PDUDomainParameters(ASN1encoding_t enc, PDUDomainParameters *val);
extern int ASN1CALL ASN1Enc_ConnectInitialPDU(ASN1encoding_t enc, ConnectInitialPDU *val);
extern int ASN1CALL ASN1Enc_ConnectResponsePDU(ASN1encoding_t enc, ConnectResponsePDU *val);
extern int ASN1CALL ASN1Enc_ConnectAdditionalPDU(ASN1encoding_t enc, ConnectAdditionalPDU *val);
extern int ASN1CALL ASN1Enc_ConnectResultPDU(ASN1encoding_t enc, ConnectResultPDU *val);
static int ASN1CALL ASN1Enc_PlumbDomainIndicationPDU(ASN1encoding_t enc, PlumbDomainIndicationPDU *val);
static int ASN1CALL ASN1Enc_ErectDomainRequestPDU(ASN1encoding_t enc, ErectDomainRequestPDU *val);
static int ASN1CALL ASN1Enc_PDUChannelAttributes(ASN1encoding_t enc, PDUChannelAttributes *val);
static int ASN1CALL ASN1Enc_MergeChannelsRequestPDU(ASN1encoding_t enc, MergeChannelsRequestPDU *val);
static int ASN1CALL ASN1Enc_MergeChannelsConfirmPDU(ASN1encoding_t enc, MergeChannelsConfirmPDU *val);
static int ASN1CALL ASN1Enc_PurgeChannelIndicationPDU(ASN1encoding_t enc, PurgeChannelIndicationPDU *val);
static int ASN1CALL ASN1Enc_PDUTokenAttributes(ASN1encoding_t enc, PDUTokenAttributes *val);
static int ASN1CALL ASN1Enc_SetOfUserIDs(ASN1encoding_t enc, PSetOfUserIDs *val);
static int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes(ASN1encoding_t enc, PSetOfPDUChannelAttributes *val);
static int ASN1CALL ASN1Enc_SetOfChannelIDs(ASN1encoding_t enc, PSetOfChannelIDs *val);
static int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes(ASN1encoding_t enc, PSetOfPDUTokenAttributes *val);
static int ASN1CALL ASN1Enc_SetOfTokenIDs(ASN1encoding_t enc, PSetOfTokenIDs *val);
static int ASN1CALL ASN1Enc_MergeTokensRequestPDU(ASN1encoding_t enc, MergeTokensRequestPDU *val);
static int ASN1CALL ASN1Enc_MergeTokensConfirmPDU(ASN1encoding_t enc, MergeTokensConfirmPDU *val);
static int ASN1CALL ASN1Enc_PurgeTokenIndicationPDU(ASN1encoding_t enc, PurgeTokenIndicationPDU *val);
static int ASN1CALL ASN1Enc_DisconnectProviderUltimatumPDU(ASN1encoding_t enc, DisconnectProviderUltimatumPDU *val);
static int ASN1CALL ASN1Enc_RejectUltimatumPDU(ASN1encoding_t enc, RejectUltimatumPDU *val);
static int ASN1CALL ASN1Enc_AttachUserConfirmPDU(ASN1encoding_t enc, AttachUserConfirmPDU *val);
static int ASN1CALL ASN1Enc_DetachUserRequestPDU(ASN1encoding_t enc, DetachUserRequestPDU *val);
static int ASN1CALL ASN1Enc_DetachUserIndicationPDU(ASN1encoding_t enc, DetachUserIndicationPDU *val);
static int ASN1CALL ASN1Enc_ChannelJoinRequestPDU(ASN1encoding_t enc, ChannelJoinRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelJoinConfirmPDU(ASN1encoding_t enc, ChannelJoinConfirmPDU *val);
static int ASN1CALL ASN1Enc_ChannelLeaveRequestPDU(ASN1encoding_t enc, ChannelLeaveRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelConveneRequestPDU(ASN1encoding_t enc, ChannelConveneRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelConveneConfirmPDU(ASN1encoding_t enc, ChannelConveneConfirmPDU *val);
static int ASN1CALL ASN1Enc_ChannelDisbandRequestPDU(ASN1encoding_t enc, ChannelDisbandRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelDisbandIndicationPDU(ASN1encoding_t enc, ChannelDisbandIndicationPDU *val);
static int ASN1CALL ASN1Enc_ChannelAdmitRequestPDU(ASN1encoding_t enc, ChannelAdmitRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelAdmitIndicationPDU(ASN1encoding_t enc, ChannelAdmitIndicationPDU *val);
static int ASN1CALL ASN1Enc_ChannelExpelRequestPDU(ASN1encoding_t enc, ChannelExpelRequestPDU *val);
static int ASN1CALL ASN1Enc_ChannelExpelIndicationPDU(ASN1encoding_t enc, ChannelExpelIndicationPDU *val);
static int ASN1CALL ASN1Enc_TokenGrabRequestPDU(ASN1encoding_t enc, TokenGrabRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenGrabConfirmPDU(ASN1encoding_t enc, TokenGrabConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenInhibitRequestPDU(ASN1encoding_t enc, TokenInhibitRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenInhibitConfirmPDU(ASN1encoding_t enc, TokenInhibitConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenGiveRequestPDU(ASN1encoding_t enc, TokenGiveRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenGiveIndicationPDU(ASN1encoding_t enc, TokenGiveIndicationPDU *val);
static int ASN1CALL ASN1Enc_TokenGiveResponsePDU(ASN1encoding_t enc, TokenGiveResponsePDU *val);
static int ASN1CALL ASN1Enc_TokenGiveConfirmPDU(ASN1encoding_t enc, TokenGiveConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenPleaseRequestPDU(ASN1encoding_t enc, TokenPleaseRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenPleaseIndicationPDU(ASN1encoding_t enc, TokenPleaseIndicationPDU *val);
static int ASN1CALL ASN1Enc_TokenReleaseRequestPDU(ASN1encoding_t enc, TokenReleaseRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenReleaseConfirmPDU(ASN1encoding_t enc, TokenReleaseConfirmPDU *val);
static int ASN1CALL ASN1Enc_TokenTestRequestPDU(ASN1encoding_t enc, TokenTestRequestPDU *val);
static int ASN1CALL ASN1Enc_TokenTestConfirmPDU(ASN1encoding_t enc, TokenTestConfirmPDU *val);
extern int ASN1CALL ASN1Enc_ConnectMCSPDU(ASN1encoding_t enc, ConnectMCSPDU *val);
static int ASN1CALL ASN1Enc_DomainMCSPDU(ASN1encoding_t enc, DomainMCSPDU *val);
static int ASN1CALL ASN1Dec_Given(ASN1decoding_t dec, Given *val);
static int ASN1CALL ASN1Dec_Ungivable(ASN1decoding_t dec, Ungivable *val);
static int ASN1CALL ASN1Dec_Giving(ASN1decoding_t dec, Giving *val);
static int ASN1CALL ASN1Dec_Inhibited(ASN1decoding_t dec, Inhibited *val);
static int ASN1CALL ASN1Dec_Grabbed(ASN1decoding_t dec, Grabbed *val);
static int ASN1CALL ASN1Dec_ChannelAttributesAssigned(ASN1decoding_t dec, ChannelAttributesAssigned *val);
static int ASN1CALL ASN1Dec_ChannelAttributesPrivate(ASN1decoding_t dec, ChannelAttributesPrivate *val);
static int ASN1CALL ASN1Dec_ChannelAttributesUserID(ASN1decoding_t dec, ChannelAttributesUserID *val);
static int ASN1CALL ASN1Dec_ChannelAttributesStatic(ASN1decoding_t dec, ChannelAttributesStatic *val);
extern int ASN1CALL ASN1Dec_PDUDomainParameters(ASN1decoding_t dec, PDUDomainParameters *val);
extern int ASN1CALL ASN1Dec_ConnectInitialPDU(ASN1decoding_t dec, ConnectInitialPDU *val);
extern int ASN1CALL ASN1Dec_ConnectResponsePDU(ASN1decoding_t dec, ConnectResponsePDU *val);
extern int ASN1CALL ASN1Dec_ConnectAdditionalPDU(ASN1decoding_t dec, ConnectAdditionalPDU *val);
extern int ASN1CALL ASN1Dec_ConnectResultPDU(ASN1decoding_t dec, ConnectResultPDU *val);
static int ASN1CALL ASN1Dec_PlumbDomainIndicationPDU(ASN1decoding_t dec, PlumbDomainIndicationPDU *val);
static int ASN1CALL ASN1Dec_ErectDomainRequestPDU(ASN1decoding_t dec, ErectDomainRequestPDU *val);
static int ASN1CALL ASN1Dec_PDUChannelAttributes(ASN1decoding_t dec, PDUChannelAttributes *val);
static int ASN1CALL ASN1Dec_MergeChannelsRequestPDU(ASN1decoding_t dec, MergeChannelsRequestPDU *val);
static int ASN1CALL ASN1Dec_MergeChannelsConfirmPDU(ASN1decoding_t dec, MergeChannelsConfirmPDU *val);
static int ASN1CALL ASN1Dec_PurgeChannelIndicationPDU(ASN1decoding_t dec, PurgeChannelIndicationPDU *val);
static int ASN1CALL ASN1Dec_PDUTokenAttributes(ASN1decoding_t dec, PDUTokenAttributes *val);
static int ASN1CALL ASN1Dec_SetOfUserIDs(ASN1decoding_t dec, PSetOfUserIDs *val);
static int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes(ASN1decoding_t dec, PSetOfPDUChannelAttributes *val);
static int ASN1CALL ASN1Dec_SetOfChannelIDs(ASN1decoding_t dec, PSetOfChannelIDs *val);
static int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes(ASN1decoding_t dec, PSetOfPDUTokenAttributes *val);
static int ASN1CALL ASN1Dec_SetOfTokenIDs(ASN1decoding_t dec, PSetOfTokenIDs *val);
static int ASN1CALL ASN1Dec_MergeTokensRequestPDU(ASN1decoding_t dec, MergeTokensRequestPDU *val);
static int ASN1CALL ASN1Dec_MergeTokensConfirmPDU(ASN1decoding_t dec, MergeTokensConfirmPDU *val);
static int ASN1CALL ASN1Dec_PurgeTokenIndicationPDU(ASN1decoding_t dec, PurgeTokenIndicationPDU *val);
static int ASN1CALL ASN1Dec_DisconnectProviderUltimatumPDU(ASN1decoding_t dec, DisconnectProviderUltimatumPDU *val);
static int ASN1CALL ASN1Dec_RejectUltimatumPDU(ASN1decoding_t dec, RejectUltimatumPDU *val);
static int ASN1CALL ASN1Dec_AttachUserConfirmPDU(ASN1decoding_t dec, AttachUserConfirmPDU *val);
static int ASN1CALL ASN1Dec_DetachUserRequestPDU(ASN1decoding_t dec, DetachUserRequestPDU *val);
static int ASN1CALL ASN1Dec_DetachUserIndicationPDU(ASN1decoding_t dec, DetachUserIndicationPDU *val);
static int ASN1CALL ASN1Dec_ChannelJoinRequestPDU(ASN1decoding_t dec, ChannelJoinRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelJoinConfirmPDU(ASN1decoding_t dec, ChannelJoinConfirmPDU *val);
static int ASN1CALL ASN1Dec_ChannelLeaveRequestPDU(ASN1decoding_t dec, ChannelLeaveRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelConveneRequestPDU(ASN1decoding_t dec, ChannelConveneRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelConveneConfirmPDU(ASN1decoding_t dec, ChannelConveneConfirmPDU *val);
static int ASN1CALL ASN1Dec_ChannelDisbandRequestPDU(ASN1decoding_t dec, ChannelDisbandRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelDisbandIndicationPDU(ASN1decoding_t dec, ChannelDisbandIndicationPDU *val);
static int ASN1CALL ASN1Dec_ChannelAdmitRequestPDU(ASN1decoding_t dec, ChannelAdmitRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelAdmitIndicationPDU(ASN1decoding_t dec, ChannelAdmitIndicationPDU *val);
static int ASN1CALL ASN1Dec_ChannelExpelRequestPDU(ASN1decoding_t dec, ChannelExpelRequestPDU *val);
static int ASN1CALL ASN1Dec_ChannelExpelIndicationPDU(ASN1decoding_t dec, ChannelExpelIndicationPDU *val);
static int ASN1CALL ASN1Dec_TokenGrabRequestPDU(ASN1decoding_t dec, TokenGrabRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenGrabConfirmPDU(ASN1decoding_t dec, TokenGrabConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenInhibitRequestPDU(ASN1decoding_t dec, TokenInhibitRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenInhibitConfirmPDU(ASN1decoding_t dec, TokenInhibitConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenGiveRequestPDU(ASN1decoding_t dec, TokenGiveRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenGiveIndicationPDU(ASN1decoding_t dec, TokenGiveIndicationPDU *val);
static int ASN1CALL ASN1Dec_TokenGiveResponsePDU(ASN1decoding_t dec, TokenGiveResponsePDU *val);
static int ASN1CALL ASN1Dec_TokenGiveConfirmPDU(ASN1decoding_t dec, TokenGiveConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenPleaseRequestPDU(ASN1decoding_t dec, TokenPleaseRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenPleaseIndicationPDU(ASN1decoding_t dec, TokenPleaseIndicationPDU *val);
static int ASN1CALL ASN1Dec_TokenReleaseRequestPDU(ASN1decoding_t dec, TokenReleaseRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenReleaseConfirmPDU(ASN1decoding_t dec, TokenReleaseConfirmPDU *val);
static int ASN1CALL ASN1Dec_TokenTestRequestPDU(ASN1decoding_t dec, TokenTestRequestPDU *val);
static int ASN1CALL ASN1Dec_TokenTestConfirmPDU(ASN1decoding_t dec, TokenTestConfirmPDU *val);
extern int ASN1CALL ASN1Dec_ConnectMCSPDU(ASN1decoding_t dec, ConnectMCSPDU *val);
static int ASN1CALL ASN1Dec_DomainMCSPDU(ASN1decoding_t dec, DomainMCSPDU *val);
static void ASN1CALL ASN1Free_Inhibited(Inhibited *val);
static void ASN1CALL ASN1Free_ChannelAttributesPrivate(ChannelAttributesPrivate *val);
static void ASN1CALL ASN1Free_ConnectInitialPDU(ConnectInitialPDU *val);
static void ASN1CALL ASN1Free_ConnectResponsePDU(ConnectResponsePDU *val);
static void ASN1CALL ASN1Free_PDUChannelAttributes(PDUChannelAttributes *val);
static void ASN1CALL ASN1Free_MergeChannelsRequestPDU(MergeChannelsRequestPDU *val);
static void ASN1CALL ASN1Free_MergeChannelsConfirmPDU(MergeChannelsConfirmPDU *val);
static void ASN1CALL ASN1Free_PurgeChannelIndicationPDU(PurgeChannelIndicationPDU *val);
static void ASN1CALL ASN1Free_PDUTokenAttributes(PDUTokenAttributes *val);
static void ASN1CALL ASN1Free_SetOfUserIDs(PSetOfUserIDs *val);
static void ASN1CALL ASN1Free_SetOfPDUChannelAttributes(PSetOfPDUChannelAttributes *val);
static void ASN1CALL ASN1Free_SetOfChannelIDs(PSetOfChannelIDs *val);
static void ASN1CALL ASN1Free_SetOfPDUTokenAttributes(PSetOfPDUTokenAttributes *val);
static void ASN1CALL ASN1Free_SetOfTokenIDs(PSetOfTokenIDs *val);
static void ASN1CALL ASN1Free_MergeTokensRequestPDU(MergeTokensRequestPDU *val);
static void ASN1CALL ASN1Free_MergeTokensConfirmPDU(MergeTokensConfirmPDU *val);
static void ASN1CALL ASN1Free_PurgeTokenIndicationPDU(PurgeTokenIndicationPDU *val);
static void ASN1CALL ASN1Free_RejectUltimatumPDU(RejectUltimatumPDU *val);
static void ASN1CALL ASN1Free_DetachUserRequestPDU(DetachUserRequestPDU *val);
static void ASN1CALL ASN1Free_DetachUserIndicationPDU(DetachUserIndicationPDU *val);
static void ASN1CALL ASN1Free_ChannelLeaveRequestPDU(ChannelLeaveRequestPDU *val);
static void ASN1CALL ASN1Free_ChannelAdmitRequestPDU(ChannelAdmitRequestPDU *val);
static void ASN1CALL ASN1Free_ChannelAdmitIndicationPDU(ChannelAdmitIndicationPDU *val);
static void ASN1CALL ASN1Free_ChannelExpelRequestPDU(ChannelExpelRequestPDU *val);
static void ASN1CALL ASN1Free_ChannelExpelIndicationPDU(ChannelExpelIndicationPDU *val);
static void ASN1CALL ASN1Free_ConnectMCSPDU(ConnectMCSPDU *val);
static void ASN1CALL ASN1Free_DomainMCSPDU(DomainMCSPDU *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_ConnectMCSPDU,
    (ASN1EncFun_t) ASN1Enc_DomainMCSPDU,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_ConnectMCSPDU,
    (ASN1DecFun_t) ASN1Dec_DomainMCSPDU,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_ConnectMCSPDU,
    (ASN1FreeFun_t) ASN1Free_DomainMCSPDU,
};
static const ULONG sizetab[2] = {
    SIZE_MCSPDU_Module_PDU_0,
    SIZE_MCSPDU_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
void ASN1CALL MCSPDU_Module_Startup(void)
{
    MCSPDU_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x73636d);
}
void ASN1CALL MCSPDU_Module_Cleanup(void)
{
    ASN1_CloseModule(MCSPDU_Module);
    MCSPDU_Module = NULL;
}

static int ASN1CALL ASN1Enc_Given(ASN1encoding_t enc, Given *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Given(ASN1decoding_t dec, Given *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_Ungivable(ASN1encoding_t enc, Ungivable *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->grabber - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Ungivable(ASN1decoding_t dec, Ungivable *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->grabber))
	return 0;
    (val)->grabber += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_Giving(ASN1encoding_t enc, Giving *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->grabber - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Giving(ASN1decoding_t dec, Giving *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->grabber))
	return 0;
    (val)->grabber += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_Inhibited(ASN1encoding_t enc, Inhibited *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->inhibitors))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Inhibited(ASN1decoding_t dec, Inhibited *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->inhibitors))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Inhibited(Inhibited *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->inhibitors);
    }
}

static int ASN1CALL ASN1Enc_Grabbed(ASN1encoding_t enc, Grabbed *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->grabber - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Grabbed(ASN1decoding_t dec, Grabbed *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->grabber))
	return 0;
    (val)->grabber += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAttributesAssigned(ASN1encoding_t enc, ChannelAttributesAssigned *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesAssigned(ASN1decoding_t dec, ChannelAttributesAssigned *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAttributesPrivate(ASN1encoding_t enc, ChannelAttributesPrivate *val)
{
    if (!ASN1PEREncBoolean(enc, (val)->joined))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manager - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->admitted))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesPrivate(ASN1decoding_t dec, ChannelAttributesPrivate *val)
{
    if (!ASN1PERDecBoolean(dec, &(val)->joined))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manager))
	return 0;
    (val)->manager += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->admitted))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelAttributesPrivate(ChannelAttributesPrivate *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->admitted);
    }
}

static int ASN1CALL ASN1Enc_ChannelAttributesUserID(ASN1encoding_t enc, ChannelAttributesUserID *val)
{
    if (!ASN1PEREncBoolean(enc, (val)->joined))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->user_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesUserID(ASN1decoding_t dec, ChannelAttributesUserID *val)
{
    if (!ASN1PERDecBoolean(dec, &(val)->joined))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->user_id))
	return 0;
    (val)->user_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAttributesStatic(ASN1encoding_t enc, ChannelAttributesStatic *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAttributesStatic(ASN1decoding_t dec, ChannelAttributesStatic *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectInitialPDU(ConnectInitialPDU *val)
{
    if (val) {
        ASN1octetstring_free(&(val)->calling_domain_selector);
        ASN1octetstring_free(&(val)->called_domain_selector);
        ASN1octetstring_free(&(val)->user_data);
    }
}

static void ASN1CALL ASN1Free_ConnectResponsePDU(ConnectResponsePDU *val)
{
    if (val) {
        ASN1octetstring_free(&(val)->user_data);
    }
}

static int ASN1CALL ASN1Enc_PlumbDomainIndicationPDU(ASN1encoding_t enc, PlumbDomainIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedInteger(enc, (val)->height_limit))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PlumbDomainIndicationPDU(ASN1decoding_t dec, PlumbDomainIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedInteger(dec, &(val)->height_limit))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ErectDomainRequestPDU(ASN1encoding_t enc, ErectDomainRequestPDU *val)
{
#ifndef _WIN64
    if (!ASN1PEREncUnsignedInteger(enc, (val)->sub_height))
#endif
	return 0;
    if (!ASN1PEREncUnsignedInteger(enc, (val)->sub_interval))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ErectDomainRequestPDU(ASN1decoding_t dec, ErectDomainRequestPDU *val)
{
#ifndef _WIN64
    if (!ASN1PERDecUnsignedInteger(dec, &(val)->sub_height))
#endif
	return 0;
    if (!ASN1PERDecUnsignedInteger(dec, &(val)->sub_interval))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_PDUChannelAttributes(ASN1encoding_t enc, PDUChannelAttributes *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ChannelAttributesStatic(enc, &(val)->u.channel_attributes_static))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ChannelAttributesUserID(enc, &(val)->u.channel_attributes_user_id))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ChannelAttributesPrivate(enc, &(val)->u.channel_attributes_private))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ChannelAttributesAssigned(enc, &(val)->u.channel_attributes_assigned))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PDUChannelAttributes(ASN1decoding_t dec, PDUChannelAttributes *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ChannelAttributesStatic(dec, &(val)->u.channel_attributes_static))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ChannelAttributesUserID(dec, &(val)->u.channel_attributes_user_id))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ChannelAttributesPrivate(dec, &(val)->u.channel_attributes_private))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ChannelAttributesAssigned(dec, &(val)->u.channel_attributes_assigned))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PDUChannelAttributes(PDUChannelAttributes *val)
{
    if (val) {
        switch ((val)->choice) {
        case 3:
            ASN1Free_ChannelAttributesPrivate(&(val)->u.channel_attributes_private);
            break;
        }
    }
}

static int ASN1CALL ASN1Enc_MergeChannelsRequestPDU(ASN1encoding_t enc, MergeChannelsRequestPDU *val)
{
    if (!ASN1Enc_SetOfPDUChannelAttributes(enc, &(val)->merge_channels))
	return 0;
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeChannelsRequestPDU(ASN1decoding_t dec, MergeChannelsRequestPDU *val)
{
    if (!ASN1Dec_SetOfPDUChannelAttributes(dec, &(val)->merge_channels))
	return 0;
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeChannelsRequestPDU(MergeChannelsRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUChannelAttributes(&(val)->merge_channels);
        ASN1Free_SetOfChannelIDs(&(val)->purge_channel_ids);
    }
}

static int ASN1CALL ASN1Enc_MergeChannelsConfirmPDU(ASN1encoding_t enc, MergeChannelsConfirmPDU *val)
{
    if (!ASN1Enc_SetOfPDUChannelAttributes(enc, &(val)->merge_channels))
	return 0;
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeChannelsConfirmPDU(ASN1decoding_t dec, MergeChannelsConfirmPDU *val)
{
    if (!ASN1Dec_SetOfPDUChannelAttributes(dec, &(val)->merge_channels))
	return 0;
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeChannelsConfirmPDU(MergeChannelsConfirmPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUChannelAttributes(&(val)->merge_channels);
        ASN1Free_SetOfChannelIDs(&(val)->purge_channel_ids);
    }
}

static int ASN1CALL ASN1Enc_PurgeChannelIndicationPDU(ASN1encoding_t enc, PurgeChannelIndicationPDU *val)
{
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->detach_user_ids))
	return 0;
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PurgeChannelIndicationPDU(ASN1decoding_t dec, PurgeChannelIndicationPDU *val)
{
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->detach_user_ids))
	return 0;
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->purge_channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PurgeChannelIndicationPDU(PurgeChannelIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->detach_user_ids);
        ASN1Free_SetOfChannelIDs(&(val)->purge_channel_ids);
    }
}

static int ASN1CALL ASN1Enc_PDUTokenAttributes(ASN1encoding_t enc, PDUTokenAttributes *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Grabbed(enc, &(val)->u.grabbed))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_Inhibited(enc, &(val)->u.inhibited))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_Giving(enc, &(val)->u.giving))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_Ungivable(enc, &(val)->u.ungivable))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_Given(enc, &(val)->u.given))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PDUTokenAttributes(ASN1decoding_t dec, PDUTokenAttributes *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Grabbed(dec, &(val)->u.grabbed))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_Inhibited(dec, &(val)->u.inhibited))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_Giving(dec, &(val)->u.giving))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_Ungivable(dec, &(val)->u.ungivable))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_Given(dec, &(val)->u.given))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PDUTokenAttributes(PDUTokenAttributes *val)
{
    if (val) {
        switch ((val)->choice) {
        case 2:
            ASN1Free_Inhibited(&(val)->u.inhibited);
            break;
        }
    }
}

static int ASN1CALL ASN1Enc_SetOfUserIDs(ASN1encoding_t enc, PSetOfUserIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfUserIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfUserIDs_ElmFn(ASN1encoding_t enc, PSetOfUserIDs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfUserIDs(ASN1decoding_t dec, PSetOfUserIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfUserIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfUserIDs_ElmFn(ASN1decoding_t dec, PSetOfUserIDs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfUserIDs(PSetOfUserIDs *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfUserIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfUserIDs_ElmFn(PSetOfUserIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes(ASN1encoding_t enc, PSetOfPDUChannelAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfPDUChannelAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUChannelAttributes val)
{
    if (!ASN1Enc_PDUChannelAttributes(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes(ASN1decoding_t dec, PSetOfPDUChannelAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfPDUChannelAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUChannelAttributes val)
{
    if (!ASN1Dec_PDUChannelAttributes(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfPDUChannelAttributes(PSetOfPDUChannelAttributes *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfPDUChannelAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfPDUChannelAttributes_ElmFn(PSetOfPDUChannelAttributes val)
{
    if (val) {
        ASN1Free_PDUChannelAttributes(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfChannelIDs(ASN1encoding_t enc, PSetOfChannelIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfChannelIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfChannelIDs_ElmFn(ASN1encoding_t enc, PSetOfChannelIDs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfChannelIDs(ASN1decoding_t dec, PSetOfChannelIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfChannelIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfChannelIDs_ElmFn(ASN1decoding_t dec, PSetOfChannelIDs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfChannelIDs(PSetOfChannelIDs *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfChannelIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfChannelIDs_ElmFn(PSetOfChannelIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes(ASN1encoding_t enc, PSetOfPDUTokenAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfPDUTokenAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUTokenAttributes val)
{
    if (!ASN1Enc_PDUTokenAttributes(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes(ASN1decoding_t dec, PSetOfPDUTokenAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfPDUTokenAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUTokenAttributes val)
{
    if (!ASN1Dec_PDUTokenAttributes(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfPDUTokenAttributes(PSetOfPDUTokenAttributes *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfPDUTokenAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfPDUTokenAttributes_ElmFn(PSetOfPDUTokenAttributes val)
{
    if (val) {
        ASN1Free_PDUTokenAttributes(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfTokenIDs(ASN1encoding_t enc, PSetOfTokenIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfTokenIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfTokenIDs_ElmFn(ASN1encoding_t enc, PSetOfTokenIDs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfTokenIDs(ASN1decoding_t dec, PSetOfTokenIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfTokenIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfTokenIDs_ElmFn(ASN1decoding_t dec, PSetOfTokenIDs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfTokenIDs(PSetOfTokenIDs *val)
{
    if (val) {
        ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfTokenIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfTokenIDs_ElmFn(PSetOfTokenIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MergeTokensRequestPDU(ASN1encoding_t enc, MergeTokensRequestPDU *val)
{
    if (!ASN1Enc_SetOfPDUTokenAttributes(enc, &(val)->merge_tokens))
	return 0;
    if (!ASN1Enc_SetOfTokenIDs(enc, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeTokensRequestPDU(ASN1decoding_t dec, MergeTokensRequestPDU *val)
{
    if (!ASN1Dec_SetOfPDUTokenAttributes(dec, &(val)->merge_tokens))
	return 0;
    if (!ASN1Dec_SetOfTokenIDs(dec, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeTokensRequestPDU(MergeTokensRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUTokenAttributes(&(val)->merge_tokens);
        ASN1Free_SetOfTokenIDs(&(val)->purge_token_ids);
    }
}

static int ASN1CALL ASN1Enc_MergeTokensConfirmPDU(ASN1encoding_t enc, MergeTokensConfirmPDU *val)
{
    if (!ASN1Enc_SetOfPDUTokenAttributes(enc, &(val)->merge_tokens))
	return 0;
    if (!ASN1Enc_SetOfTokenIDs(enc, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MergeTokensConfirmPDU(ASN1decoding_t dec, MergeTokensConfirmPDU *val)
{
    if (!ASN1Dec_SetOfPDUTokenAttributes(dec, &(val)->merge_tokens))
	return 0;
    if (!ASN1Dec_SetOfTokenIDs(dec, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MergeTokensConfirmPDU(MergeTokensConfirmPDU *val)
{
    if (val) {
        ASN1Free_SetOfPDUTokenAttributes(&(val)->merge_tokens);
        ASN1Free_SetOfTokenIDs(&(val)->purge_token_ids);
    }
}

static int ASN1CALL ASN1Enc_PurgeTokenIndicationPDU(ASN1encoding_t enc, PurgeTokenIndicationPDU *val)
{
    if (!ASN1Enc_SetOfTokenIDs(enc, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PurgeTokenIndicationPDU(ASN1decoding_t dec, PurgeTokenIndicationPDU *val)
{
    if (!ASN1Dec_SetOfTokenIDs(dec, &(val)->purge_token_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PurgeTokenIndicationPDU(PurgeTokenIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfTokenIDs(&(val)->purge_token_ids);
    }
}

static int ASN1CALL ASN1Enc_DisconnectProviderUltimatumPDU(ASN1encoding_t enc, DisconnectProviderUltimatumPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 3, (val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectProviderUltimatumPDU(ASN1decoding_t dec, DisconnectProviderUltimatumPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RejectUltimatumPDU(ASN1encoding_t enc, RejectUltimatumPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->diagnostic))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->initial_octets))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RejectUltimatumPDU(ASN1decoding_t dec, RejectUltimatumPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->diagnostic))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->initial_octets))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RejectUltimatumPDU(RejectUltimatumPDU *val)
{
    if (val) {
        ASN1octetstring_free(&(val)->initial_octets);
    }
}

static int ASN1CALL ASN1Enc_AttachUserConfirmPDU(ASN1encoding_t enc, AttachUserConfirmPDU *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AttachUserConfirmPDU(ASN1decoding_t dec, AttachUserConfirmPDU *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	    return 0;
	(val)->initiator += 1001;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_DetachUserRequestPDU(ASN1encoding_t enc, DetachUserRequestPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 3, (val)->reason))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DetachUserRequestPDU(ASN1decoding_t dec, DetachUserRequestPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->reason))
	return 0;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DetachUserRequestPDU(DetachUserRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_DetachUserIndicationPDU(ASN1encoding_t enc, DetachUserIndicationPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 3, (val)->reason))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DetachUserIndicationPDU(ASN1decoding_t dec, DetachUserIndicationPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->reason))
	return 0;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DetachUserIndicationPDU(DetachUserIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelJoinRequestPDU(ASN1encoding_t enc, ChannelJoinRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelJoinRequestPDU(ASN1decoding_t dec, ChannelJoinRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelJoinConfirmPDU(ASN1encoding_t enc, ChannelJoinConfirmPDU *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requested))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->join_channel_id))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelJoinConfirmPDU(ASN1decoding_t dec, ChannelJoinConfirmPDU *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requested))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->join_channel_id))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelLeaveRequestPDU(ASN1encoding_t enc, ChannelLeaveRequestPDU *val)
{
    if (!ASN1Enc_SetOfChannelIDs(enc, &(val)->channel_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelLeaveRequestPDU(ASN1decoding_t dec, ChannelLeaveRequestPDU *val)
{
    if (!ASN1Dec_SetOfChannelIDs(dec, &(val)->channel_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelLeaveRequestPDU(ChannelLeaveRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfChannelIDs(&(val)->channel_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelConveneRequestPDU(ASN1encoding_t enc, ChannelConveneRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelConveneRequestPDU(ASN1decoding_t dec, ChannelConveneRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelConveneConfirmPDU(ASN1encoding_t enc, ChannelConveneConfirmPDU *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->convene_channel_id - 1001))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelConveneConfirmPDU(ASN1decoding_t dec, ChannelConveneConfirmPDU *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->convene_channel_id))
	    return 0;
	(val)->convene_channel_id += 1001;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelDisbandRequestPDU(ASN1encoding_t enc, ChannelDisbandRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelDisbandRequestPDU(ASN1decoding_t dec, ChannelDisbandRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelDisbandIndicationPDU(ASN1encoding_t enc, ChannelDisbandIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelDisbandIndicationPDU(ASN1decoding_t dec, ChannelDisbandIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_ChannelAdmitRequestPDU(ASN1encoding_t enc, ChannelAdmitRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAdmitRequestPDU(ASN1decoding_t dec, ChannelAdmitRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelAdmitRequestPDU(ChannelAdmitRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelAdmitIndicationPDU(ASN1encoding_t enc, ChannelAdmitIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelAdmitIndicationPDU(ASN1decoding_t dec, ChannelAdmitIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelAdmitIndicationPDU(ChannelAdmitIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelExpelRequestPDU(ASN1encoding_t enc, ChannelExpelRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelExpelRequestPDU(ASN1decoding_t dec, ChannelExpelRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelExpelRequestPDU(ChannelExpelRequestPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_ChannelExpelIndicationPDU(ASN1encoding_t enc, ChannelExpelIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    if (!ASN1Enc_SetOfUserIDs(enc, &(val)->user_ids))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChannelExpelIndicationPDU(ASN1decoding_t dec, ChannelExpelIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (!ASN1Dec_SetOfUserIDs(dec, &(val)->user_ids))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ChannelExpelIndicationPDU(ChannelExpelIndicationPDU *val)
{
    if (val) {
        ASN1Free_SetOfUserIDs(&(val)->user_ids);
    }
}

static int ASN1CALL ASN1Enc_TokenGrabRequestPDU(ASN1encoding_t enc, TokenGrabRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGrabRequestPDU(ASN1decoding_t dec, TokenGrabRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGrabConfirmPDU(ASN1encoding_t enc, TokenGrabConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGrabConfirmPDU(ASN1decoding_t dec, TokenGrabConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenInhibitRequestPDU(ASN1encoding_t enc, TokenInhibitRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenInhibitRequestPDU(ASN1decoding_t dec, TokenInhibitRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenInhibitConfirmPDU(ASN1encoding_t enc, TokenInhibitConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenInhibitConfirmPDU(ASN1decoding_t dec, TokenInhibitConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveRequestPDU(ASN1encoding_t enc, TokenGiveRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveRequestPDU(ASN1decoding_t dec, TokenGiveRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveIndicationPDU(ASN1encoding_t enc, TokenGiveIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveIndicationPDU(ASN1decoding_t dec, TokenGiveIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveResponsePDU(ASN1encoding_t enc, TokenGiveResponsePDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->recipient - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveResponsePDU(ASN1decoding_t dec, TokenGiveResponsePDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->recipient))
	return 0;
    (val)->recipient += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenGiveConfirmPDU(ASN1encoding_t enc, TokenGiveConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenGiveConfirmPDU(ASN1decoding_t dec, TokenGiveConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenPleaseRequestPDU(ASN1encoding_t enc, TokenPleaseRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenPleaseRequestPDU(ASN1decoding_t dec, TokenPleaseRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenPleaseIndicationPDU(ASN1encoding_t enc, TokenPleaseIndicationPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenPleaseIndicationPDU(ASN1decoding_t dec, TokenPleaseIndicationPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenReleaseRequestPDU(ASN1encoding_t enc, TokenReleaseRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenReleaseRequestPDU(ASN1decoding_t dec, TokenReleaseRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenReleaseConfirmPDU(ASN1encoding_t enc, TokenReleaseConfirmPDU *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->result))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenReleaseConfirmPDU(ASN1decoding_t dec, TokenReleaseConfirmPDU *val)
{
    if (!ASN1PERDecU32Val(dec, 4, (ASN1uint32_t *) &(val)->result))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenTestRequestPDU(ASN1encoding_t enc, TokenTestRequestPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenTestRequestPDU(ASN1decoding_t dec, TokenTestRequestPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TokenTestConfirmPDU(ASN1encoding_t enc, TokenTestConfirmPDU *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->initiator - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->token_id - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->token_status))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TokenTestConfirmPDU(ASN1decoding_t dec, TokenTestConfirmPDU *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initiator))
	return 0;
    (val)->initiator += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->token_id))
	return 0;
    (val)->token_id += 1;
    if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->token_status))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectMCSPDU(ConnectMCSPDU *val)
{
    if (val) {
        switch ((val)->choice) {
        case 1:
        ASN1Free_ConnectInitialPDU(&(val)->u.connect_initial);
        break;
        case 2:
        ASN1Free_ConnectResponsePDU(&(val)->u.connect_response);
        break;
        }
    }
}

static int ASN1CALL ASN1Enc_DomainMCSPDU(ASN1encoding_t enc, DomainMCSPDU *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PlumbDomainIndicationPDU(enc, &(val)->u.plumb_domain_indication))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ErectDomainRequestPDU(enc, &(val)->u.erect_domain_request))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MergeChannelsRequestPDU(enc, &(val)->u.merge_channels_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_MergeChannelsConfirmPDU(enc, &(val)->u.merge_channels_confirm))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_PurgeChannelIndicationPDU(enc, &(val)->u.purge_channel_indication))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_MergeTokensRequestPDU(enc, &(val)->u.merge_tokens_request))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MergeTokensConfirmPDU(enc, &(val)->u.merge_tokens_confirm))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_PurgeTokenIndicationPDU(enc, &(val)->u.purge_token_indication))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_DisconnectProviderUltimatumPDU(enc, &(val)->u.disconnect_provider_ultimatum))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RejectUltimatumPDU(enc, &(val)->u.reject_user_ultimatum))
	    return 0;
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Enc_AttachUserConfirmPDU(enc, &(val)->u.attach_user_confirm))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_DetachUserRequestPDU(enc, &(val)->u.detach_user_request))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_DetachUserIndicationPDU(enc, &(val)->u.detach_user_indication))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_ChannelJoinRequestPDU(enc, &(val)->u.channel_join_request))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_ChannelJoinConfirmPDU(enc, &(val)->u.channel_join_confirm))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_ChannelLeaveRequestPDU(enc, &(val)->u.channel_leave_request))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_ChannelConveneRequestPDU(enc, &(val)->u.channel_convene_request))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_ChannelConveneConfirmPDU(enc, &(val)->u.channel_convene_confirm))
	    return 0;
	break;
    case 20:
	if (!ASN1Enc_ChannelDisbandRequestPDU(enc, &(val)->u.channel_disband_request))
	    return 0;
	break;
    case 21:
	if (!ASN1Enc_ChannelDisbandIndicationPDU(enc, &(val)->u.channel_disband_indication))
	    return 0;
	break;
    case 22:
	if (!ASN1Enc_ChannelAdmitRequestPDU(enc, &(val)->u.channel_admit_request))
	    return 0;
	break;
    case 23:
	if (!ASN1Enc_ChannelAdmitIndicationPDU(enc, &(val)->u.channel_admit_indication))
	    return 0;
	break;
    case 24:
	if (!ASN1Enc_ChannelExpelRequestPDU(enc, &(val)->u.channel_expel_request))
	    return 0;
	break;
    case 25:
	if (!ASN1Enc_ChannelExpelIndicationPDU(enc, &(val)->u.channel_expel_indication))
	    return 0;
	break;
    case 26:
    case 27:
    case 28:
    case 29:
        return 0;
    case 30:
	if (!ASN1Enc_TokenGrabRequestPDU(enc, &(val)->u.token_grab_request))
	    return 0;
	break;
    case 31:
	if (!ASN1Enc_TokenGrabConfirmPDU(enc, &(val)->u.token_grab_confirm))
	    return 0;
	break;
    case 32:
	if (!ASN1Enc_TokenInhibitRequestPDU(enc, &(val)->u.token_inhibit_request))
	    return 0;
	break;
    case 33:
	if (!ASN1Enc_TokenInhibitConfirmPDU(enc, &(val)->u.token_inhibit_confirm))
	    return 0;
	break;
    case 34:
	if (!ASN1Enc_TokenGiveRequestPDU(enc, &(val)->u.token_give_request))
	    return 0;
	break;
    case 35:
	if (!ASN1Enc_TokenGiveIndicationPDU(enc, &(val)->u.token_give_indication))
	    return 0;
	break;
    case 36:
	if (!ASN1Enc_TokenGiveResponsePDU(enc, &(val)->u.token_give_response))
	    return 0;
	break;
    case 37:
	if (!ASN1Enc_TokenGiveConfirmPDU(enc, &(val)->u.token_give_confirm))
	    return 0;
	break;
    case 38:
	if (!ASN1Enc_TokenPleaseRequestPDU(enc, &(val)->u.token_please_request))
	    return 0;
	break;
    case 39:
	if (!ASN1Enc_TokenPleaseIndicationPDU(enc, &(val)->u.token_please_indication))
	    return 0;
	break;
    case 40:
	if (!ASN1Enc_TokenReleaseRequestPDU(enc, &(val)->u.token_release_request))
	    return 0;
	break;
    case 41:
	if (!ASN1Enc_TokenReleaseConfirmPDU(enc, &(val)->u.token_release_confirm))
	    return 0;
	break;
    case 42:
	if (!ASN1Enc_TokenTestRequestPDU(enc, &(val)->u.token_test_request))
	    return 0;
	break;
    case 43:
	if (!ASN1Enc_TokenTestConfirmPDU(enc, &(val)->u.token_test_confirm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DomainMCSPDU(ASN1decoding_t dec, DomainMCSPDU *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PlumbDomainIndicationPDU(dec, &(val)->u.plumb_domain_indication))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ErectDomainRequestPDU(dec, &(val)->u.erect_domain_request))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MergeChannelsRequestPDU(dec, &(val)->u.merge_channels_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_MergeChannelsConfirmPDU(dec, &(val)->u.merge_channels_confirm))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_PurgeChannelIndicationPDU(dec, &(val)->u.purge_channel_indication))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_MergeTokensRequestPDU(dec, &(val)->u.merge_tokens_request))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MergeTokensConfirmPDU(dec, &(val)->u.merge_tokens_confirm))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_PurgeTokenIndicationPDU(dec, &(val)->u.purge_token_indication))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_DisconnectProviderUltimatumPDU(dec, &(val)->u.disconnect_provider_ultimatum))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RejectUltimatumPDU(dec, &(val)->u.reject_user_ultimatum))
	    return 0;
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Dec_AttachUserConfirmPDU(dec, &(val)->u.attach_user_confirm))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_DetachUserRequestPDU(dec, &(val)->u.detach_user_request))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_DetachUserIndicationPDU(dec, &(val)->u.detach_user_indication))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_ChannelJoinRequestPDU(dec, &(val)->u.channel_join_request))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_ChannelJoinConfirmPDU(dec, &(val)->u.channel_join_confirm))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_ChannelLeaveRequestPDU(dec, &(val)->u.channel_leave_request))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_ChannelConveneRequestPDU(dec, &(val)->u.channel_convene_request))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_ChannelConveneConfirmPDU(dec, &(val)->u.channel_convene_confirm))
	    return 0;
	break;
    case 20:
	if (!ASN1Dec_ChannelDisbandRequestPDU(dec, &(val)->u.channel_disband_request))
	    return 0;
	break;
    case 21:
	if (!ASN1Dec_ChannelDisbandIndicationPDU(dec, &(val)->u.channel_disband_indication))
	    return 0;
	break;
    case 22:
	if (!ASN1Dec_ChannelAdmitRequestPDU(dec, &(val)->u.channel_admit_request))
	    return 0;
	break;
    case 23:
	if (!ASN1Dec_ChannelAdmitIndicationPDU(dec, &(val)->u.channel_admit_indication))
	    return 0;
	break;
    case 24:
	if (!ASN1Dec_ChannelExpelRequestPDU(dec, &(val)->u.channel_expel_request))
	    return 0;
	break;
    case 25:
	if (!ASN1Dec_ChannelExpelIndicationPDU(dec, &(val)->u.channel_expel_indication))
	    return 0;
	break;
    case 26:
    case 27:
    case 28:
    case 29:
        return 0;
    case 30:
	if (!ASN1Dec_TokenGrabRequestPDU(dec, &(val)->u.token_grab_request))
	    return 0;
	break;
    case 31:
	if (!ASN1Dec_TokenGrabConfirmPDU(dec, &(val)->u.token_grab_confirm))
	    return 0;
	break;
    case 32:
	if (!ASN1Dec_TokenInhibitRequestPDU(dec, &(val)->u.token_inhibit_request))
	    return 0;
	break;
    case 33:
	if (!ASN1Dec_TokenInhibitConfirmPDU(dec, &(val)->u.token_inhibit_confirm))
	    return 0;
	break;
    case 34:
	if (!ASN1Dec_TokenGiveRequestPDU(dec, &(val)->u.token_give_request))
	    return 0;
	break;
    case 35:
	if (!ASN1Dec_TokenGiveIndicationPDU(dec, &(val)->u.token_give_indication))
	    return 0;
	break;
    case 36:
	if (!ASN1Dec_TokenGiveResponsePDU(dec, &(val)->u.token_give_response))
	    return 0;
	break;
    case 37:
	if (!ASN1Dec_TokenGiveConfirmPDU(dec, &(val)->u.token_give_confirm))
	    return 0;
	break;
    case 38:
	if (!ASN1Dec_TokenPleaseRequestPDU(dec, &(val)->u.token_please_request))
	    return 0;
	break;
    case 39:
	if (!ASN1Dec_TokenPleaseIndicationPDU(dec, &(val)->u.token_please_indication))
	    return 0;
	break;
    case 40:
	if (!ASN1Dec_TokenReleaseRequestPDU(dec, &(val)->u.token_release_request))
	    return 0;
	break;
    case 41:
	if (!ASN1Dec_TokenReleaseConfirmPDU(dec, &(val)->u.token_release_confirm))
	    return 0;
	break;
    case 42:
	if (!ASN1Dec_TokenTestRequestPDU(dec, &(val)->u.token_test_request))
	    return 0;
	break;
    case 43:
	if (!ASN1Dec_TokenTestConfirmPDU(dec, &(val)->u.token_test_confirm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DomainMCSPDU(DomainMCSPDU *val)
{
    if (val) {
        switch ((val)->choice) {
        case 3:
        ASN1Free_MergeChannelsRequestPDU(&(val)->u.merge_channels_request);
        break;
        case 4:
        ASN1Free_MergeChannelsConfirmPDU(&(val)->u.merge_channels_confirm);
        break;
        case 5:
        ASN1Free_PurgeChannelIndicationPDU(&(val)->u.purge_channel_indication);
        break;
        case 6:
        ASN1Free_MergeTokensRequestPDU(&(val)->u.merge_tokens_request);
        break;
        case 7:
        ASN1Free_MergeTokensConfirmPDU(&(val)->u.merge_tokens_confirm);
        break;
        case 8:
        ASN1Free_PurgeTokenIndicationPDU(&(val)->u.purge_token_indication);
        break;
        case 10:
        ASN1Free_RejectUltimatumPDU(&(val)->u.reject_user_ultimatum);
        break;
        case 13:
        ASN1Free_DetachUserRequestPDU(&(val)->u.detach_user_request);
        break;
        case 14:
        ASN1Free_DetachUserIndicationPDU(&(val)->u.detach_user_indication);
        break;
        case 17:
        ASN1Free_ChannelLeaveRequestPDU(&(val)->u.channel_leave_request);
        break;
        case 22:
        ASN1Free_ChannelAdmitRequestPDU(&(val)->u.channel_admit_request);
        break;
        case 23:
        ASN1Free_ChannelAdmitIndicationPDU(&(val)->u.channel_admit_indication);
        break;
        case 24:
        ASN1Free_ChannelExpelRequestPDU(&(val)->u.channel_expel_request);
        break;
        case 25:
        ASN1Free_ChannelExpelIndicationPDU(&(val)->u.channel_expel_indication);
        break;
        case 26:
        case 27:
        case 28:
        case 29:
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\mcsuser.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	mcsuser.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implemntation file for the MCSUser class. It implements
 *		functions responsible for encoding out bound indirect conference
 *		join request and response PDUs, and also Send user ID Requests. All
 *		these PDUs are encapsulated in user data field of MCSSendDataRequest.
 *		Also this file implements functions that are responsible for decoding
 *		incoming indications and confirm PDUs which are encapsulated in the
 *		user data field of MCSSendDataIndication. Functions responsible for
 *		joining different channels are also implemented in this module.
 *
 *		SEE THE INTERFACE FILE FOR A MORE DETAILED DESCRIPTION OF THIS CLASS.
 *
 *	Private Instance Variables
 *		m_pMCSSap
 *			This is the MCS User handle handed back from the MCS Attache User
 *			Request.
 *		m_nidMyself
 *			The is the MCS User ID returned in the Attach User Confirm.  This
 *			is also refered to as the Node ID with in GCC.
 *		m_nidTopProvider
 *			This holds the MCS User ID (or Node ID) for the top Provider.
 *		m_nidParent
 *			This holds the MCS User ID (or Node ID) for this nodes parent node.
 *		m_fEjectionPending
 *			This flag indicates if an ejection of this node is pending.
 *		m_eEjectReason
 *			This variable holds the reason for ejection until the eject
 *			indication can be delivered after all child nodes have disconnected.
 *		m_pOwnerConf
 *			Pointer to the object that will receive all the owner callbacks
 *			from the user object (typically the conference object).
 *		m_ChannelJoinedFlags
 *			A structure of flags used to keep up with creation state machine.
 *			Basically, it keeps up with which channels have been joined and
 *			which ones have not.
 *		m_ChildUidConnHdlList2
 *			Keeps mapping of child Node IDs to child logical connection
 *			handles.
 *		m_OutgoingPDUQueue
 *			This is a rogue wave list used to queue up all outgoing PDUs.
 *		m_ConfJoinResponseList2
 *			This rogue wave list holds information needed to send back in a join
 *			response after the local node controller responds.
 *		m_EjectedNodeAlarmList2
 *			This list holds alarm objects for all the nodes that have been
 *			ejected and are directly connected to this node.  The alarm is
 *			used to disconnect any misbehaving nodes that do not disconnect
 *			after the EJECTED_NODE_TIMER_DURATION.
 *		m_EjectedNodeList
 *			This list keeps up with nodes that have been ejected but are NOT
 *			directly connected to this node.  We save these nodes so that
 *			a correct reason for disconnecting (user ejected) can be issued
 *			when the detch user indication comes in.
 * 		
 *	Author:
 *		blp
 */

#include "mcsuser.h"
#include "mcsdllif.h"
#include "ogcccode.h"
#include "conf.h"
#include "translat.h"
#include "gcontrol.h"

//	Static Channel and Token ID definitions used by the MCS user object.
#define		BROADCAST_CHANNEL_ID	1
#define		CONVENER_CHANNEL_ID 	2
#define		CONDUCTOR_TOKEN_ID		1

//	Time given to allow an ejected node to disconnect before it is disconnected
#define	EJECTED_NODE_TIMER_DURATION		10000	//	Duration in milliseconds


extern MCSDLLInterface     *g_pMCSIntf;

/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CGCCCoder	*g_GCCCoder;

/*
 *	MCSUser ()
 *
 *	Public Function Description
 *		This is the MCSUser object constructor.  It is responsible for
 *		initializing all the instance variables used by this class.  The
 *		constructor is responsible for establishing the user attachment to
 *		the MCS domain defined by the conference ID.  It also kicks off the
 *		process of joining all the appropriate channels.
 */
MCSUser::
MCSUser(CConf                   *pConf,
		GCCNodeID				nidTopProvider,
		GCCNodeID				nidParent,
		PGCCError				return_value)
:
    CRefCount(MAKE_STAMP_ID('M','U','s','r')),
	m_ChildUidConnHdlList2(),
	m_EjectedNodeAlarmList2(),
	m_EjectedNodeList(),
	m_pConf(pConf),
	m_nidTopProvider(nidTopProvider),
	m_nidParent(nidParent),
	m_nidMyself(NULL),
	m_fEjectionPending(FALSE)
{
    MCSError        mcs_rc;
    GCCConfID       nConfID = pConf->GetConfID();

	//	No channels are joined initially
	m_ChannelJoinedFlags.user_channel_joined = FALSE;
	m_ChannelJoinedFlags.broadcast_channel_joined = FALSE;
	m_ChannelJoinedFlags.convener_channel_joined = FALSE;
	m_ChannelJoinedFlags.channel_join_error = FALSE;

	mcs_rc = g_pMCSIntf->AttachUserRequest(&nConfID, &m_pMCSSap, this);
    if (MCS_NO_ERROR != mcs_rc)
	{
		WARNING_OUT(("MCSUser::MCSUser: Failure in attach user req, "));
		*return_value = GCC_FAILURE_ATTACHING_TO_MCS;
	}
	else
    {
		*return_value = GCC_NO_ERROR;
    }
 }

/*
 *	~MCSUser ()
 *
 *	Public Function Description
 *		This is the user destructor. It takes care of leaving channels
 *		joined by the user object. Also it detaches the user attachment
 *	 	with MCS by issuing a detach user request.
 */
MCSUser::~MCSUser(void)
{
	//	Clean up the Ejected Node Alarm List
	PAlarm				lpAlarm;
	while (NULL != (lpAlarm = m_EjectedNodeAlarmList2.Get()))
    {
		delete lpAlarm;
    }

	if(m_ChannelJoinedFlags.user_channel_joined)
    {
		g_pMCSIntf->ChannelLeaveRequest(m_nidMyself, m_pMCSSap);
    }

	if(m_ChannelJoinedFlags.broadcast_channel_joined)
    {
		g_pMCSIntf->ChannelLeaveRequest(BROADCAST_CHANNEL_ID, m_pMCSSap);
    }

	if(m_ChannelJoinedFlags.convener_channel_joined)
    {
		g_pMCSIntf->ChannelLeaveRequest(CONVENER_CHANNEL_ID, m_pMCSSap);
    }

    //	Empty the queue of all PDUs
	SEND_DATA_REQ_INFO *pReqInfo;
	m_OutgoingPDUQueue.Reset();
	while (NULL != (pReqInfo = m_OutgoingPDUQueue.Iterate()))
	{
		pReqInfo->packet->Unlock();
		delete pReqInfo;
	}

	g_pMCSIntf->DetachUserRequest(m_pMCSSap, this);
}

/*
 *	UINT	ProcessAttachUserConfirm ()
 *
 *	Private Function Description
 *		This function is called when the user object gets an attach user
 *		confirm from MCS in response to an attach user request made by the
 *		user object in it's constructor. The function checks the result
 *		indicated in the confirm. If the result is a successful attachment, then
 *		different channels depending upon the type of the provider, are joined.
 *		Also this function reports failures in attach user (as indicated by
 *		result in attach user confirm) and channel joins, to the conference
 *		through an owner callback.
 *
 *	Formal Parameters:
 *		result		-	(i)	Result of the attach user request.
 *		user_id		-	(i)	This nodes user or Node ID if successful result.
 *
 *	Return Value
 *		MCS_NO_ERROR	-	No error is always returned.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT MCSUser::ProcessAttachUserConfirm(Result result, UserID user_id)
{
	UINT					rc;

	if (result == RESULT_SUCCESSFUL)
	{
		m_nidMyself = user_id;

		/*
		**	After the attach confirm is received we go ahead and join the
		**	appropriate channel based on the conf node type. If this
		**	node is the yop provider we also set up the top provider user id,
		**	otherwise this gets set up in the constructor.
		*/
		switch (m_pConf->GetConfNodeType())
		{
		case TOP_PROVIDER_NODE:
            m_nidTopProvider = m_nidMyself;
			rc = JoinUserAndBroadCastChannels();
			break;

        case JOINED_CONVENER_NODE:
		case CONVENER_NODE:
			rc = JoinUserAndBroadCastChannels();
			if(rc == MCS_NO_ERROR)
            {
				rc = JoinConvenerChannel();
            }
			break;

        case TOP_PROVIDER_AND_CONVENER_NODE:
			m_nidTopProvider = m_nidMyself;
			rc = JoinUserAndBroadCastChannels();
			if(rc == MCS_NO_ERROR)
            {
				rc = JoinConvenerChannel();	
            }
			break;

        case JOINED_NODE:
		case INVITED_NODE:
			rc = JoinUserAndBroadCastChannels();
			break;

        default:
			ERROR_OUT(("User::ProcessAttachUserConfirm: Bad Node Type, %u", (UINT) m_pConf->GetConfNodeType()));
			break;
		}
		
		if (rc != MCS_NO_ERROR)
		{
			/*
			 * ChannelJoinRequestFailed at some level in MCS
			 * So this message tells the conferenceabout this
			 * failure. Conference will delete the user object
			 * as a result of this
			 */
			m_pConf->ProcessUserCreateConfirm(USER_CHANNEL_JOIN_FAILURE, m_nidMyself);
		}
	}
	else
	{
		/*
		 * Attach user request failed as indicated by the result field in the
		 * confirm message, because of any of the following causes:
		 * congested, domain disconnected, no such domain, too many channels,
		 * too many users, unspecified failure. In this case the user object
		 * just sends the conference a GCC_USER_ATTACH_FAILURE ( to be defined
		 * in command target.h) , which causes
		 * the conference object to delete the user attachment.
		 * UserCreateConfirm message is not corresponding exectly to a single
		 * primitive.
		 */
	    WARNING_OUT(("MCSUser::ProcessAttachUserConfirm: ATTACH FAILED"));
		m_pConf->ProcessUserCreateConfirm(USER_ATTACH_FAILURE, m_nidMyself);
	}

	return (MCS_NO_ERROR);
}

/*
 *	MCSError	JoinUserAndBroadCastChannels()
 *
 *	Private Function Description
 *		This function is called by user object when it gets a successful
 *		attach user confrim, to join user id and broadcast channels.
 *		If the channel join requests fail, it returns the appropriate MCS
 *		Error.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		See return values for mcs channel jon request.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

MCSError	MCSUser::JoinUserAndBroadCastChannels()
{
	MCSError		rc;

	rc = g_pMCSIntf->ChannelJoinRequest(m_nidMyself, m_pMCSSap);
	if(rc == MCS_NO_ERROR)

	{
		rc = g_pMCSIntf->ChannelJoinRequest(BROADCAST_CHANNEL_ID, m_pMCSSap);
	}

	return (rc);
}

/*
 *	MCSError	JoinUserAndBroadCastChannels()
 *
 *	Private Function Description
 *		This function is called by user object of a convener gcc provider
 *		when it gets a successful attach user confrim, to join convener
 *	 	channel. If the channel join requests fail, it returns the appropriate
 *		MCS	Error.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		See return values for mcs channel jon request.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
MCSError	MCSUser::JoinConvenerChannel()
{
	return g_pMCSIntf->ChannelJoinRequest(CONVENER_CHANNEL_ID, m_pMCSSap);
}

/*
 *	UINT	ProcessChannelJoinConfirm()
 *
 *	Private Function Description
 *		This function is called when the user object gets an channel join
 *		confirm from MCS in response to channel join requests made by the
 *		user object. If a channel is joined successfully as indicated by
 *		the result in the confirm, a channel joined flag corresponding to
 *		that channel id is set. This flag indicates as to which channels a
 *		user object is joined at any given time. Also after setting this
 *		flag the functions checks to see if all tke required channels based
 *		on the type of gcc provider, are joined. If all required channels are
 *		joined the conference object is informaed about it via an owner call-
 *		back (USER_CREATE_CONFIRM).	
 *
 *	Formal Parameters:
 *		result		-	(i)	Result of the channel join request.
 *		channel_id	-	(i)	Channel ID that this confirm pertains to.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT MCSUser::ProcessChannelJoinConfirm(Result result, ChannelID channel_id)
{
	if (m_ChannelJoinedFlags.channel_join_error == FALSE)
	{
		if (result == RESULT_SUCCESSFUL)
		{
			if( channel_id == m_nidMyself)
            {
				m_ChannelJoinedFlags.user_channel_joined = TRUE;
            }
			else
			{
				switch (channel_id)
				{	
				case CONVENER_CHANNEL_ID:
					m_ChannelJoinedFlags.convener_channel_joined = TRUE;
					break;	

                case BROADCAST_CHANNEL_ID:
					m_ChannelJoinedFlags.broadcast_channel_joined = TRUE;
					break;
				}
			}

			/*
			**	If all the channels are joined we inform the owner object that
			**	the user object was successfully created.
			*/
			if (AreAllChannelsJoined())
			{
				m_pConf->ProcessUserCreateConfirm(USER_RESULT_SUCCESSFUL, m_nidMyself);
			}
		}
		else
		{
			WARNING_OUT(("MCSUser::ProcessChannelJoinConfirm: Error joining channel, result=%u", (UINT) result));

			m_ChannelJoinedFlags.channel_join_error = TRUE ;

			m_pConf->ProcessUserCreateConfirm(USER_CHANNEL_JOIN_FAILURE, m_nidMyself);
		}
	}

	return (MCS_NO_ERROR);
}

/*
 *	BOOL	AreAllChannelsJoined()
 *
 *	Public Function Description
 *		This function is called to check if all tke required channels based
 *		on the type of gcc provider, are joined. It returns true if all
 *		required channels are joined and false otherwise. This function uses
 *		different channel joined flags to check which channels the given user
 *		object is joined to.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	If all channels are joined.
 *		FALSE	-	If all the channels are not joined.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
BOOL MCSUser::AreAllChannelsJoined(void)
{
	BOOL rc = FALSE;
	
	switch (m_pConf->GetConfNodeType())
	{
		case TOP_PROVIDER_NODE:
			if ((m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
			
		case JOINED_CONVENER_NODE:
		case CONVENER_NODE:
			if ((m_ChannelJoinedFlags.convener_channel_joined) &&
				(m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
							
		case TOP_PROVIDER_AND_CONVENER_NODE:
   			if ((m_ChannelJoinedFlags.convener_channel_joined) &&
				(m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
	
		case JOINED_NODE:
		case INVITED_NODE:
	   		if( (m_ChannelJoinedFlags.user_channel_joined) &&
				(m_ChannelJoinedFlags.broadcast_channel_joined))
			{
				rc = TRUE;
			}
			break;
	}

	return rc;
} 					

/*
 *	void	SendUserIDRequest()
 *
 *	Public Function Description:
 *		This request originates from the conference object. Conference object
 *		sends the sequence number obtained in the conference create confirm
 *		or conference join confirm to the parent GCC provider on the parent
 *		gcc provider's UserId channel. The pdu is encoded here and is
 *		queued to be sent during the next heartbeat.
 */
void MCSUser::SendUserIDRequest(TagNumber tag_number)
{
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the UserIDIndication pdu structure to be passed in the
	**	constructor of the packet class.
	*/

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = USER_ID_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.user_id_indication.tag = tag_number;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidParent, TOP_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
    }
}

/*
 *	GCCError	ConferenceJoinRequest()
 *
 *	Public Function Description:
 * 		This call is made by the conference object of the intermediate node
 *  	to forward the conference join request over to the top provider. This
 *		function encodes the conference join request pdu and queues it to be
 *		sent in the next heartbeat.
 *
 *	Caveats
 *		The connection handle is used here for a TAG and should be passed back
 *		to the owner object when the join response comes in.
 */
GCCError MCSUser::ConferenceJoinRequest(
									CPassword           *convener_password,
									CPassword           *password_challenge,
									LPWSTR				pwszCallerID,
									CUserDataListContainer *user_data_list,
									ConnectionHandle	connection_handle)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_JOIN_REQUEST_CHOSEN;
   	gcc_pdu.u.request.u.conference_join_request.tag = (TagNumber)connection_handle;
	gcc_pdu.u.request.u.conference_join_request.bit_mask = TAG_PRESENT;

	//	Insert the convener password into the ASN.1 structure
	if (convener_password != NULL)
	{
		rc = convener_password->GetPasswordSelectorPDU(
				&gcc_pdu.u.request.u.conference_join_request.cjrq_convener_password);
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.request.u.conference_join_request.bit_mask |= CJRQ_CONVENER_PASSWORD_PRESENT;
		}
	}

    //	Insert the password challenge into the ASN.1 structure
	if (( password_challenge != NULL ) && (rc == GCC_NO_ERROR))
	{
		rc = password_challenge->GetPasswordChallengeResponsePDU (
								&gcc_pdu.u.request.u.conference_join_request.
									cjrq_password);
									
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.request.u.conference_join_request.bit_mask |=
												CJRQ_PASSWORD_PRESENT;
		}
	}

	//	Insert the caller identifier into the ASN.1 structure
	UINT cchCallerID = ::My_strlenW(pwszCallerID);
	if ((cchCallerID != 0 ) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.request.u.conference_join_request.cjrq_caller_id.value = pwszCallerID;
		gcc_pdu.u.request.u.conference_join_request.cjrq_caller_id.length = cchCallerID;
		gcc_pdu.u.request.u.conference_join_request.bit_mask |= CJRQ_CALLER_ID_PRESENT;
	}
	
 	//	Insert the user data into the ASN.1 structure
	if (( user_data_list != NULL ) && (rc == GCC_NO_ERROR))
	{
		rc = user_data_list->GetUserDataPDU (
								&gcc_pdu.u.request.u.conference_join_request.cjrq_user_data);
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.request.u.conference_join_request.bit_mask |= CJRQ_USER_DATA_PRESENT;
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					  		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
    		AddToMCSMessageQueue(packet, m_nidTopProvider, TOP_PRIORITY, FALSE);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}
	
	//	Cleanup after any errors
	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
	
	return rc;
}

/*
 *	GCCError	SendConferenceLockRequest()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference lock
 *		request PDU to the top provider.
 */
GCCError MCSUser::SendConferenceLockRequest()
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_LOCK_REQUEST_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceLockResponse()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference lock
 *		response PDU to the requesting node.
 */
GCCError	MCSUser::SendConferenceLockResponse (
									UserID		source_node,
									GCCResult	result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_LOCK_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_lock_response.result =
							::TranslateGCCResultToLockResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, source_node, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceUnlockRequest()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference unlock
 *		request PDU to the top provider.
 */
GCCError	MCSUser::SendConferenceUnlockRequest ()
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_UNLOCK_REQUEST_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceUnlockResponse()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object to send a conference unlock
 *		response PDU to the requesting node.
 */
GCCError	MCSUser::SendConferenceUnlockResponse (
									UserID		source_node,
									GCCResult	result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_UNLOCK_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_unlock_response.result =
							::TranslateGCCResultToUnlockResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, source_node, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceLockIndication()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object of the top provider
 *		to send a conference lock indication PDU to one or all other nodes
 *		that are registered in the conference.
 */
GCCError	MCSUser::SendConferenceLockIndication(
									BOOL		uniform_send,
									UserID		source_node)
{
	GCCError 				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_LOCK_INDICATION_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(
			        packet,
			        uniform_send ? BROADCAST_CHANNEL_ID : source_node,
			        HIGH_PRIORITY,
			        uniform_send);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConferenceUnlockIndication()
 *
 *	Public Function Description:
 *		This function is invoked by the owner object of the top provider
 *		to send a conference unlock indication PDU to one or all other nodes
 *		that are registered in the conference.
 */
GCCError MCSUser::SendConferenceUnlockIndication(
									BOOL		uniform_send,
									UserID		source_node)
{
	GCCError 				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_UNLOCK_INDICATION_CHOSEN;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(
                    packet,
                    uniform_send ? BROADCAST_CHANNEL_ID : source_node,
                    HIGH_PRIORITY,
                    uniform_send);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/******************************* Registry Calls ******************************/

/*
 *	void	RegistryRegisterChannelRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a channel in
 *		the application registry.
 */
void	MCSUser::RegistryRegisterChannelRequest(
									CRegKeyContainer        *registry_key_data,
									ChannelID				channel_id,
									EntityID				entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN;

	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_register_channel_request.key);
							
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_register_channel_request.channel_id =
																	channel_id;
		gcc_pdu.u.request.u.registry_register_channel_request.entity_id =
																	entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					  		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			ERROR_OUT(("MCSUser::RegistryRegisterChannelRequest: Error creating packet"));
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	MCSUser::RegistryAssignTokenRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a token in
 *		the application registry.  Note that there is no token ID included in
 *		this request.  The token ID is allocated at the top provider.
 */
void	MCSUser::RegistryAssignTokenRequest (	
										CRegKeyContainer    *registry_key_data,
										EntityID			entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
		
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN;
	
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    					registry_assign_token_request.registry_key);
							
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_assign_token_request.entity_id = entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					 		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}
		
	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistrySetParameterRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a parameter in
 *		the application registry.  Note that parameter to be registered is
 *		included in this request.
 */
void	MCSUser::RegistrySetParameterRequest (
							CRegKeyContainer        *registry_key_data,
							LPOSTR			        parameter_value,
							GCCModificationRights	modification_rights,
							EntityID				entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_SET_PARAMETER_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.registry_set_parameter_request.bit_mask = 0;
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    			&gcc_pdu.u.request.u.
			    				registry_set_parameter_request.key);

	if (error_value == GCC_NO_ERROR)
	{
		if (parameter_value != NULL)
		{
			gcc_pdu.u.request.u.registry_set_parameter_request.
				registry_set_parameter.length =
					parameter_value->length;
					
			memcpy (gcc_pdu.u.request.u.registry_set_parameter_request.
						registry_set_parameter.value,
					parameter_value->value,
					parameter_value->length);
		}
		else
		{
			gcc_pdu.u.request.u.registry_set_parameter_request.
				registry_set_parameter.length = 0;
		}

		gcc_pdu.u.request.u.registry_set_parameter_request.entity_id =
																	entity_id;

		//	Set up the modification rights here if it exists
		if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
		{
			gcc_pdu.u.request.u.registry_set_parameter_request.bit_mask |=
											PARAMETER_MODIFY_RIGHTS_PRESENT;
			
			gcc_pdu.u.request.u.registry_set_parameter_request.
						parameter_modify_rights =
							(RegistryModificationRights)modification_rights;
		}

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					 		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryRetrieveEntryRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to retrieve an registry item
 *		from the registry.
 */
void	MCSUser::RegistryRetrieveEntryRequest (
										CRegKeyContainer    *registry_key_data,
										EntityID			entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN;
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_retrieve_entry_request.key);
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_retrieve_entry_request.entity_id =
																	entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					  		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	
		registry_key_data->FreeRegistryKeyDataPDU();
	}
	else
		error_value = GCC_ALLOCATION_FAILURE;

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
    }
}

/*
 *	void	RegistryDeleteEntryRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to delete a registry item
 *		from the registry.
 */
void	MCSUser::RegistryDeleteEntryRequest (	
										CRegKeyContainer    *registry_key_data,
										EntityID			entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN;

	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_delete_entry_request.key);

	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_delete_entry_request.entity_id = entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}
	
	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryMonitorRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to monitor a registry item
 *		in the registry.
 */
void		MCSUser::RegistryMonitorRequest (	
						CRegKeyContainer        *registry_key_data,
						EntityID				entity_id)
{
	GCCError				error_value;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN;
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    					&gcc_pdu.u.request.u.
			    						registry_monitor_entry_request.key);
							
	if (error_value == GCC_NO_ERROR)
	{
		gcc_pdu.u.request.u.registry_monitor_entry_request.entity_id= entity_id;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE; 	
		    delete packet;
		}

		registry_key_data->FreeRegistryKeyDataPDU();
	}
	
	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryAllocateHandleRequest()
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to allocate a number of
 *		handles from the application registry.
 */
void MCSUser::RegistryAllocateHandleRequest(
						UINT					number_of_handles,
						EntityID				entity_id )
{
	GCCError				error_value = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN;
	
	gcc_pdu.u.request.u.registry_allocate_handle_request.number_of_handles = (USHORT) number_of_handles;
	gcc_pdu.u.request.u.registry_allocate_handle_request.entity_id= entity_id;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
					   	PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	RegistryAllocateHandleResponse()
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to respond to an allocate
 *		handle request from an APE at a remote node.  The allocated handles
 *		are passed back here.
 */
void	MCSUser::RegistryAllocateHandleResponse (
						UINT					number_of_handles,
						UINT					registry_handle,
						EntityID				requester_entity_id,
						UserID					requester_node_id,
						GCCResult				result)
{
	GCCError				error_value = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN;

	gcc_pdu.u.response.u.registry_allocate_handle_response.number_of_handles = (USHORT) number_of_handles;
	gcc_pdu.u.response.u.registry_allocate_handle_response.entity_id = requester_entity_id;
	gcc_pdu.u.response.u.registry_allocate_handle_response.first_handle = (Handle) registry_handle;

	if (result == GCC_RESULT_SUCCESSFUL)
	{
		gcc_pdu.u.response.u.registry_allocate_handle_response.result = RARS_RESULT_SUCCESS;
	}
	else
	{
		gcc_pdu.u.response.u.registry_allocate_handle_response.result = NO_HANDLES_AVAILABLE;
	}

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
					   	PACKED_ENCODING_RULES,
						(LPVOID)&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, requester_node_id, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	void	RegistryResponse()
 *
 *	Public Function Description:
 *		This routine is used to respond to all the registry request except
 *		allocate handle.  It formulates the response PDU and queues it for
 *		delivery.
 */
void	MCSUser::RegistryResponse (
						RegistryResponsePrimitiveType	primitive_type,
						UserID							requester_owner_id,
						EntityID						requester_entity_id,
						CRegKeyContainer                *registry_key_data,
						CRegItem                        *registry_item_data,
						GCCModificationRights			modification_rights,
						UserID							entry_owner_id,
						EntityID						entry_entity_id,
						GCCResult						result)
{
	GCCError				error_value;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	DebugEntry(MCSUser::RegistryResponse);

	/*
	**	Encode the conference join response PDU, along with the sequence
	**	number.
	*/
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = REGISTRY_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.registry_response.bit_mask = 0;

	error_value = registry_key_data->GetRegistryKeyDataPDU(&gcc_pdu.u.response.u.registry_response.key);
	if (error_value == GCC_NO_ERROR)
	{
		if (registry_item_data != NULL)
		{
			registry_item_data->GetRegistryItemDataPDU(&gcc_pdu.u.response.u.registry_response.item);
		}
		else
        {
			gcc_pdu.u.response.u.registry_response.item.choice = VACANT_CHOSEN;
        }

		TRACE_OUT(("MCSUser: RegistryResponse: item_type=%d", (UINT) gcc_pdu.u.response.u.registry_response.item.choice));

		//	Set up the entry owner
		if (entry_owner_id != 0)
		{
			gcc_pdu.u.response.u.registry_response.owner.choice = OWNED_CHOSEN;
			gcc_pdu.u.response.u.registry_response.owner.u.owned.node_id = entry_owner_id;
			gcc_pdu.u.response.u.registry_response.owner.u.owned.entity_id = entry_entity_id;
		}
		else
		{
			gcc_pdu.u.response.u.registry_response.owner.choice = NOT_OWNED_CHOSEN;
		}

		//	Set up the requesters entity ID
		gcc_pdu.u.response.u.registry_response.entity_id = requester_entity_id;

		//	Set up the primitive type
		gcc_pdu.u.response.u.registry_response.primitive_type = primitive_type;

		gcc_pdu.u.response.u.registry_response.result =
						::TranslateGCCResultToRegistryResp(result);

		if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
		{
			gcc_pdu.u.response.u.registry_response.bit_mask |=
										RESPONSE_MODIFY_RIGHTS_PRESENT;

			gcc_pdu.u.response.u.registry_response.response_modify_rights =
						(RegistryModificationRights)modification_rights;
		}

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, requester_owner_id, HIGH_PRIORITY, FALSE);
		}
		else
        {
            ResourceFailureHandler();
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	DebugExitVOID(MCSUser::RegistryResponse);
}

/*
 *	void	RegistryMonitorEntryIndication()
 *
 *	Public Function Description:
 *		This routine is used by the top provider to issue a monitor
 *		indication anytime a registry entry that is being monitored changes.
 */
void	MCSUser::RegistryMonitorEntryIndication ( 	
						CRegKeyContainer	            *registry_key_data,
						CRegItem                        *registry_item_data,
						UserID							entry_owner_id,
						EntityID						entry_entity_id,
						GCCModificationRights			modification_rights)
{
	GCCError				error_value;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	/*
	**	Encode the conference join response PDU, along with the sequence
	**	number.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.registry_monitor_entry_indication.bit_mask = 0;
	
	
	error_value = registry_key_data->GetRegistryKeyDataPDU(
			    			&gcc_pdu.u.indication.u.
			    					registry_monitor_entry_indication.key);
							
	if (error_value == GCC_NO_ERROR)
	{
		registry_item_data->GetRegistryItemDataPDU(&gcc_pdu.u.indication.u.registry_monitor_entry_indication.item);

        //	Set up the entry owner
		if (entry_owner_id != 0)
		{
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.choice = OWNED_CHOSEN;
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.u.owned.node_id = entry_owner_id;
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.u.owned.entity_id = entry_entity_id;
		}
		else
		{
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.owner.choice = NOT_OWNED_CHOSEN;
		}
		
		if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
		{
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.bit_mask |= RESPONSE_MODIFY_RIGHTS_PRESENT;
			
			gcc_pdu.u.indication.u.registry_monitor_entry_indication.entry_modify_rights =
						(RegistryModificationRights)modification_rights;
		}

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
        {
			error_value = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}


/************************************************************************/

/*
 *	GCCError	AppInvokeIndication()
 *
 *	Public Function Description:
 *		This routine is used to send an application invoke indication to
 *		every node in the conference.
 */
GCCError 	MCSUser::AppInvokeIndication(
					CInvokeSpecifierListContainer	*invoke_specifier_list,
                    GCCSimpleNodeList               *pNodeList)
{
	GCCError								rc = GCC_NO_ERROR;
	PPacket									packet;
	GCCPDU									gcc_pdu;
	PacketError								packet_error;
	PSetOfDestinationNodes					new_destination_node;
	PSetOfDestinationNodes					old_destination_node = NULL;
	PSetOfDestinationNodes					pDstNodesToFree = NULL;
	UINT									i;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = APPLICATION_INVOKE_INDICATION_CHOSEN;

	gcc_pdu.u.indication.u.application_invoke_indication.bit_mask = 0;
	gcc_pdu.u.indication.u.application_invoke_indication.destination_nodes = NULL;
	gcc_pdu.u.indication.u.application_invoke_indication.application_protocol_entity_list = NULL;

	//	First, set up the destination node list
	if (pNodeList->cNodes != 0)
	{
		gcc_pdu.u.indication.u.application_invoke_indication.bit_mask |=
													DESTINATION_NODES_PRESENT;

		for (i = 0; i < pNodeList->cNodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_destination_node = new SetOfDestinationNodes;
			if (new_destination_node != NULL)
			{
				if (gcc_pdu.u.indication.u.application_invoke_indication.
													destination_nodes == NULL)
				{
					gcc_pdu.u.indication.u.application_invoke_indication.
									destination_nodes = new_destination_node;
					pDstNodesToFree = new_destination_node;
				}
				else
				{
					old_destination_node->next = new_destination_node;
				}

				old_destination_node = new_destination_node;
				new_destination_node->next = NULL;
				new_destination_node->value = pNodeList->aNodeIDs[i];
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		rc = invoke_specifier_list->GetApplicationInvokeSpecifierListPDU(
					&gcc_pdu.u.indication.u.application_invoke_indication.
						application_protocol_entity_list);
	}

	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

    if (NULL != pDstNodesToFree)
    {
        PSetOfDestinationNodes p;
        while (NULL != (p = pDstNodesToFree))
        {
            pDstNodesToFree = pDstNodesToFree->next;
            delete p;
        }
    }

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

   return rc;
}

/*
 *	GCCError	TextMessageIndication()
 *
 *	Public Function Description:
 *		This routine is used to send a text message to either a specific node
 *		or to every node in the conference.
 */
GCCError 	MCSUser::TextMessageIndication (
						LPWSTR						pwszTextMsg,
						UserID						destination_node )
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;
	LPWSTR					pwszMsg;

	//	Encode the PDU that will be forwarded to the top provider.
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = TEXT_MESSAGE_INDICATION_CHOSEN;

	if (NULL != (pwszMsg = ::My_strdupW(pwszTextMsg)))
	{
		gcc_pdu.u.indication.u.text_message_indication.message.length = ::lstrlenW(pwszMsg);
		gcc_pdu.u.indication.u.text_message_indication.message.value = pwszMsg;

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
					   		PACKED_ENCODING_RULES,
							(LPVOID)&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(
				        packet,
				        (destination_node == 0) ? BROADCAST_CHANNEL_ID : destination_node,
				        HIGH_PRIORITY,
				        FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }

		delete pwszMsg;
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return rc;
}

/*
 *	GCCError	ConferenceAssistanceIndication()
 *
 *	Public Function Description:
 *		This routine is used to send a conference assistance indication to
 *		every node in the conference.
 */
GCCError		MCSUser::ConferenceAssistanceIndication (
						UINT						number_of_user_data_members,
						PGCCUserData		*		user_data_list)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU					gcc_pdu;
	PacketError				packet_error;
	CUserDataListContainer  *user_data_record;

 	DebugEntry(MCSUser::ConferenceAssistanceIndication);

	//	Encode the PDU
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_ASSISTANCE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_assistance_indication.bit_mask = 0;

	//	Construct the user data list container
	if ((number_of_user_data_members != 0) && (rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		user_data_record = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
		if (user_data_record == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		user_data_record = NULL;
    }

	if ((user_data_record != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = user_data_record->GetUserDataPDU(
			&gcc_pdu.u.indication.u.conference_assistance_indication.
									cain_user_data);

		gcc_pdu.u.indication.u.conference_assistance_indication.bit_mask
									|= CAIN_USER_DATA_PRESENT;
	}

	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}

	// Clean up containers
	if (user_data_record != NULL)
	{
		user_data_record->Release();
	}

	return (rc);
}



/*
 *	GCCError	ConferenceTransferRequest()
 *
 *	Public Function Description:
 *		This routine is used to send a conference transfer request to the
 *		top provider in the conference.
 */
GCCError	MCSUser::ConferenceTransferRequest (
				PGCCConferenceName		destination_conference_name,
				GCCNumericString		destination_conference_modifier,
				CNetAddrListContainer   *destination_address_list,
				UINT					number_of_destination_nodes,
				PUserID					destination_node_list,
				CPassword               *password)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;
	UINT						string_length;
	PSetOfTransferringNodesRq	new_set_of_nodes;
	PSetOfTransferringNodesRq	old_set_of_nodes;
	UINT						i;

	DebugEntry(MCSUser::ConferenceTransferRequest);

	//	Encode the PDU
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_TRANSFER_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.conference_transfer_request.bit_mask = 0;
	
	//	First get the conference name (either numeric or text).
	if (destination_conference_name->numeric_string != NULL)
	{
		gcc_pdu.u.request.u.conference_transfer_request.conference_name.choice =
											NAME_SELECTOR_NUMERIC_CHOSEN;
		
		lstrcpy (gcc_pdu.u.request.u.conference_transfer_request.
					conference_name.u.name_selector_numeric,
				(LPSTR)destination_conference_name->numeric_string);
	}
	else
	{
		//	Use a unicode string to determine the length
		gcc_pdu.u.request.u.conference_transfer_request.conference_name.choice =
											NAME_SELECTOR_TEXT_CHOSEN;

		string_length = ::My_strlenW(destination_conference_name->text_string);

		gcc_pdu.u.request.u.conference_transfer_request.
					conference_name.u.name_selector_text.length = string_length;
		
		gcc_pdu.u.request.u.conference_transfer_request.
					conference_name.u.name_selector_text.value =
							destination_conference_name->text_string;
	}
	

	//	Next get the conference name modifier if it exists
	if (destination_conference_modifier != NULL)
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
											CTRQ_CONFERENCE_MODIFIER_PRESENT;
	
		lstrcpy (gcc_pdu.u.request.u.conference_transfer_request.
					ctrq_conference_modifier,
				(LPSTR)destination_conference_modifier);
	}

	//	Get the network address list if it exist
	if (destination_address_list != NULL)
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
											CTRQ_NETWORK_ADDRESS_PRESENT;
		
		rc = destination_address_list->GetNetworkAddressListPDU (
						&gcc_pdu.u.request.u.conference_transfer_request.
							ctrq_net_address);
	}

	//	Get the destination node list if it exists
	if ((number_of_destination_nodes != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
											CTRQ_TRANSFERRING_NODES_PRESENT;
											
		old_set_of_nodes = NULL;
		gcc_pdu.u.request.u.conference_transfer_request.
									ctrq_transferring_nodes = NULL;
									
		for (i = 0; i <	number_of_destination_nodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_set_of_nodes = new SetOfTransferringNodesRq;
			if (new_set_of_nodes == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;	
			}
			else
				new_set_of_nodes->next = NULL;

			if (old_set_of_nodes == NULL)
			{
				gcc_pdu.u.request.u.conference_transfer_request.
									ctrq_transferring_nodes = new_set_of_nodes;
			}
			else
				old_set_of_nodes->next = new_set_of_nodes;

			old_set_of_nodes = new_set_of_nodes;
			new_set_of_nodes->value = destination_node_list[i];
		}
	}

	//	Get the password if it exists
	if ((password != NULL) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.request.u.conference_transfer_request.bit_mask |=
													CTRQ_PASSWORD_PRESENT;
		
		rc = password->GetPasswordSelectorPDU (
				&gcc_pdu.u.request.u.conference_transfer_request.ctrq_password);
	}
	
	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	// Clean up the node list if it was created
	if (gcc_pdu.u.request.u.conference_transfer_request.bit_mask &
											CTRQ_TRANSFERRING_NODES_PRESENT)
	{
		old_set_of_nodes = gcc_pdu.u.request.u.conference_transfer_request.
									ctrq_transferring_nodes;
		while (old_set_of_nodes != NULL)
		{
			new_set_of_nodes = old_set_of_nodes->next;
			delete old_set_of_nodes;
			old_set_of_nodes = new_set_of_nodes;
		}
	}

	return rc;
}


/*
 *	GCCError	ConferenceTransferIndication()
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send out the transfer
 *		indication to every node in the conference.  It is each nodes
 *		responsiblity to search the destination node list to see if
 *		it should transfer.
 */
GCCError	MCSUser::ConferenceTransferIndication (
				PGCCConferenceName		destination_conference_name,
				GCCNumericString		destination_conference_modifier,
				CNetAddrListContainer   *destination_address_list,
				UINT					number_of_destination_nodes,
				PUserID					destination_node_list,
				CPassword               *password)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;
	UINT						string_length;
	PSetOfTransferringNodesIn	new_set_of_nodes;
	PSetOfTransferringNodesIn	old_set_of_nodes;
	UINT						i;

	DebugEntry(MCSUser::ConferenceTransferIndication);

	//	Encode the PDU
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TRANSFER_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask = 0;
	
	//	First get the conference name (either numeric or text).
	if (destination_conference_name->numeric_string != NULL)
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.
									conference_name.choice =
											NAME_SELECTOR_NUMERIC_CHOSEN;
		
		lstrcpy (gcc_pdu.u.indication.u.conference_transfer_indication.
					conference_name.u.name_selector_numeric,
				(LPSTR)destination_conference_name->numeric_string);
	}
	else
	{
		//	Use a unicode string to determine the length
		gcc_pdu.u.indication.u.conference_transfer_indication.
									conference_name.choice =
											NAME_SELECTOR_TEXT_CHOSEN;

		string_length = ::My_strlenW(destination_conference_name->text_string);

		gcc_pdu.u.indication.u.conference_transfer_indication.
					conference_name.u.name_selector_text.length = string_length;
		
		gcc_pdu.u.indication.u.conference_transfer_indication.
					conference_name.u.name_selector_text.value =
							destination_conference_name->text_string;
	}
	

	//	Next get the conference name modifier if it exists
	if (destination_conference_modifier != NULL)
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
											CTIN_CONFERENCE_MODIFIER_PRESENT;
	
		lstrcpy (gcc_pdu.u.indication.u.conference_transfer_indication.
					ctin_conference_modifier,
				(LPSTR)destination_conference_modifier);
	}

	//	Get the network address list if it exist
	if (destination_address_list != NULL)
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
											CTIN_NETWORK_ADDRESS_PRESENT;
		
		rc = destination_address_list->GetNetworkAddressListPDU (
						&gcc_pdu.u.indication.u.conference_transfer_indication.
							ctin_net_address);
	}

	//	Get the destination node list if it exists
	if ((number_of_destination_nodes != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
											CTIN_TRANSFERRING_NODES_PRESENT;
											
		old_set_of_nodes = NULL;
		gcc_pdu.u.indication.u.conference_transfer_indication.
									ctin_transferring_nodes = NULL;
									
		for (i = 0; i <	number_of_destination_nodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_set_of_nodes = new SetOfTransferringNodesIn;
			if (new_set_of_nodes == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;	
			}
			else
				new_set_of_nodes->next = NULL;

			if (old_set_of_nodes == NULL)
			{
				gcc_pdu.u.indication.u.conference_transfer_indication.
									ctin_transferring_nodes = new_set_of_nodes;
			}
			else
				old_set_of_nodes->next = new_set_of_nodes;

			old_set_of_nodes = new_set_of_nodes;
			new_set_of_nodes->value = destination_node_list[i];
		}
	}

	//	Get the password if it exists
	if ((password != NULL) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask |=
													CTIN_PASSWORD_PRESENT;
		
		rc = password->GetPasswordSelectorPDU (
						&gcc_pdu.u.indication.u.conference_transfer_indication.
							ctin_password);
	}
	
	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	// Clean up the node list if it was created
	if (gcc_pdu.u.indication.u.conference_transfer_indication.bit_mask &
											CTIN_TRANSFERRING_NODES_PRESENT)
	{
		old_set_of_nodes = gcc_pdu.u.indication.u.
						conference_transfer_indication.ctin_transferring_nodes;
		while (old_set_of_nodes != NULL)
		{
			new_set_of_nodes = old_set_of_nodes->next;
			delete old_set_of_nodes;
			old_set_of_nodes = new_set_of_nodes;
		}
	}

	DebugExitINT(MCSUser::ConferenceTransferIndication, rc);
	return rc;
}


/*
 *	GCCError	ConferenceTransferResponse()
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send back a response to
 *		the node that made a transfer request.  The info specified in the
 *		request is included in the response to match request to response.
 */
GCCError	MCSUser::ConferenceTransferResponse (
				UserID					requesting_node_id,
				PGCCConferenceName		destination_conference_name,
				GCCNumericString		destination_conference_modifier,
				UINT					number_of_destination_nodes,
 				PUserID					destination_node_list,
				GCCResult				result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;
	UINT						string_length;
	PSetOfTransferringNodesRs	new_set_of_nodes;
	PSetOfTransferringNodesRs	old_set_of_nodes;
	UINT						i;

	DebugEntry(MCSUser::ConferenceTransferResponse);

	//	Encode the PDU
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_TRANSFER_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_transfer_response.bit_mask = 0;
	
	//	First get the conference name (either numeric or text).
	if (destination_conference_name->numeric_string != NULL)
	{
		gcc_pdu.u.response.u.conference_transfer_response.
									conference_name.choice =
											NAME_SELECTOR_NUMERIC_CHOSEN;
		
        ::lstrcpyA(gcc_pdu.u.response.u.conference_transfer_response.
					conference_name.u.name_selector_numeric,
				(LPSTR)destination_conference_name->numeric_string);
	}
	else
	{
		//	Use a unicode string to determine the length
		gcc_pdu.u.response.u.conference_transfer_response.
									conference_name.choice =
											NAME_SELECTOR_TEXT_CHOSEN;

		string_length = ::My_strlenW(destination_conference_name->text_string);

		gcc_pdu.u.response.u.conference_transfer_response.
					conference_name.u.name_selector_text.length = string_length;
		
		gcc_pdu.u.response.u.conference_transfer_response.
					conference_name.u.name_selector_text.value =
							destination_conference_name->text_string;
	}
	

	//	Next get the conference name modifier if it exists
	if (destination_conference_modifier != NULL)
	{
		gcc_pdu.u.response.u.conference_transfer_response.bit_mask |=
											CTRS_CONFERENCE_MODIFIER_PRESENT;
	
        ::lstrcpyA(gcc_pdu.u.response.u.conference_transfer_response.
					ctrs_conference_modifier,
				(LPSTR)destination_conference_modifier);
	}

	//	Get the destination node list if it exists
	if ((number_of_destination_nodes != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.response.u.conference_transfer_response.bit_mask |=
											CTRS_TRANSFERRING_NODES_PRESENT;
											
		old_set_of_nodes = NULL;
		gcc_pdu.u.response.u.conference_transfer_response.
									ctrs_transferring_nodes = NULL;
									
		for (i = 0; i <	number_of_destination_nodes; i++)
		{
			DBG_SAVE_FILE_LINE
			new_set_of_nodes = new SetOfTransferringNodesRs;
			if (new_set_of_nodes == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;	
			}
			else
				new_set_of_nodes->next = NULL;

			if (old_set_of_nodes == NULL)
			{
				gcc_pdu.u.response.u.conference_transfer_response.
									ctrs_transferring_nodes = new_set_of_nodes;
			}
			else
				old_set_of_nodes->next = new_set_of_nodes;

			old_set_of_nodes = new_set_of_nodes;
			new_set_of_nodes->value = destination_node_list[i];
		}
	}

	//	Set up the result
	if (result == GCC_RESULT_SUCCESSFUL)
	{
		gcc_pdu.u.response.u.conference_transfer_response.result =
														CTRANS_RESULT_SUCCESS;
	}
	else
	{
		gcc_pdu.u.response.u.conference_transfer_response.result =
												CTRANS_RESULT_INVALID_REQUESTER;
	}

	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, requesting_node_id, HIGH_PRIORITY, FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	// Clean up the node list if it was created
	if (gcc_pdu.u.response.u.conference_transfer_response.bit_mask &
											CTRS_TRANSFERRING_NODES_PRESENT)
	{
		old_set_of_nodes = gcc_pdu.u.response.u.
						conference_transfer_response.ctrs_transferring_nodes;
		while (old_set_of_nodes != NULL)
		{
			new_set_of_nodes = old_set_of_nodes->next;
			delete old_set_of_nodes;
			old_set_of_nodes = new_set_of_nodes;
		}
	}

	DebugExitINT(MCSUser::ConferenceTransferResponse, rc);
	return rc;
}


/*
 *	GCCError	ConferenceAddRequest()
 *
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 */
GCCError	MCSUser::ConferenceAddRequest (
						TagNumber				conference_add_tag,
						UserID					requesting_node,
						UserID					adding_node,
						UserID					target_node,
						CNetAddrListContainer   *network_address_container,
						CUserDataListContainer  *user_data_container)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	DebugEntry(MCSUser::ConferenceAddRequest);

	//	Encode the PDU
	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_ADD_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.conference_add_request.bit_mask = 0;
	
	//	Get the network address list if it exist
	if (network_address_container != NULL)
	{
		//	Set up the network address portion of the pdu
		rc = network_address_container->GetNetworkAddressListPDU (
						&gcc_pdu.u.request.u.conference_add_request.
							add_request_net_address);
		
		//	Set up the user data container
		if ((rc == GCC_NO_ERROR) && (user_data_container != NULL))
		{
			rc = user_data_container->GetUserDataPDU (
				&gcc_pdu.u.request.u.conference_add_request.carq_user_data);
								
			if (rc == GCC_NO_ERROR)
			{
				gcc_pdu.u.request.u.conference_add_request.bit_mask |=
														CARQ_USER_DATA_PRESENT;
			}
		}
	
		//	Encode the PDU
		if (rc == GCC_NO_ERROR)
		{
			//	specify the requesting node					
			gcc_pdu.u.request.u.conference_add_request.requesting_node =
															requesting_node;
		
			if (adding_node != 0)
			{
				gcc_pdu.u.request.u.conference_add_request.bit_mask |=
															ADDING_MCU_PRESENT;
				gcc_pdu.u.request.u.conference_add_request.adding_mcu =
															adding_node;
			}

			gcc_pdu.u.request.u.conference_add_request.tag = conference_add_tag;

			DBG_SAVE_FILE_LINE
			packet = new Packet((PPacketCoder) g_GCCCoder,
								PACKED_ENCODING_RULES,
								&gcc_pdu,
								GCC_PDU,
								TRUE,
								&packet_error);
			if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
			{
				AddToMCSMessageQueue(packet, target_node, HIGH_PRIORITY, FALSE);
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
				delete packet;
            }
		}
	}
	else
    {
		rc = GCC_BAD_NETWORK_ADDRESS;
    }

	DebugExitINT(MCSUser::ConferenceAddRequest, rc);
	return rc;
}


/*
 *	GCCError	ConferenceAddResponse()
 *
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 */
GCCError	MCSUser::ConferenceAddResponse(
						TagNumber				add_request_tag,
						UserID					requesting_node,
						CUserDataListContainer  *user_data_container,
						GCCResult				result)
{
	GCCError					rc = GCC_NO_ERROR;
	PPacket						packet;
	GCCPDU						gcc_pdu;
	PacketError					packet_error;

	DebugEntry(MCSUser::ConferenceAddResponse);

	//	Encode the PDU
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_ADD_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_add_response.bit_mask = 0;
	
	//	Set up the user data container
	if ((rc == GCC_NO_ERROR) && (user_data_container != NULL))
	{
		rc = user_data_container->GetUserDataPDU (
			&gcc_pdu.u.response.u.conference_add_response.cars_user_data);
							
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.response.u.conference_add_response.bit_mask |=
													CARS_USER_DATA_PRESENT;
		}
	}

	//	Encode the PDU
	if (rc == GCC_NO_ERROR)
	{
		gcc_pdu.u.response.u.conference_add_response.tag = add_request_tag;
		
		gcc_pdu.u.response.u.conference_add_response.result =
						::TranslateGCCResultToAddResult(result);

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, requesting_node, HIGH_PRIORITY, FALSE);
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
        }
	}

	DebugExitINT(MCSUser::ConferenceAddResponse, rc);
	return rc;
}


/************************* Conductorship Calls ***********************/
/*
 *	GCCError	ConductorTokenGrab()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to grab the conductor token.
 */
GCCError	MCSUser::ConductorTokenGrab()
{
	MCSError	mcs_error;
	
	mcs_error = g_pMCSIntf->TokenGrabRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);
											
	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}

/*
 *	GCCError	ConductorTokenRelease()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to release the conductor token.
 */
GCCError	MCSUser::ConductorTokenRelease()
{
	MCSError	mcs_error;
	
	mcs_error = g_pMCSIntf->TokenReleaseRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);
											
	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}
/*
 *	GCCError	ConductorTokenPlease()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to request the conductor token from
 *		the current conductor.
 */
GCCError	MCSUser::ConductorTokenPlease()
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenPleaseRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);

	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}

/*
 *	GCCError	ConductorTokenGive ()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to give the conductor token to the
 *		specified node.
 */
GCCError	MCSUser::ConductorTokenGive(UserID recipient_user_id)
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenGiveRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID,
														recipient_user_id);

	return (g_pMCSIntf->TranslateMCSIFErrorToGCCError (mcs_error));
}

/*
 *	GCCError	ConductorTokenGiveResponse ()
 *
 *	Public Function Description:
 *		This routine makes the MCS calls to respond to a conductor give
 *		request.
 */
GCCError	MCSUser::ConductorTokenGiveResponse(Result result)
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenGiveResponse(m_pMCSSap, CONDUCTOR_TOKEN_ID, result);

	return g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
}

/*
 *	GCCError	ConductorTokenTest ()
 *
 *	Public Function Description:
 *		This routine is used to test the current state of the conductor token
 *		(is it grabbed or not).
 */
GCCError	MCSUser::ConductorTokenTest()
{
	MCSError	mcs_error;

	mcs_error = g_pMCSIntf->TokenTestRequest(m_pMCSSap, CONDUCTOR_TOKEN_ID);

	return g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
}


/*
 *	GCCError	SendConductorAssignIndication()
 *
 *	Public Function Description:
 *		This routine sends a conductor assign indication to all the
 *		nodes in the conference.
 */
GCCError	MCSUser::SendConductorAssignIndication(
								UserID			conductor_user_id)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConductorAssignIndication pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_ASSIGN_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_assign_indication.user_id =
															conductor_user_id;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, TOP_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConductorReleaseIndication()
 *
 *	Public Function Description:
 *		This routine sends a conductor release indication to all the
 *		nodes in the conference.
 */
GCCError	MCSUser::SendConductorReleaseIndication()
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConductorAssignIndication pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_RELEASE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_release_indication.placeholder = 0;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, TOP_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}
		
/*
 *	GCCError	SendConductorPermitAsk ()
 *
 *	Public Function Description:
 *		This routine sends a conductor permission ask request directly to the
 *		conductor node.
 */
GCCError	MCSUser::SendConductorPermitAsk (
						BOOL					grant_permission)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConductorPermissionAskIndication pdu structure to be passed
	**	in the constructor of the packet class.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_permission_ask_indication.
								permission_is_granted = (ASN1bool_t)grant_permission;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	SendConductorPermitGrant ()
 *
 *	Public Function Description:
 *		This routine sends a conductor permission grant indication to every
 *		node in the conference.  Usually issued when permissions change.
 */
GCCError	MCSUser::SendConductorPermitGrant (
				UINT					number_granted,
				PUserID					granted_node_list,
				UINT					number_waiting,
				PUserID					waiting_node_list)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;
	PPermissionList		permission_list;
	PPermissionList		previous_permission_list;
	PWaitingList			waiting_list;
	PWaitingList			previous_waiting_list;
	UINT					i;
	
	/*
	**	Fill in the ConductorPermissionAskIndication pdu structure to be passed
	**	in the constructor of the packet class.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conductor_permission_grant_indication.bit_mask = 0;

	//	First fill in the granted node permission list
	gcc_pdu.u.indication.u.
		conductor_permission_grant_indication.permission_list = NULL;
	previous_permission_list = NULL;
	for (i = 0; i < number_granted; i++)
	{
		DBG_SAVE_FILE_LINE
		permission_list = new PermissionList;
		if (permission_list == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
			break;
		}

		if (previous_permission_list == NULL)
		{
			gcc_pdu.u.indication.u.conductor_permission_grant_indication.
											permission_list = permission_list;
		}
		else
			previous_permission_list->next = permission_list;

		previous_permission_list = permission_list;

		permission_list->value = granted_node_list[i];
		permission_list->next = NULL;
	}

	//	If waiting list exists fill it in
	if ((number_waiting != 0) && (rc == GCC_NO_ERROR))
	{
		gcc_pdu.u.indication.u.conductor_permission_grant_indication.bit_mask =
														WAITING_LIST_PRESENT;
		gcc_pdu.u.indication.u.
			conductor_permission_grant_indication.waiting_list = NULL;
		previous_waiting_list = NULL;
		for (i = 0; i < number_waiting; i++)
		{
			DBG_SAVE_FILE_LINE
			waiting_list = new WaitingList;
			if (waiting_list == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}

			if (previous_waiting_list == NULL)
			{
				gcc_pdu.u.indication.u.conductor_permission_grant_indication.
												waiting_list = waiting_list;
			}
			else
				previous_waiting_list->next = waiting_list;

			previous_waiting_list = waiting_list;

			waiting_list->value = waiting_node_list[i];
			waiting_list->next = NULL;
		}
	}

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, TOP_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/**********************************************************************/


/*****************	Miscelaneous calls ******************************/
/*
 *	GCCError	TimeRemainingRequest()
 *
 *	Public Function Description:
 *		This routine sends out an indication to every node in the
 *		conference informing how much time is remaining in the conference.
 */
GCCError	MCSUser::TimeRemainingRequest (
						UINT					time_remaining,
						UserID					node_id)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the TimeRemainingRequest pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_time_remaining_indication.bit_mask = 0;
	
	gcc_pdu.u.indication.u.conference_time_remaining_indication.time_remaining =
																time_remaining;
	
	if (node_id != 0)
	{
		gcc_pdu.u.indication.u.conference_time_remaining_indication.bit_mask |=
										TIME_REMAINING_NODE_ID_PRESENT;
		gcc_pdu.u.indication.u.conference_time_remaining_indication.
						time_remaining_node_id = node_id;
	}

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	TimeInquireRequest()
 *
 *	Public Function Description:
 *		This routine sends out a request for a time remaing update.
 */
GCCError	MCSUser::TimeInquireRequest (
						BOOL				time_is_conference_wide)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the TimeInquireRequest pdu structure to be passed in the
 	**	constructor of the packet class.
 	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_time_inquire_indication.
							time_is_node_specific = (ASN1bool_t)time_is_conference_wide;
	
	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,					
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, CONVENER_CHANNEL_ID, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	GCCError	ConferenceExtendIndication()
 *
 *	Public Function Description:
 *		This routine sends out an indication informing conference participants
 *		of an extension.
 */
GCCError	MCSUser::ConferenceExtendIndication (
						UINT						extension_time,
						BOOL				time_is_conference_wide)
{
	GCCError				rc = GCC_NO_ERROR;
	PPacket					packet;
	GCCPDU 					gcc_pdu;
	PacketError				packet_error;

	/*
	**	Fill in the ConfernceExtendIndication pdu structure to be passed in the
	**	constructor of the packet class.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_time_extend_indication.
							time_to_extend = extension_time;
	gcc_pdu.u.indication.u.conference_time_extend_indication.
							time_is_node_specific = (ASN1bool_t)time_is_conference_wide;

	/*
	**	Create a packet object
	*/
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,		// pdu_type
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, CONVENER_CHANNEL_ID, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
	}

	return rc;
}

/*
 *	void	ConferenceJoinResponse()
 *
 *	Functional Description:
 * 		This function is called by the conference object of the
 * 		top provider when it wants to send the join response back to the gcc
 * 		provider that made the join request, through the directly connected
 * 		intermediate node. This function does the encoding of the join response
 *		PDU and also adds the sequence number sent in the request.
 */
void	MCSUser::ConferenceJoinResponse(
						UserID					receiver_id,
						BOOL					password_is_in_the_clear,
						BOOL					conference_locked,
						BOOL					conference_listed,
						GCCTerminationMethod	termination_method,
						CPassword               *password_challenge,
						CUserDataListContainer  *user_data_list,
						GCCResult				result)	
{
	GCCError				rc = GCC_NO_ERROR;	 	
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;
	TagNumber				lTagNum;

	if (0 == (lTagNum = m_ConfJoinResponseList2.Find(receiver_id)))
	{
		WARNING_OUT(("MCSUser::ConferenceJoinResponse: Unexpected Join Response"));
		return;
	}

	/*
	**	Encode the conference join response PDU, along with the sequence
	**	number.
	*/
	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_JOIN_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_join_response.bit_mask = 0;

	/*
	**	Get the sequence number of the outstanding response from the
	**	list of seq # vs userID using the userID passed from above.
	*/
	gcc_pdu.u.response.u.conference_join_response.tag = lTagNum;
	
	// Remove this entry from the list.
	m_ConfJoinResponseList2.Remove(receiver_id);


	//	Get password challenge PDU
	if ((password_challenge != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = password_challenge->GetPasswordChallengeResponsePDU (
			&gcc_pdu.u.response.u.conference_join_response.cjrs_password);
			
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.response.u.conference_join_response.bit_mask |=
													CJRS_PASSWORD_PRESENT;
		}
	}
	
	//	Get user data list PDU
	if ((user_data_list != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = user_data_list->GetUserDataPDU (
			&gcc_pdu.u.response.u.conference_join_response.cjrs_user_data);
							
		if (rc == GCC_NO_ERROR)
		{
			gcc_pdu.u.response.u.conference_join_response.bit_mask |=
													CJRS_USER_DATA_PRESENT;
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		gcc_pdu.u.response.u.conference_join_response.
												top_node_id = m_nidTopProvider;
		
		gcc_pdu.u.response.u.conference_join_response.
					clear_password_required = (ASN1bool_t)password_is_in_the_clear;

		gcc_pdu.u.response.u.conference_join_response.
					conference_is_locked = (ASN1bool_t)conference_locked;
		
		gcc_pdu.u.response.u.conference_join_response.
					conference_is_listed = (ASN1bool_t)conference_listed;

		gcc_pdu.u.response.u.conference_join_response.termination_method =
  									(TerminationMethod)termination_method;

		gcc_pdu.u.response.u.conference_join_response.result =
						::TranslateGCCResultToJoinResult(result);

		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							&gcc_pdu,
							GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			AddToMCSMessageQueue(packet, receiver_id, TOP_PRIORITY, FALSE);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			delete packet;
		}
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	ConferenceTerminateRequest()
 *
 *	Functional Description:
 *		This routine is used by a node subordinate to the top provider to
 *		request that the conference by terminated.
 */
void	MCSUser::ConferenceTerminateRequest(
									GCCReason				reason)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = REQUEST_CHOSEN;
	gcc_pdu.u.request.choice = CONFERENCE_TERMINATE_REQUEST_CHOSEN;
	gcc_pdu.u.request.u.conference_terminate_request.reason =
				::TranslateGCCReasonToTerminateRqReason(reason);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, m_nidTopProvider, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	void	ConferenceTerminateResponse ()
 *
 *	Functional Description:
 *		This routine is used by the top provider to respond to a terminate
 *		request issued by a subordinate node.  The result indicates if the
 *		requesting node had the correct privileges.
 */
void	MCSUser::ConferenceTerminateResponse (	
						UserID					requester_id,
						GCCResult				result)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	gcc_pdu.u.response.choice = CONFERENCE_TERMINATE_RESPONSE_CHOSEN;
	gcc_pdu.u.response.u.conference_terminate_response.result =
					::TranslateGCCResultToTerminateResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, requester_id, HIGH_PRIORITY, FALSE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	GCCError	ConferenceTerminateIndication()
 *
 *	Functional Description:
 *		This routine is used by the top provider to send out a terminate
 *		indication to every node in the conference.
 */
void	MCSUser::ConferenceTerminateIndication (
						GCCReason				reason)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = INDICATION_CHOSEN;
	gcc_pdu.u.indication.choice = CONFERENCE_TERMINATE_INDICATION_CHOSEN;
	gcc_pdu.u.indication.u.conference_terminate_indication.reason =
					::TranslateGCCReasonToTerminateInReason(reason);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
	}
	else
	{
        ResourceFailureHandler();
		error_value = GCC_ALLOCATION_FAILURE;
		delete packet;
	}
}

/*
 *	void	EjectNodeFromConference()
 *
 *	Functional Description:
 *		This routine is used when attempting to eject a node from the
 *		conference.
 */
GCCError	MCSUser::EjectNodeFromConference (	UserID		ejected_node_id,
			  									GCCReason	reason)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;
	ChannelID				channel_id;
	BOOL					uniform_send;
	Priority				priority;
	PAlarm					alarm;
	
	if (ejected_node_id == m_nidMyself)
	{
		/*
		**	If the ejected node is this node we can immediately initiate the
		**	ejection.  There is no need to request this through the Top
		**	Provider.
		*/
		rc = InitiateEjectionFromConference (reason);
	}
	else
	{
		/*
		**	If the ejected node is a child node to this node we can directly
		**	eject it.  Otherwise the request is forwarded to the Top Provider.
		*/
		if (m_ChildUidConnHdlList2.Find(ejected_node_id) ||
			(m_nidTopProvider == m_nidMyself))
		{
			gcc_pdu.choice = INDICATION_CHOSEN;
			gcc_pdu.u.indication.choice =
										CONFERENCE_EJECT_USER_INDICATION_CHOSEN;
			gcc_pdu.u.indication.u.conference_eject_user_indication.
												node_to_eject = ejected_node_id;
			gcc_pdu.u.indication.u.conference_eject_user_indication.reason =
							::TranslateGCCReasonToEjectInd(reason);

			uniform_send = TRUE;
			channel_id = BROADCAST_CHANNEL_ID;

			//	If this is the top provider send the data at TOP priority
			if (m_nidTopProvider == m_nidMyself)
				priority = TOP_PRIORITY;
			else
				priority = HIGH_PRIORITY;
			
			/*
			**	Set up ejection alarm to automatically eject any misbehaving
			**	nodes.  Note that we only do this if we are directly connected
			**	to the node to be ejected.
			*/
			if (m_ChildUidConnHdlList2.Find(ejected_node_id))
			{
				DBG_SAVE_FILE_LINE
				alarm = new Alarm (EJECTED_NODE_TIMER_DURATION);
				if (alarm != NULL)
				{
					/*
					**	Here we save the alarm in a list of ejected nodes. This
					**	alarm is used to cleanup any misbehaving node.
					*/
					m_EjectedNodeAlarmList2.Append(ejected_node_id, alarm);
				}
				else
                {
					rc = GCC_ALLOCATION_FAILURE;
                }
			}
		}
		else
		{
			gcc_pdu.choice = REQUEST_CHOSEN;
			gcc_pdu.u.request.choice = CONFERENCE_EJECT_USER_REQUEST_CHOSEN;
			gcc_pdu.u.request.u.conference_eject_user_request.node_to_eject =
																ejected_node_id;

			//	The only valid reason is user initiated which is zero
			gcc_pdu.u.request.u.conference_eject_user_request.reason =
	      											CERQ_REASON_USER_INITIATED;
		
			uniform_send = FALSE;
			channel_id = m_nidTopProvider;
			priority = TOP_PRIORITY;
		}
		
		if (rc == GCC_NO_ERROR)
		{
			DBG_SAVE_FILE_LINE
			packet = new Packet((PPacketCoder) g_GCCCoder,
								PACKED_ENCODING_RULES,
								&gcc_pdu,
								GCC_PDU,
								TRUE,
								&packet_error);
			if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
			{
				AddToMCSMessageQueue(packet, channel_id, priority, uniform_send);
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
				delete packet;
            }
		}
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return rc;
}

/*
 *	void	SendEjectNodeResponse()
 *
 *	Functional Description:
 *		This routine is used by the top provider to respond to an eject
 *		user request.
 */
GCCError	MCSUser::SendEjectNodeResponse (	UserID		requester_id,
												UserID		node_to_eject,
												GCCResult	result)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;

	gcc_pdu.choice = RESPONSE_CHOSEN;
	
	gcc_pdu.u.response.choice = CONFERENCE_EJECT_USER_RESPONSE_CHOSEN;
	
	gcc_pdu.u.response.u.conference_eject_user_response.node_to_eject =
															node_to_eject;
	
	gcc_pdu.u.response.u.conference_eject_user_response.result =
						::TranslateGCCResultToEjectResult(result);

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						&gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		AddToMCSMessageQueue(packet, requester_id, HIGH_PRIORITY, FALSE);
	}
	else
    {
        ResourceFailureHandler();
		rc = GCC_ALLOCATION_FAILURE;
		delete packet;
    }

	return rc;
}

/*
 *	void	RosterUpdateIndication()
 *
 *	Functional Description:
 *		This routine is used to forward a roster update indication either
 *		upward to the parent node or downward as a full refresh to all nodes
 *		in the conference.
 */
void	MCSUser::RosterUpdateIndication(PGCCPDU		gcc_pdu,
										BOOL		send_update_upward)
{
	PPacket					packet;
	PacketError				packet_error;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						gcc_pdu,
						GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		if (send_update_upward)
		{
			AddToMCSMessageQueue(packet, m_nidParent, HIGH_PRIORITY, FALSE);
		}
		else
		{
			AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);
		}
	}
	else
	{
        ResourceFailureHandler();
        delete packet;
	}
}

/*
 *	void	AddToMCSMessageQueue()
 *
 *	Private Function Description:
 * 		This function adds the out bound messages to a queue which is
 *		flushed in the next heartbeat when controller call FlushMessageQueue.
 *		In case memory allocation for messages holding the out bound inform-
 *		ation fails an owner call back is sent to conference object to
 *		indicate insufficient memory.
 *
 *	Formal Parameters:
 *		packet					-	(i)	Pointer to packet to queue up.
 *		send_data_request_info	-	(i)	Structure containing all the info
 *										necessary to deliver the packet.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */	
void MCSUser::
AddToMCSMessageQueue
(
	PPacket                 packet,
	ChannelID				channel_id,
	Priority				priority,
	BOOL    				uniform_send
)
{
	SEND_DATA_REQ_INFO *pReqInfo;

	DBG_SAVE_FILE_LINE
	pReqInfo = new SEND_DATA_REQ_INFO;
	if (pReqInfo != NULL)
	{
		pReqInfo->packet = packet;
		pReqInfo->channel_id = channel_id;
		pReqInfo->priority = priority;
		pReqInfo->uniform_send = uniform_send;

    	/*
    	**	This forces the packet to be encoded.  This must happen here so
    	**	that any memory used by the decoded portion of the packet can
    	**	be freed after returning.
    	*/
    	// packet->Lock();

    	m_OutgoingPDUQueue.Append(pReqInfo);

        if (m_OutgoingPDUQueue.GetCount() == 1)
        {
            if (FlushOutgoingPDU())
            {
        		//	Inform the MCS interface that there are PDUs queued
    			g_pGCCController->SetEventToFlushOutgoingPDU();
    		}
    	}
    	else
    	{
            //	Inform the MCS interface that there are PDUs queued
            g_pGCCController->SetEventToFlushOutgoingPDU();
    	}
	}
	else
    {
        ResourceFailureHandler();
        /*
		**	This just sets a flag in the packet object that allows packet
		**	to commit suicide if lock count on encoded and decoded data is
		**	zero. This will occur once the packet is sent on to MCS.
		*/
		packet->Unlock();
    }
}

/*
 *	BOOL FlushOutgoingPDU()
 *
 *	Public Function Description:
 * 		This function is called by the owner object in every heartbeat. This
 *		function iterates throught the list of pending out bound messages
 *		and sends them down to MCS. Also after a successful send it frees
 *		any resources tied up with the outbound messages. If however a message
 *		can not be sent in this heartbeat, as indicated by MCS, then it
 *		inserts the message back onto the message queue and returns.
 *
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the MCS message queue
 *		FALSE, if all the msgs in the MCS msg queue were processed.
 */	
void MCSUser::
CheckEjectedNodeAlarms ( void )
{
	/*
	**	We first check the eject user list to make sure that no alarms have
	**	expired on any of the ejected nodes.
	*/
	if (m_EjectedNodeAlarmList2.IsEmpty() == FALSE)
	{
		PAlarm				lpAlarm;
		UserID              uid;

		//	We copy the list so that we can remove entries in the iterator
		while (NULL != (lpAlarm = m_EjectedNodeAlarmList2.Get(&uid)))
		{
			//	Has the alarm expired for this node?
			if (lpAlarm->IsExpired())
			{
				ConnectionHandle hConn;

				/*
				**	Tell the owner object to disconnect the misbehaving node
				**	that exists at the connection handle accessed through
				**	the m_ChildUidConnHdlList2.
				*/
				if (NULL != (hConn = m_ChildUidConnHdlList2.Find(uid)))
				{
                    //
                    // This must generate a disconnect provider for eject node to
                    // work properly.
                    //
                    g_pMCSIntf->DisconnectProviderRequest(hConn);

                    //
                    // Since this node will not get a disconnect indication when it
                    // issues a DisconnectProviderRequest we go ahead and call it
                    // from here.
                    //
                    m_pConf->DisconnectProviderIndication(hConn);
				}
			}

    		//	Delete the alarm
			delete lpAlarm;
		}
	}
}

BOOL MCSUser::
FlushOutgoingPDU ( void )
{
	
	DWORD				mcs_message_count;
	DWORD				count;
	UINT				rc;
	SEND_DATA_REQ_INFO  *pReqInfo;

	mcs_message_count = m_OutgoingPDUQueue.GetCount();
	for (count = 0;
	     (count < mcs_message_count) && (m_OutgoingPDUQueue.IsEmpty() == FALSE);
	     count++)
	{
		/*
		**	Get the next message from the queue.
		*/
		pReqInfo = m_OutgoingPDUQueue.Get();

		/*
		 * If MCS takes the request without an error, free information
		 * structure and unlock the encoded information in the packet.
		 * Unlocking the packet before deleting the infomration	structure
		 * ensures that packet object is deleted and not left dangling.
		 * This is true because here only one lock is performed.
		 * If there is an error in the send data request, it means mcs can not
		 * take any more requests, therefore insert the information
		 * structure back in the queue and break out of this loop.
		 */
		if (pReqInfo->uniform_send)
		{
			rc = g_pMCSIntf->UniformSendDataRequest(
						pReqInfo->channel_id,
						m_pMCSSap,
						pReqInfo->priority,
						(LPBYTE) pReqInfo->packet->GetEncodedData(),
						pReqInfo->packet->GetEncodedDataLength());
		}
		else
		{
			rc = g_pMCSIntf->SendDataRequest(
						pReqInfo->channel_id,
						m_pMCSSap,
						pReqInfo->priority,
						(LPBYTE) pReqInfo->packet->GetEncodedData(),
						pReqInfo->packet->GetEncodedDataLength());
		}

		if (rc == MCS_NO_ERROR)
		{
			pReqInfo->packet->Unlock();
			delete pReqInfo;
		}
		else
		{
			TRACE_OUT(("MCSUser::FlushMessageQueue: Could not send queued packet data in this heartbeat"));
			m_OutgoingPDUQueue.Prepend(pReqInfo);
			break;	// breaking out of the for loop
		}
	}

	return (! (m_OutgoingPDUQueue.IsEmpty() && m_EjectedNodeAlarmList2.IsEmpty()));
}

/*
 *	MCSUser::SetChildUserID()
 *
 *	Public Function Description:
 * 		This function is called by the conference object to pass on the user id
 *		of the child node to the user object. The user object inserts this
 *		user id into a user id list of it's children which it maintains.
 */
void		MCSUser::SetChildUserIDAndConnection (
						UserID				child_user_id,
						ConnectionHandle	child_connection_handle)
{
	TRACE_OUT(("MCSUser::SetChildUserID: Adding Child userid=0x%04x to the list", (UINT) child_user_id));
	TRACE_OUT(("MCSUser::SetChildUserID: Adding Child Connection=%d to the list", (UINT) child_connection_handle));

	m_ChildUidConnHdlList2.Append(child_user_id, child_connection_handle);
}

/*
 *	GCCError	InitiateEjectionFromConference()
 *
 *	Private Function Description:
 *		This internal routine kicks of the process of ejecting this node
 *		from the conference.  This includes ejecting all the nodes below
 *		this node and waiting for their disconnect indications to come back
 *		in.
 *
 *	Formal Parameters:
 *		reason	-	(i)	Reason for ejection.
 *
 *	Return Value
 *		GCC_NO_ERROR		  	-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError	MCSUser::InitiateEjectionFromConference (GCCReason		reason)
{
	GCCError				error_value = GCC_NO_ERROR;
	GCCPDU					gcc_pdu;
	PPacket					packet;
	PacketError				packet_error;
	PAlarm					alarm = NULL;

	m_fEjectionPending = TRUE;
	m_eEjectReason = reason;

	if (m_ChildUidConnHdlList2.IsEmpty() == FALSE)
	{
	    UserID      uid;

		gcc_pdu.choice = INDICATION_CHOSEN;
		gcc_pdu.u.indication.choice = CONFERENCE_EJECT_USER_INDICATION_CHOSEN;
		
		gcc_pdu.u.indication.u.conference_eject_user_indication.reason =
				::TranslateGCCReasonToEjectInd(
					GCC_REASON_HIGHER_NODE_EJECTED);

		m_ChildUidConnHdlList2.Reset();
	 	while (m_ChildUidConnHdlList2.Iterate(&uid))
	 	{
			//	Get the Node to eject from the list of child nodes
			gcc_pdu.u.indication.u.conference_eject_user_indication.node_to_eject = uid;

			DBG_SAVE_FILE_LINE
			packet = new Packet((PPacketCoder) g_GCCCoder,
								PACKED_ENCODING_RULES,
								&gcc_pdu,
								GCC_PDU,
								TRUE,
								&packet_error);
			if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
			{
				AddToMCSMessageQueue(packet, BROADCAST_CHANNEL_ID, HIGH_PRIORITY, TRUE);

				DBG_SAVE_FILE_LINE
				alarm = new Alarm (EJECTED_NODE_TIMER_DURATION);
				if (alarm != NULL)
				{
					/*
					**	Here we save the alarm in a list of ejected
					**	nodes. This alarm is used to cleanup any
					**	misbehaving node.
					*/
					m_EjectedNodeAlarmList2.Append(uid, alarm);
				}
				else
				{
					error_value = GCC_ALLOCATION_FAILURE;
					break;
				}
			}
			else
			{
				error_value = GCC_ALLOCATION_FAILURE;
				delete packet;
				break;
			}
		}
	}
	else
	{
		m_pConf->ProcessEjectUserIndication(m_eEjectReason);
	}

	return (error_value);
}

/*
 *	UINT	ProcessSendDataIndication()
 *
 *	Private Function Description:
 * 		This function is called when the user object gets send data indications
 *		from below. It finds out the message type and decodes the pdu in the
 *		user data field of send data indications. Based on the type of decoded
 *		pdu it take the necessary actions.
 *
 *	Formal Parameters:
 *		send_data_info	-	(i)	Send data structure to process.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned from this routine.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT	MCSUser::ProcessSendDataIndication(PSendData send_data_info)
{
	PPacket					packet;
	PacketError				packet_error;
	PGCCPDU					gcc_pdu;
	GCCError				error_value = GCC_NO_ERROR;
	UserID					initiator;

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
			   			PACKED_ENCODING_RULES,
						(LPBYTE)send_data_info->user_data.value,
						send_data_info->user_data.length,
						GCC_PDU,
						TRUE,
						&packet_error);
	if(packet != NULL && packet_error == PACKET_NO_ERROR)
	{
		initiator = send_data_info->initiator;
		gcc_pdu = (PGCCPDU)packet->GetDecodedData();
		switch(gcc_pdu->choice)
		{
			case INDICATION_CHOSEN: // Data PDU
				switch(gcc_pdu->u.indication.choice)
				{
					case USER_ID_INDICATION_CHOSEN:
						{
							/*
							 * Sequence number and User Id sent by the child
							 * node after a successful conference create or
							 * join.
							 */
							m_pConf->ProcessUserIDIndication(
							        gcc_pdu->u.indication.u.user_id_indication.tag,
							        initiator);
						}
						break;

					case ROSTER_UPDATE_INDICATION_CHOSEN:
						if(send_data_info->channel_id == m_nidMyself)
						{
                            //
                            // We only process the roster update if the conference is
                            // established.
                            //
                            if (m_pConf->IsConfEstablished())
                            {
                                m_pConf->ProcessRosterUpdatePDU(gcc_pdu, initiator);
                            }
						}
    					break;

					case CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN:
                        g_pControlSap->ConfTimeInquireIndication(
                                m_pConf->GetConfID(),
                                gcc_pdu->u.indication.u.conference_time_inquire_indication.time_is_node_specific,
                                initiator);
						break;

					case CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN:
#ifdef JASPER
						ProcessConferenceExtendIndicationPDU(
									&gcc_pdu->u.indication.u.
										conference_time_extend_indication,
									initiator);
#endif // JASPER
						break;

					case APPLICATION_INVOKE_INDICATION_CHOSEN:
						ProcessApplicationInvokeIndication(
									&gcc_pdu->u.indication.u.
										application_invoke_indication,
									initiator);
						break;
							
					case TEXT_MESSAGE_INDICATION_CHOSEN:
#ifdef JASPER
						if (ProcessTextMessageIndication(
									&gcc_pdu->u.indication.u.
									text_message_indication,
									initiator) != GCC_NO_ERROR)
						{
							error_value = GCC_ALLOCATION_FAILURE;
						}
#endif // JASPER
						break;

					case CONFERENCE_LOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceLockIndication(initiator);
						break;

					case CONFERENCE_UNLOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceUnlockIndication(initiator);
    					break;

					default:
						ERROR_OUT(("User::ProcessSendDataIndication Unsupported PDU"));
    					break;
				} // switch(gcc_pdu->u.indication.choice)
                break;

			case REQUEST_CHOSEN:	// Connection(control) PDU
				switch(gcc_pdu->u.request.choice)
				{	
					case CONFERENCE_JOIN_REQUEST_CHOSEN:
						ProcessConferenceJoinRequestPDU(
								&gcc_pdu->u.request.u.conference_join_request,
								send_data_info);
						break;

					case CONFERENCE_TERMINATE_REQUEST_CHOSEN:
						ProcessConferenceTerminateRequestPDU(
								&gcc_pdu->u.request.u.
											conference_terminate_request,
								send_data_info);
						break;
						
					case CONFERENCE_EJECT_USER_REQUEST_CHOSEN:
						ProcessConferenceEjectUserRequestPDU(
								&gcc_pdu->u.request.u.
											conference_eject_user_request,
								send_data_info);
						break;

					case REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN:
						ProcessRegistryAllocateHandleRequestPDU(	
								&gcc_pdu->u.request.u.
										registry_allocate_handle_request,
								send_data_info);
						break;

					case CONFERENCE_LOCK_REQUEST_CHOSEN:
						m_pConf->ProcessConferenceLockRequest(initiator);
						break;

					case CONFERENCE_UNLOCK_REQUEST_CHOSEN:
						m_pConf->ProcessConferenceUnlockRequest(initiator);
						break;

					case CONFERENCE_TRANSFER_REQUEST_CHOSEN:
						ProcessTransferRequestPDU(
								&gcc_pdu->u.request.u.conference_transfer_request,
								send_data_info);
						break;

					case CONFERENCE_ADD_REQUEST_CHOSEN:
						ProcessAddRequestPDU (
								&gcc_pdu->u.request.u.conference_add_request,
								send_data_info);
						break;

					case REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN:
					case REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN:
					case REGISTRY_SET_PARAMETER_REQUEST_CHOSEN:
					case REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN:
					case REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN:
					case REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN:
						ProcessRegistryRequestPDU(	gcc_pdu,
														send_data_info);
						break;
	
					default:
							ERROR_OUT(("User::ProcessSendDataIndication this pdu choice is not supported"));
						break;
				} // switch(gcc_pdu->u.request.choice)
				break;

			case RESPONSE_CHOSEN:	// Connection(control) PDU
				switch(gcc_pdu->u.response.choice)
				{	
					case CONFERENCE_JOIN_RESPONSE_CHOSEN:
						/* This comes from top provider to the intermediate
						 * gcc provider which has to pass it on to the node
						 * that made a join request.
				    	 */	
						ProcessConferenceJoinResponsePDU(
								&gcc_pdu->u.response.u.
											conference_join_response);
						break;

					case CONFERENCE_TERMINATE_RESPONSE_CHOSEN:
						ProcessConferenceTerminateResponsePDU(
								&gcc_pdu->u.response.u.
											conference_terminate_response);
						break;

					case CONFERENCE_EJECT_USER_RESPONSE_CHOSEN:
						ProcessConferenceEjectUserResponsePDU(
								&gcc_pdu->u.response.u.
											conference_eject_user_response);
						break;

					case REGISTRY_RESPONSE_CHOSEN:
						ProcessRegistryResponsePDU(
								&gcc_pdu->u.response.u.registry_response);
						break;

					case REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN:
						ProcessRegistryAllocateHandleResponsePDU(
								&gcc_pdu->u.response.u.
									registry_allocate_handle_response);
						break;

					case CONFERENCE_LOCK_RESPONSE_CHOSEN:
#ifdef JASPER
						{
							GCCResult               result;
                            result = ::TranslateLockResultToGCCResult(gcc_pdu->u.response.u.conference_lock_response.result);
                    		g_pControlSap->ConfLockConfirm(result, m_pConf->GetConfID());
						}
#endif // JASPER
						break;

					case CONFERENCE_UNLOCK_RESPONSE_CHOSEN:
#ifdef JASPER
						{
							GCCResult               result;
                            result = ::TranslateUnlockResultToGCCResult(gcc_pdu->u.response.u.conference_unlock_response.result);
                    		g_pControlSap->ConfUnlockConfirm(result, m_pConf->GetConfID());
						}
#endif // JASPER
						break;

					case CONFERENCE_TRANSFER_RESPONSE_CHOSEN:
#ifdef JASPER
						ProcessTransferResponsePDU(
								&gcc_pdu->u.response.u.conference_transfer_response);
#endif // JASPER
						break;

					case CONFERENCE_ADD_RESPONSE_CHOSEN:
						ProcessAddResponsePDU(
								&gcc_pdu->u.response.u.conference_add_response);
						break;

					case FUNCTION_NOT_SUPPORTED_RESPONSE_CHOSEN:
						ProcessFunctionNotSupported (
								(UINT) gcc_pdu->u.response.u.function_not_supported_response.request.choice);
						break;

					// other cases to be added as we go along.
					default:
						ERROR_OUT(("User::ProcessSendDataIndication this pdu choice is not supported"));
						break;
				} // switch(gcc_pdu->u.response.choice)
				break;

			default:
				ERROR_OUT(("User::ProcessSendDataIndication this pdu type"));
				break;
		} // switch(gcc_pdu->choice)
		packet->Unlock();
	}
	else
	{
		delete packet;
		error_value = GCC_ALLOCATION_FAILURE;
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return(MCS_NO_ERROR);
}

/*
 *	void	ProcessConferenceJoinRequestPDU ()
 *
 *	Private Function Description:
 *		This PDU comes from below (intermediate directly connected node) to the
 *		top gcc provider. Pull out the tag number and user id from the
 *		pdu and store in a list.
 *
 *	Formal Parameters:
 *		join_request	-	(i)	Join request PDU structure to process.
 *		send_data_info	-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceJoinRequestPDU(
								PConferenceJoinRequest	join_request,
								PSendData				send_data_info)
{
	GCCError				rc = GCC_NO_ERROR;
	UserJoinRequestInfo		join_request_info;
	
	/*
	**	Build all the containers to be used in the join request info structure.
	*/
	
	//	Build the convener password container
	if ((join_request->bit_mask & CJRQ_CONVENER_PASSWORD_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_request_info.convener_password = new CPassword(
										&join_request->cjrq_convener_password,
										&rc);
												
		if (join_request_info.convener_password == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		join_request_info.convener_password = NULL;
    }

	//	Build the password challenge container
	if ((join_request->bit_mask & CJRQ_PASSWORD_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_request_info.password_challenge = new CPassword(
												&join_request->cjrq_password,
												&rc);
												
		if (join_request_info.password_challenge == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		join_request_info.password_challenge = NULL;
    }
		
	//	Build the caller identifier container
	if ((join_request->bit_mask & CJRQ_CALLER_ID_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		if (NULL == (join_request_info.pwszCallerID = ::My_strdupW2(
										join_request->cjrq_caller_id.length,
										join_request->cjrq_caller_id.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
    {
		join_request_info.pwszCallerID = NULL;
    }
	
	//	Build the password challenge container
	if ((join_request->bit_mask & CJRQ_USER_DATA_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_request_info.user_data_list = new CUserDataListContainer(join_request->cjrq_user_data, &rc);
		if (join_request_info.user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		join_request_info.user_data_list = NULL;
    }

	if (rc == GCC_NO_ERROR)
	{
		m_ConfJoinResponseList2.Append(send_data_info->initiator, join_request->tag);

		join_request_info.sender_id = send_data_info->initiator;

		g_pControlSap->ForwardedConfJoinIndication(
							join_request_info.sender_id,
							m_pConf->GetConfID(),
							join_request_info.convener_password,
							join_request_info.password_challenge,
							join_request_info.pwszCallerID,
							join_request_info.user_data_list);
	}

	//	Free up the containers allocated above
	if (join_request_info.convener_password != NULL)
	{
		join_request_info.convener_password->Release();
	}

	if (join_request_info.password_challenge != NULL)
	{
		join_request_info.password_challenge->Release();
	}

	delete join_request_info.pwszCallerID;

	if (join_request_info.user_data_list != NULL)
	{
		join_request_info.user_data_list->Release();
	}

	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	ProcessConferenceJoinResponsePDU ()
 *
 *	Private Function Description:
 *		This comes from top provider to the intermediate gcc provider which has
 *		to pass it on to the node that made a join request.
 *
 *	Formal Parameters:
 *		join_response	-	(i)	Join response PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceJoinResponsePDU(
								PConferenceJoinResponse		join_response)
{
	GCCError				rc = GCC_NO_ERROR;
	UserJoinResponseInfo	join_response_info;

	//	Store the password data in the join response info structure
	if ((join_response->bit_mask & CJRS_PASSWORD_PRESENT) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		join_response_info.password_challenge = new CPassword(
												&join_response->cjrs_password,
												&rc);
		if (join_response_info.password_challenge == NULL)
        {
			rc = GCC_NO_ERROR;
        }
	}
	else
    {
		join_response_info.password_challenge = NULL;
    }

	//	Store the user data in the join response info structure	
	if ((join_response->bit_mask & CJRS_USER_DATA_PRESENT) &&
	   	(rc == GCC_NO_ERROR))	
	{
		DBG_SAVE_FILE_LINE
		join_response_info.user_data_list = new CUserDataListContainer(join_response->cjrs_user_data, &rc);		
		if (join_response_info.user_data_list == NULL)
        {
			rc = GCC_NO_ERROR;
        }
	}
	else
    {
		join_response_info.user_data_list = NULL;
    }

	if (rc == GCC_NO_ERROR)
	{
		join_response_info.connection_handle = (ConnectionHandle)join_response->tag;
		join_response_info.result = ::TranslateJoinResultToGCCResult(join_response->result);

		m_pConf->ProcessConfJoinResponse(&join_response_info);
	}

	//	Free up the containers allocated above
	if (join_response_info.password_challenge != NULL)
		join_response_info.password_challenge->Release();

	if (join_response_info.user_data_list != NULL)
		join_response_info.user_data_list->Release();

	//	Cleanup after any allocation failures.
	if (rc == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}
}

/*
 *	void	ProcessConferenceTerminateRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Terminate Request PDU.
 *
 *	Formal Parameters:
 *		terminate_request	-	(i)	Terminate request PDU structure to process.
 *		send_data_info		-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessConferenceTerminateRequestPDU
(
    PConferenceTerminateRequest     terminate_request,
    PSendData                       send_data_info
)
{
    m_pConf->ProcessTerminateRequest(
                send_data_info->initiator,
                ::TranslateTerminateRqReasonToGCCReason(terminate_request->reason));
}

/*
 *	void	ProcessConferenceEjectUserRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		eject user request PDU.
 *
 *	Formal Parameters:
 *		eject_user_request	-	(i)	Eject user request PDU structure to process.
 *		send_data_info		-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceEjectUserRequestPDU(
							PConferenceEjectUserRequest	eject_user_request,
							PSendData					send_data_info)
{
	UserEjectNodeRequestInfo	eject_node_request;

	eject_node_request.requester_id = send_data_info->initiator;
	eject_node_request.node_to_eject = eject_user_request->node_to_eject;
	eject_node_request.reason = GCC_REASON_NODE_EJECTED;

	m_pConf->ProcessEjectUserRequest(&eject_node_request);
}

/*
 *	void	ProcessConferenceTerminateResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		terminate response PDU.
 *
 *	Formal Parameters:
 *		terminate_response	-	(i)	Terminate response PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceTerminateResponsePDU(
							PConferenceTerminateResponse	terminate_response)
{
    GCCResult               result = ::TranslateTerminateResultToGCCResult(terminate_response->result);

	//
	// If the terminate was successful, go ahead and set the
	// conference to not established.
	//
	if (result == GCC_RESULT_SUCCESSFUL)
	{
		m_pConf->ConfIsOver();
	}

	g_pControlSap->ConfTerminateConfirm(m_pConf->GetConfID(), result);
}


/*
 *	void	ProcessConferenceEjectUserResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Eject User response PDU.
 *
 *	Formal Parameters:
 *		eject_user_response	-	(i)	Eject user response PDU structure to
 *									process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceEjectUserResponsePDU(
							PConferenceEjectUserResponse	eject_user_response)
{
	UserEjectNodeResponseInfo	eject_node_response;

	eject_node_response.node_to_eject = eject_user_response->node_to_eject;

	eject_node_response.result = ::TranslateEjectResultToGCCResult(
													eject_user_response->result);

	m_pConf->ProcessEjectUserResponse(&eject_node_response);
}

/*
 *	void	ProcessRegistryRequest()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Registry
 *		request PDU.
 *
 *	Formal Parameters:
 *		gcc_pdu			-	(i)	This is the PDU structure to process.
 *		send_data_info	-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryRequestPDU
(
    PGCCPDU             gcc_pdu,
    PSendData           send_data_info
)
{
    CRegistry   *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        GCCError            rc = GCC_ALLOCATION_FAILURE;
        CRegKeyContainer    *pRegKey = NULL;

        switch (gcc_pdu->u.request.choice)
        {
        case REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_register_channel_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessRegisterChannelPDU(
                            pRegKey,
                            gcc_pdu->u.request.u.registry_register_channel_request.channel_id,
                            send_data_info->initiator, // Requester node id
                            gcc_pdu->u.request.u.registry_register_channel_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_assign_token_request.registry_key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessAssignTokenPDU(
                            pRegKey,
                            send_data_info->initiator, // Requester node id
                            gcc_pdu->u.request.u.registry_assign_token_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_SET_PARAMETER_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_set_parameter_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                OSTR                    oszParamValue;
                LPOSTR                  poszParamValue;
                GCCModificationRights   eRights;

                if (gcc_pdu->u.request.u.registry_set_parameter_request.
                                registry_set_parameter.length != 0)
                {
                    poszParamValue = &oszParamValue;
                    oszParamValue.length = gcc_pdu->u.request.u.registry_set_parameter_request.
                                                    registry_set_parameter.length;
                    oszParamValue.value = gcc_pdu->u.request.u.registry_set_parameter_request.
                                                    registry_set_parameter.value;
                }
                else
                {
                    poszParamValue = NULL;
                }

                if (gcc_pdu->u.request.u.registry_set_parameter_request.
                                bit_mask & PARAMETER_MODIFY_RIGHTS_PRESENT)
                {
                    eRights = (GCCModificationRights)gcc_pdu->u.request.u.
                                    registry_set_parameter_request.parameter_modify_rights;
                }
                else
                {
                    eRights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;
                }

                pAppReg->ProcessSetParameterPDU(
                            pRegKey,
                            poszParamValue,
                            eRights,
                            send_data_info->initiator, // Requester node id
                            gcc_pdu->u.request.u.registry_set_parameter_request.entity_id);

            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_retrieve_entry_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessRetrieveEntryPDU(
                                pRegKey,
                                send_data_info->initiator, // Requester node id
                                gcc_pdu->u.request.u.registry_retrieve_entry_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_delete_entry_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessDeleteEntryPDU (
                                pRegKey,
                                send_data_info->initiator, // Requester node id
                                gcc_pdu->u.request.u.registry_delete_entry_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;

        case REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN:
            DBG_SAVE_FILE_LINE
            pRegKey = new CRegKeyContainer(
                            &gcc_pdu->u.request.u.registry_monitor_entry_request.key,
                            &rc);
            if ((pRegKey != NULL) && (rc == GCC_NO_ERROR))
            {
                pAppReg->ProcessMonitorEntryPDU(
                                pRegKey,
                                send_data_info->initiator, // Requester node id
                                gcc_pdu->u.request.u.registry_monitor_entry_request.entity_id);
            }
            else
            {
                // rc = GCC_ALLOCATION_FAILURE;
            }
            break;
        }

        if (NULL != pRegKey)
        {
            pRegKey->Release();
        }

        //	Handle resource errors
        if (rc == GCC_ALLOCATION_FAILURE)
        {
            ResourceFailureHandler();
        }
    } // if pAppReg != NULL
}

/*
 *	void	ProcessRegistryAllocateHandleRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Allocate
 *		Handle request PDU.
 *
 *	Formal Parameters:
 *		allocate_handle_request	-	(i)	This is the PDU structure to process.
 *		send_data_info			-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryAllocateHandleRequestPDU
(
    PRegistryAllocateHandleRequest	allocate_handle_request,
    PSendData						send_data_info
)
{
    CRegistry *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        pAppReg->ProcessAllocateHandleRequestPDU(
                        allocate_handle_request->number_of_handles,
                        allocate_handle_request->entity_id,
                        send_data_info->initiator);
    }
}

/*
 *	void	ProcessRegistryResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Registry
 *		Response PDU.
 *
 *	Formal Parameters:
 *		registry_response	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryResponsePDU ( PRegistryResponse registry_response )
{
    CRegistry   *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        GCCError                    rc;
        UserRegistryResponseInfo    urri;

        ::ZeroMemory(&urri, sizeof(urri));
        // urri.registry_key = NULL;
        // urri.registry_item = NULL;

        DBG_SAVE_FILE_LINE
        urri.registry_key = new CRegKeyContainer(&registry_response->key, &rc);
        if ((urri.registry_key != NULL) && (rc == GCC_NO_ERROR))
        {
            DBG_SAVE_FILE_LINE
            urri.registry_item = new CRegItem(&registry_response->item, &rc);
            if ((urri.registry_item != NULL) && (rc == GCC_NO_ERROR))
            {
                //	Set up the original requester entity id
                urri.requester_entity_id = registry_response->entity_id;

                //	Set up the primitive type being responded to
                urri.primitive_type = registry_response->primitive_type;

                //	Set up the owner related variables	
                if (registry_response->owner.choice == OWNED_CHOSEN)
                {
                    urri.owner_node_id = registry_response->owner.u.owned.node_id;
                    urri.owner_entity_id = registry_response->owner.u.owned.entity_id;
                }
                else
                {
                    // urri.owner_node_id = 0;
                    // urri.owner_entity_id = 0;
                }

                //	Set up the modification rights
                if (registry_response->bit_mask & RESPONSE_MODIFY_RIGHTS_PRESENT)
                {
                    urri.modification_rights = (GCCModificationRights)registry_response->response_modify_rights;
                }
                else
                {
                    urri.modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;
                }

                //	Translate the result to a GCC result
                urri.result = ::TranslateRegistryRespToGCCResult(registry_response->result);

                pAppReg->ProcessRegistryResponsePDU(
                                urri.primitive_type,
                                urri.registry_key,
                                urri.registry_item,
                                urri.modification_rights,
                                urri.requester_entity_id,
                                urri.owner_node_id,
                                urri.owner_entity_id,
                                urri.result);
            }
            else
            {
                rc = GCC_ALLOCATION_FAILURE;
            }
        }
        else
        {
            rc = GCC_ALLOCATION_FAILURE;
        }

        if (NULL != urri.registry_key)
        {
            urri.registry_key->Release();
        }
        if (NULL != urri.registry_item)
        {
            urri.registry_item->Release();
        }

        //	Handle any resource errors	
        if (rc == GCC_ALLOCATION_FAILURE)
        {
            ResourceFailureHandler();
        }
    } // if pAppReg != NULL
}

/*
 *	void	ProcessAllocateHandleResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Allocate
 *		Handle Response PDU.
 *
 *	Formal Parameters:
 *		allocate_handle_response-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryAllocateHandleResponsePDU
(
    PRegistryAllocateHandleResponse     allocate_handle_response
)
{
    CRegistry   *pAppReg = m_pConf->GetRegistry();

    if (NULL != pAppReg)
    {
        pAppReg->ProcessAllocateHandleResponsePDU(
                    allocate_handle_response->number_of_handles,
                    allocate_handle_response->first_handle,
                    allocate_handle_response->entity_id,
                    (allocate_handle_response->result == RARS_RESULT_SUCCESS) ?
                        GCC_RESULT_SUCCESSFUL :
                        GCC_RESULT_NO_HANDLES_AVAILABLE);
    }
}

/*
 *	void	ProcessTransferRequestPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Transfer
 *		request PDU.
 *
 *	Formal Parameters:
 *		transfer_request	-	(i)	This is the PDU structure to process.
 *		send_data_info		-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessTransferRequestPDU
(
    PConferenceTransferRequest      transfer_request,
    PSendData                       send_data_info
)
{
	GCCError					rc = GCC_NO_ERROR;
	TransferInfo				transfer_info;
	PSetOfTransferringNodesRq	set_of_nodes;
	LPBYTE						sub_node_list_memory = NULL;
	Int							i;

	//	Make sure that this node is the top provider
	if (GetMyNodeID() != GetTopNodeID())
		return;

    ::ZeroMemory(&transfer_info, sizeof(transfer_info));

	//	First set up the conference name
	if (transfer_request->conference_name.choice ==
												NAME_SELECTOR_NUMERIC_CHOSEN)
	{
		transfer_info.destination_conference_name.numeric_string =
			(LPSTR) transfer_request->conference_name.u.name_selector_numeric;
		// transfer_info.destination_conference_name.text_string = NULL;
	}
	else
	{
		// transfer_info.destination_conference_name.numeric_string = NULL;
		if (NULL == (transfer_info.destination_conference_name.text_string = ::My_strdupW2(
							transfer_request->conference_name.u.name_selector_text.length,
							transfer_request->conference_name.u.name_selector_text.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	

	//	Next set up the conference name modifier
	if (transfer_request->bit_mask & CTRQ_CONFERENCE_MODIFIER_PRESENT)
	{
		transfer_info.destination_conference_modifier =
						(LPSTR) transfer_request->ctrq_conference_modifier;
	}
	else
    {
		// transfer_info.destination_conference_modifier = NULL;
    }
	
	//	Next set up the network address
	if (transfer_request->bit_mask & CTRQ_NETWORK_ADDRESS_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.destination_address_list = new CNetAddrListContainer(
								transfer_request->ctrq_net_address,
								&rc);
		if (transfer_info.destination_address_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		// transfer_info.destination_address_list = NULL;
    }
	

	//	Set up the transferring nodes list
	if (transfer_request->bit_mask & CTRQ_TRANSFERRING_NODES_PRESENT)
	{
		//	First determine the number of nodes.
		set_of_nodes = transfer_request->ctrq_transferring_nodes;
		// transfer_info.number_of_destination_nodes = 0;
		while (set_of_nodes != NULL)
		{
			transfer_info.number_of_destination_nodes++;
			set_of_nodes = set_of_nodes->next;		
		}

		//	Next allocate the memory required to hold the sub nodes
		DBG_SAVE_FILE_LINE
		sub_node_list_memory = new BYTE[sizeof(UserID) * transfer_info.number_of_destination_nodes];

		//	Now fill in the permission list
		if (sub_node_list_memory != NULL)
		{
			transfer_info.destination_node_list = (PUserID) sub_node_list_memory;

			set_of_nodes = transfer_request->ctrq_transferring_nodes;
			for (i = 0; i < transfer_info.number_of_destination_nodes; i++)
			{
				transfer_info.destination_node_list[i] = set_of_nodes->value;
				set_of_nodes = set_of_nodes->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessTransferRequestPDU: Memory Manager Alloc Failure"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.number_of_destination_nodes = 0;
		// transfer_info.destination_node_list = NULL;
	}

	//	Set up the password
	if (transfer_request->bit_mask & CTRQ_PASSWORD_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.password = new CPassword(&transfer_request->ctrq_password, &rc);
		if (transfer_info.password == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.password = NULL;
	}

	//	Save the sender ID	
	transfer_info.requesting_node_id = send_data_info->initiator;

	if (rc == GCC_NO_ERROR)
	{
		m_pConf->ProcessConferenceTransferRequest(
						transfer_info.requesting_node_id,
						&transfer_info.destination_conference_name,
						transfer_info.destination_conference_modifier,
						transfer_info.destination_address_list,
						transfer_info.number_of_destination_nodes,
						transfer_info.destination_node_list,
						transfer_info.password);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessTransferRequestPDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	//	Now cleanup any allocated memory
	if (transfer_info.destination_address_list != NULL)
	{
		transfer_info.destination_address_list->Release();
	}

	delete sub_node_list_memory;

	if (transfer_info.password != NULL)
	{
		transfer_info.password->Release();
	}
}

/*
 *	void	ProcessAddRequestPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference Add
 *		request PDU.
 *
 *	Formal Parameters:
 *		conference_add_request	-	(i)	This is the PDU structure to process.
 *		send_data_info			-	(i)	Send data structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessAddRequestPDU (
								PConferenceAddRequest	conference_add_request,
								PSendData				send_data_info)
{
	GCCError			rc = GCC_NO_ERROR;
	AddRequestInfo		add_request_info;

	/*
	**	Ignore this request if this node is NOT the Top Provider and the request
	**	did not come from the Top Provider.
	*/
	if (m_nidTopProvider != m_nidMyself)
	{
		if (m_nidTopProvider != send_data_info->initiator)
			return;	
	}

    ::ZeroMemory(&add_request_info, sizeof(add_request_info));

	DBG_SAVE_FILE_LINE
	add_request_info.network_address_list = new CNetAddrListContainer(
								conference_add_request->add_request_net_address,
								&rc);
	if (add_request_info.network_address_list == NULL)
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	if ((rc == GCC_NO_ERROR) &&
		(conference_add_request->bit_mask & CARQ_USER_DATA_PRESENT))
	{
		DBG_SAVE_FILE_LINE
		add_request_info.user_data_list = new CUserDataListContainer(conference_add_request->carq_user_data, &rc);
		if (add_request_info.user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		// add_request_info.user_data_list = NULL;
    }

	if (rc == GCC_NO_ERROR)
	{
		add_request_info.adding_node = (conference_add_request->bit_mask & ADDING_MCU_PRESENT) ?
                                            conference_add_request->adding_mcu : 0;
		add_request_info.requesting_node = conference_add_request->requesting_node;
		add_request_info.add_request_tag = (TagNumber)conference_add_request->tag;

		m_pConf->ProcessConferenceAddRequest(
    					add_request_info.network_address_list,
    					add_request_info.user_data_list,
    					add_request_info.adding_node,
    					add_request_info.add_request_tag,
    					add_request_info.requesting_node);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessAddRequestPDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	if (add_request_info.network_address_list != NULL)
	{
		add_request_info.network_address_list->Release();
	}

	if (add_request_info.user_data_list != NULL)
	{
		add_request_info.user_data_list->Release();
	}
}

/*
 *	void	ProcessTransferResponsePDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Transfer response PDU.
 *
 *	Formal Parameters:
 *		transfer_response	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void	MCSUser::ProcessTransferResponsePDU (
								PConferenceTransferResponse	transfer_response)
{
	GCCError					rc = GCC_NO_ERROR;
	TransferInfo				transfer_info;
	PSetOfTransferringNodesRs	set_of_nodes;
	LPBYTE						sub_node_list_memory = NULL;
	Int							i;

    ::ZeroMemory(&transfer_info, sizeof(transfer_info));

	//	First set up the conference name
	if (transfer_response->conference_name.choice ==
												NAME_SELECTOR_NUMERIC_CHOSEN)
	{
		transfer_info.destination_conference_name.numeric_string =
			(LPSTR) transfer_response->conference_name.u.name_selector_numeric;
		// transfer_info.destination_conference_name.text_string = NULL;
	}
	else
	{
		// transfer_info.destination_conference_name.numeric_string = NULL;
		if (NULL == (transfer_info.destination_conference_name.text_string = ::My_strdupW2(
							transfer_response->conference_name.u.name_selector_text.length,
							transfer_response->conference_name.u.name_selector_text.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Next set up the conference name modifier
	if (transfer_response->bit_mask & CTRS_CONFERENCE_MODIFIER_PRESENT)
	{
		transfer_info.destination_conference_modifier =
						(LPSTR) transfer_response->ctrs_conference_modifier;
	}
	else
	{
		// transfer_info.destination_conference_modifier = NULL;
	}

	//	Set up the transferring nodes list
	if (transfer_response->bit_mask & CTRS_TRANSFERRING_NODES_PRESENT)
	{
		//	First determine the number of nodes.
		set_of_nodes = transfer_response->ctrs_transferring_nodes;
		// transfer_info.number_of_destination_nodes = 0;
		while (set_of_nodes != NULL)
		{
			transfer_info.number_of_destination_nodes++;
			set_of_nodes = set_of_nodes->next;		
		}

		//	Next allocate the memory required to hold the sub nodes
		DBG_SAVE_FILE_LINE
		sub_node_list_memory = new BYTE[sizeof(UserID) * transfer_info.number_of_destination_nodes];

		//	Now fill in the permission list
		if (sub_node_list_memory != NULL)
		{
			transfer_info.destination_node_list = (PUserID) sub_node_list_memory;

			set_of_nodes = transfer_response->ctrs_transferring_nodes;
			for (i = 0; i < transfer_info.number_of_destination_nodes; i++)
			{
				transfer_info.destination_node_list[i] = set_of_nodes->value;
				set_of_nodes = set_of_nodes->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessTransferResponsePDU: Memory Manager Alloc Failure"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.number_of_destination_nodes = 0;
		// transfer_info.destination_node_list = NULL;
	}
	

	//	Save the result	
	transfer_info.result = (transfer_response->result == CTRANS_RESULT_SUCCESS) ?
                            GCC_RESULT_SUCCESSFUL :
                            GCC_RESULT_INVALID_REQUESTER;

	if (rc == GCC_NO_ERROR)
	{
		g_pControlSap->ConfTransferConfirm(
    							m_pConf->GetConfID(),
    							&transfer_info.destination_conference_name,
    							transfer_info.destination_conference_modifier,
    							transfer_info.number_of_destination_nodes,
    							transfer_info.destination_node_list,
    							transfer_info.result);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessTransferResponsePDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	//	Now cleanup any allocated memory
	delete sub_node_list_memory;
}
#endif // JASPER


/*
 *	void	ProcessAddResponsePDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Add response PDU.
 *
 *	Formal Parameters:
 *		conference_add_response	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessAddResponsePDU (
						PConferenceAddResponse		conference_add_response)
{
	GCCError				error_value = GCC_NO_ERROR;
	AddResponseInfo			add_response_info;

	if (conference_add_response->bit_mask &	CARS_USER_DATA_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		add_response_info.user_data_list = new CUserDataListContainer(conference_add_response->cars_user_data, &error_value);
		if (add_response_info.user_data_list == NULL)
        {
			error_value = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		add_response_info.user_data_list = NULL;
    }
	
	if (error_value == GCC_NO_ERROR)
	{
		add_response_info.add_request_tag = (TagNumber)conference_add_response->tag;
		add_response_info.result = ::TranslateAddResultToGCCResult(conference_add_response->result);

        m_pConf->ProcessConfAddResponse(&add_response_info);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessAddResponsePDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == error_value)
		{
            ResourceFailureHandler();
        }
	}

	if (add_response_info.user_data_list != NULL)
	{
		add_response_info.user_data_list->Release();
	}
}

/*
 *	void	ProcessFunctionNotSupported ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing responses for request that
 *		are not supported at the node that the request was directed toward.
 *
 *	Formal Parameters:
 *		request_choice	-	(i)	This is the request that is not supported.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The existance of this routine does not mean that this provider does
 *		not support it.  It only means that the node which received the
 *		request does not support it.
 */
void MCSUser::
ProcessFunctionNotSupported ( UINT request_choice )
{
	switch (request_choice)
	{
	case CONFERENCE_LOCK_REQUEST_CHOSEN:
#ifdef JASPER
		g_pControlSap->ConfLockConfirm(GCC_RESULT_LOCKED_NOT_SUPPORTED, m_pConf->GetConfID());
#endif // JASPER
		break;

	case CONFERENCE_UNLOCK_REQUEST_CHOSEN:
#ifdef JASPER
		g_pControlSap->ConfUnlockConfirm(GCC_RESULT_UNLOCK_NOT_SUPPORTED, m_pConf->GetConfID());
#endif // JASPER
		break;

	default:
		ERROR_OUT(("MCSUser: ProcessFunctionNotSupported: "
					"Error: Illegal request is unsupported"));
		break;
	}
}

/*
 *	UINT	ProcessUniformSendDataIndication ()
 *
 *	Private Function Description:
 * 		This function is called when the user object gets send data indications
 *		from below. It finds out the message type and decodes the pdu in the
 *		user data field of send data indications. Based on the type of decoded
 *		pdu it take the necessary actions.
 *		This routine is responsible for processing responses for request that
 *		are not supported at the node that the request was directed toward.
 *
 *	Formal Parameters:
 *		send_data_info	-	(i)	This is the MCS data structure to process.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT	MCSUser::ProcessUniformSendDataIndication(	
						PSendData		send_data_info)
{
	PPacket					packet;
	PacketError				packet_error;
	PGCCPDU					gcc_pdu;
	GCCError				error_value = GCC_NO_ERROR;
	UserID					initiator;
	
	TRACE_OUT(("User: UniformSendDataInd: length = %d",
				send_data_info->user_data.length));

	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
						PACKED_ENCODING_RULES,
						(LPBYTE)send_data_info->user_data.value,
						send_data_info->user_data.length,
						GCC_PDU,
						TRUE,
						&packet_error);
	if((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		initiator = send_data_info->initiator;
		gcc_pdu = (PGCCPDU)packet->GetDecodedData();
		switch (gcc_pdu->choice)
		{
			case INDICATION_CHOSEN: // Data PDU
				switch(gcc_pdu->u.indication.choice)
				{
					case CONFERENCE_TERMINATE_INDICATION_CHOSEN:
						/*
						**	Note that we allow the top provider to process
						**	this message so that it can set up its own
						**	node for termination in a generic way.
						*/
						ProcessConferenceTerminateIndicationPDU (
									&gcc_pdu->u.indication.u.
										conference_terminate_indication,
									initiator);
    					break;

					case CONFERENCE_EJECT_USER_INDICATION_CHOSEN:
						/*
						**	Do not decode a packet that was sent uniformly
						**	from this node.
						*/
						if (initiator != m_nidMyself)
						{
							ProcessConferenceEjectUserIndicationPDU (
									&gcc_pdu->u.indication.u.
										conference_eject_user_indication,
									initiator);
						}
						break;

					case ROSTER_UPDATE_INDICATION_CHOSEN:
						/*
						**	Do not decode a packet that was sent uniformly
						**	from this node.
						*/
						if ((initiator != m_nidMyself) &&
							(send_data_info->channel_id ==
													BROADCAST_CHANNEL_ID))
						{
                            //
                            // We only process the roster update if the conference is
                            // established.
                            //
                            if (m_pConf->IsConfEstablished())
                            {
                                m_pConf->ProcessRosterUpdatePDU(gcc_pdu, initiator);
                            }
						}
						break;

					case CONFERENCE_LOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceLockIndication(initiator);
						break;

					case CONFERENCE_UNLOCK_INDICATION_CHOSEN:
						m_pConf->ProcessConferenceUnlockIndication(initiator);
						break;

					case CONDUCTOR_ASSIGN_INDICATION_CHOSEN:
                        m_pConf->ProcessConductorAssignIndication(
                                    gcc_pdu->u.indication.u.conductor_assign_indication.user_id,
                                    initiator);
                        break;

					case CONDUCTOR_RELEASE_INDICATION_CHOSEN:
						if (initiator != m_nidMyself)
						{
							m_pConf->ProcessConductorReleaseIndication(initiator);
						}
						break;

					case CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN:
#ifdef JASPER
						/*
						**	Do not decode a packet that was sent uniformly
						**	from this node.
						*/
						if (initiator != m_nidMyself)
						{
							PermitAskIndicationInfo		indication_info;

							indication_info.sender_id = initiator;
							
							indication_info.permission_is_granted =
										gcc_pdu->u.indication.u.
											conductor_permission_ask_indication.
												permission_is_granted;

							m_pConf->ProcessConductorPermitAskIndication(&indication_info);
						}
#endif // JASPER
						break;

					case CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN:
						ProcessPermissionGrantIndication(
									&(gcc_pdu->u.indication.u.
										conductor_permission_grant_indication),
									initiator);
						break;

					case CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN:
#ifdef JASPER
						ProcessTimeRemainingIndicationPDU (
									&gcc_pdu->u.indication.u.
										conference_time_remaining_indication,
									initiator);
#endif // JASPER
						break;
						
					case APPLICATION_INVOKE_INDICATION_CHOSEN:
						ProcessApplicationInvokeIndication(
									&gcc_pdu->u.indication.u.
										application_invoke_indication,
									initiator);
						break;
					
					case TEXT_MESSAGE_INDICATION_CHOSEN:
#ifdef JASPER
						if (ProcessTextMessageIndication(
									&gcc_pdu->u.indication.u.
										text_message_indication,
									initiator) != GCC_NO_ERROR)
						{
							error_value = GCC_ALLOCATION_FAILURE;
						}
#endif // JASPER
						break;

					case CONFERENCE_ASSISTANCE_INDICATION_CHOSEN:
#ifdef JASPER
						ProcessConferenceAssistanceIndicationPDU(
									&gcc_pdu->u.indication.u.
										conference_assistance_indication,
									initiator);
#endif // JASPER
						break;

					case REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN:
						/*
						**	Do not decode this packet if it was sent
						**	uniformly from this node.
						*/
						if (initiator != m_nidMyself)
						{
							ProcessRegistryMonitorIndicationPDU (
								&gcc_pdu->u.indication.u.
									registry_monitor_entry_indication,
								initiator);
						}
						break;

					case CONFERENCE_TRANSFER_INDICATION_CHOSEN:
#ifdef JASPER
						/*
						**	Do not decode this packet if it was not sent
						**	from the top provider.
						*/
						if (initiator == m_nidTopProvider)
						{
							ProcessTransferIndicationPDU (
								&gcc_pdu->u.indication.u.
									conference_transfer_indication);
						}
#endif // JASPER
						break;

					default:
						ERROR_OUT(("MCSUser::ProcessSendDataIndication"
										"Unsupported PDU"));
						break;
				} // switch(gcc_pdu->u.indication.choice)
	            break;

			default:
				ERROR_OUT(("MCSUser::ProcessUniformSendDataIndication. wrong pdu type "));
				break;
		}
		packet->Unlock();
	}
	else
	{
		delete packet;
		error_value = GCC_ALLOCATION_FAILURE;
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
        ResourceFailureHandler();
	}

	return (MCS_NO_ERROR);
}

/*
 *	void	ProcessTransferIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Transfer indication PDU.
 *
 *	Formal Parameters:
 *		transfer_indication	-	(i)	This is the PDU structure to process.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessTransferIndicationPDU
(
    PConferenceTransferIndication       transfer_indication
)
{
	GCCError					rc = GCC_NO_ERROR;
	TransferInfo				transfer_info;
	PSetOfTransferringNodesIn	set_of_nodes;
	LPBYTE						sub_node_list_memory = NULL;
	Int							i;
	BOOL						process_pdu = FALSE;

    ::ZeroMemory(&transfer_info, sizeof(transfer_info));

	/*
	**	If there is a transferring node list we must determine if this node
	**	is in the list.  If it isn't then the request is ignored.
	*/
	if (transfer_indication->bit_mask & CTIN_TRANSFERRING_NODES_PRESENT)
	{
		set_of_nodes = transfer_indication->ctin_transferring_nodes;
		while (set_of_nodes != NULL)
		{
			if (set_of_nodes->value == GetMyNodeID())
			{
				process_pdu = TRUE;
				break;
			}

			set_of_nodes = set_of_nodes->next;
		}

		if (process_pdu == FALSE)
		{
			return;
		}
	}

	//	First set up the conference name
	if (transfer_indication->conference_name.choice == NAME_SELECTOR_NUMERIC_CHOSEN)
	{
		transfer_info.destination_conference_name.numeric_string =
                (LPSTR) transfer_indication->conference_name.u.name_selector_numeric;
		// transfer_info.destination_conference_name.text_string = NULL;
	}
	else
	{
		// transfer_info.destination_conference_name.numeric_string = NULL;
		if (NULL == (transfer_info.destination_conference_name.text_string = ::My_strdupW2(
							transfer_indication->conference_name.u.name_selector_text.length,
							transfer_indication->conference_name.u.name_selector_text.value)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Next set up the conference name modifier
	if (transfer_indication->bit_mask & CTIN_CONFERENCE_MODIFIER_PRESENT)
	{
		transfer_info.destination_conference_modifier =
						(LPSTR) transfer_indication->ctin_conference_modifier;
	}
	else
    {
		// transfer_info.destination_conference_modifier = NULL;
    }

	//	Next set up the network address
	if (transfer_indication->bit_mask & CTIN_NETWORK_ADDRESS_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.destination_address_list = new CNetAddrListContainer(
								transfer_indication->ctin_net_address,
								&rc);
		if (transfer_info.destination_address_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		// transfer_info.destination_address_list = NULL;
    }

	//	Set up the transferring nodes list
	if (transfer_indication->bit_mask & CTIN_TRANSFERRING_NODES_PRESENT)
	{
		//	First determine the number of nodes.
		set_of_nodes = transfer_indication->ctin_transferring_nodes;
		// transfer_info.number_of_destination_nodes = 0;
		while (set_of_nodes != NULL)
		{
			transfer_info.number_of_destination_nodes++;
			set_of_nodes = set_of_nodes->next;
		}

		//	Next allocate the memory required to hold the sub nodes
		DBG_SAVE_FILE_LINE
		sub_node_list_memory = new BYTE[sizeof(UserID) * transfer_info.number_of_destination_nodes];

		//	Now fill in the permission list
		if (sub_node_list_memory != NULL)
		{
			transfer_info.destination_node_list = (PUserID) sub_node_list_memory;

			set_of_nodes = transfer_indication->ctin_transferring_nodes;
			for (i = 0; i < transfer_info.number_of_destination_nodes; i++)
			{
				transfer_info.destination_node_list[i] = set_of_nodes->value;
				set_of_nodes = set_of_nodes->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessTransferIndicationPDU: Memory Manager Alloc Failure"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.number_of_destination_nodes = 0;
		// transfer_info.destination_node_list = NULL;
	}
	

	//	Set up the password
	if (transfer_indication->bit_mask & CTIN_PASSWORD_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		transfer_info.password = new CPassword(&transfer_indication->ctin_password, &rc);
		if (transfer_info.password == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		// transfer_info.password = NULL;
	}

	if (rc == GCC_NO_ERROR)
	{
		g_pControlSap->ConfTransferIndication(
							m_pConf->GetConfID(),
							&transfer_info.destination_conference_name,
							transfer_info.destination_conference_modifier,
							transfer_info.destination_address_list,
							transfer_info.password);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessTransferIndicationPDU: Allocation Failure"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}

	//	Now cleanup any allocated memory
	if (NULL != transfer_info.destination_address_list)
	{
	    transfer_info.destination_address_list->Release();
	}

	delete sub_node_list_memory;

	if (NULL != transfer_info.password)
	{
	    transfer_info.password->Release();
	}
}
#endif // JASPER

/*
 *	void	ProcessConferenceTerminateIndicationPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Terminate indication PDU.
 *
 *	Formal Parameters:
 *		terminate_indication	-	(i)	This is the PDU structure to process.
 *		sender_id				-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceTerminateIndicationPDU (
						PConferenceTerminateIndication	terminate_indication,
						UserID							sender_id)
{
	if (sender_id == m_nidTopProvider)
	{
		m_pConf->ProcessTerminateIndication(
			::TranslateTerminateInReasonToGCCReason(terminate_indication->reason));
	}
}

/*
 *	void	ProcessTimeRemainingIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		Time remaining indication PDU.
 *
 *	Formal Parameters:
 *		time_remaining_indication	-	(i)	This is the PDU structure to process
 *		sender_id					-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessTimeRemainingIndicationPDU
(
    PConferenceTimeRemainingIndication      time_remaining_indication,
    UserID                                  sender_id
)
{
    g_pControlSap->ConfTimeRemainingIndication(
                        m_pConf->GetConfID(),
                        sender_id,
                        (time_remaining_indication->bit_mask & TIME_REMAINING_NODE_ID_PRESENT) ?
                            time_remaining_indication->time_remaining_node_id : 0,
                        time_remaining_indication->time_remaining);
}
#endif // JASPER

/*
 *	void	ProcessConferenceAssistanceIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		assistance indication PDU.
 *
 *	Formal Parameters:
 *		conf_assistance_indication	-	(i)	This is the PDU structure to process
 *		sender_id					-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessConferenceAssistanceIndicationPDU
(
    PConferenceAssistanceIndication     conf_assistance_indication,
    UserID                              sender_id
)
{
	GCCError				rc = GCC_NO_ERROR;
	CUserDataListContainer  *user_data_list = NULL;

	DebugEntry(MCSUser::ProcessConferenceAssistanceIndication);

	//	Unpack the user data list if it exists
	if (conf_assistance_indication->bit_mask & CAIN_USER_DATA_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		user_data_list = new CUserDataListContainer(conf_assistance_indication->cain_user_data, &rc);
		if (user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}

	if (rc == GCC_NO_ERROR)
	{
        g_pControlSap->ConfAssistanceIndication(
                            m_pConf->GetConfID(),
                            user_data_list,
                            sender_id);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessConferenceAssistanceIndication: can't create CUserDataListContainer"));
		if (GCC_ALLOCATION_FAILURE == rc)
		{
            ResourceFailureHandler();
        }
	}
}
#endif // JASPER


/*
 *	void	ProcessConferenceExtendIndicationPDU()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		extend indication PDU.
 *
 *	Formal Parameters:
 *		conf_time_extend_indication	-	(i)	This is the PDU structure to process
 *		sender_id					-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
void MCSUser::
ProcessConferenceExtendIndicationPDU
(
    PConferenceTimeExtendIndication     conf_time_extend_indication,
    UserID                              sender_id
)
{
    g_pControlSap->ConfExtendIndication(
                        m_pConf->GetConfID(),
                        conf_time_extend_indication->time_to_extend,
                        conf_time_extend_indication->time_is_node_specific,
                        sender_id);
}
#endif // JASPER

/*
 *	void	ProcessConferenceEjectUserIndicationPDU ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Conference
 *		eject user indication PDU.
 *
 *	Formal Parameters:
 *		eject_user_indication	-	(i)	This is the PDU structure to process
 *		sender_id			 	-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessConferenceEjectUserIndicationPDU (
						PConferenceEjectUserIndication	eject_user_indication,
						UserID							sender_id)
{
	GCCError				error_value = GCC_NO_ERROR;
	PAlarm					alarm = NULL;

	//	First check to make sure that this is the node being ejected
	if (eject_user_indication->node_to_eject == m_nidMyself)
	{
		/*
		**	Next make sure the ejection came from either the Top Provider or
		**	the Parent Node.
		*/
		if ((sender_id == m_nidParent) || (sender_id == m_nidTopProvider))
		{
			TRACE_OUT(("MCSUser:ProcessEjectUserIndication: This node is ejected"));
			error_value = InitiateEjectionFromConference (
							::TranslateEjectIndReasonToGCCReason(
										eject_user_indication->reason));
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessEjectUserIndication: Received eject from illegal node"));
		}
	}
	else
	{
		TRACE_OUT(("MCSUser: ProcessEjectUserIndication: Received eject for node other than mine"));

		/*
		**	If this node is a directly connected child node we insert an
		**	alarm in the list m_EjectedNodeAlarmList2 to disconnect it if
		**	it misbehaves and does not disconnect itself.  Otherwise,  we save
		**	the ejected user id in the m_EjectedNodeList to inform the local
		**	node of the correct reason for disconnecting (user ejected) when the
		**	detch user indication comes in.
		*/
		if (m_ChildUidConnHdlList2.Find(eject_user_indication->node_to_eject))
		{
			DBG_SAVE_FILE_LINE
			alarm = new Alarm (EJECTED_NODE_TIMER_DURATION);
			if (alarm != NULL)
			{
				m_EjectedNodeAlarmList2.Append(eject_user_indication->node_to_eject, alarm);
			}
			else
				error_value = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			/*
			**	Here we save the alarm in a list of ejected nodes. This
			**	alarm is used to cleanup any misbehaving node.  Note that
			**	if the ejected node is not a child of this node then no
			**	alarm is set up to monitor the ejection.
			*/
			m_EjectedNodeList.Append(eject_user_indication->node_to_eject);
		}
	}

	if (error_value == GCC_ALLOCATION_FAILURE)
	{
		ERROR_OUT(("MCSUser::ProcessEjectUserIndication: Allocation Failure"));
        ResourceFailureHandler();
	}
}

/*
 *	void	ProcessPermissionGrantIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Permission
 *		grant indication PDU.
 *
 *	Formal Parameters:
 *		permission_grant_indication	-	(i)	This is the PDU structure to process
 *		sender_id			 		-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessPermissionGrantIndication(
			PConductorPermissionGrantIndication	permission_grant_indication,
			UserID								sender_id)
{
	GCCError									error_value = GCC_NO_ERROR;
	UserPermissionGrantIndicationInfo			grant_indication_info;
	PPermissionList								permission_list;
	LPBYTE										permission_list_memory = NULL;
	PWaitingList								waiting_list;
	LPBYTE										waiting_list_memory = NULL;
	UINT										i;

	//	First count the number of entries in the permission list
	grant_indication_info.number_granted = 0;
	permission_list = permission_grant_indication->permission_list;
	while (permission_list != NULL)
	{
		permission_list = permission_list->next;
		grant_indication_info.number_granted++;
	}
	
	TRACE_OUT(("MCSUser: ProcessPermissionGrantIndication: number_granted=%d", (UINT) grant_indication_info.number_granted));

	//	If a list exist allocate memory for it and copy it over.
	if (grant_indication_info.number_granted != 0)
	{
		// allocating space to hold permission list.
		DBG_SAVE_FILE_LINE
		permission_list_memory = new BYTE[sizeof(UserID) * grant_indication_info.number_granted];

		//	Now fill in the permission list
		if (permission_list_memory != NULL)
		{
			grant_indication_info.granted_node_list = (PUserID) permission_list_memory;

			permission_list = permission_grant_indication->permission_list;
			for (i = 0; i < grant_indication_info.number_granted; i++)
			{
				grant_indication_info.granted_node_list[i] = permission_list->value;
				permission_list = permission_list->next;
			}
		}
		else
		{
			ERROR_OUT(("MCSUser: ProcessPermissionGrantIndication: Memory Manager Alloc Failure"));
			error_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		grant_indication_info.granted_node_list = NULL;
	}

	//	Now extract the waiting list information if any exist
	if ((error_value == GCC_NO_ERROR) &&
		(permission_grant_indication->bit_mask & WAITING_LIST_PRESENT))
	{
		//	First count the number of entries in the waiting list
		grant_indication_info.number_waiting = 0;
		waiting_list = permission_grant_indication->waiting_list;
		while (waiting_list != NULL)
		{
			waiting_list = waiting_list->next;
			grant_indication_info.number_waiting++;
		}

		TRACE_OUT(("MCSUser: ProcessPermissionGrantIndication: number_waiting=%d", (UINT) grant_indication_info.number_waiting));

		// allocating space to hold waiting list.
		DBG_SAVE_FILE_LINE
		waiting_list_memory = new BYTE[sizeof(UserID) * grant_indication_info.number_waiting];

		//	Now fill in the permission list
		if (waiting_list_memory != NULL)
		{
			grant_indication_info.waiting_node_list = (PUserID) waiting_list_memory;

			waiting_list = permission_grant_indication->waiting_list;
			for (i = 0; i < grant_indication_info.number_waiting; i++)
			{
				grant_indication_info.waiting_node_list[i] = waiting_list->value;
				waiting_list = waiting_list->next;
			}
		}
		else
		{
			error_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		grant_indication_info.number_waiting = 0;
		grant_indication_info.waiting_node_list = NULL;
	}

	/*
	**	If there were no memory errors, send the indication back to the
	**	owner object.
	*/
	if (error_value == GCC_NO_ERROR)
	{
		m_pConf->ProcessConductorPermitGrantInd(&grant_indication_info, sender_id);
	}
	else
	{
		ERROR_OUT(("MCSUser::ProcessPermissionGrantIndication: Alloc Failed"));
		if (GCC_ALLOCATION_FAILURE == error_value)
		{
            ResourceFailureHandler();
        }
	}

	//	Free up any memory used in this call
	delete permission_list_memory;
	delete waiting_list_memory;
}

/*
 *	MCSUser::GetUserIDFromConnection()
 *
 *	Public Function Description:
 *		This function returns the Node ID associated with the specified
 *		connection handle.  It returns zero if the connection handle is
 *		not a child connection of this node.
 */
UserID MCSUser::GetUserIDFromConnection(ConnectionHandle connection_handle)
{
	ConnectionHandle        hConn;
	UserID                  uid;

	m_ChildUidConnHdlList2.Reset();
	while (NULL != (hConn = m_ChildUidConnHdlList2.Iterate(&uid)))
	{
		if (hConn == connection_handle)
		{
			return uid;
		}
	}
	return 0;
}



/*
 *	MCSUser::UserDisconnectIndication()
 *
 *	Public Function Description:
 *		This function informs the user object when a Node disconnects from
 *		the conference.  This gives the user object a chance to clean up
 *		its internal information base.
 */
void MCSUser::UserDisconnectIndication(UserID disconnected_user)
{
	PAlarm			lpAlarm;

	/*
	**	If this node has a pending ejection we will go ahead and remove the
	**	ejected node from the list.  Once all child nodes have disconnected
	**	we will inform the owner object of the ejection.
	*/	
	if (m_fEjectionPending)
	{
		// Delete the Alarm if it exists
		if (NULL != (lpAlarm = m_EjectedNodeAlarmList2.Remove(disconnected_user)))
		{
			delete lpAlarm;
			/*
			**	Here we must check to see if there are anymore active alarms
			**	in the list.  If so we wait until that node disconnects before
			**	informing the owner object that this node has been ejected.
			**	Otherwise, we complete the ejection process.
			*/
			if (m_EjectedNodeAlarmList2.IsEmpty())
			{
				m_pConf->ProcessEjectUserIndication(m_eEjectReason);
			}
		}
	}
	// If we are the top provider, just clean the eject alarm list.
	else if (TOP_PROVIDER_AND_CONVENER_NODE == m_pConf->GetConfNodeType() &&
			 NULL != (lpAlarm = m_EjectedNodeAlarmList2.Remove(disconnected_user)))
	{
			delete lpAlarm;
	}
	
	/*
	**	Here we remove the entry from the list of child connections if
	**	it is included in this list.
	*/
	m_ChildUidConnHdlList2.Remove(disconnected_user);
}

/*
 *	void	ProcessApplicationInvokeIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Invoke
 *		indication PDU.
 *
 *	Formal Parameters:
 *		invoke_indication	-	(i)	This is the PDU structure to process
 *		sender_id		 	-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void	MCSUser::ProcessApplicationInvokeIndication(
							PApplicationInvokeIndication	invoke_indication,
							UserID							sender_id)
{
	GCCError							error_value = GCC_NO_ERROR;
	BOOL								process_pdu = FALSE;
	CInvokeSpecifierListContainer		*invoke_list;
	PSetOfDestinationNodes				set_of_destination_nodes;
	
	if (invoke_indication->bit_mask & DESTINATION_NODES_PRESENT)
	{
		set_of_destination_nodes = invoke_indication->destination_nodes;
		while (set_of_destination_nodes != NULL)
		{
			if (set_of_destination_nodes->value == m_nidMyself)
			{
				process_pdu = TRUE;
				break;
			}
			else
			{
				set_of_destination_nodes = set_of_destination_nodes->next;
			}
		}
	}
	else
	{
		process_pdu = TRUE;
	}

	if (process_pdu)
	{
		TRACE_OUT(("MCSUser: ProcessApplicationInvokeIndication: Process PDU"));
		DBG_SAVE_FILE_LINE
		invoke_list = new CInvokeSpecifierListContainer(
							invoke_indication->application_protocol_entity_list,
							&error_value);
		if ((invoke_list != NULL) && (error_value == GCC_NO_ERROR))
		{
			m_pConf->ProcessAppInvokeIndication(invoke_list, sender_id);
			invoke_list->Release();
		}
		else if (invoke_list == NULL)
		{
			error_value = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			invoke_list->Release();
		}

		if (error_value == GCC_ALLOCATION_FAILURE)
		{
			ERROR_OUT(("MCSUser::ProcessApplicationInvokeIndication: Allocation Failure"));
            ResourceFailureHandler();
		}
	}
	else
	{
		WARNING_OUT(("MCSUser:ProcessApplicationInvokeIndication: Don't Process PDU"));
	}
}

/*
 *	GCCError	ProcessTextMessageIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Text
 *		message indication PDU.
 *
 *	Formal Parameters:
 *		text_message_indication	-	(i)	This is the PDU structure to process
 *		sender_id		 		-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
#ifdef JASPER
GCCError	MCSUser::ProcessTextMessageIndication(
							PTextMessageIndication	text_message_indication,
							UserID					sender_id)
{
	LPWSTR					gcc_unicode_string;
	GCCError				rc;

	if (NULL != (gcc_unicode_string = ::My_strdupW2(
					text_message_indication->message.length,
					text_message_indication->message.value)))
	{
		rc = g_pControlSap->TextMessageIndication(
                                    m_pConf->GetConfID(),
                                    gcc_unicode_string,
                                    sender_id);
	}
	else
    {
		rc = GCC_ALLOCATION_FAILURE;
    }

	return rc;
}
#endif // JASPER

/*
 *	void	ProcessRegistryMonitorIndication ()
 *
 *	Private Function Description:
 *		This routine is responsible for processing an incoming Registry
 *		monitor indication PDU.
 *
 *	Formal Parameters:
 *		monitor_indication	-	(i)	This is the PDU structure to process
 *		sender_id		  	-	(i)	Node ID of node that sent this PDU.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void MCSUser::
ProcessRegistryMonitorIndicationPDU
(
    PRegistryMonitorEntryIndication     monitor_indication,
    UserID                              sender_id
)
{
    if (sender_id == m_nidTopProvider)
    {
        CRegistry   *pAppReg = m_pConf->GetRegistry();
        if (NULL != pAppReg)
        {
            GCCError                    rc;
            UserRegistryMonitorInfo     urmi;

            ::ZeroMemory(&urmi, sizeof(urmi));
            // urmi.registry_key = NULL;
            // urmi.registry_item = NULL;

            DBG_SAVE_FILE_LINE
            urmi.registry_key = new CRegKeyContainer(&monitor_indication->key, &rc);
            if ((urmi.registry_key != NULL) && (rc == GCC_NO_ERROR))
            {
                DBG_SAVE_FILE_LINE
                urmi.registry_item = new CRegItem(&monitor_indication->item, &rc);
                if ((urmi.registry_item != NULL) && (rc == GCC_NO_ERROR))
                {
                    //	Set up the owner related variables	
                    if (monitor_indication->owner.choice == OWNED_CHOSEN)
                    {
                        urmi.owner_node_id = monitor_indication->owner.u.owned.node_id;
                        urmi.owner_entity_id = monitor_indication->owner.u.owned.entity_id;
                    }
                    else
                    {
                        // urmi.owner_node_id = 0;
                        // urmi.owner_entity_id = 0;
                    }

                    //	Set up the modification rights
                    if (monitor_indication->bit_mask & RESPONSE_MODIFY_RIGHTS_PRESENT)
                    {
                        urmi.modification_rights = (GCCModificationRights)monitor_indication->entry_modify_rights;
                    }
                    else
                    {
                        urmi.modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;
                    }

                    pAppReg->ProcessMonitorIndicationPDU(
                                        urmi.registry_key,
                                        urmi.registry_item,
                                        urmi.modification_rights,
                                        urmi.owner_node_id,
                                        urmi.owner_entity_id);
                }
                else
                {
                    rc = GCC_ALLOCATION_FAILURE;
                }
            }
            else
            {
                rc = GCC_ALLOCATION_FAILURE;
            }

            if (NULL != urmi.registry_key)
            {
                urmi.registry_key->Release();
            }
            if (NULL != urmi.registry_item)
            {
                urmi.registry_item->Release();
            }

            //	Handle any resource errors	
            if (rc == GCC_ALLOCATION_FAILURE)
            {
                ResourceFailureHandler();
            }
        }
        else
        {
            WARNING_OUT(("MCSUser:ProcessRegistryMonitorIndication: invalid app registry"));
        }
    }
    else
    {
        WARNING_OUT(("MCSUser:ProcessRegistryMonitorIndication:"
                        "Monitor Indication received from NON Top Provider"));
    }
}

/*
 *	UINT	ProcessDetachUserIndication()
 *
 *	Private Function Description:
 * 		This function is called when the user object gets detach user
 *		indications from nodes in it's subtree or it's parent node.
 *		Depending upon the reason of the indication it sends to the
 *		conference object the appropriate owner callback.
 * 		If the reason contained in the indication is UserInitiated or
 *		provider initiated a DETACH USER INDICATION is sent to the con-
 *		ference. The MCS reason is converted to GCC reason. If MCS
 *		reason in indication is neither user initiated nor provider initiated
 *		then the above owner callback carries a GCC reason ERROR_TERMINATION
 *		else it carries a GCC reason USER_INITIATED.
 *		If the detach user indication reveals the user id of the sendar as
 *		the parent user id of this node a CONFERENCE_TERMINATE_INDICATION
 *		is sent to the conference object.
 *
 *	Formal Parameters:
 *		mcs_reason	-	(i)	MCS reason for being detached.
 *		sender_id	-	(i)	User ID of user being detached.
 *
 *	Return Value
 *		MCS_NO_ERROR is always returned fro this routine.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
UINT	MCSUser::ProcessDetachUserIndication(	Reason		mcs_reason,
												UserID		detached_user)
{
	GCCReason				gcc_reason;

	if (detached_user == m_nidParent)
	{
		WARNING_OUT(("MCSUser: Fatal Error: Parent User Detached"));
		m_pConf->ProcessTerminateIndication(GCC_REASON_PARENT_DISCONNECTED);
	}
    else
    {
		TRACE_OUT(("MCSUser: User Detached: uid=0x%04x", (UINT) detached_user));

		/*
		**	First, we check to see if the detching node was ejected.
		**	If not, translate the mcs reason to a gcc reason.
		*/
		if (m_EjectedNodeList.Find(detached_user))
		{
			gcc_reason = GCC_REASON_NODE_EJECTED;
			
			//	Remove this entry from the ejected node list.
			m_EjectedNodeList.Remove(detached_user);
		}
		else if (m_EjectedNodeAlarmList2.Find(detached_user))
		{
			//	Here we wait for the disconnect before removing the entry.
			gcc_reason = GCC_REASON_NODE_EJECTED;
		}
		else if ((mcs_reason == REASON_USER_REQUESTED) ||
			(mcs_reason == REASON_PROVIDER_INITIATED))
        {
	    	gcc_reason = GCC_REASON_USER_INITIATED;
		}
        else
        {
			gcc_reason = GCC_REASON_ERROR_TERMINATION;
        }

        m_pConf->ProcessDetachUserIndication(detached_user, gcc_reason);
	}
	return (MCS_NO_ERROR);
}


void MCSUser::
ProcessTokenGrabConfirm
(
    TokenID         tidConductor,
    Result          result
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorGrabConfirm(::TranslateMCSResultToGCCResult(result));
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Grab Confirm"));
    }
}


void MCSUser::
ProcessTokenGiveIndication
(
    TokenID         tidConductor,
    UserID          uidRecipient
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorGiveIndication(uidRecipient);
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Please Ind"));
    }
}


void MCSUser::
ProcessTokenGiveConfirm
(
    TokenID         tidConductor,
    Result          result
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorGiveConfirm(::TranslateMCSResultToGCCResult(result));
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Grab Confirm"));
    }
}


#ifdef JASPER
void MCSUser::
ProcessTokenPleaseIndication
(
    TokenID         tidConductor,
    UserID          uidRequester
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        if (m_pConf->IsConfConductible())
        {
            //	Inform the control SAP.
            g_pControlSap->ConductorPleaseIndication(
                                        m_pConf->GetConfID(),
                                        uidRequester);
        }
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Please Ind"));
    }
}
#endif // JASPER


#ifdef JASPER
void MCSUser::
ProcessTokenReleaseConfirm
(
    TokenID         tidConductor,
    Result          result
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        g_pControlSap->ConductorReleaseConfirm(::TranslateMCSResultToGCCResult(result),
                                               m_pConf->GetConfID());
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Release Cfrm"));
    }
}
#endif // JASPER


void MCSUser::
ProcessTokenTestConfirm
(
    TokenID         tidConductor,
    TokenStatus     eStatus
)
{
    if (tidConductor == CONDUCTOR_TOKEN_ID)
    {
        m_pConf->ProcessConductorTestConfirm((eStatus == TOKEN_NOT_IN_USE) ?
                                                GCC_RESULT_NOT_IN_CONDUCTED_MODE :
                                                GCC_RESULT_SUCCESSFUL);
    }
    else
    {
        ERROR_OUT(("MCSUser:Assertion Failure: Non Conductor Release Cfrm"));
    }
}



void MCSUser::ResourceFailureHandler(void)
{
    ERROR_OUT(("MCSUser::ResourceFailureHandler: terminating the conference"));
    m_pConf->InitiateTermination(GCC_REASON_ERROR_LOW_RESOURCES, 0);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\memmgr.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MEMORY);
/*
 *	memmgr.cpp
 *
 *	Copyright (c) 1998 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the implementation file for the T.120 memory allocation mechanism.  This
 *		file contains the code necessary to allocate and distribute memory
 *		in the form of Memory objects.
 *
 *	This implementation defines priorities of memory allocations.  A lower
 *	priority number implies higher priority.  Priority-0 allocations will be
 *	satisfied, unless the system is out of memory.  Priorities 1 and 2
 *	limit the amount of total memory that can be allocated, but priority 1 (recv priority)
 *	has higher water mark limits than priority 2 (send priority).
 *
 *	Protected Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Christos Tsollis
 */
static int						s_anCurrentSize[MEMORY_PRIORITIES] = { 0, 0, 0 };
static const int				sc_iLimit[MEMORY_PRIORITIES] = {
										0x7FFFFFFF,
										0x100000,
										0xE0000
								};

#ifdef DEBUG
static int						s_TotalSize = 0;
#endif // DEBUG

/*
 *	PMemory		AllocateMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to allocate a buffer together with a
 *		Memory (buffer header) object
 */
PMemory	AllocateMemory (
					PUChar				reference_ptr,
					UINT				length,
					MemoryPriority		priority)
{

	PUChar				copy_ptr;
	PMemory				memory;
						
	ASSERT (length > 0);

	if (s_anCurrentSize[priority] < sc_iLimit[priority]) {
		/*
		 *	We attempt to allocate enough space for the buffer and the
		 *	Memory object.
		 */
#ifdef DEBUG
		memory = (PMemory) new BYTE[length + sizeof (Memory)];
#else // DEBUG
		memory = (PMemory) LocalAlloc (LMEM_FIXED, length + sizeof (Memory));
#endif // DEBUG
	}
	else {
		/*
		 *	The application has attempted to allocate past its limit
		 *	It is necessary to fail the request.
		 */
		memory = NULL;
		WARNING_OUT (("AllocateMemory: attempt to allocate past the allowable limit. "
					  "Request: %d. Currently allocated: %d. Priority: %d",
					  length, s_anCurrentSize[priority], priority));
	}

	/*
	 *	Check to see whether the allocation was successful.
	 */
	if (memory != NULL) {
#ifdef DEBUG
		s_TotalSize += (int) length;
#endif // DEBUG
		/*
		 * Update the currently allocated size. Notice that we only
		 * do this for buffers used in the send/recv code path in
		 * MCS.  Since this is only one thread, we do not have to
		 * use a critical section to protect the size variable.
		 */
		ASSERT (s_anCurrentSize[priority] >= 0);
		s_anCurrentSize[priority] += (int) length;

		copy_ptr = (PUChar) memory + sizeof(Memory);
		memory->Init (reference_ptr, length, priority, copy_ptr);

		TRACE_OUT (("Allocate: successful request. "
						"Request: %d. Currently allocated: %d. Total: %d. Priority: %d",
					  	length, s_anCurrentSize[priority], s_TotalSize, priority));
		TRACE_OUT (("AllocateMemory: buffer at address %p; memory segment at address %p",
					copy_ptr, memory));
	}
	else {
		/*
		 *	We failed to allocate the requested size
		 *	It is necessary to fail the request.
		 */
		WARNING_OUT (("AllocateMemory: failed to allocated buffer.  We are out of system memory. "
					 "Request: %d. Last error: %d",
					 length, GetLastError()));
	}
	return (memory);
}

/*
 *	PUChar		ReAllocate ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to re-allocate a buffer with a Memory
 *		(buffer header) object. The buffer must have been allocated by
 *		a call to AllocateMemory.  This call assumes RECV_PRIORITY.  However,
 *		it's not restricted in allocations, because, if it did, this might
 *		cause deadlocks (some memory has already been allocated for the
 *		new arriving data).
 */
BOOL ReAllocateMemory (PMemory		*pmemory,
						UINT		length)
{

	PUChar				copy_ptr = NULL;
	UINT				new_length;
	MemoryPriority		priority;
						
	ASSERT (length > 0);
	ASSERT (pmemory != NULL);
	ASSERT (*pmemory != NULL);
	ASSERT ((*pmemory)->GetPointer());

	new_length = length + (*pmemory)->GetLength();
	priority = (*pmemory)->GetMemoryPriority();

	ASSERT (priority == RECV_PRIORITY);
	
	// We attempt to allocate enough space for the buffer.
#ifdef DEBUG
	copy_ptr = (PUChar) new BYTE[new_length + sizeof(Memory)];
	if (copy_ptr != NULL) {
		memcpy (copy_ptr, *pmemory, (*pmemory)->GetLength() + sizeof(Memory));
		delete [] (BYTE *) *pmemory;
	}
#else // DEBUG
	copy_ptr = (PUChar) LocalReAlloc ((HLOCAL) *pmemory,
										new_length + sizeof(Memory),
										LMEM_MOVEABLE);
#endif // DEBUG

	/*
	 *	Check to see whether the allocation was successful.
	 */
	if (copy_ptr != NULL) {

#ifdef DEBUG
		s_TotalSize += (int) length;
#endif // DEBUG
		/*
		 * Update the currently allocated size.
		 */
		ASSERT (s_anCurrentSize[priority] >= 0);
		s_anCurrentSize[priority] += (int) length;
		*pmemory = (PMemory) copy_ptr;
		copy_ptr += sizeof (Memory);
		(*pmemory)->Init (NULL, new_length, priority, copy_ptr);

		TRACE_OUT (("ReAllocate: successful request. "
					"Request: %d. Currently allocated: %d. Total: %d",
				  	length, s_anCurrentSize[priority], s_TotalSize));
		TRACE_OUT (("ReAllocate: buffer at address %p; memory segment at address %p",
					copy_ptr, *pmemory));
	}
	else {
		/*
		 *	We failed to allocate the requested size
		 *	It is necessary to fail the request.
		 */
		WARNING_OUT (("ReAllocate: failed to allocated buffer.  We are out of system memory. "
					 "Request: %d. Currently allocated: %d. Last error: %d",
					 length, s_anCurrentSize[priority], GetLastError()));
	}

	return (copy_ptr != NULL);
}

/*
 *	Void	FreeMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to release a previously allocated Memory object.
 */
void FreeMemory (PMemory	memory)
{
	if (memory != NULL) {

		ASSERT (SIGNATURE_MATCH(memory, MemorySignature));
		ASSERT (memory->GetPointer() == (PUChar) memory + sizeof(Memory));
		
		if (memory->Unlock() == 0) {

    	    MemoryPriority		priority = memory->GetMemoryPriority();

			TRACE_OUT (("FreeMemory: buffer at address %p (memory segment at address %p) freed. Size: %d. ",
						memory->GetPointer(), memory, memory->GetLength()));

			// We may need to adjust the variable tracking the allocated amount of mem.
			ASSERT (s_anCurrentSize[priority] >= (int) memory->GetLength());
			s_anCurrentSize[priority] -= memory->GetLength();
			ASSERT(s_anCurrentSize[priority] >= 0);
#ifdef DEBUG
			s_TotalSize -= memory->GetLength();
#endif // DEBUG
			TRACE_OUT(("FreeMemory: Currently allocated: %d. Total: %d.",
						s_anCurrentSize[priority], s_TotalSize));
			
			// free the buffer, and the memory
#ifdef DEBUG
			delete [] (BYTE *) memory;
#else // DEBUG
			LocalFree ((HLOCAL) memory);
#endif // DEBUG
		}
	}
}

#ifdef DEBUG
/*
 *	PUChar		Allocate ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to allocate a buffer without a Memory
 *		(buffer header) object.
 */
PUChar	Allocate (UINT	length)
{

	PUChar		copy_ptr;
						
	ASSERT (length > 0);

	// We attempt to allocate enough space for the buffer.
	copy_ptr = (PUChar) new BYTE[length];

	/*
	 *	Check to see whether the allocation was successful.
	 */
	if (copy_ptr == NULL) {
		/*
		 *	We failed to allocate the requested size
		 *	It is necessary to fail the request.
		 */
		ERROR_OUT (("Allocate: failed to allocated buffer.  We are out of system memory. "
					 "Request: %d. Last error: %d",
					 length, GetLastError()));
	}
		
	return (copy_ptr);
}
#endif // DEBUG

/*
 *	UINT	GetFreeMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns the amount of space that can still be
 *		allocated at the given priority level.  The function should be
 *		called only when send/recv space is allocated.
 */

UINT GetFreeMemory (MemoryPriority		priority)
{
		int		idiff;
	
	ASSERT (priority != HIGHEST_PRIORITY);

	idiff = sc_iLimit[priority] - s_anCurrentSize[priority];
	return ((idiff > 0) ? (UINT) idiff : 0);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\netaddr.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	netaddr.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CNetAddrListContainer Class.  This
 *		class manages the data associated with a network address.  Network
 *		addresses can be one of three types: aggregated channel, transport
 *		connection, or non-standard.  A variety of structures, objects, and
 *		Rogue Wave containers are used to buffer the network address data
 *		internally.
 *
 *	Protected Instance Variables:
 *		m_NetAddrItemList
 *			List of structures used to hold the network address data internally.
 *		m_pSetOfNetAddrPDU
 *			Storage for the "PDU" form of the network address list.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" network address structures.
 *		m_fValidNetAddrPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" network address list.
 *
 *	Private Member Functions:
 *		StoreNetworkAddressList
 *			This routine is used to store the network address data passed in as
 *			"API" data in the internal structures.
 *		ConvertPDUDataToInternal	
 *			This routine is used to store the network address data passed in as
 *			"PDU" data in the internal structures.
 * 		ConvertNetworkAddressInfoToPDU
 *			This routine is used to convert the network address info structures
 *			maintained internally into the "PDU" form which is a 
 *			SetOfNetworkAddresses.
 *		ConvertTransferModesToInternal
 *			This routine is used to convert the PDU network address transfer 
 *			modes structure into the internal form where the structure is saved
 *			as a GCCTranferModes structure.
 *		ConvertHighLayerCompatibilityToInternal
 *			This routine is used to convert the PDU network address high layer
 *			compatibility structure into the internal form where the structure
 *			is saved as a GCCHighLayerCompatibility structure.
 *		ConvertTransferModesToPDU
 *			This routine is used to convert the API network address transfer
 *			modes structure into the PDU form which is a TranferModes structure.
 *		ConvertHighLayerCompatibilityToPDU
 *			This routine is used to convert the API network address high layer
 *			compatibility structure into the PDU form which is a 
 *			HighLayerCompatibility structure.
 *		IsDialingStringValid
 *			This routine is used to ensure that the values held within a
 *			dialing string do not violate the imposed ASN.1 constraints.
 *		IsCharacterStringValid
 *			This routine is used to ensure that the values held within a
 *			character string do not violate the imposed ASN.1 constraints.
 *		IsExtraDialingStringValid
 *			This routine is used to ensure that the values held within an
 *			extra dialing string do not violate the imposed ASN.1 constraints.
 *
 *	Caveats:
 *		This container stores much of the network address information internally
 *		using an "API" GCCNetworkAddress structure.  Any data referenced by
 *		pointers in this structure is stored in some other container.
 *		Therefore, the pointers held within the internal "API" structure are
 *		not valid and must not be accessed.
 *
 *	Author:
 *		blp/jbo
 */
#include <stdio.h>

#include "ms_util.h"
#include "netaddr.h"

/*
 * These macros are used to define the size constraints of an "nsap" address.
 */
#define		MINIMUM_NSAP_ADDRESS_SIZE		1
#define		MAXIMUM_NSAP_ADDRESS_SIZE		20

/*
 * These macros are used to verify that a network address has a valid number
 * of network address entities.
 */
#define		MINIMUM_NUMBER_OF_ADDRESSES		1
#define		MAXIMUM_NUMBER_OF_ADDRESSES		64

/*
 * These macros are used to define the size constraints of an extra dialing
 * string.
 */
#define		MINIMUM_EXTRA_DIALING_STRING_SIZE		1
#define		MAXIMUM_EXTRA_DIALING_STRING_SIZE		255



NET_ADDR::NET_ADDR(void)
:
    pszSubAddress(NULL),
    pwszExtraDialing(NULL),
    high_layer_compatibility(NULL),
    poszTransportSelector(NULL),
    poszNonStandardParam(NULL),
	object_key(NULL)
{
}


NET_ADDR::~NET_ADDR(void)
{
    switch (network_address.network_address_type)
    {
    case GCC_AGGREGATED_CHANNEL_ADDRESS:
		delete pszSubAddress;
		delete pwszExtraDialing;
		delete high_layer_compatibility;
        break;
    case GCC_TRANSPORT_CONNECTION_ADDRESS:
		delete poszTransportSelector;
        break;
    case GCC_NONSTANDARD_NETWORK_ADDRESS:
		delete poszNonStandardParam;
		if (NULL != object_key)
        {
            object_key->Release();
        }
        break;
    default:
        ERROR_OUT(("NET_ADDR::~NET_ADDR: unknown addr type=%u", (UINT) network_address.network_address_type));
        break;
	}
}


/*
 *	CNetAddrListContainer()
 *
 *	Public Function Description:
 * 		This constructor is used when creating a CNetAddrListContainer object with
 *		the "API" form of network address, GCCNetworkAddress.
 */
CNetAddrListContainer::
CNetAddrListContainer(UINT                 number_of_network_addresses,
                      PGCCNetworkAddress    *network_address_list,
                      PGCCError             return_value )  
:
    CRefCount(MAKE_STAMP_ID('N','t','A','L')),
    m_pSetOfNetAddrPDU(NULL),
    m_fValidNetAddrPDU(FALSE),
    m_cbDataSize(0)
{
	/*
	 * Initialize the instance variables.  The m_NetAddrItemList which
	 * will hold the network address data internally will be filled in by the
	 * call to StoreNetworkAddressList.
	 */

	/*
	 * Check to make sure a valid number of network addresses exist.
	 */
	if ((number_of_network_addresses < MINIMUM_NUMBER_OF_ADDRESSES)
			|| (number_of_network_addresses > MAXIMUM_NUMBER_OF_ADDRESSES))
	{
		ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: ERROR Invalid number of network addresses, %u", (UINT) number_of_network_addresses));
		*return_value = GCC_BAD_NETWORK_ADDRESS;
	}
	/*
	 * Check to make sure that the list pointer is valid.
	 */
	else if (network_address_list == NULL)
	{
		ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: ERROR NULL address list"));
		*return_value = GCC_BAD_NETWORK_ADDRESS;
	}
	/*
	 * Save the network address(es) in the internal structures.
	 */
	else
	{
		*return_value = StoreNetworkAddressList(number_of_network_addresses,
												network_address_list);
	}
}

/*
 *	CNetAddrListContainer()
 *
 *	Public Function Description:
 * 		This constructor is used when creating a CNetAddrListContainer object with
 *		the "PDU" form of network address, SetOfNetworkAddresses.
 */
CNetAddrListContainer::
CNetAddrListContainer(PSetOfNetworkAddresses    network_address_list, 
                      PGCCError                 return_value )
:
    CRefCount(MAKE_STAMP_ID('N','t','A','L')),
    m_pSetOfNetAddrPDU(NULL),
    m_fValidNetAddrPDU(FALSE),
    m_cbDataSize(0)
{
	PSetOfNetworkAddresses		network_address_ptr;

	/*
	 * Initialize the instance variables.  The m_NetAddrItemList which
	 * will hold the network address data internally will be filled in by the
	 * calls to ConvertPDUDataToInternal.
	 */

	*return_value = GCC_NO_ERROR;
	network_address_ptr = network_address_list;

	/*
	 * Loop through the set of network addresses, saving each in an internal
	 * NET_ADDR structure and saving those structures in the internal
	 * list.
	 */
	if (network_address_list != NULL)
	{
		while (1)
		{
			/*
			 * Convert each "PDU" network address into the internal form.  Note
			 * that object ID validation is not performed on data received as
			 * a PDU.  If a bad object ID comes in on the wire, this will be
			 * flagged as an allocation failure.
			 */
			if (ConvertPDUDataToInternal (network_address_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Error converting PDU data to internal"));
				*return_value = GCC_ALLOCATION_FAILURE;
				break;
			}
			else
            {
				network_address_ptr = network_address_ptr->next;
            }

			if (network_address_ptr == NULL)
				break;
		}
	}
}

/*
 *	CNetAddrListContainer()
 *
 *	Public Function Description:
 *		This is the copy constructor used to create a new CNetAddrListContainer
 *		object from an existing CNetAddrListContainer object. 
 */
CNetAddrListContainer::
CNetAddrListContainer(CNetAddrListContainer *address_list,
                      PGCCError		        pRetCode)
:
    CRefCount(MAKE_STAMP_ID('N','t','A','L')),
    m_pSetOfNetAddrPDU(NULL),
    m_fValidNetAddrPDU(FALSE),
    m_cbDataSize(0)
{
	NET_ADDR    				    *network_address_info;
	NET_ADDR	    			    *lpNetAddrInfo;
	GCCNetworkAddressType			network_address_type;
	GCCError						rc;

	/*
	 * Set up an iterator for the internal list of network addresses.
	 */
	address_list->m_NetAddrItemList.Reset();

    /*
	 * Copy each NET_ADDR structure contained in the 
	 * CNetAddrListContainer object to	be copied.
	 */
	while (NULL != (lpNetAddrInfo = address_list->m_NetAddrItemList.Iterate()))
	{
		/*
		 * Create a new NET_ADDR structure to hold each element of the
		 * new CNetAddrListContainer object.  Report an error if creation of this 
		 * structure fails.
		 */
		DBG_SAVE_FILE_LINE
		if (NULL == (network_address_info = new NET_ADDR))
		{
			ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create NET_ADDR"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

        /*
		 * First copy the GCCNetworkAddress structure contained in the
		 * internal NET_ADDR structure.  This copies all data
		 * except that referenced by pointers in the structure.
		 */
		network_address_info->network_address = lpNetAddrInfo->network_address;

		/*
		 * Next copy any data embedded in the network address that would 
		 * not have been copied in the above operation (typically pointers 
		 * to strings).
		 */

		/*
		 * This variable is used for abbreviation.
		 */
		network_address_type = lpNetAddrInfo->network_address.network_address_type;

		/*
		 * The network address is the "Aggregated" type.
		 */
        switch (network_address_type)
        {
        case GCC_AGGREGATED_CHANNEL_ADDRESS:
			/*
			 * If a sub-address string exists, store it in a Rogue Wave
			 * container.  Set the  structure pointer to NULL if one does 
			 * not exist.
			 */
			if (lpNetAddrInfo->pszSubAddress != NULL)
			{
				if (NULL == (network_address_info->pszSubAddress =
									::My_strdupA(lpNetAddrInfo->pszSubAddress)))
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create sub address"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->pszSubAddress = NULL;
            }
					
			/*
			 * If an extra dialing string exists, store it in a Unicode
			 * String object.  Set the  structure pointer to NULL if one 
			 * does not exist.
			 */
			if (lpNetAddrInfo->pwszExtraDialing != NULL)
			{
				if (NULL == (network_address_info->pwszExtraDialing =
									::My_strdupW(lpNetAddrInfo->pwszExtraDialing)))
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't creating extra dialing string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->pwszExtraDialing = NULL;
            }

			/*
			 * If a higher layer compatibility structure exists, store it 
			 * in a GCCHighLayerCompatibility structure.  Set the structure
			 * pointer to NULL if one does not exist.
			 */
			if (lpNetAddrInfo->high_layer_compatibility != NULL)
			{
				DBG_SAVE_FILE_LINE
				network_address_info->high_layer_compatibility = new GCCHighLayerCompatibility;
				if (network_address_info->high_layer_compatibility != NULL)
				{
					/*
					 * Copy the high layer compatibility data to the
					 * new structure.
					 */
					*network_address_info->high_layer_compatibility =  
							*(lpNetAddrInfo->high_layer_compatibility);
				}
				else
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Error creating new GCCHighLayerCompat"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->high_layer_compatibility = NULL;
            }
            break;

		/*
		 * The network address is the "Transport Connection" type.
		 */
        case GCC_TRANSPORT_CONNECTION_ADDRESS:
			/*
			 * If a transport selector exists, store it in a Rogue Wave 
			 * container.  Otherwise, set the structure pointer to NULL.
			 */
			if (lpNetAddrInfo->poszTransportSelector != NULL)
			{
				if (NULL == (network_address_info->poszTransportSelector =
									::My_strdupO(lpNetAddrInfo->poszTransportSelector)))
				{
					ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create transport selector"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->poszTransportSelector = NULL;
            }
            break;

		/*
		 * The network address is the "Non-Standard" type.
		 */
        case GCC_NONSTANDARD_NETWORK_ADDRESS:
			/*
			 * First store the non-standard parameter data in a Rogue Wave
			 * container.
			 */
			if (NULL == (network_address_info->poszNonStandardParam =
								::My_strdupO(lpNetAddrInfo->poszNonStandardParam)))
			{
				ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: can't create non-standard param"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}

			/*
			 * Next store the object key internally in an CObjectKeyContainer
			 * object.  Note that there is no need to report the error
			 * "BAD_NETWORK_ADDRESS" here since the object key data 
			 * would have been validated when the original network address
			 * was created.
			 */
			DBG_SAVE_FILE_LINE
			network_address_info->object_key = new CObjectKeyContainer(lpNetAddrInfo->object_key, &rc);
			if ((network_address_info->object_key == NULL) || (rc != GCC_NO_ERROR))
			{
				ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Error creating new CObjectKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
            break;

		/*
		 * The network address is of unknown type.  This should never be
		 * encountered so flag it as an allocation failure.
		 */
        default:
			ERROR_OUT(("CNetAddrListContainer::CNetAddrListContainer: Invalid type received as PDU"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		/*
		 * Go ahead and insert the pointer to the NET_ADDR
		 * structure into the internal Rogue Wave list.
		 */
		m_NetAddrItemList.Append(network_address_info);
	}

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete network_address_info;
    }

    *pRetCode = rc;
}


/*
 *	~CNetAddrListContainer()
 *
 *	Public Function Description:
 *		The destructor is used to free up any memory allocated during the life
 * 		of the object.
 */
CNetAddrListContainer::
~CNetAddrListContainer(void)
{
	
	/*
	 * Free any data allocated to hold "PDU" information.
	 */
	if (m_fValidNetAddrPDU)
    {
		FreeNetworkAddressListPDU();
    }

	/*
	 * Free any data allocated for the internal list of "info" structures.
	 */
	NET_ADDR *pNetAddrInfo;
	m_NetAddrItemList.Reset();
	while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
	{
		delete pNetAddrInfo;
	}
}


/*
 *	LockNetworkAddressList ()
 *
 *	Public Function Description:
 *		This routine is called to "Lock" the network address data in "API" form.
 *		The amount of memory required to hold the "API" data which is referenced
 *		by, but not included in the GCCNetworkAddress structure, will be
 *		returned. 
 *
 */
UINT CNetAddrListContainer::
LockNetworkAddressList(void)
{  
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data.  Otherwise, just increment the 
	 * lock count.
	 */
	if (Lock() == 1)
	{
    	PGCCNetworkAddress		network_address;
	    NET_ADDR    		    *lpNetAddrInfo;

		/*
		 * Set aside memory to hold the pointers to the GCCNetworkAddress
		 * structures as well as the structures themselves.  The "sizeof" the 
		 * structure must be rounded to an even four-byte boundary.
		 */
		m_cbDataSize = m_NetAddrItemList.GetCount() * 
				( sizeof(PGCCNetworkAddress) + ROUNDTOBOUNDARY(sizeof(GCCNetworkAddress)) );

		/*
		 * Loop through the list of network addresses, adding up the space
		 * requirements of each address.
		 */
		m_NetAddrItemList.Reset();
	 	while (NULL != (lpNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			/*
			 * Use a local variable to keep from having to access the Rogue Wave
			 * iterator repeatedly.
			 */
			network_address = &lpNetAddrInfo->network_address;

			/*
			 * Check to see what type of network address exists.
			 */
			switch (network_address->network_address_type)
            {
            case GCC_AGGREGATED_CHANNEL_ADDRESS:
				/*
				 * Add the length of the sub address string if it exists.
				 */
				if (lpNetAddrInfo->pszSubAddress != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(::lstrlenA(lpNetAddrInfo->pszSubAddress) + 1);
				}

				/*
				 * Add the size of the GCCExtraDialingString structure as well
				 * as the length of the extra dialing string if it exists.
				 */
				if (lpNetAddrInfo->pwszExtraDialing != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(sizeof(GCCExtraDialingString)) +
                                    ROUNDTOBOUNDARY((::lstrlenW(lpNetAddrInfo->pwszExtraDialing) + 1) * sizeof(WCHAR));
				}

				/*
				 * Add the size of the high layer compatibility structure if
				 * it exists.
				 */
				if (lpNetAddrInfo->high_layer_compatibility != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(sizeof(GCCHighLayerCompatibility));
				}
                break;

            case GCC_TRANSPORT_CONNECTION_ADDRESS:
				/*
				 * Add the size of the OSTR structure as well as the
				 * length of the octet string if it exists.
				 */
				if (lpNetAddrInfo->poszTransportSelector != NULL)
				{
					m_cbDataSize += ROUNDTOBOUNDARY(sizeof(OSTR)) +
					                ROUNDTOBOUNDARY(lpNetAddrInfo->poszTransportSelector->length); 
				}
                break;

            case GCC_NONSTANDARD_NETWORK_ADDRESS:
				/*
				 * Lock the object key in the non-standard parameter in order to
				 * determine the amount of memory needed to hold its data.
				 */
				m_cbDataSize += lpNetAddrInfo->object_key->LockObjectKeyData ();

				/*
				 * Add the space needed to hold the octet string data for the 
				 * non-standard parameter.
				 */
				m_cbDataSize += ROUNDTOBOUNDARY(lpNetAddrInfo->poszNonStandardParam->length);
                break;
			}
		}
	}

	return m_cbDataSize;
} 


/*
 *	GetNetworkAddressListAPI ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the list of network addresses in "API"
 *		form.
 */
UINT CNetAddrListContainer::
GetNetworkAddressListAPI(UINT				*	number_of_network_addresses,
                         PGCCNetworkAddress	**	network_address_list,
                         LPBYTE					memory)
{
	UINT					cbDataSizeToRet = 0;
	UINT					data_length = 0;
	UINT					network_address_counter = 0;
	PGCCNetworkAddress		network_address_ptr;
	NET_ADDR    		    *address_info;
	PGCCNetworkAddress		*address_array;

	/*
	 * If the user data has been locked, fill in the output parameters and
	 * the data referenced by the pointers.  Otherwise, report that the object
	 * has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		// NET_ADDR	*lpNetAddrInfo;

		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the number of network address entities and save a pointer to 
		 * the memory location passed in.  This is where the pointers to the 
		 * GCCNetworkAddress structures will be written.  The actual structures 
		 * will be written into memory immediately following the list of 
		 * pointers.
		 */
		*number_of_network_addresses = (UINT) m_NetAddrItemList.GetCount();

		*network_address_list = (PGCCNetworkAddress *)memory;
		address_array = *network_address_list;

		/*
		 * Save the amount of memory needed to hold the list of pointers as
		 * well as the actual network address structures.
		 */
		data_length = m_NetAddrItemList.GetCount() * sizeof(PGCCNetworkAddress);

		/*
		 * Move the memory pointer past the list of network address pointers.  
		 * This is where the first network address structure will be written.
		 */
		memory += data_length;

		/*
		 * Iterate through the internal list of NET_ADDR structures,
		 * building "API" GCCNetworkAddress structures in memory.
		 */
		m_NetAddrItemList.Reset();
		while (NULL != (address_info = m_NetAddrItemList.Iterate()))
		{
			/*
			 * Save the pointer to the network address structure in the list 
			 * of pointers.
			 */
			network_address_ptr = (PGCCNetworkAddress)memory;
			address_array[network_address_counter++] = network_address_ptr;

			/*
			 * Move the memory pointer past the network address structure.  
			 * This is where the network address data will be written.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCNetworkAddress));

			/*
			 * Check to see what type of network address this is and fill in 
			 * the user data structure.  Here the address is the aggregated
			 * channel type.
			 */
			switch (address_info->network_address.network_address_type)
            {
            case GCC_AGGREGATED_CHANNEL_ADDRESS:
				network_address_ptr->network_address_type =	GCC_AGGREGATED_CHANNEL_ADDRESS;

				/*
				 * Copy the transfer modes.
				 */
				network_address_ptr->u.aggregated_channel_address.transfer_modes = 
					address_info->network_address.u.aggregated_channel_address.transfer_modes;

				/*
				 * Copy the international number.
				 */
                ::lstrcpyA(network_address_ptr->u.aggregated_channel_address.international_number,
						   address_info->network_address.u.aggregated_channel_address.international_number);

				/*
				 * If the sub address string exists, set the sub address string
				 * pointer and write the data into memory.  Otherwise, set the
				 * "API" pointer to NULL.
				 */
				if (address_info->pszSubAddress != NULL)
				{
					network_address_ptr->u.aggregated_channel_address.sub_address_string = 
																(GCCCharacterString)memory;

					/*
					 * Now copy the sub-address string data from the internal 
					 * Rogue Wave string into memory.
					 */		
                    ::lstrcpyA((LPSTR) memory, address_info->pszSubAddress);

					/*
					 * Move the memory pointer past the sub-address string data.
					 * This is where the GCCExtraDialingString structure will be
					 * written.
					 */
					memory += ROUNDTOBOUNDARY(::lstrlenA(address_info->pszSubAddress) + 1);
				}
				else
				{
					/*
					 * No sub-address was present so set the pointer to NULL.
					 */
					network_address_ptr->u.aggregated_channel_address.sub_address_string = NULL;
				}

				/*
				 * If the extra dialing string exists, set the extra dialing
				 * string pointer and write the data into memory.  Otherwise,
				 * set the "API" pointer to NULL.
				 */
				if (address_info->pwszExtraDialing != NULL)
				{
					network_address_ptr->u.aggregated_channel_address.extra_dialing_string = 
							(PGCCExtraDialingString)memory;

					/*
					 * Move the memory pointer past the GCCExtraDialingString
					 * structure.  This is where the extra dialing string data 
					 * will	be written.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(GCCExtraDialingString));

					UINT cchExtraDialing = ::lstrlenW(address_info->pwszExtraDialing);
					network_address_ptr->u.aggregated_channel_address.extra_dialing_string->length = 
							(USHORT) cchExtraDialing;

					network_address_ptr->u.aggregated_channel_address.extra_dialing_string->value = 
																		(LPWSTR)memory;

					/*
					 * Now copy the hex string data from the internal Unicode 
					 * String into the allocated memory.
					 */
					//
					// LONCHANC: The size does not include null terminator in the original code.
					// could this be a bug???
					//
					::CopyMemory(memory, address_info->pwszExtraDialing, cchExtraDialing * sizeof(WCHAR));

					/*
					 * Move the memory pointer past the extra dialing string 
					 * data.  This is where the high layer compatibility 
					 * structure will be written.
					 */
					memory += ROUNDTOBOUNDARY(cchExtraDialing * sizeof(WCHAR));
				}
				else
				{
					/*
					 * No extra dialing string was present so set the pointer
					 * to NULL.
					 */
					network_address_ptr->u.aggregated_channel_address.extra_dialing_string = NULL;
				}

				/*
				 * If the high layer compatibility structure exists, set the 
				 * pointer and write the data into memory.  Otherwise, set
				 * the "API" pointer to NULL.
				 */
				if (address_info->high_layer_compatibility != NULL)
				{
					network_address_ptr->u.aggregated_channel_address.high_layer_compatibility = 
							(PGCCHighLayerCompatibility)memory;

					*network_address_ptr->u.aggregated_channel_address.high_layer_compatibility =
                            *(address_info->high_layer_compatibility);

					/*
					 * Move the memory pointer past the high layer 
					 * compatibility structure.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(GCCHighLayerCompatibility));
				}
				else
				{
					/*
					 * No high layer compatibility structure was present so 
					 * set the pointer to NULL.
					 */
					network_address_ptr->u.aggregated_channel_address.
							high_layer_compatibility = NULL;
				}
                break;

			/*
			 * The network address is a transport connection type.
			 */
            case GCC_TRANSPORT_CONNECTION_ADDRESS:
				network_address_ptr->network_address_type = GCC_TRANSPORT_CONNECTION_ADDRESS;

				/*
				 * Now copy the nsap address.
				 */		
                ::CopyMemory(network_address_ptr->u.transport_connection_address.nsap_address.value, 
							address_info->network_address.u.transport_connection_address.nsap_address.value, 
							address_info->network_address.u.transport_connection_address.nsap_address.length);

                network_address_ptr->u.transport_connection_address.nsap_address.length =
                            address_info->network_address.u.transport_connection_address.nsap_address.length; 

				/*
				 * If a transport selector exists, set the transport selector 
				 * pointer and write the data into memory.  Otherwise, set the
				 * "API" pointer to NULL.
				 */
				if (address_info->poszTransportSelector != NULL)
				{
					network_address_ptr->u.transport_connection_address.transport_selector = (LPOSTR) memory;

					/*
					 * Move the memory pointer past the OSTR 
					 * structure.  This is where the actual string data will 
					 * be written.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(OSTR));

					network_address_ptr->u.transport_connection_address.
							transport_selector->value = (LPBYTE)memory;

					network_address_ptr->u.transport_connection_address.
							transport_selector->length =
								address_info->poszTransportSelector->length;

					/*
					 * Now copy the transport selector string data from the 
					 * internal Rogue Wave string into memory.
					 */		
					::CopyMemory(memory, address_info->poszTransportSelector->value,
								address_info->poszTransportSelector->length);

					/*
					 * Move the memory pointer past the transport selector
					 * string data.
					 */
					memory += ROUNDTOBOUNDARY(address_info->poszTransportSelector->length);
				}
				else
				{
					network_address_ptr->u.transport_connection_address.transport_selector = NULL;
				}
                break;

			/*
			 * The network address is a non-standard type.
			 */
            case GCC_NONSTANDARD_NETWORK_ADDRESS:
				network_address_ptr->network_address_type = GCC_NONSTANDARD_NETWORK_ADDRESS;

				/*
				 * Check to make sure both elements of the non-standard address
				 * exist in the internal structure.
				 */
				if ((address_info->poszNonStandardParam == NULL) ||
						(address_info->object_key == NULL))
				{
					ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListAPI: Bad internal pointer"));
					cbDataSizeToRet = 0;
				}
				else
				{
					data_length = address_info->object_key->
							GetGCCObjectKeyData( &network_address_ptr->u.
							non_standard_network_address.object_key, 
							memory);

					/*
					 * Move the memory pointer past the object key data.  This 
					 * is where the octet string data will be written.
					 */
					memory += data_length;

					network_address_ptr->u.non_standard_network_address.parameter_data.value = 
							memory;

					/*
					 * Write the octet string data into memory and set the octet 
					 * string structure pointer and length.
					 */
					network_address_ptr->u.non_standard_network_address.parameter_data.length = 
								(USHORT) address_info->poszNonStandardParam->length;

					/*
					 * Now copy the octet string data from the internal Rogue 
					 * Wave string into the object key structure held in memory.
					 */		
					::CopyMemory(memory, address_info->poszNonStandardParam->value,
								address_info->poszNonStandardParam->length);

					/*
					 * Move the memory pointer past the octet string data.
					 */
					memory += ROUNDTOBOUNDARY(address_info->poszNonStandardParam->length);
				}
                break;

            default:
                ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListAPI: Error Bad type."));
                break;
            } // switch
        } // while
	}
	else
	{
    	*network_address_list = NULL;
		*number_of_network_addresses = 0;
		ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListAPI: Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnLockNetworkAddressList ()
 *
 *	Public Function Description:
 *		This routine unlocks any memory which has been locked for the "API" 
 *		form of the network address list.  If the "Free" flag has been set then
 * 		the CNetAddrListContainer object will be destroyed.
 *
 */
void CNetAddrListContainer::
UnLockNetworkAddressList(void)
{
	/*
	 * If the lock count has reached zero, this object is "unlocked" so do
	 * some cleanup.
	 */
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock any memory locked for the CObjectKeyContainer objects in the
		 * internal NET_ADDR structures.
		 */
		NET_ADDR *pNetAddrInfo;
		m_NetAddrItemList.Reset();
		while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			if (pNetAddrInfo->object_key != NULL)
			{
				pNetAddrInfo->object_key->UnLockObjectKeyData();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}
   

/*
 *	GetNetworkAddressListPDU ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the network address list in "PDU" form.
 */
GCCError CNetAddrListContainer::
GetNetworkAddressListPDU(PSetOfNetworkAddresses *set_of_network_addresses)
{
	GCCError					rc = GCC_NO_ERROR;
	PSetOfNetworkAddresses		new_pdu_network_address_ptr;
	PSetOfNetworkAddresses		old_pdu_network_address_ptr = NULL;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidNetAddrPDU == FALSE)
	{
		m_fValidNetAddrPDU = TRUE;

		/*
		 * Initialize the output parameter to NULL so that the first time
		 * through it will be set equal to the first new set of network address
		 * data created in the iterator loop.
		 */
		m_pSetOfNetAddrPDU = NULL;
		
		/*
		 * Iterate through the list of NET_ADDR structures, 
		 * converting each into "PDU" form and saving the pointers in the 
		 * linked list of "SetsOfNetworkAddresses".
		 */
		NET_ADDR *pNetAddrInfo;
		m_NetAddrItemList.Reset();
		while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			DBG_SAVE_FILE_LINE
			new_pdu_network_address_ptr = new SetOfNetworkAddresses;
			if (new_pdu_network_address_ptr == NULL)
			{
				ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListPDU: Allocation error, cleaning up"));
				rc = GCC_ALLOCATION_FAILURE;
				FreeNetworkAddressListPDU ();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfNetworkAddresses created.  On subsequent loops,
			 * set the structure's "next" pointer equal to the new structure.
			 */
			if (m_pSetOfNetAddrPDU == NULL)
            {
				m_pSetOfNetAddrPDU = new_pdu_network_address_ptr;
            }
			else
            {
				old_pdu_network_address_ptr->next = new_pdu_network_address_ptr;
            }

			old_pdu_network_address_ptr = new_pdu_network_address_ptr;

			/*
			 * Initialize the new "next" pointer to NULL.
			 */
			new_pdu_network_address_ptr->next = NULL;

			/*
			 * Call the routine to actually convert the network address.
			 */
			if (ConvertNetworkAddressInfoToPDU(pNetAddrInfo, new_pdu_network_address_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("CNetAddrListContainer::GetNetworkAddressListPDU: can't create NET_ADDR to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*set_of_network_addresses = m_pSetOfNetAddrPDU;

	return rc;
}


/*
 *	FreeNetworkAddressListPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the memory allocated for the "PDU" form
 *		of the network address list.
 */
GCCError CNetAddrListContainer::
FreeNetworkAddressListPDU(void)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfNetworkAddresses			pdu_network_address_set;
	PSetOfNetworkAddresses			next_pdu_network_address_set;

	if (m_fValidNetAddrPDU)
	{
		m_fValidNetAddrPDU = FALSE;

		pdu_network_address_set = m_pSetOfNetAddrPDU;

		/*
		 * Loop through the list, freeing the network address data associated 
		 * with each structure contained in the list. The only data allocated
		 * for the PDU which is not held in the internal info structure list
		 * is done by the CObjectKeyContainer object.  Those objects are told to free
		 * that data in the iterator loop below.
		 */
		while (pdu_network_address_set != NULL)
		{
			next_pdu_network_address_set = pdu_network_address_set->next;
			delete pdu_network_address_set;
			pdu_network_address_set = next_pdu_network_address_set;
		}

		/*
		 * Free any PDU memory allocated by the internal CObjectKeyContainer object.
		 */
		NET_ADDR *pNetAddrInfo;
		m_NetAddrItemList.Reset();
		while (NULL != (pNetAddrInfo = m_NetAddrItemList.Iterate()))
		{
			if (pNetAddrInfo->object_key != NULL)
            {
				pNetAddrInfo->object_key->FreeObjectKeyDataPDU();
            }
		}
	}
	else
	{
		ERROR_OUT(("NetAddressList::FreeUserDataListPDU: PDU Data not allocated"));
		rc = GCC_BAD_NETWORK_ADDRESS;
	}

	return (rc);
}

/*
 *	GCCError	StoreNetworkAddressList (	
 *						UINT					number_of_network_addresses,
 *						PGCCNetworkAddress 	*	local_network_address_list);
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to store the network address data passed in as
 *		"API" data in the internal structures.
 *
 *	Formal Parameters:
 *		number_of_network_addresses	(i)	Number of addresses in "API" list.
 *		local_network_address_list	(i) List of "API" addresses.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CNetAddrListContainer::
StoreNetworkAddressList(UINT					number_of_network_addresses,
						PGCCNetworkAddress 	*	local_network_address_list)
{
	GCCError						rc;
	NET_ADDR				        *network_address_info;
	PGCCNetworkAddress				network_address;
	UINT							i;
	
	/*
	 * For each network address in the list, create a new "info" structure to 
	 * buffer the data internally.  Fill in the structure and save it in the
	 * Rogue Wave list.
	 */
	for (i = 0; i < number_of_network_addresses; i++)
	{
		DBG_SAVE_FILE_LINE
		if (NULL == (network_address_info = new NET_ADDR))
		{
            ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't create NET_ADDR"));
			rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

		/*
		 * This variable is used for abbreviation.
		 */
		network_address = &network_address_info->network_address;
		
		/*
		 * Copy all the network address data into the network address
		 * structure that is part of the network address info structure.
		 */									
		*network_address = *local_network_address_list[i];
		
		/*
		 * This section of the code deals with any data embedded in the
		 * network address that would not have been copied in the above
		 * operation (typically pointers to strings).
		 */
		switch (network_address->network_address_type)
        {
        case GCC_AGGREGATED_CHANNEL_ADDRESS:
			/*
			 * Check to make sure the international number dialing string
			 * does not violate the imposed ASN.1 constraints.
			 */
			if (! IsDialingStringValid(local_network_address_list[i]->u.aggregated_channel_address.international_number))
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid international number"));
				rc = GCC_BAD_NETWORK_ADDRESS;
				goto MyExit;
			}

			/*
			 * If a sub-address string exists, store it in a Rogue Wave
			 * container.  Set the  structure pointer to NULL if one does 
			 * not exist.
			 */
			if (local_network_address_list[i]->u.aggregated_channel_address.sub_address_string != NULL)
			{
				/*
				 * Check to make sure the sub address string does not 
				 * violate the imposed ASN.1 constraints.
				 */
				if (! IsCharacterStringValid(local_network_address_list[i]->u.aggregated_channel_address.sub_address_string))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid sub address string"));
					rc = GCC_BAD_NETWORK_ADDRESS;
					goto MyExit;
				}

				/*			
				 * Create a  string to hold the sub address.
				 */
				if (NULL == (network_address_info->pszSubAddress = ::My_strdupA(
								(LPSTR) local_network_address_list[i]->u.aggregated_channel_address.sub_address_string)))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't creating new sub address string"));
					rc = GCC_ALLOCATION_FAILURE;
                    goto MyExit;
				}
			}
			else
            {
				network_address_info->pszSubAddress = NULL;
            }

            /*
			 * If an extra dialing string exists, store it in a Unicode
			 * String object.  Set the  structure pointer to NULL if one 
			 * does not exist.
			 */
			if (local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string != NULL)
			{
				/*
				 * Check to make sure the extra dialing string does not 
				 * violate the imposed ASN.1 constraints.
				 */
				if (! IsExtraDialingStringValid(local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid extra dialing string"));
					rc = GCC_BAD_NETWORK_ADDRESS;
					goto MyExit;
				}

				if (NULL == (network_address_info->pwszExtraDialing = ::My_strdupW2(
								local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string->length,
								local_network_address_list[i]->u.aggregated_channel_address.extra_dialing_string->value)))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Error creating extra dialing string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->pwszExtraDialing = NULL;
            }

			/*
			 * If a higher layer compatibility structure exists, store it 
			 * in a GCCHighLayerCompatibility structure.  Set the structure
			 * pointer to NULL if one does not exist.
			 */
			if (local_network_address_list[i]->u.aggregated_channel_address.high_layer_compatibility != NULL)
			{
				DBG_SAVE_FILE_LINE
				network_address_info->high_layer_compatibility = new GCCHighLayerCompatibility;
				if (network_address_info->high_layer_compatibility != NULL)
				{
					/*
					 * Copy the high layer compatibility data to the
					 * new structure.
					 */
					*network_address_info->high_layer_compatibility =  
							*(local_network_address_list[i]->u.aggregated_channel_address.high_layer_compatibility);
				}
				else
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Error creating new GCCHighLayerCompatibility"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
            {
				network_address_info->high_layer_compatibility = NULL;
            }
            break;

        case GCC_TRANSPORT_CONNECTION_ADDRESS:
			/*
			 * Check to make sure the length of the nsap address is within
			 * the allowable range.
			 */
			if ((local_network_address_list[i]->u.transport_connection_address.nsap_address.length < MINIMUM_NSAP_ADDRESS_SIZE)
                ||
				(local_network_address_list[i]->u.transport_connection_address.nsap_address.length > MAXIMUM_NSAP_ADDRESS_SIZE))
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: Invalid nsap address"));
				rc = GCC_BAD_NETWORK_ADDRESS;
				goto MyExit;
			}

			/*
			 * If a transport selector exists, store it in a Rogue Wave 
			 * string.  Otherwise, set the structure pointer to NULL.
			 */
			if (local_network_address_list[i]->u.transport_connection_address.transport_selector != NULL)
			{
				/*			
				 * Create a Rogue Wave string to hold the transport
				 * selector string.
				 */
				if (NULL == (network_address_info->poszTransportSelector = ::My_strdupO2(
								local_network_address_list[i]->u.transport_connection_address.transport_selector->value,
						 		local_network_address_list[i]->u.transport_connection_address.transport_selector->length)))
				{
					ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't create transport selector"));
					rc = GCC_ALLOCATION_FAILURE;
                    goto MyExit;
				}
			}
			else
            {
				network_address_info->poszTransportSelector = NULL;
            }
            break;

        case GCC_NONSTANDARD_NETWORK_ADDRESS:
			/*			
			 * Create a Rogue Wave string to hold the non-standard
			 * parameter octet string.
			 */
			if (NULL == (network_address_info->poszNonStandardParam = ::My_strdupO2(
								local_network_address_list[i]->u.non_standard_network_address.parameter_data.value,
					 			local_network_address_list[i]->u.non_standard_network_address.parameter_data.length)))
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetworkAddressList: can't create non-standard param"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		
			/*
			 * Next store the object key internally in an CObjectKeyContainer
			 * object.
			 */
			DBG_SAVE_FILE_LINE
			network_address_info->object_key = new CObjectKeyContainer(
					&local_network_address_list[i]->u.non_standard_network_address.object_key,
					&rc);
			if (network_address_info->object_key == NULL || rc != GCC_NO_ERROR)
			{
				ERROR_OUT(("CNetAddrListContainer::StoreNetAddrList: Error creating new CObjectKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
            break;

        default:
			ERROR_OUT(("CNetAddrListContainer::StoreNetAddrList: bad network address type=%u", (UINT) network_address->network_address_type));
			rc = GCC_BAD_NETWORK_ADDRESS_TYPE;
			goto MyExit;
		}

		/*
		 * If all data was properly saved, insert the "info" structure
		 * pointer into the Rogue Wave list.
		 */
		m_NetAddrItemList.Append(network_address_info);
	} // for

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete network_address_info;
    }

    return rc;
}

/*
 *	GCCError	ConvertPDUDataToInternal (	
 *						PSetOfNetworkAddresses			network_address_ptr)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to store the network address data passed in as
 *		"PDU" data in the internal structures.
 *
 *	Formal Parameters:
 *		network_address_ptr	(i) 	"PDU" address list structure.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CNetAddrListContainer::
ConvertPDUDataToInternal(PSetOfNetworkAddresses network_address_ptr)
{
	GCCError					rc;
	GCCError					error_value;
	NET_ADDR    			    *network_address_info_ptr;
	PGCCNetworkAddress			copy_network_address;
	PNetworkAddress				pdu_network_address;

	/*
	 * Create a new info structure to hold the data internally.
	 */
	DBG_SAVE_FILE_LINE
	if (NULL == (network_address_info_ptr = new NET_ADDR))
	{
		ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create NET_ADDR"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

    /*
	 * Use these variables for clarity and brevity.
	 */
	copy_network_address = &network_address_info_ptr->network_address;
	pdu_network_address = &network_address_ptr->value; 

	/*
	 * Check to see what type of network address exists and save the data
	 * in the internal structures.
	 */
	switch (pdu_network_address->choice)
    {
    case AGGREGATED_CHANNEL_CHOSEN:
		copy_network_address->network_address_type = GCC_AGGREGATED_CHANNEL_ADDRESS;

		/*
		 * Save the tranfer modes structure.
		 */
		ConvertTransferModesToInternal(
				&pdu_network_address->u.aggregated_channel.transfer_modes,
				&copy_network_address->u.aggregated_channel_address.transfer_modes);
						
		/*
		 * Save the international number.
		 */
        ::lstrcpyA(copy_network_address->u.aggregated_channel_address.international_number,
					pdu_network_address->u.aggregated_channel.international_number);
						
		/*
		 * Save the sub address string (if it exists) in the Rogue Wave
		 * buffer contained in the network info structure.  Otherwise, set
		 * the structure pointer to NULL.
		 */
		if (pdu_network_address->u.aggregated_channel.bit_mask & SUB_ADDRESS_PRESENT)
		{
			/*			
			 * Create a Rogue Wave string to hold the sub address string.
			 */
			if (NULL == (network_address_info_ptr->pszSubAddress = ::My_strdupA(
								pdu_network_address->u.aggregated_channel.sub_address)))
			{
				ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create sub address string"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		}
		else
		{
			/*
			 * The sub address string is not present so set the internal
			 * info structure pointer to NULL.
			 */
			network_address_info_ptr->pszSubAddress = NULL;
		}

		/*
		 * Next save the extra dialing string if one exists.
		 */
		if (pdu_network_address->u.aggregated_channel.bit_mask & EXTRA_DIALING_STRING_PRESENT)
		{
			if (NULL == (network_address_info_ptr->pwszExtraDialing = ::My_strdupW2(
							pdu_network_address->u.aggregated_channel.extra_dialing_string.length,
							pdu_network_address->u.aggregated_channel.extra_dialing_string.value)))
			{
				ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error creating extra dialing string"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		}
		else
		{
			/*
			 * The extra dialing string is not present so set the internal
			 * info structure pointer to NULL.
			 */
			network_address_info_ptr->pwszExtraDialing = NULL;
		}

		/*
		 * Save the high layer compatibility structure if it is present.
		 */
		if (pdu_network_address->u.aggregated_channel.bit_mask & HIGH_LAYER_COMPATIBILITY_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			network_address_info_ptr->high_layer_compatibility = new GCCHighLayerCompatibility;
			if (network_address_info_ptr->high_layer_compatibility != NULL)
			{
				/*
				 * Copy the high layer compatibility data to the
				 * new structure.
				 */
				ConvertHighLayerCompatibilityToInternal(
						&pdu_network_address->u.aggregated_channel.high_layer_compatibility,
						network_address_info_ptr->high_layer_compatibility);
			}
			else
			{
				ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error creating new GCCHighLayerCompatibility"));
				rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
			}
		}
		else
		{
			/*
			 * The high layer compatibility structure is not present so set
			 * the internal	info structure pointer to NULL.
			 */
			network_address_info_ptr->high_layer_compatibility = NULL;
		}
        break;

    /*
     * Save the transport connection address.
     */
    case TRANSPORT_CONNECTION_CHOSEN:
	    copy_network_address->network_address_type = GCC_TRANSPORT_CONNECTION_ADDRESS;

	    /*
	     * Save the nsap address by copying the length and then the string.
	     */
	    copy_network_address->u.transport_connection_address.nsap_address.length =
                pdu_network_address->u.transport_connection.nsap_address.length;

        ::lstrcpyA((LPSTR)copy_network_address->u.transport_connection_address.nsap_address.value,
				    (LPSTR)pdu_network_address->u.transport_connection.nsap_address.value);
	    /*
	     * Save the transport selector if one exists.
	     */
	    if (pdu_network_address->u.transport_connection.bit_mask & TRANSPORT_SELECTOR_PRESENT)
	    {
		    /*			
		     * Create a Rogue Wave string to hold the transport
		     * selector string.
		     */
		    if (NULL == (network_address_info_ptr->poszTransportSelector = ::My_strdupO2(
						    pdu_network_address->u.transport_connection.transport_selector.value,
					 	    pdu_network_address->u.transport_connection.transport_selector.length)))
		    {
			    ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create transport selector"));
			    rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
		    }
	    }
	    else
	    {
		    /*
		     * The transport selector is not present so set the internal
		     * info structure pointer to NULL.
		     */
		    network_address_info_ptr->poszTransportSelector = NULL;
	    }
        break;

    /*
     * Save the non standard address.
     */
    case ADDRESS_NON_STANDARD_CHOSEN:
	    copy_network_address->network_address_type = GCC_NONSTANDARD_NETWORK_ADDRESS;

	    /*			
	     * Create a Rogue Wave string to hold the non-standard
	     * parameter octet string.
	     */
	    if (NULL == (network_address_info_ptr->poszNonStandardParam = ::My_strdupO2(
						    pdu_network_address->u.address_non_standard.data.value,
				 		    pdu_network_address->u.address_non_standard.data.length)))
	    {
		    ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: can't create non-standard param"));
		    rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
	    }

	    /*
	     * Next store the object key internally in an CObjectKeyContainer
	     * object.
	     */
	    DBG_SAVE_FILE_LINE
	    network_address_info_ptr->object_key = new CObjectKeyContainer(
			    &pdu_network_address->u.address_non_standard.key,
			    &error_value);
	    if ((network_address_info_ptr->object_key == NULL) ||
			    (error_value != GCC_NO_ERROR))
	    {
		    ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error creating new CObjectKeyContainer"));
		    rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
	    }
        break;

    default:
        ERROR_OUT(("CNetAddrListContainer::ConvertPDUDataToInternal: Error bad network address type"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    } // switch

    /*
	 * Go ahead and save the pointer to the info structure in the 
	 * internal Rogue Wave list.
	 */
	m_NetAddrItemList.Append(network_address_info_ptr);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete network_address_info_ptr;
    }

	return rc;
}

/*
 * GCCError		ConvertNetworkAddressInfoToPDU (
 *						NET_ADDR    			    *network_address_info_ptr,
 *						PSetOfNetworkAddresses		network_address_pdu_ptr)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the network address info structures
 *		maintained internally into the "PDU" form which is a 
 *		SetOfNetworkAddresses.
 *
 *	Formal Parameters:
 *		network_address_info_ptr	(i) Internal network address structure.
 *		network_address_pdu_ptr		(o) PDU network address structure to fill in
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error converting the network address
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CNetAddrListContainer::
ConvertNetworkAddressInfoToPDU(NET_ADDR    			    *network_address_info_ptr,
                               PSetOfNetworkAddresses   network_address_pdu_ptr)
{
	GCCError				rc = GCC_NO_ERROR;
	PGCCNetworkAddress		api_ptr;
	PNetworkAddress			pdu_ptr;

	/*
	 * This variable will point to the "API" network address structure held in 
	 * the internal info structure.  It is used for brevity.
	 */
	api_ptr = &network_address_info_ptr->network_address;

	/*
	 * This variable will point to the "PDU" network address structure held in 
	 * the "SetOfNetworkAddresses" structure.  It is used for brevity.
	 */
	pdu_ptr = &network_address_pdu_ptr->value;

	/*
	 * Check to see what type of network address exists.  Fill in the
	 * appropriate form of the network address PDU structure.
	 */
	switch (api_ptr->network_address_type)
    {
    case GCC_AGGREGATED_CHANNEL_ADDRESS:
		/*
		 * Fill in the aggregated channel address PDU structure.
		 */
		pdu_ptr->choice = AGGREGATED_CHANNEL_CHOSEN;

		pdu_ptr->u.aggregated_channel.bit_mask = 0;

		/*
		 * Convert the structure holding the transfer modes into PDU form.
		 */
		ConvertTransferModesToPDU(&api_ptr->u.aggregated_channel_address.transfer_modes,
								  &pdu_ptr->u.aggregated_channel.transfer_modes);
		/*
		 * Copy the international number string.
		 */
        ::lstrcpyA(pdu_ptr->u.aggregated_channel.international_number,
				   api_ptr->u.aggregated_channel_address.international_number);

		/*
		 * Copy the sub-address string if it is present.  Set the bit mask in
		 * the PDU structure indicating that a sub-address string is present.
		 */
		if (network_address_info_ptr->pszSubAddress != NULL)
		{
			pdu_ptr->u.aggregated_channel.bit_mask |= SUB_ADDRESS_PRESENT;
            ::lstrcpyA((LPSTR) pdu_ptr->u.aggregated_channel.sub_address, 
					   network_address_info_ptr->pszSubAddress);
		}

		/* 
		 * Copy the extra dialing string if it is present.  Set the bit mask in
		 * the PDU structure indicating that an extra dialing string is present.
		 */
		if (network_address_info_ptr->pwszExtraDialing != NULL)
		{
			pdu_ptr->u.aggregated_channel.bit_mask |= EXTRA_DIALING_STRING_PRESENT;

			pdu_ptr->u.aggregated_channel.extra_dialing_string.value = 
					network_address_info_ptr->pwszExtraDialing;

			pdu_ptr->u.aggregated_channel.extra_dialing_string.length = 
					::lstrlenW(network_address_info_ptr->pwszExtraDialing);
		}

		/*
		 * Convert the structure holding the high layer compatibilities into 
		 * PDU form, if it is present.  Set the bit mask in	the PDU structure 
		 * indicating that a high layer compatibility structure is present.
		 */
		if (network_address_info_ptr->high_layer_compatibility != NULL)
		{
			pdu_ptr->u.aggregated_channel.bit_mask |= HIGH_LAYER_COMPATIBILITY_PRESENT;

			ConvertHighLayerCompatibilityToPDU(
					network_address_info_ptr->high_layer_compatibility,
					&pdu_ptr->u.aggregated_channel.high_layer_compatibility);
		}
        break;

    case GCC_TRANSPORT_CONNECTION_ADDRESS:
		/*
		 * Fill in the transport connection address PDU structure.
		 */
		pdu_ptr->choice = TRANSPORT_CONNECTION_CHOSEN;

		/*
		 * Copy the nsap_address.
		 */
		pdu_ptr->u.transport_connection.nsap_address.length = 
				api_ptr->u.transport_connection_address.nsap_address.length;
				
        ::lstrcpyA((LPSTR)pdu_ptr->u.transport_connection.nsap_address.value,
				   (LPSTR)api_ptr->u.transport_connection_address.nsap_address.value);
				
		/*
		 * Copy the transport selector if it is present.  Set the bit mask in
		 * the PDU structure indicating that a transport selector is present.
		 */
		if (network_address_info_ptr->poszTransportSelector != NULL)
		{
			pdu_ptr->u.transport_connection.bit_mask |= TRANSPORT_SELECTOR_PRESENT;

			pdu_ptr->u.transport_connection.transport_selector.length =
					network_address_info_ptr->poszTransportSelector->length;

			pdu_ptr->u.transport_connection.transport_selector.value = 
					(LPBYTE) network_address_info_ptr->poszTransportSelector->value;
		}
        break;

    case GCC_NONSTANDARD_NETWORK_ADDRESS:
		/*
		 * Fill in the non-standard network address PDU structure.
		 */
		pdu_ptr->choice = ADDRESS_NON_STANDARD_CHOSEN;

		/*
		 * Fill in the data portion of the non-standard parameter.
		 */
		pdu_ptr->u.address_non_standard.data.length = 
				network_address_info_ptr->poszNonStandardParam->length;

        pdu_ptr->u.address_non_standard.data.value = 
				network_address_info_ptr->poszNonStandardParam->value;

		/*
		 * Now fill in the object key portion of the non-standard parameter
		 * using the CObjectKeyContainer object stored internally in the network
		 * address info structure.
		 */
		rc = network_address_info_ptr->object_key->GetObjectKeyDataPDU(&pdu_ptr->u.address_non_standard.key);
		if (rc != GCC_NO_ERROR)
		{
			ERROR_OUT(("CNetAddrListContainer::ConvertNetworkAddressInfoToPDU: Error getting object key data PDU"));
		}
        break;

    default:
        /*
		 * The constructors will check to make sure a valid network address
		 * type exists so this should never be encountered.
		 */
		ERROR_OUT(("CNetAddrListContainer::ConvertNetworkAddressInfoToPDU: Error bad network address type"));
		rc = GCC_ALLOCATION_FAILURE;
	}

	return rc;
}

/*
 *	void		ConvertTransferModesToInternal (
 *						PTransferModes				source_transfer_modes,
 *						PGCCTransferModes			copy_transfer_modes)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the PDU network address transfer modes
 *		structure into the internal form where the structure is saved as a
 *		GCCTranferModes structure.
 *
 *	Formal Parameters:
 *		source_transfer_modes	(i)	Structure holding "PDU" transfer modes.
 *		copy_transfer_modes		(o) Structure to hold "API" transfer modes.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertTransferModesToInternal(PTransferModes       source_transfer_modes,
                               PGCCTransferModes    copy_transfer_modes)
{
	copy_transfer_modes->speech = (BOOL) source_transfer_modes->speech;
	copy_transfer_modes->voice_band = (BOOL) source_transfer_modes->voice_band;
	copy_transfer_modes->digital_56k = (BOOL) source_transfer_modes->digital_56k;
	copy_transfer_modes->digital_64k = (BOOL) source_transfer_modes->digital_64k;
	copy_transfer_modes->digital_128k = (BOOL) source_transfer_modes->digital_128k;
	copy_transfer_modes->digital_192k = (BOOL) source_transfer_modes->digital_192k;
	copy_transfer_modes->digital_256k = (BOOL) source_transfer_modes->digital_256k;
	copy_transfer_modes->digital_320k = (BOOL) source_transfer_modes->digital_320k;
	copy_transfer_modes->digital_384k = (BOOL) source_transfer_modes->digital_384k;
	copy_transfer_modes->digital_512k = (BOOL) source_transfer_modes->digital_512k;
	copy_transfer_modes->digital_768k = (BOOL) source_transfer_modes->digital_768k;
	copy_transfer_modes->digital_1152k = (BOOL) source_transfer_modes->digital_1152k;
	copy_transfer_modes->digital_1472k = (BOOL) source_transfer_modes->digital_1472k;
	copy_transfer_modes->digital_1536k = (BOOL) source_transfer_modes->digital_1536k;
	copy_transfer_modes->digital_1920k = (BOOL) source_transfer_modes->digital_1920k;
	copy_transfer_modes->packet_mode = (BOOL) source_transfer_modes->packet_mode;
	copy_transfer_modes->frame_mode = (BOOL) source_transfer_modes->frame_mode;
	copy_transfer_modes->atm = (BOOL) source_transfer_modes->atm;
}

/*
 *	void		ConvertHighLayerCompatibilityToInternal (
 *					PHighLayerCompatibility				source_structure,
 *					PGCCHighLayerCompatibility			copy_structure)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the PDU network address high layer
 *		compatibility structure into the internal form where the structure is 
 *		saved as a GCCHighLayerCompatibility structure.
 *
 *	Formal Parameters:
 *		source_structure		(i)	Structure holding "PDU" high layer 
 *										compatibilities.
 *		copy_structure			(o) Structure to hold "API" high layer 
 *										compatibilities.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertHighLayerCompatibilityToInternal(PHighLayerCompatibility     source_structure,
                                        PGCCHighLayerCompatibility  copy_structure)
{
	copy_structure->telephony3kHz = (BOOL) source_structure->telephony3kHz;
	copy_structure->telephony7kHz = (BOOL) source_structure->telephony7kHz;
	copy_structure->videotelephony = (BOOL) source_structure->videotelephony;
	copy_structure->videoconference = (BOOL) source_structure->videoconference;
	copy_structure->audiographic = (BOOL) source_structure->audiographic;
	copy_structure->audiovisual = (BOOL) source_structure->audiovisual;
	copy_structure->multimedia = (BOOL) source_structure->multimedia;
}

/*
 *	void		ConvertTransferModesToPDU (
 *					PGCCTransferModes					source_transfer_modes,
 *					PTransferModes						copy_transfer_modes)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the API network address transfer modes
 *		structure into the PDU form which is a TranferModes structure.
 *
 *	Formal Parameters:
 *		source_transfer_modes	(i)	Structure holding "API" transfer modes.
 *		copy_transfer_modes		(i) Structure holding "PDU" transfer modes.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertTransferModesToPDU(PGCCTransferModes     source_transfer_modes,
                          PTransferModes        copy_transfer_modes)
{
	copy_transfer_modes->speech = (ASN1bool_t) source_transfer_modes->speech;
	copy_transfer_modes->voice_band = (ASN1bool_t) source_transfer_modes->voice_band;
	copy_transfer_modes->digital_56k = (ASN1bool_t) source_transfer_modes->digital_56k;
	copy_transfer_modes->digital_64k = (ASN1bool_t) source_transfer_modes->digital_64k;
	copy_transfer_modes->digital_128k = (ASN1bool_t) source_transfer_modes->digital_128k;
	copy_transfer_modes->digital_192k = (ASN1bool_t) source_transfer_modes->digital_192k;
	copy_transfer_modes->digital_256k = (ASN1bool_t) source_transfer_modes->digital_256k;
	copy_transfer_modes->digital_320k = (ASN1bool_t) source_transfer_modes->digital_320k;
	copy_transfer_modes->digital_384k = (ASN1bool_t) source_transfer_modes->digital_384k;
	copy_transfer_modes->digital_512k = (ASN1bool_t) source_transfer_modes->digital_512k;
	copy_transfer_modes->digital_768k = (ASN1bool_t) source_transfer_modes->digital_768k;
	copy_transfer_modes->digital_1152k = (ASN1bool_t) source_transfer_modes->digital_1152k;
	copy_transfer_modes->digital_1472k = (ASN1bool_t) source_transfer_modes->digital_1472k;
	copy_transfer_modes->digital_1536k = (ASN1bool_t) source_transfer_modes->digital_1536k;
	copy_transfer_modes->digital_1920k = (ASN1bool_t) source_transfer_modes->digital_1920k;
	copy_transfer_modes->packet_mode = (ASN1bool_t) source_transfer_modes->packet_mode;
	copy_transfer_modes->frame_mode = (ASN1bool_t) source_transfer_modes->frame_mode;
	copy_transfer_modes->atm = (ASN1bool_t) source_transfer_modes->atm;
}

/*
 *	void		ConvertHighLayerCompatibilityToPDU (
 *					PGCCHighLayerCompatibility				source_structure,
 *					PHighLayerCompatibility					copy_structure)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to convert the API network address high layer
 *		compatibility structure into the PDU form which is a 
 *		HighLayerCompatibility structure.
 *
 *	Formal Parameters:
 *		source_structure		(i)	Structure holding "API" high layer 
 *										compatibilities.
 *		copy_structure			(o) Structure to hold "PDU" high layer 
 *										compatibilities.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CNetAddrListContainer::
ConvertHighLayerCompatibilityToPDU(PGCCHighLayerCompatibility   source_structure,
                                   PHighLayerCompatibility      copy_structure)
{
	copy_structure->telephony3kHz = (ASN1bool_t) source_structure->telephony3kHz;
	copy_structure->telephony7kHz = (ASN1bool_t) source_structure->telephony7kHz;
	copy_structure->videotelephony = (ASN1bool_t) source_structure->videotelephony;
	copy_structure->videoconference = (ASN1bool_t) source_structure->videoconference;
	copy_structure->audiographic = (ASN1bool_t) source_structure->audiographic;
	copy_structure->audiovisual = (ASN1bool_t) source_structure->audiovisual;
	copy_structure->multimedia = (ASN1bool_t) source_structure->multimedia;
}

/*
 *	BOOL    	IsDialingStringValid ( GCCDialingString		dialing_string)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to ensure that the values held within a
 *		dialing string do not violate the imposed ASN.1 constraints.  The
 *		dialing string is constrained to be digits between 0 and 9, inclusive.
 *
 *	Formal Parameters:
 *		dialing_string		(i)	Dialing string to validate. 
 *
 *	Return Value:
 *		TRUE				- The string is valid.
 *		FALSE				- The string violates the ASN.1 constraints.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CNetAddrListContainer::
IsDialingStringValid(GCCDialingString dialing_string)
{
	BOOL fRet = TRUE;
	
	while (*dialing_string != 0)
	{
		if ((*dialing_string < '0') || (*dialing_string > '9'))
		{
			fRet = FALSE;
			break;
		}
		dialing_string++;
	}

	return fRet;
}

/*
 *	BOOL    	IsCharacterStringValid (
 *								GCCCharacterString			character_string)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to ensure that the values held within a
 *		character string do not violate the imposed ASN.1 constraints.  The
 *		character string is constrained to be digits between 0 and 9, inclusive.
 *
 *	Formal Parameters:
 *		character_string		(i)	Character string to validate. 
 *
 *	Return Value:
 *		TRUE				- The string is valid.
 *		FALSE				- The string violates the ASN.1 constraints.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CNetAddrListContainer::
IsCharacterStringValid(GCCCharacterString character_string)
{
	BOOL fRet = TRUE;
	
	while (*character_string != 0)
	{
		if ((*character_string < '0') || (*character_string > '9'))
		{
			fRet = FALSE;
			break;
		}
	
		character_string++;
	}
	
	return fRet;
}

/*
 *	BOOL    	IsExtraDialingStringValid (
 *							PGCCExtraDialingString		extra_dialing_string)
 *
 *	Private member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to ensure that the values held within an
 *		extra dialing string do not violate the imposed ASN.1 constraints.
 *
 *	Formal Parameters:
 *		extra_dialing_string		(i)	Dialing string to validate. 
 *
 *	Return Value:
 *		TRUE				- The string is valid.
 *		FALSE				- The string violates the ASN.1 constraints.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CNetAddrListContainer::
IsExtraDialingStringValid(PGCCExtraDialingString extra_dialing_string)
{
	BOOL fRet = TRUE;

	/*
	 * Check to make sure the length of the string is within the
	 * allowable range.
	 */
	if ((extra_dialing_string->length < MINIMUM_EXTRA_DIALING_STRING_SIZE) || 
		(extra_dialing_string->length > MAXIMUM_EXTRA_DIALING_STRING_SIZE))
	{
		fRet = FALSE;
	}
    else
    {
	    /*
	     * If the length is valid, check the string values.
	     */
    	LPWSTR pwsz = extra_dialing_string->value;
		for (USHORT i = 0; i < extra_dialing_string->length; i++)
		{
			if ((*pwsz != '#') && (*pwsz != '*') && (*pwsz != ','))
			{
				if ((*pwsz < '0') || (*pwsz > '9'))
				{
					fRet = FALSE;
					break;
				}
			}
		
			pwsz++;
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\ogcccode.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	ogcccode.cpp
 *	
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CGCCCoder class.  This class
 *		is responsible for encoding and decoding GCC (T.124) PDU's using ASN.1 
 *		encoding rules via the ASN.1 toolkit.  This class is also capable
 *		of determining the size of both the encoded and decoded PDU's. 
 *
 *	Static Variables:
 *
 *	Caveats:
 *		Only one instance of this class should be in existance at any one time
 *		due to the static variable.
 *
 *	Author:
 *		John B. O'Nan
 */

/*
 *	External Interfaces
 */
#include <string.h>
#include "ogcccode.h"

/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
CGCCCoder	*g_GCCCoder;

/*
 *	CGCCCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the CGCCCoder class.  It initializes
 *		the ASN.1 encoder/decoder and sets the encoding rules to the
 *		Packed-Aligned variant.
 */
CGCCCoder::CGCCCoder ()
:m_pEncInfo(NULL),
 m_pDecInfo(NULL)
{
// lonchanc: We should move Init out of constructor. However,
// to minimize the changes in the GCC/MCS code, we put it here for now.
// Otherwise, we need to change MCS and Packet interfaces.
// We will move it out and call Init() separately.
	Init();
}

BOOL CGCCCoder::Init ( void )
{
	BOOL fRet = FALSE;
	GCCPDU_Module_Startup();
	if (GCCPDU_Module != NULL)
	{
		if (ASN1_CreateEncoder(
                            GCCPDU_Module,	// ptr to mdule
                            &m_pEncInfo,	// ptr to encoder info
                            NULL,			// buffer ptr
                            0,				// buffer size
                            NULL)			// parent ptr
			== ASN1_SUCCESS)
		{
			ASSERT(m_pEncInfo != NULL);
			fRet = (ASN1_CreateDecoder(
                                GCCPDU_Module,	// ptr to mdule
                                &m_pDecInfo,	// ptr to decoder info
                                NULL,			// buffer ptr
                                0,				// buffer size
                                NULL)			// parent ptr
					== ASN1_SUCCESS);
			ASSERT(fRet && m_pDecInfo != NULL);
		}
	}
	ASSERT(fRet);
	return fRet;
}

/*
 *	~CGCCCoder ()
 *
 *	Public Functional Description:
 *		This is a virtual destructor.  It is used to clean up after ASN.1.
 */
CGCCCoder::~CGCCCoder ()
{
	if (GCCPDU_Module != NULL)
	{
	    ASN1_CloseEncoder(m_pEncInfo);
	    ASN1_CloseDecoder(m_pDecInfo);
	    GCCPDU_Module_Cleanup();
	}
}

/*
 *	Encode ()
 *
 *	Public Functional Description:
 *		This function encodes GCC Protocol Data Units (PDU's) into ASN.1 
 *		compliant byte streams using the ASN.1 toolkit.
 *		The coder allocates the buffer space for the encoded data.
 */
BOOL	CGCCCoder::Encode(LPVOID		pdu_structure,
							int			pdu_type,
							UINT		nEncodingRule_not_used,
							LPBYTE		*encoding_buffer,
							UINT		*encoding_buffer_length)
{
	BOOL			fRet = FALSE;
	int				return_value;
	ConnectData		connect_data_structure;

	// clean up local buffer pointer
	connect_data_structure.connect_pdu.value = NULL;

	/*
	 * If the PDU to be encoded is a "ConnectGCC" PDU we must first encode the
	 * "ConnectGCC" PDU.  A "ConnectData" PDU structure is then built which 
	 * contains the encoded "ConnectGCC" PDU along with object identifier key.  
	 * The "ConnectData" PDU is then encoded into the provided buffer.
	 */ 
	if (pdu_type == CONNECT_GCC_PDU)
	{
		return_value = ASN1_Encode(m_pEncInfo,	// ptr to encoder info
									 pdu_structure,	// pdu data structure
									 pdu_type,		// pdu id
									 ASN1ENCODE_ALLOCATEBUFFER, // flags
									 NULL,			// do not provide buffer
									 0);			// buffer size if provided
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CGCCCoder::Encode: ASN1_Encode failed, err=%d in CONNECT_GCC_PDU.",
						return_value));
			ASSERT(FALSE);
			goto MyExit;
		}
		ASSERT(return_value == ASN1_SUCCESS);
		/*
		 * Fill in the "ConnectData" PDU structure and encode it.
		 */
		connect_data_structure.t124_identifier = t124identifier;

		connect_data_structure.connect_pdu.length = m_pEncInfo->len; // len of encoded data in buffer
		connect_data_structure.connect_pdu.value = m_pEncInfo->buf;  // buffer to encode into

		// Prepare for the encode call
		pdu_structure = (LPVOID) &connect_data_structure;
		pdu_type = CONNECT_DATA_PDU;
	}

	/* 
	 * Encode the Non-Connect PDU into the buffer provided.
	 */
	return_value = ASN1_Encode(m_pEncInfo,		// ptr to encoder info
								pdu_structure,	// pdu data structure
								pdu_type,		// pdu id
								ASN1ENCODE_ALLOCATEBUFFER, // flags
								NULL,			// do not provide buffer
								0);				// buffer size if provided
	if (ASN1_FAILED(return_value))
	{
		ERROR_OUT(("CGCCCoder::Encode: ASN1_Encode failed, err=%d", return_value));
		ASSERT(FALSE);
		goto MyExit;
	}
	ASSERT(return_value == ASN1_SUCCESS);
	*encoding_buffer_length = m_pEncInfo->len;	// len of encoded data in buffer
	*encoding_buffer = m_pEncInfo->buf;			// buffer to encode into
	fRet = TRUE;

MyExit:

	/*
	 *	If this was a CONNECT_DATA_PDU we need to free the buffer that
	 *	was allocated by ASN.1.
	 */
	if (CONNECT_DATA_PDU == pdu_type && connect_data_structure.connect_pdu.value != NULL)
	{
		ASN1_FreeEncoded(m_pEncInfo, connect_data_structure.connect_pdu.value);
	}

	return fRet;
}

/*
 *	Decode ()
 *
 *	Public Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate GCC PDU structures using the ASN.1 toolkit.
 */
BOOL	CGCCCoder::Decode(LPBYTE		encoded_buffer,
							UINT		encoded_buffer_length,
							int			pdu_type,
							UINT		nEncodingRule_not_used,
							LPVOID		*pdecoding_buffer,
							UINT		*pdecoding_buffer_length)
{
	BOOL	fRet = FALSE;
	int		return_value;
	LPVOID	connect_data_decoding_buffer = NULL;
	ASN1optionparam_s OptParam;

	/*
	 * If the PDU is a "ConnectGCC" PDU then after it is decoded we must decode
	 * the "ConnectGCC" PDU which is actually contained within a "ConnectData"
	 * PDU.
	 */
	if (pdu_type == CONNECT_GCC_PDU)
	{
		return_value = ASN1_Decode(m_pDecInfo,		// ptr to decoder info
								&connect_data_decoding_buffer,	// destination buffer
								CONNECT_DATA_PDU,				// pdu type
								ASN1DECODE_SETBUFFER,			// flags
								encoded_buffer,					// source buffer
								encoded_buffer_length);			// source buffer size
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CGCCCoder::Decode: ASN1_Decode failed, err=%d", return_value));
			ASSERT(FALSE);
			goto MyExit;
		}
		ASSERT(return_value == ASN1_SUCCESS);

		/*
		 * If the decoded PDU is a "ConnectData" PDU, then we first must check
		 * to make sure this PDU originated from a T.124-compliant source.
		 * If so we then decode the "ConnectGCC" PDU which is held in the 
		 * "connect_pdu" field.  If the PDU is not T.124-compliant, we will
		 * report an error which will cause the PDU to be rejected.
		 */
		if (IsObjectIDCompliant(&(((PConnectData) connect_data_decoding_buffer)->t124_identifier)) 
																				== FALSE)
		{
			ERROR_OUT(("CGCCCoder::Decode: Non-T.124 objectID"));
			ASSERT (FALSE);
			goto MyExit;
		}
		ASSERT(connect_data_decoding_buffer != NULL);
		encoded_buffer = (PUChar)((PConnectData) connect_data_decoding_buffer)->
							connect_pdu.value;
		encoded_buffer_length = (UINT)((PConnectData) connect_data_decoding_buffer)->
								connect_pdu.length;
	}

	/* 
	 * Decode the Non-Connect PDU into the buffer provided.
	 */
	return_value = ASN1_Decode(m_pDecInfo,	// ptr to decoder info
							pdecoding_buffer,			// destination buffer
							pdu_type,					// pdu type
							ASN1DECODE_SETBUFFER,		// flags
							encoded_buffer,				// source buffer
							encoded_buffer_length);		// source buffer size
	if (ASN1_FAILED(return_value))
	{
		ERROR_OUT(("CCCCoder::Decode: ASN1_Decode failed, err=%d", return_value));
		ASSERT(FALSE);
		goto MyExit;
	}
	ASSERT(return_value == ASN1_SUCCESS);

    OptParam.eOption = ASN1OPT_GET_DECODED_BUFFER_SIZE;
	return_value = ASN1_GetDecoderOption(m_pDecInfo, &OptParam);
	if (ASN1_FAILED(return_value))
	{
		ERROR_OUT(("CGCCCoder::Decode: ASN1_GetDecoderOption failed, err=%d", return_value));
		ASSERT(FALSE);
		goto MyExit;
	}
    *pdecoding_buffer_length = OptParam.cbRequiredDecodedBufSize;

	ASSERT(return_value == ASN1_SUCCESS);
	ASSERT(*pdecoding_buffer_length > 0);

	fRet = TRUE;

MyExit:

	/*
	 * Free the PDU structure allocated by decoder for the Connect-Data PDU.
	 */
	if (connect_data_decoding_buffer != NULL)
	{
		ASSERT (pdu_type == CONNECT_GCC_PDU);
		ASN1_FreeDecoded(m_pDecInfo, connect_data_decoding_buffer, CONNECT_DATA_PDU);
	}

	return fRet;
}

/*
 *	IsObjectIDCompliant ()
 *
 *	Private Functional Description:
 *		This function is used to verify that the object identifier contained
 * 		in a "Connect" PDU is compliant with this version of GCC.
 */
BOOL	CGCCCoder::IsObjectIDCompliant (PKey	t124_identifier)
{
	BOOL				return_value = TRUE;
	PSetOfObjectID		test_object_id_set;
	PSetOfObjectID		valid_object_id_set;

	/*
	 * First check to make sure that the identifier is a standard Object 
	 * Identifier type.
	 */
	if (t124_identifier->choice == OBJECT_CHOSEN)
	{
		/*
		 * Retrieve the object identifier to test and the valid	T.124 
		 * identifier ("t124identifier) to use as a comparison.
		 */
		test_object_id_set = t124_identifier->u.object;
		valid_object_id_set = t124identifier.u.object;

		while ((valid_object_id_set != NULL) && (test_object_id_set != NULL)) 
		{
			if (test_object_id_set->value != valid_object_id_set->value)
			{
				return_value = FALSE;
				break;
			}

			test_object_id_set = test_object_id_set->next;
			valid_object_id_set = valid_object_id_set->next;
		}
	}
	else
		return_value = FALSE;

	return (return_value);
}


void CGCCCoder::FreeEncoded (PUChar encoded_buffer)
{
    ASN1_FreeEncoded(m_pEncInfo, encoded_buffer);
}

void CGCCCoder::FreeDecoded (int pdu_type, LPVOID decoded_buffer)
{
    ASN1_FreeDecoded(m_pDecInfo, decoded_buffer, pdu_type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\omcscode.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	omcscode.cpp
 *	
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CMCSCoder class.  This class
 *		is responsible for encoding and decoding T.125 PDU's using ASN.1 
 *		encoding rules via the ASN.1 toolkit.  This class is also capable
 *		of determining the size of both the encoded and decoded PDU's and is 
 *		capable of making copies of each of the PDU's. 
 *
 *	Private Instance Variables:
 *		Encoding_Rules_Type
 *			This variable holds the type of encoding rules which are currently
 *			being utilized.
 *
 *	Private Member Functions:
 *
 *		Copy***
 *			Private member functions exist which are capable of making complete
 *			copies of the decoded "Send Data" PDU data structures.  These 
 *			routines copy not only the data contained within the structure but 
 *			also any data which is referenced by the pointers held within the 
 *			structure.
 *
 *		SetEncodingRules
 *			This routine is used to switch between using Basic Encoding Rules
 *			(BER) and Packed Encoding Rules (PER).  This routine also updates
 *			the private instance variables used to hold values for the minimum
 *			and maximum amount of overhead associated with the "send data" PDUs.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 */

#include "omcscode.h"

/*
 * Macros.
 */
#define		BOOLEAN_TAG						0x01
#define		INTEGER_TAG						0x02
#define		BIT_STRING_TAG	   				0x03
#define		OCTET_STRING_TAG	   			0x04
#define		ENUMERATED_TAG	   				0x0a

#define		SEQUENCE						0x30
#define		SETOF							0x31
#define		INDEFINITE_LENGTH				0x80
#define		ONE_BYTE_LENGTH					0x81
#define		TWO_BYTE_LENGTH					0x82
#define		THREE_BYTE_LENGTH				0x83
#define		FOUR_BYTE_LENGTH				0x84
#define		END_OF_CONTENTS					0x00

#define		CONSTRUCTED_TAG_ZERO			0xa0	
#define		CONSTRUCTED_TAG_ONE				0xa1	
#define		CONSTRUCTED_TAG_TWO				0xa2	
#define		CONSTRUCTED_TAG_THREE			0xa3	
#define		CONSTRUCTED_TAG_FOUR			0xa4

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
CMCSCoder	*g_MCSCoder;

/*
 *	The following array contains a template for the X.224 data header.
 *	The 5 of the 7 bytes that it initializes are actually sent to the
 *	wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *	The array is only used when we encode a data PDU.
 */
UChar g_X224Header[] = { 3, 0, 0, 0, 2, DATA_PACKET, EOT_BIT };

/*
 *	CMCSCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the CMCSCoder class.  It initializes
 *		the ASN.1 encoder/decoder, saves the current encoding rules type,
 *		and sets values for the highest and lowest overhead in the "send data"
 *		PDU's.
 */
CMCSCoder::CMCSCoder ()
:m_pEncInfo(NULL),
 m_pDecInfo(NULL)
{
	Encoding_Rules_Type = BASIC_ENCODING_RULES;
// lonchanc: We should move Init out of constructor. However,
// to minimize the changes in the GCC/MCS code, we put it here for now.
// Otherwise, we need to change MCS and Packet interfaces.
// We will move it out and call Init() separately.
	Init();
}

BOOL CMCSCoder::Init ( void )
{
	BOOL fRet = FALSE;
	MCSPDU_Module_Startup();
	if (MCSPDU_Module != NULL)
	{
		if (ASN1_CreateEncoder(
                            MCSPDU_Module,	// ptr to mdule
                            &m_pEncInfo,	// ptr to encoder info
                            NULL,			// buffer ptr
                            0,				// buffer size
                            NULL)			// parent ptr
			== ASN1_SUCCESS)
		{
			ASSERT(m_pEncInfo != NULL);
			m_pEncInfo->cbExtraHeader = PROTOCOL_OVERHEAD_X224;
			fRet = (ASN1_CreateDecoder(
                                MCSPDU_Module,	// ptr to mdule
                                &m_pDecInfo,	// ptr to decoder info
                                NULL,			// buffer ptr
                                0,				// buffer size
                                NULL)			// parent ptr
					== ASN1_SUCCESS);
			ASSERT(fRet && m_pDecInfo != NULL);
		}
	}
	ASSERT(fRet);
	return fRet;
}

/*
 *	~CMCSCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a virtual destructor.  It is used to clean up after ASN.1.
 */
CMCSCoder::~CMCSCoder ()
{
	if (MCSPDU_Module != NULL)
	{
		ASN1_CloseEncoder(m_pEncInfo);
		ASN1_CloseDecoder(m_pDecInfo);
	    MCSPDU_Module_Cleanup();
	}
}

/*
 *	void	Encode ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function encodes MCS protocol data units (PDU's) into ASN.1 
 *		compliant byte streams using the ASN.1 toolkit.
 *		The encode happens in a coder-allocated buffer.
 */
BOOL	CMCSCoder::Encode(LPVOID			pdu_structure,
							int				pdu_type,
							UINT			rules_type,
							LPBYTE			*encoding_buffer,
							UINT			*encoding_buffer_length)
{
	BOOL					fRet = TRUE;
	BOOL					send_data_pdu = FALSE;
	int						return_value;

	//UINT					encoding_length;
	UShort					initiator;
	LPBYTE					buffer_pointer;
	PSendDataRequestPDU		send_data;
	UINT					PDUChoice;
	BOOL					bBufferAllocated;
	PMemory					memory;

	/*
	 * Check to make sure the encoding rules type is properly set.
	 */
	ASSERT(rules_type == PACKED_ENCODING_RULES || pdu_type == CONNECT_MCS_PDU);
	if (pdu_type == DOMAIN_MCS_PDU)
	{
		/*
		 *	Set PDUChoice to the type of MCS PDU we need to encode.
		 *	Also, determine if this is a data PDU.
		 */
		PDUChoice = (unsigned int) ((PDomainMCSPDU) pdu_structure)->choice;
		if ((PDUChoice == SEND_DATA_REQUEST_CHOSEN) ||
			(PDUChoice == SEND_DATA_INDICATION_CHOSEN) ||
			(PDUChoice == UNIFORM_SEND_DATA_REQUEST_CHOSEN) ||
			(PDUChoice == UNIFORM_SEND_DATA_INDICATION_CHOSEN)) {
			send_data_pdu = TRUE;
			send_data = &((PDomainMCSPDU) pdu_structure)->u.send_data_request;
			bBufferAllocated = (*encoding_buffer == NULL);
			if (bBufferAllocated) {
				// We have to allocate the encoded buffer.
				DBG_SAVE_FILE_LINE
				memory = AllocateMemory (NULL,
								send_data->user_data.length + MAXIMUM_PROTOCOL_OVERHEAD,
								SEND_PRIORITY);
				if (memory != NULL) {
					buffer_pointer = *encoding_buffer = (LPBYTE) memory->GetPointer();
				}
				else {
					WARNING_OUT (("CMCSCoder::Encode: Failed to allocate space for "
								"encoded data PDU for send."));
					fRet = FALSE;
					ASSERT (*encoding_buffer == NULL);
					goto MyExit;
				}
			}
			else {
				// All the space needed here has been pre-allocated
				buffer_pointer = *encoding_buffer;
			}
		}

		/*
		 *	Check if this is a data PDU
		 */
		if (send_data_pdu)
		{
#ifdef ENABLE_BER
			
			/*
			 * If we are currently using Basic Encoding Rules.
			 */
			if (Encoding_Rules_Type == BASIC_ENCODING_RULES)
			{
				/*
				 * The long variant of length must be used if the octet string
				 * is longer than 127 bytes.  The upper bit of the length byte
				 * is set and the lower bits indicate the number of length bytes 
				 * which will follow.
				 */
				*(buffer_pointer--) = (UChar)send_data->user_data.length;
				if (send_data->user_data.length > 127)
				{
					*(buffer_pointer--) = (UChar)(send_data->user_data.length >> 8);
					*(buffer_pointer--) = TWO_BYTE_LENGTH;
					encoding_length = 3;
				}
				else 
				{
					encoding_length = 1;
				}

				/*
				 * Encode the "user data" octet string.
				 */										
				*(buffer_pointer--) = OCTET_STRING_TAG;

				/*
				 * Encode the "segmentation" bit string field.  The identifier
				 * is followed by a length of 2 and a byte indicating that 6
				 * bits are unused in the actual bit string byte.
				 */
				*(buffer_pointer--) = (UChar) send_data->segmentation;
				*(buffer_pointer--) = 0x06;
				*(buffer_pointer--) = 0x02;
				*(buffer_pointer--) = BIT_STRING_TAG;

				/* 
				 * Encode the enumerated "data priority" field.
				 */
				*(buffer_pointer--) = (UChar)send_data->data_priority;
				*(buffer_pointer--) = 0x01;
				*(buffer_pointer--) = ENUMERATED_TAG;

				/*
				 * Encode the integer "channel ID" field.
				 */
				*(buffer_pointer--) = (UChar)send_data->channel_id;
				if (send_data->channel_id < 128)
				{
					*(buffer_pointer--) = 0x01;
					encoding_length += 10;
				}
				else if (send_data->channel_id < 32768L)
				{
					*(buffer_pointer--) = (UChar)(send_data->channel_id >> 8);
					*(buffer_pointer--) = 0x02;
					encoding_length += 11;
				}
				else
				{
					*(buffer_pointer--) = (UChar)(send_data->channel_id >> 8);
					*(buffer_pointer--) = (UChar)(send_data->channel_id >> 16);
					*(buffer_pointer--) = 0x03;
					encoding_length += 12;
				}
				*(buffer_pointer--) = INTEGER_TAG;

				/*
				 * Encode the integer "initiator" field.
				 */
				*(buffer_pointer--) = (UChar)send_data->initiator;
				*(buffer_pointer--) = (UChar)(send_data->initiator >> 8);
				if (send_data->initiator < 32768L)
				{
					*(buffer_pointer--) = 0x02;
					encoding_length += 4;
				}
				else
				{
					*(buffer_pointer--) = (UChar)(send_data->initiator >> 16);
					*(buffer_pointer--) = 0x03;
					encoding_length += 5;
				}
				*(buffer_pointer--) = INTEGER_TAG;

				*(buffer_pointer--) = INDEFINITE_LENGTH; 
				
				switch (PDUChoice)
				{	
					case SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = SEND_DATA_REQUEST;
						break;
					case SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = SEND_DATA_INDICATION;
						break;
					case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = UNIFORM_SEND_DATA_REQUEST;
						break;
					case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = UNIFORM_SEND_DATA_INDICATION;
						break;
				}

				// Set the returned pointer to the beginning of the encoded packet
				PUChar	temp = *encoding_buffer;
				*encoding_buffer = buffer_pointer;

				/*
				 * Encode the end-of-contents marker for the "Send Data" PDU.
				 * This goes after the data, at the end of the PDU.
				 */
				buffer_pointer = temp + (send_data->user_data.length + 
								(MAXIMUM_PROTOCOL_OVERHEAD_FRONT + 1));
				*(buffer_pointer++) = END_OF_CONTENTS;
				*buffer_pointer = END_OF_CONTENTS;

				// Set the returned length of the encoded packet
				*encoding_buffer_length = 
							encoding_length + send_data->user_data.length + 5;
			}
			/*
			 * If we are currently using Packed Encoding Rules.
			 */
			else
#endif // ENABLE_BER
			{	
				// Move the ptr past the X.224 header.
				buffer_pointer += sizeof(X224_DATA_PACKET);
				
				switch (PDUChoice)
				{
					case SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = PER_SEND_DATA_REQUEST;
						break;
					case SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = PER_SEND_DATA_INDICATION;
						break;
					case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
						*buffer_pointer = PER_UNIFORM_SEND_DATA_REQUEST;
						break;
					case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
						*buffer_pointer = PER_UNIFORM_SEND_DATA_INDICATION;
						break;
				}
				buffer_pointer++;

				/*
				 * Encode the integer "initiator" field.  The lower bound must
				 * first be subtracted from the value to encode.
				 */
				initiator = send_data->initiator - INITIATOR_LOWER_BOUND;
				*(buffer_pointer++) = (UChar) (initiator >> 8);
				*(buffer_pointer++) = (UChar) initiator;

				/*
				 * Encode the integer "channel ID" field.
				 */
				*(buffer_pointer++) = (UChar)(send_data->channel_id >> 8);
				*(buffer_pointer++) = (UChar)(send_data->channel_id);

				/*
				 * Encode the "priority" and "segmentation" fields.
				 */
				*(buffer_pointer++) = (UChar)((send_data->data_priority << 6) |
										(send_data->segmentation >> 2));
				
				/* 
				 * Encode the "user data" octet string.  The octet strings are
				 * encoded differently depending upon their length.
				 */
				ASSERT (send_data->user_data.length < 16384);

				if (send_data->user_data.length <= 127)
				{
					*encoding_buffer_length = MAXIMUM_PROTOCOL_OVERHEAD - 1;
				}
				else
				{
					*(buffer_pointer++) = (UChar)(send_data->user_data.length >> 8) | 
											INDEFINITE_LENGTH;
					*encoding_buffer_length = MAXIMUM_PROTOCOL_OVERHEAD;
				}
				*buffer_pointer++ = (UChar)send_data->user_data.length;

				initiator = (UShort) (*encoding_buffer_length + send_data->user_data.length);
				
				// Set the returned length of the encoded PDU.
				if (bBufferAllocated || (send_data->segmentation & SEGMENTATION_BEGIN)) {
					/*
					 *	If the Encode operation allocates the space needed, or the space
					 *	was allocated by MCSGetBufferRequest (by a client) and this is
					 *	the 1st segment of the data in the buffer, the whole encoded PDU
					 *	is in contiguous space.  The total PDU size is returned in this
					 *	case.
					 *	However, in the case where the space was allocated by MCSGetBufferRequest,
					 *	the PDUs after the 1st one, will put the X.224 and MCS headers in 
					 *	a separate piece of memory (whose length is returned here), and the
					 *	data is still in the pre-allocated space.
					 */
					*encoding_buffer_length = (UINT) initiator;
				}

				/*
				 *	If the space was not preallocated, we need to copy the data
				 *	into the space allocated by the encoder.
				 */
				if (bBufferAllocated) {
					// We now need to copy the data into the encoded data PDU.
					memcpy (buffer_pointer, send_data->user_data.value,
							send_data->user_data.length);
					// Update the data ptr in the data packet
					send_data->user_data.value = (ASN1octet_t *) buffer_pointer;
				}
			}
		}
	}

	if (send_data_pdu == FALSE)
	{
		SetEncodingRules (rules_type);
		return_value = ASN1_Encode(m_pEncInfo,	// ptr to encoder info
									 pdu_structure,	// pdu data structure
									 pdu_type,		// pdu id
									 ASN1ENCODE_ALLOCATEBUFFER, // flags
									 NULL,			// do not provide buffer
									 0);			// buffer size if provided
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CMCSCoder::Encode: ASN1_Encode failed, err=%d", return_value));
			ASSERT(FALSE);
			fRet = FALSE;
			goto MyExit;
		}
		ASSERT(return_value == ASN1_SUCCESS);
		/*
		 *	The encoded buffers returned by ASN.1 have preallocated the space
		 *	needed for the X.224 header.
		 */
		// len of encoded data in buffer
		*encoding_buffer_length = m_pEncInfo->len;
		initiator = (UShort) *encoding_buffer_length;
		// buffer to encode into
		*encoding_buffer = m_pEncInfo->buf;
	}

	// Now, add the X.224 header
	buffer_pointer = *encoding_buffer;
	memcpy (buffer_pointer, g_X224Header, PROTOCOL_OVERHEAD_X224);
	AddRFCSize (buffer_pointer, initiator);

MyExit:

	return fRet;
}

/*
 *	void 	Decode ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate MCS PDU structures using the ASN.1 toolkit.
 *
 *	NOTE: For data PDUs, do NOT access pdecoding_buffer_length. It's set
 *			to NULL.
 */
BOOL	CMCSCoder::Decode(LPBYTE			encoded_buffer,
							UINT			encoded_buffer_length,
							int				pdu_type,
							UINT			rules_type,
							LPVOID			*pdecoding_buffer,
							UINT			*pdecoding_buffer_length)
{
	BOOL				fRet = TRUE;
	BOOL				send_data_pdu = FALSE;
    ASN1optionparam_s   OptParam;

	/*
	 * Check to make sure the encoding rules type is properly set.
	 */
	ASSERT(rules_type == PACKED_ENCODING_RULES || pdu_type == CONNECT_MCS_PDU);

	if (pdu_type == DOMAIN_MCS_PDU)
	{
			UChar					length;
			unsigned int			short_data;
			PUChar					buffer_pointer;
			PSendDataRequestPDU		send_data;
			PDomainMCSPDU			decoding_pdu;
			ASN1choice_t			choice;
			
		buffer_pointer = encoded_buffer;
		
#ifdef ENABLE_BER
		/*
		 * If we are currently using Basic Encoding Rules.
		 */
		if (Encoding_Rules_Type == BASIC_ENCODING_RULES)
		{
			switch (*(buffer_pointer++))
			{
				case SEND_DATA_REQUEST:
					((PDomainMCSPDU) decoding_buffer)->choice =
							SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case SEND_DATA_INDICATION:
					((PDomainMCSPDU) decoding_buffer)->choice =
							SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case UNIFORM_SEND_DATA_REQUEST:
					((PDomainMCSPDU) decoding_buffer)->choice =
							UNIFORM_SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case UNIFORM_SEND_DATA_INDICATION:
					((PDomainMCSPDU) decoding_buffer)->choice =
							UNIFORM_SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;
			}

			if (send_data_pdu )
			{
				/*
				 * Get the pointer to the "Send Data" PDU.
				 */
				send_data = &((PDomainMCSPDU) decoding_buffer)->
												u.send_data_request;

				/*
				 * Retrieve one byte for the length and check to see which 
				 * length variant is being used.  If the long variant is being 
				 * used, move the buffer pointer past the length and set the 
				 * flag indicating that the indefinite length is not being used.
				 */
				length = *buffer_pointer;

				switch (length)
				{
					case ONE_BYTE_LENGTH: 
							buffer_pointer += 3;
							break;
					case TWO_BYTE_LENGTH: 
							buffer_pointer += 4;
							break;		
					case THREE_BYTE_LENGTH:
							buffer_pointer += 5;
							break;
					case FOUR_BYTE_LENGTH:
							buffer_pointer += 6;
							break;
					default:
							buffer_pointer += 2;
				}

				/*
				 * Decode the integer "initiator" field.  Increment the data 
				 * pointer past the integer identifier and retrieve the length 
				 * of the integer.
				 */
				length = *(buffer_pointer++);

				ASSERT ((length == 1) || (length == 2));
				if (length == 1)
					send_data->initiator = (UserID) *(buffer_pointer++);
				else if (length == 2)
				{
					send_data->initiator = ((UserID) *(buffer_pointer++)) << 8;
					send_data->initiator |= (UserID) *(buffer_pointer++);
				}
				else 
				{
					TRACE_OUT(("CMCSCoder::Decode: initiator field is longer than 2 bytes (%d bytes) in MCS Data packet.",  (UINT) length));
				}

				/*
				 * Decode the integer "channel ID" field.  Increment the data 
				 * pointer past the integer identifier and retrieve the length 
				 * of the integer.
				 */
				buffer_pointer++;
				length = *(buffer_pointer++);

				ASSERT ((length == 1) || (length == 2));
				if (length == 1)
					send_data->channel_id = (ChannelID) *(buffer_pointer++);
				else if (length == 2)
				{
					send_data->channel_id = ((ChannelID) *buffer_pointer++) << 8;
					send_data->channel_id |= (ChannelID) *(buffer_pointer++);
				}
				else 
				{
					TRACE_OUT(("CMCSCoder::Decode: channel_id field is longer than 2 bytes (%d bytes) in MCS Data packet.", (UINT) length));
				}

				/*
				 * Decode the enumerated "data priority" field.  Increment the
				 * data pointer past the identifier and length.
				 */
				buffer_pointer+=2;
				send_data->data_priority =(PDUPriority)*buffer_pointer;

				/*
				 * Decode the bit string "segmentation" field.  Increment the 
				 * data pointer past the bit string identifier, length, and the 
				 * "unused bits" byte and retrieve the "segmentation" flag.
				 */
				buffer_pointer += 4;
				send_data->segmentation = *buffer_pointer;

				/*
				 * Decode the "user data" octet string.	 Increment the data 
				 * pointer past the identifier.
				 */
				buffer_pointer += 2;

				/*
				 * Check to see which variant of the length is being used and
				 * then retrieve the length.
				 */
				length = *(buffer_pointer++);

				if (length & INDEFINITE_LENGTH)
				{
					if (length == ONE_BYTE_LENGTH)
						send_data->user_data.length = (unsigned int) *(buffer_pointer++);
					/*
					 * A length identifier of 0x82 indicates that two bytes are
					 * being used to hold the actual length so retrieve the two
					 * bytes to form the length.
					 */
					else if (length == TWO_BYTE_LENGTH)
					{
						send_data->user_data.length = 
								((unsigned int) *(buffer_pointer++)) << 8;
						send_data->user_data.length |= 
								(unsigned int) *(buffer_pointer++);
					}
				}
				else
					send_data->user_data.length = (unsigned int) length;

				// buffer_pointer now points to the 1st data byte
				send_data->user_data.value = buffer_pointer;
				*pulDataOffset = buffer_pointer - encoded_buffer;
			}
		}
		/*
		 * If we are currently using Packed Encoding Rules.
		 */
		else
#endif // ENABLE_BER
		{
			switch (*(buffer_pointer++))
			{
				case PER_SEND_DATA_REQUEST:
					choice = SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case PER_SEND_DATA_INDICATION:
					choice = SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case PER_UNIFORM_SEND_DATA_REQUEST:
					choice = UNIFORM_SEND_DATA_REQUEST_CHOSEN;
					send_data_pdu = TRUE;
					break;

				case PER_UNIFORM_SEND_DATA_INDICATION:
					choice = UNIFORM_SEND_DATA_INDICATION_CHOSEN;
					send_data_pdu = TRUE;
					break;
			}

			if (send_data_pdu)
			{
				decoding_pdu = (PDomainMCSPDU) pdecoding_buffer; 

				// Store the choice field
				decoding_pdu->choice = choice;
				/*
				 * Get the pointer to the "Send Data" PDU.
				 */
				send_data = &decoding_pdu->u.send_data_request;

				/*
				 * Decode the integer "initiator" field.
				 */
				short_data = ((unsigned int) *(buffer_pointer++)) << 8;
				short_data |= (unsigned int) *(buffer_pointer++);
				send_data->initiator = (UserID) short_data + INITIATOR_LOWER_BOUND;

				/*
				 * Decode the integer "channel ID" field. 
				 */
				send_data->channel_id = ((ChannelID) *(buffer_pointer++)) << 8;
				send_data->channel_id |= (ChannelID) *(buffer_pointer++);

				/*
				 * Decode the enumerated "data priority" field and the
				 * "segmentation" field.
				 */
				send_data->data_priority = 
						(PDUPriority)((*buffer_pointer >> 6) & 0x03);
				send_data->segmentation = (*(buffer_pointer++) << 2) & 0xc0; 

				/*
				 * Decode the "user data" octet string.	 Check to see which 
				 * variant of the length is being used and then retrieve the 
				 * length.
				 */
				length = *(buffer_pointer++);

				if (length & INDEFINITE_LENGTH)
				{
					ASSERT ((length & 0x40) == 0);
					
					/*
					 * If bit 7 is set the length is greater than 127 but
					 * less than 16K.
					 *
					 *	ChristTs: We no longer handle the case where the data length
					 *	was higher than 16K. Our Max PDU size is 4K.
					 */
					short_data = (unsigned int) ((length & 0x3f) << 8);
					send_data->user_data.length = 
								short_data | ((unsigned int) *(buffer_pointer++));
				}
				/*
				 * If bit 7 is not set then the length is less than 128 and is
				 * contained in the retrieved byte.
				 */
				else
				{
					send_data->user_data.length = (UShort) length;
				}

				// buffer_pointer now points to the 1st data byte
				send_data->user_data.value = buffer_pointer;
			}
		}
	}
	
	if (send_data_pdu == FALSE)
	{
		int 	return_value;
		//void	*pDecodedData;

		SetEncodingRules (rules_type);

		return_value = ASN1_Decode(m_pDecInfo,// ptr to decoder info
							pdecoding_buffer,		// destination buffer
							pdu_type,				// pdu type
							ASN1DECODE_SETBUFFER,	// flags
							encoded_buffer,			// source buffer
							encoded_buffer_length);	// source buffer size
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CMCSCoder::Decode: ASN1_Decode failed, err=%d", return_value));
			ASSERT(FALSE);
			fRet = FALSE;
			goto MyExit;
		}

        OptParam.eOption = ASN1OPT_GET_DECODED_BUFFER_SIZE;
		return_value = ASN1_GetDecoderOption(m_pDecInfo, &OptParam);
		if (ASN1_FAILED(return_value))
		{
			ERROR_OUT(("CMCSCoder::Decode: ASN1_GetDecoderOption failed, err=%d", return_value));
			ASSERT(FALSE);
			fRet = FALSE;
			goto MyExit;
		}
        *pdecoding_buffer_length = OptParam.cbRequiredDecodedBufSize;

		ASSERT((return_value == ASN1_SUCCESS) && (*pdecoding_buffer_length > 0));
	}

MyExit:

	return fRet;
}

/*
 *	PacketCoderError	ReverseDirection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is used to convert data request PDU's into data indication
 *		PDU's and vice versa.
 */
Void CMCSCoder::ReverseDirection (LPBYTE	encoded_buffer)
{
	encoded_buffer += PROTOCOL_OVERHEAD_X224;
	switch (*encoded_buffer)
	{
		case PER_SEND_DATA_REQUEST:
			*encoded_buffer = PER_SEND_DATA_INDICATION;
			break;

		case PER_SEND_DATA_INDICATION:
			*encoded_buffer = PER_SEND_DATA_REQUEST;
			break;

		case PER_UNIFORM_SEND_DATA_REQUEST:
			*encoded_buffer = PER_UNIFORM_SEND_DATA_INDICATION;
			break;

		case PER_UNIFORM_SEND_DATA_INDICATION:
			*encoded_buffer = PER_UNIFORM_SEND_DATA_REQUEST;
			break;
		default:
			ASSERT (FALSE);
			break;
	}
}

/*
 *	void	SetEncodingRules ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to set the type (basic or packed) of encoding
 *		rules to be used.
 */
void CMCSCoder::SetEncodingRules (UINT	rules_type)
{
	/*
	 * If the rules type is changing, set our rules instance variable and reset
	 * the variables which hold the amount of overhead associated with the
	 * "SendData" PDU's.
	 */
	Encoding_Rules_Type = rules_type;
}

/*
 *	BOOL	IsMCSDataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Return value:
 *		TRUE, if the packet is an MCS Data packet. FALSE, otherwise.
 */
BOOL CMCSCoder::IsMCSDataPacket(LPBYTE encoded_buffer, UINT rules_type)
{
	UChar		identifier;

	/*
	 * Retrieve the identifier from the encoded data.
	 */
	identifier = *encoded_buffer;

	if (rules_type == BASIC_ENCODING_RULES)
	{
		if (	(identifier == SEND_DATA_REQUEST) || 
				(identifier == SEND_DATA_INDICATION) || 
				(identifier == UNIFORM_SEND_DATA_REQUEST) || 
				(identifier == UNIFORM_SEND_DATA_INDICATION))
		{
			return TRUE;
		}
	}
	else
	{
		if (	(identifier == PER_SEND_DATA_REQUEST) || 
				(identifier == PER_SEND_DATA_INDICATION) || 
				(identifier == PER_UNIFORM_SEND_DATA_REQUEST) || 
				(identifier == PER_UNIFORM_SEND_DATA_INDICATION))
		{
			return TRUE;
		}
	}

	return FALSE;
}


void CMCSCoder::FreeEncoded(LPBYTE encoded_buffer)
{
    ASN1_FreeEncoded(m_pEncInfo, encoded_buffer);
}

void CMCSCoder::FreeDecoded (int pdu_type, LPVOID decoded_buffer)
{
    ASN1_FreeDecoded(m_pDecInfo, decoded_buffer, pdu_type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\pktcoder.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC | ZONE_T120_GCCNC);
/*
 *	pktcoder.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the PacketCoder class.
 *
 *	Private Instance Variables:
 *		None.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 */

/*
 *	External Interfaces
 */

#include "pktcoder.h"


/*
 *	~PacketCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is virtual destructor that does not do anything at this time.
 */
PacketCoder::~PacketCoder ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\password.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/* 
 *	password.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CPassword.  This class
 *		manages the data associated with a Password.  Passwords are used to 
 *		restrict access to conferences.  A password can be one of two basic
 *		types.  The simple type consists of either a simple numeric password or
 *		a simple textual password, or both.  The "PDU" type "Password" is a
 *		structure which must contain the numeric form of the password and may
 *		optionally contain the textual part as well.  The "PDU" type
 *		"PasswordSelector" is a union of the numeric and textual forms of a
 *		password and is therefore always one or the other but not both.  When
 *		the password is not the simple type it assumes the form of a
 *		"PasswordChallengeRequestResponse".  This complex structure allows a
 *		challenge-response scheme to be used to control access to conferences.
 *
 *	Protected Instance Variables:
 *		m_fSimplePassword
 *			Flag indicating this password does not contain "challenge" data.
 *		m_fClearPassword
 *			Flag used when the password assumes the "challenge" form indicating
 *			that this password is "in the clear" meaning no true challenge
 *			data is present.
 *		m_pszNumeric
 *			String holding the numeric portion of the simple password.
 *		Text_String_Ptr
 *			String holding the textual portion of the simple password.
 *		m_pInternalRequest
 *			Structure holding the data associated with a password challenge
 *			request.
 *		m_pInternalResponse
 *			Structure holding the data associated with a password challenge
 *			response.
 *		m_pChallengeResponse
 *			Structure holding the "API" form of a challenge password.
 *		m_pPassword
 *			Structure holding the "API" form of a simple password.
 *		m_pUserDataMemory
 *			Memory container holding the user data associated with a
 *			challenge password.
 *		m_pChallengeItemListMemory
 *			Memory container holding the list of pointers to challenge items
 *			associated with a password challenge request.
 *		m_pObjectKeyMemory
 *			Memory container holding the object key data associated with the
 *			non-standard challenge response algorithm.
 *		m_ChallengeItemMemoryList 
 *			Memory container holding the data for the challenge items
 *			associated with a password challenge request.
 *		m_ChallengeResponsePDU
 *			Storage for the "PDU" form of the challenge password.
 *		m_fValidChallengeResponsePDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" password.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */

#include "password.h"
#include "userdata.h"

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor for the CPassword class is used when creating a 
 *		CPassword object with an "API" GCCPassword structure.  It saves the
 *		password data in the internal structures.
 */
CPassword::CPassword(PGCCPassword			password,
					PGCCError				return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is a "simple" password, without the 
	 * challenge request-response information.  The "clear" flag is also 
	 * initialized here but should only be needed when the password is not
	 * "simple".
	 */
	m_fSimplePassword = TRUE;
	m_fClearPassword = TRUE;

	/*
	 * Save the numeric part of the password in the internal numeric string.
	 */
	if (password->numeric_string != NULL)
	{
		if (NULL == (m_pszNumeric = ::My_strdupA(password->numeric_string)))
		{
			ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::CPassword: No valid numeric password"));
		*return_value = GCC_INVALID_PASSWORD;
	}

	/*
	 * Check to see if the textual part of the password is present.  If so,
	 * save it in the internal UnicodeString.  If not, set the text pointer
	 * to NULL.
	 */
	if ((password->text_string != NULL) && (*return_value == GCC_NO_ERROR))
	{
		if (NULL == (m_pwszText = ::My_strdupW(password->text_string)))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating text string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pwszText = NULL;
}

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor is used when a CPassword object is being created
 *		with a "ChallengeRequestResponse" "API" structure.  The password data 
 *		is saved in the internal structures.
 */
CPassword::CPassword(PGCCChallengeRequestResponse		challenge_response_data,
					PGCCError							return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is not a "simple" password, meaning 
	 * that it contains challenge request-response information.  If the password
	 * is "clear" there is no need to create the internal "Challenge" structure
	 * used to hold the challenge request-response information.
	 */
	m_fSimplePassword = FALSE;
	
	/*
	 * Check to see if a "clear" challenge password exists or if this is a 
	 * true challenge request-response password.
	 */
	if (challenge_response_data->password_challenge_type == 
													GCC_PASSWORD_IN_THE_CLEAR)
	{
		/*
		 * A "clear" password is being sent so set the flag indicating so.  
		 * Also set the password type and save the numeric part of the password,
		 * if it exists.  Note that since the "clear" password contained in the
		 * challenge is a PasswordSelector type, either the numeric or the text
		 * form of the password should exist, but not both.
		 */
		m_fClearPassword = TRUE;

		if (challenge_response_data->u.password_in_the_clear.
				numeric_string != NULL)
		{
			if (NULL == (m_pszNumeric = ::My_strdupA(
							challenge_response_data->u.password_in_the_clear.numeric_string)))
			{
				ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pszNumeric = NULL;
		}

		/*
		 * Check to see if the textual part of the password is present.  If it
		 * is, save it in the internal UnicodeString.
		 */
		if ((challenge_response_data->u.password_in_the_clear.
				text_string != NULL) && (*return_value == GCC_NO_ERROR))
		{
			if (NULL == (m_pwszText = ::My_strdupW(
							challenge_response_data->u.password_in_the_clear.text_string)))
			{
				ERROR_OUT(("CPassword::CPassword: Error creating text string"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pwszText = NULL;
		}

		/*
		 * Check to make sure at least one form (text or numeric) of the 
		 * "clear" password was saved.  Report an error if neither was created.
		 */
		if ((*return_value == GCC_NO_ERROR) && (m_pszNumeric == NULL) 
				&& (m_pwszText == NULL))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password"));
			*return_value = GCC_INVALID_PASSWORD;
		}
	}
	else
	{
		/*
		 * This is a true challenge request-response password.  Set the flag
		 * indicating that the password is not "clear" and create the 
		 * "challenge" data structures to hold the password data internally.
		 */
		m_fClearPassword = FALSE;

		/*
		 * Check to see if a challenge request is present.
		 */
		if (challenge_response_data->u.challenge_request_response.
				challenge_request != NULL)
		{
			/*
			 * Create a RequestInfo stucture to hold the request data
			 * and copy the challenge request structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalRequest = new RequestInfo;
			if (m_pInternalRequest != NULL)
			{
				*return_value = ConvertAPIChallengeRequest (
						challenge_response_data->u.
						challenge_request_response.challenge_request);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new RequestInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}

		/*
		 * Check to see if a challenge response is present.
		 */
		if ((challenge_response_data->u.challenge_request_response.
				challenge_response != NULL) && 
				(*return_value == GCC_NO_ERROR))
		{
			/*
			 * Create a ResponseInfo stucture to hold the response data
			 * and copy the challenge response structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalResponse = new ResponseInfo;
			if (m_pInternalResponse != NULL)
			{
				*return_value = ConvertAPIChallengeResponse (
						challenge_response_data->u.
						challenge_request_response.challenge_response);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new ResponseInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
	} 
}

/*
 *	CPassword()
 *
 *	Public Function Description
 *		This constructor for the CPassword class is used when creating a 
 *		CPassword object with a "PDU" Password structure.  It saves the
 *		password data in the internal structures.
 */
CPassword::CPassword(PPassword				password_pdu,
					PGCCError				return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is a "simple" password, without the 
	 * challenge request-response information.  The "clear" flag is also 
	 * initialized here but should only be needed when the password is not
	 * "simple".
	 */
	m_fSimplePassword = TRUE;
	m_fClearPassword = TRUE;
	
	/*
	 * Save the numeric part of the password. The numeric portion of the
	 * password is required to be present so report an error if it is not.
	 */
	if (password_pdu->numeric != NULL)
	{
		if (NULL == (m_pszNumeric = ::My_strdupA(password_pdu->numeric)))
		{
			ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::CPassword: Error no valid numeric password in PDU"));
		*return_value = GCC_INVALID_PASSWORD;
		m_pszNumeric = NULL;
	}

	/*
	 * Check to see if the textual part of the password is present.
	 */
	if ((password_pdu->bit_mask & PASSWORD_TEXT_PRESENT) &&
			(*return_value == GCC_NO_ERROR))
	{
		if (NULL == (m_pwszText = ::My_strdupW2(
							password_pdu->password_text.length,
							password_pdu->password_text.value)))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password text"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pwszText = NULL;
}

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor for the CPassword class is used when creating a 
 *		CPassword object with a "PDU" PasswordSelector structure.  It saves
 *		the password data in it's internal structures but does not require
 *		saving any "challenge request-response" data.
 */
CPassword::CPassword(PPasswordSelector			password_selector_pdu,
					PGCCError					return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is a "simple" password, without the 
	 * challenge request-response information.
	 */
	m_fSimplePassword = TRUE;
	m_fClearPassword = TRUE;
	
	/*
	 * The password selector contains either the numeric password or the 
	 * textual password but not both.  Check to see if the textual password 
	 * is chosen.
	 */
	if (password_selector_pdu->choice == PASSWORD_SELECTOR_TEXT_CHOSEN)
	{
		if (NULL == (m_pwszText = ::My_strdupW2(
							password_selector_pdu->u.password_selector_text.length,
							password_selector_pdu->u.password_selector_text.value)))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password selector text"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pwszText = NULL;

	/*
	 * Check to see if the numeric password is chosen.
	 */
	if (password_selector_pdu->choice == PASSWORD_SELECTOR_NUMERIC_CHOSEN)
	{
		if (NULL == (m_pszNumeric = ::My_strdupA(
							password_selector_pdu->u.password_selector_numeric)))
		{
			ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
			*return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pszNumeric = NULL;

	/*
	 * Check to make sure at least one form (text or numeric) of the 
	 * password was saved.  Report an error if neither was created.
	 */
	if ((*return_value == GCC_NO_ERROR) && (m_pszNumeric == NULL) 
			&& (m_pwszText == NULL))
	{
		ERROR_OUT(("CPassword::CPassword: Error creating password selector"));
		*return_value = GCC_INVALID_PASSWORD;
	}
}

/*
 *	CPassword()
 *
 *	Public Function Description:
 *		This constructor for the CPassword class is used when creating a
 *		CPassword object with a "PDU" Challenge Request-Response structure.
 *		The password data is saved in the internal structures.
 */
CPassword::CPassword(PPasswordChallengeRequestResponse	pdu_challenge_data,
					PGCCError							return_value)
:
    CRefCount(MAKE_STAMP_ID('P','a','s','w')),
    m_fValidChallengeResponsePDU(FALSE),
    m_pInternalRequest(NULL),
    m_pInternalResponse(NULL),
    m_pChallengeResponse(NULL),
    m_pPassword(NULL),
    m_pChallengeItemListMemory(NULL),
    m_pUserDataMemory(NULL),
    m_pObjectKeyMemory(NULL),
    m_pszNumeric(NULL),
    m_pwszText(NULL)
{
	*return_value = GCC_NO_ERROR;

	/*
	 * Set the flag indicating that this is not "simple" password, meaning that 
	 * it contains challenge request-response information.  If the password is
	 * "clear" there is no need to create the internal "Challenge" structure
	 * used to hold the challenge request-response information.
	 */
	m_fSimplePassword = FALSE;
	
	/*
	 * Check to see if a "clear" challenge password exists or if this is a 
	 * true challenge request-response password.
	 */
	if (pdu_challenge_data->choice == CHALLENGE_CLEAR_PASSWORD_CHOSEN)
	{
		/*
		 * A "clear" password is being sent so set the flag indicating so.  
		 * Also set the password type and save the numeric part of the password,
		 * if it is present.
		 */
		m_fClearPassword = TRUE;

		if (pdu_challenge_data->u.challenge_clear_password.choice ==
											PASSWORD_SELECTOR_NUMERIC_CHOSEN)
		{
			if (NULL == (m_pszNumeric = ::My_strdupA(
							pdu_challenge_data->u.challenge_clear_password.u.password_selector_numeric)))
			{
				ERROR_OUT(("CPassword::CPassword: can't create numeric string"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pszNumeric = NULL;
		}

		/*
		 * Check to see if the textual part of the password is present.  If it
		 * is, save it in the internal structure.
		 */
		if (pdu_challenge_data->u.challenge_clear_password.choice ==
											PASSWORD_SELECTOR_TEXT_CHOSEN)
		{
			if (NULL == (m_pwszText = ::My_strdupW2(
								pdu_challenge_data->u.challenge_clear_password.
										u.password_selector_text.length,
								pdu_challenge_data->u.challenge_clear_password.
										u.password_selector_text.value)))
			{
				ERROR_OUT(("CPassword::CPassword: Error creating password selector text"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			m_pwszText = NULL;
		}

		/*
		 * Check to make sure at least one form (text or numeric) of the 
		 * "clear" password was saved.  Report an error if neither was created.
		 */
		if ((*return_value == GCC_NO_ERROR) && (m_pszNumeric == NULL) 
				&& (m_pwszText == NULL))
		{
			ERROR_OUT(("CPassword::CPassword: Error creating password"));
			*return_value = GCC_INVALID_PASSWORD;
		}
	}
	else
	{
		/*
		 * This is a true challenge request-response password.  Set the flag
		 * indicating that the password is not "clear" and create a 
		 * "challenge data" structure to hold the password data internally.
		 */
		m_fClearPassword = FALSE;

		/*
		 * Check to see if a challenge request is present.
		 */
		if (pdu_challenge_data->u.challenge_request_response.
				bit_mask & CHALLENGE_REQUEST_PRESENT)
		{
			/*
			 * Create a RequestInfo stucture to hold the request data
			 * and copy the challenge request structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalRequest = new RequestInfo;
			if (m_pInternalRequest != NULL)
			{
				*return_value = ConvertPDUChallengeRequest (
						&pdu_challenge_data->u.challenge_request_response.
						challenge_request);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new RequestInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		}

		/*
		 * Check to see if a challenge response is present.
		 */
		if ((pdu_challenge_data->u.challenge_request_response.
				bit_mask & CHALLENGE_RESPONSE_PRESENT) &&
				(*return_value == GCC_NO_ERROR))
		{
			/*
			 * Create a ResponseInfo stucture to hold the response data
			 * and copy the challenge response structure internally.
			 */
			DBG_SAVE_FILE_LINE
			m_pInternalResponse = new ResponseInfo;
			if (m_pInternalResponse != NULL)
			{
				*return_value = ConvertPDUChallengeResponse (
						&pdu_challenge_data->u.challenge_request_response.
						challenge_response);
			}
			else
			{
				ERROR_OUT(("CPassword::CPassword: Error creating new ResponseInfo"));
				*return_value = GCC_ALLOCATION_FAILURE;
			}
		} 
	}
}

/*
 *	~CPassword()
 *
 *	Public Function Description:
 *		This is the destructor for the CPassword class.  It will free up
 *		any memory allocated during the life of this object.
 */
CPassword::~CPassword(void)
{
	PChallengeItemInfo			challenge_item_info_ptr;

	delete m_pszNumeric;
	delete m_pwszText;

	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidChallengeResponsePDU)
	{
		FreePasswordChallengeResponsePDU();
	}

	/*
	 * Delete the memory associated with the "API" "simple" password 
	 * data structure.
	 */
	delete m_pPassword;

	/*
	 * Free any data allocated for the "API" challenge password.  This would be
	 * left around if "UnLock" was not called.  Note that if the "challenge" 
	 * password is "clear", the numeric and text pointers above would contain
	 *  the "API" data so now we just need to delete the "challenge" password 
	 * structure.
	 */
	if (m_pChallengeResponse != NULL)
	{
		if (m_fClearPassword == FALSE)
		{
			FreeAPIPasswordData();
		}
		else
		{
			delete m_pChallengeResponse;
		}
	}

	/*
	 * Free any internal memory allocated for the challenge request information.
	 * Iterate through the list of challenge items associated with the 
	 * challenge request, if it exists.
	 */
	if (m_pInternalRequest != NULL)
	{
		m_pInternalRequest->ChallengeItemList.Reset();
		while (NULL != (challenge_item_info_ptr = m_pInternalRequest->ChallengeItemList.Iterate()))
		{
			/*
			 * Delete any memory being referenced in the ChallengeItemInfo 
			 * structure.
			 */
			if (NULL != challenge_item_info_ptr->algorithm.object_key)
			{
			    challenge_item_info_ptr->algorithm.object_key->Release();
			}
			delete challenge_item_info_ptr->algorithm.poszOctetString;
			if (NULL!= challenge_item_info_ptr->challenge_data_list)
			{
			    challenge_item_info_ptr->challenge_data_list->Release();
			}

			/*
			 * Delete the challenge item contained in the list.
			 */
			delete challenge_item_info_ptr;
		}
		
		/*
		 * Delete the request structure.
		 */
		delete m_pInternalRequest;
	}

	/*
	 * Delete any memory allocated for the challenge response information.
	 */
	if (m_pInternalResponse != NULL)
	{
		if (NULL != m_pInternalResponse->algorithm.object_key)
		{
		    m_pInternalResponse->algorithm.object_key->Release();
		}
		delete m_pInternalResponse->algorithm.poszOctetString;
		if (NULL != m_pInternalResponse->challenge_response_item.password)
		{
		    m_pInternalResponse->challenge_response_item.password->Release();
		}
		if (NULL != m_pInternalResponse->challenge_response_item.response_data_list)
		{
		    m_pInternalResponse->challenge_response_item.response_data_list->Release();
		}
		delete m_pInternalResponse;
	}
}


/*
 *	LockPasswordData ()
 *
 *	Public Function Description:
 *		This routine is called to "Lock" the password data.  The first time this
 *		routine is called, the lock count will be zero and this will result
 *		in the password data being copied from the internal structures into an 
 *		"API" structure of the proper form.  Subsequent calls to this routine 
 *		will result in the lock count being incremented. 
 */
GCCError CPassword::LockPasswordData(void)
{
	GCCError rc;

	if (Lock() == 1)
	{
	    rc = GCC_ALLOCATION_FAILURE;
		/*
		 * Check to see whether or not the password contains "challenge"
		 * information.  Fill in the appropriate internal structure.
		 */
		if (m_fSimplePassword)
		{
			if (m_pszNumeric == NULL)
			{
				ERROR_OUT(("CPassword::LockPasswordData: No valid numeric password data exists"));
				goto MyExit;
			}

			DBG_SAVE_FILE_LINE
			if (NULL == (m_pPassword = new GCCPassword))
			{
				ERROR_OUT(("CPassword::LockPasswordData: can't create GCCPassword"));
				goto MyExit;
			}

    		/*
    		 * Fill in the numeric password string which must exist.
    		 */
			m_pPassword->numeric_string = (GCCNumericString) m_pszNumeric;

			/*
			 * Fill in the textual password string.
			 */
			m_pPassword->text_string = m_pwszText;
		}
		else
		{
			/*
			 * The password contains challenge information so create the 
			 * structure to pass back the necessary information.
			 */
			DBG_SAVE_FILE_LINE
			m_pChallengeResponse = new GCCChallengeRequestResponse;
			if (m_pChallengeResponse == NULL)
			{
				ERROR_OUT(("CPassword::LockPasswordData: can't create GCCChallengeRequestResponse"));
				goto MyExit;
			}
			::ZeroMemory(m_pChallengeResponse, sizeof(GCCChallengeRequestResponse));

			/*
			 * Fill in the "API" password challenge structure after 
			 * determining what type exists.
			 */
			if (m_fClearPassword)
			{
				/*
				 * This password contains no "challenge" information.
				 */
				m_pChallengeResponse->password_challenge_type = GCC_PASSWORD_IN_THE_CLEAR;

				/*
				 * This "clear" part of the	password is a "selector" which 
				 * means the form is either	numeric or text.  The check to
				 * verify that at least one form exists was done on
				 * construction.
				 */
				m_pChallengeResponse->u.password_in_the_clear.numeric_string = m_pszNumeric;
				m_pChallengeResponse->u.password_in_the_clear.text_string = m_pwszText;
			}
			else
			{
				/*
				 * This password contains real "challenge" information.
				 */
				m_pChallengeResponse->password_challenge_type = GCC_PASSWORD_CHALLENGE;

				/*
				 * Check to see if a challenge request exists.  If so,
				 * create a GCCChallengeRequest to hold the "API" data and 
				 * fill in that structure.
				 */
				if (m_pInternalRequest != NULL)
				{
					DBG_SAVE_FILE_LINE
					m_pChallengeResponse->u.challenge_request_response.
							challenge_request = new GCCChallengeRequest;
					if (m_pChallengeResponse->u.challenge_request_response.
							challenge_request == NULL)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't create GCCChallengeRequest"));
						goto MyExit;
					}

					if (GetGCCChallengeRequest(m_pChallengeResponse->u.
							challenge_request_response.challenge_request) != GCC_NO_ERROR)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't gett GCCChallengeRequest"));
						goto MyExit;
					}
				}
				else
				{
					m_pChallengeResponse->u.challenge_request_response.challenge_request = NULL;
				}

				/*
				 * Check to see if a challenge response exists.  If so,
				 * create a GCCChallengeResponse to hold the "API" data and 
				 * fill in that structure.
				 */
				if (m_pInternalResponse != NULL)
				{
					DBG_SAVE_FILE_LINE
					m_pChallengeResponse->u.challenge_request_response.
							challenge_response = new GCCChallengeResponse;
					if (m_pChallengeResponse->u.challenge_request_response.
							challenge_response == NULL)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't create new GCCChallengeResponse"));
						goto MyExit;
					}

					if (GetGCCChallengeResponse(m_pChallengeResponse->u.
					        challenge_request_response.challenge_response) != GCC_NO_ERROR)
					{
						ERROR_OUT(("CPassword::LockPasswordData: can't get GCCChallengeResponse"));
						goto MyExit;
					}
				}
				else
				{
					m_pChallengeResponse->u.challenge_request_response.
							challenge_response = NULL;
				}
			}
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (! m_fSimplePassword)
        {
            if (NULL != m_pChallengeResponse)
            {
                delete m_pChallengeResponse->u.challenge_request_response.challenge_request;
                delete m_pChallengeResponse->u.challenge_request_response.challenge_response;
                delete m_pChallengeResponse;
                m_pChallengeResponse = NULL;
            }
        }
    }

	return rc;
}


/*
 *	GetPasswordData ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the form of 
 *		the "API" structure "GCCPassword".  No "challenge" information is
 *		returned.
 */
GCCError CPassword::GetPasswordData(PGCCPassword *gcc_password)
{
	GCCError	return_value = GCC_NO_ERROR;
	
	/*
	 * If the pointer to the "API" password data is valid, set the output
	 * parameter to return a pointer to the "API" password data.  Otherwise, 
	 * report that the password data has yet to be locked into the "API" form.
	 */ 
	if (m_pPassword != NULL)
	{
		*gcc_password = m_pPassword;
	}
	else
	{
    	*gcc_password = NULL;
		return_value = GCC_ALLOCATION_FAILURE;
		ERROR_OUT(("CPassword::GetPasswordData: Error Data Not Locked"));
	}
	
	return (return_value);
}

/*
 *	GetPasswordChallengeData ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the form of 
 *		the "API" structure "GCCChallengeRequestResponse".
 */
GCCError CPassword::GetPasswordChallengeData(PGCCChallengeRequestResponse *gcc_challenge_password)
{
	GCCError	return_value = GCC_NO_ERROR;

	/*
	 * If the pointer to the "API" password challenge data is valid, set the
	 * output parameter to return a pointer to the "API" password challenge
	 * data.  Otherwise, report that the password data has yet to be locked 
	 * into the "API" form.
	 */ 
	if (m_pChallengeResponse != NULL)
	{
		*gcc_challenge_password = m_pChallengeResponse;
	}
	else
	{
    	*gcc_challenge_password = NULL;
		return_value = GCC_ALLOCATION_FAILURE;
		ERROR_OUT(("CPassword::GetPasswordData: Error Data Not Locked"));
	}
	
	return (return_value);
}

/*
 *	UnLockPasswordData ()
 *
 *	Public Function Description
 *		This routine decrements the lock count and frees the memory associated 
 *		with "API" password data when the lock count reaches zero.
 */
void CPassword::UnLockPasswordData(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Delete the memory associated with the "API" "simple" password 
		 * data structure.
		 */
		delete m_pPassword;
		m_pPassword = NULL;

		/*
		 * Delete the memory associated with the "API" "challenge" password 
		 * data structure.
		 */
		if (m_pChallengeResponse != NULL)
		{
			if (m_fClearPassword == FALSE)
			{
				FreeAPIPasswordData();
			}
			else
			{
				delete m_pChallengeResponse;
				m_pChallengeResponse = NULL;
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetPasswordPDU ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the "PDU" form
 *		of a "Password" structure.
 */
GCCError CPassword::GetPasswordPDU(PPassword pdu_password)
{
	GCCError			return_value = GCC_NO_ERROR;
	
	pdu_password->bit_mask = 0;

	/*
	 * Fill in the numeric portion of the password which must always exist.
	 */	
	if (m_pszNumeric != NULL)
	{
		::lstrcpyA(pdu_password->numeric, m_pszNumeric);
	}
	else
		return_value = GCC_ALLOCATION_FAILURE;
	
	/*
	 * Fill in the optional textual portion of the password if it is present.
	 * Set the bitmask in the PDU structure to indicate that the text exists.
	 */		
	if (m_pwszText != NULL)
	{
		pdu_password->bit_mask |= PASSWORD_TEXT_PRESENT;
		
		pdu_password->password_text.value = m_pwszText; 
		pdu_password->password_text.length= ::lstrlenW(m_pwszText);
	}
	
	return (return_value);
}

/*
 *	GetPasswordSelectorPDU ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the password data in the "PDU" form
 *		of a "PasswordSelector" structure.  In a "PasswordSelector" either the
 *		numeric or the text version of the password exists, but not both.
 */
GCCError CPassword::GetPasswordSelectorPDU(PPasswordSelector password_selector_pdu)
{
	GCCError		return_value = GCC_NO_ERROR;
	
	/*
	 * Fill in the version of the password which exists and set
	 * the "choice" to indicate what type of password this is.
	 */
	if (m_pszNumeric != NULL)
	{
		password_selector_pdu->choice = PASSWORD_SELECTOR_NUMERIC_CHOSEN;
		
		::lstrcpyA(password_selector_pdu->u.password_selector_numeric, m_pszNumeric);
	}
	else if (m_pwszText != NULL)
	{
		password_selector_pdu->choice = PASSWORD_SELECTOR_TEXT_CHOSEN;
		password_selector_pdu->u.password_selector_text.value = m_pwszText; 
		password_selector_pdu->u.password_selector_text.length = ::lstrlenW(m_pwszText);
	}
	else
	{
		ERROR_OUT(("CPassword::GetPasswordSelectorPDU: No valid data"));
		return_value = GCC_INVALID_PASSWORD;
	}
	
   return (return_value);
}

/*
 *	GetPasswordChallengeResponsePDU	()
 *
 *	Public Function Description:
 *		This routine fills in a password challenge request-response "PDU"
 *		structure with the password data.
 */
GCCError CPassword::GetPasswordChallengeResponsePDU(PPasswordChallengeRequestResponse challenge_pdu)
{
	GCCError			return_value = GCC_NO_ERROR;
	
	/*
	 * Check to see if this is a "simple" password.  If it is, then this routine
	 * has been called in error.
	 */
	if ((challenge_pdu == NULL) || m_fSimplePassword)
	{
		ERROR_OUT(("CPassword::GetPasswordChallengeResponsePDU: no challenge data"));
		return (GCC_INVALID_PARAMETER);
	}

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidChallengeResponsePDU == FALSE)
	{
		m_fValidChallengeResponsePDU = TRUE;

		/*
		 * Fill in the password challenge PDU structure.
		 */
		if (m_fClearPassword)
		{
			/*
			 * If this is a clear password then fill in the text or
			 * numeric string as well as the choice.  Only one form of the
			 * password exists for PasswordSelectors such as this.
			 */
			m_ChallengeResponsePDU.choice = CHALLENGE_CLEAR_PASSWORD_CHOSEN;

			if (m_pszNumeric != NULL)
			{
				m_ChallengeResponsePDU.u.challenge_clear_password.choice =
											PASSWORD_SELECTOR_NUMERIC_CHOSEN;
				
				::lstrcpyA(m_ChallengeResponsePDU.u.challenge_clear_password.u.password_selector_numeric,
						m_pszNumeric);
			}
			else if (m_pwszText != NULL)
			{
				m_ChallengeResponsePDU.u.challenge_clear_password.choice =
												PASSWORD_SELECTOR_TEXT_CHOSEN;

				m_ChallengeResponsePDU.u.challenge_clear_password.u.
						password_selector_text.value = m_pwszText;
 
				m_ChallengeResponsePDU.u.challenge_clear_password.u.
						password_selector_text.length = ::lstrlenW(m_pwszText);
			}
			else
			{
				ERROR_OUT(("CPassword::GetPwordChallengeResPDU: No valid data"));
				return_value = GCC_INVALID_PASSWORD;
			}
		}
		else
		{
			/*
			 * The challenge password contains challenge information.  Fill in
			 * the request and response structures if they exist.
			 */
			m_ChallengeResponsePDU.choice = CHALLENGE_REQUEST_RESPONSE_CHOSEN; 
			m_ChallengeResponsePDU.u.challenge_request_response.bit_mask = 0;

			/*
			 * Check to see if a "request" exists.
			 */
			if (m_pInternalRequest != NULL)
			{
				m_ChallengeResponsePDU.u.challenge_request_response.bit_mask |=
												CHALLENGE_REQUEST_PRESENT;

				/*
				 * Call the routine which fills in the PDU form of the
				 * request structure.
				 */
				return_value = GetChallengeRequestPDU (&m_ChallengeResponsePDU.
						u.challenge_request_response.challenge_request);
			}

			/*
			 * Check to see if a "response" exists.
			 */
			if ((m_pInternalResponse != NULL) && (return_value == GCC_NO_ERROR))
			{
				m_ChallengeResponsePDU.u.challenge_request_response.bit_mask |=
												CHALLENGE_RESPONSE_PRESENT;

				/*
				 * Call the routine which fills in the PDU form of the
				 * response structure.
				 */
				return_value = GetChallengeResponsePDU (&m_ChallengeResponsePDU.
						u.challenge_request_response.challenge_response);
			}
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*challenge_pdu = m_ChallengeResponsePDU;
		
	return (return_value);
}
									

/*
 *	FreePasswordChallengeResponsePDU ()
 *
 *	Public Function Description:
 *		This routine is used to free any memory allocated to hold "PDU" data
 * 		associated with the PasswordChallengeRequestResponse.
 */
void CPassword::FreePasswordChallengeResponsePDU(void)
{
	/*
	 * Check to see if there has been any "PDU" memory allocated which now
	 * needs to be freed.
	 */
	if (m_fValidChallengeResponsePDU)
	{
		/*
		 * Set the flag indicating that PDU password data is no longer
		 * allocated.
		 */
		m_fValidChallengeResponsePDU = FALSE;

		/*
		 * Check to see what type of password PDU is to be freed.  If this is a
		 * clear password then no data was allocated which now must be freed.
		 */
		if (m_ChallengeResponsePDU.choice == CHALLENGE_REQUEST_RESPONSE_CHOSEN)
		{
			/*
			 * This is a challenge password so free any data which was allocated
			 * to hold the challenge information.  Check the PDU structure 
			 * bitmask which indicates what form of challenge exists.
			 */
			if (m_ChallengeResponsePDU.u.challenge_request_response.bit_mask & 
													CHALLENGE_REQUEST_PRESENT)
			{
				FreeChallengeRequestPDU ();
			}
			
			if (m_ChallengeResponsePDU.u.challenge_request_response.
					bit_mask & CHALLENGE_RESPONSE_PRESENT)
			{
				FreeChallengeResponsePDU ();
			}
		}
	}
}
									

/*
 *	GCCError	ConvertAPIChallengeRequest(
 *							PGCCChallengeRequest		challenge_request)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy an "API" challenge request structure into
 *		the internal structure.
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertAPIChallengeRequest(PGCCChallengeRequest challenge_request)
{
	GCCError				return_value = GCC_NO_ERROR;
	GCCError				error_value;
	Int						i;
	PGCCChallengeItem		challenge_item_ptr;
	PChallengeItemInfo		challenge_item_info_ptr;

	/*
	 * Save the challenge tag and number of challenge items in the internal
	 * structure.
	 */
	m_pInternalRequest->challenge_tag = challenge_request->challenge_tag;

	/*
	 * Save the list of challenge items in the internal Rogue Wave List.
	 */
	for (i = 0; i < challenge_request->number_of_challenge_items; i++)
	{
		DBG_SAVE_FILE_LINE
		challenge_item_info_ptr = new ChallengeItemInfo;
		if (challenge_item_info_ptr != NULL)
		{
			/*
			 * Initialize the pointers in the challenge item info structure
			 * to NULL.
			 */
			challenge_item_info_ptr->algorithm.object_key = NULL;
			challenge_item_info_ptr->algorithm.poszOctetString = NULL;
			challenge_item_info_ptr->challenge_data_list = NULL;

			/*
			 * Insert the pointer to the new challenge item structure into the 
			 * internal list.
			 */
			m_pInternalRequest->ChallengeItemList.Append(challenge_item_info_ptr);

			/*
			 * Retrieve the pointer to the challenge item from the input list.
			 */
			challenge_item_ptr = challenge_request->challenge_item_list[i];

			/*
			 * Copy the challenge response algorithm to the internal structure.
			 */
			return_value = CopyResponseAlgorithm (
					&(challenge_item_ptr->response_algorithm),
					&(challenge_item_info_ptr->algorithm));

			if (return_value != GCC_NO_ERROR)
			{
				ERROR_OUT(("Password::ConvertAPIChallengeRequest: Error copying Response Algorithm."));
				break;
			}

			/*
			 * Copy the challenge data.
			 */
			if ((challenge_item_ptr->number_of_challenge_data_members != 0) && 
					(challenge_item_ptr->challenge_data_list != NULL))
			{
				DBG_SAVE_FILE_LINE
				challenge_item_info_ptr->challenge_data_list = new CUserDataListContainer(
						challenge_item_ptr->number_of_challenge_data_members,
						challenge_item_ptr->challenge_data_list,
						&error_value);
				if ((challenge_item_info_ptr == NULL) || 
						(error_value != GCC_NO_ERROR))
				{
					ERROR_OUT(("Password::ConvertAPIChallengeRequest: can't create CUserDataListContainer."));
					return_value = GCC_ALLOCATION_FAILURE;
					break;
				}
			}
			else
			{
				challenge_item_info_ptr->challenge_data_list = NULL;
				ERROR_OUT(("Password::ConvertAPIChallengeRequest: Error no valid user data."));
				return_value = GCC_INVALID_PASSWORD;
				break;
			}
		}
		else
		{
			ERROR_OUT(("Password::ConvertAPIChallengeRequest: Error creating "
					"new ChallengeItemInfo."));
			return_value = GCC_ALLOCATION_FAILURE;
			break;
		}
	}
	
	return (return_value);
}

/*
 *	GCCError	ConvertAPIChallengeResponse(
 *							PGCCChallengeResponse		challenge_response)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy an "API" challenge response structure into
 *		the internal structure.
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertAPIChallengeResponse(PGCCChallengeResponse challenge_response)
{
	GCCError			return_value = GCC_NO_ERROR;
	GCCError			error_value;
			
	/*
	 * Initialize the challenge response info structure pointers to NULL.
	 */
	m_pInternalResponse->challenge_response_item.password = NULL;
	m_pInternalResponse->challenge_response_item.response_data_list = NULL;

	/*
	 * Save the challenge tag in the internal structure.
	 */
	m_pInternalResponse->challenge_tag = challenge_response->challenge_tag;

	/*
	 * Copy the challenge response algorithm to the internal structure.
	 */
	return_value = CopyResponseAlgorithm (
			&(challenge_response->response_algorithm),
			&(m_pInternalResponse->algorithm));
	if (return_value != GCC_NO_ERROR)
	{
		ERROR_OUT(("Password::ConvertAPIChallengeResponse: Error copying Response Algorithm."));
	}

	/*
	 * Copy the challenge response item into the internal info structure.
	 * The challenge response item will consist of either a password string
	 * or else a response user data list.
	 */
	if (return_value == GCC_NO_ERROR)
	{
		if (challenge_response->response_algorithm.password_algorithm_type ==
												GCC_IN_THE_CLEAR_ALGORITHM)
		{
			if (challenge_response->response_item.password_string != NULL)
			{
				DBG_SAVE_FILE_LINE
				m_pInternalResponse->challenge_response_item.password = new 
						CPassword(challenge_response->response_item.password_string, &error_value);
				if ((m_pInternalResponse->challenge_response_item.password == 
						NULL)||	(error_value != GCC_NO_ERROR))
				{
					ERROR_OUT(("Password::ConvertAPIChallengeResp: Error creating new CPassword."));
					return_value = GCC_ALLOCATION_FAILURE;
				}
			}
			else
				return_value = GCC_INVALID_PASSWORD;
		}
		else
		{
			if ((challenge_response->response_item.
				number_of_response_data_members != 0) && 
				(challenge_response->response_item.response_data_list != NULL))
			{
				/* 
				 * Save the response data list in a CUserDataListContainer object.
				 */
				DBG_SAVE_FILE_LINE
				m_pInternalResponse->challenge_response_item.response_data_list = 
					new CUserDataListContainer(challenge_response->response_item.number_of_response_data_members,
						        challenge_response->response_item.response_data_list,
						        &error_value);
				if ((m_pInternalResponse->challenge_response_item.response_data_list == NULL) || 
					(error_value != GCC_NO_ERROR))
				{
					ERROR_OUT(("Password::ConvertAPIChallengeResponse: can't create CUserDataListContainer."));
					return_value = GCC_ALLOCATION_FAILURE;
				}
			}
			else
				return_value = GCC_INVALID_PASSWORD;
		}
	}

	/*
	 * Check to make sure one type of response item was saved.
	 */
	if ((return_value == GCC_NO_ERROR) && 
			(m_pInternalResponse->challenge_response_item.password == NULL) && 
			(m_pInternalResponse->challenge_response_item.response_data_list == 
			NULL))
	{
		ERROR_OUT(("Password::ConvertAPIChallengeResponse: Error no valid response item saved."));
		return_value = GCC_ALLOCATION_FAILURE;
	}

	return (return_value);
}

/*
 *	GCCError	CopyResponseAlgorithm(
 *					PGCCChallengeResponseAlgorithm		source_algorithm,
 *					PResponseAlgorithmInfo				destination_algorithm)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy an "API" response algorithm into the
 *		internal storage structure.
 *
 *	Formal Parameters:
 *		source_algorithm		(i)	The API algorithm structure to copy 
 *										internally.
 *		destination_algorithm	(o)	Pointer to the internal algorithm structure
 *										which will hold the converted item.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::CopyResponseAlgorithm(
					PGCCChallengeResponseAlgorithm		source_algorithm,
					PResponseAlgorithmInfo				destination_algorithm)
{
	GCCError			return_value = GCC_NO_ERROR;
	GCCError			error_value;

	/*
	 * Copy the challenge response algorithm.
	 */
	destination_algorithm->algorithm_type = source_algorithm->
													password_algorithm_type;

	if (destination_algorithm->algorithm_type == GCC_NON_STANDARD_ALGORITHM)
	{
		/* 
		 * Create a new CObjectKeyContainer object to hold the algorithm's object key
		 * internally.
		 */
		DBG_SAVE_FILE_LINE
		destination_algorithm->object_key = new CObjectKeyContainer(
							&source_algorithm->non_standard_algorithm->object_key,
							&error_value);
		if (destination_algorithm->object_key == NULL)
		{
			ERROR_OUT(("CPassword::CopyResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
		else if (error_value != GCC_NO_ERROR)
		{
			ERROR_OUT(("CPassword::CopyResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_INVALID_PASSWORD;
		}

		if (return_value == GCC_NO_ERROR)
		{
			/* 
			 * Create a new Rogue Wave string to hold the algorithm's octet 
			 * string internally.
			 */
			if (NULL == (destination_algorithm->poszOctetString = ::My_strdupO2(
						source_algorithm->non_standard_algorithm->parameter_data.value,
						source_algorithm->non_standard_algorithm->parameter_data.length)))
			{	
				ERROR_OUT(("CPassword::CopyResponseAlgorithm: can't create octet string in algorithm"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
			destination_algorithm->poszOctetString = NULL;
	}
	else
	{
		/*
		 * The algorithm is a standard type so initialize to NULL the pointers
		 * used to hold the data associated with a non-standard algorithm.
		 */
		destination_algorithm->object_key = NULL;
		destination_algorithm->poszOctetString = NULL;
	}

	return (return_value);
}

/*
 *	GCCError	ConvertPDUChallengeRequest (
 *					PChallengeRequest					challenge_request);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy a "PDU" challenge request structure into
 *		the internal storage structure.
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUChallengeRequest(PChallengeRequest challenge_request)
{
	GCCError				return_value = GCC_NO_ERROR;
	PSetOfChallengeItems	current_challenge_item_set;
	PSetOfChallengeItems	next_challenge_item_set;

	/*
	 * Save the challenge tag in the internal structure.
	 */
	m_pInternalRequest->challenge_tag = challenge_request->challenge_tag;

	if (challenge_request->set_of_challenge_items != NULL)
	{
		/*
		 * Loop through the PDU set of challenge items, converting each into
		 * the internal form.
		 */
		current_challenge_item_set = challenge_request->set_of_challenge_items;
		while (1)
		{
			next_challenge_item_set = current_challenge_item_set->next;

			/*
			 * The routine which converts the challenge items saves the internal
			 * form in a Rogue Wave list.
			 */
			if (ConvertPDUChallengeItem (&current_challenge_item_set->value) !=
					GCC_NO_ERROR)
			{
				return_value = GCC_ALLOCATION_FAILURE;
				break;
			}

			if (next_challenge_item_set != NULL)
				current_challenge_item_set = next_challenge_item_set;
			else
				break;	
		}
	}

	return (return_value);
}


/*
 *	GCCError	ConvertPDUChallengeItem (
 *					PChallengeItem						challenge_item_ptr);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy a "PDU" ChallengeItem structure into
 *		the internal ChallengeItemInfo storage structure.
 *
 *	Formal Parameters:
 *		challenge_item_ptr		(i)	The PDU structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUChallengeItem(PChallengeItem challenge_item_ptr)
{
	PChallengeItemInfo		challenge_item_info_ptr;
	GCCError				return_value = GCC_NO_ERROR;
	GCCError				error_value = GCC_NO_ERROR;

	/*
	 * Create a new challenge item and save it in the internal Rogue Wave List.
	 */
	DBG_SAVE_FILE_LINE
	challenge_item_info_ptr = new ChallengeItemInfo;
	if (challenge_item_info_ptr != NULL)
	{
		/*
		 * Insert the pointer to the new challenge item structure into the 
		 * internal Rogue Wave list.
		 */
		challenge_item_info_ptr->challenge_data_list = NULL;
	
		m_pInternalRequest->ChallengeItemList.Append(challenge_item_info_ptr);

		/*
		 * Convert the challenge response algorithm to the internal structure.
		 */
		if (ConvertPDUResponseAlgorithm(
				&(challenge_item_ptr->response_algorithm),
				&(challenge_item_info_ptr->algorithm)) != GCC_NO_ERROR)
		{
			ERROR_OUT(("Password::ConvertAPIChallengeItem: Error converting Response Algorithm."));
			return_value = GCC_ALLOCATION_FAILURE;
		}

		/*
		 * Convert the challenge data to internal form.
		 */
		if ((return_value == GCC_NO_ERROR) &&
				(challenge_item_ptr->set_of_challenge_data != NULL))
		{
			DBG_SAVE_FILE_LINE
			challenge_item_info_ptr->challenge_data_list = new CUserDataListContainer(
					challenge_item_ptr->set_of_challenge_data,
					&error_value);
			if ((challenge_item_info_ptr->challenge_data_list == NULL) || 
					(error_value != GCC_NO_ERROR))
			{
				ERROR_OUT(("Password::ConvertAPIChallengeItem: can't create CUserDataListContainer."));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("Password::ConvertAPIChallengeItem: Error no valid user data"));
			return_value = GCC_INVALID_PASSWORD;
		}
	}
	else
	{
		ERROR_OUT(("Password::ConvertAPIChallengeItem: Error creating "
				"new ChallengeItemInfo."));
		return_value = GCC_ALLOCATION_FAILURE;
	}
	
	return (return_value);
}

/*
 *	GCCError	ConvertPDUChallengeResponse (
 *							PChallengeResponse			challenge_response)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to copy a "PDU" challenge response structure into
 *		the internal structure.
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The API structure to copy internally.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUChallengeResponse(PChallengeResponse challenge_response)
{
	GCCError				return_value = GCC_NO_ERROR;
	GCCError				error_value = GCC_NO_ERROR;

	/*
	 * Save the challenge tag in the internal structure.
	 */
	m_pInternalResponse->challenge_tag = challenge_response->challenge_tag;

	/*
	 * Convert the challenge response algorithm to the internal structure.
	 */
	if (ConvertPDUResponseAlgorithm(
			&(challenge_response->response_algorithm),
			&(m_pInternalResponse->algorithm)) != GCC_NO_ERROR)
	{
		ERROR_OUT(("Password::ConvertPDUChallengeResponse: Error converting Response Algorithm."));
		return_value = GCC_ALLOCATION_FAILURE;
	}

	/*
	 * Check to see what form the challenge response item has taken.  Create
	 * the necessary object to hold the item internally.
	 */
	if ((challenge_response->response_item.choice == PASSWORD_STRING_CHOSEN) &&
			(return_value == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		m_pInternalResponse->challenge_response_item.password = new CPassword(
			&challenge_response->response_item.u.password_string,
			&error_value);
		if ((m_pInternalResponse->challenge_response_item.password == NULL) || 
				(error_value != GCC_NO_ERROR))
		{
			ERROR_OUT(("Password::ConvertPDUChallengeResponse: Error creating new CPassword."));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		m_pInternalResponse->challenge_response_item.password = NULL;

	if ((challenge_response->response_item.choice == 
			SET_OF_RESPONSE_DATA_CHOSEN) && (return_value == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		m_pInternalResponse->challenge_response_item.response_data_list = 
				new CUserDataListContainer(challenge_response->response_item.u.set_of_response_data,
				            &error_value);
		if ((m_pInternalResponse->challenge_response_item.
				response_data_list == NULL) || (error_value != GCC_NO_ERROR))
		{
			ERROR_OUT(("Password::ConvertPDUChallengeResponse: can't create CUserDataListContainer."));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
    {
		m_pInternalResponse->challenge_response_item.response_data_list = NULL;
    }

	return (return_value);
}

/*
 *	GCCError	ConvertPDUResponseAlgorithm (
 *					PChallengeResponseAlgorithm			source_algorithm,
 *					PResponseAlgorithmInfo				destination_algorithm);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to convert a "PDU" response algorithm 
 * 		structure into the internal form.
 *
 *	Formal Parameters:
 *		source_algorithm		(i)	The PDU algorithm structure to copy 
 *										internally.
 *		destination_algorithm	(o) Pointer to the internal structure which will
 *										hold the converted item.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	A NULL pointer was passed in or
 *												the algorithm has invalid type.
 *		GCC_INVALID_PASSWORD			-	An invalid password was passed in. 
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertPDUResponseAlgorithm(
					PChallengeResponseAlgorithm			source_algorithm,
					PResponseAlgorithmInfo				destination_algorithm)
{
	GCCError			return_value = GCC_NO_ERROR;
	GCCError			error_value;;

	if (source_algorithm != NULL)
	{
		/*
		 * Convert the challenge response algorithm type.
		 */
		if (source_algorithm->choice == ALGORITHM_CLEAR_PASSWORD_CHOSEN)
			destination_algorithm->algorithm_type = GCC_IN_THE_CLEAR_ALGORITHM;
		else if (source_algorithm->choice == NON_STANDARD_ALGORITHM_CHOSEN)
			destination_algorithm->algorithm_type = GCC_NON_STANDARD_ALGORITHM;
		else
		{
			ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error: invalid password type"));
			return_value = GCC_INVALID_PARAMETER;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error: NULL source pointer."));
		return_value = GCC_INVALID_PARAMETER;
	}
	
	if ((return_value == GCC_NO_ERROR) && 
			(source_algorithm->choice == NON_STANDARD_ALGORITHM_CHOSEN))
	{
		/* 
		 * Create a new CObjectKeyContainer object to hold the algorithm's object key
		 * internally.
		 */
		DBG_SAVE_FILE_LINE
		destination_algorithm->object_key = new CObjectKeyContainer(
							&source_algorithm->u.non_standard_algorithm.key,
							&error_value);
		if (destination_algorithm->object_key == NULL)
		{
			ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
		else if (error_value != GCC_NO_ERROR)
		{
			ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: Error creating new CObjectKeyContainer"));
			return_value = GCC_INVALID_PASSWORD;
		}
		else
		{
			/* 
			 * Create a new Rogue Wave string to hold the algorithm's octet
			 * string internally.
			 */
			if (NULL == (destination_algorithm->poszOctetString = ::My_strdupO2(
					source_algorithm->u.non_standard_algorithm.data.value,
					source_algorithm->u.non_standard_algorithm.data.length)))
			{	
				ERROR_OUT(("CPassword::ConvertPDUResponseAlgorithm: can't create octet string in algorithm"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
	}
	else
	{
		/*
		 * The algorithm is a standard type so initialize to NULL the pointers
		 * used to hold the data associated with a non-standard algorithm.
		 */
		destination_algorithm->poszOctetString = NULL;
		destination_algorithm->object_key = NULL;
	}

	return (return_value);
}


/*
 *	GCCError	GetGCCChallengeRequest (
 *					PGCCChallengeRequest				challenge_request)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to fill in the internal "API" challenge request
 *		structure from the internal storage structures.  This is done on a 
 *		"lock" in order to make data available which is suitable for being
 *		passed back up through the API.  
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The API structure to fill in with the "API"
 *										challenge request data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetGCCChallengeRequest(PGCCChallengeRequest challenge_request)
{
	GCCError					return_value = GCC_NO_ERROR;
	UInt						i = 0;
	Int							j = 0;
	PGCCChallengeItem			api_challenge_item_ptr;
	PChallengeItemInfo			internal_challenge_item_ptr;
	PChallengeItemMemoryInfo	internal_challenge_item_memory_ptr;		
	UINT						object_key_length;
	UINT						user_data_length;

	/*
	 * Save the challenge tag and retrieve the number of challenge items.
	 */
	challenge_request->challenge_tag = m_pInternalRequest->challenge_tag;

	challenge_request->number_of_challenge_items = 
							(USHORT) m_pInternalRequest->ChallengeItemList.GetCount();

	if (m_pInternalRequest->ChallengeItemList.GetCount() != 0)
	{
		/*
		 * Allocate the space needed for the list of pointers to GCC challenge 
		 * items.
		 */
		DBG_SAVE_FILE_LINE
		m_pChallengeItemListMemory = new BYTE[sizeof(PGCCChallengeItem) * m_pInternalRequest->ChallengeItemList.GetCount()];
		if (m_pChallengeItemListMemory != NULL)
		{
			PChallengeItemInfo lpChItmInfo;

			/*
			 * Retrieve the actual pointer to memory from the Memory object
			 * and save it in the internal API Challenge Item list.
			 */
			challenge_request->challenge_item_list = (GCCChallengeItem **)
										m_pChallengeItemListMemory;

			/*
			 * Initialize the pointers in the list to NULL.
			 */						
			for (i=0; i < m_pInternalRequest->ChallengeItemList.GetCount(); i++)
				challenge_request->challenge_item_list[i] = NULL;
			
			/*
			 * Copy the data from the internal list of "ChallengeItemInfo" 
			 * structures into the "API" form which is a list of pointers
			 * to GCCChallengeItem structures.
			 */
			m_pInternalRequest->ChallengeItemList.Reset();
			while (NULL != (lpChItmInfo = m_pInternalRequest->ChallengeItemList.Iterate()))
			{
				/* 
				 * Get a pointer to a new GCCChallengeItem structure.
				 */
				DBG_SAVE_FILE_LINE
				api_challenge_item_ptr = new GCCChallengeItem;
				if (api_challenge_item_ptr != NULL)
				{
					/*
					 * Go ahead and put the pointer in the list and 
					 * post-increment the loop counter.
					 */
					challenge_request->challenge_item_list[j++] =
							api_challenge_item_ptr;
			
					/*
					 * Retrieve the ChallengeItemInfo structure from the Rogue 
					 * Wave list.
					 */
					internal_challenge_item_ptr = lpChItmInfo;

					/*
					 * Fill in the algorithm type for the challenge response
					 * algorithm.
					 */
					api_challenge_item_ptr->response_algorithm.
							password_algorithm_type = 
							internal_challenge_item_ptr->
									algorithm.algorithm_type;

					/*
					 * The memory for the response algorithm's object key data 
					 * and the challenge item's used data are stored in
					 * a ChallengeItemMemoryInfo structure so create one
					 * here.  If the response algorithm is "clear" then the
					 * object key data element will not be used.  The challenge
					 * item user data should always exist.
					 */
					DBG_SAVE_FILE_LINE
					internal_challenge_item_memory_ptr = new ChallengeItemMemoryInfo;
					if (internal_challenge_item_memory_ptr != NULL)
					{
						/*
						 * Initialize the pointers in the challenge item 
						 * memory info structure to NULL.
						 */
						internal_challenge_item_memory_ptr->user_data_list_memory = NULL;
						internal_challenge_item_memory_ptr->object_key_memory = NULL;

						/*
						 * Insert the pointer to the new challenge item 
						 * memory structure into the internal Rogue Wave 
						 * list.
						 */
						m_ChallengeItemMemoryList.Append(internal_challenge_item_memory_ptr);
					}
					else
					{
						ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error creating new ChallengeItemMemoryInfo"));
						return_value = GCC_ALLOCATION_FAILURE;
						break;
					}

					if (api_challenge_item_ptr->response_algorithm.password_algorithm_type == 
							GCC_NON_STANDARD_ALGORITHM)
					{
						/*
						 * Create a new GCCNonStandardParameter to put in the
						 * ResponseAlgorithm structure.
						 */
						DBG_SAVE_FILE_LINE
						api_challenge_item_ptr->response_algorithm.non_standard_algorithm = 
								new GCCNonStandardParameter;

						if (api_challenge_item_ptr->response_algorithm.non_standard_algorithm	== NULL)
						{
							ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error creating new GCCNonStdParameter"));
							return_value = GCC_ALLOCATION_FAILURE;
							break;
						}

						/*
						 * Retrieve the API object key from the CObjectKeyContainer
						 * object in the ResponseAlgorithmInfo structure and
						 * fill in the GCCObjectKey in the non-standard 
						 * algorithm.  The CObjectKeyContainer object must be locked 
						 * before getting the data.
						 */
						object_key_length = internal_challenge_item_ptr->
								algorithm.object_key->LockObjectKeyData ();

						DBG_SAVE_FILE_LINE
						internal_challenge_item_memory_ptr->object_key_memory =
						        new BYTE[object_key_length];
						if (internal_challenge_item_memory_ptr->object_key_memory != NULL)
						{
							internal_challenge_item_ptr->algorithm.object_key->GetGCCObjectKeyData(
									&(api_challenge_item_ptr->response_algorithm.non_standard_algorithm->object_key),
									internal_challenge_item_memory_ptr->object_key_memory);
						}
						else
						{
							ERROR_OUT(("CPassword::GetGCCChallengeReq: Error Allocating Memory"));
							return_value = GCC_ALLOCATION_FAILURE;
						 	break;
						}

						/*
						 * Fill in the parameter data for the non-standard
						 * algorithm.  This includes the octet string pointer 
						 * and length.
						 */
						api_challenge_item_ptr->response_algorithm.non_standard_algorithm->
								parameter_data.value = 
								internal_challenge_item_ptr->algorithm.poszOctetString->value;

						api_challenge_item_ptr->response_algorithm.non_standard_algorithm->
								parameter_data.length =
								internal_challenge_item_ptr->algorithm.poszOctetString->length;
					}
					else
					{
						/*
						 * The algorithm is not a non-standard type so set the 
						 * non-standard pointer to NULL.
						 */
						api_challenge_item_ptr->response_algorithm.non_standard_algorithm = NULL;
					}

					/*
					 * Retrieve the API challenge data from the CUserDataListContainer 
					 * object.  The	call to GetUserDataList also returns the 
					 * number of user data members.  The CUserDataListContainer object
					 * must be locked before getting the data in order to 
					 * determine how much memory to allocate to hold the data.
					 */
					if (internal_challenge_item_ptr->challenge_data_list != NULL)
					{
						user_data_length = internal_challenge_item_ptr->
								challenge_data_list->LockUserDataList ();

						/*
						 * The memory for the user data is stored in the
						 * ChallengeItemMemoryInfo structure created above.
						 */
						DBG_SAVE_FILE_LINE
						internal_challenge_item_memory_ptr->user_data_list_memory =
						        new BYTE[user_data_length];
						if (internal_challenge_item_memory_ptr->user_data_list_memory != NULL)
						{
							/*
							 * Retrieve the actual pointer to memory from the 
							 * Memory object and save it in the internal user 
							 * data memory.
							 */
							internal_challenge_item_ptr->challenge_data_list->GetUserDataList(
										&api_challenge_item_ptr->number_of_challenge_data_members,
										&api_challenge_item_ptr->challenge_data_list,
										internal_challenge_item_memory_ptr->user_data_list_memory);
						}
						else
						{
							ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error Allocating Memory"));
							return_value = GCC_ALLOCATION_FAILURE;
						 	break;
						}
					}
					else
					{
						ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error no valid user data"));
						return_value = GCC_ALLOCATION_FAILURE;
					 	break;
					}
				}
				else
				{
					ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error creating new GCCChallengeItem"));
					return_value = GCC_ALLOCATION_FAILURE;
				 	break;
				}
			/*
			 * This is the end of the challenge item iterator loop.
			 */
			}
		}
		else
		{
			ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error Allocating Memory"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 * There are no challenge items in the list so set the list pointer
		 * to NULL.
		 */
		challenge_request->challenge_item_list = NULL;
	}

	return (return_value);
}

/*
 *	GCCError	GetGCCChallengeResponse (
 *					PGCCChallengeResponse				challenge_response);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to fill in the internal "API" challenge response
 *		structure from the internal storage structures.  This is done on a 
 *		"lock" in order to make data available which is suitable for being
 *		passed back up through the API.  
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The API structure to fill in with the "API"
 *										challenge response data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetGCCChallengeResponse(PGCCChallengeResponse challenge_response)
{
	GCCError		return_value = GCC_NO_ERROR;
	UINT			object_key_length;
	UINT			user_data_length;

	challenge_response->challenge_tag = m_pInternalResponse->challenge_tag;

	/*
	 * Fill in the algorithm type for the challenge response algorithm.
	 */
	challenge_response->response_algorithm.password_algorithm_type = 
			m_pInternalResponse->algorithm.algorithm_type;

	/*
	 * If the response algorithm is of non-standard type, create a new 
	 * GCCNonStandardParameter to put in the ResponseAlgorithm structure.
	 */
	if (challenge_response->response_algorithm.password_algorithm_type ==
			GCC_NON_STANDARD_ALGORITHM)
	{
		DBG_SAVE_FILE_LINE
		challenge_response->response_algorithm.non_standard_algorithm =
				new GCCNonStandardParameter;
		if (challenge_response->response_algorithm.non_standard_algorithm == 
				NULL)
		{
			ERROR_OUT(("CPassword::GetGCCChallengeResponse: Error creating new GCCNonStandardParameter"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			/*
			 * Retrieve the API object key from the CObjectKeyContainer object in the 
			 * ResponseAlgorithmInfo structure and fill	in the GCCObjectKey in  
			 * the non-standard algorithm.  The CObjectKeyContainer object must be 
			 * locked before getting the data.
			 */
			object_key_length = m_pInternalResponse->algorithm.object_key->
					LockObjectKeyData ();

    		DBG_SAVE_FILE_LINE
			m_pObjectKeyMemory = new BYTE[object_key_length];
			if (m_pObjectKeyMemory != NULL)
			{
				m_pInternalResponse->algorithm.object_key->
						GetGCCObjectKeyData (&(challenge_response->
								response_algorithm.non_standard_algorithm->
										object_key),
								m_pObjectKeyMemory);
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeResponse: Error Allocating Memory"));
				return_value = GCC_ALLOCATION_FAILURE;
			}

			/*
			 * Fill in the parameter data for the non-standard algorithm.
			 */
			if (return_value == GCC_NO_ERROR)
			{
				/*
				 * Fill in the octet string pointer and length.
				 */
				challenge_response->response_algorithm.non_standard_algorithm->
						parameter_data.value = 
						m_pInternalResponse->algorithm.poszOctetString->value;

				challenge_response->response_algorithm.non_standard_algorithm->
						parameter_data.length = 
						m_pInternalResponse->algorithm.poszOctetString->length;
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error getting GCCObjectKeyData"));
				return_value = GCC_ALLOCATION_FAILURE;
			} 
		}
	}
	else
	{
		/*
		 * The algorithm in not non-standard so set the non-standard algorithm
		 * pointer to NULL.
		 */
		challenge_response->response_algorithm.non_standard_algorithm = NULL;
	}
	
	/*
	 * Now fill in the challenge response item in the challenge response
	 * structure.
	 */
	if (return_value == GCC_NO_ERROR)
	{
		/*
		 * Check to see whether the challenge response item consists of a 
		 * password string or a set of user data.  Fill in the appropriate
		 * part.
		 */
		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			/*
			 * Set the number of user data members to zero to avoid any 
			 * confusion at the application.  This should match up with the 
			 * algorithm being set to "in the clear".
			 */
			challenge_response->response_item.
							number_of_response_data_members = 0;
			challenge_response->response_item.
							response_data_list = NULL;
		
			/* 
			 * Retrieve the API GCCPassword from the CPassword object.  The
			 * CPassword object must be locked before getting the data.
			 */
			if (m_pInternalResponse->challenge_response_item.
					password->LockPasswordData () == GCC_NO_ERROR)
			{
				return_value = m_pInternalResponse->challenge_response_item.
						password->GetPasswordData (&(challenge_response->
						response_item.password_string));
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error locking CPassword"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else if (m_pInternalResponse->challenge_response_item.response_data_list != NULL)
		{
			/*
			 * Set the password string to NULL to avoid any confusion at the 
			 * application.  This should match up with the algorithm set to
			 * non-standard.
			 */
			challenge_response->response_item.password_string = NULL;
			
			/*
			 * Retrieve the API challenge data from the CUserDataListContainer 
			 * object.  The	call to GetUserDataList also returns the 
			 * number of user data members.  The CUserDataListContainer object
			 * must be locked before getting the data in order to 
			 * determine how much memory to allocate to hold the data.
			 */
			user_data_length = m_pInternalResponse->challenge_response_item.
					response_data_list->LockUserDataList ();

    		DBG_SAVE_FILE_LINE
			m_pUserDataMemory = new BYTE[user_data_length];
			if (m_pUserDataMemory != NULL)
			{
				/*
				 * Retrieve the actual pointer to memory from the Memory
				 * object and save it in the internal user data memory.
				 */
				m_pInternalResponse->challenge_response_item.response_data_list->
						GetUserDataList (
								&challenge_response->response_item.
										number_of_response_data_members,
								&challenge_response->response_item.
										response_data_list,
								m_pUserDataMemory);
			}
			else
			{
				ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error allocating memory"));
				return_value = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("CPassword::GetGCCChallengeRequest: Error saving response item"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}

	return (return_value);
}

/*
 *	GCCError	GetChallengeRequestPDU (
 *					PChallengeRequest					challenge_request);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine converts internal challenge request data to "PDU" form.
 *
 *	Formal Parameters:
 *		challenge_request		(i)	The PDU structure to fill in with the
 *										challenge request data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	The algorithm type was not set
 *												properly.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetChallengeRequestPDU(PChallengeRequest challenge_request)
{
	GCCError					return_value = GCC_NO_ERROR;
	PSetOfChallengeItems		new_set_of_challenge_items;
	PSetOfChallengeItems		old_set_of_challenge_items;
	DWORD						number_of_items;
	PChallengeItemInfo			internal_challenge_item_ptr;

	/*
	 * Fill in the challenge tag.
	 */
	challenge_request->challenge_tag = m_pInternalRequest->challenge_tag;

	/*
	 * Initialize the set pointers to NULL in order to detect the first time
	 * through the iterator loop.
	 */
	challenge_request->set_of_challenge_items = NULL;
    old_set_of_challenge_items = NULL;

	/*
	 * Retrieve the number of challenge items in the internal list.
	 */
	number_of_items = m_pInternalRequest->ChallengeItemList.GetCount();

	if (number_of_items > 0)
	{
		PChallengeItemInfo		lpChItmInfo;
		/*
		 * Iterate through the internal list of challenge items, creating a
		 * new "PDU" SetOfChallengeItems for each and filling it in.
		 */
		m_pInternalRequest->ChallengeItemList.Reset();
		while (NULL != (lpChItmInfo = m_pInternalRequest->ChallengeItemList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_set_of_challenge_items = new SetOfChallengeItems;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_set_of_challenge_items == NULL)
			{
				ERROR_OUT(("CPassword::GetChallengeRequestPDU: Allocation error, cleaning up"));
				return_value = GCC_ALLOCATION_FAILURE;
				FreeChallengeRequestPDU ();
				break;
			}

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfChallengeItems created.  On subsequent loops,
			 * set the structure's "next" pointer equal to the new structure.
			 */
			if (challenge_request->set_of_challenge_items == NULL)
			{
				challenge_request->set_of_challenge_items = 
						new_set_of_challenge_items;
			}
			else
				old_set_of_challenge_items->next = new_set_of_challenge_items;
	
			/*
			 * Save the newly created set and initialize the new "next" 
			 * pointer to NULL in case this is the last time through the loop.
			 */
			old_set_of_challenge_items = new_set_of_challenge_items;
			new_set_of_challenge_items->next = NULL;

			/*
			 * Retrieve the ChallengeItemInfo structure from the Rogue 
			 * Wave list and fill in the "PDU" challenge item structure from 
			 * the internal	challenge item structure.
			 */
			internal_challenge_item_ptr = lpChItmInfo;

			return_value = ConvertInternalChallengeItemToPDU (
										internal_challenge_item_ptr,
										&new_set_of_challenge_items->value);
			 
			/*
			 * Cleanup if an error has occurred.
			 */
			if (return_value != GCC_NO_ERROR)
			{
				FreeChallengeRequestPDU ();
			}
		}
	}
	else
	{
		ERROR_OUT(("CPassword::GetChallengeRequestPDU: Error no items"));
	}
		
	return (return_value);
}

/*
 *	GCCError	ConvertInternalChallengeItemToPDU(
 *					PChallengeItemInfo				internal_challenge_item,
 *					PChallengeItem					pdu_challenge_item)
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine converts an internal ChallengeItemInfo structure into
 *		the "PDU" form of a ChallengeItem structure.
 *
 *	Formal Parameters:
 *		internal_challenge_item		(i)	The internal challenge item to convert.
 *		pdu_challenge_item			(o) The	output PDU form of the challenge
 *											item.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	The algorithm type was not set
 *												properly.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::ConvertInternalChallengeItemToPDU(
					PChallengeItemInfo				internal_challenge_item,
					PChallengeItem					pdu_challenge_item)
{
	GCCError		return_value = GCC_NO_ERROR;

	/*
	 * First convert the algorithm.
	 */
	if (internal_challenge_item->algorithm.algorithm_type == 
												GCC_IN_THE_CLEAR_ALGORITHM)
	{
		pdu_challenge_item->response_algorithm.choice = 
				ALGORITHM_CLEAR_PASSWORD_CHOSEN;
	}
	else if (internal_challenge_item->algorithm.algorithm_type == 
												GCC_NON_STANDARD_ALGORITHM)
	{
		pdu_challenge_item->response_algorithm.choice = 
				NON_STANDARD_ALGORITHM_CHOSEN;

		/*
		 * Retrieve the "PDU" object key data from the internal CObjectKeyContainer
		 * object.
		 */
		if (internal_challenge_item->algorithm.object_key->
				GetObjectKeyDataPDU (
						&pdu_challenge_item->response_algorithm.u.
						non_standard_algorithm.key) == GCC_NO_ERROR)
		{
			/*
			 * Retrieve the non-standard parameter data from the internal
			 * algorithm octet string.
			 */
			pdu_challenge_item->response_algorithm.u.non_standard_algorithm.data.value = 
						internal_challenge_item->algorithm.poszOctetString->value;

			pdu_challenge_item->response_algorithm.u.non_standard_algorithm.data.length = 
						internal_challenge_item->algorithm.poszOctetString->length;
		}
		else
		{
			ERROR_OUT(("CPassword::ConvertInternalChallengeItemToPDU: Error getting ObjKeyData"));
			return_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CPassword::ConvertInternalChallengeItemToPDU: Error bad algorithm type"));
		return_value = GCC_INVALID_PARAMETER;
	}

	/*
	 * Now retrieve the set of user data.
	 */
	if (return_value == GCC_NO_ERROR)
	{
		return_value = internal_challenge_item->challenge_data_list->
				GetUserDataPDU (&pdu_challenge_item->set_of_challenge_data);
	}
		
	return (return_value);
}

/*
 *	GCCError	GetChallengeResponsePDU (
 *					PChallengeResponse					challenge_response);
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine converts internal challenge response data to "PDU" form.
 *
 *	Formal Parameters:
 *		challenge_response		(i)	The PDU structure to fill in with the
 *										challenge response data.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			- 	The form of the password is not 
 *												valid.
 *		GCC_INVALID_PARAMETER			-	The algorithm type was not set
 *												properly.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CPassword::GetChallengeResponsePDU(PChallengeResponse challenge_response)
{
	GCCError	return_value = GCC_NO_ERROR;

	/*
	 * Fill in the challenge tag.
	 */
	challenge_response->challenge_tag = m_pInternalResponse->challenge_tag;

	/*
	 * Fill in the response algorithm.
	 */
	if (m_pInternalResponse->algorithm.algorithm_type ==
													GCC_IN_THE_CLEAR_ALGORITHM)
	{
		challenge_response->response_algorithm.choice = 
				ALGORITHM_CLEAR_PASSWORD_CHOSEN;
	
		/*
		 * Now convert the challenge response item.  The challenge response item
		 * will consist of either a password string or a set of user data.
		 */
		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			/*
			 * If the password string exists, set the "PDU" choice and retrieve
			 * the password selector data from the internal CPassword object.
			 */
			challenge_response->response_item.choice = PASSWORD_STRING_CHOSEN;

			return_value= m_pInternalResponse->challenge_response_item.password->
					GetPasswordSelectorPDU (&challenge_response->response_item.
					u.password_string);
		}
		else
			return_value = GCC_INVALID_PASSWORD;
	}
	else if (m_pInternalResponse->algorithm.algorithm_type ==
													GCC_NON_STANDARD_ALGORITHM)
	{
		challenge_response->response_algorithm.choice = 
				NON_STANDARD_ALGORITHM_CHOSEN;
		
		/*
		 * Retrieve the "PDU" object key data from the internal CObjectKeyContainer
		 * object.
		 */
		if (m_pInternalResponse->algorithm.object_key->
				GetObjectKeyDataPDU (
						&challenge_response->response_algorithm.u.
						non_standard_algorithm.key) == GCC_NO_ERROR)
		{
			/*
			 * Retrieve the non-standard parameter data from the internal
			 * algorithm octet string.
			 */
			challenge_response->response_algorithm.u.non_standard_algorithm.data.value = 
						m_pInternalResponse->algorithm.poszOctetString->value;

			challenge_response->response_algorithm.u.non_standard_algorithm.data.length = 
						m_pInternalResponse->algorithm.poszOctetString->length;

			if (m_pInternalResponse->challenge_response_item.response_data_list != NULL)
			{
				/*
				 * If the response data list exists, set the "PDU" choice and
				 * retrieve the response data from the internal 
				 * CUserDataListContainer object.
				 */
				challenge_response->response_item.choice = 
						SET_OF_RESPONSE_DATA_CHOSEN;

				return_value = m_pInternalResponse->challenge_response_item.
						response_data_list->GetUserDataPDU (
								&challenge_response->response_item.u.
								set_of_response_data);
			}
			else
				return_value = GCC_INVALID_PASSWORD;
		}
		else
		{
			return_value = GCC_ALLOCATION_FAILURE;
			ERROR_OUT(("CPassword::GetChallengeResponsePDU: Error getting ObjKeyData"));
		}
	}
	else
	{
		ERROR_OUT(("CPassword::GetChallengeResponsePDU: Error bad algorithm type"));
		return_value = GCC_INVALID_PARAMETER;
	}

	return (return_value);
}

/*
 *	void	FreeChallengeRequestPDU ();
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to free any "PDU" data allocated for the
 *		challenge request structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CPassword::FreeChallengeRequestPDU(void)
{
	PSetOfChallengeItems	set_of_challenge_items;
	PSetOfChallengeItems	next_set_of_challenge_items;
	PChallengeItemInfo		challenge_item_ptr;
	PChallengeRequest		challenge_request;

	/*
	 * Retrieve the challenge request pointer from the internally maintained
	 * PasswordChallengeRequestResponse structure and delete each set of
	 * challenge items which was created.
	 */
	challenge_request = &m_ChallengeResponsePDU.u.challenge_request_response.
			challenge_request;

	if (challenge_request != NULL)
	{
		if (challenge_request->set_of_challenge_items == NULL)
		{
			ERROR_OUT(("CPassword::FreeChallengeRequestPDU: NULL ptr passed"));
		}
		else
		{
			set_of_challenge_items = challenge_request->set_of_challenge_items;

			while (1)
			{
				if (set_of_challenge_items == NULL)
					break;

				next_set_of_challenge_items = set_of_challenge_items->next;

				delete set_of_challenge_items;

				set_of_challenge_items = next_set_of_challenge_items;
			}
		}
	}
	else
	{
		WARNING_OUT(("CPassword::FreeChallengeRequestPDU: NULL pointer passed"));
	}

	/*
	 * Loop through the internal list of challenge items, freeing the data 
	 * associated with each challenge item structure contained in the list.
	 */
	m_pInternalRequest->ChallengeItemList.Reset();
	while (NULL != (challenge_item_ptr = m_pInternalRequest->ChallengeItemList.Iterate()))
	{
		/*
		 * Retrieve the ChallengeItemInfo structure from the Rogue 
		 * Wave list and use the CUserDataListContainer object contained in the
		 * structure to free the PDU user data.  Also use the CObjectKeyContainer
		 * object contained in the algorithm structure to free the PDU
		 * data associated with the object key.
		 */
		if (challenge_item_ptr != NULL)
		{
			if (challenge_item_ptr->algorithm.object_key != NULL)
			{
				challenge_item_ptr->algorithm.object_key->FreeObjectKeyDataPDU();
			}
			if (challenge_item_ptr->challenge_data_list != NULL)
			{
				challenge_item_ptr->challenge_data_list->FreeUserDataListPDU();
			}
		}
	}
}

/*
 *	void	FreeChallengeResponsePDU ();
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to free any "PDU" data allocated for the
 *		challenge response structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CPassword::FreeChallengeResponsePDU(void)
{
	PChallengeResponse		challenge_response;

	/*
	 * Retrieve the challenge response pointer from the internally maintained
	 * PasswordChallengeRequestResponse structure.  If it is not equal to NULL
	 * then we know PDU response data has been allocated which must be freed.
	 */
	challenge_response = &m_ChallengeResponsePDU.u.challenge_request_response.
			challenge_response;

	if ((challenge_response != NULL) && (m_pInternalResponse != NULL))
	{
		if (m_pInternalResponse->algorithm.object_key != NULL)
			m_pInternalResponse->algorithm.object_key->FreeObjectKeyDataPDU ();

		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			m_pInternalResponse->challenge_response_item.
					password->FreePasswordChallengeResponsePDU ();
		}
			
		if (m_pInternalResponse->challenge_response_item.
				response_data_list != NULL)
		{
			m_pInternalResponse->challenge_response_item.
					response_data_list->FreeUserDataListPDU ();
		}	
	}
}

/*
 *	void	FreeAPIPasswordData ();
 *
 *	Private member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to free any data allocated by this container to
 * 		hold "API" data.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CPassword::FreeAPIPasswordData(void)
{
	PGCCChallengeItem			challenge_item_ptr;
	PChallengeItemInfo			challenge_item_info_ptr;
	PChallengeItemMemoryInfo	challenge_item_memory_info;
	USHORT						i;

	/*
	 * Delete any "API" memory associated with the challenge request if
	 * it exists.
	 */
	if (m_pChallengeResponse->u.challenge_request_response.
			challenge_request != NULL)
	{
		for (i=0; i<m_pChallengeResponse->u.
				challenge_request_response.challenge_request->
				number_of_challenge_items; i++)
		{
			challenge_item_ptr = m_pChallengeResponse->u.
					challenge_request_response.challenge_request->
					challenge_item_list[i];

			if (challenge_item_ptr != NULL)
			{
				/*
				 * Delete the non-standard algorithm memory.
				 */
				delete challenge_item_ptr->response_algorithm.non_standard_algorithm;
				delete challenge_item_ptr;
			}	
		}

		delete m_pChallengeResponse->u.challenge_request_response.
				challenge_request;
	}
		
	/*
	 * Unlock any memory locked for the challenge request information.
	 */
	if (m_pInternalRequest != NULL)
	{
		/*
		 * Set up an iterator in order to loop through the list of challenge
		 * items, freeing up any allocated memory.
		 */
		m_pInternalRequest->ChallengeItemList.Reset();
		while (NULL != (challenge_item_info_ptr = m_pInternalRequest->ChallengeItemList.Iterate()))
		{
			/*
			 * Unlock any memory being referenced in the ChallengeItemInfo 
			 * structure.
			 */
			if (challenge_item_info_ptr->algorithm.object_key != NULL)
			{
				challenge_item_info_ptr->algorithm.object_key->
						UnLockObjectKeyData ();
			}

			if (challenge_item_info_ptr->challenge_data_list != NULL)
			{
				challenge_item_info_ptr->challenge_data_list->
						UnLockUserDataList ();
			}
		}
	}

	/*
	 * Call the Memory Manager to free the memory allocated to hold the 
	 * challenge request data.
	 */
	while (NULL != (challenge_item_memory_info = m_ChallengeItemMemoryList.Get()))
	{
		delete challenge_item_memory_info->user_data_list_memory;
		delete challenge_item_memory_info->object_key_memory;
		delete challenge_item_memory_info;
	}

	/*
	 * Delete any memory associated with the challenge response if
	 * it exists.
	 */
	if (m_pChallengeResponse->u.challenge_request_response.
			challenge_response != NULL)
	{
		/*
		 * Delete any memory associated with the non-standard algorithm and
		 * then delete the challenge response structure.
		 */
		delete m_pChallengeResponse->u.challenge_request_response.
					challenge_response->response_algorithm.non_standard_algorithm;

		delete m_pChallengeResponse->u.challenge_request_response.
				challenge_response;	
	}

	/*
	 * Unlock any memory allocated for the challenge response information.
	 */
	if (m_pInternalResponse != NULL)
	{
		if (m_pInternalResponse->algorithm.object_key != NULL)
		{
			m_pInternalResponse->algorithm.object_key->UnLockObjectKeyData();
		}

		if (m_pInternalResponse->challenge_response_item.password != NULL)
		{
			m_pInternalResponse->challenge_response_item.password->
					UnLockPasswordData ();
		}

		if (m_pInternalResponse->challenge_response_item.
				response_data_list != NULL)
		{
			m_pInternalResponse->challenge_response_item.response_data_list->
					UnLockUserDataList ();
		}
	}

	/*
	 * Call the Memory Manager to free the memory allocated to hold the 
	 * challenge response data.
	 */
	delete m_pUserDataMemory;
	m_pUserDataMemory = NULL;

	delete m_pObjectKeyMemory;
	m_pObjectKeyMemory = NULL;

	/*
	 * Call the Memory Manager to free the memory allocated to hold the 
	 * challenge request challenge item pointers.
	 */
	delete m_pChallengeItemListMemory;
	m_pChallengeItemListMemory = NULL;

	/*
	 * Delete the challenge password structure and set the pointer to NULL.
	 */
	delete m_pChallengeResponse;
	m_pChallengeResponse = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\packet.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC | ZONE_T120_GCCNC);
/*
 * packet.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 * Abstract:
 *		This is the implementation file for the MCS packet class.  The packet
 *		class is responsible for encoding and decoding the PDUs, as well as
 *		maintaining the necessary pointers to the encoded and decoded data.
 *		Instances of this class will be created both by User and Connection
 *		objects as PDUs flow through MCS.
 *
 * Private Instance Variables:
 *		Packet_Coder
 *			A pointer to the packet coder object.  
 *		Encoded_Lock_Count
 *			A counter indicating the number of locks currently existing on the
 *			encoded data.
 *		Decoded_Lock_Count
 *			A counter indicating the number of locks currently existing on the
 *			decoded data.
 *		Free_State
 *			A boolean value indicating whether the object can be freed when all
 *			lock counts fall to zero.
 *		m_EncodedPDU
 *			This is a pointer to the encoded PDU contained in the internal
 *			buffer.  Note that the reason for keeping this separate is that
 *			the encoded PDU may not start at the beginning of the encoded data
 *			memory block identified above.  Some encoders actually encode the
 *			PDUs backward, or back justified.
 *		Encoded_Data_Length
 *			Indicates the length of the encoded data.  If zero, the packet coder
 *			must be consulted to obtain the length which is subsequently saved.
 *		Decoded_Data_Length     
 *			Indicates the length of the decoded data.  If zero, the packet coder
 *			must be consulted to obtain the length which is subsequently saved.
 *		PDU_Type
 *			Indicates the type of PDU contained in the packet.  Valid values
 *			are DOMAIN_MCS_PDU or CONNECT_MCS_PDU.
 *		Packet_Direction_Up
 *			A boolean indicating whether the direction of travel for the PDU
 *			is upward.
 *
 * Private Member Functions:
 *		PacketSuicideCheck
 *			This function is called by Unlock() as well as any Unlock call
 *			(ie. UnlockUncoded()) when it's associated lock	count falls to
 *			zero.
 *
 * Caveats:
 *		None.
 *
 * Author:
 *		James J. Johnstone IV
 */ 

/*
 *	Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for outgoing PDUs when the packet is to be created from a structure
 *		containing the PDU data to be encoded.
 */
// outgoing packets
Packet::Packet(PPacketCoder	pPacketCoder,
				UINT			nEncodingRules,
				LPVOID			pInputPduStructure,
				int				nPduType,
				BOOL			fPacketDirectionUp,
				PPacketError	pePktErr,
				BOOL			fLockEncodedData)
:
	SimplePacket(fPacketDirectionUp),
	Packet_Coder(pPacketCoder),
	PDU_Type(nPduType),
	m_Decoded_Data (NULL),
	Decoded_Data_Length (0)
{
	/*
	 *	Encode the PDU using the externally provided decoded data. The encoded
	 *	buffer will be allocated by the encoder. The buffer needs to be freed later.
	 */
	if (Packet_Coder->Encode (pInputPduStructure, PDU_Type, nEncodingRules, 
							&m_EncodedPDU, &Encoded_Data_Length))
	{
		ASSERT (m_EncodedPDU);
		/*
		 *	Encoding was successful.
		 */
		*pePktErr = PACKET_NO_ERROR;

		// should we lock encoded data?
		if (fLockEncodedData)
			lLock = 2;
	}
	else
	{
		/*
		 *	Encoding failed.
		 */
		m_EncodedPDU = NULL;
		ERROR_OUT(("Packet::Packet: encoding failed"));
		*pePktErr = PACKET_MALLOC_FAILURE;
	}
}  

/*
 *	Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 */
// incoming packets
Packet::Packet(PPacketCoder		pPacketCoder,
				UINT			nEncodingRules,
				LPBYTE			pEncodedData,
				UINT			cbEncodedDataSize,
				int				nPduType,
				BOOL			fPacketDirectionUp,
				PPacketError	pePktErr)
:
	SimplePacket(fPacketDirectionUp),
	Packet_Coder(pPacketCoder),
	PDU_Type(nPduType)
{
		//PacketCoderError		coder_error;

	m_EncodedPDU = NULL;
	
	/*
	 *	Decode the provided encoded buffer.  Note that the decoder will
	 *	allocate the space needed.  The buffer needs to be freed later.
	 */
	if (Packet_Coder->Decode (pEncodedData, cbEncodedDataSize, PDU_Type,
								nEncodingRules, &m_Decoded_Data, 
								&Decoded_Data_Length) == FALSE)
	{
		ERROR_OUT(("Packet::Packet: Decode call failed."));
		m_Decoded_Data = NULL;
		*pePktErr = PACKET_INCOMPATIBLE_PROTOCOL;
	}
	else
	{ 
		ASSERT (m_Decoded_Data != NULL);
		/*
		 * The decode was successful.
		 */
		*pePktErr = PACKET_NO_ERROR;
	}
}                                             

/*
 *	~Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		Destructor for the Packet class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 */
Packet::~Packet(void)
{
	/*
	 *	If there is memory allocated for encoded data, then free it.
	 */
	if (m_EncodedPDU != NULL) {
		// the encoded memory was allocated by the ASN.1 coder.
		Packet_Coder->FreeEncoded (m_EncodedPDU);
	}

	/*
	 *	If there is memory allocated for decoded data, then free it.
	 */
	if (m_Decoded_Data != NULL) {
		// the decoded memory was allocated by the ASN.1 decoder
		Packet_Coder->FreeDecoded (PDU_Type, m_Decoded_Data);
	}
		
}

/*
 *	IsDataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns whether this is a data packet (it's not).
 */
BOOL Packet::IsDataPacket(void)
{
	return (FALSE);
}                        

/*
 *	GetDecodedData ()
 *
 *	Public
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  If the packet does not have decoded data the Decode method is
 *		called.  If decode is unable to provide decoded data then NULL is
 *		returned.
 */
PVoid	Packet::GetDecodedData ()
{		
	ASSERT (m_Decoded_Data != NULL);
	return (m_Decoded_Data);
}                          

/*
 *	GetPDUType ()
 *
 *	Public
 *
 *	Functional Description:
 *		The GetPDUType method returns the PDU type for the packet.
 */
int	Packet::GetPDUType ()
{		
	return (PDU_Type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\plgxprt.h ===
#ifndef _T120_TRANSPORT_H_
#define _T120_TRANSPORT_H_

#include "iplgxprt.h"
#include "it120xprt.h"
#include "socket.h"
#include "mcattprt.h"
#include "imst123.h"

#define MAX_PLUGGABLE_OUT_BUF_SIZE        32

#define MAX_PLUGXPRT_CONNECTIONS          16
#define MAX_PLUGXPRT_EVENTS               5 // read, write, close, pending read, and pending write

#define MAKE_PLUGXPRT_WPARAM(id,type)     (MAKELONG(id,type))
#define PLUGXPRT_WPARAM_TO_ID(wParam)     (LOWORD(wParam))
#define PLUGXPRT_WPARAM_TO_TYPE(wParam)   (HIWORD(wParam))

#define MAKE_PLUGXPRT_LPARAM(evt,err)     (MAKELONG(evt,err))
#define PLUGXPRT_LPARAM_TO_EVENT(lParam)  (LOWORD(lParam))
#define PLUGXPRT_LPARAM_TO_ERROR(lParam)  (HIWORD(lParam))


enum
{
    PLUGXPRT_PENDING_EVENT          = 0,
    PLUGXPRT_EVENT_READ             = 1,
    PLUGXPRT_EVENT_WRITE            = 2,
    PLUGXPRT_EVENT_CLOSE            = 3,
    PLUGXPRT_EVENT_ACCEPT           = 4,
    PLUGXPRT_EVENT_CONNECT          = 5,
    PLUGXPRT_HIGH_LEVEL_READ        = 6,
    PLUGXPRT_HIGH_LEVEL_WRITE       = 7,
};


class CPluggableOutBufQueue2 : public CQueue2
{
    DEFINE_CQUEUE2(CPluggableOutBufQueue2, LPBYTE, int)
};


class CPluggableConnection : public CRefCount
{
public:

    CPluggableConnection(PLUGXPRT_CALL_TYPE eCaller, HANDLE hCommLink,
                        HANDLE hevtRead, HANDLE hevtWrite, HANDLE hevtClose,
                        PLUGXPRT_FRAMING eFraming, PLUGXPRT_PARAMETERS *pParams,
                        T120Error *);
    ~CPluggableConnection(void);

    LPSTR   GetConnString(void) { return &m_szConnID[0]; }
    UINT    GetConnID(void) { return m_nConnID; }
    HANDLE  GetCommLink(void) { return m_hCommLink; }
    HANDLE  GetReadEvent(void) { return m_hevtRead; }
    HANDLE  GetWriteEvent(void) { return m_hevtWrite; }
    HANDLE  GetCloseEvent(void) { return m_hevtClose; }

    void SetSocket(PSocket pSocket) { m_pSocket = pSocket; }
    PSocket GetSocket(void) { return m_pSocket; }

    TransportType GetType(void) { return m_eType; }

    BOOL IsCaller(void) { return (PLUGXPRT_CALLER == m_eCaller); }
    BOOL IsCallee(void) { return (PLUGXPRT_CALLEE == m_eCaller); }

    HANDLE  GetPendingReadEvent(void) { return m_hevtPendingRead; }
    HANDLE  GetPendingWriteEvent(void) { return m_hevtPendingWrite; }

    T120Error UpdateCommLink(HANDLE hCommLink);


    int Read(LPBYTE buffer, int length, PLUGXPRT_RESULT *);
    BOOL OnPendingRead(void);

    int Write(LPBYTE buffer, int length, PLUGXPRT_RESULT *);
    BOOL OnPendingWrite(void);
    void WriteTheFirst(void);

    void NotifyHighLevelRead(void);
    void NotifyReadFailure(void);

    void NotifyHighLevelWrite(void);
    void NotifyWriteFailure(void);
    void NotifyWriteEvent(void);

    BOOL SetupReadState(int length);
    void CleanupReadState(void);
    void CleanupWriteState(void);

    void Shutdown(void);


    //
    // Legacy PSTN transport
    //
    LEGACY_HANDLE GetLegacyHandle(void) { return m_nLegacyLogicalHandle; }
    void SetLegacyHandle(LEGACY_HANDLE logical_handle) { m_nLegacyLogicalHandle = logical_handle; }
    TransportError TConnectRequest(void);
    TransportError TDisconnectRequest(void);
    int TDataRequest(LPBYTE pbData, ULONG cbDataSize, PLUGXPRT_RESULT *);
    TransportError TPurgeRequest(void);

private:

    PLUGXPRT_STATE      m_eState;
    PLUGXPRT_CALL_TYPE  m_eCaller;

    HANDLE              m_hCommLink;
    HANDLE              m_hevtRead;
    HANDLE              m_hevtWrite;
    HANDLE              m_hevtClose;
    TransportType       m_eType;

    PSocket             m_pSocket;

    UINT                m_nConnID;
    char                m_szConnID[T120_CONNECTION_ID_LENGTH];

    //
    // Legacy PSTN transport
    //
    LEGACY_HANDLE           m_nLegacyLogicalHandle;

    //
    // X.224 framing
    //
    HANDLE              m_hevtPendingRead;  // for asynchronous ReadFile()
    HANDLE              m_hevtPendingWrite; // for asynchronous WriteFile()
    // IO queue management for X.224
    BOOL                    m_fPendingReadDone;
    int                     m_cbPendingRead;
    LPBYTE                  m_pbPendingRead;
    OVERLAPPED              m_OverlappedRead;
    int                     m_cbPendingWrite;
    LPBYTE                  m_pbPendingWrite;
    OVERLAPPED              m_OverlappedWrite;
    CPluggableOutBufQueue2  m_OutBufQueue2;
};




class CPluggableConnectionList : public CList
{
    DEFINE_CLIST(CPluggableConnectionList, CPluggableConnection *)
};


class CPluggableTransport : public IT120PluggableTransport,
                            public CRefCount
{
public:

    CPluggableTransport(void);
    ~CPluggableTransport(void);

    STDMETHOD_(void, ReleaseInterface) (THIS);

    STDMETHOD_(T120Error, CreateConnection) (THIS_
                    char                szConnID[],
                    PLUGXPRT_CALL_TYPE  eCaller,
                    HANDLE              hCommLink,
                    HANDLE              hevtRead,
                    HANDLE              hevtWrite,
                    HANDLE              hevtClose,
                    PLUGXPRT_FRAMING    eFraming,
                    PLUGXPRT_PARAMETERS *pParams);

    STDMETHOD_(T120Error, UpdateConnection) (THIS_
                    LPSTR               pszConnID,
                    HANDLE              hCommLink);

    STDMETHOD_(T120Error, CloseConnection) (THIS_ LPSTR pszConnID);

    STDMETHOD_(T120Error, EnableWinsock) (THIS);

    STDMETHOD_(T120Error, DisableWinsock) (THIS);

    STDMETHOD_(void, Advise) (THIS_ LPFN_PLUGXPRT_CB, LPVOID pContext);

    STDMETHOD_(void, UnAdvise) (THIS);

    STDMETHOD_(void, ResetConnCounter) (THIS);

    void OnProtocolControl(TransportConnection, PLUGXPRT_STATE, PLUGXPRT_RESULT);

    ULONG UpdateEvents(HANDLE *aHandles);
    void OnEventSignaled(HANDLE hevtSignaled);
    void OnEventAbandoned(HANDLE hevtSignaled);

    CPluggableConnection * GetPluggableConnection(PSocket pSocket);
    CPluggableConnection * GetPluggableConnection(UINT_PTR nConnID);
    CPluggableConnection * GetPluggableConnection(HANDLE hCommLink);
    CPluggableConnection * GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE);

    //
    // legacy tranport
    //
    BOOL EnsureLegacyTransportLoaded(void);

private:

    LPFN_PLUGXPRT_CB            m_pfnNotify;
    LPVOID                      m_pContext;
    CPluggableConnectionList    m_PluggableConnectionList;
};

void OnProtocolControl(TransportConnection, PLUGXPRT_STATE,
                       PLUGXPRT_RESULT eResult = PLUGXPRT_RESULT_SUCCESSFUL);

ULONG CreateConnString(int nConnID, char szConnID[]);
BOOL IsValidPluggableTransportName(LPCSTR pcszNodeAddress);
UINT GetPluggableTransportConnID(LPCSTR pcszNodeAddress);
CPluggableConnection * GetPluggableConnection(PSocket pSocket);
CPluggableConnection * GetPluggableConnection(UINT_PTR nConnID);
CPluggableConnection * GetPluggableConnection(HANDLE hCommLink);
CPluggableConnection * GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE);

int SubmitPluggableRead(PSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *);
int SubmitPluggableWrite(PSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *);
void PluggableWriteTheFirst(TransportConnection);
void PluggableShutdown(TransportConnection);


//
// PSTN framing
//
TransportError TReceiveBufferAvailable(void);
extern ILegacyTransport *g_pLegacyTransport;


extern BOOL g_fWinsockDisabled;
extern CRITICAL_SECTION g_csTransport;

#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
LPCSTR FakeNodeAddress(LPCSTR pcszNodeAddress);
#endif

#endif // _T120_TRANSPORT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\plgxprt.cpp ===
#include "precomp.h"
#include "plgxprt.h"

// #undef TRACE_OUT
// #define TRACE_OUT   WARNING_OUT

#define XPRT_CONN_ID_PREFIX         "XPRT"
#define XPRT_CONN_ID_PREFIX_LEN     4

static UINT s_nConnID = 0;

CPluggableTransport *g_pPluggableTransport = NULL;
BOOL                g_fWinsockDisabled = FALSE;
BOOL                g_fPluggableTransportInitialized = FALSE;
DWORD               g_dwPluggableTransportThreadID = 0;
HANDLE              g_hevtUpdatePluggableTransport = FALSE;
CRITICAL_SECTION    g_csTransport;
ILegacyTransport   *g_pLegacyTransport = NULL;
HINSTANCE           g_hlibMST123 = NULL;

BOOL EnsurePluggableTransportThread(void);


extern HWND     TCP_Window_Handle;
extern SOCKET   Listen_Socket;
extern SOCKET   Listen_Socket_Secure;
extern PTransportInterface	g_Transport;
extern UChar g_X224Header[];

extern void CloseListenSocket(void);


T120Error WINAPI T120_CreatePluggableTransport(IT120PluggableTransport **ppTransport)
{
    if (NULL != ppTransport)
    {
        *ppTransport = NULL;
        if (NULL == g_pPluggableTransport)
        {
            if (g_fPluggableTransportInitialized)
            {
                DBG_SAVE_FILE_LINE
                *ppTransport = (CPluggableTransport *) new CPluggableTransport;
                if (NULL != *ppTransport)
                {
                    if (EnsurePluggableTransportThread())
                    {
                        return T120_NO_ERROR;
                    }
                    else
                    {
                        (*ppTransport)->ReleaseInterface();
                        *ppTransport = NULL;
                    }
                }

                return T120_ALLOCATION_FAILURE;
            }

            return T120_NOT_INITIALIZED;
        }

        return T120_ALREADY_INITIALIZED;
    }

    return T120_INVALID_PARAMETER;
}



CPluggableConnection::CPluggableConnection
(
    PLUGXPRT_CALL_TYPE  eCaller,
    HANDLE              hCommLink,
    HANDLE              hevtRead,
    HANDLE              hevtWrite,
    HANDLE              hevtClose,
    PLUGXPRT_FRAMING    eFraming,
    PLUGXPRT_PARAMETERS *pParams,
    T120Error          *pRC
)
:
    CRefCount(MAKE_STAMP_ID('P','X','P','C')),
    m_eState(PLUGXPRT_UNKNOWN_STATE),
    m_eCaller(eCaller),
    m_hCommLink(hCommLink),
    m_hevtRead(hevtRead),
    m_hevtWrite(hevtWrite),
    m_hevtClose(hevtClose),
    m_eType(TRANSPORT_TYPE_PLUGGABLE_X224),
    m_pSocket(NULL),
    // Legacy tranport
    m_nLegacyLogicalHandle(0),
    // IO queue management for X.224 framing
    m_hevtPendingRead(NULL),
    m_hevtPendingWrite(NULL),
    m_fPendingReadDone(FALSE),
    m_cbPendingRead(0),
    m_pbPendingRead(NULL),
    m_cbPendingWrite(0),
    m_pbPendingWrite(NULL),
    m_OutBufQueue2(MAX_PLUGGABLE_OUT_BUF_SIZE)
{
    TransportError err;
    BOOL fCaller = (PLUGXPRT_CALLER == eCaller);

    // X.224 only
    ::ZeroMemory(&m_OverlappedRead, sizeof(m_OverlappedRead));
    ::ZeroMemory(&m_OverlappedWrite, sizeof(m_OverlappedWrite));

    // assign connection ID
    ::EnterCriticalSection(&g_csTransport);
    if (s_nConnID > 0x7FFF)
    {
        s_nConnID = 0;
    }
    m_nConnID = ++s_nConnID;
    ::LeaveCriticalSection(&g_csTransport);

    // create connection ID string
    ::CreateConnString(GetConnID(), m_szConnID);

    // do framing specific initialization
    switch (eFraming)
    {
    case FRAMING_X224:
        m_eType = TRANSPORT_TYPE_PLUGGABLE_X224;

        m_hevtPendingRead  = ::CreateEvent(NULL, TRUE, FALSE, NULL); /* manual reset */
        m_hevtPendingWrite = ::CreateEvent(NULL, TRUE, FALSE, NULL); /* manual reset */
        ASSERT(NULL != m_hevtPendingRead && NULL != m_hevtPendingWrite);
        *pRC = (NULL != m_hevtPendingRead && NULL != m_hevtPendingWrite)
                ? T120_NO_ERROR : T120_ALLOCATION_FAILURE;
        break;

    case FRAMING_LEGACY_PSTN:
        m_eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
        ASSERT(NULL != g_pLegacyTransport);

        err = g_pLegacyTransport->TCreateTransportStack(fCaller, m_hCommLink, m_hevtClose, pParams);
        ASSERT(TRANSPORT_NO_ERROR == err);

        *pRC = (TRANSPORT_NO_ERROR == err) ? T120_NO_ERROR : T120_NO_TRANSPORT_STACKS;
        break;

    default:
        ERROR_OUT(("CPluggableConnection: unknown framing %d", eFraming));
        *pRC = T120_INVALID_PARAMETER;
        break;
    }
}


CPluggableConnection::~CPluggableConnection(void)
{
    if (NULL != m_pSocket)
    {
        ::freePluggableSocket(m_pSocket);
        m_pSocket = NULL;
    }

    Shutdown();

    if (TRANSPORT_TYPE_PLUGGABLE_PSTN == m_eType)
    {
        if (NULL != g_pLegacyTransport && NULL != m_hCommLink)
        {
            g_pLegacyTransport->TCloseTransportStack(m_hCommLink);
        }
    }

    if (NULL != m_hCommLink)
    {
        ::CloseHandle(m_hCommLink);
    }

    if (NULL != m_hevtRead)
    {
        ::CloseHandle(m_hevtRead);
    }

    if (NULL != m_hevtWrite)
    {
        ::CloseHandle(m_hevtWrite);
    }

    if (NULL != m_hevtClose)
    {
        ::CloseHandle(m_hevtClose);
    }

    if (NULL != m_hevtPendingRead)
    {
        ::CloseHandle(m_hevtPendingRead);
    }

    if (NULL != m_hevtPendingWrite)
    {
        ::CloseHandle(m_hevtPendingWrite);
    }
}


ULONG CreateConnString(int nConnID, char szConnID[])
{
    return ::wsprintfA(szConnID, "%s: %u", XPRT_CONN_ID_PREFIX, nConnID);
}


UINT GetPluggableTransportConnID(LPCSTR pcszNodeAddress)
{
    UINT nConnID = 0;
    char szName[T120_CONNECTION_ID_LENGTH];

    // make sure we have a clean buffer to start with
    ::ZeroMemory(szName, sizeof(szName));

    // copy the address string
    ::lstrcpynA(szName, pcszNodeAddress, T120_CONNECTION_ID_LENGTH);

    // make sure we have the semi-colon in place
    if (':' == szName[XPRT_CONN_ID_PREFIX_LEN])
    {
        // compare the prefix string
        szName[XPRT_CONN_ID_PREFIX_LEN] = '\0';
        if (! lstrcmpA(szName, XPRT_CONN_ID_PREFIX))
        {
            LPSTR psz = &szName[XPRT_CONN_ID_PREFIX_LEN+1];

            // get a space?
            if (' ' == *psz++)
            {
                // now, have a number
                if ('0' <= *psz && *psz <= '9')
                {
                    while ('0' <= *psz && *psz <= '9')
                    {
                        nConnID = nConnID * 10 + (*psz++ - '0');
                    }
                }
            }
        }
    }

    return nConnID;
}


BOOL IsValidPluggableTransportName(LPCSTR pcszNodeAddress)
{
    return GetPluggableTransportConnID(pcszNodeAddress);
}


typedef BOOL (WINAPI *LPFN_CANCEL_IO) (HANDLE);
void CPluggableConnection::Shutdown(void)
{
    TRACE_OUT(("CPluggableConnection::Shutdown"));

    if (NULL != m_OverlappedRead.hEvent || NULL != m_OverlappedWrite.hEvent)
    {
        HINSTANCE hLib = ::LoadLibrary("kernel32.dll");
        if (NULL != hLib)
        {
            LPFN_CANCEL_IO pfnCancelIo = (LPFN_CANCEL_IO) ::GetProcAddress(hLib, "CancelIo");
            if (NULL != pfnCancelIo)
            {
                (*pfnCancelIo)(m_hCommLink);
            }
            ::FreeLibrary(hLib);
        }

        m_OverlappedRead.hEvent = NULL;
        m_OverlappedWrite.hEvent = NULL;
    }

    delete [] m_pbPendingRead;
    m_pbPendingRead = NULL;

    LPBYTE buffer;
    while (NULL != (buffer = m_OutBufQueue2.Get()))
    {
        delete [] buffer;
    }
}


T120Error CPluggableConnection::UpdateCommLink(HANDLE hCommLink)
{
    T120Error rc;

    ::EnterCriticalSection(&g_csTransport);

    switch (m_eState)
    {
    case PLUGXPRT_UNKNOWN_STATE:
    case PLUGXPRT_DISCONNECTED:
        Shutdown();
        m_hCommLink = hCommLink;
        rc = T120_NO_ERROR;
        break;

    default:
        rc = T120_TRANSPORT_NOT_READY;
        break;
    }

    ::LeaveCriticalSection(&g_csTransport);

    return rc;
}


CPluggableTransport::CPluggableTransport(void)
:
    CRefCount(MAKE_STAMP_ID('X','P','R','T')),
    m_pfnNotify(NULL),
    m_pContext(NULL)
{
    g_pPluggableTransport = this;
    g_pLegacyTransport = NULL;
}


CPluggableTransport::~CPluggableTransport(void)
{
    ::PostThreadMessage(g_dwPluggableTransportThreadID, WM_QUIT, 0, 0);

    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    while (NULL != (p = m_PluggableConnectionList.Get()))
    {
        p->Release();
    }
    ::LeaveCriticalSection(&g_csTransport);

    if (NULL != g_pLegacyTransport)
    {
        g_pLegacyTransport->TCleanup();
        g_pLegacyTransport->ReleaseInterface();
        g_pLegacyTransport = NULL;
    }

    if (NULL != g_hlibMST123)
    {
        ::FreeLibrary(g_hlibMST123);
        g_hlibMST123 = NULL;
    }

    g_pPluggableTransport = NULL;
}


void CPluggableTransport::ReleaseInterface(void)
{
    UnAdvise();
    CRefCount::Release();
}


T120Error CPluggableTransport::CreateConnection
(
    char                szConnID[], /* out */
    PLUGXPRT_CALL_TYPE  eCaller,
    HANDLE              hCommLink,
    HANDLE              hevtRead,
    HANDLE              hevtWrite,
    HANDLE              hevtClose,
    PLUGXPRT_FRAMING    eFraming,
    PLUGXPRT_PARAMETERS *pParams
)
{
    T120Error rc;

    if (FRAMING_LEGACY_PSTN == eFraming)
    {
        if (! EnsureLegacyTransportLoaded())
        {
            return T120_NO_TRANSPORT_STACKS;
        }
    }

    if (NULL != pParams)
    {
        if (sizeof(PLUGXPRT_PARAMETERS) != pParams->cbStructSize)
        {
            return T120_INVALID_PARAMETER;
        }
    }

    DBG_SAVE_FILE_LINE
    CPluggableConnection *p;
    p = new CPluggableConnection(eCaller, hCommLink, hevtRead, hevtWrite, hevtClose,
                                 eFraming, pParams, &rc);
    if (NULL != p && T120_NO_ERROR == rc)
    {
        ::lstrcpyA(szConnID, p->GetConnString());

        ::EnterCriticalSection(&g_csTransport);
        m_PluggableConnectionList.Append(p);
        ::LeaveCriticalSection(&g_csTransport);

        TransportConnection XprtConn;
        XprtConn.eType = p->GetType();
        XprtConn.nLogicalHandle = p->GetConnID();
        PSocket pSocket = ::newPluggableSocket(XprtConn);
        p->SetSocket(pSocket);
        ASSERT(NULL != pSocket);

        // update the events list to wait for in the plugable transport thread
        ::SetEvent(g_hevtUpdatePluggableTransport);

        return T120_NO_ERROR;
    }

    if (NULL != p)
    {
        p->Release();
    }
    else
    {
        rc = T120_ALLOCATION_FAILURE;
    }

    return rc;
}


T120Error CPluggableTransport::UpdateConnection
(
    LPSTR       pszConnID,
    HANDLE      hCommLink
)
{
    BOOL fFound = FALSE;
    CPluggableConnection *p;
    T120Error rc = GCC_INVALID_TRANSPORT;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (! ::lstrcmpA(p->GetConnString(), pszConnID))
        {
            rc = p->UpdateCommLink(hCommLink);
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    // update the events list to wait for in the plugable transport thread
    ::SetEvent(g_hevtUpdatePluggableTransport);

    return rc;
}


T120Error CPluggableTransport::CloseConnection
(
    LPSTR       pszConnID
)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (! ::lstrcmpA(p->GetConnString(), pszConnID))
        {
            m_PluggableConnectionList.Remove(p);
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    // update the events list to wait for in the plugable transport thread
    ::SetEvent(g_hevtUpdatePluggableTransport);

    if (NULL != p)
    {
        //
        // do real work here
        //
        p->Release();

        return T120_NO_ERROR;
    }

    return GCC_INVALID_TRANSPORT;
}


T120Error CPluggableTransport::EnableWinsock(void)
{
    if (g_fWinsockDisabled)
    {
        g_fWinsockDisabled = FALSE;

        //
        // LONCHANC: create Listen_Socket if not done so...
        //
        if (INVALID_SOCKET == Listen_Socket)
        {
            Listen_Socket = ::CreateAndConfigureListenSocket();
        }
    }

    return T120_NO_ERROR;
}


T120Error CPluggableTransport::DisableWinsock(void)
{
    if (! g_fWinsockDisabled)
    {
        g_fWinsockDisabled = TRUE;

        // close Listen_Socket...
        ::CloseListenSocket();
    }

    return T120_NO_ERROR;
}


void CPluggableTransport::Advise(LPFN_PLUGXPRT_CB pNotify, LPVOID pContext)
{
    m_pfnNotify = pNotify;
    m_pContext = pContext;
}


void CPluggableTransport::UnAdvise(void)
{
    m_pfnNotify = NULL;
    m_pContext = NULL;
}


void CPluggableTransport::ResetConnCounter(void)
{
    s_nConnID = 0;
}


void CPluggableTransport::OnProtocolControl
(
    TransportConnection     XprtConn,
    PLUGXPRT_STATE          eState,
    PLUGXPRT_RESULT         eResult
)
{
    if (IS_PLUGGABLE(XprtConn))
    {
        WARNING_OUT(("CPluggableTransport::OnProtocolControl: socket (%d, %d) is doing %d with result %d",
                        XprtConn.eType, XprtConn.nLogicalHandle, eState, eResult));

        if (NULL != m_pfnNotify)
        {
            CPluggableConnection *p = GetPluggableConnection(XprtConn.nLogicalHandle);
            if (NULL != p)
            {
                PLUGXPRT_MESSAGE Msg;
                Msg.eState = eState;
                Msg.pContext = m_pContext;
                Msg.pszConnID = p->GetConnString();
                // we only support X.224 level notifications
                Msg.eProtocol = PLUGXPRT_PROTOCOL_X224;
                Msg.eResult = eResult;

                (*m_pfnNotify)(&Msg);
            }
        }
    }
}


void OnProtocolControl
(
    TransportConnection     XprtConn,
    PLUGXPRT_STATE          eState,
    PLUGXPRT_RESULT         eResult
)
{
    if (NULL != g_pPluggableTransport)
    {
        g_pPluggableTransport->OnProtocolControl(XprtConn, eState, eResult);
    }
}


// called only in the plugable transport thread
// already in the critical section
ULONG CPluggableTransport::UpdateEvents(HANDLE *aHandles)
{
    ULONG cHandles = 0;
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (TRANSPORT_TYPE_PLUGGABLE_X224 == p->GetType())
        {
            aHandles[cHandles++] = p->GetReadEvent();
            aHandles[cHandles++] = p->GetWriteEvent();
            aHandles[cHandles++] = p->GetCloseEvent();
            aHandles[cHandles++] = p->GetPendingReadEvent();
            aHandles[cHandles++] = p->GetPendingWriteEvent();
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return cHandles;
}


// called only in the plugable transport thread
// already in the critical section
void CPluggableTransport::OnEventSignaled(HANDLE hevtSignaled)
{
    CPluggableConnection *p;
    BOOL fPostMessage, fFound;
    WPARAM wParam;
    LPARAM lParam;

    ::EnterCriticalSection(&g_csTransport);

    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        fFound = TRUE;
        fPostMessage = FALSE;
        wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), p->GetType());
        if (hevtSignaled == p->GetReadEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_READ, PLUGXPRT_RESULT_SUCCESSFUL);
            fPostMessage = TRUE;
        }
        else
        if (hevtSignaled == p->GetWriteEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
            fPostMessage = TRUE;
        }
        else
        if (hevtSignaled == p->GetCloseEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_CLOSE, PLUGXPRT_RESULT_SUCCESSFUL);
            fPostMessage = TRUE;
        }
        else
        {
            TransportConnection XprtConn;
            XprtConn.eType = p->GetType();
            XprtConn.nLogicalHandle = p->GetConnID();
            if (hevtSignaled == p->GetPendingReadEvent())
            {
                TRACE_OUT(("OnEventSignaled: PendingREAD(%d, %d)", p->GetType(), p->GetConnID()));
                if (p->OnPendingRead())
                {
                    ::ResetEvent(hevtSignaled);
                    // start next high-level read
                    p->NotifyHighLevelRead();
                }
            }
            else
            if (hevtSignaled == p->GetPendingWriteEvent())
            {
                TRACE_OUT(("OnEventSignaled: PendingWRITE(%d, %d)", p->GetType(), p->GetConnID()));
                if (p->OnPendingWrite())
                {
                    ::ResetEvent(hevtSignaled);
                    // start next low-level write
                    p->NotifyWriteEvent();
                }
            }
            else
            {
                fFound = FALSE;
            }
        }

        if (fPostMessage)
        {
            BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
            ASSERT(fRet);
        }

        if (fFound)
        {
            break;
        }
    } // while

    ::LeaveCriticalSection(&g_csTransport);

    ASSERT(NULL != p);
}


// called only in the plugable transport thread
// already in the critical section
void CPluggableTransport::OnEventAbandoned(HANDLE hevtSignaled)
{
    CPluggableConnection *p;
    BOOL fFound;
    WPARAM wParam;
    LPARAM lParam;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        fFound = TRUE;
        wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), p->GetType());
        if (hevtSignaled == p->GetReadEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_READ, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetWriteEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetCloseEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_CLOSE, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetPendingReadEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_PENDING_EVENT, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        if (hevtSignaled == p->GetPendingWriteEvent())
        {
            lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_PENDING_EVENT, PLUGXPRT_RESULT_ABANDONED);
        }
        else
        {
            fFound = FALSE;
        }

        if (fFound)
        {
            m_PluggableConnectionList.Remove(p);

            // update the events list to wait for in the plugable transport thread
            ::SetEvent(g_hevtUpdatePluggableTransport);

            BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
            ASSERT(fRet);
            break;
        }
    } // while
    ::LeaveCriticalSection(&g_csTransport);

    ASSERT(NULL != p);
}


CPluggableConnection * CPluggableTransport::GetPluggableConnection(PSocket pSocket)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetType()   == pSocket->XprtConn.eType &&
            p->GetConnID() == pSocket->XprtConn.nLogicalHandle)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnection(PSocket pSocket)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnection(pSocket) :
        NULL;
}


CPluggableConnection * CPluggableTransport::GetPluggableConnection(UINT_PTR nConnID)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetConnID() == nConnID)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnection(UINT_PTR nConnID)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnection(nConnID) :
        NULL;
}


CPluggableConnection * CPluggableTransport::GetPluggableConnection(HANDLE hCommLink)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetCommLink() == hCommLink)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnection(HANDLE hCommLink)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnection(hCommLink) :
        NULL;
}


CPluggableConnection * CPluggableTransport::GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE logical_handle)
{
    CPluggableConnection *p;

    ::EnterCriticalSection(&g_csTransport);
    m_PluggableConnectionList.Reset();
    while (NULL != (p = m_PluggableConnectionList.Iterate()))
    {
        if (p->GetLegacyHandle() == logical_handle)
        {
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);

    return p;
}


CPluggableConnection * GetPluggableConnectionByLegacyHandle(LEGACY_HANDLE logical_handle)
{
    return (NULL != g_pPluggableTransport) ?
         g_pPluggableTransport->GetPluggableConnectionByLegacyHandle(logical_handle) :
        NULL;
}


// called in ERNC ConfMgr's constructor
BOOL InitializePluggableTransport(void)
{
    if (! g_fPluggableTransportInitialized)
    {
        g_fWinsockDisabled = FALSE;
        g_hevtUpdatePluggableTransport = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != g_hevtUpdatePluggableTransport)
        {
            g_fPluggableTransportInitialized = TRUE;
        }
    }
    return g_fPluggableTransportInitialized;
}


// called in ERNC ConfMgr's destructor
void CleanupPluggableTransport(void)
{
    if (g_fPluggableTransportInitialized)
    {
        g_fPluggableTransportInitialized = FALSE;

        if (g_dwPluggableTransportThreadID)
        {
            ::PostThreadMessage(g_dwPluggableTransportThreadID, WM_QUIT, 0, 0);
        }

        ::EnterCriticalSection(&g_csTransport);
        if (NULL != g_hevtUpdatePluggableTransport)
        {
            ::CloseHandle(g_hevtUpdatePluggableTransport);
        }
        ::LeaveCriticalSection(&g_csTransport);
    }
}




DWORD __stdcall PluggableTransportThreadProc(LPVOID lpv)
{
    MSG msg;
    BOOL fContinueMainLoop = TRUE;
    DWORD nEventSignaled;
    ULONG cEvents;
    HANDLE aEvents[MAX_PLUGXPRT_CONNECTIONS * MAX_PLUGXPRT_EVENTS + 1];

    // signaling that the work hread has been started.
    ::SetEvent((HANDLE) lpv);

    // set up initial event list, the first entry always for update event
    cEvents = 1;
    aEvents[0] = g_hevtUpdatePluggableTransport;
    ::SetEvent(g_hevtUpdatePluggableTransport);

    // main loop
	while (fContinueMainLoop)
	{
		// process any possible window and thread messages
		while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (WM_QUIT != msg.message)
            {
			    ::DispatchMessage(&msg);
            }
            else
            {
                fContinueMainLoop = FALSE;
                break;
            }
		}

        if (fContinueMainLoop)
        {
		    nEventSignaled = ::MsgWaitForMultipleObjects(cEvents, aEvents, FALSE, INFINITE, QS_ALLINPUT);
            ::EnterCriticalSection(&g_csTransport);
            if (NULL != g_pPluggableTransport)
            {
                switch (nEventSignaled)
                {
		        case WAIT_OBJECT_0:
                    // update the event list
                    cEvents = 1 + g_pPluggableTransport->UpdateEvents(&aEvents[1]);
                    break;
                case WAIT_TIMEOUT:
                    // impossible, do nothing
                    break;
                default:
                    if (WAIT_OBJECT_0 + 1 <= nEventSignaled && nEventSignaled < WAIT_OBJECT_0 + cEvents)
                    {
                        g_pPluggableTransport->OnEventSignaled(aEvents[nEventSignaled - WAIT_OBJECT_0]);
                    }
                    else
                    if (WAIT_ABANDONED_0 + 1 <= nEventSignaled && nEventSignaled < WAIT_ABANDONED_0 + cEvents)
                    {
                        g_pPluggableTransport->OnEventAbandoned(aEvents[nEventSignaled - WAIT_OBJECT_0]);
                    }
                    break;
                }
            }
            else
            {
                fContinueMainLoop = FALSE;
            }
            ::LeaveCriticalSection(&g_csTransport);
        }
    } // while

    g_dwPluggableTransportThreadID = 0;

    return 0;
}

BOOL EnsurePluggableTransportThread(void)
{
    BOOL fRet = TRUE;
    if (! g_dwPluggableTransportThreadID)
    {
        fRet = FALSE;
        HANDLE hSync = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hSync)
        {
            HANDLE hThread = ::CreateThread(NULL, 0, PluggableTransportThreadProc, hSync, 0,
                                            &g_dwPluggableTransportThreadID);
            if (NULL != hThread)
            {
                ::WaitForSingleObject(hSync, 5000); // 5 second
                ::CloseHandle(hThread);
                fRet = TRUE;
            }
            ::CloseHandle(hSync);
        }
    }
    return fRet;
}


#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
LPCSTR FakeNodeAddress(LPCSTR pcszNodeAddress)
{
    char szAddr[64];
    ::lstrcpyA(szAddr, pcszNodeAddress);
    for (LPSTR psz = &szAddr[0]; *psz; psz++)
    {
        if (*psz == ':')
        {
            *psz = '\0';
            break;
        }
    }
    if (! ::lstrcmp(szAddr, "157.59.12.93"))
    {
        pcszNodeAddress = "XPRT: 1";
    }
    else
    if (! ::lstrcmp(szAddr, "157.59.13.194"))
    {
        pcszNodeAddress = "XPRT: 2";
    }
    else
    if (! ::lstrcmp(szAddr, "157.59.10.198"))
    {
        pcszNodeAddress = "XPRT: 1";
    }
    else
    {
        ASSERT(0);
    }
    return pcszNodeAddress;
}
#endif


int SubmitPluggableRead(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("SubmitPluggableRead"));

    int nRet = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    CPluggableConnection *p = ::GetPluggableConnection(pSocket);
    if (NULL != p)
    {
        nRet = p->Read(buffer, length, plug_rc);
    }
    else
    {
        WARNING_OUT(("SubmitPluggableRead: no such conn ID=%d", pSocket->XprtConn.nLogicalHandle));
    }
    return nRet;
}


int CPluggableConnection::Read(LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    int cbRecv = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    ::EnterCriticalSection(&g_csTransport);

    if (NULL != m_OverlappedRead.hEvent)
    {
        // handle low-level pending read first
        if (m_fPendingReadDone)
        {
            // copy the data from internal buffer to external buffer
            if (length <= m_cbPendingRead)
            {
                // get as requested
                cbRecv = length;
                ::CopyMemory(buffer, m_pbPendingRead, length);
                m_cbPendingRead -= length;
                if (m_cbPendingRead <= 0)
                {
                    CleanupReadState();
                }
                else
                {
                    // move the memory, do not use copymemory due to overlap
                    int cb = m_cbPendingRead;
                    LPBYTE pbDst = m_pbPendingRead;
                    LPBYTE pbSrc = &m_pbPendingRead[length];
                    while (cb--)
                    {
                        *pbDst++ = *pbSrc++;
                    }
                }
            }
            else
            {
                // only get partial data
                cbRecv = m_cbPendingRead;
                ::CopyMemory(buffer, m_pbPendingRead, m_cbPendingRead);
                CleanupReadState();
            }

            // start next high-level read
            NotifyHighLevelRead();
        }
    }
    else
    {
        if (SetupReadState(length))
        {
            TRACE_OUT(("CPluggableConnection::Read: ReadFile(%d)", m_cbPendingRead));

            DWORD dwRead = 0;
            if (! ::ReadFile(m_hCommLink,
                             m_pbPendingRead,
                             m_cbPendingRead,
                             &dwRead,
                             &m_OverlappedRead))
            {
                DWORD dwErr = ::GetLastError();
                if (ERROR_HANDLE_EOF != dwErr && ERROR_IO_PENDING != dwErr)
                {
                    WARNING_OUT(("CPluggableConnection::Read: ReadFile failed, err=%d", dwErr));

                    CleanupReadState();

                    // disconnect at next tick
                    NotifyReadFailure();
                    *plug_rc = PLUGXPRT_RESULT_READ_FAILED;
                }
            }
            else
            {
                // do nothing, treat it as WSAEWOULDBLOCK
            }
        }
        else
        {
            ERROR_OUT(("CPluggableConnection::Read: failed to allocate memory (%d)", length));
            // out of memory, try later
            // do nothing, treat it as WSAEWOULDBLOCK
        }
    }

    ::LeaveCriticalSection(&g_csTransport);

    return cbRecv;
}


BOOL CPluggableConnection::OnPendingRead(void)
{
    TRACE_OUT(("CPluggableConnection::OnPendingRead"));

    BOOL fRet = FALSE;

    ::EnterCriticalSection(&g_csTransport);

    if (NULL != m_OverlappedRead.hEvent)
    {
        DWORD cbRead = 0;

        if (::GetOverlappedResult(m_hCommLink, &m_OverlappedRead, &cbRead, FALSE))
        {
            if ((int) cbRead == m_cbPendingRead)
            {
                TRACE_OUT(("CPluggableConnection::OnPendingRead: Received %d bytes (required %d bytes) on socket (%d, %d).",
                            cbRead, m_cbPendingRead, m_eType, m_nConnID));
            }
            else
            {
                WARNING_OUT(("CPluggableConnection::OnPendingRead: Received %d bytes (required %d bytes) on socket (%d, %d).",
                            cbRead, m_cbPendingRead, m_eType, m_nConnID));
            }
            m_cbPendingRead = cbRead; // in case cbRead is smaller
            m_fPendingReadDone = TRUE;
            fRet = TRUE; // turn off event
        }
        else
        {
            DWORD dwErr = ::GetLastError();
            if (ERROR_IO_INCOMPLETE == dwErr)
            {
                ASSERT(! cbRead);
            }
            else
            {
                TRACE_OUT(("CPluggableConnection::OnPendingRead: read failed %d", dwErr));
                fRet = TRUE; // turn off event

                // disconnect at next tick
                NotifyReadFailure();
            }
        }
    }
    else
    {
        ERROR_OUT(("CPluggableConnection::OnPendingRead: no pending read event handle."));
        fRet = TRUE; // turn off event
    }

    ::LeaveCriticalSection(&g_csTransport);

    return fRet;
}


void CPluggableConnection::NotifyHighLevelRead(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_HIGH_LEVEL_READ, PLUGXPRT_RESULT_SUCCESSFUL);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyReadFailure(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_READ, PLUGXPRT_RESULT_READ_FAILED);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyWriteEvent(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyHighLevelWrite(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_HIGH_LEVEL_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}


void CPluggableConnection::NotifyWriteFailure(void)
{
    WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
    LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_WRITE_FAILED);
    BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
    ASSERT(fRet);
}




LPBYTE DuplicateBuffer(LPBYTE buffer, UINT length)
{
    // DBG_SAVE_FILE_LINE
    LPBYTE new_buffer = new BYTE[length];
    if (NULL != new_buffer)
    {
        ::CopyMemory(new_buffer, buffer, length);
    }
    return new_buffer;
}


int SubmitPluggableWrite(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("SubmitPluggableWrite"));

    int nRet = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    CPluggableConnection *p = ::GetPluggableConnection(pSocket);
    if (NULL != p)
    {
        nRet = p->Write(buffer, length, plug_rc);
    }
    else
    {
        WARNING_OUT(("SubmitPluggableWrite: no such conn ID=%d", pSocket->XprtConn.nLogicalHandle));
    }
    return nRet;
}


int CPluggableConnection::Write(LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("CPluggableConnection::Write"));

    int cbSent = SOCKET_ERROR;
    *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    ::EnterCriticalSection(&g_csTransport);

    if (m_OutBufQueue2.GetCount() < MAX_PLUGGABLE_OUT_BUF_SIZE) // x4K
    {
        DBG_SAVE_FILE_LINE
        buffer = ::DuplicateBuffer(buffer, length);
        if (NULL != buffer)
        {
            cbSent = length;
            m_OutBufQueue2.Append(length, buffer);
            if (1 == m_OutBufQueue2.GetCount())
            {
                TRACE_OUT(("CPluggableConnection::Write: the only item in the queue"));
                WriteTheFirst();
                #if 0 // avoid another tick
                // start next low-level write
                WPARAM wParam = MAKE_PLUGXPRT_WPARAM(m_nConnID, m_eType);
                LPARAM lParam = MAKE_PLUGXPRT_LPARAM(PLUGXPRT_EVENT_WRITE, PLUGXPRT_RESULT_SUCCESSFUL);
                BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_X224, wParam, lParam);
                ASSERT(fRet);
                #endif
            }
            else
            {
                TRACE_OUT(("CPluggableConnection::Write: more items in the queue"));
            }
        }
        else
        {
            ERROR_OUT(("CPluggableConnection::Write: failed to allocate memory (%d)", length));
            // out of memory, try later
            // do nothing, treat it as WSAEWOULDBLOCK
        }
    }

    ::LeaveCriticalSection(&g_csTransport);

    return cbSent;
}


void CPluggableConnection::WriteTheFirst(void)
{
    int length;
    LPBYTE buffer;

    TRACE_OUT(("CPluggableConnection::WriteTheFirst"));

    ::EnterCriticalSection(&g_csTransport);

    if (NULL == m_OverlappedWrite.hEvent)
    {
        length = 0;
        buffer = m_OutBufQueue2.PeekHead(&length);
        if (NULL != buffer)
        {
            ::ZeroMemory(&m_OverlappedWrite, sizeof(m_OverlappedWrite));
            m_OverlappedWrite.hEvent = m_hevtPendingWrite;

            m_pbPendingWrite = buffer;
            m_cbPendingWrite = length;

            TRACE_OUT(("CPluggableConnection::WriteTheFirst: WriteFile(%d)", length));

            DWORD cbWritten = 0;
            if (! ::WriteFile(m_hCommLink, buffer, length, &cbWritten, &m_OverlappedWrite))
            {
                DWORD dwErr = ::GetLastError();
                if (ERROR_IO_PENDING != dwErr)
                {
                    ERROR_OUT(("CPluggableConnection::WriteTheFirst: WriteFile failed, err=%d", dwErr));
                    CleanupWriteState();
                    m_OutBufQueue2.Get(); // dequeue the buffer which cannot be sent

                    NotifyWriteFailure();
                }
                else
                {
                    // we are still in pending
                    // repeat the write event
                    NotifyWriteEvent();
                }
            }
        }
        else
        {
            TRACE_OUT(("CPluggableConnection::WriteTheFirst: queue is empty"));

            // no more low-level write
            m_pbPendingWrite = NULL;
            CleanupWriteState();

            // start next high-level write
            NotifyHighLevelWrite();
        }
    }
    else
    {
        TRACE_OUT(("CPluggableConnection::WriteTheFirst: still pending"));
        // we are still in write pending, wake up the pending write
        OnPendingWrite(); // check for pending write result
        NotifyWriteEvent();
    }

    ::LeaveCriticalSection(&g_csTransport);
}


void PluggableWriteTheFirst(TransportConnection XprtConn)
{
    if (IS_PLUGGABLE(XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
        if (NULL != p)
        {
            p->WriteTheFirst();
        }
        else
        {
            ERROR_OUT(("PluggableWriteTheFirst: no such conn ID=%d", XprtConn.nLogicalHandle));
        }
    }
    else
    {
        ERROR_OUT(("PluggableWriteTheFirst: not plugable connection"));
    }
}


void PluggableShutdown(TransportConnection XprtConn)
{
    if (IS_PLUGGABLE(XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
        if (NULL != p)
        {
            p->Shutdown();
        }
        else
        {
            ERROR_OUT(("PluggableShutdown: no such conn ID=%d", XprtConn.nLogicalHandle));
        }
    }
    else
    {
        ERROR_OUT(("PluggableShutdown: not plugable connection"));
    }
}


BOOL CPluggableConnection::OnPendingWrite(void)
{
    TRACE_OUT(("CPluggableConnection::OnPendingWrite"));

    BOOL fRet = FALSE;
	BOOL fStartNextWrite = FALSE;

    ::EnterCriticalSection(&g_csTransport);

    if (NULL != m_OverlappedWrite.hEvent)
    {
        DWORD cbWritten = 0;
        if (::GetOverlappedResult(m_hCommLink, &m_OverlappedWrite, &cbWritten, FALSE))
        {
            TRACE_OUT(("CPluggableConnection::OnPendingWrite: Sent %d bytes (required %d bytes) on socket (%d, %d).",
                            cbWritten, m_cbPendingWrite, m_eType, m_nConnID));
            if (cbWritten >= (DWORD) m_cbPendingWrite)
            {
                ASSERT(cbWritten == (DWORD) m_cbPendingWrite);

                // remove the item from the queue
                int length = 0;
                LPBYTE buffer = m_OutBufQueue2.Get(&length);
                ASSERT(length == m_cbPendingWrite);
                ASSERT(buffer == m_pbPendingWrite);

                CleanupWriteState();

                fRet = TRUE; // turn off event
            }
            else
            {
                ERROR_OUT(("CPluggableConnection::OnPendingWrite: unexpected error, less data written %d (required %d)",
                            cbWritten, m_cbPendingWrite));
                NotifyWriteFailure();
                fRet = TRUE; // turn off event
            }
        }
        else
        {
            DWORD dwErr = ::GetLastError();
            if (ERROR_IO_INCOMPLETE == dwErr)
            {
                ASSERT(! cbWritten);
            }
            else
            {
                ERROR_OUT(("CPluggableConnection::OnPendingWrite: failed to write, err=%d", dwErr));
                NotifyWriteFailure();
                fRet = TRUE; // turn off event
            }
        }
    }
    else
    {
        // it is very possible that we hit this many times
        fRet = TRUE;
    }

    ::LeaveCriticalSection(&g_csTransport);

    return fRet;
}



BOOL CPluggableConnection::SetupReadState(int length)
{
    DBG_SAVE_FILE_LINE
    LPBYTE buffer = new BYTE[length];
    if (NULL != buffer)
    {
        m_pbPendingRead = buffer;
        m_cbPendingRead = length;
        m_fPendingReadDone = FALSE;

        ::ZeroMemory(&m_OverlappedRead, sizeof(m_OverlappedRead));
        m_OverlappedRead.hEvent = m_hevtPendingRead;
    }
    else
    {
        CleanupReadState();
    }
    return (NULL != buffer);
}


void CPluggableConnection::CleanupReadState(void)
{
    delete [] m_pbPendingRead;
    m_pbPendingRead = NULL;
    m_cbPendingRead = 0;
    m_fPendingReadDone = FALSE;

    ::ZeroMemory(&m_OverlappedRead, sizeof(m_OverlappedRead));
}


void CPluggableConnection::CleanupWriteState(void)
{
    delete [] m_pbPendingWrite;
    m_pbPendingWrite = NULL;
    m_cbPendingWrite = 0;

    ::ZeroMemory(&m_OverlappedWrite, sizeof(m_OverlappedWrite));
}



TransportError CALLBACK LegacyTransportCallback(ULONG nMsg, void *Param1, void *Param2)
{
    if (Param2 == g_pPluggableTransport)
    {
        BOOL fPostMsg = FALSE;
        WPARAM wParam = 0;
        CPluggableConnection *p;

        switch (nMsg)
        {
        case TRANSPORT_CONNECT_INDICATION:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_CONNECT_INDICATION"));
            {
                LegacyTransportID *pID = (LegacyTransportID *) Param1;
                p = ::GetPluggableConnection(pID->hCommLink);
                if (NULL != p)
                {
                    p->SetLegacyHandle(pID->logical_handle);

                    {
                        PSocket pSocket = p->GetSocket();
                        ASSERT(NULL != pSocket);
                        if (NULL != pSocket)
                        {
                            pSocket->State = SOCKET_CONNECTED;
                            wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), TRANSPORT_TYPE_PLUGGABLE_PSTN);
                            fPostMsg = TRUE;
                        }
                    }
                }
            }
            break;

        case TRANSPORT_CONNECT_CONFIRM:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_CONNECT_CONFIRM"));
            {
                LegacyTransportID *pID = (LegacyTransportID *) Param1;
                p = ::GetPluggableConnection(pID->hCommLink);
                if (NULL != p)
                {
                    ASSERT(p->GetLegacyHandle() == pID->logical_handle);

                    {
                        PSocket pSocket = p->GetSocket();
                        ASSERT(NULL != pSocket);
                        if (NULL != pSocket)
                        {
                            pSocket->State = X224_CONNECTED;
                            wParam = MAKE_PLUGXPRT_WPARAM(p->GetConnID(), TRANSPORT_TYPE_PLUGGABLE_PSTN);
                            fPostMsg = TRUE;
                        }
                    }
                }
            }
            break;

        case TRANSPORT_DISCONNECT_INDICATION:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_DISCONNECT_INDICATION"));
            {
                LegacyTransportID *pID = (LegacyTransportID *) Param1;
                TransportConnection XprtConn;
                XprtConn.eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
                p = ::GetPluggableConnectionByLegacyHandle(pID->logical_handle);
                if (NULL != p)
                {
                    XprtConn.nLogicalHandle = p->GetConnID();
                }
                ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTED);
                fPostMsg = FALSE;
            }
            break;

        case TRANSPORT_DATA_INDICATION:
            TRACE_OUT(("LegacyTransportCallback::TRANSPORT_DATA_INDICATION"));
            {
                //
                // This piece of data does not have X.224 framing
                //
                LegacyTransportData *pData = (LegacyTransportData *) Param1;
                TRACE_OUT(("LegacyTransportCallback::pbData=0x%x, cbDataSize=%d", pData->pbData, pData->cbDataSize));

                if (NULL != g_Transport)
                {
                    DBG_SAVE_FILE_LINE
                    TransportData *td = new TransportData;
                    if (NULL != td)
                    {
                        td->transport_connection.eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
                        p = ::GetPluggableConnectionByLegacyHandle(pData->logical_handle);
                        if (NULL != p)
                        {
                            ULONG cbTotalSize = PROTOCOL_OVERHEAD_X224 + pData->cbDataSize;
                            td->transport_connection.nLogicalHandle = p->GetConnID();
                            DBG_SAVE_FILE_LINE
                            td->memory = ::AllocateMemory(NULL, cbTotalSize, RECV_PRIORITY);
                            if (NULL != td->memory)
                            {
                                td->user_data = td->memory->GetPointer();
                                td->user_data_length = cbTotalSize;

                                // take care of the X.224 header
                                ::CopyMemory(td->user_data, g_X224Header, PROTOCOL_OVERHEAD_X224);
                                AddRFCSize(td->user_data, cbTotalSize);
                                // take care of the data
                                ::CopyMemory(td->user_data + PROTOCOL_OVERHEAD_X224, pData->pbData, pData->cbDataSize);

                                wParam = (WPARAM) td;
                                fPostMsg = TRUE;
                            }
                            else
                            {
                                ERROR_OUT(("LegacyTransportCallback: failed to allocate memory, size=%d", cbTotalSize));
                            }
                        }
                    }
                    else
                    {
                        ERROR_OUT(("LegacyTransportCallback: failed to allocate TransportData"));
                    }
                }
            }
            break;

        default:
            wParam = (WPARAM) Param1;
            fPostMsg = TRUE;
            break;
        }

        if (fPostMsg)
        {
            BOOL fRet = ::PostMessage(TCP_Window_Handle, WM_PLUGGABLE_PSTN, wParam, nMsg);
            ASSERT(fRet);
        }
    }

    return TRANSPORT_NO_ERROR;
}


void HandlePSTNCallback(WPARAM wParam, LPARAM lParam)
{
    if (NULL != g_pPluggableTransport)
    {
        CPluggableConnection *p;

        switch (lParam)
        {
        case TRANSPORT_CONNECT_INDICATION:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_CONNECT_INDICATION"));
            if (NULL != g_Transport)
            {
                TransportConnection XprtConn;
                XprtConn.nLogicalHandle = PLUGXPRT_WPARAM_TO_ID(wParam);
                XprtConn.eType = (TransportType) PLUGXPRT_WPARAM_TO_TYPE(wParam);
                ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                g_Transport->ConnectIndication(XprtConn);
            }
            break;

        case TRANSPORT_CONNECT_CONFIRM:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_CONNECT_CONFIRM"));
            if (NULL != g_Transport)
            {
                TransportConnection XprtConn;
                XprtConn.nLogicalHandle = PLUGXPRT_WPARAM_TO_ID(wParam);
                XprtConn.eType = (TransportType) PLUGXPRT_WPARAM_TO_TYPE(wParam);
                ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                g_Transport->ConnectConfirm(XprtConn);
            }
            break;

        case TRANSPORT_DATA_INDICATION:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_DATA_INDICATION"));
            {
                TransportData *td = (TransportData *) wParam;
                if (NULL != g_Transport)
                {
                    g_Transport->DataIndication(td);
                }
                delete td;
            }
            break;

        case TRANSPORT_BUFFER_EMPTY_INDICATION:
            TRACE_OUT(("HandlePSTNCallback::TRANSPORT_BUFFER_EMPTY_INDICATION"));
            {
                LEGACY_HANDLE logical_handle = (LEGACY_HANDLE) wParam;
                TransportConnection XprtConn;
                XprtConn.eType = TRANSPORT_TYPE_PLUGGABLE_PSTN;
                p = ::GetPluggableConnectionByLegacyHandle(logical_handle);
                if (NULL != p)
                {
                    XprtConn.nLogicalHandle = p->GetConnID();
                    g_Transport->BufferEmptyIndication(XprtConn);
                }
            }
            break;

        default:
            ERROR_OUT(("HandlePSTNCallback: unknown message=%d", lParam));
            break;
        }
    }
}


BOOL CPluggableTransport::EnsureLegacyTransportLoaded(void)
{
    if (NULL == g_pLegacyTransport)
    {
        g_hlibMST123 = ::LoadLibrary("MST123.DLL");
        if (NULL != g_hlibMST123)
        {
            LPFN_T123_CreateTransportInterface pfn = (LPFN_T123_CreateTransportInterface)
                    ::GetProcAddress(g_hlibMST123, LPSTR_T123_CreateTransportInterface);
            if (NULL != pfn)
            {
                TransportError rc = (*pfn)(&g_pLegacyTransport);
                if (TRANSPORT_NO_ERROR == rc)
                {
                    ASSERT(NULL != g_pLegacyTransport);

                    // start to call initialize
                    rc = g_pLegacyTransport->TInitialize(LegacyTransportCallback, this);
                    ASSERT(TRANSPORT_NO_ERROR == rc);

                    if (TRANSPORT_NO_ERROR == rc)
                    {
                        return TRUE;
                    }

                    g_pLegacyTransport->TCleanup();
                    g_pLegacyTransport->ReleaseInterface();
                    g_pLegacyTransport = NULL;
                }
            }

            ::FreeLibrary(g_hlibMST123);
            g_hlibMST123 = NULL;
        }

        return FALSE;
    }

    return TRUE;
}


TransportError CPluggableConnection::TConnectRequest(void)
{
    TRACE_OUT(("CPluggableConnection::TConnectRequest"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        TransportConnection XprtConn;
        XprtConn.eType = m_eType;
        XprtConn.nLogicalHandle = m_nConnID;
        ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTING);

        rc = g_pLegacyTransport->TConnectRequest(&m_nLegacyLogicalHandle, m_hCommLink);
    }
    return rc;
}


TransportError CPluggableConnection::TDisconnectRequest(void)
{
    TRACE_OUT(("CPluggableConnection::TDisconnectRequest"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        TransportConnection XprtConn;
        XprtConn.eType = m_eType;
        XprtConn.nLogicalHandle = m_nConnID;
        ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTING);

        ::Sleep(600);
        rc = g_pLegacyTransport->TDisconnectRequest(m_nLegacyLogicalHandle, TRUE);
    }
    return rc;
}


int CPluggableConnection::TDataRequest(LPBYTE pbData, ULONG cbDataSize, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("CPluggableConnection::TDataRequest, pbData=0x%x, cbDataSize=%d", pbData, cbDataSize));
    if (NULL != g_pLegacyTransport)
    {
        *plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

        // skip X.224 framing
        ASSERT(cbDataSize > PROTOCOL_OVERHEAD_X224);

        TransportError rc;
        rc = g_pLegacyTransport->TDataRequest(m_nLegacyLogicalHandle,
                                              pbData + PROTOCOL_OVERHEAD_X224,
                                              cbDataSize - PROTOCOL_OVERHEAD_X224);
        if (TRANSPORT_NO_ERROR == rc)
        {
            TRACE_OUT(("CPluggableConnection::TDataRequest: sent data size=%d", cbDataSize));
            return cbDataSize;
        }
    }
    else
    {
        *plug_rc = PLUGXPRT_RESULT_WRITE_FAILED;
    }
    return SOCKET_ERROR;
}


TransportError TReceiveBufferAvailable(void)
{
    TRACE_OUT(("CPluggableConnection::TReceiveBufferAvailable"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        rc = g_pLegacyTransport->TReceiveBufferAvailable();
    }
    return rc;
}


TransportError CPluggableConnection::TPurgeRequest(void)
{
    TRACE_OUT(("CPluggableConnection::TPurgeRequest"));
    TransportError rc = TRANSPORT_NO_PLUGGABLE_CONNECTION;
    if (NULL != g_pLegacyTransport)
    {
        rc = g_pLegacyTransport->TPurgeRequest(m_nLegacyLogicalHandle);
    }
    return rc;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\precomp.h ===
#define INC_OLE2
#define IDS_NULL_STRING			(0)
#include <windows.h>
#include <tchar.h>

// MCSNC includes
#include <databeam.h>

#include <oprahcom.h>
#include <confdbg.h>
// end MCSNC includes

extern "C"
{
#include <t120.h>
}
#include <memmgr.h>
#include <mcattprt.h>
#include <ncmcs.h>
#include <debspew.h>
#include <RegEntry.h>
#include <ConfReg.h>
#include <it120nc.h>

#include "fclasses.h"

#include "cntlist.h"
#include "clists.h"
#include "ms_util.h"
#include <fsdiag.h>

#include <spacket.h>
#include <packet.h>
#include <datapkt.h>
#include <cmdtar.h>
#include <attmnt.h>
#include <channel.h>
#include <tptif.h>
#include <domain.h>
#include <connect.h>
#include <tprtctrl.h>
#include <user.h>
#include <control.h>
#include <evtlog.h>
#include <nmevtmsg.h>

#include "pdutypes.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\privchnl.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	privchnl.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the PrivateChannel class.  It
 *		contains the code that distinguishes this class from that of its parent,
 *		Channel.
 *
 *		This class maintains an authorized user list, and includes the code
 *		necessary to use that list.  No user will be allowed to join or send
 *		data on a private channel unless they are either the channel manager
 *		or an admitted user.
 *
 *	Private Instance Variables:
 *		m_uidChannelManager
 *			This is the User ID of the user that convened the private channel.
 *			Only this user is allowed to manipulate the authorized user list.
 *			When a private channel becomes invalid (as the result of a channel
 *			disband request or indication), this value will be set to 0.
 *		m_AuthorizedUserList
 *			This is a collection containing the user IDs of those users that
 *			have been admitted to the private channel by the channel manager.
 *			Other than the manager, these are the only users that are allowed
 *			to join or send data on the channel.  When a private channel becomes
 *			invalid (as the result of a channel disband request or indication),
 *			this list will be cleared.
 *		m_fDisbandRequestPending
 *			This is a boolean flag that gets set when a disband request is
 *			forwarded upward to the top provider.  This prevents this channel
 *			from issuing a disband indication to the channel manager when it
 *			comes back down the tree from the top provider.
 *
 *	Private Member Functions:
 *		ValidateUserID
 *			This member function is called to verify that a specified user ID
 *			corresponds to a valid user in the sub-tree of the local provider.
 *		BuildAttachmentLists
 *			This member function is called to build two lists of attachments
 *			from a master user ID list.  The first list contains all local
 *			attachments whose user ID is in the specified list.  The second
 *			list contains all remote attachments whose user ID is in the
 *			specified list.  These lists are used to issue various indications
 *			to specified users without sending any to the same attachment.
 *		BuildUserIDList
 *			This member function is called to build a list of users that lie
 *			in the direction of a specified attachment.  These lists are
 *			sent along with PDUs that require them.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include "privchnl.h"


/*
 *	PrivateChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the primary constructor for PrivateChannel objects.  It creates
 *		an object with all instance variable initialized, but with no
 *		attachments (i.e. no users are joined to the channel automatically).
 *
 *		Note that most instance variable initialization is done by invoking the
 *		equivalent constructor in the base class.
 *
 *		Upon successful completion, a  channel convene confirm is automatically
 *		issued to the channel manager, if the channel manager is in the sub-tree
 *		of this provider.  Note that if the channel manager is NOT in this
 *		sub-tree, then this private channel object was probably created as the
 *		result of a channel admit indication, and no channel convene confirm
 *		will be issued.
 */
PrivateChannel::PrivateChannel (
		ChannelID			channel_id,
		UserID				channel_manager,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list)
:
	Channel(channel_id, local_provider, top_provider, channel_list, attachment_list),
	m_AuthorizedUserList(),
	m_uidChannelManager(channel_manager),
	m_fDisbandRequestPending(FALSE)
{
	/*
	 *	Check to see if the channel manager lies in the sub-tree of this
	 *	provider.  If so, then this object was created as the result of a
	 *	channel convene request or confirm, and it is necessary to issue the
	 *	confirm toward that user.  If not, then this object was created as the
	 *	result of a channel admit indication, and it is not necessary to send
	 *	the channel convene confirm.
	 */
	if (ValidateUserID(m_uidChannelManager))
	{
		PChannel	lpChannel;
		/*
		 *	Determine which attachment leads to the channel manager by asking
		 *	the channel object corresponding to it.  Then issue the confirm
		 *	to that attachment.
		 */
		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
		{
		    CAttachment *pAtt = lpChannel->GetAttachment();
		    if (pAtt)
		    {
    		    pAtt->ChannelConveneConfirm(RESULT_SUCCESSFUL,
    		                                m_uidChannelManager, channel_id);
            }
            else
            {
                ERROR_OUT(("PrivateChannel::PrivateChannel: null attachment"));
            }
		}
	}
}

/*
 *	PrivateChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a secondary constructor that is only used during merge
 *		operations.  The intent of this constructor is to create an equivalent
 *		object without issuing any of the confirms.
 *
 *		Note that the additional constructor allows for the creator to specify
 *		that there is an attachment already joined to the channel upon creation.
 */
PrivateChannel::PrivateChannel (
		ChannelID			channel_id,
		UserID				channel_manager,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list,
		CUidList           *admitted_list,
		PConnection         pConn)
:
	Channel(channel_id, local_provider, top_provider, channel_list, attachment_list, pConn),
	m_AuthorizedUserList(),
	m_uidChannelManager(channel_manager),
	m_fDisbandRequestPending(FALSE)
{
	UserID		uid;

	/*
	 *	Copy the initial contents of the admitted list into the authorized
	 *	user list.
	 */
	admitted_list->Reset();
	while (NULL != (uid = admitted_list->Iterate()))
	{
		m_AuthorizedUserList.Append(uid);
	}
}

/*
 *	~PrivateChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This destructor walks through the admitted list, sending expel
 *		indications to any admitted users that are locally attached.  If the
 *		channel manager is locally attached, and this channel is being deleted
 *		a reason other than a previous disband request, then a disband
 *		indication will be sent to the channel manager.
 */
PrivateChannel::~PrivateChannel ()
{
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList                user_id_list;

	/*
	 *	Assemble lists of the attachments that lead to authorized users in
	 *	the sub-tree of this provider.
	 */
	BuildAttachmentLists (&m_AuthorizedUserList, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	For each local attachment, issue a channel expel indication letting the
	 *	user know that the channel is no longer valid.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of the users
		 *	that lie in the direction of that attachment.
		 */
		BuildUserIDList(&m_AuthorizedUserList, pAtt, &user_id_list);

		/*
		 *	Send the indication.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_list);
	}

	/*
	 *	If the channel manager is a locally attached user, then send it a
	 *	ChannelDisbandIndication informing it that the channel is no longer
	 *	valid.
	 */
	if ((m_fDisbandRequestPending == FALSE) && ValidateUserID(m_uidChannelManager))
	{
		PChannel		lpChannel;

		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
		{
    		CAttachment *pAtt = lpChannel->GetAttachment();
    		if (m_pAttachmentList->Find(pAtt) && pAtt->IsUserAttachment())
    		{
    		    PUser pUser = (PUser) pAtt;
    			pUser->ChannelDisbandIndication(Channel_ID);
    	    }
    	}
	}

	/*
	 *	Clear the lists associated with this object.  Note that this also
	 *	prevents the base class destructor from issuing ChannelLeaveIndications
	 *	to any local attachments in the joined attachment list (which would be
	 *	inappropriate).
	 */
	m_AuthorizedUserList.Clear();
	m_JoinedAttachmentList.Clear();
}

/*
 *	Channel_Type		GetChannelType ()
 *
 *	Public
 *
 *	Functional Description:
 *		Objects of this class are always private channels, so simply return
 *		PRIVATE_CHANNEL.
 */
Channel_Type		PrivateChannel::GetChannelType ()
{
	return (PRIVATE_CHANNEL);
}

/*
 *	BOOL    IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		By convention, if the m_uidChannelManager is in the sub-tree of this
 *		provider OR if there are any users in the authorized user list, then
 *		the private channel is valid.  Otherwise it is not, and can be deleted
 *		by the domain object.
 */
BOOL    PrivateChannel::IsValid ()
{
	UserID			uid;
	CUidList		deletion_list;

	/*
	 *	Loop through the authorized user list making a list of those entries
	 *	that are no longer valid.
	 */
	m_AuthorizedUserList.Reset();
	while (NULL != (uid = m_AuthorizedUserList.Iterate()))
	{
		if (ValidateUserID(uid) == FALSE)
			deletion_list.Append(uid);
	}

	/*
	 *	Loop through the deletion list created above, deleting those user IDs
	 *	that are no longer valid.
	 */
	deletion_list.Reset();
	while (NULL != (uid = deletion_list.Iterate()))
	{
		m_AuthorizedUserList.Remove(uid);
	}

	/*
	 *	If this is the Top Provider, then the channel manager should ALWAYS be
	 *	in the sub-tree.  If it is not, then this indicates that the channel
	 *	manager has detached (willingly or otherwise).  When this happens it
	 *	is necessary to simulate a channel disband request (only if there are
	 *	other admitted users who need to receive a channel expel indication).
	 */
	if ((m_pConnToTopProvider == NULL) &&
			(ValidateUserID(m_uidChannelManager) == FALSE) &&
			(m_AuthorizedUserList.IsEmpty() == FALSE))
	{
		TRACE_OUT (("PrivateChannel::IsValid: "
				"simulating ChannelDisbandRequest"));
		ChannelDisbandRequest(NULL, m_uidChannelManager, Channel_ID);
	}

	/*
	 *	Check to see if the channel manager is in the sub-tree of this provider
	 *	or if the authorized user list is not empty.  If either is TRUE, then
	 *	then the channel is still valid.
	 */
	return (ValidateUserID(m_uidChannelManager) || (m_AuthorizedUserList.IsEmpty() == FALSE));
}

/*
 *	CAttachment *GetAttachment ()
 *
 *	Public
 *
 *	Functional Description:
 *		Return a pointer to the attachment leading to the channel manager.
 */
CAttachment *PrivateChannel::GetAttachment(void)
{
	if (ValidateUserID(m_uidChannelManager))
    {
		PChannel	lpChannel;
		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
		{
            return lpChannel->GetAttachment();
        }
	}
	return NULL;
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		Issue a merge request for the information contained in this
 *		PrivateChannel object.
 */
Void	PrivateChannel::IssueMergeRequest ()
{
	ChannelAttributes		channel_attributes;
	CChannelAttributesList	merge_channel_list;
	CChannelIDList			purge_channel_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Fill in the fields of the channel attributes structure so that it
		 *	accurately describes this channel.  Then put the structure into the
		 *	merge channel list.
		 */
		channel_attributes.channel_type = PRIVATE_CHANNEL;
		if (m_JoinedAttachmentList.IsEmpty() )
			channel_attributes.u.private_channel_attributes.joined = FALSE;
		else
			channel_attributes.u.private_channel_attributes.joined = TRUE;
		channel_attributes.u.private_channel_attributes.channel_id = Channel_ID;
		channel_attributes.u.private_channel_attributes.channel_manager = m_uidChannelManager;
		channel_attributes.u.private_channel_attributes.admitted_list =	&m_AuthorizedUserList;

		merge_channel_list.Append(&channel_attributes);

		/*
		 *	Send the merge request to the indicated provider.
		 */
		m_pConnToTopProvider->MergeChannelsRequest(&merge_channel_list, &purge_channel_list);
	}
}

/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function overrides the base class implementation.  The main
 *		difference is that this implementation only allows a user to join
 *		the private channel if it is either the channel manager or in the
 *		authorized user list.
 */
Void	PrivateChannel::ChannelJoinRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	/*
	 *	See if the requesting user is either the channel manager or in the
	 *	authorized user list.
	 */
	if ((uidInitiator == m_uidChannelManager) || m_AuthorizedUserList.Find(uidInitiator))
	{
		/*
		 *	See if anyone is currently joined to the channel in this sub-tree
		 */
		if (m_JoinedAttachmentList.IsEmpty())
		{
			/*
			 *	If this is the Top Provider, then this request can be handled
			 *	locally.
			 */
			if (IsTopProvider())
			{
				/*
				 *	There is no one in this sub-tree joined to the channel.  It
				 *	will therefore be necessary to add the originator to the
				 *	attachment list.
				 */
				TRACE_OUT (("PrivateChannel::ChannelJoinRequest: "
						"user %04X joining private channel = %04X",
						(UINT) uidInitiator, (UINT) Channel_ID));
				m_JoinedAttachmentList.Append(pOrigAtt);

				/*
				 *	Send a ChannelJoinConfirm downward to the originator.
				 */
				pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the join request
				 *	upward to the Top Provider.
				 */
				TRACE_OUT (("PrivateChannel::ChannelJoinRequest: "
						"forwarding join request to Top Provider"));
				m_pConnToTopProvider->ChannelJoinRequest(uidInitiator, Channel_ID);
			}
		}

		/*
		 *	There is at least one attachment joined to the channel, which means
		 *	that we do not have to forward the join request upward (even if
		 *	this is not the Top Provider).  Now check to see if the requesting
		 *	originator is already joined to the channel.
		 */
		else if (m_JoinedAttachmentList.Find(pOrigAtt) == FALSE)
		{
			/*
			 *	The originator is not yet joined to the channel, so add it to
			 *	the channel.
			 */
			TRACE_OUT (("PrivateChannel::ChannelJoinRequest: "
					"user %04X joining private channel = %04X",
					(UINT) uidInitiator, (UINT) Channel_ID));
			m_JoinedAttachmentList.Append(pOrigAtt);

			/*
			 *	Send a ChannelJoinConfirm downward to the originator.
			 */
			pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
		}

		else
		{
			/*
			 *	The originator is already joined to the channel.  Go ahead and
			 *	issue a successful channel join confirm.
			 */
			WARNING_OUT (("PrivateChannel::ChannelJoinRequest: "
					"already joined to channel"));
			pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
		}
	}
	else
	{
		/*
		 *	Someone is trying to join a private channel that they are not
		 *	admitted to.  Reject the request without further processing.
		 */
		WARNING_OUT (("PrivateChannel::ChannelJoinRequest: "
				"rejecting attempt to join private channel"));
		pOrigAtt->ChannelJoinConfirm(RESULT_NOT_ADMITTED, uidInitiator, channel_id, 0);
	}
}

/*
 *	Void	ChannelDisbandRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user that wishes to disband a
 *		private channel that it previously created.  If the requesting user is
 *		the private channel manager, then the request will be processed.  If
 *		this is not the Top Provider, the request will be forwarded upward.
 */
Void	PrivateChannel::ChannelDisbandRequest (
				CAttachment *,
				UserID				uidInitiator,
				ChannelID)
{
	CUidList				user_id_list;

	/*
	 *	Check to see if the requesting user is the channel manager.  Only
	 *	process the request if it is.
	 */
	if (uidInitiator == m_uidChannelManager)
	{
		/*
		 *	See if this is the Top Provider.  If it is, then the request can
		 *	be processed locally.  Otherwise, pass the request upward toward
		 *	the Top Provider.
		 */
		if (IsTopProvider())
		{
        	CAttachmentList     local_attachment_list;
        	CAttachmentList     remote_attachment_list;
        	CAttachment        *pAtt;

			TRACE_OUT (("PrivateChannel::ChannelDisbandRequest: "
					"disbanding channel = %04X", Channel_ID));

			/*
			 *	Go construct lists of the current unique local and remote
			 *	attachments.  These lists will be used to transmit the proper
			 *	channel expel and channel disband indications.
			 */
			BuildAttachmentLists (&m_AuthorizedUserList, &local_attachment_list,
					&remote_attachment_list);

			/*
			 *	It is also necessary to send the disband indication to the
			 *	channel manager, if it is valid and in the sub-tree of this
			 *	provider.  Determine what attachment leads to the channel
			 *	manager, and make sure that attachment is in the remote
			 *	attachment list, if valid.
			 */
			if (ValidateUserID(m_uidChannelManager))
			{
				PChannel		lpChannel;
				if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
                {
				    pAtt = lpChannel->GetAttachment();
				    if (m_pAttachmentList->Find(pAtt) && pAtt->IsConnAttachment())
				    {
					    if (remote_attachment_list.Find(pAtt) == FALSE)
					    {
						    remote_attachment_list.Append(pAtt);
						}
				    }
                }
                else
                {
                    ERROR_OUT(("PrivateChannel::ChannelDisbandRequest: can't locate channel"));
                }
			}

			/*
			 *	Loop through the local attachment list sending channel expel
			 *	indications to each attachment contained therein.
			 */
			local_attachment_list.Reset();
			while (NULL != (pAtt = local_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&m_AuthorizedUserList, pAtt, &user_id_list);

				/*
				 *	Send the expel indication to the locally attached user.
				 */
				pAtt->ChannelExpelIndication(Channel_ID, &user_id_list);
			}

			/*
			 *	Loop through the remote attachment list sending channel disband
			 *	indications to each attachment contained therein.
			 */
			remote_attachment_list.Reset();
			while (NULL != (pAtt = remote_attachment_list.Iterate()))
			{
				/*
				 *	Send the disband indication to the remotely attached
				 *	provider.
				 */
				pAtt->ChannelDisbandIndication(Channel_ID);
			}

			/*
			 *	Set m_uidChannelManager to 0 and clear the authorized user list as
			 *	an indicator that this private channel object is no longer
			 *	valid, and cannot be used.  The next time the domain object
			 *	calls IsValid, it will return FALSE allowing the domain object
			 *	to delete this object.
			 */
			m_uidChannelManager = 0;
			m_AuthorizedUserList.Clear();
		}
		else
		{
			/*
			 *	Set a flag indicating that a disband request has been sent
			 *	upward.  This flag will be used to prevent a disband indication
			 *	from being sent to the channel manager as it flows back down
			 *	the domain tree.
			 */
			m_fDisbandRequestPending = TRUE;

			/*
			 *	This is not the Top Provider, so forward the request toward
			 *	the Top Provider.  This will result in a channel disband
			 *	indication at a future time.
			 */
			TRACE_OUT (("PrivateChannel::ChannelDisbandRequest: "
					"forwarding request to Top Provider"));
			m_pConnToTopProvider->ChannelDisbandRequest(uidInitiator, Channel_ID);
		}
	}
	else
	{
		/*
		 *	Someone is trying to disband a private channel that they are not
		 *	the channel manager for.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::ChannelDisbandRequest: "
				"ignoring request from non-channel manager"));
	}
}

/*
 *	Void	ChannelDisbandIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it decides
 *		to delete a private channel from the domain.  It travels downward to
 *		all attachments and connections that contain an admitted user or the
 *		channel manager in their sub-tree.
 */
Void	PrivateChannel::ChannelDisbandIndication (
				ChannelID)
{
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList				user_id_list;

	TRACE_OUT (("PrivateChannel::ChannelDisbandIndication: "
			"disbanding channel = %04X", Channel_ID));

	/*
	 *	Build the lists of unique local and remote attachments.  These lists
	 *	will be used to issue the appropriate indications.
	 */
	BuildAttachmentLists (&m_AuthorizedUserList, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	It is also necessary to send the disband indication to the channel
	 *	manager, if it is valid and in the sub-tree of this provider.
	 *	Determine what attachment leads to the channel manager, and make sure
	 *	that attachment is in the remote attachment list, if valid.
	 */
	if (ValidateUserID(m_uidChannelManager))
	{
		PChannel		lpChannel;
		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
        {
		    pAtt = lpChannel->GetAttachment();
		    if ((m_fDisbandRequestPending == FALSE) ||
			    (m_pAttachmentList->Find(pAtt) && pAtt->IsConnAttachment()))
			{
			    if (remote_attachment_list.Find(pAtt) == FALSE)
			    {
				    remote_attachment_list.Append(pAtt);
				}
		    }
        }
        else
        {
            ERROR_OUT(("PrivateChannel::ChannelDisbandIndication: can't locate channel"));
        }
    }

	/*
	 *	Loop through the local attachment list sending channel expel indications
	 *	to each attachment contained therein.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&m_AuthorizedUserList, pAtt, &user_id_list);

		/*
		 *	Send the expel indication to the locally attached user.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_list);
	}

	/*
	 *	Loop through the remote attachment list sending channel disband
	 *	indications to each attachment contained therein.
	 */
	remote_attachment_list.Reset();
	while (NULL != (pAtt = remote_attachment_list.Iterate()))
	{
		/*
		 *	Send the disband indication to the remotely attached provider.
		 */
		pAtt->ChannelDisbandIndication(Channel_ID);
	}

	/*
	 *	Set m_uidChannelManager to 0 and clear the authorized user list as an
	 *	indicator that this private channel object is no longer valid, and
	 *	cannot be used.  The next time the domain object calls IsValid, it will
	 *	return FALSE allowing the domain object to delete this object.
	 */
	m_uidChannelManager = 0;
	m_AuthorizedUserList.Clear();
}

/*
 *	Void	ChannelAdmitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the manager of a private channel
 *		when it wishes to expand the authorized user list of that channel.  If
 *		this is the Top Provider, then the request can be handled locally.
 *		Otherwise, it must be forwarded upward to the Top Provider.
 */
Void	PrivateChannel::ChannelAdmitRequest (
				CAttachment *,
				UserID				uidInitiator,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID					uid;
	CUidList				admitted_id_list;
	CUidList				user_id_subset;

	/*
	 *	Check to see if the requesting user is the channel manager.  Only
	 *	process the request if it is.
	 */
	if (uidInitiator == m_uidChannelManager)
	{
		/*
		 *	See if this is the Top Provider.  If it is, then the request can
		 *	be processed locally.  Otherwise, pass the request upward toward
		 *	the Top Provider.
		 */
		if (IsTopProvider())
		{
        	CAttachmentList     local_attachment_list;
        	CAttachmentList     remote_attachment_list;
        	CAttachment        *pAtt;

			TRACE_OUT (("PrivateChannel::ChannelAdmitRequest: "
					"admitting users to channel = %04X", Channel_ID));

			/*
			 *	Iterate through the list of users to be admitted, adding all
			 *	valid users to the local authorized user list.
			 */
			user_id_list->Reset();
			while (NULL != (uid = user_id_list->Iterate()))
			{
				/*
				 *	Make sure that the user ID corresponds to a valid user in
				 *	the domain.
				 */
				if (ValidateUserID(uid))
				{
					/*
					 *	If the user is not already in the authorized user list,
					 *	then add it.
					 */
					if (m_AuthorizedUserList.Find(uid) == FALSE)
					{
						m_AuthorizedUserList.Append(uid);
						admitted_id_list.Append(uid);
					}
				}
			}

			/*
			 *	Build lists of unique attachments which can then be used to
			 *	issue the appropriate admit indications.  This prevents the
			 *	transmission of an admit indication to the same attachment more
			 *	than once.
			 */
			BuildAttachmentLists (&admitted_id_list, &local_attachment_list,
					&remote_attachment_list);

			/*
			 *	Iterate through the local attachment list issuing an admit
			 *	indication to each attachment contained therein.
			 */
			local_attachment_list.Reset();
			while (NULL != (pAtt = local_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the admit indication to the named attachment.
				 */
				pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
			}

			/*
			 *	Iterate through the remote attachment list issuing an admit
			 *	indication to each attachment contained therein.
			 */
			remote_attachment_list.Reset();
			while (NULL != (pAtt = remote_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the admit indication to the named attachment.
				 */
				pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
			}
		}
		else
		{
			/*
			 *	This is not the Top Provider, so forward the request toward
			 *	the Top Provider.  This will result in a channel admit
			 *	indication at a future time.
			 */
			TRACE_OUT (("PrivateChannel::ChannelAdmitRequest: "
					"forwarding request to Top Provider"));
			m_pConnToTopProvider->ChannelAdmitRequest(uidInitiator, Channel_ID, user_id_list);
		}
	}
	else
	{
		/*
		 *	Someone is trying to admit users to a private channel that they are
		 *	not the channel manager for.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::ChannelAdmitRequest: "
				"ignoring request from non-channel manager"));
	}
}

/*
 *	Void	ChannelAdmitIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it receives
 *		a channel admit indication from the manager of a private channel.  This
 *		indication is broadcast downward to all providers that contain an
 *		admitted user somewhere in their sub-tree.  A side-effect of this
 *		indication is that a private channel will be created in the information
 *		base if one does not already exist.
 */
Void	PrivateChannel::ChannelAdmitIndication (
				PConnection,
				UserID				uidInitiator,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID					uid;
	CUidList				admitted_id_list;
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList				user_id_subset;

	TRACE_OUT (("PrivateChannel::ChannelAdmitIndication: "
			"admitting users to channel = %04X", (UINT) Channel_ID));

	/*
	 *	Iterate through the list of users to be admitted, adding all
	 *	valid users to the local authorized user list.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Make sure that the user ID corresponds to a valid user in
		 *	the domain.
		 */
		if (ValidateUserID(uid))
		{
			/*
			 *	If the user is not already in the authorized user list,
			 *	then add it.
			 */
			if (m_AuthorizedUserList.Find(uid) == FALSE)
			{
				m_AuthorizedUserList.Append(uid);
				admitted_id_list.Append(uid);
			}
		}
	}

	/*
	 *	Build lists of unique attachments which can then be used to
	 *	issue the appropriate admit indications.  This prevents the
	 *	transmission of an admit indication to the same attachment more
	 *	than once.
	 */
	BuildAttachmentLists (&admitted_id_list, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	Iterate through the local attachment list issuing an admit
	 *	indication to each attachment contained therein.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the admit indication to the named attachment.
		 */
		pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
	}

	/*
	 *	Iterate through the remote attachment list issuing an admit
	 *	indication to each attachment contained therein.
	 */
	remote_attachment_list.Reset();
	while (NULL != (pAtt = remote_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the admit indication to the named attachment.
		 */
		pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
	}
}

/*
 *	Void	ChannelExpelRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the manager of a private channel
 *		when it wishes to shrink the authorized user list of that channel.  If
 *		the channel is in the local information base, the request is sent to it.
 *		Otherwise, the request is ignored.
 */
Void	PrivateChannel::ChannelExpelRequest (
				CAttachment *,
				UserID				uidInitiator,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID  				uid;
	CUidList				expelled_id_list;
	CUidList				user_id_subset;

	/*
	 *	Check to see if the requesting user is the channel manager.  Only
	 *	process the request if it is.
	 */
	if (uidInitiator == m_uidChannelManager)
	{
		/*
		 *	See if this is the Top Provider.  If it is, then the request can
		 *	be processed locally.  Otherwise, pass the request upward toward
		 *	the Top Provider.
		 */
		if (m_pConnToTopProvider == NULL)
		{
        	CAttachmentList         local_attachment_list;
        	CAttachmentList         remote_attachment_list;
        	CAttachment            *pAtt;

			TRACE_OUT (("PrivateChannel::ChannelExpelRequest: "
					"expelling users from channel = %04X", Channel_ID));

			/*
			 *	Iterate through the list of users to be expelled, removing all
			 *	valid users from the local authorized user list.
			 */
			user_id_list->Reset();
			while (NULL != (uid = user_id_list->Iterate()))
			{
				/*
				 *	If the user is in the authorized user list, then remove it.
				 */
				if (m_AuthorizedUserList.Find(uid))
				{
					m_AuthorizedUserList.Remove(uid);
					expelled_id_list.Append(uid);
				}
			}

			/*
			 *	Build lists of unique attachments which can then be used to
			 *	issue the appropriate expel indications.  This prevents the
			 *	transmission of an expel indication to the same attachment more
			 *	than once.
			 */
			BuildAttachmentLists (&expelled_id_list, &local_attachment_list,
					&remote_attachment_list);

			/*
			 *	Iterate through the local attachment list issuing an expel
			 *	indication to each attachment contained therein.
			 */
			local_attachment_list.Reset();
			while (NULL != (pAtt = local_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the expel indication to the named attachment.
				 */
				pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);

				/*
				 *	Since this is a locally attached user, it is necessary to
				 *	simulate a channel leave request from the user, indicating
				 *	the fact that it can no longer use the channel.
				 */
				ChannelLeaveRequest(pAtt, (CChannelIDList *) &user_id_subset);
			}

			/*
			 *	Iterate through the remote attachment list issuing an expel
			 *	indication to each attachment contained therein.
			 */
			remote_attachment_list.Reset();
			while (NULL != (pAtt = remote_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the expel indication to the named attachment.
				 */
				pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);
			}
		}
		else
		{
			/*
			 *	This is not the Top Provider, so forward the request toward
			 *	the Top Provider.  This will result in a channel expel
			 *	indication at a future time.
			 */
			TRACE_OUT (("PrivateChannel::ChannelExpelRequest: "
					"forwarding request to Top Provider"));
			m_pConnToTopProvider->ChannelExpelRequest(uidInitiator, Channel_ID, user_id_list);
		}
	}
	else
	{
		/*
		 *	Someone is trying to admit users to a private channel that they are
		 *	not the channel manager for.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::ChannelExpelRequest: "
				"ignoring request from non-channel manager"));
	}
}

/*
 *	Void	ChannelExpelIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it receives
 *		a request from the manager of a private channel to reduce the
 *		authorized user list.  It travels downward to all attachments and
 *		connections that contain an admitted user or the channel manager in
 *		their sub-tree.
 */
Void	PrivateChannel::ChannelExpelIndication (
				PConnection,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID					uid;
	CUidList				expelled_id_list;
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList				user_id_subset;

	TRACE_OUT (("PrivateChannel::ChannelExpelIndication: "
			"expelling users from channel = %04X", Channel_ID));

	/*
	 *	Iterate through the list of users to be expelled, removing all
	 *	valid users from the local authorized user list.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	If the user is in the authorized user list, then remove it.
		 */
		if (m_AuthorizedUserList.Find(uid))
		{
			m_AuthorizedUserList.Remove(uid);
			expelled_id_list.Append(uid);
		}
	}

	/*
	 *	Build lists of unique attachments which can then be used to
	 *	issue the appropriate expel indications.  This prevents the
	 *	transmission of an expel indication to the same attachment more
	 *	than once.
	 */
	BuildAttachmentLists (&expelled_id_list, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	Iterate through the local attachment list issuing an expel
	 *	indication to each attachment contained therein.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the expel indication to the named attachment.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);

		/*
		 *	Since this is a locally attached user, it is necessary to
		 *	simulate a channel leave request from the user, indicating
		 *	the fact that it can no longer use the channel.
		 */
		ChannelLeaveRequest(pAtt, (CChannelIDList *) &user_id_subset);
	}

	/*
	 *	Iterate through the remote attachment list issuing an expel
	 *	indication to each attachment contained therein.
	 */
	remote_attachment_list.Reset();
	while (NULL != (pAtt = remote_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the expel indication to the named attachment.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);
	}
}

/*
 *	Void	SendDataRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user that wishes to send data
 *		to other users who are joined to a specified channel.  This routine
 *		is executed in the case that it is a private channel.  It verifies
 *		that the user is authorized to use the channel before allowing the data
 *		to be sent.
 */
Void	PrivateChannel::SendDataRequest (
				CAttachment        *pOrigAtt,
				UINT				type,
				PDataPacket			data_packet)
{
	UserID  uidInitiator;

	uidInitiator = data_packet->GetInitiator();
	if ((uidInitiator == m_uidChannelManager) || m_AuthorizedUserList.Find(uidInitiator))
	{
		/*
		 *	The channel usage is authorized, so forward the request to the
		 *	base class implementation for processing.
		 */
		Channel::SendDataRequest(pOrigAtt, type, data_packet);
	}
	else
	{
		/*
		 *	Someone is trying to send data on a private channel that they are
		 *	not authorized to use.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::SendDataRequest: "
				"ignoring request from non-authorized user"));
	}
}

/*
 *	BOOL    ValidateUserID ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called whenever another member function of this class
 *		wants to check and see if a specified user is still valid in the
 *		domain channel list.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user being checked out.
 *
 *	Return Value:
 *		TRUE if the user is valid.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 */
BOOL    PrivateChannel::ValidateUserID (
					UserID			user_id)
{
	PChannel	channel;

	/*
	 *	First check to see if the user ID is in the channel list at all.  This
	 *	prevents an attempt to read an invalid entry from the dictionary.
	 */
	if (NULL != (channel = m_pChannelList2->Find(user_id)))
	{
		/*
		 *	We know that the ID is in the dictionary, but we don't know for sure
		 *	whether or not it is a user ID channel.  So check this.  If it is a
		 *	user channel, then set the valid flag to TRUE.
		 */
		if (channel->GetChannelType () == USER_CHANNEL)
			return TRUE;
	}

	return FALSE;
}

/*
 *	Void	BuildAttachmentLists ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called upon to build a list of unique attachments that
 *		lead to the users in the specified list.  It builds two attachment
 *		lists.  The first has an entry for each unique local attachment.  The
 *		second for each remote attachment.  The key to each list is the
 *		attachment.
 *
 *	Formal Parameters:
 *		user_id_list (i)
 *			This is the list of users for which the list is to be built.
 *		local_attachment_list (i)
 *			This is the dictionary that is to contain the list of unique
 *			local attachments.
 *		remote_attachment_list (i)
 *			This is the dictionary that is to contain the list of unique
 *			remote attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	PrivateChannel::BuildAttachmentLists (
				CUidList                *user_id_list,
				CAttachmentList         *local_attachment_list,
				CAttachmentList         *remote_attachment_list)
{
	UserID				uid;

	/*
	 *	Loop through the passed in user ID list building a dictionary of local
	 *	attachments (those leading to locally attached users) and a dictionary
	 *	of remote attachments (those leading to remotely connected providers).
	 *	These dictionaries will be used by this provider to issue various
	 *	indications downward, without sending multiple indications to the same
	 *	attachment.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Check to see if the user ID refers to a valid user in the sub-tree
		 *	of this provider.
		 */
		if (ValidateUserID(uid))
		{
			PChannel		lpChannel;
			/*
			 *	Determine which attachment leads to the user in question.
			 */
			if (NULL != (lpChannel = m_pChannelList2->Find(uid)))
            {
			    CAttachment *pAtt = lpChannel->GetAttachment();
			    /*
			     *	This module builds separate lists for those users that are
			     *	attached locally and those attached remotely.
			     */
                if (m_pAttachmentList->Find(pAtt))
                {
			        if (pAtt->IsUserAttachment())
			        {
				        /*
				         *	This attachment is a local one (meaning that it leads to a
				         *	locally attached user, rather than another MCS provider).
				         *	Check to see if this attachment has already been put into
				         *	the dictionary while processing a previous user ID.
				         */
				        if (local_attachment_list->Find(pAtt) == FALSE)
					        local_attachment_list->Append(pAtt);
			        }
			        else
			        {
				        /*
				         *	This attachment is a remote one (meaning that it leads to
				         *	another MCS provider, rather than a locally attached user).
				         *	Check to see if this attachment has already been put into
				         *	the dictionary while processing a previous user ID.
				         */
				        if (remote_attachment_list->Find(pAtt) == FALSE)
					        remote_attachment_list->Append(pAtt);
			        }
                }
                else
                {
                    ERROR_OUT(("PrivateChannel::BuildAttachmentLists: can't find this attachment=0x%p", pAtt));
                }
            }
            else
            {
                ERROR_OUT(("PrivateChannel::BuildAttachmentLists: can't locate channel"));
            }
        }
		else
		{
			/*
			 *	This user ID does not correspond to a valid user in the sub-tree
			 *	of this provider.  Therefore, discard the ID.
			 */
			ERROR_OUT (("PrivateChannel::BuildAttachmentLists: "
					"ERROR - user ID not valid"));
		}
	}
}

/*
 *	Void	BuildUserIDList ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called upon to build a list of all users in the
 *		specified list that are in the direction of the specified attachment.
 *
 *	Formal Parameters:
 *		user_id_list (i)
 *			This is the list of users for which the list is to be built.
 *		attachment (i)
 *			This is the attachment that the caller wishes to have a list of
 *			user IDs for.
 *		user_id_subset (o)
 *			This is the subset of the passed in user IDs that are in the
 *			direction of the specified attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	PrivateChannel::BuildUserIDList (
				CUidList               *user_id_list,
				CAttachment            *pAtt,
				CUidList               *user_id_subset)
{
	UserID				uid;

	/*
	 *	Clear out the subset list, so that we start fresh.
	 */
	user_id_subset->Clear();

	/*
	 *	Loop through the specified user list, checking to see which users
	 *	lie in the direction of the specified attachment.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Check to see if the user ID refers to a valid user in the sub-tree
		 *	of this provider.
		 */
		if (ValidateUserID(uid))
		{
			PChannel	lpChannel;
			/*
			 *	Check to see if this user is the direction of the specified
			 *	attachment.  If it is, then put it into the user ID subset that
			 *	we are building.
			 */
			if (NULL != (lpChannel = m_pChannelList2->Find(uid)))
            {
			    if (lpChannel->GetAttachment () == pAtt)
				    user_id_subset->Append(uid);
            }
            else
            {
                ERROR_OUT(("PrivateChannel::BuildUserIDList: can't locate channel"));
            }
		}
		else
		{
			/*
			 *	This user ID does not correspond to a valid user in the sub-tree
			 *	of this provider.  Therefore, discard the ID.
			 */
			ERROR_OUT (("PrivateChannel::BuildUserIDList: "
					"ERROR - user ID not valid"));
		}
	}
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\randchnl.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	randchnl.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the RandomChannelGenerator class,
 *		which inherits from the RandomNumberGenerator class.  On instantiation,
 *		instances of this class will internally generate a random number which
 *		falls within the allowable range of dynamic channels values.  Channel
 *		assignments are then generated by incrementing this value each time a
 *		new assignment is requested.  Once the maximum allowable value has been
 *		assigned, the next value to be generated "wraps around" to the minimum
 *		allowable value.
 *
 *		Obviously, this class does not generate completely random channel
 *		values for each request.  With a completely random generator, it is
 *		possible to delete a channel in MCS, and then have the random number
 *		generator assign the same value as the deleted channel before all
 *		components of the system even know that the channel was deleted to
 *		start with, thus causing erratic behavior in the system.  In this
 *		class, no channel can be reassigned until all other possible channels
 *		have been assigned.
 *
 *		This class can be modifed in the future to incorporate additional
 *		"randomness" into the algorithm and still not reassign any channel
 *		numbers before all other possible values are used.  This, however,
 *		would be at the expense of performance and/or memory resources.
 *                  
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Alan D. May
 */
#include "randchnl.h"

/*
 *	These macros define the mimimum and maximum allowable dynamic channel
 *	values.
 */
#define MINIMUM_DYNAMIC_CHANNEL		1001
#define MAXIMUM_DYNAMIC_CHANNEL		65535

/*
 *	RandomChannelGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random channel
 *		generator object that has been automatically seeded with the current
 *		time.
 */
RandomChannelGenerator::RandomChannelGenerator()
{
	Current_Channel = (GetTickCount() % (MAXIMUM_DYNAMIC_CHANNEL + 1 - MINIMUM_DYNAMIC_CHANNEL)) + MINIMUM_DYNAMIC_CHANNEL;
}

/*
 *	~RandomChannelGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the RandomChannelGenerator class.
 */
RandomChannelGenerator::~RandomChannelGenerator ()
{
}

/*
 *	GetRandomChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method returns a valid dynamic channel number.
 */
RandomValue		RandomChannelGenerator::GetRandomChannel (Void)
{
	/*
	 *	Increment the current channel value.
	 */
	++Current_Channel;

	/*
	 *	Determine if the current channel value needs to wrap around.
	 */	if (Current_Channel > MAXIMUM_DYNAMIC_CHANNEL)
	{
		Current_Channel = MINIMUM_DYNAMIC_CHANNEL;
	}

	/*
	 *	Return the current channel value.
	 */
	return (Current_Channel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\privlist.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/* 
 *	privlist.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the imlpementation file for the class PrivilegeListData. 
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */


#include "privlist.h"



/*
 *	PrivilegeListData ()
 *
 *	Public Function Description
 */
PrivilegeListData::PrivilegeListData(	
								PGCCConferencePrivileges	privilege_list)
{
	Privilege_List = *privilege_list;
}


/*
 *	GetPrivilegeListPDU ()
 *
 *	Public Function Description
 */
PrivilegeListData::PrivilegeListData(	PSetOfPrivileges	set_of_privileges)
{
	PSetOfPrivileges 	privilege_set;
	Privilege			privilege_value;

	Privilege_List.terminate_is_allowed = FALSE;
	Privilege_List.eject_user_is_allowed = FALSE;
	Privilege_List.add_is_allowed = FALSE;
	Privilege_List.lock_unlock_is_allowed = FALSE;
	Privilege_List.transfer_is_allowed = FALSE;

	privilege_set = set_of_privileges;

	while (privilege_set != NULL)
	{
		privilege_value = privilege_set->value;
			
		switch (privilege_value)
		{
			case TERMINATE:
				Privilege_List.terminate_is_allowed = TRUE;
				break;
	
			case EJECT_USER:
				Privilege_List.eject_user_is_allowed = TRUE;
				break;
	
			case ADD:
				Privilege_List.add_is_allowed = TRUE;
				break;
	
			case LOCK_UNLOCK:
				Privilege_List.lock_unlock_is_allowed = TRUE;
				break;
	
			case TRANSFER:
				Privilege_List.transfer_is_allowed = TRUE;
				break;

			default:
				ERROR_OUT(("PrivilegeListData::PrivilegeListData: Bad privilege value=%d", (UINT) privilege_value));
				break;
		}

		privilege_set = privilege_set->next;
	}
}


/*
 *	~PrivilegeListData	()
 *
 *	Public Function Description
 */
PrivilegeListData::~PrivilegeListData()
{
}


/*
 *	GetPrivilegeListData ()
 *
 *	Public Function Description
 */


/*
 *	GetPrivilegeListPDU ()
 *
 *	Public Function Description
 */
GCCError	PrivilegeListData::GetPrivilegeListPDU(
						PSetOfPrivileges		*	set_of_privileges)
{
	GCCError			return_value = GCC_NO_ERROR;
	PSetOfPrivileges	current_privilege = NULL;
	PSetOfPrivileges	next_privilege = NULL;
	Privilege			privilege_value;
	Int					i;
	
	*set_of_privileges = NULL;
	
	for (i = 0; i < NUMBER_OF_PRIVILEGES; i++)
	{
		privilege_value = (Privilege)NUMBER_OF_PRIVILEGES;
	
		switch (i)
		{
			case TERMINATE_IS_ALLOWED:
				if (Privilege_List.terminate_is_allowed )
					privilege_value = TERMINATE;
				break;
	
			case EJECT_USER_IS_ALLOWED:
				if (Privilege_List.eject_user_is_allowed )
					privilege_value = EJECT_USER;
				break;
	
			case ADD_IS_ALLOWED:
				if (Privilege_List.add_is_allowed )
					privilege_value = ADD;
				break;
	
			case LOCK_UNLOCK_IS_ALLOWED:
				if (Privilege_List.lock_unlock_is_allowed )
					privilege_value = LOCK_UNLOCK;
				break;
	
			case TRANSFER_IS_ALLOWED:
				if (Privilege_List.transfer_is_allowed )
					privilege_value = TRANSFER;
				break;

			default:
				ERROR_OUT(("PrivilegeListData::GetPrivilegeListPDU: Bad value"));
				break;
		}
		
		if (privilege_value != NUMBER_OF_PRIVILEGES)
		{
    		DBG_SAVE_FILE_LINE
			next_privilege = new SetOfPrivileges;

			if (next_privilege != NULL)
			{
				next_privilege->value = privilege_value; 
				next_privilege->next = NULL;

				if (*set_of_privileges == NULL)
				{
					*set_of_privileges = next_privilege;
					current_privilege = next_privilege;
				}
				else
				{
					current_privilege->next = next_privilege;
					current_privilege = next_privilege;
				}
					 
			}
			else
			{
				return_value = GCC_ALLOCATION_FAILURE;
				break;
			}
		}
	}

	return (return_value);
}


/*
 *	FreePrivilegeListPDU ()
 *
 *	Public Function Description
 */
Void	PrivilegeListData::FreePrivilegeListPDU(
						PSetOfPrivileges			set_of_privileges)
{
	PSetOfPrivileges	current_privilege = NULL;
	PSetOfPrivileges	next_privilege = NULL;
	
	current_privilege = set_of_privileges;
	while (current_privilege != NULL)
	{
		next_privilege = current_privilege->next;
		
		delete current_privilege;
		current_privilege = next_privilege;	
	}
}


/*
 *	IsPrivilegeAvailable ()
 *
 *	Public Function Description
 */
BOOL    PrivilegeListData::IsPrivilegeAvailable (
							ConferencePrivilegeType			privilege_type)
{
	BOOL    return_value = FALSE;
	
	switch (privilege_type)
	{
		case TERMINATE_PRIVILEGE:
			if (Privilege_List.terminate_is_allowed )
				return_value = TRUE;
			break;
			
		case EJECT_USER_PRIVILEGE:
			if (Privilege_List.eject_user_is_allowed )
				return_value = TRUE;
			break;
			
		case ADD_PRIVILEGE:
			if (Privilege_List.add_is_allowed )
				return_value = TRUE;
			break;
			
		case LOCK_UNLOCK_PRIVILEGE:
			if (Privilege_List.lock_unlock_is_allowed )
				return_value = TRUE;
			break;
			
		case TRANSFER_PRIVILEGE:
			if (Privilege_List.transfer_is_allowed )
				return_value = TRUE;
			break;
	}
	
	return (return_value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\sap.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);
/*
 *	sap.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CBaseSap.  This class is an
 *		abstract base class for objects that act as Service Access Points (SAPs)
 *		to external applications or the node controller.
 *
 *		This class has two main responsibilities. First, it handles many of the
 *		administrative tasks that are common to all types of SAPs.  These
 *		include handling command target registration responsibilities and
 *		managing the message queue.  It	also handles all of the primitives that
 *		are common between the Control SAP (CControlSAP class) and Application
 *		SAPs (CAppSap class).
 *
 *	Protected Member Functions:
 *		AddToMessageQueue
 *			This routine is used to place messages into the queue of messages
 *			to be sent to applications or the node controller.
 *		CreateDataToBeDeleted
 *			This routine is used to create a structure which holds message data
 *			to be delivered to applications or the node controller.
 *		CopyDataToGCCMessage
 *			This routine is	used to fill in the messages to be delivered to
 *			applications or the node controller with the necessary data.
 *		FreeCallbackMessage
 *			This is a virtual function which is used to free up any data which
 *			was allocated in order to send a callback message.  This function
 *			is overloaded in CControlSAP to free messages which were sent to the
 *			node controller.  It is overloaded in CAppSap to free messages sent
 *			to applications.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */


#include "ms_util.h"
#include "sap.h"
#include "conf.h"
#include "gcontrol.h"
#include "ernccm.hpp"


/*
 *	The node controller SAP handle is always 0.
 */
#define NODE_CONTROLLER_SAP_HANDLE						0

LRESULT CALLBACK SapNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern HINSTANCE g_hDllInst;
extern char g_szGCCWndClassName[24];


/*
 *	CBaseSap::CBaseSap()
 *
 *	Public Function Description
 *		This is the CBaseSap constructor.  The hash list used to hold command
 *		target objects is initialized by this constructor.
 */
#ifdef SHIP_BUILD
CBaseSap::CBaseSap(void)
:
    CRefCount(),
#else
CBaseSap::CBaseSap(DWORD dwStampID)
:
    CRefCount(dwStampID),
#endif
    m_nReqTag(GCC_INVALID_TAG)
{
    //
    // LONCHANC: We have to create the hidden window first
    // because we may need to post PermissionToEnrollIndication
    // to this window for Chat and File Transfer.
    //

    ASSERT(g_szGCCWndClassName[0] == 'G' &&
           g_szGCCWndClassName[1] == 'C' &&
           g_szGCCWndClassName[2] == 'C');
    //
    // Create a hidden window for confirm and indication.
    // CAppSap or CControlSAP should check for the value of m_hwndNotify.
    //
    m_hwndNotify = CreateWindowA(g_szGCCWndClassName, NULL, WS_POPUP,
                        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                        NULL, NULL, g_hDllInst, NULL);

    ASSERT(NULL != m_hwndNotify);
}

CBaseSap::~CBaseSap(void)
{
    //
    // Destroy window and unregister window class
    //
    if (NULL != m_hwndNotify)
    {
        ::DestroyWindow(m_hwndNotify);
    }
}


BOOL CBaseSap::IsThisNodeTopProvider(GCCConfID nConfID)
{
    BOOL   fRet;
    CConf  *pConf;
    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        fRet = pConf->IsConfTopProvider();
    }
    else
    {
        fRet = FALSE;
    }
    return fRet;
}


GCCNodeID CBaseSap::GetTopProvider(GCCConfID nConfID)
{
    GCCNodeID uRet;
    CConf     *pConf;
    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        uRet = pConf->GetTopProvider();
    }
    else
    {
        uRet = 0;
    }
    return uRet;
}


/*
 *	ConfRosterInquire()
 *
 *	Public Function Description
 *		This routine is used to retrieve the conference roster.  This function
 *		just passes this request to the controller via an owner callback.  The
 *		conference roster is delivered to the requesting command target object
 *		in a Conference Roster inquire confirm.
 */
GCCError CBaseSap::
ConfRosterInquire(GCCConfID nConfID, GCCAppSapMsgEx **ppMsgEx)
{
	GCCError  rc;
    CConf     *pConf;

    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
		rc = pConf->ConfRosterInquireRequest(this, ppMsgEx);
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CBaseSap::ConfRosterInquire: can't inquire app roster, rc=%u", (UINT) rc));
            // goto MyExit;
        }
	}
	else
    {
        WARNING_OUT(("CBaseSap::ConfRosterInquire: invalid conf ID=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
    }

	return rc;
}

/*
 *	GCCError   AppRosterInquire()
 *
 *	Public Function Description
 *		This routine is used to retrieve a list of application rosters.  This
 *		function just passes this request to the controller via an owner
 *		callback.  This	list is delivered to the requesting SAP through an
 *		Application Roster inquire confirm message.
 */
GCCError CBaseSap::
AppRosterInquire(GCCConfID          nConfID,
                 GCCSessionKey      *pSessionKey,
                 GCCAppSapMsgEx     **ppMsgEx) // nonzero for sync operation

{
	GCCError  rc;
    CConf     *pConf;

    if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        WARNING_OUT(("CBaseSap::AppRosterInquire: invalid conf ID=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
    }
	else
	{
        CAppRosterMsg  *pAppRosterMsg;
		rc = pConf->AppRosterInquireRequest(pSessionKey, &pAppRosterMsg);
        if (GCC_NO_ERROR == rc)
        {
            AppRosterInquireConfirm(nConfID, pAppRosterMsg, GCC_RESULT_SUCCESSFUL, ppMsgEx);
            pAppRosterMsg->Release();
        }
        else
        {
            ERROR_OUT(("CBaseSap::AppRosterInquire: can't inquire app roster, rc=%u", (UINT) rc));
        }
	}

	return rc;
}

/*
 *	ConductorInquire()
 *
 *	Public Function Description
 *		This routine is called in order to retrieve conductorship information.
 *		The conductorship information is returned in the confirm.
 *
 */
GCCError CBaseSap::ConductorInquire(GCCConfID nConfID)
{
    GCCError    rc;
    CConf       *pConf;

	/*
	**	Make sure the conference exists in the internal list before forwarding
	**	the call on to the conference object.
	*/
	if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
		rc = pConf->ConductorInquireRequest(this);
	}
	else
	{
		rc = GCC_INVALID_CONFERENCE;
	}

	return rc;
}

/*
 *	AppInvoke()
 *
 *	Public Function Description
 *		This routine is called in order to invoke other applications at remote
 *		nodes.  The request is passed on to the appropriate Conference objects.
 */
GCCError CBaseSap::
AppInvoke(GCCConfID             nConfID,
          GCCAppProtEntityList  *pApeList,
          GCCSimpleNodeList     *pNodeList,
          GCCRequestTag         *pnReqTag)
{
	GCCError							rc = GCC_NO_ERROR;
	CInvokeSpecifierListContainer		*invoke_list;
	UINT								i;
	CConf       *pConf;

    DebugEntry(CBaseSap::AppInvoke);

    if (NULL == pApeList || NULL == pNodeList || NULL == pnReqTag)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

    *pnReqTag = GenerateRequestTag();

	if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
		if (pApeList->cApes != 0)
		{
			/*
			**	Create an object which is used to hold the list of application
			**	invoke specifiers.
			*/
			DBG_SAVE_FILE_LINE
			invoke_list = new CInvokeSpecifierListContainer(
									pApeList->cApes,
									pApeList->apApes,
									&rc);
			if ((invoke_list != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				**	Here we must check the destination node list for invalid
				**	node IDs.
				*/
				for (i = 0; i < pNodeList->cNodes; i++)
				{
					if (pNodeList->aNodeIDs[i] < MINIMUM_USER_ID_VALUE)
					{
						rc = GCC_INVALID_MCS_USER_ID;
						goto MyExit;
					}
				}

				/*
				**	If no error has occurred, send the request on to the
				**	command target (conference) object.
				*/
				rc = pConf->AppInvokeRequest(invoke_list, pNodeList, this, *pnReqTag);

				/*
				**	Free here instead of delete in case the object
				**	must persist.
				*/
				invoke_list->Release();
			}
			else if (invoke_list == NULL)
			{
				ERROR_OUT(("CBaseSap::AppInvoke: Error creating new AppInvokeSpecList"));
				rc = GCC_ALLOCATION_FAILURE;
				// goto MyExit;
			}
			else
			{
				invoke_list->Release();
			}
		}
		else
		{
			rc = GCC_BAD_NUMBER_OF_APES;
			// goto MyExit;
		}
	}
	else
	{
		rc = GCC_INVALID_CONFERENCE;
		// goto MyExit;
	}

MyExit:

    DebugExitINT(CBaseSap::AppInvoke, rc);
	return rc;
}


GCCRequestTag CBaseSap::GenerateRequestTag(void)
{
    GCCRequestTag nNewReqTag;

    ASSERT(sizeof(GCCRequestTag) == sizeof(LONG));

    nNewReqTag = ++m_nReqTag;
    if (GCC_INVALID_TAG == nNewReqTag)
    {
        nNewReqTag = ++m_nReqTag;
    }

    // we only take the lower word
    return (nNewReqTag & 0x0000FFFFL);
}




//
// SapNotifyWndProc() is used to notify the sap clients (app in app sap,
// node controller in control sap) in their respective thread.
// The window handle is in CSap::m_hwndNotify.
//
LRESULT CALLBACK
SapNotifyWndProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    LRESULT wnd_rc = 0;

    if (CSAPMSG_BASE <= uMsg && uMsg < CSAPCONFIRM_BASE + MSG_RANGE)
    {
        ASSERT(CSAPMSG_BASE + MSG_RANGE == CSAPCONFIRM_BASE);
        if (uMsg < CSAPMSG_BASE + MSG_RANGE)
        {
            if (((CControlSAP *) lParam) == g_pControlSap)
            {
                g_pControlSap->NotifyProc((GCCCtrlSapMsgEx *) wParam);
            }
            else
            {
                WARNING_OUT(("SapNotifyWndProc: invalid control sap, uMsg=%u, lParam=0x%p, g_pControlSap=0x%p",
                            uMsg, lParam, g_pControlSap));
            }
        }
        else
        {
            ASSERT(CSAPCONFIRM_BASE <= uMsg && uMsg < CSAPCONFIRM_BASE + MSG_RANGE);
            if (NULL != g_pControlSap)
            {
                g_pControlSap->WndMsgHandler(uMsg, wParam, lParam);
            }
            else
            {
                WARNING_OUT(("SapNotifyWndProc: invalid control sap, uMsg=%u, wParam=0x%x, lParam=0x%x",
                            uMsg, (UINT) wParam, (UINT) lParam));
            }
        }
    }
    else
    if (ASAPMSG_BASE <= uMsg && uMsg < ASAPMSG_BASE + MSG_RANGE)
    {
        ASSERT(uMsg == ASAPMSG_BASE + (UINT) ((GCCAppSapMsgEx *) wParam)->Msg.eMsgType);
        ((CAppSap *) lParam)->NotifyProc((GCCAppSapMsgEx *) wParam);
    }
    else
    if (CONFMSG_BASE <= uMsg && uMsg < CONFMSG_BASE + MSG_RANGE)
    {
        ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != ((CConf *) lParam))
        {
            ((CConf *) lParam)->WndMsgHandler(uMsg);
        }
        else
        {
            ERROR_OUT(("SapNotifyWndProc: invalid conf object, uMsg=%u, lParam=0x%x",
                        uMsg, (UINT) lParam));
        }
        ::LeaveCriticalSection(&g_csGCCProvider);
    }
    else
    if (GCTRLMSG_BASE <= uMsg && uMsg < GCTRLMSG_BASE + MSG_RANGE)
    {
        ::EnterCriticalSection(&g_csGCCProvider);
        if (((GCCController *) lParam) == g_pGCCController)
        {
            g_pGCCController->WndMsgHandler(uMsg);
        }
        else
        {
            WARNING_OUT(("SapNotifyWndProc: invalid gcc controller, uMsg=%u, lParam=0x%p, g_pGCCController=0x%p",
                        uMsg, lParam, g_pGCCController));
        }
        ::LeaveCriticalSection(&g_csGCCProvider);
    }
    else
    if (MCTRLMSG_BASE <= uMsg && uMsg < MCTRLMSG_BASE + MSG_RANGE)
    {	
    	void CALLBACK MCSCallBackProcedure (UINT, LPARAM, PVoid);
    	MCSCallBackProcedure (uMsg - MCTRLMSG_BASE, lParam, NULL);
    	/*
    	 *	If the msg contains user data, we need to unlock the
    	 *	memory with it.
    	 */
    	UnlockMemory ((PMemory) wParam);
    }
    else
    if (NCMSG_BASE <= uMsg && uMsg < NCMSG_BASE + MSG_RANGE)
    {
        if (((DCRNCConferenceManager *) wParam) == g_pNCConfMgr)
        {
            g_pNCConfMgr->WndMsgHandler(uMsg, lParam);
        }
        else
        {
            WARNING_OUT(("SapNotifyWndProc: invalid NC ConfMgr, uMsg=%u, lParam=0x%p, g_pNCConfMgr=0x%p",
                        uMsg, lParam, g_pNCConfMgr));
        }
    }
    else
    {
        switch (uMsg)
        {
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
    }

    return wnd_rc;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\registry.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	registry.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the registry class implementation file. All registry operations
 *		at both the Top Provider and subordinate nodes.  It is responsible for
 *		queing registry request, maintaining the registry, sending confirms to
 *		the application SAP, etc.  Registry objects at sub-ordinate nodes are
 *		responsible for queuing up the registry request to be sent on to the
 *		Top Provider.  On of these classes should be created per node.  This
 *		class handles request from all existing application SAPs.
 *
 *		FOR A MORE DETAILED EXPLANATION OF THIS CLASS SEE THE INTERFACE FILE
 *
 *	Private Instance Variables:
 *  	m_pMCSUserObject
 *			Pointer to the User Attachment object used to deliver all registry
 *			request and responses to remote nodes.
 *		m_RegEntryList
 *			This is the list that holds all the registry entries associated 
 *			with this conference.
 *	 	m_fTopProvider
 *			This flag specifies if this is the top provider node (TRUE means
 *			this is the top provider node). 
 *		m_nCurrentTokenID
 *			This is a counter that is used to generate the token IDs by the 
 *			registry object at the top provider.
 *		m_nConfID
 *			Conference ID assocaited with this conference.
 *		m_pEmptyRegItem
 *			This is a pointer to an empty registry item that is used to generate
 *			empty items for PDUs that don't contain a registry item.
 *		m_AppSapEidList2
 *			This list contains pointers to the command target objects associated
 *			with each of the enrolled APEs
 *		m_nRegHandle
 *			This is a counter that is used to generate the handles allocated
 *			by the registry object at the top provider.
 *		m_pAppRosterMgrList
 *			This list hold all the current application roster managers and
 *			is used to verify that a requesting APE is actually enrolled with
 *			the conference.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "registry.h"
#include "appsap.h"

#define		FIRST_DYNAMIC_TOKEN_ID				16384
#define		MAXIMUM_ALLOWABLE_ALLOCATED_HANDLES	(16 * 1024) // for T.126


/*
 *	CRegistry()
 *
 *	Public Function Description
 *		This is the registry constructor.  It is responsible for initializing
 *		instance variables.
 *
 */
CRegistry::CRegistry(PMCSUser						user_object,
					BOOL    						top_provider,
					GCCConfID   					conference_id,
					CAppRosterMgrList				*app_roster_manager_list,
					PGCCError						pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','R','e','g')),
	m_AppSapEidList2(DESIRED_MAX_APP_SAP_ITEMS),
	m_pMCSUserObject(user_object),
	m_fTopProvider(top_provider),
	m_nCurrentTokenID(FIRST_DYNAMIC_TOKEN_ID),
	m_nConfID(conference_id),
	m_nRegHandle(0),
	m_pAppRosterMgrList(app_roster_manager_list)
{
	GCCRegistryItem		registry_item;

	*pRetCode = GCC_NO_ERROR;

	/*
	**	If this is the Top Provider we now build a vacant registry item to
	**	be used when an entry in the registry is being accessed that does not
	**	exists.
	*/
	if (m_fTopProvider)
	{
		registry_item.item_type = GCC_REGISTRY_NONE;
		DBG_SAVE_FILE_LINE
		m_pEmptyRegItem = new CRegItem(&registry_item, pRetCode);
		if (m_pEmptyRegItem == NULL || GCC_NO_ERROR != *pRetCode)
        {
			*pRetCode = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		m_pEmptyRegItem = NULL;
    }
}
        
/*
 *	~CRegistry()
 *
 *	Public Function Description
 *		This is the registry destructor. It is responsible for freeing any
 *		outstanding memory associated with the application registry.
 */
CRegistry::~CRegistry(void)
{
	REG_ENTRY *pRegEntry;

	m_RegEntryList.Reset();

	//	Free up any registry entries
	while (NULL != (pRegEntry = m_RegEntryList.Iterate()))
	{
		if (NULL != pRegEntry->registry_key)
		{
		    pRegEntry->registry_key->Release();
		}
		if (NULL != pRegEntry->entry_item)
		{
		    pRegEntry->entry_item->Release();
		}
		delete pRegEntry;
	}

	if (NULL != m_pEmptyRegItem)
	{
        m_pEmptyRegItem->Release();
	}
}

/*
 *	void	EnrollAPE ()
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of a newly
 *		enrolling APE and its corresponding command target interface.
 */
void CRegistry::EnrollAPE(EntityID eid, CAppSap *pAppSap)
{
    m_AppSapEidList2.Append(eid, pAppSap);
}

/*
 *	void	UnEnrollApplicationSAP ()
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of an 
 *		APE that is unerolling from the conference.
 *
 *	Caveats
 *		This routine removes ownership from all the entries currently owned by 
 *		the passed in application entity.  It will also remove any outstanding
 *		request for the SAP that unenrolled.
 */
void	CRegistry::UnEnrollAPE (	EntityID	entity_id )
{
	REG_ENTRY       *lpRegEntry;
	UserID			my_user_id = m_pMCSUserObject->GetMyNodeID();

	m_RegEntryList.Reset();
	while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
	{
		/*
		**	First we remove this APE from the list of nodes that are
		**	monitoring this entry.
		*/
		lpRegEntry->monitoring_list.Remove(entity_id);

		/*
		**	Next, if this is the top provider, we clean up the the 
		**	ownership properties of this entry and issue any PDUs and/or
		**	messages that are necessary.
		*/
		if (m_fTopProvider)
		{
			if ((lpRegEntry->owner_id == my_user_id) &&
				(lpRegEntry->entity_id == entity_id))
			{
				/*
				**	Ownership is removed from any registry entries this 
				**	entity owned.
				*/
				lpRegEntry->owner_id = 0;
				lpRegEntry->entity_id = 0;
		
				//	Send Monitor Indication if necessary
				if (lpRegEntry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage (lpRegEntry);
				
					m_pMCSUserObject->RegistryMonitorEntryIndication(
							lpRegEntry->registry_key,
							lpRegEntry->entry_item,
							lpRegEntry->owner_id,
							lpRegEntry->entity_id,
							lpRegEntry->modification_rights);
				}
			}
		}
	}

	//	Remove this enity from the command target list if it exists.	
	m_AppSapEidList2.Remove(entity_id);
}

/*
 *	GCCError	RegisterChannel ()
 *
 *	Public Function Description
 *		This routine is responsible for registering a specified channel.
 *		It has two different paths of execution based on whether this is
 *		a Top Provider registry or a subordinate node registry object.
 */
GCCError	CRegistry::RegisterChannel (
										PGCCRegistryKey		registry_key,
										ChannelID			channel_id,
										EntityID			entity_id)
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry; // a must
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CRegItem            *registry_item_data = NULL; // a must
	GCCRegistryItem		registry_item;
	CAppSap	            *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
		return (GCC_APP_NOT_ENROLLED);

	/*
	**	Next set up the Registry Key and Registry Item. Return immediately if
	**	a resource failure occurs.
	*/
	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if (NULL == registry_key_data || GCC_NO_ERROR != rc)
	{
	    ERROR_OUT(("CRegistry::RegisterChannel: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryRegisterChannelRequest(registry_key_data, channel_id, entity_id);

		//	The registry key data object is no longer needed here
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	/*
	**	First check to see if the registry entry exists and if it 
	**	does check the ownership to make sure this node has 
	**	permission to change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		//	Entry already exists, send back negative result
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_REGISTER_CHANNEL_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								GCC_RESULT_ENTRY_ALREADY_EXISTS);

		//	The registry key data object is no longer needed
		registry_key_data->Release();
		rc = GCC_NO_ERROR;
		goto MyExit;
	}

	//	Set up the registry item here
	registry_item.item_type = GCC_REGISTRY_CHANNEL_ID;
	registry_item.channel_id = channel_id;

	DBG_SAVE_FILE_LINE
	registry_item_data = new CRegItem(&registry_item, &rc);
	if (registry_item_data == NULL || GCC_NO_ERROR != rc)
	{
	    ERROR_OUT(("CRegistry::RegisterChannel: can't create regitry item"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Since entry does not exists create it here
	DBG_SAVE_FILE_LINE
	registry_entry = new REG_ENTRY;
	if (registry_entry == NULL)
	{
	    ERROR_OUT(("CRegistry::RegisterChannel: can't create regitry entry"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Fill in the new entry
	registry_entry->registry_key = registry_key_data;
	registry_entry->entry_item = registry_item_data;
	registry_entry->monitoring_state = OFF;
	registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
	registry_entry->entity_id = entity_id;

	/*
	**	Initialize to public incase entry is switched to
	**	a parameter.  Note that as long as the entry is
	**	not a PARAMETER modification rights will not be
	**	used.
	*/
	registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;

	//	Add registry entry to registry list
	m_RegEntryList.Append(registry_entry);

	//	Send success for the result
	requester_sap->RegistryConfirm (
						m_nConfID,
						GCC_REGISTER_CHANNEL_CONFIRM,
						registry_entry->registry_key,
						registry_entry->entry_item,
						registry_entry->modification_rights,
						registry_entry->owner_id,
						registry_entry->entity_id,
						FALSE,
						GCC_RESULT_SUCCESSFUL);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (NULL != registry_key_data)
        {
            registry_key_data->Release();
        }
        if (NULL != registry_item_data)
        {
            registry_item_data->Release();
        }
        delete registry_entry;
    }

	return (rc);
}

/*
 *	GCCError	AssignToken ()
 *
 *	Public Function Description
 *		This routine is responsible for generating and registering a new token.
 *		It has two different paths of execution based on whether this is
 *		a Top Provider registry or a subordinate node registry object.
 */
GCCError	CRegistry::AssignToken (
										PGCCRegistryKey		registry_key,
										EntityID			entity_id )
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry = NULL; // a must
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CRegItem            *registry_item_data = NULL; // a must
	GCCRegistryItem		registry_item;
	CAppSap              *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
		return (GCC_APP_NOT_ENROLLED);

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::AssignToken: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryAssignTokenRequest(registry_key_data, entity_id);

		//	The registry key data object is no longer needed here
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	/*
	**	First check to see if the registry entry exists and if it 
	**	does check the ownership to make sure this node has 
	**	permission to change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		//	Entry already exists, send back negative result
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_ASSIGN_TOKEN_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								GCC_RESULT_ENTRY_ALREADY_EXISTS);

		//	The registry key data object is no longer needed
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

	//	Set up the registry item here
	registry_item.item_type = GCC_REGISTRY_TOKEN_ID;
	registry_item.token_id = GetUnusedToken();

	DBG_SAVE_FILE_LINE
	registry_item_data = new CRegItem(&registry_item, &rc);
	if ((registry_item_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::AssignToken: can't create regitry item"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	DBG_SAVE_FILE_LINE
	registry_entry = new REG_ENTRY;
	if (registry_entry == NULL)
	{
	    ERROR_OUT(("CRegistry::AssignToken: can't create regitry entry"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Fill in the new entry
	registry_entry->registry_key = registry_key_data;
	registry_entry->entry_item = registry_item_data;
	registry_entry->monitoring_state = OFF;
	registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
	registry_entry->entity_id = entity_id;

	/*
	**	Initialize to public incase entry is switched to
	**	a parameter.  Note that as long as the entry is
	**	not a PARAMETER modification rights will not be
	**	used.
	*/
	registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;

	//	Add registry entry to registry list
	m_RegEntryList.Append(registry_entry);

	//	Send success for the result
	requester_sap->RegistryConfirm (
						m_nConfID,
						GCC_ASSIGN_TOKEN_CONFIRM,
						registry_entry->registry_key,
						registry_entry->entry_item,
             			registry_entry->modification_rights,
						registry_entry->owner_id,
						registry_entry->entity_id,
						FALSE,
						GCC_RESULT_SUCCESSFUL);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (NULL != registry_key_data)
        {
            registry_key_data->Release();
        }
        if (NULL != registry_item_data)
        {
            registry_item_data->Release();
        }
        delete registry_entry;
    }

	return (rc);
}

/*
 *	GCCError	SetParameter ()
 *
 *	Public Function Description
 *		This routine is responsible for generating and registering a new token.
 *		It has two different paths of execution based on whether this is
 *		a Top Provider registry or a subordinate node registry object.
 */
GCCError	CRegistry::SetParameter (
								PGCCRegistryKey			registry_key,
								LPOSTR			        parameter_value,
								GCCModificationRights	modification_rights,
								EntityID				entity_id )
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry = NULL; // a must
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CRegItem            *registry_item_data = NULL; // a must
	GCCResult			result;
	GCCRegistryItem		registry_item;
	BOOL    			application_is_enrolled = FALSE;
	CAppSap              *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
		return (GCC_APP_NOT_ENROLLED);

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::SetParameter: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistrySetParameterRequest(registry_key_data,
												parameter_value,
												modification_rights,
												entity_id);

		//	The registry key data object is no longer needed here
		registry_key_data->Release();
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	//	Set up the registry item here
	if (parameter_value != NULL)
	{
		registry_item.item_type = GCC_REGISTRY_PARAMETER;
		registry_item.parameter = *parameter_value;
	}
	else
	{
		registry_item.item_type = GCC_REGISTRY_NONE;
	}

	DBG_SAVE_FILE_LINE
	registry_item_data = new CRegItem(&registry_item, &rc);
	if ((registry_item_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::SetParameter: can't create regitry item"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	/*
	**	First check to see if the registry entry exists and if it 
	**	does check the ownership and modification rights to make 
	**	sure this node has permission to change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		/*
		**	Here we make sure that this request is comming from an 
		**	APE that previously enrolled.  
		*/
		CAppRosterMgr				*lpAppRosterMgr;

		m_pAppRosterMgrList->Reset();
		while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
		{
			if (lpAppRosterMgr->IsAPEEnrolled(registry_key_data->GetSessionKey(),
								            m_pMCSUserObject->GetMyNodeID(),
								            entity_id))
			{
				application_is_enrolled = TRUE;
				break;
			}
		}

		/*
		**	Check ownership rights here: First check is to make
		**	sure that this is the owner if Owner rights is 
		**	specified.  Next check is to make sure that
		*/ 
		if (((registry_entry->modification_rights == GCC_OWNER_RIGHTS) && 
			(registry_entry->owner_id == m_pMCSUserObject->GetMyNodeID()) &&
			 (registry_entry->entity_id == entity_id)) ||
			((registry_entry->modification_rights == GCC_SESSION_RIGHTS) && 
			(application_is_enrolled)) ||
			(registry_entry->modification_rights == GCC_PUBLIC_RIGHTS) ||
			(registry_entry->owner_id == 0))
		{
			/*
			**	Monitoring state should not be affected by 
			**	this request.
			*/
			*registry_entry->entry_item = *registry_item_data;
			
			/*
			**	Only the owner is allowed to change the modification
			**	rights of a registry entry (unless the entry is
			**	unowned). Also if there is no owner, we set up the
			**	new owner here.
			*/
			if (((registry_entry->owner_id == m_pMCSUserObject->GetMyNodeID()) &&
				(registry_entry->entity_id == entity_id)) ||
				(registry_entry->owner_id == 0))
			{
				registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
				registry_entry->entity_id = entity_id;
				/*
				**	If no modification rights are specified we must
				**	set the modification rights to be public.
				*/
				if (modification_rights != GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
				{
					registry_entry->modification_rights = modification_rights;
				}
			}

			//	Send Monitor Indication if necessary
			if (registry_entry->monitoring_state == ON)
			{
				/*
				**	Deliver the monitor indication to the Top
				**	Provider's Node Controller if necessary.
				*/
				SendMonitorEntryIndicationMessage(registry_entry);

				/*
				**	Broadcast a monitor entry indication to all
				**	nodes in the conference.
				*/
				m_pMCSUserObject->RegistryMonitorEntryIndication(
						registry_entry->registry_key,
						registry_entry->entry_item,
						registry_entry->owner_id,
						registry_entry->entity_id,
						registry_entry->modification_rights);
			}

			//	Send success for the result
			result = GCC_RESULT_SUCCESSFUL;
		}
		else
		{
			result = GCC_RESULT_INDEX_ALREADY_OWNED;
		}

		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_SET_PARAMETER_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
                     			registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								result);

		//	The registry key data object is no longer needed
		registry_key_data->Release();

		//	The registry item data object is no longer needed
		registry_item_data->Release();

		rc = GCC_NO_ERROR;
		goto MyExit;
	}

    // registry entry does not exist, create one.
	DBG_SAVE_FILE_LINE
	registry_entry = new REG_ENTRY;
	if (registry_entry == NULL)
	{
	    ERROR_OUT(("CRegistry::SetParameter: can't create regitry entry"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	//	Fill in the new entry
	registry_entry->registry_key = registry_key_data;
	registry_entry->entry_item = registry_item_data;
	registry_entry->monitoring_state = OFF;
	registry_entry->owner_id = m_pMCSUserObject->GetMyNodeID();
	registry_entry->entity_id = entity_id;

	/*
	**	If no modification rights are specified we must
	**	initialize the modification rights to be public.
	**	Note that modification rights are only specified
	**	for the SetParameter call.
	*/
	registry_entry->modification_rights =
	        (modification_rights == GCC_NO_MODIFICATION_RIGHTS_SPECIFIED) ?
                GCC_PUBLIC_RIGHTS :
				modification_rights;

	//	Add registry entry to registry list
	m_RegEntryList.Append(registry_entry);

	//	Send success for the result
	requester_sap->RegistryConfirm(
						m_nConfID,
						GCC_SET_PARAMETER_CONFIRM,
						registry_entry->registry_key,
						registry_entry->entry_item,
             			registry_entry->modification_rights,
						registry_entry->owner_id,
						registry_entry->entity_id,
						FALSE,
						GCC_RESULT_SUCCESSFUL);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if (NULL != registry_key_data)
        {
            registry_key_data->Release();
        }
        if (NULL != registry_item_data)
        {
            registry_item_data->Release();
        }
        delete registry_entry;
    }

	return (rc);
}

/*
 *	GCCError	RetrieveEntry ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to obtain an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError	CRegistry::RetrieveEntry (
										PGCCRegistryKey		registry_key,
										EntityID			entity_id )
{
	GCCError					rc;
	REG_ENTRY                   *registry_entry;
	CRegKeyContainer       		*registry_key_data = NULL; // a must
	CAppSap                     *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
	}

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::RetrieveEntry: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryRetrieveEntryRequest(registry_key_data, entity_id);
		rc = GCC_NO_ERROR;
		goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		//	Send back a positive result with the entry item
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_RETRIEVE_ENTRY_CONFIRM,
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->modification_rights,
								registry_entry->owner_id,
								registry_entry->entity_id,
								FALSE,
								GCC_RESULT_SUCCESSFUL);
	}
	else
	{
		//	Send back a negative result
		requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_RETRIEVE_ENTRY_CONFIRM,
								registry_key_data,
								m_pEmptyRegItem,
								GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,	//	No owner id
								0,	//	No entity id
								FALSE,
								GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}

    rc = GCC_NO_ERROR;

MyExit:

    if (NULL != registry_key_data)
    {
        registry_key_data->Release();
    }

	return (rc);
}

/*
 *	GCCError	DeleteEntry ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to delete an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError	CRegistry::DeleteEntry (
										PGCCRegistryKey		registry_key,
										EntityID			entity_id )
{
	GCCError			rc;
	REG_ENTRY           *registry_entry;
	CRegKeyContainer    *registry_key_data = NULL; // a must
	CAppSap             *requester_sap;

	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
	}

	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data == NULL) || (rc != GCC_NO_ERROR))
	{
	    ERROR_OUT(("CRegistry::DeleteEntry: can't create regitry key"));
		rc = GCC_ALLOCATION_FAILURE;
	    goto MyExit;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryDeleteEntryRequest(registry_key_data, entity_id);
        rc = GCC_NO_ERROR;
        goto MyExit;
	}

    // no PDU is sent when request occurs at the top provider

	/*
	**	First check to see if the registry entry exists and if it does
	**	check the ownership to make sure this node has permission to
	**	change the entry.
	*/
	registry_entry = GetRegistryEntry(registry_key_data);
	if (registry_entry != NULL)
	{
		if (((registry_entry->owner_id == m_pMCSUserObject->GetMyNodeID()) &&
			 (registry_entry->entity_id == entity_id)) ||
			(registry_entry->owner_id == 0))
		{
			/*
			**	First convert this to a non-entry incase it needs to
			**	be included in a monitor indication. We first delete
			**	the old entry item and replace it with an Emtpy item.
			*/
			registry_entry->entry_item->Release();
			registry_entry->entry_item = m_pEmptyRegItem;

			registry_entry->owner_id = 0;
			registry_entry->entity_id = 0;
			registry_entry->modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;

			//	Send Monitor Indication if necessary
			if (registry_entry->monitoring_state == ON)
			{
				/*
				**	Deliver the monitor indication to the Top
				**	Provider's Node Controller if necessary.
				*/
				SendMonitorEntryIndicationMessage(registry_entry);

				/*
				**	Broadcast a monitor entry indication to all
				**	nodes in the conference.
				*/
				m_pMCSUserObject->RegistryMonitorEntryIndication(
							registry_entry->registry_key,
							registry_entry->entry_item,
							registry_entry->owner_id,
							registry_entry->entity_id,
							registry_entry->modification_rights);
			}

			m_RegEntryList.Remove(registry_entry);

			if (NULL != registry_entry->registry_key)
			{
			    registry_entry->registry_key->Release();
			}
			delete registry_entry;

			//	Send success for the result
			requester_sap->RegistryConfirm(
								m_nConfID,
								GCC_DELETE_ENTRY_CONFIRM,
								registry_key_data,
								NULL,
								GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
								FALSE,
								GCC_RESULT_SUCCESSFUL);
		}
		else
		{
			//	No ownership rights send back negative result
			requester_sap->RegistryConfirm (
									m_nConfID,
									GCC_DELETE_ENTRY_CONFIRM,
									registry_entry->registry_key,
									registry_entry->entry_item,
									registry_entry->modification_rights,
									registry_entry->owner_id,
									registry_entry->entity_id,
									FALSE,
									GCC_RESULT_INDEX_ALREADY_OWNED);
		}
	}
	else
	{
		//	Send failure for the result. Entry does not exist
		requester_sap->RegistryConfirm (
								m_nConfID,
								GCC_DELETE_ENTRY_CONFIRM,
								registry_key_data,
								NULL,
								GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
								FALSE,
								GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}

    rc = GCC_NO_ERROR;

MyExit:

	//	The registry key data object is no longer needed here
	if (NULL != registry_key_data)
	{
	    registry_key_data->Release();
	}

	return (rc);
}

/*
 *	GCCError	MonitorRequest ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to monitor an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError	CRegistry::MonitorRequest (
							PGCCRegistryKey			registry_key,
							BOOL    				enable_delivery,
							EntityID				entity_id )
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry;
	CRegKeyContainer    *registry_key_data;
	GCCResult			result = GCC_RESULT_SUCCESSFUL;
	CAppSap	            *requester_sap;
    BOOL                fToConfirm = FALSE;

	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
    }

	/*
	**	First set up the Registry Key. Return immediately if a resource 
	**	failure occurs.
	*/
	DBG_SAVE_FILE_LINE
	registry_key_data = new CRegKeyContainer(registry_key, &rc);
	if ((registry_key_data != NULL) && (rc == GCC_NO_ERROR))
	{
		/*
		**	If the request is recieved at a node that is not the top 
		**	provider we must send the request on to the top provider.
		*/
		if (m_fTopProvider == FALSE)
		{
			if (enable_delivery)
			{
				/*
				**	Here we first go ahead and add the requesting APE to the
				**	list of applications wishing to monitor this particular 
				**	entry.  Note that if this entry does not exists at the top 
				**	provider, this entry will be removed during the confirm.
				*/
				rc = AddAPEToMonitoringList(registry_key_data, entity_id, requester_sap);
				if (rc == GCC_NO_ERROR)
				{
					/*
					**	Wait for the response before sending the confirm
					**	if we get this far.
					*/
					m_pMCSUserObject->RegistryMonitorRequest(registry_key_data, entity_id);
				}
				else
				{
					result = GCC_RESULT_RESOURCES_UNAVAILABLE;
					fToConfirm = TRUE;
				}
			}
			else
			{
				RemoveAPEFromMonitoringList(registry_key_data, entity_id);
                result = GCC_RESULT_SUCCESSFUL;
				fToConfirm = TRUE;
			}
		}
		else	//	No PDU is sent when request occurs at the top provider
		{
			if (enable_delivery)
			{
				/*
				**	First check to see if the registry entry exists.  If it does
				**	not we go ahead and create an empty entry so that we can
				**	add the monitoring APE to that entries list of monitoring 
				**	APEs.
				*/
				registry_entry = GetRegistryEntry(registry_key_data);
				if (registry_entry != NULL)
				{
					/*
					**	Here we go ahead and add the requesting APE to the
					**	list of applications wishing to monitor this entry.
					*/
					rc = AddAPEToMonitoringList(registry_key_data, entity_id, requester_sap);
					if (rc == GCC_NO_ERROR)
					{
						//	Set the monitoring state to ON
						registry_entry->monitoring_state = ON;
					}
					else
                    {
						result = GCC_RESULT_RESOURCES_UNAVAILABLE;
                    }
				}
				else
                {
					result = GCC_RESULT_ENTRY_DOES_NOT_EXIST;
                }
			}
			else
			{
				RemoveAPEFromMonitoringList(registry_key_data, entity_id);
			}
			fToConfirm = TRUE;
		}
	}
	else
    {
        ERROR_OUT(("CRegistry::MonitorRequest: can't create registry key"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    if (fToConfirm)
    {
        ASSERT(NULL != registry_key_data);
        requester_sap->RegistryConfirm(
                            m_nConfID,
                            GCC_MONITOR_CONFIRM,
                            registry_key_data,
                            NULL,
                            GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
                            0,
                            0,
                            enable_delivery,
                            result);
    }

	//	The registry key data object is no longer needed
    if (NULL != registry_key_data)
    {
        registry_key_data->Release();
    }

    return (rc);
}

/*
 *	GCCError	AllocateHandleRequest ()
 *
 *	Public Function Description
 *		This routine is used by a local APE to allocate a specified number of
 *		handles from the application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 */
GCCError CRegistry::AllocateHandleRequest(
							UINT					number_of_handles,
							EntityID				entity_id )
{
	UINT				temp_registry_handle;
	CAppSap              *requester_sap;
	
	if (NULL == (requester_sap = m_AppSapEidList2.Find(entity_id)))
	{
		return GCC_APP_NOT_ENROLLED;
	}

	if (m_fTopProvider == FALSE)
	{
		m_pMCSUserObject->RegistryAllocateHandleRequest(number_of_handles, entity_id);
	}
	else	//	No PDU is sent when request occurs at the top provider
	{
	    UINT nFirstHandle = 0;
	    GCCResult nResult;
		if ((number_of_handles > 0) &&
			(number_of_handles <= MAXIMUM_ALLOWABLE_ALLOCATED_HANDLES))
		{
			temp_registry_handle = m_nRegHandle + number_of_handles;
			if (temp_registry_handle > m_nRegHandle)
			{
			    nFirstHandle = m_nRegHandle;
			    nResult = GCC_RESULT_SUCCESSFUL;

				m_nRegHandle = temp_registry_handle;
			}
			else
			{
			    ASSERT(0 == nFirstHandle);
			    nResult = GCC_RESULT_NO_HANDLES_AVAILABLE;
			}
		}
		else
		{
		    ASSERT(0 == nFirstHandle);
		    nResult = GCC_RESULT_INVALID_NUMBER_OF_HANDLES;
		}

		requester_sap->RegistryAllocateHandleConfirm (
								m_nConfID,
								number_of_handles,
								nFirstHandle,
								nResult);
	}

	return (GCC_NO_ERROR);
}

/*
 *	GCCError	ProcessRegisterChannelPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register channel PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 */
GCCError	CRegistry::ProcessRegisterChannelPDU (
									CRegKeyContainer    *registry_key_data,
									ChannelID			channel_id,
									UserID				requester_node_id,
									EntityID			requester_entity_id )
{
	GCCError					rc = GCC_NO_ERROR;
	REG_ENTRY                   *registry_entry;
	CRegItem                    *registry_item_data;
	GCCRegistryItem				registry_item;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;
	
	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}

	if (application_is_enrolled)
	{
		/*
		**	Next check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		if (registry_entry != NULL)
		{
			//	Entry already exists, send back negative result
			m_pMCSUserObject->RegistryResponse(
								  	REGISTER_CHANNEL,	
									requester_node_id,
									requester_entity_id,
								   	registry_key_data,
								   	registry_entry->entry_item,
								   	registry_entry->modification_rights,
									registry_entry->owner_id,
									registry_entry->entity_id,
							    	GCC_RESULT_ENTRY_ALREADY_EXISTS);
		}
		else
		{
			registry_item.item_type = GCC_REGISTRY_CHANNEL_ID;
			registry_item.channel_id = channel_id;

			DBG_SAVE_FILE_LINE
			registry_item_data = new CRegItem(&registry_item, &rc);
			if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
			{
				DBG_SAVE_FILE_LINE
				registry_entry = new REG_ENTRY;
				if (registry_entry != NULL)
				{
					//	Fill in the new entry
					DBG_SAVE_FILE_LINE
					registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
					if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
					{
						registry_entry->entry_item = registry_item_data;
						registry_entry->monitoring_state = OFF;
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;
					
						/*
						**	Initialize to public incase entry is switched to
						**	a parameter.  Note that as long as the entry is
						**	not a PARAMETER modification rights will not be
						**	used.
						*/
						registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;
					
						m_RegEntryList.Append(registry_entry);
					
						//	Send success for the result
						m_pMCSUserObject->RegistryResponse(
											REGISTER_CHANNEL,	
											requester_node_id,
											requester_entity_id,
										   	registry_entry->registry_key,
										   	registry_entry->entry_item,
										   	registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									    	GCC_RESULT_SUCCESSFUL);
					}
					else if (registry_entry->registry_key == NULL)
					{
						delete registry_entry;
						registry_item_data->Release();
						rc = GCC_ALLOCATION_FAILURE;
					}
					else
					{
						registry_entry->registry_key->Release();
						delete registry_entry;
						registry_item_data->Release();
					}
				}
				else
                {
					rc = GCC_ALLOCATION_FAILURE;
                }
			}
			else if (registry_item_data == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
			else
            {
				registry_item_data->Release();
            }
		}
	}
	else
	{
		//	Send back negative result stating invalid requester
		m_pMCSUserObject->RegistryResponse(
								REGISTER_CHANNEL,	
								requester_node_id,
								requester_entity_id,
						   		registry_key_data,
						   		NULL,
						   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
					    		GCC_RESULT_INVALID_REQUESTER);
	}

	return (rc);
}

/*
 *	GCCError	ProcessAssignTokenPDU ()			    
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register token PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 */
GCCError	CRegistry::ProcessAssignTokenPDU (
									CRegKeyContainer    *registry_key_data,
									UserID				requester_node_id,
									EntityID			requester_entity_id )
{
	GCCError					rc = GCC_NO_ERROR;
	REG_ENTRY                   *registry_entry;
	CRegItem                    *registry_item_data;
	GCCRegistryItem				registry_item;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;

	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}
	
	if (application_is_enrolled)
	{
		/*
		**	First check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		if (registry_entry != NULL)
		{
			//	Entry already exists, send back negative result
			m_pMCSUserObject->RegistryResponse(ASSIGN_TOKEN,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
											registry_entry->entry_item,
									   		registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									  		GCC_RESULT_ENTRY_ALREADY_EXISTS);
		}
		else
		{
			DBG_SAVE_FILE_LINE
			registry_entry = new REG_ENTRY;
			if (registry_entry != NULL)
			{
				registry_item.item_type = GCC_REGISTRY_TOKEN_ID;
				registry_item.token_id = GetUnusedToken();

				DBG_SAVE_FILE_LINE
				registry_item_data = new CRegItem(&registry_item, &rc);
				if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
				{
					//	Fill in the new entry
					DBG_SAVE_FILE_LINE
					registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
					if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
					{
						registry_entry->entry_item = registry_item_data;
						registry_entry->monitoring_state = OFF;
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;
					
						/*
						**	Initialize to public incase entry is switched to
						**	a parameter.  Note that as long as the entry is
						**	not a PARAMETER modification rights will not be
						**	used.
						*/
						registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;
					
						//	Add registry entry to registry list
						m_RegEntryList.Append(registry_entry);
						
						//	Send success for the result
						m_pMCSUserObject->RegistryResponse(
											ASSIGN_TOKEN,
											requester_node_id,
											requester_entity_id,
									   		registry_key_data,
									   		registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
								    		GCC_RESULT_SUCCESSFUL);
					}
					else  if (registry_entry->registry_key == NULL)
					{
						registry_item_data->Release();
						delete registry_entry;
						rc = GCC_ALLOCATION_FAILURE;
					}
					else
					{
						registry_entry->registry_key->Release();
						registry_item_data->Release();
						delete registry_entry;
					}
				}
				else
				{
					if (registry_item_data == NULL)
                    {
						rc = GCC_ALLOCATION_FAILURE;
                    }
					else
                    {
						registry_item_data->Release();
                    }
						
					delete registry_entry;
				}
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}
	}
	else
	{
		m_pMCSUserObject->RegistryResponse(
								ASSIGN_TOKEN,	
								requester_node_id,
								requester_entity_id,
						   		registry_key_data,
						   		NULL,
						   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
					    		GCC_RESULT_INVALID_REQUESTER);
	}
	
	return (rc);
}

/*
 *	GCCError	ProcessSetParameterPDU ()			    
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register parameter PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 */
GCCError	CRegistry::ProcessSetParameterPDU (
								CRegKeyContainer        *registry_key_data,
								LPOSTR                  parameter_value,
								GCCModificationRights	modification_rights,
								UserID					requester_node_id,
								EntityID				requester_entity_id )
{
	GCCError					rc = GCC_NO_ERROR;
	REG_ENTRY                   *registry_entry;
	CRegItem                    *registry_item_data;
	GCCResult					result;
	GCCRegistryItem				registry_item;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;
	
	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}
	
	if (application_is_enrolled)
	{
		//	Set up the registry item 
		if (parameter_value != NULL)
		{
			registry_item.item_type = GCC_REGISTRY_PARAMETER;
			registry_item.parameter = *parameter_value;
		}
		else
			registry_item.item_type = GCC_REGISTRY_NONE;
			
		/*
		**	Check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		
		if (registry_entry != NULL)
		{
			/*
			**	Here we make sure that this request is comming from an 
			**	APE that previously enrolled in the appropriate session.  
			*/
			m_pAppRosterMgrList->Reset();
			while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
			{
				if (lpAppRosterMgr->IsAPEEnrolled (registry_key_data->GetSessionKey (),
													requester_node_id,
													requester_entity_id))
				{
					application_is_enrolled = TRUE;
					break;
				}
			}

			/*
			**	Check ownership rights here: First check is to make
			**	sure that this is the owner if Owner rights is 
			**	specified.  Next check is to make sure that
			*/ 
			if (((registry_entry->modification_rights == GCC_OWNER_RIGHTS) && 
					(registry_entry->owner_id == requester_node_id) &&
				 	(registry_entry->entity_id == requester_entity_id)) ||
				((registry_entry->modification_rights == GCC_SESSION_RIGHTS) && 
					(application_is_enrolled)) ||
				(registry_entry->modification_rights == GCC_PUBLIC_RIGHTS) ||
				(registry_entry->owner_id == 0))
			{
				DBG_SAVE_FILE_LINE
				registry_item_data = new CRegItem(&registry_item, &rc);
				if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
				{
					//	Monitoring state should not be affected by this request
					*registry_entry->entry_item = *registry_item_data;

					/*
					**	Only the owner is allowed to change the modification
					**	rights of a registry entry (unless the entry is
					**	unowned). Also if there is no owner, we set up the
					**	new owner here.
					*/
					if (((registry_entry->owner_id == requester_node_id) &&
						(registry_entry->entity_id == requester_entity_id)) ||
						(registry_entry->owner_id == 0))
					{
						/*
						**	This will take care of setting up the new owner if 
						**	one exists.
						*/
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;

						/*
						**	If no modification rights are specified we must
						**	set the modification rights to be public.
						*/
						if (modification_rights != 
									GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
						{
							registry_entry->modification_rights = modification_rights;
						}
					}

					//	Send Monitor Indication if necessary
					if (registry_entry->monitoring_state == ON)
					{
						/*
						**	Deliver the monitor indication to the Top
						**	Provider's Node Controller if necessary.
						*/
						SendMonitorEntryIndicationMessage(registry_entry);
						
						/*
						**	Broadcast a monitor entry indication to all
						**	nodes in the conference.
						*/
						m_pMCSUserObject->RegistryMonitorEntryIndication(
								registry_entry->registry_key,
								registry_entry->entry_item,
								registry_entry->owner_id,
								registry_entry->entity_id,
								registry_entry->modification_rights);
					}

    			    registry_item_data->Release();

					//	Send success for the result
					result = GCC_RESULT_SUCCESSFUL;
				}
				else if (registry_item_data == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
					result = GCC_RESULT_RESOURCES_UNAVAILABLE;
				}
				else
				{
					registry_item_data->Release();
					result = GCC_RESULT_RESOURCES_UNAVAILABLE;
				}
			}
			else
				result = GCC_RESULT_INDEX_ALREADY_OWNED;

			//	No ownership rights send back negative result
			m_pMCSUserObject->RegistryResponse(SET_PARAMETER,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
											registry_entry->entry_item,
									   		registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									  		result);
		}
		else
		{
			DBG_SAVE_FILE_LINE
			registry_entry = new REG_ENTRY;
			if (registry_entry != NULL)
			{
				DBG_SAVE_FILE_LINE
				registry_item_data = new CRegItem(&registry_item, &rc);
				if ((registry_item_data != NULL) && (rc == GCC_NO_ERROR))
				{
					//	Fill in the new entry
					DBG_SAVE_FILE_LINE
					registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
					if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
					{
						registry_entry->entry_item = registry_item_data;
						registry_entry->monitoring_state = OFF;
						registry_entry->owner_id = requester_node_id;
						registry_entry->entity_id = requester_entity_id;

						/*
						**	If no modification rights are specified we must
						**	initialize the modification rights to be public.
						**	Note that modification rights are only specified
						**	for the SetParameter call.
						*/
						if (modification_rights == GCC_NO_MODIFICATION_RIGHTS_SPECIFIED)
						{
							registry_entry->modification_rights = GCC_PUBLIC_RIGHTS;
						}
						else
						{
							registry_entry->modification_rights = modification_rights;
						}

						//	Add registry entry to registry list
						m_RegEntryList.Append(registry_entry);

						//	Send success for the result
						m_pMCSUserObject->RegistryResponse(
											SET_PARAMETER,
											requester_node_id,
											requester_entity_id,
									   		registry_key_data,
									   		registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
								    		GCC_RESULT_SUCCESSFUL);
					}
					else  if (registry_entry->registry_key == NULL)
					{
						registry_item_data->Release();
						delete registry_entry;
						rc = GCC_ALLOCATION_FAILURE;
					}
					else
					{
						registry_entry->registry_key->Release();
						registry_item_data->Release();
						delete registry_entry;
					}
				}
				else if (registry_item_data == NULL)
				{
					delete registry_entry;
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}
	}
	else
	{
		m_pMCSUserObject->RegistryResponse(
								SET_PARAMETER,	
								requester_node_id,
								requester_entity_id,
						   		registry_key_data,
						   		NULL,
						   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
								0,
								0,
					    		GCC_RESULT_INVALID_REQUESTER);
	}
	
	return (rc);
}

/*
 *	void	ProcessRetrieveEntryPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to retrieve a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 */
void	CRegistry::ProcessRetrieveEntryPDU (
										CRegKeyContainer    *registry_key_data,
										UserID				requester_node_id,
										EntityID			requester_entity_id)
{
	REG_ENTRY   *registry_entry;

	registry_entry = GetRegistryEntry (	registry_key_data );

	if (registry_entry != NULL)
	{
		//	Send back a positive result with the entry item
		m_pMCSUserObject->RegistryResponse(RETRIEVE_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
									   	registry_entry->entry_item,
					   					registry_entry->modification_rights,
										registry_entry->owner_id,
										registry_entry->entity_id,
								    	GCC_RESULT_SUCCESSFUL);
	}
	else
	{
		//	Send back a negative result
		m_pMCSUserObject->RegistryResponse(RETRIEVE_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
										m_pEmptyRegItem,
										GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
										0,
										0,
										GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}
}

/*
 *	void	ProcessDeleteEntryPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to delete a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 */
void	CRegistry::ProcessDeleteEntryPDU (
										CRegKeyContainer    *registry_key_data,
										UserID				requester_node_id,
										EntityID			requester_entity_id)
{
	REG_ENTRY                   *registry_entry;
	BOOL    					application_is_enrolled = FALSE;
	CAppRosterMgr				*lpAppRosterMgr;

	/*
	**	We first make sure that this request is comming from an APE that
	**	previously enrolled.  Here we are not worried about a specific
	**	session, only that the APE is enrolled.  
	*/
	m_pAppRosterMgrList->Reset();
	while (NULL != (lpAppRosterMgr = m_pAppRosterMgrList->Iterate()))
	{
		if (lpAppRosterMgr->IsAPEEnrolled (requester_node_id, requester_entity_id))
		{
			application_is_enrolled = TRUE;
			break;
		}
	}

	if (application_is_enrolled)
	{
		/*
		**	First check to see if the registry entry exists and if it does
		**	check the ownership to make sure this node has permission to
		**	change the entry.
		*/
		registry_entry = GetRegistryEntry (	registry_key_data );
		if (registry_entry != NULL)
		{
			if (((registry_entry->owner_id == requester_node_id) &&
				 (registry_entry->entity_id == requester_entity_id)) ||
				(registry_entry->owner_id == NULL))
			{
				m_pMCSUserObject->RegistryResponse(
											DELETE_ENTRY,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
										   	registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									    	GCC_RESULT_SUCCESSFUL);

				/*
				**	First convert this to a non-entry incase it needs to
				**	be included in a monitor indication. We first delete
				**	the old entry item and replace it with an Emtpy item.
				*/
				if (NULL != registry_entry->entry_item)
				{
				    registry_entry->entry_item->Release();
				}
				registry_entry->entry_item = m_pEmptyRegItem;

				registry_entry->owner_id = 0;
				registry_entry->entity_id = 0;
				registry_entry->modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;

				//	Send Monitor Indication if necessary
				if (registry_entry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage(registry_entry);
					
					/*
					**	Broadcast a monitor entry indication to all
					**	nodes in the conference.
					*/
					m_pMCSUserObject->RegistryMonitorEntryIndication(
									registry_entry->registry_key,
									registry_entry->entry_item,
									registry_entry->owner_id,
									registry_entry->entity_id,
									registry_entry->modification_rights);
				}
			
				//	Remove the entry from the list
				m_RegEntryList.Remove(registry_entry);

				if (NULL != registry_entry->registry_key)
				{
				    registry_entry->registry_key->Release();
				}
				delete registry_entry;
			}
			else
			{
				//	No ownership rights send back negative result
				m_pMCSUserObject->RegistryResponse(
											DELETE_ENTRY,
											requester_node_id,
											requester_entity_id,
										   	registry_key_data,
										   	registry_entry->entry_item,
						   					registry_entry->modification_rights,
											registry_entry->owner_id,
											registry_entry->entity_id,
									    	GCC_RESULT_INDEX_ALREADY_OWNED);
			}
		}
		else
		{
			//	Send failure for the result. Entry does not exist
			m_pMCSUserObject->RegistryResponse(
										DELETE_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
										m_pEmptyRegItem,
										GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
										0,
										0,
										GCC_RESULT_ENTRY_DOES_NOT_EXIST);
		}
	}
	else
	{
		m_pMCSUserObject->RegistryResponse(
									DELETE_ENTRY,	
									requester_node_id,
									requester_entity_id,
							   		registry_key_data,
							   		NULL,
							   		GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
									0,
									0,
						    		GCC_RESULT_INVALID_REQUESTER);
	}
}

/*
 *	void	ProcessMonitorEntryPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to monitor a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 */
void	CRegistry::ProcessMonitorEntryPDU (
							CRegKeyContainer        *registry_key_data,
							UserID					requester_node_id,
							EntityID				requester_entity_id )
{
	REG_ENTRY   *registry_entry;

	/*
	**	First check to see if the registry entry exists and if it does
	**	check the ownership to make sure this node has permission to
	**	change the entry.
	*/
	registry_entry = GetRegistryEntry (	registry_key_data );
	
	if (registry_entry != NULL)
	{
		//	Set the monitoring state to on for the life of this entry.
		registry_entry->monitoring_state = ON;
	
		//	No ownership rights send back negative result
		m_pMCSUserObject->RegistryResponse(MONITOR_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
									   	registry_entry->entry_item,
					   					registry_entry->modification_rights,
										registry_entry->owner_id,
										registry_entry->entity_id,
								    	GCC_RESULT_SUCCESSFUL);
	}
	else
	{
		//	Send failure for the result. Entry does not exist
		m_pMCSUserObject->RegistryResponse(MONITOR_ENTRY,
										requester_node_id,
										requester_entity_id,
									   	registry_key_data,
										m_pEmptyRegItem,
										GCC_NO_MODIFICATION_RIGHTS_SPECIFIED,
										0,
										0,
										GCC_RESULT_ENTRY_DOES_NOT_EXIST);
	}
}

/*
 *	void	ProcessRegistryResponsePDU ()
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry responses from the top provider.  It is responsible for 
 *		generating any local messages associated with this response.
 */
void	CRegistry::ProcessRegistryResponsePDU (
							RegistryResponsePrimitiveType	primitive_type,
							CRegKeyContainer                *registry_key_data,
							CRegItem                        *registry_item_data,
							GCCModificationRights			modification_rights,
							EntityID						requester_entity_id,
							UserID							owner_node_id,
							EntityID						owner_entity_id,
							GCCResult						result)
{
	GCCError			error_value = GCC_NO_ERROR;
	GCCMessageType  	message_type;
	CAppSap             *pAppSap;

	//	Pop the next outstanding request off the queue
	if (NULL != (pAppSap = m_AppSapEidList2.Find(requester_entity_id)))
	{
		switch (primitive_type)
		{
			case REGISTER_CHANNEL:
				message_type = GCC_REGISTER_CHANNEL_CONFIRM;
				break;
				
			case ASSIGN_TOKEN:
				message_type = GCC_ASSIGN_TOKEN_CONFIRM;
				break;
				
			case SET_PARAMETER:
				message_type = GCC_SET_PARAMETER_CONFIRM;
				break;
		
			case RETRIEVE_ENTRY:
				message_type = GCC_RETRIEVE_ENTRY_CONFIRM;
				break;
				
			case DELETE_ENTRY:
				message_type = GCC_DELETE_ENTRY_CONFIRM;
				break;
				
			case MONITOR_ENTRY:
				message_type = GCC_MONITOR_CONFIRM;

				/*
				**	Here we must check the result.  If the result failed
				**	we pull the monitoring SAP from the monitor list.
				*/
				if (result != GCC_RESULT_SUCCESSFUL)
				{
					RemoveAPEFromMonitoringList (	registry_key_data,
													requester_entity_id);
				}
				break;

			default:
				error_value = GCC_INVALID_PARAMETER;
				ERROR_OUT(("CRegistry::ProcessRegistryResponsePDU: Bad request type, primitive_type=%d", (UINT) primitive_type));
				break;
		}
		
		if (error_value == GCC_NO_ERROR)
		{
			/*
			**	Note the the monitor enable variable is always set to TRUE
			**	when a monitor response is received from the Top Provider.
			**	Otherwise, this is not even used.
			*/
			pAppSap->RegistryConfirm(m_nConfID,
									message_type,
									registry_key_data,
									registry_item_data,
									modification_rights,
									owner_node_id,
									owner_entity_id,
									TRUE,
									result);
		}
	}
	else
	{
		WARNING_OUT(("CRegistry::ProcessRegistryResponsePDU: no such app sap"));
	}
}

/*
 *	void	ProcessMonitorIndicationPDU ()
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry monitor indications from the top provider.  It is 
 *		responsible for generating any local messages associated with this 
 *		response.
 */
void	CRegistry::ProcessMonitorIndicationPDU (
								CRegKeyContainer        *registry_key_data,
								CRegItem                *registry_item_data,
								GCCModificationRights	modification_rights,
								UserID					owner_node_id,
								EntityID				owner_entity_id)
{
	REG_ENTRY           *lpRegEntry;
	EntityID			eid;
	CAppSap             *pAppSap;

	m_RegEntryList.Reset();
	while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
	{
		if (*registry_key_data == *lpRegEntry->registry_key)
		{
			lpRegEntry->monitoring_list.Reset();
			while (GCC_INVALID_EID != (eid = lpRegEntry->monitoring_list.Iterate()))
			{
				if (NULL != (pAppSap = m_AppSapEidList2.Find(eid)))
				{
					pAppSap->RegistryMonitorIndication(m_nConfID,
														registry_key_data,
														registry_item_data,
														modification_rights,
														owner_node_id,
														owner_entity_id);
				}
			}
		}
	}
}

/*
 *	void	ProcessAllocateHandleRequestPDU ()
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to allocate a number of handles.  It is responsible for 
 *		returning any necessary responses that must be sent back to the 
 *		requesting node.
 */
void	CRegistry::ProcessAllocateHandleRequestPDU (
							UINT					number_of_handles,
							EntityID				requester_entity_id,
							UserID					requester_node_id)
{
	UINT		temp_registry_handle;

	if (m_fTopProvider)
	{
		if ((number_of_handles > 0) &&
			(number_of_handles <= MAXIMUM_ALLOWABLE_ALLOCATED_HANDLES))
		{
			temp_registry_handle = m_nRegHandle + number_of_handles;
			
			if (temp_registry_handle > m_nRegHandle)
			{
				m_pMCSUserObject->RegistryAllocateHandleResponse(
										number_of_handles,
										m_nRegHandle,
										requester_entity_id,
										requester_node_id,
										GCC_RESULT_SUCCESSFUL);
										
				m_nRegHandle = temp_registry_handle;
			}
			else
			{
				m_pMCSUserObject->RegistryAllocateHandleResponse(
										number_of_handles,
										0,
										requester_entity_id,
										requester_node_id,
										GCC_RESULT_NO_HANDLES_AVAILABLE);
			}
		}
		else
		{
			m_pMCSUserObject->RegistryAllocateHandleResponse(
										number_of_handles,
										0,
										requester_entity_id,
										requester_node_id,
										GCC_RESULT_INVALID_NUMBER_OF_HANDLES);
		}
	}
}

/*
 *	void	ProcessAllocateHandleResponsePDU ()
 *
 *	Public Function Description
 *		This routine is used by a node other than the top provider node to 
 *		process an allocate handle response.  It is responsible for generating 
 *		any local messages associated with this response.
 */
void	CRegistry::ProcessAllocateHandleResponsePDU (
							UINT					number_of_handles,
							UINT					first_handle,
							EntityID				eidRequester,
							GCCResult				result)
{
	CAppSap *pAppSap;

	if (NULL != (pAppSap = m_AppSapEidList2.Find(eidRequester)))
	{
		pAppSap->RegistryAllocateHandleConfirm(m_nConfID,
												number_of_handles,
												first_handle,
												result);
	}
}

/*
 *	void	RemoveNodeOwnership ()
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified node ID.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 */
void	CRegistry::RemoveNodeOwnership (
										UserID				node_id )
{
	if (m_fTopProvider)
	{
		REG_ENTRY   *lpRegEntry;

		m_RegEntryList.Reset();
		while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
		{
			if (lpRegEntry->owner_id == node_id)
			{
				lpRegEntry->owner_id = 0;
				lpRegEntry->entity_id = 0;
			
				//	Send Monitor Indication if necessary
				if (lpRegEntry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage (lpRegEntry);
				
					m_pMCSUserObject->RegistryMonitorEntryIndication(
							lpRegEntry->registry_key,
							lpRegEntry->entry_item,
							lpRegEntry->owner_id,
							lpRegEntry->entity_id,
							lpRegEntry->modification_rights);
				}
			}
		}
	}
}

/*
 *	void	RemoveEntityOwnership ()
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified APE.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 */
void	CRegistry::RemoveEntityOwnership (
										UserID				node_id,
										EntityID			entity_id )
{
	if (m_fTopProvider)
	{
		REG_ENTRY   *lpRegEntry;

		m_RegEntryList.Reset();
		while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
		{
			if ((lpRegEntry->owner_id == node_id) &&
				(lpRegEntry->entity_id == entity_id))
			{
				lpRegEntry->owner_id = 0;
				lpRegEntry->entity_id = 0;
			
				//	Send Monitor Indication if necessary
				if (lpRegEntry->monitoring_state == ON)
				{
					/*
					**	Deliver the monitor indication to the Top
					**	Provider's Node Controller if necessary.
					*/
					SendMonitorEntryIndicationMessage(lpRegEntry);
				
					m_pMCSUserObject->RegistryMonitorEntryIndication(
							lpRegEntry->registry_key,
							lpRegEntry->entry_item,
							lpRegEntry->owner_id,
							lpRegEntry->entity_id,
							lpRegEntry->modification_rights);
				}
			}
		}
	}
}

/*
 *	void	RemoveSessionKeyReference ()
 *
 *	Public Function Description
 *		This routine removes all registry entries associated with the
 *		specified session.  This is a local operation.
 */
void	CRegistry::RemoveSessionKeyReference(CSessKeyContainer *session_key)
{
	BOOL    		keys_match;
    CRegKeyContainer *registry_key_data;
	
	if (m_fTopProvider)
	{
		/*
		**	This outer loop is to handle resetting the rogue wave iterator.
		**	You can not delete a list entry while in the iterator with out
		**	resetting it.
		*/
		while (1)
		{
			REG_ENTRY   *lpRegEntry;

			keys_match = FALSE;
			m_RegEntryList.Reset();
			while (NULL != (lpRegEntry= m_RegEntryList.Iterate()))
			{
				registry_key_data = lpRegEntry->registry_key;

				if (registry_key_data->IsThisYourSessionKey (session_key))
					keys_match = TRUE;

				if (keys_match)
				{
					/*
					**	First convert this to a non-entry incase it needs to
					**	be included in a monitor indication. We first delete
					**	the old entry item and replace it with an Emtpy item.
					*/
					if (NULL != lpRegEntry->entry_item)
					{
					    lpRegEntry->entry_item->Release();
					}
					lpRegEntry->entry_item = m_pEmptyRegItem;
					lpRegEntry->owner_id = 0;
					lpRegEntry->entity_id = 0;
					lpRegEntry->modification_rights = GCC_NO_MODIFICATION_RIGHTS_SPECIFIED;

					//	Send Monitor Indication if necessary
					if (lpRegEntry->monitoring_state == ON)
					{
						/*
						**	Deliver the monitor indication to the Top
						**	Provider's Node Controller if necessary.
						*/
						SendMonitorEntryIndicationMessage(lpRegEntry);
						
						/*
						**	Broadcast a monitor entry indication to all
						**	nodes in the conference.
						*/
						m_pMCSUserObject->RegistryMonitorEntryIndication(
									lpRegEntry->registry_key,
									lpRegEntry->entry_item,
									lpRegEntry->owner_id,
									lpRegEntry->entity_id,
									lpRegEntry->modification_rights);
					}
		
					if (NULL != lpRegEntry->registry_key)
					{
					    lpRegEntry->registry_key->Release();
					}
					m_RegEntryList.Remove(lpRegEntry);
					delete lpRegEntry;
					break;
				}
			}
			
			if (keys_match == FALSE)
				break;
		}
	}
}

/*
 *	REG_ENTRY *GetRegistryEntry ()
 *
 *	Private Function Description
 *		This routine is responsible for searching the registry list for
 *		the registry entry specified by the passed in registry key.  NULL
 *		is returned if the entry can not be found.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i) Registry key associated with entry to get.
 *
 *	Return Value
 *		Pointer to the registry item assoicated with the specified registry
 *		key.  NULL if it does not exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
REG_ENTRY *CRegistry::GetRegistryEntry(CRegKeyContainer *registry_key_data)
{
	REG_ENTRY           *registry_entry = NULL;
	REG_ENTRY           *lpRegEntry;

	m_RegEntryList.Reset();
	while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
	{
		if (*lpRegEntry->registry_key == *registry_key_data)
		{
			registry_entry = lpRegEntry;
			break;
		}
	}

	return (registry_entry);
}

/*
 *	TokenID GetUnusedToken ()
 *
 *	Private Function Description
 *		This routine is responsible for generating an unused token.  The routine
 *		will return a token ID of zero if all are used up (this is very
 *		unlikely).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The generated token ID.  Zero if no token IDs are available.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
TokenID		CRegistry::GetUnusedToken ()
{
	TokenID				token_id = 0;
	CRegItem            *registry_item_data;
	REG_ENTRY           *lpRegEntry;
	
	while (token_id == 0)
	{
		token_id = m_nCurrentTokenID;
		m_nCurrentTokenID++;
		
		if (m_nCurrentTokenID == (TokenID)0xffff)
        {
			m_nCurrentTokenID = (TokenID)16384;
        }

		m_RegEntryList.Reset();
		while (NULL != (lpRegEntry = m_RegEntryList.Iterate()))
		{
			registry_item_data = lpRegEntry->entry_item;
		
			if (registry_item_data->IsThisYourTokenID(token_id))	
			{
				token_id = 0;
				break;
			}
		}
	}
	
	return (token_id);
}

/*
 *	GCCError	AddAPEToMonitoringList ()
 *
 *	Private Function Description
 *		This routine is used to add a new APE to the monitoring list.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with entry being
 *									monitored.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									doing the monitoring.
 *		requester_sap		-	(i)	Pointer to the command target associated 
 *									with APE making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError	CRegistry::AddAPEToMonitoringList(	
									CRegKeyContainer *registry_key_data,
									EntityID		entity_id,
									CAppSap         *requester_sap)
{
	GCCError			rc = GCC_NO_ERROR;
	REG_ENTRY           *registry_entry;
	BOOL    			entry_does_exists;
	GCCRegistryItem		registry_item;
	
	registry_entry = GetRegistryEntry (registry_key_data);
	
	/*
	**	If the registry does not exists we go ahead and create an empty
	**	entry here.
	*/
	if (registry_entry == NULL)
	{
		DBG_SAVE_FILE_LINE
		registry_entry = new REG_ENTRY;
		if (registry_entry != NULL)
		{
			//	First allocate an empty registry item
			registry_item.item_type = GCC_REGISTRY_NONE;
			DBG_SAVE_FILE_LINE
			registry_entry->entry_item = new CRegItem(&registry_item, &rc);
			if ((registry_entry->entry_item != NULL) && (rc == GCC_NO_ERROR))
			{
				//	Next allocate the registry key
				DBG_SAVE_FILE_LINE
				registry_entry->registry_key = new CRegKeyContainer(registry_key_data, &rc);
				if ((registry_entry->registry_key != NULL) && (rc == GCC_NO_ERROR))
				{
					/*
					**	If everything is OK up to here we go ahead and add the
					**	registry entry to the local entry list.
					*/
					m_RegEntryList.Append(registry_entry);
				}
				else if (registry_entry->registry_key == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
					registry_entry->entry_item->Release();
				}
				else
				{
					registry_entry->registry_key->Release();
					registry_entry->entry_item->Release();
				}
			}
			else if (registry_entry->entry_item == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
			else
            {
				registry_entry->entry_item->Release();
            }
			
			if (rc != GCC_NO_ERROR)
            {
				delete registry_entry;
            }
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	
	if (rc == GCC_NO_ERROR)
	{
		m_AppSapEidList2.Append(entity_id, requester_sap);

		/*
		**	Make sure that this entry does not already exists in the
		**	monitoring list.
		*/
		EntityID eid;
		registry_entry->monitoring_list.Reset();
		entry_does_exists = FALSE;
		while (GCC_INVALID_EID != (eid = registry_entry->monitoring_list.Iterate()))
		{
			if (eid == entity_id)
			{
				entry_does_exists = TRUE;
				break;
			}
		}
		
		if (entry_does_exists == FALSE)
		{
			registry_entry->monitoring_list.Append(entity_id);
		}
	}

	return rc;
}

/*
 *	void	RemoveAPEFromMonitoringList ()
 *
 *	Private Function Description
 *		This routine is used to remove an APE from the monitoring list.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with entry being
 *									monitored.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									being removed from the monitoring list.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CRegistry::RemoveAPEFromMonitoringList(	
									CRegKeyContainer        *registry_key_data,
									EntityID				entity_id)
{
	REG_ENTRY   *registry_entry;

	registry_entry = GetRegistryEntry (registry_key_data);
	if (registry_entry != NULL)
	{
		/*
		**	Make sure that this entry does not already exists in the
		**	monitoring list.
		*/
		registry_entry->monitoring_list.Remove(entity_id);
	}
}

/*
 *	void	SendMonitorEntryIndicationMessage ()
 *
 *	Private Function Description
 *		This routine is used to generate a monitor indication to all the
 *		APEs that are currently monitoring the specified registry entry.
 *
 *	Formal Parameters:
 *		registry_entry	-	(i)	Pointer to the registry entry being monitored.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CRegistry::SendMonitorEntryIndicationMessage(REG_ENTRY *registry_entry)
{
    EntityID    eid;
    CAppSap      *pAppSap;

	registry_entry->monitoring_list.Reset();
	while (GCC_INVALID_EID != (eid = registry_entry->monitoring_list.Iterate()))
	{
		if (NULL != (pAppSap = m_AppSapEidList2.Find(eid)))
		{
			pAppSap->RegistryMonitorIndication(
									m_nConfID,
									registry_entry->registry_key,
									registry_entry->entry_item,
									registry_entry->modification_rights,
									registry_entry->owner_id,
									registry_entry->entity_id);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\regitem.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);

/* 
 *	regitem.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CRegItem.  This 
 *		class manages the data associated with a Registry Item.  Registry Items
 *		are	used to identify a particular entry in the application registry and
 *		may exist in the form of a Channel ID, a Token ID, or an octet string 
 *		parameter.  A CRegItem object holds the data for the first two 
 *		forms in a ChannelID and a TokeID, respectively.  When the registry item
 *		assumes the octet string parameter form, the data is held internally in
 *		a Rogue Wave string object.  
 *
 *	Protected Instance Variables:
 *		m_eItemType
 *			Variable used to indicate whether this registry item is a Channel,
 *			Token, Parameter, or none of these.
 *		m_nChannelID
 *			Variable used to hold the value for the registry item when it
 *			assumes the form of a Channel ID.
 *		m_nTokenID
 *			Variable used to hold the value for the registry item when it
 *			assumes the form of a Token ID.
 *		m_poszParameter
 *			Variable used to hold the value for the registry item when it
 *			assumes the form of a Parameter.
 *		m_RegItemPDU
 *			Storage for the "PDU" form of the registry item.
 *		m_fValidRegItemPDU
 *			Flag indicating that the internal "PDU" registry item has been
 *			filled in.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCRegistryItem structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "ms_util.h"
#include "regitem.h"

/*
 * This macro is used to ensure that the Parameter contained in the Registry
 * Item does not violate the imposed ASN.1 constraint.
 */
#define		MAXIMUM_PARAMETER_LENGTH		64

/*
 *	CRegItem()
 *
 *	Public Function Description:
 *		This constructor is used to create a CRegItem object from
 *		an "API" GCCRegistryItem.
 */
CRegItem::
CRegItem(PGCCRegistryItem registry_item, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','I')),
    m_fValidRegItemPDU(FALSE),
    m_cbDataSize(0),
    m_poszParameter(NULL)
{
	*pRetCode = GCC_NO_ERROR;

	/*
	 * Check to see what type of registry item exists.  Save the registry item
	 * in the internal structure.
	 */
    switch (registry_item->item_type)
    {
    case GCC_REGISTRY_CHANNEL_ID:
		m_eItemType = GCC_REGISTRY_CHANNEL_ID;
		m_nChannelID = registry_item->channel_id;
        break;
    case GCC_REGISTRY_TOKEN_ID:
		m_eItemType = GCC_REGISTRY_TOKEN_ID;
		m_nTokenID = registry_item->token_id;
        break;
    case GCC_REGISTRY_PARAMETER:
		/*
		 * Check to make sure the parameter string does not violate the imposed
		 * ASN.1 constraint.
		 */
		if (registry_item->parameter.length > MAXIMUM_PARAMETER_LENGTH)
		{
			ERROR_OUT(("CRegItem::CRegItem: Error: parameter exceeds allowable length"));
			*pRetCode = GCC_INVALID_REGISTRY_ITEM;
		}
		else
		{
			m_eItemType = GCC_REGISTRY_PARAMETER;
			if (NULL == (m_poszParameter = ::My_strdupO2(
								registry_item->parameter.value,
								registry_item->parameter.length)))
			{
				*pRetCode = GCC_ALLOCATION_FAILURE;
			}
		}
        break;
    default:
		m_eItemType = GCC_REGISTRY_NONE;
        break;
	}
}

/*
 *	CRegItem()
 *
 *	Public Function Description:
 *		This constructor is used to create an CRegItem object from
 *		a "PDU" RegistryItem.
 */
CRegItem::
CRegItem(PRegistryItem registry_item, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','I')),
    m_fValidRegItemPDU(FALSE),
    m_cbDataSize(0),
    m_poszParameter(NULL)
{
	*pRetCode = GCC_NO_ERROR;

	/*
	 * Check to see what type of registry item exists.  Save the registry item
	 * in the internal structure.
	 */
    switch (registry_item->choice)
    {
    case CHANNEL_ID_CHOSEN:
		m_eItemType = GCC_REGISTRY_CHANNEL_ID;
		m_nChannelID = registry_item->u.channel_id;
        break;
    case TOKEN_ID_CHOSEN:
		m_eItemType = GCC_REGISTRY_TOKEN_ID;
		m_nTokenID = registry_item->u.token_id;
        break;
    case PARAMETER_CHOSEN:
		m_eItemType = GCC_REGISTRY_PARAMETER;
		if (NULL == (m_poszParameter = ::My_strdupO2(
							registry_item->u.parameter.value,
							registry_item->u.parameter.length)))
		{
			*pRetCode = GCC_ALLOCATION_FAILURE;
		}
        break;
    default:
		m_eItemType = GCC_REGISTRY_NONE;
        break;
	}
}

/*
 *	CRegItem()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CRegItem object
 *		from another CRegItem object.
 */
CRegItem::
CRegItem(CRegItem *registry_item, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','I')),
    m_fValidRegItemPDU(FALSE),
    m_cbDataSize(0),
    m_poszParameter(NULL)
{
	*pRetCode = GCC_NO_ERROR;

	/*
	 *	Copy pertinent information from the source object's instance variables.
	 */
	m_eItemType = registry_item->m_eItemType;
	m_nChannelID = registry_item->m_nChannelID;
	m_nTokenID = registry_item->m_nTokenID;
	if (NULL != registry_item->m_poszParameter)
	{
		if (NULL == (m_poszParameter = ::My_strdupO(registry_item->m_poszParameter)))
		{
			*pRetCode = GCC_ALLOCATION_FAILURE;
		}
	}
}

/*
 *	~CRegItem()
 *
 *	Public Function Description
 *		The CRegItem destructor has no cleanup responsibilities since
 *		no memory is explicitly allocated by this class.
 *
 */
CRegItem::
~CRegItem(void)
{
	delete m_poszParameter;
}

/*
 *	LockRegistryItemData ()
 *
 *	Public Function Description:
 *		This routine locks the registry item data and determines the amount of
 *		memory referenced by the "API" registry item data structure.
 */
UINT CRegItem::
LockRegistryItemData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the registry item
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Determine the amount of space required to hold the data referenced
		 * by the "API" RegistryItem structure.  Force the size to be on an 
		 * even four-byte boundary.
		 */
		m_cbDataSize = 0;

		if (m_eItemType == GCC_REGISTRY_PARAMETER)
        {
			m_cbDataSize = m_poszParameter->length;
        }

		m_cbDataSize = ROUNDTOBOUNDARY(m_cbDataSize);
	}

	return m_cbDataSize;
}

/*
 *	GetGCCRegistryItemData ()
 *
 *	Public Function Description:
 *		This routine retrieves registry item data in the form of an "API" 
 *		GCCRegistryItem.  This routine is called after "locking" the registry 
 *		item data.
 */
UINT CRegItem::
GetGCCRegistryItemData(PGCCRegistryItem registry_item, LPBYTE memory)
{
	UINT cbDataSizeToRet = 0;
	
	/*
	 * If the registry item data has been locked, fill in the output structure
	 * and the data referenced by the structure.  Otherwise, report that the 
	 * registry item has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written into the memory
		 * provided.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the "API" registry item structure and copy any octet string
		 * data into the output memory block if the registry item is of type
		 * "parameter".
		 */ 
        switch (m_eItemType)
        {
        case GCC_REGISTRY_CHANNEL_ID:
			registry_item->item_type = GCC_REGISTRY_CHANNEL_ID;
			registry_item->channel_id = m_nChannelID;
            break;
        case GCC_REGISTRY_TOKEN_ID:
			registry_item->item_type = GCC_REGISTRY_TOKEN_ID;
			registry_item->token_id = m_nTokenID;
            break;
        case GCC_REGISTRY_PARAMETER:
			registry_item->item_type = GCC_REGISTRY_PARAMETER;
			/*
			 * Fill in the length and pointer of the parameter octet string.
			 */
			registry_item->parameter.length = m_poszParameter->length;
			registry_item->parameter.value = memory;
			/*
			 * Now copy the octet string data from the internal Rogue Wave
			 * string into the allocated memory.
			 */		
			::CopyMemory(memory, m_poszParameter->value, m_poszParameter->length);
		    break;
        default:
			registry_item->item_type = GCC_REGISTRY_NONE;
            break;
		}
	}
	else
	{
		ERROR_OUT(("CRegItem::GetGCCRegistryItemData Error Data Not Locked"));
	}
	
	return cbDataSizeToRet;
}

/*
 *	UnlockRegistryItemData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" registry item once the lock count reaches zero.
 */
void CRegItem::
UnLockRegistryItemData(void)
{
    Unlock();
}

/*
 *	GetRegistryItemDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the registry key from it's internal form of a
 *		"RegistryItemInfo" structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "RegistryItem" structure is 
 *		returned.
 */
void CRegItem::
GetRegistryItemDataPDU(PRegistryItem registry_item)
{
	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidRegItemPDU == FALSE)
	{
		m_fValidRegItemPDU = TRUE;

        switch (m_eItemType)
        {
        case GCC_REGISTRY_CHANNEL_ID:
			m_RegItemPDU.choice = CHANNEL_ID_CHOSEN;
			m_RegItemPDU.u.channel_id = m_nChannelID;
            break;
        case GCC_REGISTRY_TOKEN_ID:
			m_RegItemPDU.choice = TOKEN_ID_CHOSEN;
			m_RegItemPDU.u.token_id = m_nTokenID;
            break;
        case GCC_REGISTRY_PARAMETER:
			m_RegItemPDU.choice = PARAMETER_CHOSEN;
			/*
			 * Fill in the "PDU" parameter string.
			 */
			m_RegItemPDU.u.parameter.length = m_poszParameter->length;
			::CopyMemory(m_RegItemPDU.u.parameter.value, m_poszParameter->value, m_RegItemPDU.u.parameter.length);
            break;
        default:
			m_RegItemPDU.choice = VACANT_CHOSEN;
            break;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*registry_item = m_RegItemPDU;
}

/*
 *	FreeRegistryItemDataPDU ();
 *
 *	Public Function Description:
 *		This routine is used to "free" the "PDU" data for this object.  For
 *		this object, this means setting a flag to indicate that the "PDU" data
 *		for this object is no longer valid.
 */
void CRegItem::
FreeRegistryItemDataPDU(void)
{
	if (m_fValidRegItemPDU)
	{
		/*
		 * No memory is specifically allocated to hold "PDU" data so just set
		 * the flag indicating that PDU registry key data is no longer
		 * allocated.
		 */
		m_fValidRegItemPDU = FALSE;
	}
}


GCCError CRegItem::
CreateRegistryItemData(PGCCRegistryItem *ppRegItem)
{
    GCCError rc;

    DebugEntry(CRegItem::CreateRegistryItemData);

    /*
    **	Here we calculate the length of the bulk data.  This
    **	includes the registry key and registry item.  These objects are
    **	"locked" in order to determine how much bulk memory they will
    **	occupy.
    */
    UINT cbItemSize = ROUNDTOBOUNDARY(sizeof(GCCRegistryItem));
    UINT cbDataSize = LockRegistryItemData() + cbItemSize;
    LPBYTE pData;

    DBG_SAVE_FILE_LINE
    if (NULL != (pData = new BYTE[cbDataSize]))
    {
        *ppRegItem = (PGCCRegistryItem) pData;
        ::ZeroMemory(pData, cbItemSize);

        pData += cbItemSize;
        GetGCCRegistryItemData(*ppRegItem, pData);

        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CRegItem::CreateRegistryItemData: can't create GCCRegistryKey"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    //	UnLock the registry key since it is no longer needed
    UnLockRegistryItemData();

    DebugExitINT(CRegItem::CreateRegistryItemData, rc);
    return rc;
}


/*
 *	IsThisYourTokenID ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified token ID is
 *		held within this registry item object.
 */


/*
 *	operator= ()
 *
 *	Public Function Description:
 *		This routine is used to assign the value of one CRegItem object
 * 		to another.
 */
void CRegItem::operator= (const CRegItem& registry_item_data)	
{
	/*
	 * Free any PDU allocated data so that any subsequent calls to retrieve the
	 * PDU data will cause the PDU structure to be rebuilt.
	 */
	if (m_fValidRegItemPDU)
    {
		FreeRegistryItemDataPDU();
    }

	m_eItemType = registry_item_data.m_eItemType;
	m_nChannelID = registry_item_data.m_nChannelID;
	m_nTokenID = registry_item_data.m_nTokenID;
	if (NULL != registry_item_data.m_poszParameter)
	{
		m_poszParameter = ::My_strdupO(registry_item_data.m_poszParameter);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\spacket.cpp ===
/*
 *	spacket.h
 *
 *	Copyright (c) 1997-98 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the implementation file for the SimplePacket class.  Instances of this
 *		class represent Protocol Data Units (PDUs) as they flow through the
 *		system.  Objects of this class can not be instantiated, because it's a 
 *		pure virtual class.  It exists only to be inherited from.  The Packet
 *		and DataPacket classes inherit from this one.  
 *
 *		A packet object can be created in 2 different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will calculate how much memory it will need to
 *		hold both the encoded and decoded data, and attempts to allocate that
 *		memory.  If it cannot, then it will report an error, and the newly
 *		created object should be immediately destroyed.  If the allocations are
 *		successful, then the packet will report success, but WILL NOT yet put
 *		any data into those allocated buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the pre-allocated encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *
 *		When Unlock messages are received, the lock count is decremented.  When
 *		the lock count is 0, the packet deletes itself (it commits
 *		suicide).  Note that for this reason, no other object should explicitly
 *		delete a packet object.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Christos Tsollis
 */

#include "precomp.h"

// Constructor for the SimplePacket class.

SimplePacket::SimplePacket(BOOL fPacketDirectionUp)
: 
	lLock (1),
	Packet_Direction_Up (fPacketDirectionUp)
{
}

// Destructor for the SimplePacket class
SimplePacket::~SimplePacket (void)
{
}

/*
 *	Unlock ()
 *
 *	Public
 *
 */
Void SimplePacket::Unlock ()
{
	/*
	 * Check to make sure that the packet is locked before allowing it to
	 * be unlocked.
	 */
	ASSERT (lLock > 0);

	/*
	 * If the lock count has reached zero, it is necessary to perform
	 * a suicide check.  This method will determine if there is any need
	 * to continue to exist.
	 */
	if (InterlockedDecrement(&lLock) == 0)
		delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\socket.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);
/*	Socket.cpp
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the implementation of our socket constructor/destructor functions.
 *
 */
#include "socket.h"
#include "plgxprt.h"

/* Size of listen queue */
#define	LISTEN_QUEUE_SIZE	3

/* External definitions */
extern HWND					TCP_Window_Handle;
extern PTransportInterface	g_Transport;

/*	
 *	void CreateAndConfigureListenSocket (VOID)
 *	
 *	Functional Description
 *		This function sets up a listening socket.
 *	returns INVALID_SOCKET if there is any error.
 */
SOCKET CreateAndConfigureListenSocket (VOID)
{
	SOCKADDR_IN		socket_control;
	SOCKET Socket;

	// Create the listening socket.
	Socket = socket (AF_INET, SOCK_STREAM, 0);

	if (Socket == INVALID_SOCKET) {
		WARNING_OUT (("Socket: error creating listening socket (errno = %d)", WSAGetLastError()));
		goto Error;
	}

	// The listen socket only waits for FD_ACCEPT msgs.
	ASSERT(TCP_Window_Handle);
	if (WSAAsyncSelect (Socket,
						TCP_Window_Handle,
						WM_SOCKET_NOTIFICATION,
						FD_ACCEPT) != 0)	{

		WARNING_OUT (("CreateAndConfigureListenSocket: Error on WSAAsyncSelect = %d", WSAGetLastError()));
		goto Error;
	}
	
	/*
	 * Load the socket control structure with the parameters necessary.
	 *	- Internet socket
	 *	- Let it assign any address to this socket
	 *	- Assign our port number
	 */
	socket_control.sin_family = AF_INET;
	socket_control.sin_addr.s_addr = INADDR_ANY;
	socket_control.sin_port = htons ( TCP_PORT_NUMBER );

	/* Issue the bind call */
	if (bind (Socket, (LPSOCKADDR) &socket_control, sizeof(SOCKADDR_IN)) != 0) {
		WARNING_OUT (("Socket::Listen: bind failed:  Unable to use WinSock"));
		goto Error;
	}

	/*
	 * Issue a listen to WinSock to tell it we are willing to accept calls.
	 * This is a non-blocking listen, therefore we will receive FD_ACCEPT
	 * if someone is trying to call us.
	 */
	if (listen (Socket, LISTEN_QUEUE_SIZE) != 0) {
		WARNING_OUT (("Socket::Listen: listen failed:  Unable to use WinSock"));
		goto Error;
	}
	ASSERT(Socket != INVALID_SOCKET);

	return Socket;

Error:

    if (INVALID_SOCKET != Socket)
    {
        ::closesocket(Socket);
    }

	return INVALID_SOCKET;
}


/*
 *	PSocket	newSocket (SOCKET socket_number)
 *
 *	Functional Description:
 *		This is a constructor for the Socket object.  It allocates the
 *		send and receive buffers and sets up internal variables.
 */
PSocket	newSocket(TransportConnection XprtConn, PSecurityContext pSC)
{
    if (IS_SOCKET(XprtConn))
    {
        return ::newSocketEx(XprtConn, pSC);
    }
    return g_pSocketList->FindByTransportConnection(XprtConn, TRUE);
}


PSocket	newPluggableSocket(TransportConnection XprtConn)
{
    PSocket pSocket = ::newSocketEx(XprtConn, NULL);
    if (NULL != pSocket)
    {
    	g_pSocketList->SafeAppend(pSocket);
    }
    return pSocket;
}


PSocket	newSocketEx(TransportConnection XprtConn, PSecurityContext pSC)
{
    BOOL fRet;
	DBG_SAVE_FILE_LINE
	PSocket pSocket = new CSocket(&fRet, XprtConn, pSC);
	if (NULL != pSocket)
	{
	    if (fRet)
	    {
	        return pSocket;
	    }
	    pSocket->Release();
	}
	ERROR_OUT(("newSocket: Unable to allocate memory for Socket struct, pSocket=0x%x", pSocket));
	return NULL;
}


CSocket::CSocket(BOOL *_pfRet, TransportConnection _XprtConn, PSecurityContext _pSC)
:
    CRefCount(MAKE_STAMP_ID('S','o','c','k')),
    State(IS_SOCKET(_XprtConn) ? NOT_CONNECTED : SOCKET_CONNECTED),
    SecState((NULL == _pSC) ? SC_UNDETERMINED : SC_SECURE),
    pSC(_pSC),
    Max_Packet_Length(DEFAULT_MAX_X224_SIZE),
    Current_Length(0),
    Data_Indication_Buffer(NULL),
    Data_Indication_Length(0),
    Read_State(READ_HEADER),
    X224_Length(0),
    bSpaceAllocated(FALSE),
    Data_Memory(NULL),
    fExtendedX224(FALSE),
    fIncomingSecure(FALSE),
    XprtConn(_XprtConn)
{
    // assume failure
    *_pfRet = FALSE;

    // zero out sub structures
    ::ZeroMemory(&X224_Header, sizeof(X224_Header));
    ::ZeroMemory(&Retry_Info, sizeof(Retry_Info));
	Remote_Address[0] = '\0';

    if (IS_SOCKET(XprtConn))
    {
    	if (INVALID_SOCKET == XprtConn.nLogicalHandle)
    	{
    		/* Create a STREAM socket (fully reliable, full duplex, and sequenced) */
    		if ((XprtConn.nLogicalHandle = ::socket(AF_INET, SOCK_STREAM, 0))
    		    == INVALID_SOCKET)
    		{
    			ERROR_OUT (("CSocket: error acquiring INET socket # (errno = %d)", WSAGetLastError()));
    			return;
    		}
    	}

    	/* Enable Tx and Rx messages to the window */
    	ASSERT(TCP_Window_Handle);
    	if (::WSAAsyncSelect(XprtConn.nLogicalHandle, TCP_Window_Handle,
    	        WM_SOCKET_NOTIFICATION, 
    			FD_READ | FD_WRITE | FD_CLOSE | FD_CONNECT) != 0)
        {
    		WARNING_OUT (("CSocket: Error on WSAAsyncSelect = %d", WSAGetLastError()));
    	}
	}
    else
    {
        ASSERT(IS_PLUGGABLE(XprtConn));
        CPluggableConnection *p = ::GetPluggableConnection(this);
        if (NULL == p)
        {
    		ERROR_OUT(("newSocket: Unable to find plugable transport (%d, %d)",
    		        XprtConn.eType, XprtConn.nLogicalHandle));
    		return;
        }
    }

    // success
    *_pfRet = TRUE;
}


/*
 *	void freeSocket (PSocket, TransportConnection)
 *
 *	Functional Description:
 *		This is a destructor for the Socket object.  It frees the send
 *		and receive buffers and connection structure.
 *		It will also cleanup the listening socket. In this case, 
 *		"pSocket" is set to NULL and "trash_packets" should be set to TRUE.
 */
void freeSocket(PSocket pSocket, TransportConnection XprtConn)
{
    if (IS_SOCKET(XprtConn))
    {
        if (NULL != g_pSocketList)
        {
            g_pSocketList->SafeRemove(pSocket);
        }
        freeSocketEx(pSocket, XprtConn);
    }
}


void freeListenSocket(TransportConnection XprtConn)
{
    ASSERT(IS_SOCKET(XprtConn));
    freeSocketEx(NULL, XprtConn);
}


void freePluggableSocket(PSocket pSocket)
{
    freeSocketEx(pSocket, pSocket->XprtConn);
    if (NULL != g_pSocketList)
    {
        g_pSocketList->SafeRemove(pSocket);
    }
}


void freeSocketEx(PSocket pSocket, TransportConnection XprtConn)
{
	// Either "pSocket" is NULL, or the socket is not invalid.
    #ifdef _DEBUG
    if (IS_SOCKET(XprtConn))
    {
        if (NULL != pSocket)
        {
	        ASSERT(INVALID_SOCKET != pSocket->XprtConn.nLogicalHandle);
	    }
	    else
	    {
	        // it is a listen socket
	        ASSERT(INVALID_SOCKET != XprtConn.nLogicalHandle);
	    }
	}
	#endif

	// Determine the socket number to use... Either the socket is the
	// socket indicated in the PSocket structure, or it is a structure-less
	// listen socket. Note: both cannot be valid!

    if (IS_SOCKET(XprtConn))
    {
    	SOCKET socket = (pSocket) ? pSocket->XprtConn.nLogicalHandle : XprtConn.nLogicalHandle;
        XprtConn.nLogicalHandle = socket;

    	/* Disable notifications to our window */
    	if (::IsWindow(TCP_Window_Handle))
    	{
    	    ::WSAAsyncSelect(socket, TCP_Window_Handle, 0, 0);
    	}
    }

	if (pSocket != NULL)
	{
	    pSocket->Release();
	}
	else
	{
		// This is the listening socket
		::ShutdownAndClose (XprtConn, FALSE, 0);
	}
}


CSocket::~CSocket(void)
{
	switch (State)
	{
	case SOCKET_CONNECTED:
	// case WAITING_FOR_DISCONNECT:
		/* All physically connected states issue a shutdown() first */
		::ShutdownAndClose(XprtConn, TRUE, SD_BOTH);
		break;

	case X224_CONNECTED:
		// Shutdown disable reception only.
		::ShutdownAndClose(XprtConn, TRUE, SD_RECEIVE);
		break;

	default:
		::ShutdownAndClose(XprtConn, FALSE, 0);
		break;
	}

	/* Free the structures */
	FreeTransportBuffer();
	delete pSC;
}


void CSocket::FreeTransportBuffer(void)
{
    if (NULL != Data_Memory)
    {
        ::FreeMemory(Data_Memory);
        Data_Memory = NULL;
        Data_Indication_Buffer = NULL;
    }
}



void CSocketList::SafeAppend(PSocket pSocket)
{
    ::EnterCriticalSection(&g_csTransport);
    if (! Find(pSocket))
    {
        Append(pSocket);
    }
    ::LeaveCriticalSection(&g_csTransport);
}


BOOL CSocketList::SafeRemove(PSocket pSocket)
{
    ::EnterCriticalSection(&g_csTransport);
    BOOL fRet = Remove(pSocket);
    ::LeaveCriticalSection(&g_csTransport);
    return fRet;
}


PSocket CSocketList::FindByTransportConnection(TransportConnection XprtConn, BOOL fNoAddRef)
{
    PSocket pSocket;
    ::EnterCriticalSection(&g_csTransport);
    Reset();
    while (NULL != (pSocket = Iterate()))
    {
        if (IS_SAME_TRANSPORT_CONNECTION(pSocket->XprtConn, XprtConn))
        {
            if (! fNoAddRef)
            {
                pSocket->AddRef();
            }
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);
    return pSocket;
}


PSocket CSocketList::RemoveByTransportConnection(TransportConnection XprtConn)
{
    PSocket pSocket;
    ::EnterCriticalSection(&g_csTransport);
    Reset();
    while (NULL != (pSocket = Iterate()))
    {
        if (IS_SAME_TRANSPORT_CONNECTION(pSocket->XprtConn, XprtConn))
        {
            Remove(pSocket);
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);
    return pSocket;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\tprtntfy.h ===
#ifndef _TPRT_NOTIFY_
#define _TPRT_NOTIFY_

#define TPRT_NOTIFY_NONE                                0
#define TPRT_NOTIFY_OTHER_REASON                        1
#define TPRT_NOTIFY_REMOTE_NO_SECURITY        	        2
#define TPRT_NOTIFY_REMOTE_DOWNLEVEL_SECURITY           3
#define TPRT_NOTIFY_INCOMPATIBLE_T120_TPDU              4
#define TPRT_NOTIFY_REMOTE_REQUIRE_SECURITY		5
#define TPRT_NOTIFY_AUTHENTICATION_FAILED		6

#endif // _TPRT_NOTIFY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\t120qos.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);

#include <initguid.h>
#include <datguids.h>
#include <nmqos.h>
#include <t120qos.h>


/*	T120qos.cpp
 *
 *	Copyright (c) 1997 by Microsoft Corporation
 *
 *	Abstract:
 *
 *	Global Variables:
 *
 *  g_pIQoS - Global interface pointer to QoS interface
 *  g_dwLastQoSCB - timestamp of last QoS notification obtained via GetTickCount
 *  g_dwSentSinceLastQoS - bytes sent since last QoS notification (or epoch)
 *
 */



// IQOS interface pointer and resources request

LPIQOS				g_pIQoS = NULL;
T120RRQ g_aRRq;

// Global last QoS notification time stamp
DWORD g_dwLastQoSCB = 0;
DWORD g_dwSentSinceLastQoS = 0;
BOOL g_fResourcesRequested = FALSE;

// NOTE: Since connections through this transport typically
// consist of a single socket connection, followed by
// disconnection, followed by multiple connections, the
// following heuristic count is used to prevent on-off-on
// initialization of QoS at the time the first call is started.
// It represents the minimum number of socket connections that
// must be initiated (without an intervening disconnect of all
// connected sockets) before QoS initialization takes place.
#define MIN_CONNECTION_COUNT 	(DEFAULT_NUMBER_OF_PRIORITIES - 1)

WORD g_wConnectionCount = 0;

// extern from transprt.cpp to detect no connections

///// QOS related stuff ///////////////////////////////////


HRESULT CALLBACK QosNotifyDataCB (
		LPRESOURCEREQUESTLIST lpResourceRequestList,
		DWORD_PTR dwThis)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTLIST prrl=lpResourceRequestList;
	int i;
	int iBWUsageId;

	for (i=0, iBWUsageId = -1L; i<(int)lpResourceRequestList->cRequests; i++) {

		if (lpResourceRequestList->aRequests[i].resourceID ==
					RESOURCE_OUTGOING_BANDWIDTH)
			iBWUsageId = i;
	}

	if (iBWUsageId != -1L) {

		QoSLock();


		// Calculate effective bits-per second rate:
		//
		// 1000 milliseconds per second
		// 8 bits per byte
		//

		int nEffRate = MulDiv ( g_dwSentSinceLastQoS, 1000 * 8,
									GetTickCount() - g_dwLastQoSCB );

		// Report bandwidth usage to QoS:
		//

		// Are we using less than the available bandwidth?

		if ( ( nEffRate ) <
			lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin )
		{
			// Request our effective usage
			lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin = nEffRate;
		}
		else
		{
			// Request everything by not modifying nUnitsMin
			;
		}

		g_dwLastQoSCB = GetTickCount();
		g_dwSentSinceLastQoS = 0;

		QoSUnlock();
	}

	return hr;
}


VOID InitializeQoS( VOID )
{
	DWORD dwRes;
	HRESULT hRet;

	// Already initialized?
	if ( g_fResourcesRequested )
		return;


	// If the number of connections has not reached the
	// trigger count, defer QoS initialization (see MIN_CONNECTION_COUNT
	// comment above)

	if ( g_wConnectionCount < MIN_CONNECTION_COUNT )
	{
		g_wConnectionCount++;
		return;
	}

	// Initialize QoS. If it fails, that's Ok, we'll do without it.
	// No need to set the resource ourselves, this now done by the UI

	if (NULL == g_pIQoS)
	{
		if (0 != (hRet = CoCreateInstance(	CLSID_QoS,NULL,
									CLSCTX_INPROC_SERVER,
									IID_IQoS,
									(void **) &g_pIQoS)))
		{
			WARNING_OUT (("Unable to initalize QoS: %x", hRet));
			g_pIQoS = (LPIQOS)NULL;
			// Tolerate failure, operate w/o QoS
			return;
		}
	}

	// Initialize our request for bandwidth usage.
	g_aRRq.cResourceRequests = 1;
	g_aRRq.aResourceRequest[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;
	g_aRRq.aResourceRequest[0].nUnitsMin = 0;

	// Register with the QoS module. Even if this call fails,
	// that's Ok, we'll do without the QoS support

	dwRes = (HRESULT)g_pIQoS->RequestResources((GUID *)&MEDIA_TYPE_T120DATA,
		(LPRESOURCEREQUESTLIST)&g_aRRq, QosNotifyDataCB, NULL );

	if ( 0 == dwRes )
	{
		g_fResourcesRequested = TRUE;
	}
}


VOID DeInitializeQoS( VOID )
{
	if (NULL != g_pIQoS)
	{
		if ( g_fResourcesRequested )
		{
			g_pIQoS->ReleaseResources((GUID *)&MEDIA_TYPE_T120DATA,
								(LPRESOURCEREQUESTLIST)&g_aRRq);
			g_fResourcesRequested = FALSE;
		}
		g_wConnectionCount = 0;
		g_pIQoS->Release();
		g_pIQoS = NULL;
	}
}

VOID MaybeReleaseQoSResources( VOID )
{
	if (g_pSocketList->IsEmpty())
	{
		if (NULL != g_pIQoS)
		{
			if ( g_fResourcesRequested )
			{
				g_pIQoS->ReleaseResources((GUID *)&MEDIA_TYPE_T120DATA,
									(LPRESOURCEREQUESTLIST)&g_aRRq);
				g_fResourcesRequested = FALSE;
			}
		}
		g_wConnectionCount = 0;
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\t120app.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);

#include "appsap.h"
#include "conf.h"
#include "gcontrol.h"


void CALLBACK MCS_SapCallback(UINT, LPARAM, LPVOID);
void CALLBACK GCC_SapCallback(GCCAppSapMsg *);


T120Error WINAPI T120_CreateAppletSAP
(
    IT120Applet **ppApplet
)
{
    if (NULL != ppApplet)
    {
        *ppApplet = NULL;
        if (NULL != g_pGCCController)
        {
            T120Error rc;
            DBG_SAVE_FILE_LINE
            CApplet *pApplet = new CApplet(&rc);
            if (NULL != pApplet)
            {
                if (T120_NO_ERROR == rc)
                {
                    *ppApplet = (IT120Applet *) pApplet;
                    return T120_NO_ERROR;
                }

                ERROR_OUT(("T120_CreateAppletSAP: CApplet failed, rc=%u", rc));
                pApplet->Release();
                return rc;
            }

            ERROR_OUT(("T120_CreateAppletSAP: cannot create CApplet"));
            return T120_ALLOCATION_FAILURE;
        }

        WARNING_OUT(("T120_CreateAppletSAP: GCC Provider is not initialized."));
        return T120_NOT_INITIALIZED;
    }

    ERROR_OUT(("T120_CreateAppletSAP: callback pfn null"));
    return T120_INVALID_PARAMETER;
}


/* ------ interface methods for applet session ------ */


CAppletSession::CAppletSession
(
    CApplet        *pApplet,
    T120ConfID      nConfID
)
:
    CRefCount(MAKE_STAMP_ID('A','p','p','S')),
    m_pApplet(pApplet),
    m_pAppletContext(NULL),
    m_pSessionContext(NULL),
    m_pfnCallback(NULL),
    m_pMCSAppletSAP(NULL),
    m_nConfID(nConfID),
    m_uidMyself(0),
    m_sidMyself(0),
    m_eidMyself(0),
    m_nidMyself(0),
    m_eState(APPSESS_INITIALIZED),
    m_nArrayIndex(0),
    m_eErrorType(NONE_CHOSEN),
    m_eDynamicChannelJoinState(DCJS_INITIALIZED),
    m_fMCSFreeDataIndBuffer(0),
    m_fFirstRoster(FALSE),
    m_pTempMsg(NULL)
{
    ASSERT(0 != m_nConfID);
    ::ZeroMemory(&m_JoinRequest, sizeof(m_JoinRequest));
    m_pApplet->RegisterSession(this);
}


CAppletSession::~CAppletSession(void)
{
    m_pApplet->UnregisterSession(this);

    FreeJoinRequest(FALSE);

    ASSERT(NULL == m_pfnCallback);
    ASSERT(NULL == m_pAppletContext);
    ASSERT(NULL == m_pSessionContext);
}


void CAppletSession::FreeJoinRequest(BOOL fZeroOut)
{
    delete [] m_JoinRequest.aResourceReqs;

    if (fZeroOut)
    {
        ::ZeroMemory(&m_JoinRequest, sizeof(m_JoinRequest));
    }
}


void CAppletSession::ReleaseInterface(void)
{
    ASSERT(NULL != g_pGCCController);

    Leave();

    m_pfnCallback = NULL;
    m_pAppletContext = NULL;
    m_pSessionContext = NULL;

    Release();
}


void CAppletSession::Advise
(
    LPFN_APPLET_SESSION_CB  pfnCallback,
    LPVOID                  pAppletContext,
    LPVOID                  pSessionContext
)
{
    m_pfnCallback = pfnCallback;
    m_pAppletContext = pAppletContext;
    m_pSessionContext = pSessionContext;
}


void CAppletSession::Unadvise(void)
{
    m_pfnCallback = NULL;
    m_pAppletContext = NULL;
    m_pSessionContext = NULL;
}


BOOL CAppletSession::IsThisNodeTopProvider(void)
{
    return m_pApplet->GetAppSap()->IsThisNodeTopProvider(m_nConfID);
}


T120NodeID CAppletSession::GetTopProvider(void)
{
    return m_pApplet->GetAppSap()->GetTopProvider(m_nConfID);
}


T120Error CAppletSession::Join
(
    T120JoinSessionRequest    *pReq
)
{
    ASSERT(0 != m_nConfID);
    if (NULL != g_pGCCController->GetConfObject(m_nConfID))
    {
        T120Error rc = T120_NO_ERROR;

		// remember the join request, shallow structure copy
		m_JoinRequest = *pReq;

        // we need to duplicate the resource requests because we put the results in place.
        // we have to do this in order to support multiple conferences simultaneously
		if (NULL != pReq->aResourceReqs && 0 != pReq->cResourceReqs)
		{
		    DBG_SAVE_FILE_LINE
		    m_JoinRequest.aResourceReqs = new T120ResourceRequest[m_JoinRequest.cResourceReqs];
		    if (NULL != m_JoinRequest.aResourceReqs)
		    {
		        ::CopyMemory(m_JoinRequest.aResourceReqs, pReq->aResourceReqs,
							sizeof(T120ResourceRequest) * m_JoinRequest.cResourceReqs);
		    }
		    else
		    {
		        ERROR_OUT(("CAppletSession::Join: can't create resource requests"));
		        rc = T120_ALLOCATION_FAILURE;
		    }
		}

        // attach user now
        if (T120_NO_ERROR == rc)
        {
            m_fFirstRoster = FALSE;
            m_fMCSFreeDataIndBuffer = (pReq->dwAttachmentFlags & ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);

            SetState(APPSESS_ATTACH_USER_REQ);
            rc = ::MCS_AttachRequest(&m_pMCSAppletSAP,
                                     (LPBYTE) &m_nConfID, sizeof(m_nConfID),
                                     MCS_SapCallback,
                                     this,
                                     pReq->dwAttachmentFlags);
            ASSERT(T120_NO_ERROR == rc);
        }

        if (T120_NO_ERROR == rc)
        {
            return T120_NO_ERROR;
        }

        FreeJoinRequest(TRUE);
        return rc;
    }

    return GCC_INVALID_CONFERENCE;
}


void CAppletSession::Leave(void)
{
    if (APPSESS_LEAVING != m_eState && APPSESS_LEFT != m_eState)
    {
        APPLET_SESSION_STATE eOldState = m_eState;
        m_eState = APPSESS_LEAVING;

        switch (eOldState)
        {
        case APPSESS_INACTIVELY_ENROLL_REQ:
        case APPSESS_INACTIVELY_ENROLL_CON:
        case APPSESS_RESOURCE_REQ:
        case APPSESS_RESOURCE_CON:
        case APPSESS_ACTIVELY_ENROLL_REQ:
        case APPSESS_ACTIVELY_ENROLL_CON:
        case APPSESS_JOINED:
        default:

            // un-enroll
            DoEnroll(FALSE);
            // fall through

        case APPSESS_ATTACH_USER_REQ:
        case APPSESS_ATTACH_USER_CON:
        case APPSESS_JOIN_MY_CHANNEL_REQ:
        case APPSESS_JOIN_MY_CHANNEL_CON:
        case APPSESS_JOIN_STATIC_CHANNEL_REQ:
        case APPSESS_JOIN_STATIC_CHANNEL_CON:

            if (NULL != m_pMCSAppletSAP)
            {
                m_pMCSAppletSAP->ReleaseInterface();
                m_pMCSAppletSAP = NULL;
            }

            // fall through

        case APPSESS_INITIALIZED:
            m_fMCSFreeDataIndBuffer = 0;
            break;
        }

        m_eState = APPSESS_LEFT;
        m_fFirstRoster = FALSE;
    }

    FreeJoinRequest(TRUE);
}


T120Error CAppletSession::AllocateSendDataBuffer
(
    ULONG       cbBufSize,
    void      **ppBuf
)
{
    if (NULL != m_pMCSAppletSAP)
    {
        return m_pMCSAppletSAP->GetBuffer(cbBufSize, ppBuf);
    }
    return T120_NOT_INITIALIZED;
}


void CAppletSession::FreeSendDataBuffer
(
    void       *pBuf
)
{
    if (NULL != m_pMCSAppletSAP && (! m_fMCSFreeDataIndBuffer))
    {
        m_pMCSAppletSAP->FreeBuffer(pBuf);
    }
    else
    {
        ASSERT(0);
    }
}


T120Error CAppletSession::SendData
(
    DataRequestType             eReqType,
    T120ChannelID               nChannelID,
    T120Priority                ePriority,
    LPBYTE                      pbBuf,
    ULONG                       cbBufSize,
    SendDataFlags               eBufSource
)
{
    if (NULL != m_pMCSAppletSAP)
    {
        return m_pMCSAppletSAP->SendData(eReqType,
                                        nChannelID,
                                        (Priority) ePriority,
                                        pbBuf,
                                        cbBufSize,
                                        eBufSource);
    }
    return T120_NOT_INITIALIZED;
}


T120Error CAppletSession::InvokeApplet
(
    GCCAppProtEntityList   *pApeList,
    GCCSimpleNodeList      *pNodeList,
    T120RequestTag         *pnReqTag
)
{
    return m_pApplet->GetAppSap()->AppInvoke(m_nConfID, pApeList, pNodeList, pnReqTag);
}


T120Error CAppletSession::InquireRoster
(
    GCCSessionKey         *pSessionKey
)
{
    return m_pApplet->GetAppSap()->AppRosterInquire(m_nConfID, pSessionKey, NULL);
}


T120Error CAppletSession::RegistryRequest
(
    T120RegistryRequest     *pReq
)
{
    T120Error rc;
    if (NULL != pReq)
    {
        IGCCAppSap *pAppSap = m_pApplet->GetAppSap();
        ASSERT(NULL != pAppSap);
        GCCRegistryKey *pKey = pReq->pRegistryKey;
        switch (pReq->eCommand)
        {
        case APPLET_REGISTER_CHANNEL:
            rc = pAppSap->RegisterChannel(m_nConfID, pKey, pReq->nChannelID);
            break;
        case APPLET_ASSIGN_TOKEN:
            rc = pAppSap->RegistryAssignToken(m_nConfID, pKey);
            break;
        case APPLET_SET_PARAMETER:
            rc = pAppSap->RegistrySetParameter(m_nConfID, pKey,
                                    pReq->Param.postrValue, pReq->Param.eModifyRights);
            break;
        case APPLET_RETRIEVE_ENTRY:
            rc = pAppSap->RegistryRetrieveEntry(m_nConfID, pKey);
            break;
        case APPLET_DELETE_ENTRY:
            rc = pAppSap->RegistryDeleteEntry(m_nConfID, pKey);
            break;
        case APPLET_ALLOCATE_HANDLE:
            rc = pAppSap->RegistryAllocateHandle(m_nConfID, pReq->cHandles);
            break;
        case APPLET_MONITOR:
            rc = pAppSap->RegistryMonitor(m_nConfID, pReq->fEnableDelivery, pKey);
            break;
        default:
            ERROR_OUT(("CAppletSession::RegistryRequest: invalid command=%u", (UINT) pReq->eCommand));
            rc = T120_INVALID_PARAMETER;
            break;
        }
    }
    else
    {
        rc = T120_INVALID_PARAMETER;
    }
    return rc;
}


T120Error CAppletSession::ChannelRequest
(
    T120ChannelRequest      *pReq
)
{
    T120Error rc;
    if (NULL != pReq)
    {
        T120ChannelID chid = pReq->nChannelID;
        switch (pReq->eCommand)
        {
        case APPLET_JOIN_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelJoin(chid);
            break;
        case APPLET_LEAVE_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelLeave(chid);
            break;
        case APPLET_CONVENE_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelConvene();
            break;
        case APPLET_DISBAND_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelDisband(chid);
            break;
        case APPLET_ADMIT_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelAdmit(chid, pReq->aUsers, pReq->cUsers);
            break;
        default:
            ERROR_OUT(("CAppletSession::ChannelRequest: invalid command=%u", (UINT) pReq->eCommand));
            rc = T120_INVALID_PARAMETER;
            break;
        }
    }
    else
    {
        rc = T120_INVALID_PARAMETER;
    }
    return rc;
}


T120Error CAppletSession::TokenRequest
(
    T120TokenRequest        *pReq
)
{
    //T120TokenID             nTokenID;
    //T120UserID              uidGiveTo;

    T120Error rc;
    if (NULL != pReq)
    {
        T120TokenID tid = pReq->nTokenID;
        switch (pReq->eCommand)
        {
        case APPLET_GRAB_TOKEN:
            rc = m_pMCSAppletSAP->TokenGrab(tid);
            break;
        case APPLET_INHIBIT_TOKEN:
            rc = m_pMCSAppletSAP->TokenInhibit(tid);
            break;
        case APPLET_GIVE_TOKEN:
            rc = m_pMCSAppletSAP->TokenGive(tid, pReq->uidGiveTo);
            break;
        case APPLET_GIVE_TOKEN_RESPONSE:
            rc = m_pMCSAppletSAP->TokenGiveResponse(tid, pReq->eGiveResponse);
            break;
        case APPLET_PLEASE_TOKEN:
            rc = m_pMCSAppletSAP->TokenPlease(tid);
            break;
        case APPLET_RELEASE_TOKEN:
            rc = m_pMCSAppletSAP->TokenRelease(tid);
            break;
        case APPLET_TEST_TOKEN:
            rc = m_pMCSAppletSAP->TokenTest(tid);
            break;
        default:
            ERROR_OUT(("CAppletSession::TokenRequest: invalid command=%u", (UINT) pReq->eCommand));
            rc = T120_INVALID_PARAMETER;
            break;
        }
    }
    else
    {
        rc = T120_INVALID_PARAMETER;
    }
    return rc;
}


/* ------ private methods ------ */


void CAppletSession::SendCallbackMessage
(
    T120AppletSessionMsg          *pMsg
)
{
    ASSERT(NULL != pMsg);
    if (NULL != m_pfnCallback)
    {
        pMsg->pAppletContext = m_pAppletContext;
        pMsg->pSessionContext = m_pSessionContext;
        (*m_pfnCallback)(pMsg);
    }
}


void CAppletSession::SendMCSMessage
(
    T120AppletSessionMsg    *pMsg
)
{
    ASSERT(NULL != pMsg);
    if (NULL != m_pfnCallback)
    {
        pMsg->nConfID = m_nConfID;
        pMsg->pAppletContext = m_pAppletContext;
        pMsg->pSessionContext = m_pSessionContext;
        (*m_pfnCallback)(pMsg);
    }
    else
    {
        if (pMsg->eMsgType == MCS_UNIFORM_SEND_DATA_INDICATION ||
            pMsg->eMsgType == MCS_SEND_DATA_INDICATION)
        {
            if (! m_fMCSFreeDataIndBuffer)
            {
                WARNING_OUT(("CAppletSession::SendMCSMessage: send data ind, free ptr=0x%x, len=%d", pMsg->SendDataInd.user_data.value, pMsg->SendDataInd.user_data.length));
                FreeSendDataBuffer(pMsg->SendDataInd.user_data.value);
            }
        }
    }
}


void CAppletSession::MCSCallback
(
    T120AppletSessionMsg   *pMsg
)
{
    // dispatch the message depeneding on whether we are still in the join process or not
    if (IsJoining())
    {
        SetTempMsg(pMsg);

        switch (pMsg->eMsgType)
        {
        case MCS_ATTACH_USER_CONFIRM:
            HandleAttachUserConfirm();
            break;

        case MCS_CHANNEL_JOIN_CONFIRM:
            HandleJoinChannelConfirm();
            break;

        case MCS_TOKEN_GRAB_CONFIRM:
        	HandleTokenGrabConfirm();
            break;

        }
    }
    else
    {
        SendMCSMessage(pMsg);
    }
}


void CAppletSession::GCCCallback
(
    T120AppletSessionMsg   *pMsg
)
{
    if (IsJoining())
    {
        // remember the current GCC applet SAP message
        SetTempMsg(pMsg);

        switch (pMsg->eMsgType)
        {
        case GCC_ENROLL_CONFIRM:
            HandleEnrollConfirm();
            break;

        case GCC_APP_ROSTER_REPORT_INDICATION:
            if (! m_fFirstRoster)
            {
                if (APPSESS_INACTIVELY_ENROLL_CON == m_eState)
                {
                    DoResourceRequests();
                }
                m_fFirstRoster = TRUE;
            }
            break;

        case GCC_REGISTER_CHANNEL_CONFIRM:
            HandleRegisterChannelConfirm();
            break;

        case GCC_RETRIEVE_ENTRY_CONFIRM:
            HandleRetrieveEntryConfirm();
            break;
        }
    }
    else
    {
        SendCallbackMessage(pMsg);
    }
}


void CAppletSession::SetState(APPLET_SESSION_STATE eNewState)
{
#ifdef _DEBUG
    if (APPSESS_LEAVING != eNewState)
    {
        switch (m_eState)
        {
        case APPSESS_INITIALIZED:
            ASSERT(APPSESS_ATTACH_USER_REQ == eNewState);
            break;
        // attach user
        case APPSESS_ATTACH_USER_REQ:
            ASSERT(APPSESS_ATTACH_USER_CON == eNewState);
            break;
        case APPSESS_ATTACH_USER_CON:
            ASSERT(APPSESS_JOIN_MY_CHANNEL_REQ == eNewState);
            break;
        // join my channel
        case APPSESS_JOIN_MY_CHANNEL_REQ:
            ASSERT(APPSESS_JOIN_MY_CHANNEL_CON == eNewState);
            break;
        case APPSESS_JOIN_MY_CHANNEL_CON:
            ASSERT(APPSESS_JOIN_STATIC_CHANNEL_REQ == eNewState ||
                   APPSESS_INACTIVELY_ENROLL_REQ == eNewState ||
                   APPSESS_ACTIVELY_ENROLL_REQ == eNewState);
            break;
        // join static channels
        case APPSESS_JOIN_STATIC_CHANNEL_REQ:
            ASSERT(APPSESS_JOIN_STATIC_CHANNEL_CON == eNewState);
            break;
        case APPSESS_JOIN_STATIC_CHANNEL_CON:
            ASSERT(APPSESS_JOIN_STATIC_CHANNEL_REQ == eNewState ||
                   APPSESS_INACTIVELY_ENROLL_REQ == eNewState ||
                   APPSESS_ACTIVELY_ENROLL_REQ == eNewState);
            break;
        // enroll applet in order to do resource requests
        case APPSESS_INACTIVELY_ENROLL_REQ:
            ASSERT(APPSESS_INACTIVELY_ENROLL_CON == eNewState);
            break;
        case APPSESS_INACTIVELY_ENROLL_CON:
            ASSERT(APPSESS_RESOURCE_REQ == eNewState);
            break;
        // do resource requests
        case APPSESS_RESOURCE_REQ:
            ASSERT(APPSESS_RESOURCE_CON == eNewState ||
                   APPSESS_ACTIVELY_ENROLL_REQ == eNewState);
            break;
        case APPSESS_RESOURCE_CON:
            ASSERT(APPSESS_RESOURCE_REQ == eNewState);
            break;
        // enroll applet in order to do resource requests
        case APPSESS_ACTIVELY_ENROLL_REQ:
            ASSERT(APPSESS_ACTIVELY_ENROLL_CON == eNewState);
            break;
        case APPSESS_ACTIVELY_ENROLL_CON:
            ASSERT(APPSESS_JOINED == eNewState);
            break;
        // done with the join process
        case APPSESS_JOINED:
            ASSERT(APPSESS_LEAVING == eNewState);
            break; 
        case APPSESS_LEAVING:
            ASSERT(APPSESS_LEFT == eNewState);
            break; 
        default:
            ASSERT(0);
            break;
        } // switch
    } // if
#endif

    m_eState = eNewState;
}


BOOL CAppletSession::IsJoining(void)
{
    return (APPSESS_INITIALIZED < m_eState && m_eState < APPSESS_JOINED);
}


void CAppletSession::HandleAttachUserConfirm(void)
{
    if (MCS_ATTACH_USER_CONFIRM == m_pTempMsg->eMsgType)
    {
        ASSERT(IsJoining());
        SetState(APPSESS_ATTACH_USER_CON);
        if (RESULT_SUCCESSFUL == m_pTempMsg->AttachUserConfirm.eResult)
        {
            m_uidMyself = m_pTempMsg->AttachUserConfirm.nUserID;

            // join my channel
            SetState(APPSESS_JOIN_MY_CHANNEL_REQ);
            T120Error rc = m_pMCSAppletSAP->ChannelJoin(m_uidMyself);
            if (T120_NO_ERROR == rc)
            {
                return;
            }
            SetError(rc);
            AbortJoin();
        }
        else
        {
            SetError(m_pTempMsg->AttachUserConfirm.eResult);
            AbortJoin();
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleAttachUserConfirm: expecting attach user confirm, invalid msg type=%u",
                    m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleTokenGrabConfirm(void)
{
    if (MCS_TOKEN_GRAB_CONFIRM == m_pTempMsg->eMsgType)
    {
        BOOL fImmediateNotification = m_JoinRequest.aResourceReqs[m_nArrayIndex].fImmediateNotification;
        ASSERT(IsJoining());
        switch (GetState())
        {
        case APPSESS_RESOURCE_REQ:
        	ASSERT(APPLET_GRAB_TOKEN_REQUEST == m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand);
            // remember the notification message if needed
            if (fImmediateNotification)
            {
                AddRef();
                SendMCSMessage(m_pTempMsg);
                if (0 == Release())
                {
                    WARNING_OUT(("CAppletSession::HandleTokenGrabConfirm: involuntary exit"));
                    return;
                }
            }

        	SetState(APPSESS_RESOURCE_CON);
            if (RESULT_SUCCESSFUL != m_pTempMsg->TokenConfirm.eResult)
            {
        	    m_JoinRequest.aResourceReqs[m_nArrayIndex].nTokenID = 0; // do not grab it
            }
            DoResourceRequests();
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleTokenGrabConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
}


void CAppletSession::HandleJoinChannelConfirm(void)
{
    if (MCS_CHANNEL_JOIN_CONFIRM == m_pTempMsg->eMsgType)
    {
        ASSERT(IsJoining());
        if (RESULT_SUCCESSFUL == m_pTempMsg->ChannelConfirm.eResult)
        {
            T120ChannelID nChannelID = m_pTempMsg->ChannelConfirm.nChannelID;

            switch (GetState())
            {
            case APPSESS_JOIN_MY_CHANNEL_REQ:
                if (nChannelID == m_uidMyself)
                {
                    SetState(APPSESS_JOIN_MY_CHANNEL_CON);
                    DoJoinStaticChannels();
                }
                else
                {
                    ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: unknown channel join confirm, chid=%x", (UINT) nChannelID));
                }
                break;

            case APPSESS_JOIN_STATIC_CHANNEL_REQ:
                if (nChannelID == m_JoinRequest.aStaticChannels[m_nArrayIndex])
                {
                    SetState(APPSESS_JOIN_STATIC_CHANNEL_CON);
                    DoJoinStaticChannels();
                }
                else
                {
                    ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: unknown channel join confirm, chid=%x", (UINT) nChannelID));
                }
                break;

            case APPSESS_RESOURCE_REQ:
            	// SetState(APPSESS_RESOURCE_CON);
                DoResourceRequests();
                break;

            default:
                ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: unknown state=%u", (UINT) GetState()));
                break;
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: mcs_result=%u", (UINT) m_pTempMsg->ChannelConfirm.eResult));
            SetError(m_pTempMsg->ChannelConfirm.eResult);
            AbortJoin();
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: invalid msg type=%u", (UINT) m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleEnrollConfirm(void)
{
    if (GCC_ENROLL_CONFIRM == m_pTempMsg->eMsgType)
    {
        m_sidMyself = m_pTempMsg->AppEnrollConfirm.sidMyself;
        m_eidMyself = m_pTempMsg->AppEnrollConfirm.eidMyself;
        m_nidMyself = m_pTempMsg->AppEnrollConfirm.nidMyself;

        switch (GetState())
        {
        case APPSESS_ACTIVELY_ENROLL_REQ:
            ASSERT(m_pTempMsg->AppEnrollConfirm.nConfID == m_nConfID);
            SetState(APPSESS_ACTIVELY_ENROLL_CON);
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->AppEnrollConfirm.nResult)
            {
                SetState(APPSESS_JOINED);
                SendJoinResult(GCC_RESULT_SUCCESSFUL);
            }
            else
            {
                ERROR_OUT(("CAppletSession::HandleEnrollConfirm: gcc_result=%u", (UINT) m_pTempMsg->AppEnrollConfirm.nResult));
                SetError(m_pTempMsg->AppEnrollConfirm.nResult);
                AbortJoin();
            }
            break;

        case APPSESS_INACTIVELY_ENROLL_REQ:
            ASSERT(m_pTempMsg->AppEnrollConfirm.nConfID == m_nConfID);
            SetState(APPSESS_INACTIVELY_ENROLL_CON);
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->AppEnrollConfirm.nResult)
            {
                // DoResourceRequests();
            }
            else
            {
                ERROR_OUT(("CAppletSession::HandleEnrollConfirm: gcc_result=%u", (UINT) m_pTempMsg->AppEnrollConfirm.nResult));
                SetError(m_pTempMsg->AppEnrollConfirm.nResult);
                AbortJoin();
            }
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleEnrollConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleEnrollConfirm: expecting enroll confirm, invalid msg type=%u",
                (UINT) m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleRegisterChannelConfirm(void)
{
    if (GCC_REGISTER_CHANNEL_CONFIRM == m_pTempMsg->eMsgType)
    {
        switch (GetState())
        {
        case APPSESS_RESOURCE_REQ:
            DoResourceRequests();
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleRegisterChannelConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleEnrollConfirm: expecting channel register confirm, invalid msg type=%u",
                (UINT) m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleRetrieveEntryConfirm(void)
{
    if (GCC_RETRIEVE_ENTRY_CONFIRM == m_pTempMsg->eMsgType)
    {
        switch (GetState())
        {
        case APPSESS_RESOURCE_REQ:
            DoResourceRequests();
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleRetrieveEntryConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleEnrollConfirm: expecting entry retrieve confirm, invalid msg type=%u",
                (UINT) m_pTempMsg->eMsgType));
    }
}




T120Error CAppletSession::DoEnroll
(
    BOOL        fEnroll,
    BOOL        fEnrollActively
)
{
    T120Error rc;
    T120RequestTag tag;
    GCCEnrollRequest Req;

    Req.pSessionKey = &m_JoinRequest.SessionKey;
    Req.fEnrollActively = fEnrollActively;
    Req.nUserID = m_uidMyself;
    Req.fConductingCapable = m_JoinRequest.fConductingCapable;
    Req.nStartupChannelType = m_JoinRequest.nStartupChannelType;
    Req.cNonCollapsedCaps = m_JoinRequest.cNonCollapsedCaps;
    Req.apNonCollapsedCaps = m_JoinRequest.apNonCollapsedCaps;
    Req.cCollapsedCaps = m_JoinRequest.cCollapsedCaps;
    Req.apCollapsedCaps = m_JoinRequest.apCollapsedCaps;
    Req.fEnroll = fEnroll;

    rc = m_pApplet->GetAppSap()->AppEnroll(m_nConfID, &Req, &tag);
    if (GCC_NO_ERROR == rc)
	{
		return GCC_NO_ERROR;
	}

	if (fEnroll)
	{
	    WARNING_OUT(("CAppletSession::DoEnroll: AppEnroll failed, rc=%u", (UINT) rc));
	    ASSERT(GCC_CONFERENCE_NOT_ESTABLISHED == rc);
		SetError(rc);
		AbortJoin();
	}
	else
	{
		// doing nothing because we don't care we fail to unenroll...
	}
    return rc;
}


void CAppletSession::DoJoinStaticChannels(void)
{
    T120Error rc;
    ASSERT(IsJoining());

    // set up array index
    switch (GetState())
    {
    case APPSESS_JOIN_MY_CHANNEL_CON:
        m_nArrayIndex = 0;
        break;
    case APPSESS_JOIN_STATIC_CHANNEL_CON:
        m_nArrayIndex++;
        break;
    default:
        ERROR_OUT(("CAppletSession::DoJoinStaticChannels: invalid state=%u", (UINT) GetState()));
        break;
    }

    if (m_nArrayIndex < m_JoinRequest.cStaticChannels &&
        NULL != m_JoinRequest.aStaticChannels)
    {
        SetState(APPSESS_JOIN_STATIC_CHANNEL_REQ);
        rc = m_pMCSAppletSAP->ChannelJoin(m_JoinRequest.aStaticChannels[m_nArrayIndex]);
        if (T120_NO_ERROR == rc)
		{
			return;
		}

		ERROR_OUT(("CAppletSession::DoJoinStaticChannels: ChannelJoin failed, rc=%u", (UINT) rc));
        SetError(rc);
        AbortJoin();
    }
    else
    {
		m_nArrayIndex = 0;
        if (m_JoinRequest.cResourceReqs == 0)
        {
            SetState(APPSESS_ACTIVELY_ENROLL_REQ);
            DoEnroll(TRUE, TRUE);
        }
        else
        {
            SetState(APPSESS_INACTIVELY_ENROLL_REQ);
            DoEnroll(TRUE, FALSE);
        }
    }
}


void CAppletSession::DoResourceRequests(void)
{
    //T120Error rc;
    BOOL fInitResourceState = FALSE;
    //ULONG i;

    ASSERT(IsJoining());

    // set up array index
    switch (GetState())
    {
    case APPSESS_INACTIVELY_ENROLL_CON:
        m_nArrayIndex = 0;
        fInitResourceState = TRUE;
        SetState(APPSESS_RESOURCE_REQ);
        break;
    case APPSESS_RESOURCE_REQ:
        // do nothing
        break;
    case APPSESS_RESOURCE_CON:
        m_nArrayIndex++;
        fInitResourceState = TRUE;
        SetState(APPSESS_RESOURCE_REQ);
        break;
    default:
        ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: invalid state=%u", (UINT) GetState()));
        break;
    }

    if (m_nArrayIndex < m_JoinRequest.cResourceReqs)
    {
        ASSERT(NULL != m_JoinRequest.aResourceReqs);
        switch (m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand)
        {
		case APPLET_GRAB_TOKEN_REQUEST:
			DoGrabTokenRequest();
			break;
        case APPLET_JOIN_DYNAMIC_CHANNEL:
            DoJoinDynamicChannels(fInitResourceState);
            break;
        default:
            ERROR_OUT(("CAppletSession::DoResourceRequests: should not get here, state=%u",
                        (UINT) m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand));
            break;
        }
    }
    else
    {
        SetState(APPSESS_ACTIVELY_ENROLL_REQ);
        DoEnroll(TRUE, TRUE);
    }
}

void CAppletSession::DoGrabTokenRequest(void)
{
    T120TokenRequest        Req;

    Req.eCommand = APPLET_GRAB_TOKEN;
    Req.nTokenID = m_JoinRequest.aResourceReqs[m_nArrayIndex].nTokenID;
	TokenRequest(&Req);
}

void CAppletSession::DoJoinDynamicChannels(BOOL fInitState)
{
    T120Error rc;
    //ULONG i;

    ASSERT(IsJoining());
    ASSERT(APPLET_JOIN_DYNAMIC_CHANNEL == m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand);

    if (fInitState)
    {
        m_eDynamicChannelJoinState = DCJS_INITIALIZED;
    }

    switch (m_eDynamicChannelJoinState)
    {
    case DCJS_INITIALIZED:
        // clean up all the dynamic channel id
        m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = 0;

        // start the first dynamic channel negotiation process
        // SetState(APPSESS_JOIN_DYNAMIC_CHANNEL_REQ);
        m_eDynamicChannelJoinState = DCJS_RETRIEVE_ENTRY_REQ;
        rc = m_pApplet->GetAppSap()->RegistryRetrieveEntry(m_nConfID,
                        &m_JoinRequest.aResourceReqs[m_nArrayIndex].RegKey);
        if (T120_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: RegistryRetrieveEntry failed, rc=%u", (UINT) rc));
            SetError(rc);
            AbortJoin();
        }
        break;

    case DCJS_EXISTING_CHANNEL_JOIN_REQ:
        if (MCS_CHANNEL_JOIN_CONFIRM == m_pTempMsg->eMsgType)
        {
            if (m_pTempMsg->ChannelConfirm.nChannelID == m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID)
            {
                m_eDynamicChannelJoinState = DCJS_EXISTING_CHANNEL_JOIN_CON;
                SetState(APPSESS_RESOURCE_CON);
                DoResourceRequests();
            }
            else
            {
                ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: unknown channel join confirm, chid=%x",
                            (UINT) m_pTempMsg->ChannelConfirm.nChannelID));
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting channel join confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

    case DCJS_NEW_CHANNEL_JOIN_REQ:
        if (MCS_CHANNEL_JOIN_CONFIRM == m_pTempMsg->eMsgType)
        {
            ASSERT(0 == m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
            m_eDynamicChannelJoinState = DCJS_NEW_CHANNEL_JOIN_CON;
            // remember the channel id
            m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = m_pTempMsg->ChannelConfirm.nChannelID;
            // try to register this channel
            m_eDynamicChannelJoinState = DCJS_REGISTER_CHANNEL_REQ;
            rc = m_pApplet->GetAppSap()->RegisterChannel(m_nConfID,
                        &m_JoinRequest.aResourceReqs[m_nArrayIndex].RegKey,
                        m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
            if (T120_NO_ERROR != rc)
            {
                ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: RegistryRetrieveEntry failed, rc=%u", (UINT) rc));
                SetError(rc);
                AbortJoin();
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting channel join confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

   case DCJS_RETRIEVE_ENTRY_REQ:
        if (GCC_RETRIEVE_ENTRY_CONFIRM == m_pTempMsg->eMsgType)
        {
            m_eDynamicChannelJoinState = DCJS_RETRIEVE_ENTRY_CON;
            ASSERT(m_nConfID == m_pTempMsg->RegistryConfirm.nConfID);
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->RegistryConfirm.nResult)
            {
                ASSERT(GCC_REGISTRY_CHANNEL_ID == m_pTempMsg->RegistryConfirm.pRegItem->item_type);
                ASSERT(0 != m_pTempMsg->RegistryConfirm.pRegItem->channel_id);
                // remember the existing channel ID
                m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = m_pTempMsg->RegistryConfirm.pRegItem->channel_id;
                // join this channel
                m_eDynamicChannelJoinState = DCJS_EXISTING_CHANNEL_JOIN_REQ;
                rc = m_pMCSAppletSAP->ChannelJoin(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                if (T120_NO_ERROR != rc)
                {
                    ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(%u) failed, rc=%u",
                        (UINT) m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID, (UINT) rc));
                    SetError(rc);
                    AbortJoin();
                }
            }
            else
            {
                ASSERT(GCC_RESULT_ENTRY_DOES_NOT_EXIST == m_pTempMsg->RegistryConfirm.nResult);
                ASSERT(0 == m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                // allocate a new channel
                m_eDynamicChannelJoinState = DCJS_NEW_CHANNEL_JOIN_REQ;
                rc = m_pMCSAppletSAP->ChannelJoin(0);
                if (T120_NO_ERROR != rc)
                {
                    ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(0) failed, rc=%u", (UINT) rc));
                    SetError(rc);
                    AbortJoin();
                }
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting entry retrieve confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

    case DCJS_REGISTER_CHANNEL_REQ:
        if (GCC_REGISTER_CHANNEL_CONFIRM == m_pTempMsg->eMsgType)
        {
            ASSERT(0 != m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
            m_eDynamicChannelJoinState = DCJS_REGISTER_CHANNEL_CON;
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->RegistryConfirm.nResult)
            {
                ASSERT(GCC_REGISTRY_CHANNEL_ID == m_pTempMsg->RegistryConfirm.pRegItem->item_type);
                ASSERT(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID == m_pTempMsg->RegistryConfirm.pRegItem->channel_id);
                SetState(APPSESS_RESOURCE_CON);
                DoResourceRequests();
            }
            else
            if (GCC_RESULT_ENTRY_ALREADY_EXISTS == m_pTempMsg->RegistryConfirm.nResult)
            {
                ASSERT(GCC_REGISTRY_CHANNEL_ID == m_pTempMsg->RegistryConfirm.pRegItem->item_type);
                // leave the old channel (DON'T CARE ABOUT THE CONFIRM)
                rc = m_pMCSAppletSAP->ChannelLeave(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                ASSERT(T120_NO_ERROR == rc);
                // remember the new channel id
                m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = m_pTempMsg->RegistryConfirm.pRegItem->channel_id;
                // join the new channel
                m_eDynamicChannelJoinState = DCJS_EXISTING_CHANNEL_JOIN_REQ;
                rc = m_pMCSAppletSAP->ChannelJoin(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                if (T120_NO_ERROR != rc)
                {
                    ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(0) failed, rc=%u", (UINT) rc));
                    SetError(rc);
                    AbortJoin();
                }
            }
            else
            {
                ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(0) failed, result=%u",
                            (UINT) m_pTempMsg->RegistryConfirm.nResult));
                SetError(m_pTempMsg->RegistryConfirm.nResult);
                AbortJoin();
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting channel register confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

    default:
        ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: should not get here, state=%u", (UINT) m_eDynamicChannelJoinState));
        break;
    }
}


void CAppletSession::AbortJoin(void)
{
    T120Result eResult = T120_RESULT_CHECK_T120_ERROR;
    T120Error eError = T12_ERROR_CHECK_T120_RESULT;

    switch (m_eErrorType)
    {
    case NONE_CHOSEN:
        ERROR_OUT(("CAppletSession::AbortJoin: NON_CHOSEN, impossible"));
        break;
    case ERROR_CHOSEN:
        eError = m_Error.eError;
        break;
    case RESULT_CHOSEN:
        eResult = m_Error.eResult;
        break;
    default:
        ERROR_OUT(("CAppletSession::AbortJoin: invalid err type=%u", (UINT) m_eErrorType));
        break;
    }

    // let's debug why the join process is aborted.
    WARNING_OUT(("CAppletSession::AbortJoin: eResult=%u, eError=%u", eResult, eError));
    ASSERT(GCC_CONFERENCE_NOT_ESTABLISHED == eError ||
           T12_ERROR_CHECK_T120_RESULT == eError);

    SendJoinResult(eResult, eError);
}


void CAppletSession::SendJoinResult(T120Result eResult, T120Error eError)
{
    T120AppletSessionMsg Msg;
    ::ZeroMemory(&Msg, sizeof(Msg));

    Msg.eMsgType = T120_JOIN_SESSION_CONFIRM;
    Msg.nConfID = m_nConfID;
    Msg.JoinSessionConfirm.eResult = eResult;
    Msg.JoinSessionConfirm.eError = eError;
    Msg.JoinSessionConfirm.pIAppletSession = (IT120AppletSession *) this;

    if (T120_RESULT_SUCCESSFUL == eResult)
    {
        Msg.JoinSessionConfirm.uidMyself = m_uidMyself;
        Msg.JoinSessionConfirm.sidMyself = m_sidMyself;
        Msg.JoinSessionConfirm.eidMyself = m_eidMyself;
        Msg.JoinSessionConfirm.nidMyself = m_nidMyself;
        Msg.JoinSessionConfirm.cResourceReqs = m_JoinRequest.cResourceReqs;
        Msg.JoinSessionConfirm.aResourceReqs = m_JoinRequest.aResourceReqs;
    }

    SendCallbackMessage(&Msg);
}



CApplet::CApplet
(
    T120Error   *pRetCode
)
:
    CRefCount(MAKE_STAMP_ID('C','A','p','l')),
    m_pfnCallback(NULL),
    m_pAppletContext(NULL),
    m_pAppSap(NULL),
    m_pAutoJoinReq(NULL),
    m_pAutoAppletSession(NULL)
{
    *pRetCode = ::GCC_CreateAppSap(&m_pAppSap, this, GCC_SapCallback);
}


CApplet::~CApplet(void)
{
    ASSERT(NULL == m_pfnCallback);
    ASSERT(NULL == m_pAppletContext);
    ASSERT(NULL == m_pAppSap);
}


void CApplet::ReleaseInterface(void)
{
	Unadvise();

    if (NULL != m_pAppSap)
    {
        m_pAppSap->ReleaseInterface();
        m_pAppSap = NULL;
    }

    Release();
}


void CApplet::Advise
(
    LPFN_APPLET_CB      pfnCallback,
    LPVOID              pAppletContext
)
{
    ASSERT(NULL == m_pfnCallback);
    ASSERT(NULL == m_pAppletContext);
    m_pfnCallback = pfnCallback;
    m_pAppletContext = pAppletContext;

	// this may incur permit to enroll indication
	g_pGCCController->RegisterApplet(this);
}


void CApplet::Unadvise(void)
{
    m_pfnCallback = NULL;
    m_pAppletContext = NULL;

    if (g_pGCCController)
    {
        g_pGCCController->UnregisterApplet(this);
    }
}


T120Error CApplet::RegisterAutoJoin
(
    T120JoinSessionRequest *pReq
)
{
    m_pAutoJoinReq = pReq;
    return T120_NO_ERROR;
}


void CApplet::UnregisterAutoJoin(void)
{
    m_pAutoJoinReq = NULL;
}


T120Error CApplet::CreateSession
(
    IT120AppletSession    **ppSession,
    T120ConfID              nConfID
)
{
    if (NULL != ppSession)
    {
        if (NULL != g_pGCCController->GetConfObject(nConfID))
        {
            if (! FindSessionByConfID(nConfID))
            {
                DBG_SAVE_FILE_LINE
                *ppSession = (IT120AppletSession *) new CAppletSession(this, nConfID);
                if (NULL != *ppSession)
                {
                    return T120_NO_ERROR;
                }

                ERROR_OUT(("CApplet::CreateSession: cannot create CAppletSession"));
                return T120_ALLOCATION_FAILURE;
            }

            WARNING_OUT(("CApplet::CreateSession: session already exists for nConfID=%u", (UINT) nConfID));
            return GCC_CONFERENCE_ALREADY_EXISTS;
        }

        WARNING_OUT(("CApplet::CreateSession: invalid conf, nConfID=%u", (UINT) nConfID));
        return GCC_INVALID_CONFERENCE;
    }

    ERROR_OUT(("CApplet::CreateSession: ppSession is null"));
    return T120_INVALID_PARAMETER;
}


void CApplet::SendCallbackMessage(T120AppletMsg *pMsg)
{
    if (NULL != m_pfnCallback)
    {
        pMsg->pAppletContext = m_pAppletContext;
        (*m_pfnCallback)(pMsg);
    }
}


void CApplet::GCCCallback
(
    T120AppletSessionMsg    *pMsg
)
{
    T120ConfID nConfID = pMsg->nConfID;
    ASSERT(0 != nConfID);

    if (GCC_PERMIT_TO_ENROLL_INDICATION == pMsg->eMsgType)
    {
        T120AppletMsg *p = (T120AppletMsg *) pMsg;
        if (p->PermitToEnrollInd.fPermissionGranted && NULL != m_pAutoJoinReq)
        {
            HandleAutoJoin(nConfID);
        }
        else
        {
            if (! p->PermitToEnrollInd.fPermissionGranted)
            {
                CAppletSession *pAppletSession = FindSessionByConfID(nConfID);
                if (NULL != pAppletSession)
                {
                    if (pAppletSession->IsJoining())
                    {
                        pAppletSession->SetError(GCC_CONFERENCE_NOT_ESTABLISHED);
                        pAppletSession->AbortJoin();
                    }
                }
            }
            SendCallbackMessage(p);
        }
    }
    else
    {
        CAppletSession *pAppletSession = FindSessionByConfID(nConfID);
        if (NULL != pAppletSession)
        {
            pAppletSession->GCCCallback(pMsg);
        }
        else
        {
            WARNING_OUT(("GCC_SapCallback: cannot find a session (%u) for this gcc message (%u)",
                        (UINT) nConfID, (UINT) pMsg->eMsgType));
        }
    }
}


void CALLBACK AutoJoinCallbackProc
(
    T120AppletSessionMsg *pMsg
)
{
    switch (pMsg->eMsgType)
    {
    case T120_JOIN_SESSION_CONFIRM:
        if (NULL != pMsg->pAppletContext)
        {
            pMsg->pSessionContext = NULL;
            ((CApplet *) pMsg->pAppletContext)->SendCallbackMessage((T120AppletMsg *) pMsg);
        }
        break;

    default:
        ERROR_OUT(("AutoJoinCallbackProc: invalid msg type=%u", pMsg->eMsgType));
        break;
    }
}


void CApplet::HandleAutoJoin
(
    T120ConfID      nConfID
)
{
    DBG_SAVE_FILE_LINE
    CAppletSession *pSession = new CAppletSession(this, nConfID);
    if (NULL != pSession)
    {
        T120Error rc;
        pSession->Advise(AutoJoinCallbackProc, this, pSession);
        rc = pSession->Join(m_pAutoJoinReq);
        if (rc != T120_NO_ERROR)
        {
            delete pSession;
        }
    }
}




CAppletSession * CSessionList::FindByConfID
(
    T120ConfID      nConfID
)
{
    CAppletSession *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (p->GetConfID() == nConfID)
        {
            return p;
        }
    }
    return NULL;
}



void CALLBACK GCC_SapCallback
(
    GCCAppSapMsg   *_pMsg
)
{
    T120AppletSessionMsg *pMsg = (T120AppletSessionMsg *) _pMsg;
    CApplet *pApplet = (CApplet *) pMsg->pAppletContext;
    ASSERT(NULL != pApplet);

    pApplet->GCCCallback(pMsg);
}


void CALLBACK MCS_SapCallback
(
    UINT            nMsg,
    LPARAM          Param1,
    LPVOID          Param2
)
{
    CAppletSession *pAppletSession = (CAppletSession *) Param2;
    ASSERT(NULL != pAppletSession);

    T120AppletSessionMsg Msg;
    ::ZeroMemory(&Msg, sizeof(Msg));
    Msg.eMsgType = (T120MessageType) nMsg;
    // Msg.pAppletContext = NULL;
    // Msg.pSessionContext = NULL;
    // Msg.nConfID = 0;

    // construct MCS message
    switch (Msg.eMsgType)
    {
    // send data
    case MCS_SEND_DATA_INDICATION:
    case MCS_UNIFORM_SEND_DATA_INDICATION:
        Msg.SendDataInd = * (SendDataIndicationPDU *) Param1;
        break;

   // channel confirm
    case MCS_CHANNEL_JOIN_CONFIRM:
    case MCS_CHANNEL_CONVENE_CONFIRM:
        Msg.ChannelConfirm.eResult = (T120Result) HIWORD(Param1);
        Msg.ChannelConfirm.nChannelID = LOWORD(Param1);
        break;
    // channel indication
    case MCS_CHANNEL_LEAVE_INDICATION:
    case MCS_CHANNEL_DISBAND_INDICATION:
    case MCS_CHANNEL_ADMIT_INDICATION:
    case MCS_CHANNEL_EXPEL_INDICATION:
        Msg.ChannelInd.nChannelID = LOWORD(Param1);
        Msg.ChannelInd.eReason = (T120Reason) HIWORD(Param1);
        break;
    // token confirm
    case MCS_TOKEN_GRAB_CONFIRM:
    case MCS_TOKEN_INHIBIT_CONFIRM:
    case MCS_TOKEN_GIVE_CONFIRM:
    case MCS_TOKEN_RELEASE_CONFIRM:
    case MCS_TOKEN_TEST_CONFIRM:
        Msg.TokenConfirm.nTokenID = LOWORD(Param1);
        Msg.TokenConfirm.eResult = (T120Result) HIWORD(Param1);
        break;
    // token indication
    case MCS_TOKEN_GIVE_INDICATION:
    case MCS_TOKEN_PLEASE_INDICATION:
    case MCS_TOKEN_RELEASE_INDICATION:
        Msg.TokenInd.nTokenID = LOWORD(Param1);
        Msg.TokenInd.eReason = (T120Reason) HIWORD(Param1);
        break;
    // user
    case MCS_ATTACH_USER_CONFIRM:
        Msg.AttachUserConfirm.nUserID = LOWORD(Param1);
        Msg.AttachUserConfirm.eResult = (T120Result) HIWORD(Param1);
        break;
    case MCS_DETACH_USER_INDICATION:
        Msg.DetachUserInd.nUserID = LOWORD(Param1);
        Msg.DetachUserInd.eReason = (T120Reason) HIWORD(Param1);
        break;
    default:
        WARNING_OUT(("MCS_SapCallback: Ignore MCS message, type=%u", Msg.eMsgType));
        break;
    }

    pAppletSession->MCSCallback(&Msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\t120app.h ===
#ifndef _T120_APPLET_SAP_
#define _T120_APPLET_SAP_

/*
 * include files 
 */
#include "it120app.h"
#include "appsap.h"

class CApplet;

typedef enum
{
    APPSESS_INITIALIZED,
    APPSESS_ATTACH_USER_REQ,
    APPSESS_ATTACH_USER_CON,
    APPSESS_JOIN_MY_CHANNEL_REQ,
    APPSESS_JOIN_MY_CHANNEL_CON,
    APPSESS_JOIN_STATIC_CHANNEL_REQ,
    APPSESS_JOIN_STATIC_CHANNEL_CON, // may go back to APPSESS_JOIN_STATIC_CHANNEL_REQ
    APPSESS_INACTIVELY_ENROLL_REQ,
    APPSESS_INACTIVELY_ENROLL_CON,
    APPSESS_RESOURCE_REQ,
    APPSESS_RESOURCE_CON, // may go back to APPSESS_RESOURCE_REQ
    APPSESS_ACTIVELY_ENROLL_REQ,
    APPSESS_ACTIVELY_ENROLL_CON,
    APPSESS_JOINED,
    APPSESS_LEAVING,
    APPSESS_LEFT,
}
    APPLET_SESSION_STATE;


typedef enum
{
    NONE_CHOSEN,
    ERROR_CHOSEN,
    RESULT_CHOSEN,
}
    SESSION_ERROR_TYPE;


typedef enum
{
    DCJS_INITIALIZED,
    DCJS_RETRIEVE_ENTRY_REQ,
    DCJS_RETRIEVE_ENTRY_CON,
    DCJS_EXISTING_CHANNEL_JOIN_REQ,
    DCJS_EXISTING_CHANNEL_JOIN_CON,
    DCJS_NEW_CHANNEL_JOIN_REQ,
    DCJS_NEW_CHANNEL_JOIN_CON,
    DCJS_REGISTER_CHANNEL_REQ,
    DCJS_REGISTER_CHANNEL_CON,
}
    DYNCHNL_JOIN_STATE;


class CAppletSession : public IT120AppletSession, public CRefCount
{
    friend class CApplet;
    friend void CALLBACK MCS_SapCallback(UINT, LPARAM, LPVOID);
    friend void CALLBACK GCC_SapCallback(GCCAppSapMsg *);

public:

    CAppletSession(CApplet *, T120ConfID);
    ~CAppletSession(void);

    /* exit the conference */

    STDMETHOD_(void, ReleaseInterface) (THIS);

    STDMETHOD_(void, Advise) (THIS_
                    IN      LPFN_APPLET_SESSION_CB pfnCallback,
                    IN      LPVOID  pAppletContext,
                    IN      LPVOID  pSessionContext);

    STDMETHOD_(void, Unadvise) (THIS);

    /* basic info */

    STDMETHOD_(T120ConfID, GetConfID) (THIS) { return m_nConfID; }

    STDMETHOD_(BOOL, IsThisNodeTopProvider) (THIS);

    STDMETHOD_(T120NodeID, GetTopProvider) (THIS);

    /* join/leave */

    STDMETHOD_(T120Error, Join) (THIS_
                    IN      T120JoinSessionRequest *);

    STDMETHOD_(void, Leave) (THIS);

    /* send data */

    STDMETHOD_(T120Error, AllocateSendDataBuffer) (THIS_
                IN      ULONG,
                OUT     void **);

    STDMETHOD_(void, FreeSendDataBuffer) (THIS_
                IN      void *);

    STDMETHOD_(T120Error, SendData) (THIS_
                IN      DataRequestType,
                IN      T120ChannelID,
                IN      T120Priority,
                IN		LPBYTE,
                IN		ULONG,
                IN		SendDataFlags);

    /* ------ ADVANCED METHODS ---- */

    STDMETHOD_(T120Error, InvokeApplet) (THIS_
                IN      GCCAppProtEntityList *,
                IN      GCCSimpleNodeList *,
                OUT     T120RequestTag *);

    STDMETHOD_(T120Error, InquireRoster) (THIS_
                IN      GCCSessionKey *);

    /* ------ registry services ------ */

    STDMETHOD_(T120Error, RegistryRequest) (THIS_
                IN      T120RegistryRequest *);

    /* ------ channel services ------ */

    STDMETHOD_(T120Error, ChannelRequest) (THIS_
                IN      T120ChannelRequest *);

    /* ------ token services ------ */

    STDMETHOD_(T120Error, TokenRequest) (THIS_
                IN      T120TokenRequest *);

protected:

    void GCCCallback(T120AppletSessionMsg *);
    void MCSCallback(T120AppletSessionMsg *);

    BOOL IsJoining(void);

    //
    // handy functions for the join process
    //
    void SetTempMsg(T120AppletSessionMsg *pMsg) { m_pTempMsg = pMsg; }
    void ClearTempMsg(void) { m_pTempMsg = NULL; }
    void HandleAttachUserConfirm(void);
    void HandleJoinChannelConfirm(void);
    void HandleEnrollConfirm(void);
    void HandleRegisterChannelConfirm(void);
    void HandleRetrieveEntryConfirm(void);
	void HandleTokenGrabConfirm(void);

private:

    void ClearError(void) { m_eErrorType = NONE_CHOSEN; }
    void SetError(T120Error err) { m_eErrorType = ERROR_CHOSEN; m_Error.eError = err; }
    void SetError(T120Result res) { m_eErrorType = RESULT_CHOSEN; m_Error.eResult = res; }

    void SetState(APPLET_SESSION_STATE eState);
    APPLET_SESSION_STATE GetState(void) { return m_eState; }

    void SendMCSMessage(T120AppletSessionMsg *);
    void SendCallbackMessage(T120AppletSessionMsg *);

    T120Error DoEnroll(BOOL fEnroll, BOOL fEnrollActively = FALSE);
    void DoJoinStaticChannels(void);
    void DoResourceRequests(void);
    void DoJoinDynamicChannels(BOOL fInitState);
    void DoJoined(void);
	void DoGrabTokenRequest(void);

    void AbortJoin(void);
    void SendJoinResult(T120Result eResult = T120_RESULT_SUCCESSFUL, T120Error eErrorCode = T120_NO_ERROR);

    void FreeJoinRequest(BOOL fZeroOut);

private:

    // remmember the context
    LPVOID                  m_pAppletContext; 
    LPVOID                  m_pSessionContext; 
    LPFN_APPLET_SESSION_CB  m_pfnCallback;

    // parent applet object
    CApplet                *m_pApplet;

    // tentative sap pointers
    IMCSSap                *m_pMCSAppletSAP;

    // information about myself
    T120ConfID              m_nConfID;
    T120UserID              m_uidMyself;
    T120SessionID           m_sidMyself;
    T120EntityID            m_eidMyself;
    T120NodeID              m_nidMyself;

    // join state
    APPLET_SESSION_STATE    m_eState;
    ULONG                   m_nArrayIndex;

    // error handling
    SESSION_ERROR_TYPE      m_eErrorType;
    union
    {
        T120Error   eError;
        T120Result  eResult;
    }                       m_Error;

    // join conference request copy
    T120JoinSessionRequest  m_JoinRequest; // valid during join session
    BOOL                    m_fMCSFreeDataIndBuffer;

    // dynamic channels join state
    BOOL                    m_fFirstRoster;
    DYNCHNL_JOIN_STATE      m_eDynamicChannelJoinState;
    T120AppletSessionMsg   *m_pTempMsg;
};


class CSessionList : public CList
{
    DEFINE_CLIST(CSessionList, CAppletSession*)
    CAppletSession *FindByConfID(T120ConfID);
};


class CApplet : public IT120Applet, public CRefCount
{
    friend void CALLBACK GCC_SapCallback(GCCAppSapMsg *);

public:

    CApplet(T120Error *);
    ~CApplet(void);

    STDMETHOD_(void, ReleaseInterface) (THIS);

    STDMETHOD_(void, Advise) (THIS_
                    IN      LPFN_APPLET_CB  pfnCallback,
                    IN      LPVOID          pAppletContext);

    STDMETHOD_(void, Unadvise) (THIS);

    /* ------ Auto Join ------ */

    STDMETHOD_(T120Error, RegisterAutoJoin) (THIS_
                    IN      T120JoinSessionRequest *);

    STDMETHOD_(void, UnregisterAutoJoin) (THIS);

    /* ------ Session ------ */

    STDMETHOD_(T120Error, CreateSession) (THIS_
                    OUT     IT120AppletSession **,
                    IN      T120ConfID);


    void SendCallbackMessage(T120AppletMsg *pMsg);

    IGCCAppSap *GetAppSap(void) { return m_pAppSap; }

    void RegisterSession(CAppletSession *p) { m_SessionList.Append(p); }
    void UnregisterSession(CAppletSession *p) { m_SessionList.Remove(p); }

    CAppletSession *FindSessionByConfID(T120ConfID nConfID) { return m_SessionList.FindByConfID(nConfID); }

protected:

    void GCCCallback(T120AppletSessionMsg *);
    void HandleAutoJoin(T120ConfID);

private:

    LPFN_APPLET_CB          m_pfnCallback;
    LPVOID                  m_pAppletContext;
    IGCCAppSap             *m_pAppSap;
    CSessionList            m_SessionList;

    // for auto join
    T120JoinSessionRequest *m_pAutoJoinReq;
    CAppletSession         *m_pAutoAppletSession;
};


#endif // _T120_APPLET_SAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\tprtctrl.h ===
/*	Tprtctrl.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the transport for Winsock over TCP.
 *
 *		This module controls making and breaking socket connections. When the
 *		transport creates or detects a connection, Transprt.cpp is notified.
 *		It then instantiates a connection object which tracks the socket until
 *		it is destroyed.  The TCP stack notifies Transprt.cpp when a socket
 *		connection is up and running. It also notifies us if the link is broken
 *		for some reason. As a result, the Tprtctrl module will notify the user
 *		of new or broken connections.
 *
 *		When the user wants to make a data request of a specific transport
 *		connection, this module maps the connection id to a socket number.  The
 *		data request is passed on to TCP.  Data Indications are passed
 *		to the user by ReadRequest().
 *
 *	USER CALLBACKS:
 *		The user communicates with this DLL by making calls directly to the
 *		DLL.  The DLL communicates with the user by issuing callbacks.
 *		The TInitialize() call accepts as a parameter, a callback address and
 *		a user defined variable.  When a significant event occurs in the DLL,
 *		the DLL will jump to the callback address.  The first parameter of
 *		the callback is the message.  This could be a CONNECT_INDICATION, 
 *		DISCONNECT_INDICATION, or any number of significant events.  The
 *		second parameter is a message specific parameter.  The third 
 *		parameter is the user defined variable that was passed in during
 *		the TInitialize() function.  See the MCATTPRT.h interface file
 *		for a complete description of the callback messages.
 *
 *	MAKING A CALL:
 *		After the initialization has been done, the user will eventually,
 *		want to attempt a connection. The user issues a TConnectRequest() call 
 *		with the IP address of the remote location. The connection request 
 *		is passed on to the Winsock layer. It eventually issues FD_CONNECT to
 *		our window to say that the connection was successful.
 *
 *	RECEIVING A CALL:
 *		If we receive a call from a remote location, Winsock notifies
 *		us with FD_ACCEPT.  We then create a new connection object
 *		associated with the new socket.
 *
 *	SENDING PACKETS:
 *		To send data to the remote location, use the DataRequest() function
 *		call.  This module will pass the packet to the socket that it is
 *		associated with.  The send may actually occur after the call has 
 *		returned to the user.
 *
 *	RECEIVING PACKETS:
 *		The user receives packets by DATA_INDICATION callbacks.  When Winsock
 *		notifies us with a FD_READ, we issue a recv() to receive any new
 *		packets. If a packet is complete, we issue a DATA_INDICATION
 *		callback to the user with the socket handle, the address 
 *		of the packet, and the packet length.
 *
 *	DISCONNECTING A TRANSPORT:
 *		To disconnect a transport connection, use the DisconnectRequest()
 *		function.  After the link has been brought down, we perform a 
 *		callback to the user to verify the disconnect.
 *
 */
#ifndef	_TRANSPORT_CONTROLLER_
#define	_TRANSPORT_CONTROLLER_

/* Header for a RFC1006 packet */
typedef struct _rfc_tag
{
	UChar	Version;		/* Should be RFC1006_VERSION_NUMBER (3) */
	UChar	Reserved;		/* Must be 0x00 */
	UChar	msbPacketSize;	/* msb of packet size, including RFC header */
	UChar	lsbPacketSize;	/* lsb of packet size, including RFC header */
} RFC_HEADER;

/* Header for X224 data packet */
typedef struct _data_packet_tag
{
	RFC_HEADER	rfc;		/* RFC1006 packet header */
	UChar	HeaderSize;		/* Must be 0x02, for data packets */
	UChar	PacketType;		/* Must be DATA_PACKET, for data packets */
	UChar	FinalPacket;	/* EOT_BIT or 0 */
} X224_DATA_PACKET;

#include "socket.h"

/* Connection Info (used for both CONNECTION_REQUEST and CONNECTION_CONFIRM) */
typedef struct _connect_common_tag
{
	UChar	PacketType;		/* CONNECTION_REQUEST_PACKET or CONFIRM_PACKET */
	UChar	msbDest;		/* msb of destination-side (answering) socket id */
	UChar	lsbDest;		/* lsb of destination-side (answering) socket id */
	UChar	msbSrc;			/* msb of source-side (initiating) socket id */
	UChar	lsbSrc;			/* lsb of source-side (initiating) socket id */
	UChar	DataClass;		/* Must be 0x00 */
} X224_CONNECT_COMMON;

/* Transport variable field info type and size. */
typedef struct _t_variable_field_info
{
	UChar	InfoType;
	UChar	InfoSize;
} X224_VARIABLE_INFO;

/* TPDU Arbitration Info (not used with CONNECTION_CONFIRM) */
typedef struct _tpdu_info_tag
{
	UChar	InfoType;		/* Must be TPDU_SIZE (192) */
	UChar	InfoSize;		/* Must be 1 */
	UChar	Info;			/* Requested PDU Size (default: 10, or 1K bytes) */
} X224_TPDU_INFO;

/* Minimal Connection Request/Confirm packet */
typedef struct _connect_tag
{
	RFC_HEADER			rfc;	/* RFC1006 packet header */
	UChar	HeaderSize;			
	X224_CONNECT_COMMON	conn;	/* Connection Info */
} X224_CONNECT;

typedef X224_CONNECT X224_CR_FIXED;
typedef X224_CONNECT X224_CC_FIXED;

typedef struct _disconnect_info_tag
{
	UChar	PacketType;		/* Must be DISCONNECT_REQUEST_PACKET */
	UChar	msbDest;		
	UChar	lsbDest;
	UChar	msbSrc;
	UChar	lsbSrc;
	UChar	reason;			/* DR Reason Code */
} X224_DISCONN;

typedef struct _disconnect_request_fixed
{
    RFC_HEADER      rfc;
    UChar           HeaderSize;
    X224_DISCONN    disconn;
} X224_DR_FIXED;

#define X224_SIZE_OFFSET		2

#define	UNK					0	// Used to initialize fields in static
								// data structures that will be initialized
								// later.

/* 2^DEFAULT_TPDU_SIZE is the default X224 packet size we request */
#define DEFAULT_TPDU_SIZE		13	/* 2^13 is 8K packet size */
#define	LOWEST_TPDU_SIZE		7	/* 2^7 is 128 bytes */
#define	HIGHEST_TPDU_SIZE		20	/* 2^20 is ... too big */
#define	DEFAULT_MAX_X224_SIZE	(1 << DEFAULT_TPDU_SIZE)

/* Function definitions */
TransportError	ConnectRequest (TransportAddress transport_address, BOOL fSecure, PTransportConnection pXprtConn);
BOOL			ConnectResponse (TransportConnection XprtConn);
void			DisconnectRequest (TransportConnection XprtConn, ULONG ulNotify);
TransportError	DataRequest (	TransportConnection	XprtConn,
								PSimplePacket	packet);
void 			SendX224ConnectRequest (TransportConnection);
void			EnableReceiver (Void);
void			PurgeRequest (TransportConnection	XprtConn);
void 			AcceptCall (TransportType);
void 			AcceptCall (TransportConnection);
void 			ReadRequest(TransportConnection);
void            ReadRequestEx(TransportConnection);
TransportError	FlushSendBuffer(PSocket pSocket, LPBYTE buffer, UINT length);
#ifdef TSTATUS_INDICATION
Void 			SendStatusMessage(	PChar RemoteAddress,
					  				TransportState state,
					  				UInt message_id);
#endif
void			QoSLock(Void);
void			QoSUnlock(Void);
void 			ShutdownAndClose (TransportConnection, BOOL fShutdown, int how );
TransportError 	GetLocalAddress(TransportConnection	XprtConn,
								TransportAddress	address,
								int	*	size);
								
/* The TCP message window procedure (processes all Windows messages) */
LRESULT 		WindowProcedure (HWND, UINT, WPARAM, LPARAM);

/* RFC definitions */
#define	RFC1006_VERSION_NUMBER		3
#define RFC1006_VERSION_SHIFTED_LEFT	0x03000000L		/* Optimizes AddRFCHeader */

/* Packet types */
#define	CONNECTION_REQUEST_PACKET	0xe0
#define	CONNECTION_CONFIRM_PACKET	0xd0
#define	DISCONNECT_REQUEST_PACKET	0x80
#define	ERROR_PACKET				0x70
#define	DATA_PACKET					0xf0

#define	TPDU_SIZE					0xc0
#define T_SELECTOR					0xc1
#define T_SELECTOR_2                                    0xc2
/* X224 definitions */
#define	EOT_BIT						0x80

/* Macro to fill-in RFC header at specified buffer location */
#define	AddRFCSize(ptr, size)	{ \
	ASSERT((size) < 65536L ); \
	((LPBYTE) (ptr))[X224_SIZE_OFFSET] = (BYTE) ((size) >> 8); \
	((LPBYTE) (ptr))[X224_SIZE_OFFSET + 1] = (BYTE) (size); }

#endif	/* _TRANSPORT_CONTROLLER_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\tprtsec.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);

// #define FORCE_SSL3_NEGOTIATION

#include "tprtsec.h"
#include "nmmkcert.h"

#define STRSAFE_NO_DEPRECATE 1
#include <strsafe.h>

/*    Tprtsec.cpp
 *
 *    Copyright (c) 1997 by Microsoft Corporation
 *
 *    Abstract:
 *        This module maintains security for the TCP transport.
 *
 */

/* External definitions */
extern HINSTANCE            g_hDllInst;

/*
 *    The following array contains a template for the X.224 data header.
 *    The 5 of the 7 bytes that it initializes are actually sent to the
 *    wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *    The array is only used when we encode a data PDU.
 */
extern UChar g_X224Header[];


#ifdef DEBUG
//#define TESTHACKS // DANGER! don't turn on in public build!
//#define DUMP
//#define DUMPCERTS
//#undef TRACE_OUT
//#define TRACE_OUT WARNING_OUT
#endif //DEBUG

#define    SZSECPKG    UNISP_NAME_A

#define    ISC_REQ_FLAGS (    ISC_REQ_SEQUENCE_DETECT |\
                        ISC_REQ_REPLAY_DETECT |\
                        ISC_REQ_CONFIDENTIALITY |\
                        ISC_REQ_EXTENDED_ERROR |\
                        ISC_REQ_ALLOCATE_MEMORY |\
                        ISC_REQ_STREAM)

#define    ASC_REQ_FLAGS (    ASC_REQ_SEQUENCE_DETECT |\
                        ASC_REQ_REPLAY_DETECT |\
                        ASC_REQ_CONFIDENTIALITY |\
                        ASC_REQ_EXTENDED_ERROR |\
                        ASC_REQ_ALLOCATE_MEMORY |\
                        ASC_REQ_MUTUAL_AUTH |\
                        ASC_REQ_STREAM)


#if defined(DUMP) || defined(DUMPCERTS)

#define MAX_DUMP_BYTES    512

void dumpbytes(PSTR szComment, PBYTE p, int cb)
{
    int i,j;
    char buf[80];
    char buf2[80];
    DWORD dwCheckSum = 0;
    int cbShow = min(MAX_DUMP_BYTES,cb);

    for (i=0; i<cb; i++)
        dwCheckSum += p[i];

    wsprintf(buf,"%s (%d bytes, checksum %x):",
        szComment? szComment : "unknown", cb, dwCheckSum);
    OutputDebugString(buf);
    WARNING_OUT(("%s",buf));
    OutputDebugString("\n\r");

    for (i=0; i<cbShow/16; i++)
    {
        wsprintf(buf, "%08x: ", (DWORD) &p[(i*16)] );
        for (j=0; j<16; j++)
        {
            wsprintf(buf2," %02x", (int) (unsigned char) p[(i*16)+j] );
            lstrcat ( buf, buf2 );
        }
        WARNING_OUT(("%s",buf));
        lstrcat ( buf, "\n\r");
        OutputDebugString(buf);
    }
    if ( cbShow%16 )
    {
        wsprintf(buf, "%08x: ", (DWORD) &p[(i*16)] );
        for (j=0; j<cbShow%16; j++)
        {
            wsprintf(buf2," %02x", (int) (unsigned char) p[(i*16)+j] );
            lstrcat ( buf, buf2 );
        }
        WARNING_OUT(("%s",buf));
        lstrcat(buf,"\n\r");
        OutputDebugString(buf);
    }
    if ( cbShow < cb )
    {
        OutputDebugString("...\n\r");
        WARNING_OUT(("..."));
    }
}
#endif //DUMP or DUMPCERTS


///////////////////////////////////////////////////////////////////////////
// Security Interface
///////////////////////////////////////////////////////////////////////////




SecurityInterface::SecurityInterface(BOOL bService) :
                LastError(TPRTSEC_NOERROR),
                bInboundCredentialValid(FALSE),
                bOutboundCredentialValid(FALSE),
                m_pbEncodedCert(NULL),
                m_cbEncodedCert(0),
                hSecurityDll(NULL),
                pfnTable(NULL),
                bInServiceContext(bService)
{
}

SecurityInterface::~SecurityInterface(VOID)
{
    if ( pfnTable && bInboundCredentialValid )
    {
        pfnTable->FreeCredentialHandle ( &hInboundCredential );
    }

    if ( pfnTable && bOutboundCredentialValid )
    {
        pfnTable->FreeCredentialHandle ( &hOutboundCredential );
    }

    if ( NULL != m_pbEncodedCert )
    {
        delete m_pbEncodedCert;
    }

    if ( NULL != hSecurityDll )
    {
        FreeLibrary( hSecurityDll );
    }
}

#ifdef DUMPCERTS
VOID DumpCertStore ( SecurityInterface * pSI, char * sz, HCERTSTORE hStore)
{
    WARNING_OUT(("************ %s *************", sz));
    PCCERT_CONTEXT pC = NULL;
    int i = 0;
    char buf[256];

    while ( pC = CertEnumCertificatesInStore(
                                    hStore, (PCERT_CONTEXT)pC ))
    {
        WARNING_OUT(("----------- Entry %d: ----------------", i));

        // Dump stuff in pC->pCertInfo
        //DWORD                       dwVersion;
        //CRYPT_INTEGER_BLOB          SerialNumber;
        //CRYPT_ALGORITHM_IDENTIFIER  SignatureAlgorithm;
        //CERT_NAME_BLOB              Issuer;
        //FILETIME                    NotBefore;
        //FILETIME                    NotAfter;
        //CERT_NAME_BLOB              Subject;
        //CERT_PUBLIC_KEY_INFO        SubjectPublicKeyInfo;
        //CRYPT_BIT_BLOB              IssuerUniqueId;
        //CRYPT_BIT_BLOB              SubjectUniqueId;
        //DWORD                       cExtension;
        //PCERT_EXTENSION             rgExtension;

        WARNING_OUT(("dwVersion: %x", pC->pCertInfo->dwVersion));

        dumpbytes("SerialNumber",
            pC->pCertInfo->SerialNumber.pbData,
            pC->pCertInfo->SerialNumber.cbData );

        WARNING_OUT(("SignatureAlgorithm (name): %s",
            pC->pCertInfo->SignatureAlgorithm.pszObjId ));

        CertNameToStr( pC->dwCertEncodingType, &pC->pCertInfo->Issuer,
            CERT_X500_NAME_STR, buf, sizeof(buf) );
        WARNING_OUT(("Issuer: %s", buf ));

        WARNING_OUT(("NotBefore: %x,%x",
            pC->pCertInfo->NotBefore.dwLowDateTime,
            pC->pCertInfo->NotBefore.dwHighDateTime ));
        WARNING_OUT(("NotAfter: %x,%x",
            pC->pCertInfo->NotAfter.dwLowDateTime,
            pC->pCertInfo->NotAfter.dwHighDateTime ));

        CertNameToStr( pC->dwCertEncodingType, &pC->pCertInfo->Subject,
            CERT_X500_NAME_STR, buf, sizeof(buf) );
        WARNING_OUT(("Subject: %s", buf ));

        WARNING_OUT(("<stuff omitted for now>"));

        dumpbytes("IssuerUniqueId",
            pC->pCertInfo->IssuerUniqueId.pbData,
            pC->pCertInfo->IssuerUniqueId.cbData );

        dumpbytes("SubjectUniqueId",
            pC->pCertInfo->SubjectUniqueId.pbData,
            pC->pCertInfo->SubjectUniqueId.cbData );

        WARNING_OUT(("cExtension: %x", pC->pCertInfo->cExtension ));
        WARNING_OUT(("<stuff omitted for now>"));

        i++;
    }
}
#endif // DUMPCERTS

TransportSecurityError SecurityInterface::InitializeCreds(
                        PCCERT_CONTEXT pCertContext )
{
    SECURITY_STATUS ss;
    SCHANNEL_CRED CredData;

    CredHandle hNewInboundCred;
    CredHandle hNewOutboundCred;

    //
    // Are we going to create new creds or just clean up?
    //

    if ( NULL != pCertContext )
    {
        ZeroMemory(&CredData, sizeof(CredData));
        CredData.dwVersion = SCHANNEL_CRED_VERSION;

        #ifdef FORCE_SSL3_NEGOTIATION
        CredData.grbitEnabledProtocols = SP_PROT_SSL3_CLIENT |
                                    SP_PROT_SSL3_SERVER;
        #endif // FORCE_SSL3_NEGOTIATION

        CredData.dwFlags = SCH_CRED_NO_SERVERNAME_CHECK |
                            SCH_CRED_NO_DEFAULT_CREDS |
                            SCH_CRED_MANUAL_CRED_VALIDATION;

        CredData.cCreds = 1;
        CredData.paCred = &pCertContext;

        // Acquire client and server credential handles

        ss = pfnTable->AcquireCredentialsHandle (
            NULL,
            SZSECPKG,
            SECPKG_CRED_INBOUND,
            NULL,
            &CredData,
            NULL,
            NULL,
            &hNewInboundCred,
            &tsExpiry );

        if ( SEC_E_OK != ss )
        {
            WARNING_OUT(("AcquireCredentialsHandle (inbound) failed %lx", ss));
            LastError = TPRTSEC_SSPIFAIL;
            goto error;
        }

        ss = pfnTable->AcquireCredentialsHandle (
            NULL,
            SZSECPKG,
            SECPKG_CRED_OUTBOUND,
            NULL,
            &CredData,
            NULL,
            NULL,
            &hNewOutboundCred,
            &tsExpiry );

        if ( SEC_E_OK != ss )
        {
            WARNING_OUT(("AcquireCredentialsHandle (outbound) failed %lx", ss));
            pfnTable->FreeCredentialHandle( &hNewInboundCred );
            LastError = TPRTSEC_SSPIFAIL;
            goto error;
        }

        // Empty the SSL cache
        if (pfn_SslEmptyCache)
        {
            pfn_SslEmptyCache();
        }

        // This member can be called even when we're already initialized, as
        // when the user chooses a different cert and we need to build new
        // credentials based on it. Clear out the old information as necessary:

        if ( NULL != m_pbEncodedCert )
        {
            delete m_pbEncodedCert;
            m_pbEncodedCert = NULL;
        }
    }

    if ( bInboundCredentialValid )
        pfnTable->FreeCredentialHandle ( &hInboundCredential );

    if ( bOutboundCredentialValid )
        pfnTable->FreeCredentialHandle ( &hOutboundCredential );

    if ( NULL != pCertContext )
    {
        hInboundCredential = hNewInboundCred;
        hOutboundCredential = hNewOutboundCred;
        bInboundCredentialValid = TRUE;
        bOutboundCredentialValid = TRUE;

        //
        // Save the cert name for later use
        //

        ASSERT( NULL == m_pbEncodedCert );
        m_pbEncodedCert = new BYTE[pCertContext->cbCertEncoded];

        if ( NULL == m_pbEncodedCert )
        {
            ERROR_OUT(("Error allocating data for encoded Cert"));
            goto error;
        }

        memcpy( m_pbEncodedCert, pCertContext->pbCertEncoded,
                                pCertContext->cbCertEncoded );

        ASSERT(pCertContext->cbCertEncoded);
        m_cbEncodedCert = pCertContext->cbCertEncoded;
    }
    else
    {
        bInboundCredentialValid = FALSE;
        bOutboundCredentialValid = FALSE;
    }

    LastError = TPRTSEC_NOERROR;

error:

    return LastError;
}

TransportSecurityError SecurityInterface::Initialize(VOID)
{
    TRACE_OUT(("Initializing security interface"));

    // Load the security provider DLL

    hSecurityDll = LoadLibrary("SCHANNEL");

    if ( !hSecurityDll )
    {
        ERROR_OUT(("Loadlib schannel.dll failed"));
        LastError = TPRTSEC_NODLL;
        goto error;
    }

    // Get the initialization entrypoint
    pfnInitSecurityInterface = (INIT_SECURITY_INTERFACE)GetProcAddress(
                                hSecurityDll,
                                SECURITY_ENTRYPOINT );

    if ( NULL == pfnInitSecurityInterface )
    {
        ERROR_OUT(("GetProcAddr %s failed", SECURITY_ENTRYPOINT));
        LastError = TPRTSEC_NOENTRYPT;
        goto error;
    }

    // Get the SSPI function table
    pfnTable = (*pfnInitSecurityInterface)();

    if ( NULL == pfnTable )
    {
        ERROR_OUT(("InitializeSecurityProvider failed"));
        LastError = TPRTSEC_SSPIFAIL;
        goto error;
    }

    pfn_SslEmptyCache = (PFN_SSL_EMPTY_CACHE)GetProcAddress(hSecurityDll, SZ_SSLEMPTYCACHE);
    if ( NULL == pfnInitSecurityInterface )
    {
        ERROR_OUT(("GetProcAddr %s failed", SZ_SSLEMPTYCACHE));
        LastError = TPRTSEC_NOENTRYPT;
        goto error;
    }

error:

    return LastError;
}

BOOL SecurityInterface::GetUserCert(PBYTE pInfo, PDWORD pcbInfo)
{
    if ( NULL == m_pbEncodedCert)
    {
        WARNING_OUT(("GetUserCert: no encoded certname"));
        return FALSE;
    }

    ASSERT(m_cbEncodedCert > 0);

    if ( NULL == pInfo )
    {
        // Caller wants to know how much to allocate
        ASSERT(pcbInfo);
        *pcbInfo = m_cbEncodedCert;
        return TRUE;
    }

    if ( *pcbInfo < m_cbEncodedCert )
    {
        ERROR_OUT(("GetUserCert: insufficient buffer (%ld) %ld required",
            *pcbInfo, m_cbEncodedCert ));
        return FALSE;
    }

    memcpy ( (PCHAR)pInfo, m_pbEncodedCert, m_cbEncodedCert );
    *pcbInfo = m_cbEncodedCert;

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// Security Context
///////////////////////////////////////////////////////////////////////////





SecurityContext::SecurityContext(PSecurityInterface pSI, LPCSTR szHostName) :
                    scstate(SECCTX_STATE_NEW),
                    fContinueNeeded(FALSE),
                    LastError(TPRTSEC_NOERROR),
                    bContextHandleValid(FALSE)
{
    ASSERT(pSI);
    ASSERT(szHostName);

    pSecurityInterface = pSI;

    OutBuffers[0].pvBuffer = NULL;
    OutBuffers[0].cbBuffer = 0;

    if ( NULL != szHostName )
    {
        StringCchPrintf( szTargetName, CCHMAX(szTargetName), "%s:%x%x", szHostName,
            pSI->hOutboundCredential.dwUpper,
            pSI->hOutboundCredential.dwLower);
        TRACE_OUT(("SecurityContext::SecurityContext: targ %s",szTargetName));
    }
    ASSERT(pSecurityInterface);
}

SecurityContext::~SecurityContext(VOID)
{
    ASSERT(pSecurityInterface);
    if ( NULL != OutBuffers[0].pvBuffer )
    {
        ASSERT(pSecurityInterface->pfnTable);

        pSecurityInterface->pfnTable->FreeContextBuffer(OutBuffers[0].pvBuffer);
        OutBuffers[0].pvBuffer = NULL;
    }
    if ( bContextHandleValid )
    {
        pSecurityInterface->pfnTable->DeleteSecurityContext(&hContext);
    }
}


TransportSecurityError SecurityContext::InitContextAttributes(VOID)
{
    SECURITY_STATUS ss;

    ss = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                     SECPKG_ATTR_STREAM_SIZES,
                                     &Sizes );
    if (ss != ERROR_SUCCESS)
    {
        ERROR_OUT(("QueryContextAttributes returned [%x]", ss));
        return LastError = TPRTSEC_SSPIFAIL;
    }
    else
    {
        ASSERT (Sizes.cbHeader + Sizes.cbTrailer <= PROTOCOL_OVERHEAD_SECURITY);
        TRACE_OUT(("QueryContextAttributes returned header=%d trailer=%d",
                        Sizes.cbHeader, Sizes.cbTrailer));
    }

    #ifdef DEBUG //////////////////////////////////////////////////////////
    SecPkgContext_KeyInfo KeyInfo;

    ss = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                    SECPKG_ATTR_KEY_INFO,
                                    &KeyInfo );
    if (ss != ERROR_SUCCESS)
    {
        ERROR_OUT(("QueryContextAttributes (KEY_INFO) failed %x", ss));
    }
    else
    {
        WARNING_OUT(("KEY INFO: Sign:%s Encrypt:%s Keysize:%d",
                    KeyInfo.sSignatureAlgorithmName,
                    KeyInfo.sEncryptAlgorithmName,
                    KeyInfo.KeySize ));
        pSecurityInterface->pfnTable->FreeContextBuffer(
                    KeyInfo.sSignatureAlgorithmName );
        pSecurityInterface->pfnTable->FreeContextBuffer(
                    KeyInfo.sEncryptAlgorithmName );
    }

    #endif //DEBUG ///////////////////////////////////////////////////////

    return TPRTSEC_NOERROR;
}


TransportSecurityError SecurityContext::Initialize(PBYTE pData, DWORD cbData)
{
    SECURITY_STATUS ss;
    DWORD dwReqFlags;

    TRACE_OUT(("SecurityContext Initialize (%x,%d)", pData, cbData));

    fContinueNeeded = FALSE;

    ASSERT(pSecurityInterface);
    ASSERT(SECCTX_STATE_INIT == scstate || SECCTX_STATE_NEW == scstate);

    if ( !pSecurityInterface->bOutboundCredentialValid )
    {
        WARNING_OUT(("SecurityContext::Initialize: no outbound cred"));
        return TPRTSEC_SSPIFAIL;
    }

    if ( SECCTX_STATE_INIT == scstate)
    {
        ASSERT(NULL != pData);
        ASSERT(0 != cbData);

        if ( NULL == pData || 0 == cbData )
        {
            ERROR_OUT(("Second initialize call with no data"));
            return LastError = TPRTSEC_INVALID_PARAMETER;
        }

        // Build the input buffer descriptor

        InputBufferDescriptor.cBuffers = 2;
        InputBufferDescriptor.pBuffers = InBuffers;
        InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

        InBuffers[0].BufferType = SECBUFFER_TOKEN;
        InBuffers[0].cbBuffer = cbData;
        InBuffers[0].pvBuffer = pData;

        InBuffers[1].BufferType = SECBUFFER_EMPTY;
        InBuffers[1].cbBuffer = 0;
        InBuffers[1].pvBuffer = NULL;
    }
    else
    {
        ASSERT(NULL == pData);
        ASSERT(0 == cbData);
    }

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = OutBuffers;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    // If there's a output buffer from a previous call, free it here
    if ( NULL != OutBuffers[0].pvBuffer )
    {
        pSecurityInterface->pfnTable->FreeContextBuffer(OutBuffers[0].pvBuffer);
    }

    dwReqFlags = ISC_REQ_FLAGS;

    while ( 1 )
    {
        OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer = 0;
        OutBuffers[0].pvBuffer = NULL;

        #ifdef DUMP
        if (SECCTX_STATE_INIT == scstate)
        {
            dumpbytes("input token", (unsigned char *)InBuffers[0].pvBuffer,
                                                    InBuffers[0].cbBuffer);
        }
        #endif //DUMP

        ss = pSecurityInterface->pfnTable->InitializeSecurityContext(
                &(pSecurityInterface->hOutboundCredential),
                SECCTX_STATE_INIT == scstate ?  &hContext : NULL,
                szTargetName, // TargetName
                dwReqFlags,
                0, // Reserved
                SECURITY_NATIVE_DREP,
                SECCTX_STATE_INIT == scstate ?  &InputBufferDescriptor : NULL,
                0,        // reserved
                &hContext,
                &OutputBufferDescriptor,
                &ContextAttributes,
                &Expiration );

        // Some security providers don't process all the packet data
        // in one call to SCA - readjust the input buffers with the offset
        // returned in the extra buffer and iterate as necessary

        if (( SEC_I_CONTINUE_NEEDED == ss
            && NULL == OutBuffers[0].pvBuffer )
            && SECBUFFER_EXTRA == InBuffers[1].BufferType
            && 0 != InBuffers[1].cbBuffer )
        {
            InBuffers[0].pvBuffer = (PBYTE)(InBuffers[0].pvBuffer) +
                        ( InBuffers[0].cbBuffer - InBuffers[1].cbBuffer );
            InBuffers[0].BufferType = SECBUFFER_TOKEN;
            InBuffers[0].cbBuffer = InBuffers[1].cbBuffer;

            InBuffers[1].BufferType = SECBUFFER_EMPTY;
            InBuffers[1].cbBuffer = 0;
            InBuffers[1].pvBuffer = NULL;

            continue;
        }
        break;
    }


    #ifdef DUMP
    if ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss )
    {
        dumpbytes("output token",
            (unsigned char *)OutBuffers[0].pvBuffer,
            OutBuffers[0].cbBuffer);
    }
    #endif //DUMP

#ifdef ALLOW_NON_AUTHENTICATED_CLIENTS
    if ( SEC_I_INCOMPLETE_CREDENTIALS == ss )
    {
        WARNING_OUT(("InitializeSecurityContext:SEC_I_INCOMPLETE_CREDENTIALS"));

        dwReqFlags |= ISC_REQ_USE_SUPPLIED_CREDS;

        ss = pSecurityInterface->pfnTable->InitializeSecurityContext(
                &(pSecurityInterface->hOutboundCredential),
                SECCTX_STATE_INIT == scstate ?  &hContext : NULL,
                szTargetName, // TargetName
                dwReqFlags,
                0, // Reserved
                SECURITY_NATIVE_DREP,
                SECCTX_STATE_INIT == scstate ?  &InputBufferDescriptor : NULL,
                0,        // reserved
                &hContext,
                &OutputBufferDescriptor,
                &ContextAttributes,
                &Expiration );
    }
#endif // ALLOW_NON_AUTHENTICATED_CLIENTS

    if ( SEC_E_OK != ss )
    {
        if ( SEC_I_CONTINUE_NEEDED == ss && NULL != OutBuffers[0].pvBuffer )
        {
            ASSERT(SECCTX_STATE_NEW == scstate || SECCTX_STATE_INIT == scstate);

            TRACE_OUT(("Initialize: SEC_I_CONTINUE_NEEDED"));
            scstate = SECCTX_STATE_INIT;
        }
        else
        {
            ERROR_OUT(("Initialize failed: %x in state %d",(DWORD)ss,scstate));
            return LastError = TPRTSEC_SSPIFAIL;
        }
    }
    else
    {
        //  We're almost done,
        //  find the header and trailer sizes
        //

        if ( TPRTSEC_NOERROR != InitContextAttributes() )
            return LastError;

        if ( !Verify() )
            return LastError = TPRTSEC_SSPIFAIL;

        TRACE_OUT(("INITIALIZE OK"));

        scstate = SECCTX_STATE_INIT_COMPLETE;
    }

    // If there is an output buffer, set the flag to get it sent accross
    if ( ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss ) &&
                                NULL != OutBuffers[0].pvBuffer )
    {
        fContinueNeeded = TRUE;
    }

    bContextHandleValid = TRUE;
    return LastError = TPRTSEC_NOERROR;
}


TransportSecurityError SecurityContext::Accept(PBYTE pData, DWORD cbData)
{
    SECURITY_STATUS ss;

    fContinueNeeded = FALSE;

    ASSERT(SECCTX_STATE_NEW == scstate || SECCTX_STATE_ACCEPT == scstate);

    if ( !pSecurityInterface->bInboundCredentialValid )
    {
        WARNING_OUT(("SecurityContext::Initialize: no inbound cred"));
        return TPRTSEC_SSPIFAIL;
    }

    // Check to see if the required data is present
    if ( NULL == pData || 0 == cbData )
    {
        ERROR_OUT(("Accept: no data"));
        return LastError = TPRTSEC_INVALID_PARAMETER;
    }

    // Build the input buffer descriptor

    InputBufferDescriptor.cBuffers = 2;
    InputBufferDescriptor.pBuffers = InBuffers;
    InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    InBuffers[0].BufferType = SECBUFFER_TOKEN;
    InBuffers[0].cbBuffer = cbData;
    InBuffers[0].pvBuffer = pData;

    InBuffers[1].BufferType = SECBUFFER_EMPTY;
    InBuffers[1].cbBuffer = 0;
    InBuffers[1].pvBuffer = NULL;

    // Build the output buffer descriptor

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = OutBuffers;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    // If there's a output buffer from a previous call, free it here
    if ( NULL != OutBuffers[0].pvBuffer )
    {
        pSecurityInterface->pfnTable->FreeContextBuffer(OutBuffers[0].pvBuffer);
    }

    while ( 1 )
    {
        OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer = 0;
        OutBuffers[0].pvBuffer = NULL;

        #ifdef DUMP
        dumpbytes("input token", (unsigned char *)InBuffers[0].pvBuffer,
                                        InBuffers[0].cbBuffer);
        #endif //DUMP

        ss = pSecurityInterface->pfnTable->AcceptSecurityContext(
                    &(pSecurityInterface->hInboundCredential),
                    SECCTX_STATE_NEW == scstate ?  NULL : &hContext,
                    &InputBufferDescriptor,
                    ASC_REQ_FLAGS,
                    SECURITY_NATIVE_DREP,
                    &hContext, // receives new context handle
                    &OutputBufferDescriptor, // receives output security token
                    &ContextAttributes,        // receives context attributes
                    &Expiration );            // receives expiration time

        // Some security providers don't process all the packet data
        // in one call to SCA - readjust the input buffers with the offset
        // returned in the extra buffer and iterate as necessary

        if (( SEC_I_CONTINUE_NEEDED == ss
            && NULL == OutBuffers[0].pvBuffer )
            && SECBUFFER_EXTRA == InBuffers[1].BufferType
            && 0 != InBuffers[1].cbBuffer )
        {
            InBuffers[0].pvBuffer = (PBYTE)(InBuffers[0].pvBuffer) +
                        ( InBuffers[0].cbBuffer - InBuffers[1].cbBuffer );
            InBuffers[0].BufferType = SECBUFFER_TOKEN;
            InBuffers[0].cbBuffer = InBuffers[1].cbBuffer;

            InBuffers[1].BufferType = SECBUFFER_EMPTY;
            InBuffers[1].cbBuffer = 0;
            InBuffers[1].pvBuffer = NULL;

            continue;
        }
        break;
    }

    #ifdef DUMP
    if ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss )
    {
        dumpbytes("output token",
            (unsigned char *)OutBuffers[0].pvBuffer,
            OutBuffers[0].cbBuffer);
    }
    #endif //DUMP

    if ( SEC_E_OK != ss )
    {
        if ( SEC_I_CONTINUE_NEEDED == ss )
        {
            TRACE_OUT(("Accept: SEC_I_CONTINUE_NEEDED"));

            scstate = SECCTX_STATE_ACCEPT;
        }
        else
        {
            ERROR_OUT(("AcceptSecurityContext failed: %x", (DWORD)ss));
            return LastError = TPRTSEC_SSPIFAIL;
        }
    }
    else
    {

        //  We're almost done,
        //  find the header and trailer sizes
        //

        if ( TPRTSEC_NOERROR != InitContextAttributes() )
            return LastError;

        if ( !Verify() )
            return LastError = TPRTSEC_SSPIFAIL;

        TRACE_OUT(("ACCEPT OK"));

        scstate = SECCTX_STATE_ACCEPT_COMPLETE;
    }

    // If there is an output buffer, set the flag to get it sent accross
    if ( ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss ) &&
                                NULL != OutBuffers[0].pvBuffer )
    {
        fContinueNeeded = TRUE;
    }

    bContextHandleValid = TRUE;
    return LastError = TPRTSEC_NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
//
// Encrypt()
//
// Description:
//    Encrypts a packet to be sent using SSL/PCT by calling SealMessage().
//
// Parameters:
//    phContext         - security context handle returned from InitiateSecConnection
//    pBufIn1, pBufIn2  - buffers to be encrypted
//    cbBufIn1,cbBufIn2    - lengths of buffers to be encrypted
//    ppBufOut          - allocated encrypted buffer, to be freed by caller
//    pcbBufOut         - length of encrypted buffer
//
// Return:
//    TransprotSecurityError
//
TransportSecurityError SecurityContext::Encrypt(
                  LPBYTE      pBufIn1,
                  UINT        cbBufIn1,
                  LPBYTE      pBufIn2,
                  UINT        cbBufIn2,
                  LPBYTE     *ppBufOut,
                  UINT        *pcbBufOut)
{
    SECURITY_STATUS           scRet = ERROR_SUCCESS;
    SecBufferDesc             Buffer;
    SecBuffer                 Buffers[4];
    UINT                      cbBufInTotal;
    LPBYTE                      pbTemp;

    // pBufIn2 and cbBufIn2 maybe NULL and 0, respectively.
    ASSERT(pBufIn1);
    ASSERT(cbBufIn1);
    ASSERT(ppBufOut);
    ASSERT(pcbBufOut);

    ASSERT(SECCTX_STATE_INIT_COMPLETE == scstate ||
            SECCTX_STATE_ACCEPT_COMPLETE == scstate);
    if (SECCTX_STATE_INIT_COMPLETE != scstate &&
        SECCTX_STATE_ACCEPT_COMPLETE != scstate)
        return LastError = TPRTSEC_INCOMPLETE_CONTEXT;

    *pcbBufOut = 0;
    cbBufInTotal = cbBufIn1 + cbBufIn2;

    // We allocate a buffer to hold the (larger) encrypted data.
    // This must be freed by the caller!
    // christts: The buffer will now also hold the X.224 header.
    if (NULL == (*ppBufOut = (LPBYTE)LocalAlloc(0, cbBufInTotal
                                + Sizes.cbHeader + Sizes.cbTrailer +
                                sizeof(X224_DATA_PACKET))))
        return LastError = TPRTSEC_NOMEM;

    pbTemp = *ppBufOut + sizeof(X224_DATA_PACKET);

    //
    // prepare data for SecBuffer
    //
    Buffers[0].pvBuffer = pbTemp;
    Buffers[0].cbBuffer = Sizes.cbHeader;
    Buffers[0].BufferType = SECBUFFER_STREAM_HEADER;

    Buffers[1].pvBuffer = pbTemp + Sizes.cbHeader;
    // Copy the user's data
    CopyMemory(Buffers[1].pvBuffer, pBufIn1, cbBufIn1);
    if (NULL != pBufIn2) {
        CopyMemory((PVoid) ((PUChar) (Buffers[1].pvBuffer) + cbBufIn1),
                    pBufIn2, cbBufIn2);
    }
    Buffers[1].cbBuffer = cbBufInTotal;
    Buffers[1].BufferType = SECBUFFER_DATA;

    Buffers[2].pvBuffer = pbTemp + Sizes.cbHeader + cbBufInTotal;
    Buffers[2].cbBuffer = Sizes.cbTrailer;
    Buffers[2].BufferType = SECBUFFER_STREAM_TRAILER;

    Buffers[3].pvBuffer = NULL;
    Buffers[3].cbBuffer = 0;
    Buffers[3].BufferType = SECBUFFER_EMPTY;

    Buffer.cBuffers = 4;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    #ifdef DUMP
    dumpbytes("data BEFORE encryption", (PBYTE)Buffers[1].pvBuffer,
                    Buffers[1].cbBuffer);
    #endif // DUMP

    // Call the semi-documented SealMessage function (Reserved3)

    scRet = ((SEAL_MESSAGE_FN)pSecurityInterface->pfnTable->Reserved3)(
        &hContext, 0, &Buffer, 0);


    if (scRet != ERROR_SUCCESS)
    {
        //
        // Map the SSPI error.
        //
        ERROR_OUT(("SealMessage failed: %x", scRet));
        LocalFree(*ppBufOut);
        return LastError = TPRTSEC_SSPIFAIL;
    }

    // We also have to add the X.224 header.
    *pcbBufOut = cbBufInTotal + Sizes.cbHeader + Sizes.cbTrailer + sizeof(X224_DATA_PACKET);
    memcpy (*ppBufOut, g_X224Header, sizeof(X224_DATA_PACKET));
    AddRFCSize(*ppBufOut, *pcbBufOut);

    #ifdef TESTHACKS
    // Inject an error...
    if (GetAsyncKeyState(VK_CONTROL)&0x8000) {
        OutputDebugString("*** INJECTING ERROR IN OUTGOING PACKET ***\n\r");
        pbTemp[(*pcbBufOut - sizeof(X224_DATA_PACKET))/2] ^= 0x55;
    }
    #endif //TESTHACKS

    #ifdef DUMP
    dumpbytes("data AFTER encryption",  pbTemp, *pcbBufOut - sizeof(X224_DATA_PACKET));
    #endif // DUMP

    TRACE_OUT(("SealMessage returned Buffer = %p, EncryptBytes = %d, UnencryptBytes = %d", pbTemp,
                *pcbBufOut - sizeof(X224_DATA_PACKET), cbBufInTotal));

    return LastError = TPRTSEC_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
//
// Decrypt
//
// Description:
//    Decrypts a buffer received using SCHANNEL by calling UnsealMessage().
//
// Parameters:
//    pBuf      - buffer to be decrypted
//    cbBufIn       - length of buffer to be decrypted
//
TransportSecurityError SecurityContext::Decrypt( PBYTE pBuf, DWORD cbBuf)
{
    SecBufferDesc   Buffer;
    SecBuffer       Buffers[4];
    DWORD           scRet = ERROR_SUCCESS;
    SecBuffer * pDataBuffer;
    int i;

    LastError = TPRTSEC_SSPIFAIL;

    ASSERT(SECCTX_STATE_INIT_COMPLETE == scstate ||
            SECCTX_STATE_ACCEPT_COMPLETE == scstate);
    if (SECCTX_STATE_INIT_COMPLETE != scstate &&
        SECCTX_STATE_ACCEPT_COMPLETE != scstate)
        return LastError = TPRTSEC_INCOMPLETE_CONTEXT;

    ASSERT(!IsBadWritePtr(pBuf,cbBuf));

    #ifdef TESTHACKS
    // Inject an error...
    if ( GetAsyncKeyState(VK_SHIFT) & 0x8000 ) {
        OutputDebugString("*** INJECTING ERROR IN INCOMING PACKET ***\n\r");
        pBuf[cbBuf/2] ^= 0x55;
    }
    #endif //TESTHACKS

    //
    // prepare data the SecBuffer for a call to SSL/PCT decryption code.
    //
    Buffers[0].pvBuffer   = pBuf;
    Buffers[0].cbBuffer      = cbBuf;

    Buffers[0].BufferType = SECBUFFER_DATA;

    Buffers[1].pvBuffer   = NULL;
    Buffers[1].cbBuffer   = 0;
    Buffers[1].BufferType = SECBUFFER_EMPTY;
    Buffers[2].pvBuffer   = NULL;
    Buffers[2].cbBuffer   = 0;
    Buffers[2].BufferType = SECBUFFER_EMPTY;
    Buffers[3].pvBuffer   = NULL;
    Buffers[3].cbBuffer   = 0;
    Buffers[3].BufferType = SECBUFFER_EMPTY;

    Buffer.cBuffers = 4;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    // Call the semi-documented UnsealMessage function (Reserved4)

    #ifdef DUMP
    dumpbytes("data BEFORE decryption:", (PBYTE)Buffers[0].pvBuffer,
                                        Buffers[0].cbBuffer);
    #endif // DUMP

    scRet = ((UNSEAL_MESSAGE_FN)pSecurityInterface->pfnTable->Reserved4)(
        &hContext, &Buffer, 0, NULL);

    pDataBuffer = NULL;

    for( i=0; i<4; i++ )
    {
        if ( NULL == pDataBuffer && SECBUFFER_DATA == Buffers[i].BufferType )
        {
            pDataBuffer = &Buffers[i];
        }
    }

    if ( NULL == pDataBuffer )
    {
        ERROR_OUT(("Unseal: no data buffer found"));
        return LastError = TPRTSEC_SSPIFAIL;
    }

    #ifdef DUMP
    dumpbytes("data AFTER decryption:", (PBYTE)pDataBuffer->pvBuffer,
                                        pDataBuffer->cbBuffer);
    #endif // DUMP

    if (scRet != ERROR_SUCCESS)
    {
        ERROR_OUT(("UnsealMessage failed with [%x]", scRet));
        return LastError = TPRTSEC_SSPIFAIL;
    }
    return LastError = TPRTSEC_NOERROR;
}


TransportSecurityError SecurityContext::AdvanceState(PBYTE pIncomingData,
                                                    DWORD cbBuf)
{
    TRACE_OUT(("AdvanceState: state %d using data %x (%d)",
        scstate, pIncomingData, cbBuf ));

    switch ( scstate )
    {
        case SECCTX_STATE_INIT:
            if ( TPRTSEC_NOERROR != Initialize( pIncomingData, cbBuf ) )
            {
                WARNING_OUT(("AdvanceState: Initialize failed in INIT"));
                goto error;
            }
            break;

        case SECCTX_STATE_ACCEPT:
        case SECCTX_STATE_NEW:
            if ( TPRTSEC_NOERROR != Accept( pIncomingData, cbBuf ) )
            {
                WARNING_OUT(("AdvanceState: Accept failed in ACCEPT or NEW"));
                goto error;
            }
            break;

        case SECCTX_STATE_INIT_COMPLETE:
        case SECCTX_STATE_ACCEPT_COMPLETE:
        case SECCTX_STATE_ERROR:
        default:
            ERROR_OUT(("AdvanceState: called in unexpected state %d"));
            goto error;

    }
    return LastError = TPRTSEC_NOERROR;

error:

    scstate = SECCTX_STATE_ERROR;
    return LastError;
}

#define CHECKFLAGS  (CERT_STORE_REVOCATION_FLAG |\
                CERT_STORE_SIGNATURE_FLAG |\
                CERT_STORE_TIME_VALIDITY_FLAG)

BOOL SecurityContext::Verify(VOID)
{
    BOOL fRet = TRUE;
    DWORD sc;
    PCCERT_CONTEXT pCert = NULL, pIssuerCert = NULL, pCACert = NULL;
    DWORD dwFlags;
    HCERTSTORE hStore = NULL;
    HCERTSTORE hCAStore = NULL;
    RegEntry rePol(POLICIES_KEY, HKEY_LOCAL_MACHINE);
    CHAR * pIssuer = NULL;

    ASSERT( NULL != pSecurityInterface );

    // Get the subject cert context
    sc = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                        SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                        (PVOID)&pCert );

    if ( SEC_E_OK != sc )
    {
        ERROR_OUT(("QueryContextAttributes (REMOTE_CERT_CONTEXT) failed"));
        goto error;
    }

    if ( NULL == pCert )
    {
        // The caller is not authenticated
        WARNING_OUT(("No remote cred data"));
        goto error;
    }

    // Open the root store for certificate verification
    hStore = CertOpenSystemStore(0, "Root");

    if( NULL == hStore )
    {
        ERROR_OUT(("Couldn't open root certificate store"));
        goto error;
    }

    dwFlags = CHECKFLAGS;

    // Get the issuer of this cert

    pIssuerCert = CertGetIssuerCertificateFromStore(
                        hStore,
                        pCert,
                        NULL,
                        &dwFlags );

    // If the issuer of the certificate cannot be found in the root store,
    // check the CA store iteratively until we work our way back to a root
    // certificate

    pCACert = pCert;

    while ( NULL == pIssuerCert )
    {
        PCCERT_CONTEXT pTmpCert;

        if ( NULL == hCAStore )
        {
            hCAStore = CertOpenSystemStore(0, "CA");

            if ( NULL == hCAStore )
            {
                ERROR_OUT(("Couldn't open CA certificate store"));
                goto error;
            }
        }

        dwFlags =   CERT_STORE_REVOCATION_FLAG |
                    CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;

        pTmpCert = CertGetIssuerCertificateFromStore(
                        hCAStore,
                        pCACert,
                        NULL,
                        &dwFlags );

        if ( NULL == pTmpCert )
        {
            TRACE_OUT(("Issuer not found in CA store either"));
            break;
        }

        if ( pCACert != pCert )
            CertFreeCertificateContext(pCACert);
        pCACert = pTmpCert;

        if ((( CERT_STORE_REVOCATION_FLAG & dwFlags ) &&
             !( CERT_STORE_NO_CRL_FLAG & dwFlags )) ||
             ( CERT_STORE_SIGNATURE_FLAG & dwFlags ) ||
             ( CERT_STORE_TIME_VALIDITY_FLAG & dwFlags ))
        {
            TRACE_OUT(("Problem with issuer in CA store: %x", dwFlags));
            break;
        }

        dwFlags =   CERT_STORE_REVOCATION_FLAG |
                    CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;

        pIssuerCert = CertGetIssuerCertificateFromStore(
                        hStore,
                        pCACert,
                        NULL,
                        &dwFlags );

    }

    if ( pCACert != pCert )
        CertFreeCertificateContext ( pCACert );

    if ( NULL == pIssuerCert )
    {
        WARNING_OUT(("Verify: Can't find issuer in store"));
    }

    // Check certificate

    if ( NULL != pIssuerCert && 0 != dwFlags )
    {
        if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
        {
            WARNING_OUT(("Verify: Signature invalid"));
        }
        if ( dwFlags & CERT_STORE_TIME_VALIDITY_FLAG )
        {
            WARNING_OUT(("Verify: Cert expired"));
        }
        if ( dwFlags & CERT_STORE_REVOCATION_FLAG )
        {
            if (!(dwFlags & CERT_STORE_NO_CRL_FLAG))
            {
                WARNING_OUT(("Verify: Cert revoked"));
            }
            else
            {
                // We have no CRL for this issuer, do not
                // treat as revoked by default:
                dwFlags &= ~CERT_STORE_REVOCATION_FLAG;
            }
        }
    }

    //
    // Check for no-incomplete-certs policy
    //

    if (( NULL == pIssuerCert || ( 0 != ( CHECKFLAGS & dwFlags ))) &&
        rePol.GetNumber( REGVAL_POL_NO_INCOMPLETE_CERTS,
                                DEFAULT_POL_NO_INCOMPLETE_CERTS ))
    {
        WARNING_OUT(("Verify: policy prevents cert use"));
        fRet = FALSE;
        goto error;
    }

    //
    // Is there a mandatory issuer?
    //

    if ( lstrlen(rePol.GetString( REGVAL_POL_ISSUER )))
    {
        DWORD cbIssuer;

        //
        // Get the issuer information
        //

        cbIssuer = CertNameToStr (
                            pCert->dwCertEncodingType,
                            &pCert->pCertInfo->Issuer,
                            CERT_FORMAT_FLAGS,
                            NULL, 0);

        if ( 0 == cbIssuer )
        {
            ERROR_OUT(("GetUserInfo: no issuer string"));
            fRet = FALSE;
            goto error;
        }

        pIssuer = new CHAR[cbIssuer + 1];

        if ( NULL == pIssuer )
        {
            ERROR_OUT(("GetUserInfo: error allocating issuer name"));
        }

        if ( 0 >= CertNameToStr (
                            pCert->dwCertEncodingType,
                            &pCert->pCertInfo->Issuer,
                            CERT_FORMAT_FLAGS,
                            pIssuer, cbIssuer+1))
        {
            ERROR_OUT(("GetUserInfo: error getting issuer string"));
            fRet = FALSE;
            goto error;
        }

        if ( lstrcmp ( rePol.GetString(REGVAL_POL_ISSUER),
            pIssuer ))
        {
            WARNING_OUT(("Issuer (%s) didn't match policy (%s)",
                pIssuer, rePol.GetString(REGVAL_POL_ISSUER)));
            fRet = FALSE;
        }
    }

error:

    if ( NULL != hStore )
    {
        CertCloseStore(hStore, 0);
    }

    if ( NULL != hCAStore )
    {
        CertCloseStore(hCAStore, 0);
    }

    if ( NULL != pCert )
    {
        CertFreeCertificateContext ( pCert );
    }

    if ( NULL != pIssuerCert )
    {
        CertFreeCertificateContext ( pIssuerCert );
    }

    if ( NULL != pIssuer )
    {
        delete pIssuer;
    }

    return fRet;
}


BOOL SecurityContext::GetUserCert(PBYTE pInfo, PDWORD pcbInfo)
{
    BOOL fRet = FALSE;
    DWORD sc;
    PCCERT_CONTEXT pCert = NULL;

    ASSERT( NULL != pSecurityInterface );

    //
    // Get the certificate from the context
    //

    sc = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                        SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                        (PVOID)&pCert );

    if ( SEC_E_OK != sc )
    {
        ERROR_OUT(("QueryContextAttributes failed"));
        goto cleanup;
    }

    if ( NULL == pCert )
    {
        // The caller is not authenticated
        WARNING_OUT(("No remote cred data"));
        goto cleanup;
    }


    if ( NULL != pInfo && *pcbInfo >= pCert->cbCertEncoded )
    {
        memcpy ( pInfo, pCert->pbCertEncoded, pCert->cbCertEncoded );
    }
    *pcbInfo = pCert->cbCertEncoded;

    fRet = TRUE;

cleanup:

    if ( NULL != pCert )
    {
        CertFreeCertificateContext ( pCert );
    }

    return fRet;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\tprtctrl.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);

#include <datguids.h>
#include <nmqos.h>
#include <t120qos.h>
#include "tprtsec.h"
#include <tsecctrl.h>
#include <tprtntfy.h>
#include "cnpcoder.h"
#include "plgxprt.h"

// #undef TRACE_OUT
// #define TRACE_OUT   WARNING_OUT


/*    Tprtctrl.cpp
 *
 *    Copyright (c) 1996 by Microsoft Corporation
 *
 *    Abstract:
 *        This module maintains the TCP transport and all connections.
 *
 */

/* External definitions */
extern HINSTANCE            g_hDllInst;
extern PTransportInterface    g_Transport;
extern SOCKET                Listen_Socket;
extern SOCKET                Listen_Socket_Secure;
extern CRITICAL_SECTION        csQOS;
extern CPluggableTransport *g_pPluggableTransport;

extern PController            g_pMCSController;
extern CCNPCoder            *g_CNPCoder;
extern HWND                 TCP_Window_Handle;

BOOL FindSocketNumber(DWORD dwGCCID, SOCKET * socket_number);

/*
 *    The following array contains a template for the X.224 data header.
 *    The 5 of the 7 bytes that it initializes are actually sent to the
 *    wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *    The array is only used when we encode a data PDU.
 */
extern UChar g_X224Header[];

// The external MCS Controller object
extern PController    g_pMCSController;

// plugable transport prototypes
int X224Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *pnLastError);
int Q922Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *pnLastError);


/*
 *    void QoSLock(Void)
 *
 *    Functional Description:
 *        This function locks the QoS data
 *        All other reader or writer threads will be blocked.
 */
void QoSLock(Void)
{
    EnterCriticalSection(&csQOS);
}

/*
 *    void    QoSUnlock(Void)
 *
 *    Functional Description:
 *        This function unlocks the QoS data
 *        Waiting reader or writer threads will be unblocked.
 */
void QoSUnlock(Void)
{
    LeaveCriticalSection(&csQOS);
}

/*
 *    TransportError    ConnectRequest (    TransportAddress    transport_address,
 *                                        BOOL                fSecure
 *                                        PTransportConnection         pXprtConn)
 *
 *    Functional Description:
 *        This function initiates a connection.  It passes the transport address
 *        to the TCP transport.  It will either deny the request or accept the
 *        request and call us back when the physical connection is established.
 *
 *        We return the transport connection handle in the transport_connection
 *        address.  Although we return this transport number to the user, it
 *        is not ready for data transfer until the user receives the
 *        TRANSPORT_CONNECT_INDICATION and responds with a ConnectResponse() call.
 *        At that point, the transport connection is up and running.
 */
TransportError    ConnectRequest (TransportAddress    transport_address,
                                BOOL                fSecure,
                 /* out */       PTransportConnection         pXprtConn)
{
    TransportError rc = TRANSPORT_NO_ERROR;
    PSocket        pSocket;
    PSecurityContext pSC = NULL;
    ULong        address;
    SOCKADDR_IN    sin;
    CPluggableConnection *p = NULL;

    // initialize transport connection
    UINT nPluggableConnID = ::GetPluggableTransportConnID(transport_address);
    if (nPluggableConnID)
    {
        p = ::GetPluggableConnection(nPluggableConnID);
        if (NULL != p)
        {
            pXprtConn->eType = p->GetType();
            pXprtConn->nLogicalHandle = nPluggableConnID;
            ASSERT(IS_PLUGGABLE(*pXprtConn));
        }
        else
        {
            return TRANSPORT_NO_SUCH_CONNECTION;
        }
    }
    else
    {
        pXprtConn->eType = TRANSPORT_TYPE_WINSOCK;
        pXprtConn->nLogicalHandle = INVALID_SOCKET;
    }

    // we are connecting X224...
    ::OnProtocolControl(*pXprtConn, PLUGXPRT_CONNECTING);

    // Try to prepare a security context object if we're told to do so.
    if ( fSecure )
    {
        // If we're trying to connect securely but can't, fail
        if ( NULL == g_Transport->pSecurityInterface )
        {
            WARNING_OUT(("Placing secure call failed: no valid security interface"));
            return TRANSPORT_SECURITY_FAILED;
        }

        DBG_SAVE_FILE_LINE
        if (NULL != (pSC = new SecurityContext(g_Transport->pSecurityInterface,
                                                transport_address)))
        {
            if ( TPRTSEC_NOERROR != pSC->Initialize(NULL,0))
            {
                // If we can't init a security context, fail
                delete pSC;
                pSC = NULL;
                WARNING_OUT(("Placing secure call failed: could not initialize security context"));
                return TRANSPORT_SECURITY_FAILED;
            }
        }
    }

    /* Create and Initialize the Socket object */
    pSocket = newSocket(*pXprtConn, pSC);
    if( pSocket == NULL )
        return (TRANSPORT_MEMORY_FAILURE);

    pSocket->SecState = ( NULL == pSC ) ? SC_NONSECURE : SC_SECURE;

    if (IS_SOCKET(*pXprtConn))
    {
        u_short uPort = TCP_PORT_NUMBER;
        TCHAR szAddress[MAXIMUM_IP_ADDRESS_SIZE];
        lstrcpyn(szAddress, transport_address, MAXIMUM_IP_ADDRESS_SIZE);
        LPTSTR pszSeparator = (LPTSTR)_StrChr(szAddress, _T(':'));
        if (NULL != pszSeparator)
        {
            uPort = (u_short)DecimalStringToUINT(CharNext(pszSeparator));
            *pszSeparator = _T('\0');
        }

        /* Convert the ascii string into an Internet Address */
        if ((address = inet_addr(szAddress)) == INADDR_NONE)
        {
            WARNING_OUT (("ConnectRequest: %s is an invalid host addr", szAddress));
            rc = TRANSPORT_CONNECT_REQUEST_FAILED;
            goto Bail;
        }

        lstrcpyn (pSocket->Remote_Address, transport_address, MAXIMUM_IP_ADDRESS_SIZE);

        /*
         * Load the socket control structure with the parameters necessary.
         *
         *    - Internet socket
         *    - Let it assign any address to this socket
         *    - Assign our port number (depending on secure/nonsecure call!)
         */
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = address;
        sin.sin_port = htons (uPort);

        /* Attempt a connection to the remote site */
        TRACE_OUT (("ConnectRequest: Issuing connect: address = %s", transport_address));
        if (::connect(pSocket->XprtConn.nLogicalHandle, (const struct sockaddr *) &sin, sizeof(sin)) == 0)
        {
            TRACE_OUT (("ConnectRequest:   State = SOCKET_CONNECTED..."));
            /* Add socket to connection list */
            // bugbug: we may fail to insert.
            g_pSocketList->SafeAppend(pSocket);
            ::SendX224ConnectRequest(pSocket->XprtConn);
        }
        else
        if (WSAGetLastError() == WSAEWOULDBLOCK)
        {
            /* If the error message is WSAEWOULDBLOCK, we must wait for the FD_CONNECT. */
            TRACE_OUT (("ConnectRequest:   State = WAITING_FOR_CONNECTION..."));
            pSocket -> State = WAITING_FOR_CONNECTION;
            /* Add socket to connection list */
            // bugbug: we may fail to insert.
            g_pSocketList->SafeAppend(pSocket);
            // SendStatusMessage(pSocket -> Remote_Address, TSTATE_CONNECT_PENDING, IDS_NULL_STRING);
        }
        else
        {
            WARNING_OUT (("ConnectRequest: Connect Failed error = %d",WSAGetLastError()));

            /* The connect() call failed, close the socket and notify the owner    */
            // SendStatusMessage (pSocket -> Remote_Address, TSTATE_NOT_READY, IDS_NULL_STRING);
            ::ShutdownAndClose(pSocket->XprtConn, FALSE, 2);
            rc = TRANSPORT_CONNECT_REQUEST_FAILED;
            goto Bail;
        }
    }
    else
    {
        ASSERT(IS_PLUGGABLE(*pXprtConn));
        g_pSocketList->SafeAppend(pSocket);
        if (IS_PLUGGABLE_X224(*pXprtConn))
        {
           ::SendX224ConnectRequest(pSocket->XprtConn);
        }
        else
        if (IS_PLUGGABLE_PSTN(*pXprtConn))
        {
            rc = p->TConnectRequest();
            ASSERT(TRANSPORT_NO_ERROR == rc);
        }
    }

Bail:

    ASSERT(NULL != pSocket);
    if (TRANSPORT_NO_ERROR == rc)
    {
        *pXprtConn = pSocket->XprtConn;
    }
    else
    {
        ::freeSocket(pSocket, *pXprtConn);
    }

    return rc;
}


/*
 *    BOOL ConnectResponse (TransportConnection    XprtConn)
 *
 *    Functional Description:
 *        This function is called by the user in response to a
 *        TRANSPORT_CONNECT_INDICATION callback from us.  By making this call the
 *        user is accepting the call.  If the user does not want to accept the
 *        call, he should call DisconnectRequest();
 */
BOOL ConnectResponse (TransportConnection XprtConn)
{
    PSocket    pSocket;

    TRACE_OUT (("ConnectResponse(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));

    /* If this is an invalid handle, return error */
    if(NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        BOOL fRet;
        if (pSocket->State == SOCKET_CONNECTED)
        {
            /* We do not change this state in ANY other place BECAUSE  it breaks the connect request*/
            pSocket->State = X224_CONNECTED;
            fRet = TRUE;
        }
        else
        {
            ERROR_OUT(("ConnectResponse: Illegal ConnectResponse packet"));
            fRet = FALSE;
        }
        pSocket->Release();
        return fRet;
    }
    return FALSE;
}

#ifdef TSTATUS_INDICATION
/*
 *    Void    SendStatusMessage (    PChar RemoteAddress,
 *                                TransportState State,
 *                                 UInt message_id)
 *
 *    Functional Description:
 *        This function is called to send a status indication to the user. The
 *        specific text of the message is contained in a string resource.
 */
Void SendStatusMessage(    PChar RemoteAddress,
                          TransportState    state,
                          UInt                message_id)
{
    TransportStatus transport_status;
    char            sTransport[80] = "";
    char            message[80] = "";

    if( message_id == IDS_NULL_STRING )
        message[0] = '\000';
    else
        LoadString(
                (HINSTANCE) g_hDllInst,
                (UINT) message_id,
                (LPSTR) message,
                (int) sizeof(message) );

     /*
     **    We issue a callback to the user to notify him of the message
     */
    transport_status.device_identifier = "";
    transport_status.remote_address = RemoteAddress;
    transport_status.message = message;
    transport_status.state = state;

    g_pMCSController->HandleTransportStatusIndication(&transport_status);
}
#endif


/*
 *    Void    SendX224ConnectRequest(TransportConnection XprtConn)
 *
 *    Functional Description:
 *        This function is called upon receipt of the FD_CONNECT from Winsock.
 *        It indicates that the physical connection is established, and sends
 *        the X224 connection request packet.
 */
void SendX224ConnectRequest(TransportConnection XprtConn)
{
    PSocket            pSocket;

    static X224_CR_FIXED cr_fixed =
    {
        { 3, 0, 0, UNK },
        UNK,
        { CONNECTION_REQUEST_PACKET, UNK, UNK, UNK, UNK, 0 } // common info
    };

    TRACE_OUT(("SendX224ConnectRequest"));

    CNPPDU                  cnp_pdu;
    ConnectRequestPDU_reliableSecurityProtocols_Element cnp_cr_rsp_element;
    LPBYTE                  pbToSendBuf = NULL;
    UINT                    cbToSendBuf = 0;
    LPBYTE                  encoded_pdu;
    UINT                    encoded_pdu_length;

    TransportError          error;

    cnp_pdu.choice = connectRequest_chosen;
    cnp_pdu.u.connectRequest.bit_mask = 0;
    cnp_pdu.u.connectRequest.protocolIdentifier = t123AnnexBProtocolId;
    cnp_pdu.u.connectRequest.reconnectRequested = FALSE;

    // Sanity check field sizes... these need to conform to protocol
    ASSERT (sizeof(RFC_HEADER) == 4);
    ASSERT (sizeof(X224_DATA_PACKET) == 7);
    ASSERT (sizeof(X224_CONNECT_COMMON) == 6);
    ASSERT (sizeof(X224_TPDU_INFO) == 3);

    /* If this is an invalid handle, return */
    if (NULL == (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
        return;

    if (IS_SOCKET(pSocket->XprtConn))
    {
        if (pSocket -> State != WAITING_FOR_CONNECTION)
        {
            ERROR_OUT (("SendX224ConnectRequest: Illegal Socket State"));
            goto MyExit;
        }
    }
    else
    {
        ASSERT(IS_PLUGGABLE(pSocket->XprtConn));
        if (X224_CONNECTED == pSocket->State)
        {
            // after query remote, we need to reset the state back to socket connected
            pSocket->State = SOCKET_CONNECTED;
        }
        if (SOCKET_CONNECTED != pSocket->State)
        {
            ERROR_OUT (("SendX224ConnectRequest: Illegal Socket State"));
            goto MyExit;
        }
    }

    // If there is a security context associated with this socket, we
    // are settting up for a secure call and will indicate that in the CNP
    // portion of the packet
    if (NULL != pSocket->pSC)
    {
        TRACE_OUT(("SendX224ConnectRequest: requesting secure connection"));

        cnp_pdu.u.connectRequest.bit_mask |= reliableSecurityProtocols_present;
        cnp_cr_rsp_element.next = NULL;
        cnp_cr_rsp_element.value.choice = gssApiX224_chosen;
        cnp_pdu.u.connectRequest.reliableSecurityProtocols = &cnp_cr_rsp_element;
    }
    else
    {
        TRACE_OUT(("SendX224ConnectRequest: requesting NON-secure connection"));
    }

    if (! g_CNPCoder->Encode((LPVOID) &cnp_pdu,
                             CNPPDU_PDU,
                             PACKED_ENCODING_RULES,
                             &encoded_pdu,
                             &encoded_pdu_length))
    {
        ERROR_OUT(("SendX224ConnectRequest: Can't encode cnp pdu"));
        goto MyExit;
    }

    pSocket -> State = SOCKET_CONNECTED;

    /* X224 header */
    cr_fixed.conn.msbSrc = (UChar) (XprtConn.nLogicalHandle >> 8);
    cr_fixed.conn.lsbSrc = (UChar) XprtConn.nLogicalHandle;

    cbToSendBuf = sizeof(X224_CR_FIXED)+sizeof(X224_TPDU_INFO)+sizeof(X224_VARIABLE_INFO)+encoded_pdu_length;
    cr_fixed.rfc.lsbPacketSize = (UChar)cbToSendBuf;
    cr_fixed.HeaderSize = (UChar)(sizeof(X224_CONNECT_COMMON)+sizeof(X224_TPDU_INFO)+sizeof(X224_VARIABLE_INFO)+encoded_pdu_length);
    ASSERT ( cbToSendBuf <= 128);
    DBG_SAVE_FILE_LINE
    pbToSendBuf = new BYTE[cbToSendBuf];
    if (NULL == pbToSendBuf)
    {
        ERROR_OUT(("SendX224ConnectRequest: failed to allocate memory"));
        goto MyExit;
    }

    {
        LPBYTE pbTemp = pbToSendBuf;
        memcpy(pbTemp, (LPBYTE) &cr_fixed, sizeof(cr_fixed));
        pbTemp += sizeof(cr_fixed);

        {
            X224_TPDU_INFO x224_tpdu_info = { TPDU_SIZE, 1, DEFAULT_TPDU_SIZE };
            memcpy(pbTemp, (LPBYTE) &x224_tpdu_info, sizeof(x224_tpdu_info));
            pbTemp += sizeof(x224_tpdu_info);
        }

        {
            X224_VARIABLE_INFO x224_var_info = { T_SELECTOR, (UChar)encoded_pdu_length };
            memcpy(pbTemp, (LPBYTE) &x224_var_info, sizeof(x224_var_info));   // bug: error handling
            pbTemp += sizeof(x224_var_info);
            memcpy(pbTemp, encoded_pdu, encoded_pdu_length);
        }
    }

    g_CNPCoder->FreeEncoded(encoded_pdu);

    /* Attempt to send data out the socket */
    error = FlushSendBuffer(pSocket, pbToSendBuf, cbToSendBuf);
    ASSERT (TRANSPORT_NO_ERROR == error);

    delete [] pbToSendBuf;

MyExit:

    pSocket->Release();
}



/*
 *    Void    SendX224ConnectConfirm (PSocket pSocket, unsigned int remote)
 *
 *    Functional Description:
 *        This function is called upon receipt of the X224 connection request
 *        packet. It indicates that the remote side wants to establish a
 *        logical connection, and sends the X224 connection response packet.
 *
 *    Return value:
 *        TRUE, if everything went ok.
 *        FALSE, otherwise (this implies a Disconnect will be issued for the socket).
 */
// LONCHANC: "remote" is from the X.224 ConnectRequest
BOOL SendX224ConnectConfirm (PSocket pSocket, unsigned int remote)
{
    //PUChar            ptr;
    LPBYTE                  pbToSendBuf = NULL;
    UINT            cbToSendBuf = 0;
    LPBYTE                  encoded_pdu = NULL;
    UINT                    encoded_pdu_length = 0;
    CNPPDU                  cnp_pdu;
    BOOL            fAcceptSecure = FALSE;
    BOOL            fRequireSecure = FALSE;

    TRACE_OUT(("SendX224ConnectConfirm"));

    {
        RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER);

        switch (re.GetNumber(REGVAL_POL_SECURITY, DEFAULT_POL_SECURITY))
        {
            case DISABLED_POL_SECURITY:
                break;

            case REQUIRED_POL_SECURITY:
                fAcceptSecure = TRUE;
                fRequireSecure = TRUE;
                break;

            default:
                fAcceptSecure = TRUE;
                break;
        }
    }

        static X224_CC_FIXED cc_fixed =
        {
            { 3, 0, 0, UNK },    // RFC1006 header
            UNK,
            { CONNECTION_CONFIRM_PACKET, UNK, UNK, UNK, UNK, 0 } // common info
        };

    // Sanity check field sizes... these need to conform to protocol
    ASSERT (sizeof(RFC_HEADER) == 4);
    ASSERT (sizeof(X224_DATA_PACKET) == 7);
    ASSERT (sizeof(X224_CONNECT_COMMON) == 6);
    ASSERT (sizeof(X224_TPDU_INFO) == 3);

    /* X224 header */
    cc_fixed.conn.msbDest = (UChar) (remote >> 8);
    cc_fixed.conn.lsbDest = (UChar) remote;
    cc_fixed.conn.msbSrc = (UChar) (pSocket->XprtConn.nLogicalHandle >> 8);
    cc_fixed.conn.lsbSrc = (UChar) pSocket->XprtConn.nLogicalHandle;

    cnp_pdu.choice = connectConfirm_chosen;
    cnp_pdu.u.connectConfirm.bit_mask = 0;
    cnp_pdu.u.connectConfirm.protocolIdentifier = t123AnnexBProtocolId;

    if ( pSocket->fExtendedX224 )
    {
        TRACE_OUT(("SendX224ConnectConfirm reply using extended X224"));

        if ( pSocket->fIncomingSecure )
        {
            TRACE_OUT(("SendX224ConnectConfirm: reply to secure call request"));

            // Security not even initialized?
            if ( NULL == g_Transport->pSecurityInterface )
            {
                WARNING_OUT(("Can't accept secure call: no sec interface"));
            }
            // Registry indicates no secure calls? If we're in the service
            // then security is always 'on'.
            else if    ( !g_Transport->pSecurityInterface->IsInServiceContext() &&
                !fAcceptSecure)
            {
                WARNING_OUT(("Can't accept secure call: security disabled"));
            }
            else    // OK to take secure call
            {
                TRACE_OUT(("Creating security context for incoming call on socket (%d, %d).", pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle ));
                if ( NULL != (pSocket->pSC =
                    new SecurityContext(g_Transport->pSecurityInterface, "")))
                {
                    // Indicate we're ready for a secure call in the CC packet
                    cnp_pdu.u.connectConfirm.bit_mask |=
                        ConnectConfirmPDU_reliableSecurityProtocol_present;
                    cnp_pdu.u.connectConfirm.reliableSecurityProtocol.choice =
                        gssApiX224_chosen;
                    pSocket->SecState = SC_SECURE;
                }
                else
                {
                    ERROR_OUT(("Error creating sec context on received call"));
                    // We will report no-support for security in our CC
                    pSocket->SecState = SC_NONSECURE;
                }
            }
        }
        else if (    // Incoming call is not secure, but not downlevel

                // Running as a service?
                g_Transport->bInServiceContext ||
                fRequireSecure)
        {
            WARNING_OUT(("Can't accept non-secure call in RDS, or if security required"));
            return FALSE;
        }
        else
        {
            pSocket->SecState = SC_NONSECURE;
        }

                if (! g_CNPCoder->Encode((LPVOID) &cnp_pdu,
                                         CNPPDU_PDU,
                                         PACKED_ENCODING_RULES,
                                         &encoded_pdu,
                                         &encoded_pdu_length))
                {
                    ERROR_OUT(("SendX224ConnectRequest: Can't encode cnp pdu"));
                    return FALSE;
                }

                cbToSendBuf = sizeof(X224_CC_FIXED)+sizeof(X224_VARIABLE_INFO)+encoded_pdu_length;
                cc_fixed.rfc.lsbPacketSize = (UChar)cbToSendBuf;
                cc_fixed.HeaderSize = (UChar)(sizeof(X224_CONNECT_COMMON) + sizeof(X224_VARIABLE_INFO) + encoded_pdu_length);
                ASSERT( cbToSendBuf <= 128 );
                pbToSendBuf = new BYTE[cbToSendBuf];
                if (NULL == pbToSendBuf)
                {
                    ERROR_OUT(("SendX224ConnectConfirm: failed to allocate memory"));
                    return FALSE;
                }

                PBYTE pbTemp = pbToSendBuf;
                memcpy(pbTemp, (LPBYTE) &cc_fixed, sizeof(cc_fixed));
                pbTemp += sizeof(cc_fixed);

                X224_VARIABLE_INFO x224_var_info = { T_SELECTOR_2 /*0xc2*/, (UChar)encoded_pdu_length };
                memcpy(pbTemp, (LPBYTE) &x224_var_info, sizeof(x224_var_info));
                pbTemp += sizeof(x224_var_info);

                memcpy(pbTemp, encoded_pdu, encoded_pdu_length);

                g_CNPCoder->FreeEncoded(encoded_pdu);
    }
    else    // Incoming call is downlevel
    {
        if ( g_Transport->bInServiceContext || fRequireSecure)
        {
            WARNING_OUT(("Can't accept downlevel call in RDS or if security required"));
            return FALSE;
        }

        pSocket->SecState = SC_NONSECURE;

        // Downlevel: send packet w/out TSELECTOR variable portion
        cc_fixed.rfc.lsbPacketSize = sizeof(X224_CC_FIXED);
        cc_fixed.HeaderSize = sizeof(X224_CONNECT_COMMON);
        cbToSendBuf = sizeof(X224_CC_FIXED);
                pbToSendBuf = new BYTE[cbToSendBuf];
                memcpy(pbToSendBuf, (LPBYTE) &cc_fixed, sizeof(cc_fixed));
    }

    /* Attempt to send data out the socket */
#ifdef DEBUG
    TransportError error =
#endif // DEBUG
    FlushSendBuffer(pSocket, pbToSendBuf, cbToSendBuf);
#ifdef  DEBUG
    ASSERT (TRANSPORT_NO_ERROR == error);
#endif  // DEBUG
        delete [] pbToSendBuf;
    return TRUE;
}

BOOL SendX224DisconnectRequest(PSocket pSocket, unsigned int remote, USHORT usReason)
{
    LPBYTE      pbToSendBuf = NULL;
    UINT    cbToSendBuf = 0;
    RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);
    CNPPDU      cnp_pdu;
    LPBYTE      encoded_pdu = NULL;
    UINT        encoded_pdu_length = 0;

    TRACE_OUT(("SendX224DisconnectRequest"));

    static X224_DR_FIXED dr_fixed =
    {
        { 3, 0, 0, UNK },   // RFC1006 header
        UNK,
        { DISCONNECT_REQUEST_PACKET, UNK, UNK, UNK, UNK, 0 },
    };

    ASSERT (pSocket->fExtendedX224);
    ASSERT (sizeof(RFC_HEADER) == 4);
    ASSERT (sizeof(X224_DATA_PACKET) == 7);

    ::OnProtocolControl(pSocket->XprtConn, PLUGXPRT_DISCONNECTING);

    dr_fixed.disconn.msbDest = (UChar) (remote >> 8);
    dr_fixed.disconn.lsbDest = (UChar) remote;
    dr_fixed.disconn.msbSrc = (UChar) (pSocket->XprtConn.nLogicalHandle >> 8);
    dr_fixed.disconn.lsbSrc = (UChar) pSocket->XprtConn.nLogicalHandle;

    cnp_pdu.choice = disconnectRequest_chosen;
    cnp_pdu.u.disconnectRequest.bit_mask = 0;
    cnp_pdu.u.disconnectRequest.disconnectReason.choice = usReason;

    if (! g_CNPCoder->Encode((LPVOID) &cnp_pdu,
                             CNPPDU_PDU,
                             PACKED_ENCODING_RULES,
                             &encoded_pdu,
                             &encoded_pdu_length))
    {
        ERROR_OUT(("SendX224DisconnectRequest: Can't encode cnp pdu"));
        return FALSE;
    }

    cbToSendBuf = sizeof(X224_DR_FIXED) + sizeof(X224_VARIABLE_INFO) + encoded_pdu_length;
    dr_fixed.rfc.lsbPacketSize = (UChar)cbToSendBuf;
    dr_fixed.HeaderSize = (UChar)(sizeof(X224_DISCONN) + sizeof(X224_VARIABLE_INFO) + encoded_pdu_length);
    ASSERT( cbToSendBuf <= 128 );
    pbToSendBuf = new BYTE[cbToSendBuf];
    if (NULL == pbToSendBuf)
    {
        ERROR_OUT(("SendX224DisconnectRequest: failed to allocate memory"));
        return FALSE;
    }
    LPBYTE pbTemp = pbToSendBuf;
    memcpy(pbTemp, (LPBYTE) &dr_fixed, sizeof(dr_fixed));
    pbTemp += sizeof(dr_fixed);
    X224_VARIABLE_INFO x224_var_info = { 0xe0, (UChar)encoded_pdu_length };
    memcpy(pbTemp, (LPBYTE) &x224_var_info, sizeof(x224_var_info));
    pbTemp += sizeof(x224_var_info);
    memcpy(pbTemp, encoded_pdu, encoded_pdu_length);

    g_CNPCoder->FreeEncoded(encoded_pdu);

    /* Attempt to send data out the socket */
#ifdef DEBUG
    TransportError error =
#endif // DEBUG
        FlushSendBuffer(pSocket, pbToSendBuf, cbToSendBuf);
#ifdef  DEBUG
    ASSERT (TRANSPORT_NO_ERROR == error);
#endif  // DEBUG
    return TRUE;
}

/*
 *    void    ContinueAuthentication (PSocket pSocket)
 *
 *    Functional Description:
 */
void ContinueAuthentication (PSocket pSocket)
{
    ULong                packet_size;
    PUChar                Buffer;
    PSecurityContext    pSC = pSocket->pSC;

    if (NULL != pSC) {

        TRACE_OUT(("ContinueAuthentication: sending data packet"));

        ASSERT(NULL != pSC->GetTokenBuf());
        ASSERT(0 != pSC->GetTokenSiz());

        /* We send an X224 data */
        packet_size = sizeof(X224_DATA_PACKET) + pSC->GetTokenSiz();
        DBG_SAVE_FILE_LINE
        Buffer = new UChar[packet_size];
        if (NULL != Buffer)
        {
            memcpy(Buffer + sizeof(X224_DATA_PACKET),
                    pSC->GetTokenBuf(),
                    pSC->GetTokenSiz());

            /* X224 header */
            memcpy (Buffer, g_X224Header, sizeof(X224_DATA_PACKET));
            AddRFCSize (Buffer, packet_size);

            /* Attempt to send data out the socket */
#ifdef DEBUG
            TransportError error = FlushSendBuffer(pSocket, (LPBYTE) Buffer, packet_size);
            ASSERT (TRANSPORT_NO_ERROR == error);
#else  // DEBUG
            FlushSendBuffer(pSocket, (LPBYTE) Buffer, packet_size);
#endif  // DEBUG
            delete [] Buffer;
        }
        else {
            // bugbug: what do we need to do in case of a mem alloc failure?
            WARNING_OUT (("ContinueAuthentication: memory allocation failure."));
        }
    }
    else {
        ERROR_OUT(("ContinueAuthentication called w/ bad socket"));
    }
}

/*
 *    The following function processes the variable part of incoming X.224
 *    CONNECT_REQUEST and CONNECT_CONFIRM PDUs.
 *    For now, it can only process Max PDU size and security T_SELECTOR requests.
 */
BOOL ProcessX224ConnectPDU (PSocket pSocket, PUChar CP_ptr, UINT CP_length, ULONG *pNotify)
{
    UChar                length;
    BOOL                bSecurityInfoFound = FALSE;
    PSecurityContext     pSC = pSocket->pSC;

/* This structure must be accessed using byte-alignment */
#pragma pack(1)
    X224_VARIABLE_INFO        *pX224VarInfo;
/* return to normal alignment */
#pragma pack()

    while (CP_length > 0) {
        pX224VarInfo = (X224_VARIABLE_INFO *) CP_ptr;

        /*
         *    Check the packet to see if it contains a valid TPDU_SIZE part.  If it
         *    does, we need to reset the max packet size for this socket.
         */
        if (TPDU_SIZE == pX224VarInfo->InfoType) {
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
                X224_TPDU_INFO        *pX224TpduSize;
/* return to normal alignment */
#pragma pack()
            pX224TpduSize = (X224_TPDU_INFO *) CP_ptr;
            ASSERT (pX224TpduSize->InfoSize == 1);
            if (pX224TpduSize->Info != DEFAULT_TPDU_SIZE) {

                // We do not accept too small PDU sizes
                if ((pX224TpduSize->Info < LOWEST_TPDU_SIZE) && (pX224TpduSize->Info < HIGHEST_TPDU_SIZE))
                {
                  if (NULL != pNotify)
                    *pNotify = TPRT_NOTIFY_INCOMPATIBLE_T120_TPDU;
                  return FALSE;
                }
                pSocket->Max_Packet_Length = (1 << pX224TpduSize->Info);
            }
        }
        /*
         *    Check the packet to see if it contains a valid
         *    TSELECTOR variable portion. If so, make sure it's security related
         *    and include one in the reply
         */
        else if (T_SELECTOR == pX224VarInfo->InfoType || T_SELECTOR_2 == pX224VarInfo->InfoType)
                {
                    // Try to decode
                    LPVOID pdecoding_buf = NULL;
                    UINT decoding_len = 0;
                    LPBYTE pbEncoded_data = CP_ptr + sizeof(X224_VARIABLE_INFO);
                    if ( g_CNPCoder->Decode (pbEncoded_data,
                                             pX224VarInfo->InfoSize,
                                             CNPPDU_PDU, PACKED_ENCODING_RULES,
                                             (LPVOID *) &pdecoding_buf, &decoding_len))
                    {
                        bSecurityInfoFound = TRUE;
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
    CNPPDU        *pCnp_pdu;
/* return to normal alignment */
#pragma pack()
                        pCnp_pdu = (CNPPDU *) pdecoding_buf;
                        if (pSocket->Read_State == CONNECTION_REQUEST) {
                            TRACE_OUT(("CR packet using TSELECTOR extension"));
                            pSocket->fExtendedX224 = TRUE;
                            if (pCnp_pdu->u.connectRequest.bit_mask & reliableSecurityProtocols_present)
                            {
                                PConnectRequestPDU_reliableSecurityProtocols pRSP = pCnp_pdu->u.connectRequest.reliableSecurityProtocols;
                                if (gssApiX224_chosen == pRSP->value.choice)
                                {
                                    pSocket->fIncomingSecure = TRUE;
                                }
                            }
                        }
                        else {
                            ASSERT (pSocket->Read_State == CONNECTION_CONFIRM);
                            if ((NULL != pSC) && (pSC->ContinueNeeded())) {
                                ConnectConfirmPDU *pCnpCc = &pCnp_pdu->u.connectConfirm;
                                if ((pCnpCc->bit_mask & ConnectConfirmPDU_reliableSecurityProtocol_present )
                                    && gssApiX224_chosen == pCnpCc->reliableSecurityProtocol.choice)
                                {
                                    // Everything is OK, we got an extended X224 response
                                    // to our secure CR.
                                    ContinueAuthentication(pSocket);
                                }
                                else {
                                    WARNING_OUT(("No-support response to secure call attempt"));
                                    if (NULL != pNotify)
                                        *pNotify = TPRT_NOTIFY_REMOTE_NO_SECURITY;
                                    return FALSE;
                                }
                            }
                        }
                    }
                    g_CNPCoder->FreeDecoded(CNPPDU_PDU, pdecoding_buf);
        }
        else {
            ERROR_OUT (("ProcessX224ConnectPDU: Received X.224 Connect packet with unrecognizable parts."));
        }

        // Adjust the pointer and length and the X.224 CR packet.
        length = pX224VarInfo->InfoSize + sizeof(X224_VARIABLE_INFO);
        CP_ptr += length;
        CP_length -= length;
    }

    if (bSecurityInfoFound == FALSE) {
        if ((pSocket->Read_State == CONNECTION_CONFIRM) && (pSC != NULL) && pSC->ContinueNeeded()) {
            WARNING_OUT(("Downlevel response to secure call attempt"));
            if (NULL != pNotify)
              *pNotify = TPRT_NOTIFY_REMOTE_DOWNLEVEL_SECURITY;
            return FALSE;
        }
    }

    return TRUE;
}

void ProcessX224DisconnectPDU(PSocket pSocket, PUChar CP_ptr, UINT CP_length, ULONG *pNotify)
{
    UChar                length;
    BOOL                bSecurityInfoFound = FALSE;
    PSecurityContext     pSC = pSocket->pSC;

    /* This structure must be accessed using byte-alignment */
#pragma pack(1)
    X224_VARIABLE_INFO        *pX224VarInfo;
    /* return to normal alignment */
#pragma pack()

    while (CP_length > 0) {
        pX224VarInfo = (X224_VARIABLE_INFO *) CP_ptr;
        if ( 0xe0 == pX224VarInfo->InfoType) {
            LPVOID pdecoding_buf = NULL;
            UINT decoding_len = 0;
            LPBYTE pbEncoded_data = CP_ptr + sizeof(X224_VARIABLE_INFO);
            if ( g_CNPCoder->Decode (pbEncoded_data,
                                     pX224VarInfo->InfoSize,
                                     CNPPDU_PDU, PACKED_ENCODING_RULES,
                                     (LPVOID *) &pdecoding_buf, &decoding_len))
            {
#pragma pack(1)
                CNPPDU        *pCnp_pdu;
                /* return to normal alignment */
#pragma pack()
                pCnp_pdu = (CNPPDU *) pdecoding_buf;
                if (disconnectRequest_chosen == pCnp_pdu->choice)
                {
                    switch (pCnp_pdu->u.disconnectRequest.disconnectReason.choice)
                    {
                    case securityDenied_chosen:
                        *pNotify = TPRT_NOTIFY_REMOTE_REQUIRE_SECURITY;
                        break;
                    default:
                        *pNotify = TPRT_NOTIFY_OTHER_REASON;
                        break;
                    }
                }
            }
            g_CNPCoder->FreeDecoded(decoding_len, pdecoding_buf);
        }
        length = pX224VarInfo->InfoSize + sizeof(X224_VARIABLE_INFO);
        CP_ptr += length;
        CP_length -= length;
    }
}


/*
 *    void DisconnectRequest (TransportConnection    XprtConn)
 *
 *    Functional Description:
 *        This function closes the socket and deletes its connection node.
 */
void DisconnectRequest (TransportConnection    XprtConn,
                        ULONG            ulNotify)
{
    PSocket    pSocket;

    TRACE_OUT(("DisconnectRequest"));

    /* If the transport connection handle is not registered, return error */
    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn, TRUE)))
    {
        // LONCHANC: cannot do Remove in the above line because PurgeRequest() uses it again.
        ::PurgeRequest(XprtConn);

        // SendStatusMessage (pSocket -> Remote_Address, TSTATE_NOT_CONNECTED, IDS_NULL_STRING);
        if (IS_PLUGGABLE_PSTN(XprtConn))
        {
            CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
            if (NULL != p)
            {
                p->TDisconnectRequest();
            }
        }

        /* Free the structures and close the socket */
        TransportConnection XprtConn2 = XprtConn;
        if (IS_SOCKET(XprtConn2))
        {
            XprtConn2.nLogicalHandle = INVALID_SOCKET;
        }
        ::freeSocket(pSocket, XprtConn2);

        // Free up QoS resources if this disconnect was the
        // last connected socket.
        MaybeReleaseQoSResources();

        // Notify the user
        if (TPRT_NOTIFY_NONE != ulNotify)
        {
            TRACE_OUT (("TCP Callback: g_Transport->DisconnectIndication (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));

            /* We issue a callback to the user to notify him of the message */
            g_Transport->DisconnectIndication(XprtConn, ulNotify);
        }
    }
    else
    {
        WARNING_OUT(("DisconnectRequest: logical handle (%d, %d) not found",
                XprtConn.eType, XprtConn.nLogicalHandle));
    }

    ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTED);
}

typedef enum {
    RECVRET_CONTINUE = 0,
    RECVRET_NON_FATAL_ERROR,
    RECVRET_DISCONNECT,
    RECVRET_NO_PLUGGABLE_CONNECTION,
} RecvReturn;

/* RecvReturn        Call_recv (PSocket pSocket)
 *
 * Functional Description:
 *        This function calls recv once and checks for errors coming from the
 *        recv call.  It knows about the socket's state from the "pSocket" argument
 *        and uses this info to create the arguments for the recv call.
 *
 * Return value:
 *        Continue, if everything went ok and we have new data
 *        Non_Fatal_Error, if no real error has happenned, but we did not recv all data we asked for
 *        Disconnect, if a real error has occurred, or the other side has disconnected.
 */
RecvReturn Call_recv (PSocket pSocket)
{
    PUChar        buffer;
    int            length;
    int            bytes_received;
    BOOL        bAllocationOK;
    RecvReturn    rrCode = RECVRET_NON_FATAL_ERROR;
    PLUGXPRT_RESULT plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    TRACE_OUT(("Call_recv"));

    if (READ_HEADER != pSocket->Read_State)
    {
        ASSERT ((pSocket->X224_Length) > 0 && (pSocket->X224_Length <= 8192));

        // Compute how much data we have to read from this X.224 pkt.
        length = pSocket->X224_Length - sizeof(X224_DATA_PACKET);

        // Space allocation
        if (! pSocket->bSpaceAllocated)
        {
            // We need to allocate the space for the recv call.
            if (NULL == pSocket->Data_Indication_Buffer)
            {
                DBG_SAVE_FILE_LINE
                pSocket->Data_Memory = AllocateMemory (
                                NULL, pSocket->X224_Length,
                                ((READ_DATA == pSocket->Read_State) ?
                                RECV_PRIORITY : HIGHEST_PRIORITY));
                // Leave space for the X.224 header in the newly allocated data buffer
                pSocket->Data_Indication_Length = sizeof (X224_DATA_PACKET);
                bAllocationOK = (pSocket->Data_Memory != NULL);
            }
            else
            {
                // This is an MCS PDU broken up in many X.224 packets.
                ASSERT (READ_DATA == pSocket->Read_State);
                bAllocationOK = ReAllocateMemory (&(pSocket->Data_Memory), length);
            }

            // Check whether the allocations were successful.
            if (bAllocationOK)
            {
                pSocket->bSpaceAllocated = TRUE;
                pSocket->Data_Indication_Buffer = pSocket->Data_Memory->GetPointer();
                /*
                 *    If this is an X.224 CONNECT_REQUEST or CONNECT_CONFIRM packet,
                 *    we need to copy the first 7 bytes into the buffer for the whole
                 *    packet.
                 */
                if (READ_DATA != pSocket->Read_State)
                {
                    memcpy ((void *) pSocket->Data_Indication_Buffer,
                            (void *) &(pSocket->X224_Header),
                            sizeof(X224_DATA_PACKET));
                }
            }
            else
            {
                /*
                 *    We will retry the operation later.
                 */
                WARNING_OUT (("Call_recv: Buffer allocation failed."));
                g_pMCSController->HandleTransportWaitUpdateIndication(TRUE);
                goto ExitLabel;
            }
        }
        buffer = pSocket->Data_Indication_Buffer + pSocket->Data_Indication_Length;
    }
    else
    {
        buffer = (PUChar) &(pSocket->X224_Header);
        length = sizeof(X224_DATA_PACKET);
    }

    // Adjust "buffer" and "length" for data already read from the current X.224 pkt.
    buffer += pSocket->Current_Length;
    length -= pSocket->Current_Length;

    ASSERT (length > 0);

    if (IS_SOCKET(pSocket->XprtConn))
    {
        // Issue the recv call.
        bytes_received = recv (pSocket->XprtConn.nLogicalHandle, (char *) buffer, length, 0);
    }
    else
    {
        bytes_received = ::X224Recv(pSocket, buffer, length, &plug_rc);
    }

    if (bytes_received == length)
    {
        TRACE_OUT (("Call_recv: Received %d bytes on socket (%d, %d).", bytes_received,
                            pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        // We have received the whole X.224 packet.
        if (READ_HEADER != pSocket->Read_State)
        {
            pSocket->Data_Indication_Length += pSocket->X224_Length - sizeof(X224_DATA_PACKET);
        }
        // Reset the current length variable for the next Call_recv().
        pSocket->Current_Length = 0;
        rrCode = RECVRET_CONTINUE;
    }
    // Handle errors
    else
    if (bytes_received == SOCKET_ERROR)
    {
        if (IS_SOCKET(pSocket->XprtConn))
        {
            if(WSAGetLastError() == WSAEWOULDBLOCK)
            {
                TRACE_OUT(("Call_recv: recv blocked on socket (%d, %d).",
                        pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
            }
            else
            {
                 /* If the error is not WOULD BLOCK, we have a real error. */
                WARNING_OUT (("Call_recv: Error %d on recv. Socket: (%d, %d). Disconnecting...",
                            WSAGetLastError(), pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
                rrCode = RECVRET_DISCONNECT;
            }
        }
        else
        {
            if (PLUGXPRT_RESULT_SUCCESSFUL == plug_rc)
            {
                // do nothing, treat it as WSAEWOULDBLOCK
            }
            else
            {
                 /* If the error is not WOULD BLOCK, we have a real error. */
                WARNING_OUT (("Call_recv: Error %d on recv. Socket: (%d, %d). Disconnecting...",
                            WSAGetLastError(), pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
                rrCode = RECVRET_DISCONNECT;
            }
        }
    }
    else
    if (bytes_received > 0)
    {
        TRACE_OUT(("Call_recv: Received %d bytes out of %d bytes requested on socket (%d, %d).",
                    bytes_received, length, pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        // We received only part of what we wanted.  We retry later.
        pSocket->Current_Length += bytes_received;
    }
    else
    {
        WARNING_OUT(("Call_recv: Socket (%d, %d) has been gracefully closed.",
                    pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        rrCode = RECVRET_DISCONNECT;
    }

ExitLabel:
    return rrCode;
}


int X224Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("X224Recv"));

    if (IS_PLUGGABLE_X224(pSocket->XprtConn))
    {
        return ::SubmitPluggableRead(pSocket, buffer, length, plug_rc);
    }

    if (IS_PLUGGABLE_PSTN(pSocket->XprtConn))
    {
        return Q922Recv(pSocket, buffer, length, plug_rc);
    }

    ERROR_OUT(("X224Recv: invalid plugable type (%d, %d)",
                pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
    return SOCKET_ERROR;
}


int Q922Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    ERROR_OUT(("Q922Recv: NYI (%d, %d)",
                pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
    return SOCKET_ERROR;
}


typedef enum {
    FreeX224AndExit,
    ErrorExit,
    ImmediateExit
} ExitWay;


/*
 *    void    ReadRequest ( TransportConnection )
 *
 *    Functional Description:
 *        This function will attempt to read and process a full X.224 packet.
 *        However, it may only be able to read part of a packet or fail to
 *        process it at this time.  In this case, it must keep enough state
 *        info for the next entrance into this function, to be able to handle
 *        the partly-received or unprocessed X.224 packet.
 */
void ReadRequest (TransportConnection XprtConn)
{
    PSocket                pSocket;
    ExitWay                ew = ImmediateExit;
    RecvReturn            rrCode;
    ULONG               ulNotify = TPRT_NOTIFY_OTHER_REASON;

    TRACE_OUT(("ReadRequest"));

    if (IS_PLUGGABLE_PSTN(XprtConn))
    {
        ERROR_OUT(("ReadRequest: PSTN should not be here"));
        return;
    }

    /* If the transport connection handle is not registered, return */
    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        if (pSocket->State != WAITING_FOR_CONNECTION)
        {
            PSecurityContext     pSC = pSocket->pSC;
            /*
             *    If we haven't read the header of the incoming packet yet,
             *    we need to read it into the header space
             */
            if (READ_HEADER == pSocket->Read_State)
            {
                rrCode = Call_recv (pSocket);
                if (RECVRET_CONTINUE == rrCode)
                {
                    // We need to allocate the space for the rest of the X.224 packet.
                    pSocket->bSpaceAllocated = FALSE;

                    // Find the length of the X.224 packet.
                    pSocket->X224_Length = (pSocket->X224_Header.rfc.msbPacketSize << 8) +
                                            pSocket->X224_Header.rfc.lsbPacketSize;
                    /*
                     *    We have the whole X.224 header. Compute the next state,
                     *    based on the packet type.
                     */
                    switch (pSocket->X224_Header.PacketType)
                    {
                    case DATA_PACKET:
                        pSocket->Read_State = READ_DATA;
                        break;

                    case CONNECTION_CONFIRM_PACKET:
                        if (pSocket->State != X224_CONNECTED)
                        {
                            pSocket->Read_State = CONNECTION_CONFIRM;
                        }
                        else
                        {
                            ERROR_OUT (("ReadRequest: Received X.224 CONNECTION_CONFIRM packet while already connected!! Socket: (%d, %d).",
                                        XprtConn.eType, XprtConn.nLogicalHandle));
                            ew = ErrorExit;
                        }
                        break;

                    case CONNECTION_REQUEST_PACKET:
                        // we just received a X224 Connect request
                        pSocket->Read_State = CONNECTION_REQUEST;
                        ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTING);
                        break;

                    case DISCONNECT_REQUEST_PACKET:
                        // we just received a X224 Disconnect request
                        pSocket->Read_State = DISCONNECT_REQUEST;
                        ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTING);
                        break;

                    default:
                        // We have lost sync with the remote side.
                        ERROR_OUT (("ReadRequest: Bad X.224 packet on socket (%d, %d). Disconnecting...", XprtConn.eType, XprtConn.nLogicalHandle));
                        ew = ErrorExit;
                        break;
                    }
                }
                else
                if (RECVRET_DISCONNECT == rrCode)
                {
                    ew = ErrorExit;
                }
            }

            if ((READ_DATA <= pSocket->Read_State) &&
                (CONNECTION_REQUEST >= pSocket->Read_State))
            {
                rrCode = Call_recv (pSocket);
                if (RECVRET_CONTINUE == rrCode)
                {
                    // We now have the whole X.224 packet.

                    switch (pSocket->Read_State)
                    {
                    case READ_DATA:
                        // Check whether this is the final X.224 packet
                        if (pSocket->X224_Header.FinalPacket & EOT_BIT)
                        {
                            // If we're waiting for a security data packet we will process
                            // this internally without passing it up to the transport
                            // client.
                            if (NULL != pSC)
                            {
                                if (pSC->WaitingForPacket())
                                {
                                    TransportSecurityError SecErr;

                                    SecErr = pSC->AdvanceState((PBYTE) pSocket->Data_Indication_Buffer +
                                                            sizeof(X224_DATA_PACKET),
                                                        pSocket->Data_Indication_Length -
                                                            sizeof(X224_DATA_PACKET));

                                    if (TPRTSEC_NOERROR != SecErr)
                                    {
                                        // Something has gone wrong. Need to disconnect
                                        delete pSC;
                                        pSocket->pSC = NULL;
                                        ulNotify = TPRT_NOTIFY_AUTHENTICATION_FAILED;
                                        ew = ErrorExit;
                                        break;
                                    }

                                    if (pSC->ContinueNeeded())
                                    {
                                        // We need to send out another token
                                        // bugbug: what should we do if this fails?
                                        ContinueAuthentication(pSocket);
                                    }

                                    if (pSC->StateComplete())
                                    {
                                        // We're connected... inform the client
                                        TRACE_OUT(("deferred g_Transport->ConnectConfirm"));
                                        g_Transport->ConnectConfirm(XprtConn);
                                    }
                                    ew = FreeX224AndExit;
                                    break;
                                }

                                // We must decrypt the data (in place)
                                TRACE_OUT(("Decrypting received data"));

                                if (! pSC->Decrypt(pSocket->Data_Indication_Buffer +
                                                        sizeof(X224_DATA_PACKET),
                                                    pSocket->Data_Indication_Length -
                                                        sizeof(X224_DATA_PACKET)))
                                {
                                    TRACE_OUT(("Sending %d bytes to application",
                                                pSocket->Data_Indication_Length - sizeof(X224_DATA_PACKET)));
                                }
                                else
                                {
                                    ERROR_OUT(("Error decrypting packet"));
                                    ew = ErrorExit;
                                    break;
                                }
                            }
                            pSocket->Read_State = DATA_READY;
                        }
                        else
                        {
                            // This and the next X.224 packets are part of a bigger MCS data PDU.
                            ASSERT (NULL == pSC);
                            pSocket->Read_State = READ_HEADER;
                        }
                        break;

                    case CONNECTION_CONFIRM:
                        {
                            TRACE_OUT(("ReadRequest: X224 CONNECTION_CONFIRM_PACKET received"));
                                BOOL    bCallback = ((NULL == pSC) || (! pSC->ContinueNeeded()));

                            // Process the CC packet.
                            if (FALSE == ProcessX224ConnectPDU (pSocket,
                                                pSocket->Data_Indication_Buffer + sizeof(X224_CONNECT),
                                                pSocket->X224_Length - sizeof (X224_CONNECT), &ulNotify))
                            {
                                ew = ErrorExit;
                                break;
                            }

                            // Issue the callback if the CC was not on a secure connection
                            // Otherwise, we don't notify the transport client yet... still need to
                            // exchange security information. TRANSPORT_CONNECT_CONFIRM will
                            // be sent when the final security data token is received and
                            // processed.
                            if (bCallback)
                            {
                                TRACE_OUT (("TCP Callback: g_Transport->ConnectConfirm (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                                /* We issue a callback to the user to notify him of the message */
                                g_Transport->ConnectConfirm(XprtConn);
                            }
                            pSocket->State = X224_CONNECTED;
                            ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                            ew = FreeX224AndExit;
                        }
                        break;

                    case CONNECTION_REQUEST:
                        {
                                UINT             remote;
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
                                X224_CONNECT        *pConnectRequest;
/* return to normal alignment */
#pragma pack()
                            /* Grab the remote connection ID */
                            TRACE_OUT (("ReadRequest: X224 CONNECTION_REQUEST_PACKET received"));
                            pConnectRequest = (X224_CONNECT *) pSocket->Data_Indication_Buffer;
                            remote = ((unsigned int) pConnectRequest->conn.msbSrc) << 8;
                            remote |= pConnectRequest->conn.lsbSrc;

                            if (FALSE == ProcessX224ConnectPDU (pSocket, (PUChar) (pConnectRequest + 1),
                                                pSocket->X224_Length - sizeof (X224_CONNECT), &ulNotify))
                            {
                                ew = ErrorExit;
                                break;
                            }

                            if (::SendX224ConnectConfirm(pSocket, remote))
                            {
                                // success
                                if (IS_PLUGGABLE(pSocket->XprtConn))
                                {
                                    pSocket->State = SOCKET_CONNECTED;
                                    g_Transport->ConnectIndication(XprtConn);
                                    ASSERT(X224_CONNECTED == pSocket->State);
                                }
                                ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                                ew = FreeX224AndExit;
                            }
                            else
                            {
                                if (pSocket->fExtendedX224)
                                {
                                    ::SendX224DisconnectRequest(pSocket, remote, securityDenied_chosen);
                                }
                                ew = ErrorExit;
                            }
                        }
                        break;

                    case DISCONNECT_REQUEST:
                        {
                            UINT               remote;
                            X224_DR_FIXED      *pX224_DR_fixed;

                            TRACE_OUT(("ReadRequest: X224 DISCONNECT_REQUEST_PACKET received"));
                            pX224_DR_fixed = (X224_DR_FIXED *) pSocket->Data_Indication_Buffer;
                            remote = ((unsigned int) pX224_DR_fixed->disconn.msbSrc) << 8;
                            remote |= pX224_DR_fixed->disconn.lsbSrc;

                            ProcessX224DisconnectPDU(pSocket, pSocket->Data_Indication_Buffer + sizeof(X224_DR_FIXED),
                                                     pSocket->X224_Length - sizeof(X224_DR_FIXED), &ulNotify);
                            ew = ErrorExit;
                        }
                        break;
                    }
                }
                else if (RECVRET_DISCONNECT == rrCode)
                {
                    ew = ErrorExit;
                }
            }

            if (DATA_READY == pSocket->Read_State)
            {
                TransportData        transport_data;

                // Fill in the callback structure.
                transport_data.transport_connection = XprtConn;
                transport_data.user_data = pSocket->Data_Indication_Buffer;
                transport_data.user_data_length = pSocket->Data_Indication_Length;
                transport_data.memory = pSocket->Data_Memory;

                /*
                 *    If there is an incoming security context associated with this
                 *  socket, we must adjust pointer by header and overall size by header and
                 *    trailer.
                 */
                if (NULL != pSC)
                {
                    transport_data.user_data += pSC->GetStreamHeaderSize();
                    transport_data.user_data_length -= (pSC->GetStreamHeaderSize() +
                                                        pSC->GetStreamTrailerSize());
                }

                if (TRANSPORT_NO_ERROR == g_Transport->DataIndication(&transport_data))
                {
                    TRACE_OUT (("ReadRequest: %d bytes were accepted from socket (%d, %d)",
                                transport_data.user_data_length, XprtConn.eType, XprtConn.nLogicalHandle));
                    // Prepare for the next X.224 packet
                    pSocket->Read_State = READ_HEADER;
                    pSocket->Data_Indication_Buffer = NULL;
                    pSocket->Data_Memory = NULL;
                }
                else
                {
                    WARNING_OUT(("ReadRequest: Error on g_Transport->DataIndication from socket (%d, %d)",
                                XprtConn.eType, XprtConn.nLogicalHandle));
                }
            }
        }
        else
        {
            WARNING_OUT (("ReadRequest: socket (%d, %d) is in WAITING_FOR_CONNECTION state.", XprtConn.eType, XprtConn.nLogicalHandle));
        }
    }
    else
    {
        WARNING_OUT (("ReadRequest: socket (%d, %d) can not be found.", XprtConn.eType, XprtConn.nLogicalHandle));
    }

    switch (ew)
    {
    case FreeX224AndExit:
        if (NULL != pSocket)
        {
            // Free the buffers we have allocated.
            pSocket->FreeTransportBuffer();
            // Prepare for the next X.224 packet
            pSocket->Read_State = READ_HEADER;
        }
        break;

    case ErrorExit:
        // We get here only if we need to disconnect the socket (because of an error)
        ASSERT(TPRT_NOTIFY_NONE != ulNotify);
        ::DisconnectRequest(XprtConn, ulNotify);
        break;
    }

    if (NULL != pSocket)
    {
        pSocket->Release(); // offset the previous AddRef.
    }
}


/*
 *    TransportError    FlushSendBuffer ( PSocket pSocket )
 *
 *    Functional Description:
 *        This function sends any pending data through the transport.
 */
TransportError    FlushSendBuffer(PSocket pSocket, LPBYTE buffer, UINT length)
{
    int     bytes_sent = SOCKET_ERROR;
    PLUGXPRT_RESULT plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    TRACE_OUT(("FlushSendBuffer"));

    /* send the data */
    if (IS_SOCKET(pSocket->XprtConn))
    {
        bytes_sent = ::send(pSocket->XprtConn.nLogicalHandle, (PChar) buffer,
                            (int) length, 0);
    }
    else
    if (IS_PLUGGABLE_X224(pSocket->XprtConn))
    {
        bytes_sent = ::SubmitPluggableWrite(pSocket, buffer, length, &plug_rc);
    }
    else
    if (IS_PLUGGABLE_PSTN(pSocket->XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(pSocket);
        if (NULL != p)
        {
            bytes_sent = p->TDataRequest(buffer, length, &plug_rc);
        }
        else
        {
            plug_rc = PLUGXPRT_RESULT_WRITE_FAILED;
        }
    }

    if (bytes_sent == SOCKET_ERROR)
    {
        if (IS_SOCKET(pSocket->XprtConn))
        {
            /* If the error is not WOULD BLOCK, it is a real error! */
            if (::WSAGetLastError() != WSAEWOULDBLOCK)
            {
                WARNING_OUT (("FlushSendBuffer: Error %d on write", ::WSAGetLastError()));

                 /* Notify the owner of the broken connection */
                WARNING_OUT (("FlushSendBuffer: Sending up DISCONNECT_INDICATION"));
                // SendStatusMessage (pSocket -> Remote_Address,  TSTATE_REMOVED, IDS_NULL_STRING);
                ::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
                return (TRANSPORT_WRITE_QUEUE_FULL);
            }
        }
        else
        {
            // do nothing if it is WSAEWOULDBLOCK
            if (PLUGXPRT_RESULT_SUCCESSFUL != plug_rc)
            {
                 /* Notify the owner of the broken connection */
                WARNING_OUT (("FlushSendBuffer: Sending up DISCONNECT_INDICATION"));
                // SendStatusMessage (pSocket -> Remote_Address,  TSTATE_REMOVED, IDS_NULL_STRING);
                ::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
                return (TRANSPORT_WRITE_QUEUE_FULL);
            }
        }

        bytes_sent = 0;
    }

     /* If the transport layer did not accept the data, its write buffers are full */
    if (bytes_sent != (int) length)
    {
        ASSERT (bytes_sent == 0);
        TRACE_OUT(("FlushSendBuffer: returning TRANSPORT_WRITE_QUEUE_FULL"));
        return (TRANSPORT_WRITE_QUEUE_FULL);
    }

    // Increment our counter of bytes sent since last QoS notification
    if (bytes_sent)
    {
           QoSLock();
           g_dwSentSinceLastQoS += bytes_sent;
           QoSUnlock();
    }

    TRACE_OUT (("FlushSendBuffer: %d bytes sent on Socket (%d, %d).",
                length, pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));

    return (TRANSPORT_NO_ERROR);
}



/*
 *    SegmentX224Data
 *
 *    This function segments outgoing data into X.224 packets of the appropriate size.
 *    It should not be called in a NM to NM call or in a call when we have negotiated an
 *    X.224 max PDU size of at least the size of a max MCS PDU.  NM attempts to negotiate
 *    X.224 sizes of 8K, but will accept anything the other side proposes.
 *    This function does memcpy's so it will slow us down sending data.
 *
 *    The 2 buffers specified by "ptr1" and "ptr2" and their lengths are used to create
 *    one stream of X.224 bytes.  The function will return TRANSPORT_WRITE_QUEUE_FULL if
 *    it fails to allocate the necessary amount of memory.
 */
TransportError SegmentX224Data (PSocket pSocket,
                                LPBYTE *pPtr1,     UINT *pLength1,
                                LPBYTE Ptr2,     UINT Length2)
{
    TransportError        TransError;
    UINT                length;
    LPBYTE                ptr1 = *pPtr1 + sizeof (X224_DATA_PACKET);
    UINT                length1 = *pLength1 - sizeof (X224_DATA_PACKET);
    LPBYTE                ptr;
    UINT                max_pdu_length = pSocket->Max_Packet_Length;
    X224_DATA_PACKET    l_X224Header = {3, 0, (UChar) (max_pdu_length >> 8), (UChar) (max_pdu_length & 0xFF),
                                        2, DATA_PACKET, 0};
    UINT                last_length;
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
    X224_DATA_PACKET    *pX224Data;
/* return to normal alignment */
#pragma pack()


    ASSERT(! IS_PLUGGABLE_PSTN(pSocket->XprtConn));

    // Calculate how much space we need.
    length = *pLength1 + Length2;
    ASSERT (pSocket->Max_Packet_Length < length);
    ASSERT (pSocket->Max_Packet_Length > sizeof(X224_DATA_PACKET));

    max_pdu_length -= sizeof (X224_DATA_PACKET);
    /*
     *    Calculate the space we need to allocate.  Notice that the data already
     *    contains one X.224 header.
     */
    length += (length / max_pdu_length) * sizeof (X224_DATA_PACKET);
    *pPtr1 = Allocate (length);

    if (*pPtr1 != NULL) {
        TransError = TRANSPORT_NO_ERROR;
        ptr = *pPtr1;

        // Go through the 1st buffer.
        while (length1 > 0) {
            // Copy the X.224 header.
            memcpy (ptr, &l_X224Header, sizeof(X224_DATA_PACKET));
            pX224Data = (X224_DATA_PACKET *) ptr;
            ptr += sizeof (X224_DATA_PACKET);

            // Copy data
            length = ((max_pdu_length > length1) ? length1 : max_pdu_length);
            memcpy (ptr, ptr1, length);
            last_length = length;

            // Advance pointers
            ptr1 += length;
            ptr += length;
            length1 -= length;
        }

        // If there is space in the current X.224 PDU, we need to use it.
        length = max_pdu_length - length;
        if (length > 0 && Length2 > 0) {
            if (length > Length2)
                length = Length2;
            memcpy (ptr, Ptr2, length);
            last_length += length;
            Ptr2 += length;
            ptr += length;
            Length2 -= length;
        }

        // Go through the 2nd buffer.
        while (Length2 > 0) {
            // Copy the X.224 header.
            memcpy (ptr, &l_X224Header, sizeof(X224_DATA_PACKET));
            pX224Data = (X224_DATA_PACKET *) ptr;
            ptr += sizeof (X224_DATA_PACKET);

            // Copy data
            length = ((max_pdu_length > Length2) ? Length2 : max_pdu_length);
            memcpy (ptr, Ptr2, length);
            last_length = length;

            // Advance pointers
            Ptr2 += length;
            ptr += length;
            Length2 -= length;
        }

        // Prepare for return
        *pLength1 = (UINT)(ptr - *pPtr1);

        // Set the last X.224 header
        last_length += sizeof(X224_DATA_PACKET);
        pX224Data->FinalPacket = EOT_BIT;
        pX224Data->rfc.msbPacketSize = (UChar) (last_length >> 8);
        pX224Data->rfc.lsbPacketSize = (UChar) (last_length & 0xFF);
    }
    else {
        ERROR_OUT (("SegmentX224Data: Failed to allocate memory of length %d.", length));
        TransError = TRANSPORT_WRITE_QUEUE_FULL;
    }

    return TransError;
}

/*
 *    SendSecureData
 *
 *    This function segments secure data into X.224 packets, if needed, and flushes them through
 *    the transport.  "pBuf" and "cbBuf" provide the encrypted data buffer and length.
 */
TransportError SendSecureData (PSocket pSocket, LPBYTE pBuf, UINT cbBuf)
{
    TransportError        TransError;
    LPBYTE                pBuf_Copy = pBuf;
    UINT                cbBuf_Copy = cbBuf;

    // Do we need to segment the data into X.224 packets?
    if (pSocket->Max_Packet_Length >= cbBuf) {
        TransError = TRANSPORT_NO_ERROR;
    }
    else {
        TransError = SegmentX224Data (pSocket, &pBuf, &cbBuf, NULL, 0);
    }

    // Flush the data, if everything OK so far.
    if (TRANSPORT_NO_ERROR == TransError)
        TransError = FlushSendBuffer (pSocket, pBuf, cbBuf);

    // If we segmented the data, we need to free the segmented buffer.
    if (pBuf != pBuf_Copy)
        Free(pBuf);

    // If there are errors, we need to store the decrypted data for the next time, so don't free it.
    if (TRANSPORT_NO_ERROR == TransError) {
        LocalFree(pBuf_Copy);
    }

    return TransError;
}

/*
 *    TransportError    DataRequest (    TransportConnection    XprtConn,
 *                                    PSimplePacket    packet)
 *
 *    Functional Description:
 *        This function is used to send a data packet to the remote site.
 *        If the user_data_length is zero, and we have no pending data,
 *        it sends a keep-alive (zero-length) packet.
 */
TransportError    DataRequest (TransportConnection    XprtConn,
                            PSimplePacket    packet)
{
    PSocket            pSocket;
    LPBYTE            ptr1, ptr2;
    UINT            length1, length2;
    TransportError    TransError = TRANSPORT_NO_ERROR;

    TRACE_OUT(("DataRequest: packet=0x%x", packet));

    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        // First, we need to handle the retry operations.
        if (NULL != pSocket->pSC) {
                LPBYTE lpBuf;
            /*
             *    Check to see whether we have already encrypted, but not sent
             *    the last piece of data.
             */
            lpBuf = pSocket->Retry_Info.sbiBufferInfo.lpBuffer;
            if (NULL != lpBuf) {
                TransError = SendSecureData (pSocket, lpBuf,
                                            pSocket->Retry_Info.sbiBufferInfo.uiLength);

                if (TransError == TRANSPORT_NO_ERROR) {
                    TRACE_OUT(("DataRequest: Sent previously-encrypted piece of data."));
                    pSocket->Retry_Info.sbiBufferInfo.lpBuffer = NULL;
                }
            }
        }
        else {
                PDataPacket        pdpPacket = pSocket->Retry_Info.pUnfinishedPacket;

            // Check to see whether we have half-sent the last packet.
            if (NULL  != pdpPacket) {
                /*
                 *    We need to send the rest of the unfinished packet,
                 *    before we can go on.  The 1st part of the packet
                 *    must have already been sent.
                 */
                // The packet's encoded data must be in 2 buffers.
                ASSERT (TRUE == pdpPacket->IsEncodedDataBroken());

                TransError = FlushSendBuffer (pSocket, pdpPacket->GetUserData(),
                                            pdpPacket->GetUserDataLength());
                if (TransError == TRANSPORT_NO_ERROR) {
                    pdpPacket->Unlock();
                    TRACE_OUT(("DataRequest: 2nd part of data packet was sent out in separate request"));
                    pSocket->Retry_Info.pUnfinishedPacket = NULL;
                }
            }
        }

        if ((TransError == TRANSPORT_NO_ERROR) && (packet != NULL)) {

            // Now, let's try to send this new packet.
            ptr1 = packet->GetEncodedData();
            length1 = packet->GetEncodedDataLength();

            /*
             *    We need to find out whether the packet to send is a
             *    DataPacket or a Packet object.  If it's a DataPacket, the
             *    encoded data may not be contiguous (may be broken in 2 parts)
             */
            if ((packet->IsDataPacket()) &&
                ((PDataPacket) packet)->IsEncodedDataBroken()) {
                // the data to send is broken into 2 parts.
                ptr2 = ((PDataPacket) packet)->GetUserData();
                length2 = ((PDataPacket) packet)->GetUserDataLength();
            }
            else {
                // the data to send is contiguous.
                ptr2 = NULL;
                length2 = 0;
            }

            if (NULL != pSocket->pSC) {
                    LPBYTE     pBuf;
                    UINT     cbBuf;

                TRACE_OUT(("Encrypting %d bytes of outgoing data",
                            (length1 + length2) - sizeof(X224_DATA_PACKET)));

                if (!pSocket->pSC->Encrypt(ptr1 + sizeof(X224_DATA_PACKET),
                                            length1 - sizeof(X224_DATA_PACKET),
                                            ptr2, length2, &pBuf, &cbBuf))
                {

                    ASSERT (TransError == TRANSPORT_NO_ERROR);

                    TransError = SendSecureData (pSocket, pBuf, cbBuf);
                    if (TRANSPORT_NO_ERROR != TransError) {
                        TRACE_OUT(("DataRequest: Failed to send encrypted data. Keeping buffer for retry."));
                        pSocket->Retry_Info.sbiBufferInfo.lpBuffer = pBuf;
                        pSocket->Retry_Info.sbiBufferInfo.uiLength = cbBuf;
                        // The caller needs to remove the packet from its queue.
                        TransError = TRANSPORT_NO_ERROR;
                    }
                }
                else
                {
                    WARNING_OUT (("DataRequest: Encryption failed. Disconnecting..."));
                    ::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
                    TransError = TRANSPORT_MEMORY_FAILURE;
                }
            }
            else {
                BOOL        bNeedToFree = FALSE;
                // Do we need to segment the data into X.224 packets?
                if (pSocket->Max_Packet_Length >= length1 + length2)
                    ;
                else {
                    TransError = SegmentX224Data (pSocket, &ptr1, &length1, ptr2, length2);
                    if (TRANSPORT_NO_ERROR == TransError) {
                        // The data is now contiguous
                        ptr2 = NULL;
                        bNeedToFree = TRUE;
                    }
                }

                // Flush the data, if everything OK so far.
                if (TRANSPORT_NO_ERROR == TransError)
                    TransError = FlushSendBuffer (pSocket, ptr1, length1);

                // Free the temporary X.224 buffer if we need to.
                if (bNeedToFree)
                    Free(ptr1);

                if (TRANSPORT_NO_ERROR == TransError) {
                    // If there is more, send it, too.
                    if (NULL != ptr2) {
                        TransError = FlushSendBuffer (pSocket, ptr2, length2);
                        if (TRANSPORT_NO_ERROR != TransError) {
                            /*
                             *    We need to keep the partial packet to send it later.
                             *    Notice we have already sent a part of this packet.
                             */
                            ASSERT (pSocket->Retry_Info.pUnfinishedPacket == NULL);
                            pSocket->Retry_Info.pUnfinishedPacket = (PDataPacket) packet;
                            packet->Lock();

                            // Return success.
                            TransError = TRANSPORT_NO_ERROR;
                        }
                    }
                }
            }
        }

        pSocket->Release();
    }
    else {
        TransError = TRANSPORT_NO_SUCH_CONNECTION;
        WARNING_OUT (("DataRequest: Attempt to send to unknown transport connection (%d, %d)",
                    XprtConn.eType, XprtConn.nLogicalHandle));
    }

    return TransError;
}


/*
 *    void PurgeRequest (TransportConnection    XprtConn)
 *
 *    Functional Description:
 *        This function purges the outbound packets for the given transport
 *        connection.
 */
void PurgeRequest (TransportConnection XprtConn)
{

    PSocket pSocket;

    TRACE_OUT (("In PurgeRequest for transport connection (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));

    if (IS_PLUGGABLE_PSTN(XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
        if (NULL != p)
        {
            p->TPurgeRequest();
        }
    }
    else
    /* If the logical connection handle is not registered, return error */
    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        /* Purge the pending data stored in the socket struct */
        if (NULL != pSocket->pSC) {
            if (NULL != pSocket->Retry_Info.sbiBufferInfo.lpBuffer) {
                TRACE_OUT (("PurgeRequest: Purging data packet for secure connection"));
                LocalFree (pSocket->Retry_Info.sbiBufferInfo.lpBuffer);
                pSocket->Retry_Info.sbiBufferInfo.lpBuffer = NULL;
            }
        }
        pSocket->Release();
    }
}


/*
 *    void    EnableReceiver (Void)
 *
 *    Functional Description:
 *        This function allows packets to be sent to the user application.
 */
void EnableReceiver (void)
{
    PSocket            pSocket;

    ::EnterCriticalSection(&g_csTransport);
    CSocketList     Connection_List_Copy (*g_pSocketList);
    ::LeaveCriticalSection(&g_csTransport);

    TRACE_OUT(("EnableReceiver"));

    if (NULL != g_pLegacyTransport)
    {
        g_pLegacyTransport->TEnableReceiver();
    }

    /* Go thru all the sockets and enable receiving */
    while (NULL != (pSocket = Connection_List_Copy.Get()))
    {
        /*
         *    If we had failed to deliver a data pkt to MCS before, we need
         *    an extra ReadRequest to recv and keep the FD_READ msgs coming.
         */
        if (DATA_READY == pSocket->Read_State)
        {
            ::ReadRequest(pSocket->XprtConn);
        }

        TRACE_OUT (("EnableReceiver: Calling ReadRequestEx on socket (%d, %d)",
                    pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        ::ReadRequestEx(pSocket->XprtConn);
    }
}


/*
 *    TransportError    ShutdownAndClose (TransportConnection , BOOL fShutdown, int how)
 *
 *    Functional Description
 *        This function shuts down the socket and closes it.
 *
 */
void ShutdownAndClose (TransportConnection XprtConn, BOOL fShutdown, int how)
{
    if (IS_SOCKET(XprtConn))
    {
        int error;

        if (fShutdown)
        {
            error = ::shutdown(XprtConn.nLogicalHandle, how);

            ASSERT(error != SOCKET_ERROR);
#ifdef DEBUG
            if(error == SOCKET_ERROR)
            {
                error = WSAGetLastError();
                WARNING_OUT (("ShutdownAndClose: shutdown returned %d", error));
            }
#endif // DEBUG
        }

        error = ::closesocket(XprtConn.nLogicalHandle);

#ifdef DEBUG
        if(error == SOCKET_ERROR)
        {
            WARNING_OUT(("ShutdownAndClose: closesocket returned %d", WSAGetLastError()));
        }
#endif // DEBUG
    }
}


/*
 *    TransportError GetLocalAddress (TransportConnection    XprtConn,
 *                                    TransportAddress    address,
 *                                    int *        size)
 *
 *    Functional Description:
 *        This function retrieves the local IP address associated with the given
 *        connection. It returns TRANSPORT_NO_SUCH_CONNECTION if the address is
 *        not available. If the address is available, the size parameter specifies
 *        the size of the address buffer on entry, and it is filled in with the size
 *        used for the address on exit.
 */
TransportError GetLocalAddress(    TransportConnection    XprtConn,
                                TransportAddress    address,
                                int *                size)
{
    SOCKADDR_IN        socket_control;
    PChar             szTemp;
    int                Length;
    TransportError    error = TRANSPORT_NO_SUCH_CONNECTION;

    if (NULL != g_pSocketList->FindByTransportConnection(XprtConn, TRUE))
    {
        if (IS_SOCKET(XprtConn))
        {
            /* Get the local name for the socket */
            Length = sizeof(socket_control);
            if (getsockname(XprtConn.nLogicalHandle, (LPSOCKADDR) &socket_control, &Length) == 0) {
                /* Convert it to an IP address string */
                szTemp = inet_ntoa(socket_control.sin_addr);

                ASSERT (szTemp);
                Length = (int) strlen(szTemp) + 1;

                ASSERT (*size >= Length);
                ASSERT (address);

                /* Copy it to the buffer */
                lstrcpyn((PChar)address, szTemp, Length);
                *size = Length;

                error = TRANSPORT_NO_ERROR;
            }
        }
        else
        {
            ASSERT(IS_PLUGGABLE(XprtConn));

            // string should look like "xprt: 1"
            char szConnStr[T120_CONNECTION_ID_LENGTH];
            Length = ::CreateConnString((UINT)XprtConn.nLogicalHandle, szConnStr);
            if (*size > ++Length)
            {
                ::lstrcpyn(address, szConnStr, Length+1);
                *size = Length;
                error = TRANSPORT_NO_ERROR;
                TRACE_OUT (("GetLocalAddress: plugable connection local address (%s)", address));
            }
            else
            {
                ERROR_OUT(("GetLocalAddress: buffer too small, given=%d, required=%d", *size, Length));
                error = TRANSPORT_BUFFER_TOO_SMALL;
            }
        }
    }

#ifdef DEBUG
    if (error != TRANSPORT_NO_ERROR)
        WARNING_OUT (("GetLocalAddress: Failure to obtain local address (%d)", WSAGetLastError()));
#endif // DEBUG

    return (error);
}


/*
 *    void    AcceptCall (BOOL fSecure)
 *
 *    Functional Description:
 *        This function calls Winsock to answer an incoming call.
 */

void AcceptCall (TransportConnection XprtConn)
{
    PSocket            pSocket;
    PSecurityContext pSC = NULL;
    SOCKADDR_IN        socket_control;
    int                size;

    TRACE_OUT(("AcceptCall"));

    if (IS_SOCKET(XprtConn))
    {
        ASSERT(XprtConn.nLogicalHandle == Listen_Socket);
        ASSERT (Listen_Socket != INVALID_SOCKET);

        /* Call accept() to see if anyone is calling us */
        size = sizeof (socket_control);
        XprtConn.nLogicalHandle = ::accept ( Listen_Socket,
                                (struct sockaddr *) &socket_control, &size);

        /* Note that we expect accept to complete immediately */
        if (XprtConn.nLogicalHandle == INVALID_SOCKET)
        {
            ERROR_OUT (("AcceptCall: Error on accept = %d", WSAGetLastError()));
            // SendStatusMessage ("", TSTATE_NOT_READY, IDS_NULL_STRING);
            return;
        }
    }

    /* If the accept() received an incoming call, create a connection and notify our owner object. */
    pSocket = newSocket(XprtConn, NULL);
    if( pSocket == NULL )
    {
         /* Close the socket */
         ::ShutdownAndClose(XprtConn, TRUE, 2);
        return;
    }

    pSocket -> State = SOCKET_CONNECTED;

    if (IS_SOCKET(XprtConn))
    {
        /* Issue the getpeername() function to get the remote user's address */
        size = sizeof (socket_control);
        if (::getpeername(XprtConn.nLogicalHandle, (LPSOCKADDR) &socket_control, &size) == 0)
        {
            lstrcpyn (
                pSocket -> Remote_Address,
                inet_ntoa (socket_control.sin_addr),
                MAXIMUM_IP_ADDRESS_SIZE-1);
            pSocket -> Remote_Address[MAXIMUM_IP_ADDRESS_SIZE - 1] = NULL;
        }

        // SendStatusMessage(pSocket -> Remote_Address, TSTATE_CONNECTED, IDS_NULL_STRING);
    }

    /* Add to connection list */
    // bugbug: we fail to insert.
    g_pSocketList->SafeAppend(pSocket);

    /* Notify the user */
    TRACE_OUT (("TCP Callback: g_Transport->ConnectIndication (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
    /* We issue a callback to the user to notify him of the message */
    g_Transport->ConnectIndication(XprtConn);
}


//
// ReadRequestEx() is for the plugable transport.
// Since we do not have the FD_ACCEPT notifcation, we try to make sure
// we have a valid transport connection for every read...
// The following piece of code is derived from AcceptCall().
//
void ReadRequestEx(TransportConnection XprtConn)
{
    if (! IS_PLUGGABLE_PSTN(XprtConn))
    {
        ::ReadRequest(XprtConn);
    }
}

/*
 *    LRESULT    WindowProcedure (
 *                            HWND         window_handle,
 *                            UINT        message,
 *                            WPARAM         wParam,
 *                            LPARAM        lParam)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by Windows when we dispatch a TCP message from the
 *        event loop above.  It gives us a chance to process the incoming socket messages.
 */
LRESULT    WindowProcedure (HWND         window_handle,
                         UINT        message,
                         WPARAM        wParam,
                         LPARAM        lParam)
{
    TransportConnection XprtConn;
    UShort        error;
    UShort        event;
    //PSocket        pSocket;

    switch (message)
    {
#ifndef NO_TCP_TIMER
    case WM_TIMER:
        {
             /*
             **    We are currently using a slow timer to keep reading even when
             ** FD_READ msgs get lost (this happens on Win95).
             **
             */
            if (NULL != g_Transport) {
                TRACE_OUT(("MSMCSTCP: WM_TIMER"));
                EnableReceiver ();
            }
        }
        break;
#endif    /* NO_TCP_TIMER */

    case WM_SOCKET_NOTIFICATION:
        {
            /* This message is generated by WinSock */
            event = WSAGETSELECTEVENT (lParam);
            error = WSAGETSELECTERROR (lParam);

            SET_SOCKET_CONNECTION(XprtConn, wParam);

            /* We disconnect whenever a socket command generates an error message */
            if (error)
            {
                WARNING_OUT (("TCP: error %d on socket (%d). Event: %d", error, XprtConn.nLogicalHandle, event));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                break;
            }

            /* We get FD_CLOSE when the socket is closed by the remote site. */
            if (event & FD_CLOSE)
            {
                TRACE_OUT (("TCP: FD_CLOSE(%d)", XprtConn.nLogicalHandle));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                break;
            }

            /* We get FD_READ when there is data available for us to read. */
            if (event & FD_READ)
            {
                // TRACE_OUT(("MSMCSTCP: FD_READ(%d)", (UINT) wParam));
                ::ReadRequest(XprtConn);
            }

            /* We get FD_ACCEPT when a remote site is connecting with us */
            if (event & FD_ACCEPT)
            {
                TRACE_OUT (("TCP: FD_ACCEPT(%d)", XprtConn.nLogicalHandle));

                /* Note that we always accept calls. Disconnect cancels them. */
                TransportConnection XprtConn2;
                SET_SOCKET_CONNECTION(XprtConn2, Listen_Socket);
                ::AcceptCall(XprtConn2);
            }

            /* We get FD_CONNECT when our connect completes */
            if (event & FD_CONNECT)
            {
                TRACE_OUT (("TCP: FD_CONNECT(%d)", XprtConn.nLogicalHandle));
                ::SendX224ConnectRequest(XprtConn);
            }

            /* We get FD_WRITE when there is space available to write data to WinSock */
            if (event & FD_WRITE)
            {
                /*
                 *    We need to send a BUFFER_EMPTY_INDICATION to the connection associated
                 *    with the socket
                 */
                TRACE_OUT (("TCP: FD_WRITE(%d)", XprtConn.nLogicalHandle));
                // We need to flush the socket's pending data first.
                if (TRANSPORT_NO_ERROR == ::DataRequest(XprtConn, NULL))
                {
                    TRACE_OUT (("TCP: Sending BUFFER_EMPTY_INDICATION to transport."));
                    g_Transport->BufferEmptyIndication(XprtConn);
                }
            }
        }
        break;

    case WM_PLUGGABLE_X224:
        // for low level read and write,
        {
            XprtConn.eType = (TransportType) PLUGXPRT_WPARAM_TO_TYPE(wParam);
            XprtConn.nLogicalHandle = PLUGXPRT_WPARAM_TO_ID(wParam);
            ASSERT(IS_PLUGGABLE(XprtConn));

            event = PLUGXPRT_LPARAM_TO_EVENT(lParam);
            error = PLUGXPRT_LPARAM_TO_ERROR(lParam);

            /* We disconnect whenever a socket command generates an error message */
            if (error)
            {
                WARNING_OUT(("PluggableWndProc: error %d on socket (%d, %d). Event: %d",
                         error, XprtConn.eType, XprtConn.nLogicalHandle, event));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                ::PluggableShutdown(XprtConn);
                break;
            }

            switch (event)
            {
            case PLUGXPRT_EVENT_READ:
                 TRACE_OUT(("PluggableWndProc: READ(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::ReadRequestEx(XprtConn);
                break;

            case PLUGXPRT_EVENT_WRITE:
                TRACE_OUT(("PluggableWndProc: WRITE(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::PluggableWriteTheFirst(XprtConn);
                break;

            case PLUGXPRT_EVENT_CLOSE:
                TRACE_OUT(("PluggableWndProc: CLOSE(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                break;

            case PLUGXPRT_HIGH_LEVEL_READ:
                TRACE_OUT(("PluggableWndProc: READ_NEXT(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::ReadRequestEx(XprtConn);
                break;

            case PLUGXPRT_HIGH_LEVEL_WRITE:
                TRACE_OUT(("PluggableWndProc: WRITE_NEXT(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                // We need to flush the socket's pending data first.
                if (TRANSPORT_NO_ERROR == ::DataRequest(XprtConn, NULL))
                {
                    TRACE_OUT(("PluggableWndProc: Sending BUFFER_EMPTY_INDICATION to transport."));
                    g_Transport->BufferEmptyIndication(XprtConn);
                }
                break;

            default:
                ERROR_OUT(("PluggableWndProc: unknown event=%d.", event));
                break;
            }
        }
        break;

    case WM_PLUGGABLE_PSTN:
        {
            extern void HandlePSTNCallback(WPARAM wParam, LPARAM lParam);
            HandlePSTNCallback(wParam, lParam);
        }
        break;

    default:
        {
             /*
             **    The message is not related to WinSock messages, so let
             **    the default window procedure handle it.
             */
            return (DefWindowProc (window_handle, message, wParam, lParam));
        }
    }

    return (0);
}

//  GetSecurityInfo() takes a connection_handle and returns the security information associated with
//  it.
//
//    Returns TRUE if we can either find the information or we are not directly connected to the node
//    represented by this connection handle.
//
//    Returns FALSE if we are directly connected but for some reason could not get the info -- this
//    result should be viewed as suspicious.
BOOL GetSecurityInfo(ConnectionHandle connection_handle, PBYTE pInfo, PDWORD pcbInfo)
{
    PSocket pSocket;
    SOCKET socket_number;

    if (g_pMCSController->FindSocketNumber(connection_handle, &socket_number))
    {
        TransportConnection XprtConn;
        SET_SOCKET_CONNECTION(XprtConn, socket_number);

        BOOL fRet = FALSE;
        if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
        {
            if (NULL != pSocket->pSC)
            {
                fRet = pSocket->pSC->GetUserCert(pInfo, pcbInfo);
            }
            else
            {
                WARNING_OUT(("GetSecurityInfo: queried non-secure socket %d", socket_number));
            }

            pSocket->Release();
        }
        else
        {
            WARNING_OUT(("GetSecurityInfo: socket %d not found", socket_number ));
        }
        return fRet;
    }
    // In this case we are not directly connected, so will return length of NOT_DIRECTLY_CONNECTED
    // but positive return value.
    *pcbInfo = NOT_DIRECTLY_CONNECTED;
    return TRUE;
}

//     GetSecurityInfoFromGCCID() takes a GCCID and returns the security information associated with
//    it.
//
//    Returns TRUE if either (1) we successfully retrieve the information from a transport-level
//    connection, or (2) we find that we are not directly connected to the node with this GCCID.
//
//    Returns FALSE if we are directly connected but cannot retrieve the info, or some other error
//    occurs.  A FALSE return value should be treated as a security violation.

BOOL WINAPI T120_GetSecurityInfoFromGCCID(DWORD dwGCCID, PBYTE pInfo, PDWORD pcbInfo)
{
    PSocket            pSocket;

    SOCKET socket_number;
    if ( NULL != dwGCCID )
    {
        // Get the user info for a remote connection
        ConnectionHandle connection_handle;
        BOOL fConnected = FindSocketNumber(dwGCCID, &socket_number);
        if (fConnected == FALSE) {
            (* pcbInfo) = 0;
            return TRUE;
        }

        TransportConnection XprtConn;
        SET_SOCKET_CONNECTION(XprtConn, socket_number);

        BOOL fRet = FALSE;
        if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
        {
            if (NULL != pSocket->pSC)
            {
                fRet = pSocket->pSC->GetUserCert(pInfo, pcbInfo);
            }
            else
            {
                WARNING_OUT(("GetSecurityInfoFromGCCID: queried non-secure socket %d", socket_number));
            }
            pSocket->Release();
        }
        else
        {
            ERROR_OUT(("GetSecurityInfoFromGCCID: socket %d not found", socket_number ));
        }
        return fRet;
    }
    else
    {
        // Get the user info for the local user
        if ( NULL != g_Transport && NULL != g_Transport->pSecurityInterface )
            return g_Transport->pSecurityInterface->GetUserCert( pInfo, pcbInfo );
        else
            return FALSE;
    }
}

DWORD WINAPI T120_TprtSecCtrl ( DWORD dwCode, DWORD_PTR dwParam1, DWORD_PTR dwParam2 )
{
    DWORD    dwRet = TPRTSEC_NOERROR;
    RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);

    switch ( dwCode )
    {
        case TPRTCTRL_SETX509CREDENTIALS:
            //
            // Security.  Create transport interface if we don't have one.
            // Update credentials if we do.
            //
            if (!g_Transport->pSecurityInterface)
            {
                g_Transport->pSecurityInterface =
                    new SecurityInterface(g_Transport->bInServiceContext);

                if ( TPRTSEC_NOERROR !=
                    g_Transport->pSecurityInterface->Initialize())
                {
                    delete g_Transport->pSecurityInterface;
                    g_Transport->pSecurityInterface = NULL;
                    dwRet = TPRTSEC_SSPIFAIL;
                }
            }
            else
            {
                //
                // dwParam1 points to an encoded X509 cert
                // create credentials from it.
                //
                dwRet = g_Transport->pSecurityInterface->
                            InitializeCreds((PCCERT_CONTEXT)dwParam1);
            }
            return dwRet;
            break;

        case TPRTCTRL_GETX509CREDENTIALS:
            if ( g_Transport->pSecurityInterface )
            {
                DWORD cb;
                PBYTE pb;

                if ( g_Transport->pSecurityInterface->GetUserCert( NULL, &cb))
                {
                    if ( pb = (PBYTE)CoTaskMemAlloc ( cb ))
                    {
                        if(g_Transport->pSecurityInterface->GetUserCert(pb,&cb))
                        {
                            *((PBYTE *)dwParam1) = pb;
                            *((PDWORD)dwParam2) = cb;
                            dwRet = TPRTSEC_NOERROR;
                        }
                        else
                            CoTaskMemFree(pb);
                    }
                }
            }
            else
            {
                ERROR_OUT(("TPRTCTRL_GETX509CREDENTIALS w/ no infc"));
                dwRet = TPRTSEC_SSPIFAIL;
            }
            return dwRet;
            break;
        default:
            ERROR_OUT(("TprtSecCtrl: unrecognized command code"));
            return 0;
    }
    ASSERT(FALSE); // Should not reach this
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\token.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	token.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Token class.  It contains all
 *		code necessary to implement tokens as defined in the MCS specification.
 *
 *		Whenever a user allocates a token (by grabbing or inhibiting it), one
 *		of these objects is created (if domain parameters allow it).  This
 *		object then handles all requests related to that token ID.  It also
 *		issues confirms back to the originators of those requests.
 *
 *		This class includes code to maintain a list of user IDs that
 *		correspond to the current "owners" of the token.  A user is said to
 *		own a token if it has it grabbed or inhibited.  This code implements
 *		the rules concerning who can grab or inhibit tokens at any given
 *		time (which is affected by current state).
 *
 *		This class also contains the code that allows a current grabber of
 *		the token to give it away to another user in the domain.
 *
 *		This class also includes code to merge itself upward during a domain
 *		merge operation.
 *
 *	Private Instance Variables:
 *		Token_ID
 *			This is the token ID for the token that this object represents.
 *		m_pDomain
 *			This is a pointer to the local provider (the domain that owns this
 *			token).  This field is used when a command is issued on behalf of
 *			this provider.
 *		m_pConnToTopProvider
 *			This is the top provider of the current domain.
 *		m_pChannelList2
 *			This is the channel list that is maintained by the domain.  It is
 *			used by this class to perform validation of user IDs.
 *		m_pAttachmentList
 *			This is the attachment list that is maintained by the domain.  It is
 *			used by this class to determine what users are locally attached,
 *			when it becomes necessary to send certain indications.
 *		Token_State
 *			This contains the current state of the token, which will be one of
 *			the following: available; grabbed; inhibited; giving; or given.
 *		m_uidGrabber
 *			This is the user that current has the token grabbed.  This variable
 *			is only valid in the grabbed and giving states.
 *		m_InhibitorList
 *			This is a list of users that have the token inhibited.  This
 *			list is only valid when the token is in the inhibited state.
 *		m_uidRecipient
 *			This is the user to whom the token is being given.  This variable
 *			is only valid in the giving or given states.
 *
 *	Private Member Functions:
 *		ValidateUserID
 *			This function is used to verify that a specified user is valid in
 *			the sub-tree of the local provider.
 *		GetUserAttachment
 *			This function is used to determine which attachment leads to a
 *			particular attachment.
 *		IssueTokenReleaseIndication
 *			This function is used to issue a token release indication to a
 *			specified user.  It first checks to see if the user is locally
 *			attached, and if so, it sends the indication.
 *		BuildAttachmentList
 *			This function is used to build a list of unique attachments to
 *			send please indications to.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include "token.h"


/*
 *	Token ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the token class.  It does nothing more than
 *		set the initial states of instance variables.
 */
Token::Token (
		TokenID				token_id,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list)
:
	m_InhibitorList(),
	Token_ID(token_id),
	m_pDomain(local_provider),
	m_pConnToTopProvider(top_provider),
	m_pChannelList2(channel_list),
	m_pAttachmentList(attachment_list),
	Token_State(TOKEN_AVAILABLE)
{
	/*
	 *	Save all parameters in their associated instance variables for later
	 *	use.
	 */

	/*
	 *	Mark the token as available for use.
	 */
}

/*
 *	Token ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is an alternate constructor for the token class.  It is used when
 *		creating a token during a merge operation.  It accepts a current state
 *		as well as a list of current owners  as parameters.
 */
Token::Token (
		TokenID				token_id,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list,
		TokenState			token_state,
		UserID				grabber,
		CUidList           *inhibitor_list,
		UserID				recipient)
:
	m_InhibitorList(),
	Token_ID(token_id),
	m_pDomain(local_provider),
	m_pConnToTopProvider(top_provider),
	m_pChannelList2(channel_list),
	m_pAttachmentList(attachment_list),
	Token_State(token_state)
{
	UserID		uid;

	/*
	 *	Save all parameters in their associated instance variables for later
	 *	use.
	 */

	/*
	 *	Indicate the current state of the token (as passed in).
	 */

	/*
	 *	Depending on token state, copy the pertinent information into local
	 *	instance variables.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			m_uidGrabber = grabber;
			break;

		case TOKEN_INHIBITED:
			{
				/*
				 *	Add all user IDs in the inhibitor list to the local
				 *	inhibitor list.
				 */
				inhibitor_list->Reset();
				while (NULL != (uid = inhibitor_list->Iterate()))
				{
					m_InhibitorList.Append(uid);
				}
			}
			break;

		case TOKEN_GIVING:
			m_uidGrabber = grabber;
			m_uidRecipient = recipient;
			break;

		case TOKEN_GIVEN:
			m_uidRecipient = recipient;
			break;
	}
}

/*
 *	~Token ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the token destructor.  It iterates through its current owner
 *		list, issuing TokenReleaseIndications to any owners that correspond
 *		to locally attached users.
 */
Token::~Token ()
{
	/*
	 *	Depending on the current state of the token, release resources and
	 *	issue release indications to all owners.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			/*
			 *	Send a release indication to the grabber, if it is locally
			 *	attached.
			 */
			IssueTokenReleaseIndication (m_uidGrabber);
			break;

		case TOKEN_INHIBITED:
			{
				UserID	uid;
				/*
				 *	Iterate through the current inhibitor list, to make sure
				 *	that everyone is properly informed of the demise of this
				 *	token.
				 */
				m_InhibitorList.Reset();
				while (NULL != (uid = m_InhibitorList.Iterate()))
				{
					IssueTokenReleaseIndication(uid);
				}
			}
			break;

		case TOKEN_GIVING:
			/*
			 *	Send a release indication to the grabber, if it is locally
			 *	attached.
			 */
			IssueTokenReleaseIndication (m_uidGrabber);

			/*
			 *	Send a release indication to the recipient, if it is locally
			 *	attached.  Note that this will not be sent in the case where
			 *	the grabber and the recipient are one and the same.  This
			 *	prevents the sending of two release indications to the same
			 *	user for the same token.
			 */
			if (m_uidGrabber != m_uidRecipient)
				IssueTokenReleaseIndication (m_uidRecipient);
			break;

		case TOKEN_GIVEN:
			/*
			 *	Send a release indication to the recipient, if it is locally
			 *	attached.
			 */
			IssueTokenReleaseIndication (m_uidRecipient);
			break;
	}
}


/*
 *	BOOL    IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function checks the validity of each of its owners.  It then
 *		returns TRUE if there are any valid owners left.  FALSE otherwise.
 */
BOOL    Token::IsValid ()
{
	BOOL    		valid;

	/*
	 *	We must check for the validity of this token.  How this is checked for
	 *	is a function of token state.  So switch on the state.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			/*
			 *	When a token is grabbed, the grabber must be in the sub-tree
			 *	of the current provider.  If this is not true, then mark the
			 *	token as available (which will cause it to be deleted).
			 */
			if (ValidateUserID (m_uidGrabber) == FALSE)
				Token_State = TOKEN_AVAILABLE;
			break;

		case TOKEN_INHIBITED:
			{
				UserID			uid;
				CUidList		deletion_list;
				/*
				 *	Iterate through the current inhibitor list of this token,
				 *	checking to make sure that each user is still valid.  Each
				 *	one that is not will be put into a deletion list (it is
				 *	invalid to remove items from a list while using an iterator
				 *	on the list).
				 */
				m_InhibitorList.Reset();
				while (NULL != (uid = m_InhibitorList.Iterate()))
				{
					if (ValidateUserID(uid) == FALSE)
						deletion_list.Append(uid);
				}

				/*
				 *	Iterate through the deletion list that was built above,
				 *	removing each contained user from the token's inhibitor
				 *	list.  These correspond to users that have detached from the
				 *	domain for one reason or another.
				 */
				deletion_list.Reset();
				while (NULL != (uid = deletion_list.Iterate()))
				{
					m_InhibitorList.Remove(uid);
				}
			}

			/*
			 *	Check to see if there are any inhibitors left.  If not, then
			 *	we must change the state of the token to available (which will
			 *	cause it to be deleted).
			 */
			if (m_InhibitorList.IsEmpty())
				Token_State = TOKEN_AVAILABLE;
			break;

		case TOKEN_GIVING:
			/*
			 *	When a token is in the giving state, the recipient must be in
			 *	the sub-tree of the current provider.  If it is not, then the
			 *	token MUST change state.  The state it changes to depends on
			 *	whether or not the grabber is in the sub-tree of the current
			 *	provider.
			 */
			if (ValidateUserID (m_uidRecipient) == FALSE)
			{
				/*
				 *	The recipient of the token is gone.  Check to see if the
				 *	grabber is in the sub-tree of this provider.
				 */
				if (ValidateUserID (m_uidGrabber) == FALSE)
				{
					/*
					 *	The grabber is not in the sub-tree of this provider,
					 *	meaning that the token is no longer valid.
					 */
					Token_State = TOKEN_AVAILABLE;
				}
				else
				{
					/*
					 *	The grabber is in the sub-tree of this provider, so the
					 *	token state will transition back to grabbed.
					 */
					Token_State = TOKEN_GRABBED;

					/*
					 *	If this is the top provider, it is necessary to issue a
					 *	give confirm to the grabber telling it that the give
					 *	failed.
					 */
					if (m_pConnToTopProvider == NULL)
					{
						/*
						 *	Find out what attachment leads to the current
						 *	grabber of the token, and issue the appropriate
						 *	token give confirm.
						 */
						CAttachment *pAtt = GetUserAttachment(m_uidGrabber);
						if (pAtt)
						{
						    pAtt->TokenGiveConfirm(RESULT_NO_SUCH_USER, m_uidGrabber, Token_ID,
						                           TOKEN_SELF_GRABBED);
						}
					}
				}
			}
			break;

		case TOKEN_GIVEN:
			/*
			 *	When a token is in the given state, the recipient must be in
			 *	the sub-tree of the current provider.  If it is not, then the
			 *	token is no longer valid, and should transition to the
			 *	available state.
			 */
			if (ValidateUserID (m_uidRecipient) == FALSE)
				Token_State = TOKEN_AVAILABLE;
			break;
	}

	/*
	 *	Check to see if the token is still in use.  If it is marked as
	 *	available, then it is not, and we will return FALSE.
	 */
	if (Token_State != TOKEN_AVAILABLE)
		valid = TRUE;
	else
		valid = FALSE;

	return (valid);
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function tells the token object to pack its state into a merge
 *		request and send it to the specified provider.
 */
Void	Token::IssueMergeRequest ()
{
	TokenAttributes			merge_token;
	CTokenAttributesList	merge_token_list;
	CTokenIDList			purge_token_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Check the state to make sure that the token really is in use.  If
		 *	the state is set to available, then do not issue a merge request.
		 */
		if (Token_State != TOKEN_AVAILABLE)
		{
			/*
			 *	Fill in a token attributes structure to represent the state of
			 *	this token.  Then put it into the merge token list in
			 *	preparation for issuing the merge request.
			 */
			merge_token.token_state = Token_State;
			switch (Token_State)
			{
				case TOKEN_GRABBED:
					merge_token.u.grabbed_token_attributes.token_id = Token_ID;
					merge_token.u.grabbed_token_attributes.grabber = m_uidGrabber;
					break;

				case TOKEN_INHIBITED:
					merge_token.u.inhibited_token_attributes.token_id =
							Token_ID;
					merge_token.u.inhibited_token_attributes.inhibitors =
							&m_InhibitorList;
					break;

				case TOKEN_GIVING:
					merge_token.u.giving_token_attributes.token_id = Token_ID;
					merge_token.u.giving_token_attributes.grabber = m_uidGrabber;
					merge_token.u.giving_token_attributes.recipient = m_uidRecipient;
					break;

				case TOKEN_GIVEN:
					merge_token.u.given_token_attributes.token_id = Token_ID;
					merge_token.u.given_token_attributes.recipient = m_uidRecipient;
					break;
			}
			merge_token_list.Append(&merge_token);

			/*
			 *	Send the resulting merge request to the indicated provider.
			 */
			m_pConnToTopProvider->MergeTokensRequest(&merge_token_list, &purge_token_list);
		}
		else
		{
			/*
			 *	Report that the token is not in use, but do NOT send a merge
			 *	request.
			 */
			TRACE_OUT(("Token::IssueMergeRequest: token not in use"));
		}
	}
}

/*
 *	Void	TokenGrabRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user tries to grab a token.  The request
 *		will either succeed or fail depending on the current state of the token.
 *		Either way, a confirm will be sent to the user originating the request.
 */
Void	Token::TokenGrabRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this provider is the Top Provider.  If so, then process
	 *	this request here.  Otherwise, forward the request upward.
	 */
	if (IsTopProvider())
	{
		/*
		 *	Determine what state we are, which greatly affects how we process
		 *	the request.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	Since the token is available, the request automatically
				 *	succeeds.  Change the state to grabbed, and mark the
				 *	initiator as the grabber.
				 */
				Token_State = TOKEN_GRABBED;
				m_uidGrabber = uidInitiator;

				result = RESULT_SUCCESSFUL;
				token_status = TOKEN_SELF_GRABBED;
				break;

			case TOKEN_GRABBED:
				/*
				 *	If the token is already grabbed, then we must fail the
				 *	request.  However, we need to determine if the token is
				 *	grabbed by the same user who is currently requesting it, or
				 *	another user.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GRABBED;
				else
					token_status = TOKEN_OTHER_GRABBED;
				break;

			case TOKEN_INHIBITED:
				/*
				 *	If the token is inhibited, this request can still succeed if
				 *	the only inhibitor is the user that is attempting to grab
				 *	the token.  Check to see if this is the case.
				 */
				if (m_InhibitorList.Find(uidInitiator))
				{
					if (m_InhibitorList.GetCount() == 1)
					{
						/*
						 *	The user attempting to grab the token is the only
						 *	inhibitor, so convert the state to grabbed.
						 */
						Token_State = TOKEN_GRABBED;
						m_uidGrabber = uidInitiator;
						m_InhibitorList.Clear();

						result = RESULT_SUCCESSFUL;
						token_status = TOKEN_SELF_GRABBED;
					}
					else
					{
						/*
						 *	The token is inhibited by at least one other user,
						 *	so the grab request must fail.
						 */
						result = RESULT_TOKEN_NOT_AVAILABLE;
						token_status = TOKEN_SELF_INHIBITED;
					}
				}
				else
				{
					/*
					 *	The token is not inhibited by the requestor, so it must
					 *	be inhibited by someone else.
					 */
					result = RESULT_TOKEN_NOT_AVAILABLE;
					token_status = TOKEN_OTHER_INHIBITED;
				}
				break;

			case TOKEN_GIVING:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then a grab request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then a grab request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	Issue the token grab confirm to the initiating user.
		 */
		pOrigAtt->TokenGrabConfirm(result, uidInitiator, Token_ID, token_status);
	}
	else
	{
		/*
		 *	Forward this request upward towards the Top Provider.
		 */
		TRACE_OUT(("Token::TokenGrabRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenGrabRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenGrabConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenGrabConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID(uidInitiator))
	{
		/*
		 *	Check to see if this request was successful.
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Force this token to conform to the results of this confirm.
			 */
			Token_State = TOKEN_GRABBED;
			m_uidGrabber = uidInitiator;
			m_InhibitorList.Clear();
		}

		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenGrabConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenGrabConfirm: invalid initiator ID"));
	}
}

/*
 *	Void	TokenInhibitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user tries to inhibit a token.  The
 *		request will either succeed or fail depending on the current state of
 *		the token.  Either way, a confirm will be sent to the user originating
 *		the request.
 */
Void	Token::TokenInhibitRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (IsTopProvider())
	{
		/*
		 *	Determine what state we are, which greatly affects how we process
		 *	the request.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	Since the token is available, the request automatically
				 *	succeeds.  Set the token state to inhibited, and add the
				 *	initiator to the list of inhibitors.
				 */
				Token_State = TOKEN_INHIBITED;
				m_InhibitorList.Append(uidInitiator);

				result = RESULT_SUCCESSFUL;
				token_status = TOKEN_SELF_INHIBITED;
				break;

			case TOKEN_GRABBED:
				/*
				 *	If the token is grabbed, this request can still succeed if
				 *	the grabber is the user that is attempting to inhibit the
				 *	token.  Check to see if this is the case.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	The current grabber is attempting to convert the state
					 *	of the token to inhibited.  This is valid, so set the
					 *	state appropriately.
					 */
					Token_State = TOKEN_INHIBITED;
					m_InhibitorList.Append(uidInitiator);

					result = RESULT_SUCCESSFUL;
					token_status = TOKEN_SELF_INHIBITED;
				}
				else
				{
					/*
					 *	The token is grabbed by someone else, so the inhibit
					 *	request must fail.
					 */
					result = RESULT_TOKEN_NOT_AVAILABLE;
					token_status = TOKEN_OTHER_GRABBED;
				}
				break;

			case TOKEN_INHIBITED:
				/*
				 *	The token is already inhibited, but this is okay.  Add this
				 *	user to the list of inhibitors (if it is not already there).
				 */
				if (m_InhibitorList.Find(uidInitiator) == FALSE)
					m_InhibitorList.Append(uidInitiator);

				result = RESULT_SUCCESSFUL;
				token_status = TOKEN_SELF_INHIBITED;
				break;

			case TOKEN_GIVING:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then an inhibit request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then an inhibit request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	If the originator is NULL, then this inhibit request is happening as
		 *	part of a merge operation, in which case we do NOT want to send a
		 *	token inhibit confirm.  Otherwise we do send one.
		 */
		if (pOrigAtt != NULL)
		{
			pOrigAtt->TokenInhibitConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenInhibitRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenInhibitRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenInhibitConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenInhibitConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID (uidInitiator) )
	{
		/*
		 *	Check to see if this request was successful.
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Force this token to conform to the results of this confirm.
			 */
			Token_State = TOKEN_INHIBITED;
			if (m_InhibitorList.Find(uidInitiator) == FALSE)
				m_InhibitorList.Append(uidInitiator);
		}

		/*
		 *	Determine what attachment leads to the initiator, and issue the
		 *	token confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenInhibitConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenInhibitConfirm: invalid initiator ID"));
	}
}

/*
 *	Void	TokenGiveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when one user asks to give a token to another
 *		user.
 */
Void	Token::TokenGiveRequest (
				CAttachment        *pOrigAtt,
				PTokenGiveRecord	pTokenGiveRec)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this provider is the Top Provider.  If so, then process
	 *	this request here.  Otherwise, forward the request upward.
	 */
	if (m_pConnToTopProvider == NULL)
	{
		UserID		uidInitiator = pTokenGiveRec->uidInitiator;
		UserID		receiver_id = pTokenGiveRec->receiver_id;
		/*
		 *	Determine what state we are, which greatly affects how we process
		 *	the request.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	The token is not in use, and therefore cannot be given by
				 *	anyone to anyone.  So fail this request.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				token_status = TOKEN_NOT_IN_USE;
				break;

			case TOKEN_GRABBED:
				/*
				 *	Check to see if the requestor really is the grabber of this
				 *	token.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	Check to see if the intended recipient is a valid user
					 *	in the domain.
					 */
					if (ValidateUserID (receiver_id) )
					{
						/*
						 *	Everything checks out.  Set the result to success
						 *	to disable transmission of the give confirm below.
						 *	Change the state of the token to giving, and
						 *	save the ID of the intended recipient.  Then issue
						 *	the give indication toward the recipient.
						 */
						result = RESULT_SUCCESSFUL;
						Token_State = TOKEN_GIVING;
						m_uidRecipient = receiver_id;

						CAttachment *pAtt = GetUserAttachment(receiver_id);
						ASSERT (Token_ID == pTokenGiveRec->token_id);
						if (pAtt)
						{
						    pAtt->TokenGiveIndication(pTokenGiveRec);
						}
					}
					else
					{
						/*
						 *	The recipient does not exist in the domain, so
						 *	fail the request.
						 */
						result = RESULT_NO_SUCH_USER;
						token_status = TOKEN_SELF_GRABBED;
					}
				}
				else
				{
					/*
					 *	The requestor does not own the token, so the request
					 *	must fail.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					token_status = TOKEN_OTHER_GRABBED;
				}
				break;

			case TOKEN_INHIBITED:
				/*
				 *	Inhibited tokens cannot be given by anyone to anyone.  So
				 *	fail this request with the proper status.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (m_InhibitorList.Find(uidInitiator) )
					token_status = TOKEN_SELF_INHIBITED;
				else
					token_status = TOKEN_OTHER_INHIBITED;
				break;

			case TOKEN_GIVING:
				/*
				 *	This token is already in the process of being given.  So
				 *	this request must fail.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	This token is already in the process of being given.  So
				 *	this request must fail.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	If necessary, issue a token give confirm to the initiating user.
		 */
		if (result != RESULT_SUCCESSFUL)
		{
			pOrigAtt->TokenGiveConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	Forward this request upward towards the Top Provider.
		 */
		TRACE_OUT(("Token::TokenGiveRequest: forwarding request to Top Provider"));
		ASSERT (Token_ID == pTokenGiveRec->token_id);
		m_pConnToTopProvider->TokenGiveRequest(pTokenGiveRec);
	}
}

/*
 *	Void	TokenGiveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called in order to deliver a message to a user that
 *		another user is trying to give them a token.
 */
Void	Token::TokenGiveIndication (
				PTokenGiveRecord	pTokenGiveRec)
{
	UserID				receiver_id;

	receiver_id = pTokenGiveRec->receiver_id;
	/*
	 *	Make sure that the receiver ID is valid, since we must forward this
	 *	indication in the direction of that user.  If it is not valid, ignore
	 *	this indication.
	 */
	if (ValidateUserID (receiver_id) )
	{
		/*
		 *	Force this token to conform to the state implied by this indication.
		 */
		Token_State = TOKEN_GIVING;
		m_uidGrabber = pTokenGiveRec->uidInitiator;
		m_InhibitorList.Clear();
		m_uidRecipient = receiver_id;

		/*
		 *	Determine what attachment leads to the recipient, and forward the
		 *	indication in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(receiver_id);
		ASSERT (Token_ID == pTokenGiveRec->token_id);
		if (pAtt)
		{
		    pAtt->TokenGiveIndication(pTokenGiveRec);
		}
	}
	else
	{
		/*
		 *	The recipient is not in the sub-tree of this provider.  So ignore
		 *	this indication.
		 */
		ERROR_OUT(("Token::TokenGiveIndication: invalid receiver ID"));
	}
}

/*
 *	Void	TokenGiveResponse ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a potential recipient decides whether or
 *		not to accept an offered token.
 */
Void	Token::TokenGiveResponse (
				Result				result,
				UserID				receiver_id,
				TokenID)
{
	UserID			uidInitiator;
	TokenStatus		token_status;

	/*
	 *	Process the response according to the current state of this token.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
		case TOKEN_GRABBED:
		case TOKEN_INHIBITED:
			/*
			 *	The token is not in the process of being given to anyone, so
			 *	this response must be ignored.
			 */
			break;

		case TOKEN_GIVING:
			/*
			 *	The token is being given to someone.  Check to see if this is
			 *	the proper recipient.  If not, don't do anything.
			 */
			if (receiver_id == m_uidRecipient)
			{
				/*
				 *	Save the ID of the initiator, for use in issuing a give
				 *	confirm (if necessary).
				 */
				uidInitiator = m_uidGrabber;

				/*
				 *	Check to see if the token was accepted.  A result of
				 *	anything but successful would indicate that it was not.
				 */
				if (result == RESULT_SUCCESSFUL)
				{
					/*
					 *	The token was accepted by the intended recipient.
					 *	Change the state of the token to being grabbed by the
					 *	receiver.
					 */
					Token_State = TOKEN_GRABBED;
					m_uidGrabber = receiver_id;
				}
				else
				{
					/*
					 *	The token was not accepted.  It must either revert to
					 *	being grabbed by the donor, or deleted, depending on
					 *	whether or not the donor is in the sub-tree of this
					 *	provider.
					 */
					if (ValidateUserID(uidInitiator))
					{
						/*
						 *	The donor is in the sub-tree of this provider, so
						 *	change the state of the token back to grabbed.
						 */
						Token_State = TOKEN_GRABBED;
					}
					else
					{
						/*
						 *	The donor is not in the sub-tree of this provider,
						 *	so the token will be marked as available (which
						 *	will cause it to be deleted).
						 */
						Token_State = TOKEN_AVAILABLE;
					}
				}

				/*
				 *	Check to see if this is the Top Provider.
				 */
				if (m_pConnToTopProvider == NULL)
				{
					/*
					 *	If the donor is still a valid user in the domain, a
					 *	token give confirm must be issued in its direction.
					 */
					if (ValidateUserID(uidInitiator))
					{
						/*
						 *	Determine which attachment leads to the donor, and
						 *	issue the token give confirm.
						 */
						if (uidInitiator == m_uidGrabber)
							token_status = TOKEN_SELF_GRABBED;
						else
							token_status = TOKEN_OTHER_GRABBED;

						CAttachment *pAtt = GetUserAttachment(uidInitiator);
						if (pAtt)
						{
						    pAtt->TokenGiveConfirm(result, uidInitiator, Token_ID, token_status);
						}
					}
				}
				else
				{
					/*
					 *	If this is not the Top Provider, then the valid give
					 *	response must be forwarded to the Top Provider.
					 */
					m_pConnToTopProvider->TokenGiveResponse(result, receiver_id, Token_ID);
				}
			}
			break;

		case TOKEN_GIVEN:
			/*
			 *	The token is being given to someone.  Check to see if this is
			 *	the proper recipient.  If not, don't do anything.
			 */
			if (receiver_id == m_uidRecipient)
			{
				/*
				 *	Check to see if the token was accepted.  A result of
				 *	anything but successful would indicate that it was not.
				 */
				if (result == RESULT_SUCCESSFUL)
				{
					/*
					 *	The token was accepted by the intended recipient.
					 *	Change the state of the token to being grabbed by the
					 *	receiver.
					 */
					Token_State = TOKEN_GRABBED;
					m_uidGrabber = receiver_id;
				}
				else
				{
					/*
					 *	The token was not accepted.  Since the donor has
					 *	already relinquished control of the token, the token
					 *	will marked as available (which will cause it to be
					 *	deleted).
					 */
					Token_State = TOKEN_AVAILABLE;
				}

				/*
				 *	Check to see if this is the Top Provider.
				 */
				if (m_pConnToTopProvider != NULL)
				{
					/*
					 *	If this is not the Top Provider, then the valid give
					 *	response must be forwarded to the Top Provider.
					 */
					m_pConnToTopProvider->TokenGiveResponse(result, receiver_id, Token_ID);
				}
			}
			break;
	}
}

/*
 *	Void	TokenGiveConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a potential giver of a token is told whether
 *		or not the token was successfully given to the intended recipient.
 */
Void	Token::TokenGiveConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID(uidInitiator))
	{
		/*
		 *	The token should be in the grabbed state, or else this confirm
		 *	was generated in error.
		 */
		if (Token_State == TOKEN_GRABBED)
		{
			/*
			 *	Check to see if this request was successful.
			 */
			if (result == RESULT_SUCCESSFUL)
			{
				/*
				 *	If this token is marked as being owned by the initiator of
				 *	the give, but the status indicates that the token is now
				 *	owned by someone else (as a result of the successful give),
				 *	then release the token.*
				 */
				if ((uidInitiator == m_uidGrabber) &&
						(token_status == TOKEN_OTHER_GRABBED))
					Token_State = TOKEN_AVAILABLE;
			}
		}
		else
		{
			/*
			 *	The token is in an invalid state.  Report the error, but do
			 *	not change the state of the token.
			 */
			ERROR_OUT(("Token::TokenGiveConfirm: invalid token state"));
		}

		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenGiveConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenGiveConfirm: invalid initiator ID"));
	}
}

/*
 *	Void		TokenPleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wishes to ask all current owners
 *		of a token to relinquish their ownership.
 */
Void	Token::TokenPleaseRequest (
				UserID				uidInitiator,
				TokenID)
{
	CUidList				please_indication_list;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (IsTopProvider())
	{
        CAttachmentList         attachment_list;
        CAttachment            *pAtt;
		/*
		 *	Determine the state of the token, to determine who to send the
		 *	please indication to.  Each state will place the appropriate user
		 *	IDs in the please indication list.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				break;

			case TOKEN_GRABBED:
				/*
				 *	Put the grabber into the list.
				 */
				please_indication_list.Append(m_uidGrabber);
				break;

			case TOKEN_INHIBITED:
				{
					UserID		uid;
					/*
					 *	Put all current inhibitors into the list.
					 */
					m_InhibitorList.Reset();
					while (NULL != (uid = m_InhibitorList.Iterate()))
					{
						please_indication_list.Append(uid);
					}
				}
				break;

			case TOKEN_GIVING:
				/*
				 *	Put the grabber into the list.  And if the recipient is
				 *	different from the grabber, put it in as well.  Remember
				 *	that it is valid for someone to give a token to themselves.
				 */
				please_indication_list.Append(m_uidGrabber);
				if (m_uidGrabber != m_uidRecipient)
					please_indication_list.Append(m_uidRecipient);
				break;

			case TOKEN_GIVEN:
				/*
				 *	Put the recipient into the list.
				 */
				please_indication_list.Append(m_uidRecipient);
				break;
		}

		/*
		 *	Build lists of unique attachments that lead to the users in the
		 *	please indication list (built above).
		 */
		BuildAttachmentList (&please_indication_list, &attachment_list);

		/*
		 *	Iterate through the newly created attachment list, issuing token
		 *	please indications to all attachments contained therein.
		 */
		attachment_list.Reset();
		while (NULL != (pAtt = attachment_list.Iterate()))
		{
			pAtt->TokenPleaseIndication(uidInitiator, Token_ID);
		}
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenPleaseRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenPleaseRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void		TokenPleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called in order to deliver a message to all current
 *		owners of a token that someone else wishes to own the token.
 */
Void	Token::TokenPleaseIndication (
				UserID				uidInitiator,
				TokenID)
{
	CUidList				please_indication_list;
	CAttachmentList         attachment_list;
    CAttachment            *pAtt;

	/*
	 *	Determine the state of the token, to determine who to forward the
	 *	please indication to.  Each state will place the appropriate user
	 *	IDs in the please indication list.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			/*
			 *	Put the grabber into the list.
			 */
			please_indication_list.Append(m_uidGrabber);
			break;

		case TOKEN_INHIBITED:
			{
				UserID		uid;
				/*
				 *	Put all current inhibitors into the list.
				 */
				m_InhibitorList.Reset();
				while (NULL != (uid = m_InhibitorList.Iterate()))
				{
					please_indication_list.Append(uid);
				}
			}
			break;

		case TOKEN_GIVING:
			/*
			 *	Put the grabber into the list.  And if the recipient is
			 *	different from the grabber, put it in as well.  Remember
			 *	that it is valid for someone to give a token to themselves.
			 */
			please_indication_list.Append(m_uidGrabber);
			if (m_uidGrabber != m_uidRecipient)
				please_indication_list.Append(m_uidRecipient);
			break;

		case TOKEN_GIVEN:
			/*
			 *	Put the recipient into the list.
			 */
			please_indication_list.Append(m_uidRecipient);
			break;
	}

	/*
	 *	Build lists of unique attachments that lead to the users in the
	 *	please indication list (built above).
	 */
	BuildAttachmentList (&please_indication_list, &attachment_list);

	/*
	 *	Iterate through the newly created attachment list, issuing token
	 *	please indications to all attachments contained therein.
	 */
	attachment_list.Reset();
	while (NULL != (pAtt = attachment_list.Iterate()))
	{
		pAtt->TokenPleaseIndication(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenReleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wished to release a token.  If the
 *		requesting user really is an owner of the token, the request will
 *		succeed.  Otherwise it will fail.  Either way, an appropriate token
 *		release confirm will be issued.
 */
Void	Token::TokenReleaseRequest (
				CAttachment        *pAtt,
				UserID				uidInitiator,
				TokenID)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (IsTopProvider())
	{
		/*
		 *	Determine the current state of the token before proceeding.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	If the token is available, then the requestor cannot be an
				 *	owner.  This means that the request must fail.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				token_status = TOKEN_NOT_IN_USE;
				break;

			case TOKEN_GRABBED:
				/*
				 *	The token is in the grabbed state.  See if the requesting
				 *	user is the one who has it grabbed.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	The current grabber of the token wishes to release it.
					 *	Set the state back to available, and send the
					 *	appropriate token release confirm.
					 */
					Token_State = TOKEN_AVAILABLE;

					result = RESULT_SUCCESSFUL;
					token_status = TOKEN_NOT_IN_USE;
				}
				else
				{
					/*
					 *	Someone is trying to release someone elses token.  This
					 *	request must fail.  Send the appropriate token release
					 *	confirm.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					token_status = TOKEN_OTHER_GRABBED;
				}
				break;

			case TOKEN_INHIBITED:
				/*
				 *	The token is in the inhibited state.  See if the requesting
				 *	user is one of the inhibitors.
				 */
				if (m_InhibitorList.Remove(uidInitiator))
				{
					/*
					 *	The user is an inhibitor.  Remove the user from the
					 *	list.  Then check to see if this has resulted in an
					 *	"ownerless" token.
					 */
					if (m_InhibitorList.IsEmpty())
					{
						/*
						 *	The token has no other inhibitors.  Return the token
						 *	to the available state, and issue the appropriate
						 *	token release confirm.
						 */
						Token_State = TOKEN_AVAILABLE;

						result = RESULT_SUCCESSFUL;
						token_status = TOKEN_NOT_IN_USE;
					}
					else
					{
						/*
						 *	There are still other inhibitors of the token.
						 *	Simply issue the appropriate token release confirm.
						 */
						result = RESULT_SUCCESSFUL;
						token_status = TOKEN_OTHER_INHIBITED;
					}
				}
				else
				{
					/*
					 *	The user attempting to release the token is not one of
					 *	the inhibitors.  Therefore the request must fail.  Issue
					 *	the appropriate token release indication.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					token_status = TOKEN_OTHER_INHIBITED;
				}
				break;

			case TOKEN_GIVING:
				/*
				 *	See if the requestor is the current owner of the token.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	The token must transition to the given state.  This
					 *	state indicates that if the recipient rejects the offer
					 *	or detaches, the token will be freed instead of
					 *	returning to the grabbed state.  Issue the appropriate
					 *	release confirm.
					 */
					Token_State = TOKEN_GIVEN;

					result = RESULT_SUCCESSFUL;
					token_status = TOKEN_OTHER_GIVING;
				}
				else
				{
					/*
					 *	If the requestor is not the current owner, then this
					 *	request must fail.  We first need to determine the
					 *	proper token status, and then issue the confirm.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					if (uidInitiator == m_uidRecipient)
						token_status = TOKEN_SELF_RECIPIENT;
					else
						token_status = TOKEN_OTHER_GIVING;
				}
				break;

			case TOKEN_GIVEN:
				/*
				 *	When the token is in the given state, there is no true
				 *	owner (only a pending owner).  This request must therefore
				 *	fail.  We first need to determine the proper token status,
				 *	and then issue the confirm.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	Issue the token release confirm to the initiator.
		 */
		pAtt->TokenReleaseConfirm(result, uidInitiator, Token_ID, token_status);
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenReleaseRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenReleaseRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenReleaseConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenReleaseConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID (uidInitiator) )
	{
		/*
		 *	Check to see if this request was successful.
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Process the confirm according to current state.
			 */
			switch (Token_State)
			{
				case TOKEN_AVAILABLE:
					break;

				case TOKEN_GRABBED:
					/*
					 *	If the grabber has released the token, then is becomes
					 *	available.
					 */
					if (uidInitiator == m_uidGrabber)
						Token_State = TOKEN_AVAILABLE;
					break;

				case TOKEN_INHIBITED:
					/*
					 *	If an inhibitor releases the token, then remove it from
					 *	the list.  If there are no more entries in the list,
					 *	then the token becomes available.
					 */
					if (m_InhibitorList.Remove(uidInitiator))
					{
						if (m_InhibitorList.IsEmpty())
							Token_State = TOKEN_AVAILABLE;
					}
					break;

				case TOKEN_GIVING:
					/*
					 *	If the grabber releases the token, then it transitions
					 *	to an intermediate state.  This state indicates that
					 *	if the recipient rejects the token, it will be freed
					 *	instead of returning to the grabbed state.
					 */
					if (uidInitiator == m_uidGrabber)
						Token_State = TOKEN_GIVEN;
					break;

				case TOKEN_GIVEN:
					break;
			}
		}

		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenReleaseConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenReleaseConfirm: invalid initiator ID"));
	}
}

/*
 *	Void	TokenTestRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wishes to test the current state
 *		of a token.  The only action is to issue a token test confirm containing
 *		the state information.
 */
Void	Token::TokenTestRequest (
				CAttachment        *pAtt,
				UserID				uidInitiator,
				TokenID)
{
	TokenStatus		token_status;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (m_pConnToTopProvider == NULL)
	{
		/*
		 *	Determine the state of the token before proceeding.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	The token is not in use.
				 */
				token_status = TOKEN_NOT_IN_USE;
				break;

			case TOKEN_GRABBED:
				/*
				 *	The token is grabbed.  See if the originating user is the
				 *	grabber.  If so, return the state as self grabbed.  If not,
				 *	return the state as other grabbed.
				 */
				if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GRABBED;
				else
					token_status = TOKEN_OTHER_GRABBED;
				break;

			case TOKEN_INHIBITED:
				/*
				 *	The token is inhibited.  See if the originating user is one
				 *	of the inhibitors.  If so, return the state as self
				 *	inhibited.  If not, return the state as other inhibited.
				 */
				if (m_InhibitorList.Find(uidInitiator))
					token_status = TOKEN_SELF_INHIBITED;
				else
					token_status = TOKEN_OTHER_INHIBITED;
				break;

			case TOKEN_GIVING:
				/*
				 *	The token is being given from one user to another.  See if
				 *	the requestor is one of the users involved.
				 */
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	The token has been given from one user to another.  See if
				 *	the requestor is the receiver.
				 */
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	Issue the test confirm with the appropriate status information.
		 */
		pAtt->TokenTestConfirm(uidInitiator, Token_ID, token_status);
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenTestRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenTestRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenTestConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenTestConfirm (
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID(uidInitiator))
	{
		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenTestConfirm(uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenReleaseConfirm: invalid initiator ID"));
	}
}

/*
 *	BOOL    ValidateUserID ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to verify the existence of the specified user
 *		in the sub-tree of this provider.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user the caller wishes to validate.
 *
 *	Return Value:
 *		TRUE if the user is valid.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 */
BOOL    Token::ValidateUserID (
					UserID			user_id)
{
	/*
	 *	Initialize the return value to FALSE, indicating that if any of the
	 *	following checks fail, the ID does NOT refer to a valid user ID.
	 */
	BOOL    	valid=FALSE;
	PChannel	channel;

	/*
	 *	First check to see if the user ID is in the channel list at all.  This
	 *	prevents an attempt to read an invalid entry from the dictionary.
	 */
	if (NULL != (channel = m_pChannelList2->Find(user_id)))
	{
		/*
		 *	We know that the ID is in the dictionary, but we don't know for sure
		 *	whether or not it is a user ID channel.  So check this.  If it is a
		 *	user channel, then set the valid flag to TRUE.
		 */
		if (channel->GetChannelType () == USER_CHANNEL)
			valid = TRUE;
	}

	return (valid);
}

/*
 *	PCommandTarget	GetUserAttachment ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function returns the attachment which leads to the specified
 *		user.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user the caller wishes to find the attachment
 *			for.
 *
 *	Return Value:
 *		A pointer to the attachment that leads to the user.
 *
 *	Side Effects:
 *		None.
 */
CAttachment *Token::GetUserAttachment (
						UserID				user_id)
{
	PChannel		lpChannel;
	/*
	 *	Read and return a pointer to the attachment that leads to the
	 *	specified user.  Note that this routine does NOT check to see if the
	 *	user is in the channel list.  It assumes that the user is known to
	 *	be valid BEFORE this routine is called.
	 */
	return ((NULL != (lpChannel = m_pChannelList2->Find(user_id))) ?
            lpChannel->GetAttachment() :
            NULL);
}

/*
 *	Void	IssueTokenReleaseIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to issue a token release indication to a
 *		particular user.  It first check to make sure that the user id valid,
 *		and that it is a local user.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user the caller wishes to send a token
 *			release indication to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Token::IssueTokenReleaseIndication (
				UserID			user_id)
{
	/*
	 *	Make sure that the specified user exists in the sub-tree of this
	 *	provider.
	 */
	if (ValidateUserID (user_id) )
	{
		/*
		 *	Determine which attachment leads to the grabber.
		 */
		CAttachment *pAtt = GetUserAttachment(user_id);

		/*
		 *	Is this attachment a local one?  If so, then issue a token
		 *	release indication to let the user know that the token has
		 *	been taken away.
		 */
		if (m_pAttachmentList->Find(pAtt) && pAtt->IsUserAttachment())
		{
		    PUser pUser = (PUser) pAtt;
			pUser->TokenReleaseIndication(REASON_TOKEN_PURGED, Token_ID);
		}
	}
}

/*
 *	Void	BuildAttachmentList ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function builds a list of unique attachments out of the list of
 *		user IDs that is poassed in.  This is done to insure that no given
 *		attachment receives more than one indication, even when there are more
 *		than one user in the same direction.
 *
 *	Formal Parameters:
 *		user_id_list (i)
 *			This is a list of user IDs that the caller wishes to send a token
 *			please indication to.
 *		attachment_list (i)
 *			This is the list that all unique attachments will be added to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Token::BuildAttachmentList (
				CUidList                *user_id_list,
				CAttachmentList         *attachment_list)
{
	UserID				uid;

	/*
	 *	Loop through the passed in user ID list building a list of unique
	 *	attachments.  This will be used to send indications downward without
	 *	sending one twice over the same attachment.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Check to see if the user ID refers to a valid user in the sub-tree
		 *	of this provider.
		 */
		if (ValidateUserID(uid))
		{
			/*
			 *	Determine which attachment leads to the user in question.  Then
			 *	check to see if it is already in the attachment list.  If not,
			 *	then put it there.
			 */
			CAttachment *pAtt = GetUserAttachment(uid);
			if (attachment_list->Find(pAtt) == FALSE)
				attachment_list->Append(pAtt);
		}
		else
		{
			/*
			 *	This user ID does not correspond to a valid user in the sub-tree
			 *	of this provider.  Therefore, discard the ID.
			 */
			ERROR_OUT(("Token::BuildAttachmentList: user ID not valid"));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\translat.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	translat.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Reason and Result Translator
 *		Class. 
 *
 *	Caveats:
 *		None. 
 *
 *	Author:
 *		jbo
 */


#include "pdutypes.h"
#include "translat.h"


/*
 *	TranslateGCCResultToCreateResult ()
 *
 *	Public Function Description:
 */
ConferenceCreateResult
TranslateGCCResultToCreateResult ( GCCResult gcc_result )
{
	ConferenceCreateResult	create_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		create_result = CCRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_USER_REJECTED:
		create_result = CCRS_USER_REJECTED;
		break;

	case GCC_RESULT_RESOURCES_UNAVAILABLE:
		create_result = RESOURCES_NOT_AVAILABLE;
		break;

	case GCC_RESULT_SYMMETRY_BROKEN:
		create_result = REJECTED_FOR_SYMMETRY_BREAKING;
		break;

	case GCC_RESULT_LOCKED_NOT_SUPPORTED:
		create_result = LOCKED_CONFERENCE_NOT_SUPPORTED;
		break;

	default:
		create_result = RESOURCES_NOT_AVAILABLE;
		break;
	}

	return (create_result);
}


/*
 *	TranslateGCCResultToQueryResult ()
 *
 *	Public Function Description:
 */
ConferenceQueryResult
TranslateGCCResultToQueryResult ( GCCResult gcc_result )
{
	ConferenceQueryResult	query_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		query_result = CQRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_USER_REJECTED:
		query_result = CQRS_USER_REJECTED;
		break;

	default:
		query_result = CQRS_USER_REJECTED;
		break;
	}

	return (query_result);
}


/*
 *	TranslateGCCResultToJoinResult ()
 *
 *	Public Function Description:
 */
ConferenceJoinResult
TranslateGCCResultToJoinResult ( GCCResult gcc_result )
{
	ConferenceJoinResult	join_result;

    switch (gcc_result)
    {
	case GCC_RESULT_SUCCESSFUL:
    	join_result = CJRS_RESULT_SUCCESS;
        break;

	case GCC_RESULT_USER_REJECTED:
    	join_result = CJRS_USER_REJECTED;
        break;

    case GCC_RESULT_INVALID_CONFERENCE:
    	join_result = INVALID_CONFERENCE;
        break;

    case GCC_RESULT_INVALID_PASSWORD:
    	join_result = INVALID_PASSWORD;
        break;

    case GCC_RESULT_INVALID_CONVENER_PASSWORD:
    	join_result = INVALID_CONVENER_PASSWORD;
    	break;

    case GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED:
    	join_result = CHALLENGE_RESPONSE_REQUIRED;
    	break;

    case GCC_RESULT_INVALID_CHALLENGE_RESPONSE:
    	join_result = INVALID_CHALLENGE_RESPONSE;
    	break;

    default:
    	join_result = INVALID_CONFERENCE;
    	break;
    }

    return (join_result);
}


/*
 *	TranslateGCCResultToInviteResult ()
 *
 *	Public Function Description:
 */
ConferenceInviteResult
TranslateGCCResultToInviteResult ( GCCResult gcc_result )
{
	ConferenceInviteResult	invite_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		invite_result = CIRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_USER_REJECTED:
		invite_result = CIRS_USER_REJECTED;
		break;

	default:
		invite_result = CIRS_USER_REJECTED;
		break;
	}

	return (invite_result);
}


/*
 *	TranslateGCCResultToRegistryResp ()
 *
 *	Public Function Description:
 */
RegistryResponseResult
TranslateGCCResultToRegistryResp ( GCCResult gcc_result )
{
	RegistryResponseResult			registry_response_result;

    switch (gcc_result)
    {
	case GCC_RESULT_SUCCESSFUL:
    	registry_response_result = RRRS_RESULT_SUCCESSFUL;
        break;

    case GCC_RESULT_INDEX_ALREADY_OWNED:
    	registry_response_result = BELONGS_TO_OTHER;
    	break;

    case GCC_RESULT_REGISTRY_FULL:
    	registry_response_result = TOO_MANY_ENTRIES;
        break;

    case GCC_RESULT_INCONSISTENT_TYPE:
    	registry_response_result = INCONSISTENT_TYPE;
        break;

    case GCC_RESULT_ENTRY_DOES_NOT_EXIST:
    	registry_response_result = ENTRY_NOT_FOUND;
        break;

    case GCC_RESULT_ENTRY_ALREADY_EXISTS:
    	registry_response_result = ENTRY_ALREADY_EXISTS;
        break;

    case GCC_RESULT_INVALID_REQUESTER:
		registry_response_result = RRRS_INVALID_REQUESTER;
        break;

    default:
		registry_response_result = RRRS_INVALID_REQUESTER;//jbo default???????
    	break;
    }

    return (registry_response_result);
}


/*
 *	TranslateCreateResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult 
TranslateCreateResultToGCCResult ( ConferenceCreateResult create_result )
{
	GCCResult	gcc_result;
  
	switch (create_result)
	{
	case CCRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CCRS_USER_REJECTED:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;

	case RESOURCES_NOT_AVAILABLE:
		gcc_result = GCC_RESULT_RESOURCES_UNAVAILABLE;
		break;

	case REJECTED_FOR_SYMMETRY_BREAKING:
		gcc_result = GCC_RESULT_SYMMETRY_BROKEN;
		break;

	case LOCKED_CONFERENCE_NOT_SUPPORTED:
		gcc_result = GCC_RESULT_LOCKED_NOT_SUPPORTED;
		break;

	default:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateQueryResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult 
TranslateQueryResultToGCCResult ( ConferenceQueryResult query_result )
{
	GCCResult	gcc_result;
  
	switch (query_result)
	{
	case CQRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CQRS_USER_REJECTED:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;

	default:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateJoinResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateJoinResultToGCCResult ( ConferenceJoinResult join_result )
{
	GCCResult	gcc_result;

    switch (join_result)
    {
	case CJRS_RESULT_SUCCESS:
    	gcc_result = GCC_RESULT_SUCCESSFUL;
        break;

    case CJRS_USER_REJECTED:
    	gcc_result = GCC_RESULT_USER_REJECTED;
        break;

    case INVALID_CONFERENCE:
		gcc_result = GCC_RESULT_INVALID_CONFERENCE;
        break;

    case INVALID_PASSWORD:
    	gcc_result = GCC_RESULT_INVALID_PASSWORD;
        break;

    case INVALID_CONVENER_PASSWORD:
    	gcc_result = GCC_RESULT_INVALID_CONVENER_PASSWORD;
    	break;

    case CHALLENGE_RESPONSE_REQUIRED:
    	gcc_result = GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED;
    	break;

    case INVALID_CHALLENGE_RESPONSE:
    	gcc_result = GCC_RESULT_INVALID_CHALLENGE_RESPONSE;
    	break;

    default:
    	gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
    	break;
    }

    return (gcc_result);
}


/*
 *	TranslateInviteResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateInviteResultToGCCResult ( ConferenceInviteResult invite_result )
{
	GCCResult	gcc_result;
  
	switch (invite_result)
	{
	case CIRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;
		
	case CIRS_USER_REJECTED:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;

	default:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateRegistryRespToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateRegistryRespToGCCResult ( RegistryResponseResult response_result )
{
	GCCResult 	gcc_result;
	
	switch (response_result)
    {
	case RRRS_RESULT_SUCCESSFUL:
		gcc_result = GCC_RESULT_SUCCESSFUL;
        break;

	case BELONGS_TO_OTHER:
		gcc_result = GCC_RESULT_INDEX_ALREADY_OWNED;
       	break;

	case TOO_MANY_ENTRIES:
		gcc_result = GCC_RESULT_REGISTRY_FULL;
        break;

	case INCONSISTENT_TYPE:
		gcc_result = GCC_RESULT_INCONSISTENT_TYPE;
    	break;

    case ENTRY_NOT_FOUND:
    	gcc_result = GCC_RESULT_ENTRY_DOES_NOT_EXIST;
        break;

    case ENTRY_ALREADY_EXISTS:
    	gcc_result = GCC_RESULT_ENTRY_ALREADY_EXISTS;
        break;

    case RRRS_INVALID_REQUESTER:
    	gcc_result = GCC_RESULT_INVALID_REQUESTER;
        break;

	default:
		gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;//jbo default ???????
		break;
     }

	return (gcc_result);
}


/*
 *	TranslateTerminateRqReasonToGCCReason ()
 *
 *	Public Function Description:
 */
GCCReason
TranslateTerminateRqReasonToGCCReason ( ConferenceTerminateRequestReason reason )
{
	GCCReason	gcc_reason;

	switch (reason)
	{
	case CTRQ_REASON_USER_INITIATED:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;

	case CTRQ_TIMED_CONFERENCE_TERMINATE:
		gcc_reason = GCC_REASON_TIMED_TERMINATION;
		break;

	default:
		gcc_reason = GCC_REASON_ERROR_TERMINATION;
		break;
	}

	return (gcc_reason);
}


/*
 *	TranslateGCCReasonToTerminateRqReason ()
 *
 *	Public Function Description:
 */
ConferenceTerminateRequestReason
TranslateGCCReasonToTerminateRqReason ( GCCReason gcc_reason )
{
	ConferenceTerminateRequestReason	reason;

	switch (gcc_reason)
	{
	case GCC_REASON_USER_INITIATED:
		reason = CTRQ_REASON_USER_INITIATED;
		break;

	case GCC_REASON_TIMED_TERMINATION:
		reason = CTRQ_TIMED_CONFERENCE_TERMINATE;
		break;

	default:
		reason = CTRQ_REASON_USER_INITIATED;
		break;
	}

	return (reason);
}


/*
 *	TranslateEjectIndReasonToGCCReason ()
 *
 *	Public Function Description:
 */
GCCReason
TranslateEjectIndReasonToGCCReason ( ConferenceEjectIndicationReason eject_reason )
{
	GCCReason	gcc_reason;

	switch (eject_reason)
	{
	case CEIN_USER_INITIATED:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;

	case HIGHER_NODE_DISCONNECTED:
		gcc_reason = GCC_REASON_HIGHER_NODE_DISCONNECTED;
		break;

	case HIGHER_NODE_EJECTED:
		gcc_reason = GCC_REASON_HIGHER_NODE_EJECTED;
		break;

	default:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;
	}

	return (gcc_reason);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
ConferenceEjectIndicationReason
TranslateGCCReasonToEjectInd ( GCCReason gcc_reason )
{
	ConferenceEjectIndicationReason	eject_reason;

	switch (gcc_reason)
	{
	case GCC_REASON_USER_INITIATED:
		eject_reason = CEIN_USER_INITIATED;
		break;

	case GCC_REASON_HIGHER_NODE_DISCONNECTED:
		eject_reason = HIGHER_NODE_DISCONNECTED;
		break;

	case GCC_REASON_HIGHER_NODE_EJECTED:
		eject_reason = HIGHER_NODE_EJECTED;
		break;

	default:
		eject_reason = CEIN_USER_INITIATED;
		break;
	}

	return (eject_reason);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateEjectResultToGCCResult ( ConferenceEjectResult eject_result )
{
	GCCResult	gcc_result;

	switch (eject_result)
	{
	case CERS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CERS_INVALID_REQUESTER:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;

	case CERS_INVALID_NODE:
		gcc_result = GCC_RESULT_INVALID_NODE;
		break;

	default:
		gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
ConferenceEjectResult
TranslateGCCResultToEjectResult ( GCCResult gcc_result )
{
	ConferenceEjectResult	eject_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		eject_result = CERS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		eject_result = CERS_INVALID_REQUESTER;
		break;

	case GCC_RESULT_INVALID_NODE:
		eject_result = CERS_INVALID_NODE;
		break;

	default:
		eject_result = CERS_INVALID_NODE;
		break;
	}

	return (eject_result);
}


/*
 *	TranslateTerminateInReasonToGCCReason ()
 *
 *	Public Function Description:
 */
GCCReason
TranslateTerminateInReasonToGCCReason ( ConferenceTerminateIndicationReason reason )
{
	GCCReason		gcc_reason;

	switch (reason)
	{
	case CTIN_REASON_USER_INITIATED:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;

	case CTIN_TIMED_CONFERENCE_TERMINATE:
		gcc_reason = GCC_REASON_TIMED_TERMINATION;
		break;

	default:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;
	}

	return (gcc_reason);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
ConferenceTerminateIndicationReason
TranslateGCCReasonToTerminateInReason ( GCCReason gcc_reason )
{
	ConferenceTerminateIndicationReason		reason;

	switch (gcc_reason)
	{
	case GCC_REASON_USER_INITIATED:
		reason = CTIN_REASON_USER_INITIATED;
		break;

	case GCC_REASON_TIMED_TERMINATION:
		reason = CTIN_TIMED_CONFERENCE_TERMINATE;
		break;

	default:
		reason = CTIN_REASON_USER_INITIATED;
		break;
	}

	return (reason);
}


/*
 *	TranslateGCCResultToTerminateResult ()
 *
 *	Public Function Description:
 */
ConferenceTerminateResult
TranslateGCCResultToTerminateResult ( GCCResult gcc_result )
{
	ConferenceTerminateResult	result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		result = CTRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		result = CTRS_INVALID_REQUESTER;
		break;

	default:
		result = CTRS_INVALID_REQUESTER;
		break;
	}

	return (result);
}


/*
 *	TranslateTerminateResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateTerminateResultToGCCResult ( ConferenceTerminateResult result )
{
	GCCResult	gcc_result;

	switch (result)
	{
	case CTRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CTRS_INVALID_REQUESTER:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;

	default:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateGCCResultToLockResult ()
 *
 *	Public Function Description:
 */
ConferenceLockResult
TranslateGCCResultToLockResult ( GCCResult gcc_result )
{
	ConferenceLockResult	return_value;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		return_value = CLRS_SUCCESS;
		break;

	case GCC_RESULT_CONFERENCE_ALREADY_LOCKED:
		return_value = CLRS_ALREADY_LOCKED;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		return_value = CLRS_INVALID_REQUESTER;
		break;

	default:
		return_value = CLRS_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateLockResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateLockResultToGCCResult ( ConferenceLockResult result )
{
	GCCResult	return_value;

	switch (result)
	{
	case CLRS_SUCCESS:
		return_value = GCC_RESULT_SUCCESSFUL;
		break;

	case CLRS_ALREADY_LOCKED:
		return_value = GCC_RESULT_CONFERENCE_ALREADY_LOCKED;
		break;

	case CLRS_INVALID_REQUESTER:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;

	default:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateGCCResultToUnlockResult ()
 *
 *	Public Function Description:
 */
ConferenceUnlockResult
TranslateGCCResultToUnlockResult ( GCCResult gcc_result )
{
	ConferenceUnlockResult	return_value;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		return_value = CURS_SUCCESS;
		break;

	case GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED:
		return_value = CURS_ALREADY_UNLOCKED;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		return_value = CURS_INVALID_REQUESTER;
		break;

	default:
		return_value = CURS_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateUnlockResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateUnlockResultToGCCResult ( ConferenceUnlockResult result )
{
	GCCResult		return_value;

	switch (result)
	{
	case CURS_SUCCESS:
		return_value = GCC_RESULT_SUCCESSFUL;
		break;

	case CURS_ALREADY_UNLOCKED:
		return_value = GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED;
		break;

	case CURS_INVALID_REQUESTER:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;

	default:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateGCCResultToAddResult ()
 *
 *	Public Function Description:
 */
ConferenceAddResult
TranslateGCCResultToAddResult ( GCCResult gcc_result )
{
	ConferenceAddResult	add_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		add_result = CARS_SUCCESS;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		add_result = CARS_INVALID_REQUESTER;
		break;

	case GCC_RESULT_INVALID_NETWORK_TYPE:
		add_result = INVALID_NETWORK_TYPE;
		break;

	case GCC_RESULT_INVALID_NETWORK_ADDRESS:
		add_result = INVALID_NETWORK_ADDRESS;
		break;

	case GCC_RESULT_ADDED_NODE_BUSY:
		add_result = ADDED_NODE_BUSY;
		break;

	case GCC_RESULT_NETWORK_BUSY:
		add_result = NETWORK_BUSY;
		break;

	case GCC_RESULT_NO_PORTS_AVAILABLE:
		add_result = NO_PORTS_AVAILABLE;
		break;

	case GCC_RESULT_CONNECTION_UNSUCCESSFUL:
		add_result = CONNECTION_UNSUCCESSFUL;
		break;

	default:
		add_result = CARS_INVALID_REQUESTER;
		break;
	}

	return (add_result);
}


/*
 *	TranslateAddResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateAddResultToGCCResult ( ConferenceAddResult add_result )
{
	GCCResult	gcc_result;

	switch (add_result)
	{
	case CARS_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CARS_INVALID_REQUESTER:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;

	case INVALID_NETWORK_TYPE:
		gcc_result = GCC_RESULT_INVALID_NETWORK_TYPE;
		break;

	case INVALID_NETWORK_ADDRESS:
		gcc_result = GCC_RESULT_INVALID_NETWORK_ADDRESS;
		break;

	case ADDED_NODE_BUSY:
		gcc_result = GCC_RESULT_ADDED_NODE_BUSY;
		break;

	case NETWORK_BUSY:
		gcc_result = GCC_RESULT_NETWORK_BUSY;
		break;

	case NO_PORTS_AVAILABLE:
		gcc_result = GCC_RESULT_NO_PORTS_AVAILABLE;
		break;

	case CONNECTION_UNSUCCESSFUL:
		gcc_result = GCC_RESULT_CONNECTION_UNSUCCESSFUL;
		break;

	default:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return (gcc_result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\userchnl.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	userchnl.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the UserChannel class.  It contains
 *		the code that distinguishes this class from that of its parent, Channel.
 *
 *		The main difference between this class and that of its parent is how
 *		the join and data requests are handled.  There is also a new instance
 *		variable that keeps track of what attachment leads to the user being
 *		represented by this class.  Merge requests are also generated as is
 *		appropriate for a user channel
 *
 *		The data primitives are overridden, allowing this object to decide
 *		not to send data upward, if it is known that the user lies in the
 *		sub-tree of this provider.
 *
 *	Private Instance Variables:
 *		m_pUserAttachment
 *			This is a pointer to the attachment that leads to the user being
 *			represented by this object.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include "userchnl.h"


/*
 *	UserChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the primary constructor for UserChannel objects.  It creates
 *		an object with all instance variable initialized, but with no
 *		attachments (i.e. the user is not joined to the channel automatically).
 *
 *		Note that most instance variable initialization is done by invoking the
 *		equivalent constructor in the base class.
 *
 *		Upon successful completion, an attach user confirm is automtically
 *		issued to the new user.
 */
UserChannel::UserChannel (
		ChannelID			channel_id,
		CAttachment        *user_attachment,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list)
:
    Channel(channel_id, local_provider, top_provider, channel_list, attachment_list),
    m_pUserAttachment(user_attachment)
{
	/*
	 *	Issue an attach user confirm to the new user.
	 */
	m_pUserAttachment->AttachUserConfirm(RESULT_SUCCESSFUL, channel_id);
}

/*
 *	UserChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a secondary constructor that is only used during merge
 *		operations.  The intent of this constructor is to create an equivalent
 *		object without issuing any of the confirms.
 *
 *		Note that the additional constructor allows for the creator to specify
 *		that the user is to be already joined to the channel upon creation.
 *		The value of user_attachment and attachment should either be the same
 *		or attachment should be NULL.
 */
UserChannel::UserChannel (
		ChannelID			channel_id,
		CAttachment        *user_attachment,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list,
		PConnection         pConn)
:
    Channel(channel_id, local_provider, top_provider, channel_list, attachment_list, pConn),
    m_pUserAttachment(user_attachment)
{
}

/*
 *	~UserChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This destructor does nothing more than clear the joined attachment list.
 *		This is important because it prevents the base class destructor from
 *		trying to issue channel leave indications to the user if the user is
 *		locally attached.
 */
UserChannel::~UserChannel ()
{
}

/*
 *	Channel_Type		GetChannelType ()
 *
 *	Public
 *
 *	Functional Description:
 *		Objects of this class are always user channels, so simply return
 *		USER_CHANNEL.
 */
Channel_Type		UserChannel::GetChannelType ()
{
	return (USER_CHANNEL);
}

/*
 *	BOOL    IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		User ID channels are always valid, so return TRUE.
 */
BOOL    UserChannel::IsValid ()
{
	return (TRUE);
}

/*
 *	CAttachment *GetAttachment ()
 *
 *	Public
 *
 *	Functional Description:
 *		Return the pointer to the attachment leading to the user.
 */
CAttachment	*UserChannel::GetAttachment(void)
{
	return m_pUserAttachment;
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is used to cause the Channel object to issue a
 *		merge request to the pending top provier.
 */
Void	UserChannel::IssueMergeRequest ()
{
	ChannelAttributes		channel_attributes;
	CChannelAttributesList	merge_channel_list;
	CChannelIDList			purge_channel_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Fill in the fields of the channel attributes structure so that it
		 *	accurately describes this channel.  Then put the structure into the
		 *	merge channel list.
		 */
		channel_attributes.channel_type = USER_CHANNEL;
		if (m_JoinedAttachmentList.IsEmpty() == FALSE)
			channel_attributes.u.user_channel_attributes.joined = TRUE;
		else
			channel_attributes.u.user_channel_attributes.joined = FALSE;
		channel_attributes.u.user_channel_attributes.user_id = Channel_ID;

		merge_channel_list.Append(&channel_attributes);

		/*
		 *	Send the merge request to the indicated provider.
		 */
		m_pConnToTopProvider->MergeChannelsRequest(&merge_channel_list, &purge_channel_list);
	}
}

/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function overrides the base class implementation.  The main
 *		difference is that this implementation only allows a user to join
 *		their own channel.  No one else is allowed to join it.
 *
 *		Also, since it is possible to have a user channel object with no one
 *		joined to it, this request will be forwarded upward to the Top
 *		Provider from here (unless this is the Top Provider).
 */
Void	UserChannel::ChannelJoinRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	/*
	 *	See if the requesting user ID is the same as that of the user this
	 *	UserChannel object represents.
	 */
	if (uidInitiator == Channel_ID)
	{
		/*
		 *	See if the user is already joined to the channel.
		 */
		if (m_JoinedAttachmentList.Find(pOrigAtt) == FALSE)
		{
			/*
			 *	The user is not joined to the channel.  If this is the Top
			 *	Provider, then the request can be processed here.
			 */
			if (IsTopProvider())
			{
				/*
				 *	Add the user to its own channel, and issue a successful
				 *	channel join confirm to the user.
				 */
				TRACE_OUT (("UserChannel::ChannelJoinRequest: "
						"user joining own user ID channel = %04X",
						uidInitiator));

				m_JoinedAttachmentList.Append(pOrigAtt);
	
				pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the join request
				 *	upward to the Top Provider.
				 */
				TRACE_OUT (("UserChannel::ChannelJoinRequest: "
						"forwarding join request to Top Provider"));

				m_pConnToTopProvider->ChannelJoinRequest(uidInitiator, Channel_ID);
			}
		}
		else
		{
			/*
			 *	The user is already joined to their channel.  Go ahead and
			 *	issue a successful channel join confirm.
			 */
			WARNING_OUT (("UserChannel::ChannelJoinRequest: "
					"user already joined to own user channel"));

			pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
		}
	}
	else
	{
		/*
		 *	Someone is trying to join someone elses channel.  This is not
		 *	valid.  Reject the request without further processing.
		 */
		WARNING_OUT (("UserChannel::ChannelJoinRequest: "
				"rejecting attempt to join someone elses user channel"));

		pOrigAtt->ChannelJoinConfirm(RESULT_OTHER_USER_ID, uidInitiator, channel_id, 0);
	}
}

/*
 *	Void	SendDataRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to send data through the channel.  Note that data
 *		is NEVER sent upward, since the user (who is the only one who can be
 *		joined to this channel) is in the sub-tree of this provider.  This helps
 *		to optimize network traffic.
 */
Void	UserChannel::SendDataRequest (
				CAttachment        *pOrigAtt,
				UINT				type,
				PDataPacket			data_packet)
{
	CAttachment *pAtt;

	ASSERT (Channel_ID == data_packet->GetChannelID());

	/*
	 *	Iterate through the attachment list, sending the data to all
	 *	the attachments (except for one from whence the data came).
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		if (pAtt != pOrigAtt)
		{
			pAtt->SendDataIndication(type, data_packet);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\comport.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    Comport.cpp
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the ComPort class.  This class
 *        controls a specific Windows Comm port.  The main purpose of this class
 *        is to put the Windows specific comm calls in one class.
 *
 *    Private Instance Variables:
 *        m_hCommLink                    -    Handle  returned by Windows    when you open
 *                                    a com port
 *        Tx_Buffer_Size            -    Output buffer size, Win32 buffer
 *        Byte_Count                -    Represents total number of bytes transmitted
 *                                    over the comm port
 *        Last_Byte_Count            -    We have a timer that expires every X
 *                                    seconds.  It reports the total number of
 *                                    bytes transmitted if Last_Byte_Count is not
 *                                    equal to the Byte_Count.  This reduces the
 *                                    number of prints that occur
 *        m_cbReadBufferSize        -    Buffer size of the ComPort's internal
 *                                    buffer size.
 *         m_pbReadBuffer                -    Address of our own internal buffer.
 *        m_nReadBufferOffset        -    Keeps track of the number of bytes read
 *                                    by the user via DataIndication calls.
 *        m_cbRead                -    Number of bytes read via the last Windows
 *                                    ReadFile() call.
 *        m_hevtPendingWrite                -    Event object used with Windows WriteFile()
 *                                    call.
 *        m_hevtPendingRead                -    Event object used with Windows ReadFile()
 *                                    call.
 *        Write_Event_Object        -    Pointer to EventObject structure used with
 *                                    the WriteFile() call.
 *        Read_Event_Object        -    Pointer to EventObject structure used with
 *                                    the ReadFile() call.
 *        RLSD_Event_Object        -    Pointer to EventObject structure used with
 *                                    the WaitCommEvent() call.
 *        m_WriteOverlapped        -    Overlapped I/O structure used with the
 *                                    Write event.
 *        m_ReadOverlapped            -    Overlapped I/O structure used with the
 *                                    Read event.
 *        Event_Mask                -    Windows mask that specifies the events
 *                                    that we are interested in.
 *        Read_Active                -    TRUE if a ReadFile() function is active.
 *        Write_Active            -    TRUE if a WriteFile() function is active.
 *        Higher_Layer            -    Pointer to higher ProtocolLayer layer
 *        Port_Configuration        -    Pointer to PortConfiguration structure.
 *        Default_Com_Timeouts    -    This structure holds the Com timeout values
 *                                    that Win32 had set as the default values.
 *                                    When we are finished with the port, we
 *                                    will restore these values
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James P. Galvin
 *        James W. Lawwill
 */
#include "comport.h"

/*
 *    ComPort::ComPort (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                ULONG                message_base,
 *                ULONG                handle,
 *                 PPortConfiguration    port_configuration,
 *                PhysicalHandle        physical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the constructor for the ComPort class.  It initializes internal
 *        variables from the configuration file.
 */
ComPort::ComPort
(
    TransportController        *owner_object,
    ULONG                       message_base,
    PLUGXPRT_PARAMETERS        *pParams,
    PhysicalHandle              hCommLink, // physical handle
    HANDLE                      hevtClose
)
:
    m_hCommLink(hCommLink),
    m_hevtClose(hevtClose),
    m_hevtPendingRead(NULL),
    m_hevtPendingWrite(NULL),
    m_hCommLink2(NULL), // two places can call Release, one in main thread, the other in worker thread by write event
    m_cRef(2),
    m_fClosed(FALSE)
{
    m_pController = owner_object;
    m_nMsgBase = message_base;
    Automatic_Disconnect = FALSE;
    Count_Errors_On_ReadFile = 0;

	m_hevtPendingRead = ::CreateEvent(NULL, TRUE, FALSE, NULL);
	m_hevtPendingWrite = ::CreateEvent(NULL, TRUE, FALSE, NULL);
	ASSERT(m_hevtPendingRead && m_hevtPendingWrite);

    ::ZeroMemory(&m_ReadOverlapped, sizeof(m_ReadOverlapped));
    m_ReadOverlapped.hEvent = m_hevtPendingRead;

    ::ZeroMemory(&m_WriteOverlapped, sizeof(m_WriteOverlapped));
    m_WriteOverlapped.hEvent = m_hevtPendingWrite;

     /*
     **    Initialize internal variables
     */
    Byte_Count = 0;
    Last_Byte_Count = 0;

    m_pbReadBuffer = NULL;
    Read_Active = FALSE;
    m_nReadBufferOffset = 0;
    Read_Event_Object = NULL;

    Write_Active = FALSE;
    Write_Event_Object = NULL;

    DCB dcb;
    ::ZeroMemory(&dcb, sizeof(dcb));
    if (::GetCommState(m_hCommLink, &dcb))    // address of communications properties structure
    {
        Baud_Rate = dcb.BaudRate;
    }
    else
    {
        Baud_Rate = DEFAULT_BAUD_RATE;
    }

    // default settings
    Call_Control_Type = DEFAULT_PSTN_CALL_CONTROL;
    Tx_Buffer_Size = DEFAULT_TX_BUFFER_SIZE;
    Rx_Buffer_Size = DEFAULT_RX_BUFFER_SIZE;
    m_cbReadBufferSize = DEFAULT_INTERNAL_RX_BUFFER_SIZE;

    // get new parameters
    if (NULL != pParams)
    {
        if (PSTN_PARAM__CALL_CONTROL & pParams->dwFlags)
        {
            Call_Control_Type = pParams->eCallControl;
        }
        if (PSTN_PARAM__READ_FILE_BUFFER_SIZE & pParams->dwFlags)
        {
            if (1024 <= pParams->cbReadFileBufferSize)
            {
                m_cbReadBufferSize = pParams->cbReadFileBufferSize;
            }
        }
        if (PSTN_PARAM__PHYSICAL_LAYER_SEND_BUFFER_SIZE & pParams->dwFlags)
        {
            if (DEFAULT_TX_BUFFER_SIZE <= pParams->cbPhysicalLayerSendBufferSize)
            {
                Tx_Buffer_Size = pParams->cbPhysicalLayerSendBufferSize;
            }
        }
        if (PSTN_PARAM__PHSYICAL_LAYER_RECV_BUFFER_SIZE & pParams->dwFlags)
        {
            if (1024 <= pParams->cbPhysicalLayerReceiveBufferSize)
            {
                Rx_Buffer_Size = pParams->cbPhysicalLayerReceiveBufferSize;
            }
        }
    }
}


/*
 *    ComPort::~ComPort (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the destructor for the Comport class. It releases all memory
 *        that was used by the class and deletes all timers.  It also closes the
 *        com port
 */
typedef BOOL (WINAPI *LPFN_CANCEL_IO) (HANDLE);
ComPort::~ComPort(void)
{
    // hopefully the worker thread is able to clean up all the read and write operations
    delete [] m_pbReadBuffer;
    m_pbReadBuffer = NULL;
}


LONG ComPort::Release(void)
{
    Close ();

    HINSTANCE hLib = ::LoadLibrary("kernel32.dll");
    if (NULL != hLib)
    {
        LPFN_CANCEL_IO pfnCancelIo = (LPFN_CANCEL_IO) ::GetProcAddress(hLib, "CancelIo");
        if (NULL != pfnCancelIo)
        {
            (*pfnCancelIo)(m_hCommLink2);
        }
        ::FreeLibrary(hLib);
    }

    COMMTIMEOUTS    com_timeouts, com_timeouts_save;
    if (::GetCommTimeouts(m_hCommLink2, &com_timeouts_save))
    {
        /*
        **    We are setting these timeout values to 0 because we were
        **    getting a VxD fault under Windows 95 when they were set to
        **    their normal values.
        */
        ::ZeroMemory(&com_timeouts, sizeof(com_timeouts));
        ::SetCommTimeouts(m_hCommLink2, &com_timeouts);

        /*
        **    Abort any ReadFile() or WriteFile() operations
        */
        ::PurgeComm(m_hCommLink2, PURGE_TXABORT | PURGE_RXABORT);

        /*
        **    Set the timeouts to their original state
        */
        ::SetCommTimeouts(m_hCommLink2, &com_timeouts_save);
    }

    // decrement the reference count
    if (! ::InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


/*
 *    ComPortError    ComPort::Open (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function opens the comm port and configures it with the values
 *        found in the configuration object.
 */
ComPortError ComPort::Open(void)
{
    BOOL            fRet;
    ComPortError    rc;

    TRACE_OUT(("ComPort:: TX size = %d  RX size = %d Int Rx Size = %d",
                Tx_Buffer_Size, Rx_Buffer_Size, m_cbReadBufferSize));

    if (NULL == m_hevtPendingRead || NULL == m_hevtPendingWrite)
    {
        ERROR_OUT(("ComPort: Error create pending read/write events"));
        ReportInitializationFailure(COMPORT_INITIALIZATION_FAILED);
        return (COMPORT_INITIALIZATION_FAILED);
    }

    // allocate read buffer
    TRACE_OUT(("Comport: Internal Rx Buffer Size = %ld", m_cbReadBufferSize));
    DBG_SAVE_FILE_LINE
    m_pbReadBuffer = new BYTE[m_cbReadBufferSize];
    m_nReadBufferOffset = 0;
    if (m_pbReadBuffer == NULL)
    {
        ERROR_OUT(("ComPort: Error allocating memory = %d", ::GetLastError()));
        ReportInitializationFailure(COMPORT_INITIALIZATION_FAILED);
        return (COMPORT_INITIALIZATION_FAILED);
    }

     /*
     **    Issue a read to the com port.
     **    We are going to continue to issue Readfile() calls
     **    until we get into a wait state.  99.9999% of the
     **    time, we will only issue the first ReadFile() and
     **    it will immediately block waiting for data.
     */
    while (1)
    {
        m_cbRead = 0;
        fRet = ::ReadFile(m_hCommLink, m_pbReadBuffer, m_cbReadBufferSize, &m_cbRead, &m_ReadOverlapped);
        if (! fRet)
        {
            DWORD dwErr = ::GetLastError();
            if (dwErr == ERROR_IO_PENDING)
            {
                Read_Active = TRUE;
                break;
            }
            else
            {
                ERROR_OUT(("ComPort: Error on ReadFile = %d", dwErr));
                ReportInitializationFailure(COMPORT_INITIALIZATION_FAILED);
                return (COMPORT_INITIALIZATION_FAILED);
            }
        }
    }

     /*
     **    If this is a synchronous read, wait for the event object to be
     **    set before returning.
     */
    if (Call_Control_Type == PLUGXPRT_PSTN_CALL_CONTROL_MANUAL)
    {
        ::WaitForSingleObject(m_hevtPendingRead, SYNCHRONOUS_WRITE_TIMEOUT*10);
        fRet = GetOverlappedResult(m_hCommLink, &m_ReadOverlapped, &m_cbRead, FALSE);
        if (! fRet)
        {
            ::PurgeComm(m_hCommLink, PURGE_RXABORT);
        }
    }

     /*
     **    Create and fill in the EventObject.  It is then
     **    appended to the PSTN Event_List so that the EventManager
     **    can wait for the event to occur.
     */
    DBG_SAVE_FILE_LINE
    Read_Event_Object = new EventObject;
    Read_Event_Object -> event = m_hevtPendingRead;
    Read_Event_Object -> delete_event = FALSE;
    Read_Event_Object -> comport = this;
    Read_Event_Object -> hCommLink = m_hCommLink;
    Read_Event_Object -> event_type = READ_EVENT;
    g_pPSTNEventList->append((DWORD_PTR) Read_Event_Object);
    g_fEventListChanged = TRUE;

    Write_Active = FALSE;

     /*
     **    Create and fill in the EventObject.  It is then
     **    appended to the PSTN Event_List so that the EventManager
     **    can wait for the event to occur.
     */
    DBG_SAVE_FILE_LINE
    Write_Event_Object = new EventObject;
    Write_Event_Object -> event = m_hevtPendingWrite;
    Write_Event_Object -> delete_event =  FALSE;
    Write_Event_Object -> comport = this;
    Write_Event_Object -> hCommLink = m_hCommLink;
    Write_Event_Object -> event_type = WRITE_EVENT;
    g_pPSTNEventList->append((DWORD_PTR) Write_Event_Object);
    g_fEventListChanged = TRUE;

    return (COMPORT_NO_ERROR);
}


/*
 *    ComPortError    ComPort::Close (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function makes the necessary Windows calls to close the Com
 *        port.  It first clears the DTR signal to notify the modem.
 */
ComPortError ComPort::Close(void)
{
    if (! m_fClosed)
    {
        m_fClosed = TRUE;

        /*
        **    Reset the Activity flags.
        */
        Write_Active = FALSE;
        Read_Active = FALSE;

        // we do not close the handle here, T.120 will do it.
        m_hCommLink2 = m_hCommLink;
        m_hCommLink = INVALID_HANDLE_VALUE;

         /*
         **    Notify the event manager that these events need to be deleted.
         **    It is important for the event manager to realize that when the
         **    delete_event is set to TRUE, he can no longer access this object.
         */
        if (Write_Event_Object != NULL)
        {
            ::CloseHandle(Write_Event_Object->event);
            g_pPSTNEventList->remove((DWORD_PTR) Write_Event_Object);
            delete Write_Event_Object;
        }

        if (Read_Event_Object != NULL)
        {
            Read_Event_Object -> delete_event = TRUE;
            ::SetEvent(m_hevtPendingRead);
        }

        // let the worker thread to pick up the work
        ::Sleep(50);
    }

    return COMPORT_NO_ERROR;
}


/*
 *    ComPortError    ComPort::Reset (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function clears the DTR signal on the Com port.
 */
ComPortError ComPort::Reset(void)
{
    return COMPORT_NO_ERROR;
}


/*
 *    ComPortError    ComPort::ReleaseReset (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function releases the previous reset.  It set the DTR signal on
 *        the com port.
 */
ComPortError ComPort::ReleaseReset(void)
{
    return COMPORT_NO_ERROR;
}


/*
 *    ULONG    ComPort::GetBaudRate (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the baud rate of the port
 */


/*
 *    ProtocolLayerError    ComPort::DataRequest (
 *                                    ULONG,
 *                                    LPBYTE    buffer_address,
 *                                    ULONG    length,
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to send data out the port in an asynchronous
 *        manner.  In other words, we will return from the function before all
 *        of the bytes are actually written to the modem.
 */
ProtocolLayerError ComPort::DataRequest(ULONG_PTR,
                                LPBYTE        buffer_address,
                                ULONG         length,
                                ULONG        *bytes_accepted)
{
    return WriteData(FALSE, buffer_address, length, bytes_accepted);
}

/*
 *    ProtocolLayerError    ComPort::SynchronousDataRequest (
 *                                    LPBYTE        buffer_address,
 *                                    ULONG        length,
 *                                    PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to send data out the port in a synchronous
 *        manner.  In other words, we will not return from the function until
 *        all of the bytes are actually written to the modem or a timeout occurs.
 */
ProtocolLayerError ComPort::SynchronousDataRequest(
                                LPBYTE        buffer_address,
                                ULONG         length,
                                ULONG        *bytes_accepted)
{
    return WriteData(TRUE, buffer_address, length, bytes_accepted);
}


/*
 *    ProtocolLayerError    ComPort::WriteData (
 *                                    BOOL    synchronous,
 *                                    LPBYTE        buffer_address,
 *                                    ULONG        length,
 *                                    PULong        bytes_accepted)
 *
 *    Functional Description
 *        This function makes the Win32 calls to write data to the port.
 *
 *    Formal Parameters
 *        synchronous        -    (i)    TRUE, if we should wait for the write to
 *                                complete before returning.
 *        buffer_address    -    (i)    Address of the data to write.
 *        length            -    (i)    Length of the data to write.
 *        bytes_accepted    -    (i)    Actually number of bytes written.
 *
 *    Return Value
 *        PROTOCOL_LAYER_ERROR    -    Port not open
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *
 *    Side Effects
 *        None.
 *
 *    Caveats
 *        None
 */
ProtocolLayerError ComPort::WriteData
(
    BOOL            synchronous,
    LPBYTE          buffer_address,
    ULONG           length,
    PULong          bytes_accepted
)
{
    COMSTAT         com_status;
    ULONG           com_error;

    ULONG           byte_count;
    ULONG           bytes_written;
    BOOL            fRet;

    *bytes_accepted = 0;
    if (m_hCommLink == INVALID_HANDLE_VALUE)
    {
        return (PROTOCOL_LAYER_ERROR);
    }

    if (Write_Active)
    {
        return (PROTOCOL_LAYER_NO_ERROR);
    }

     /*
     **    Determine the amount of space left in the buffer
     */
    ::ZeroMemory(&com_status, sizeof(com_status));
    ::ClearCommError(m_hCommLink, &com_error, &com_status);

    if (length > (Tx_Buffer_Size - com_status.cbOutQue))
    {
        byte_count = Tx_Buffer_Size - com_status.cbOutQue;
    }
    else
    {
        byte_count = length;
    }

    ::ZeroMemory(&m_WriteOverlapped, sizeof(m_WriteOverlapped));
    m_WriteOverlapped.hEvent = m_hevtPendingWrite;
    fRet = ::WriteFile(m_hCommLink, buffer_address, byte_count, &bytes_written, &m_WriteOverlapped);

     /*
     **    If this is a synchronous write, wait for the event object to be
     **    set before returning.
     */
    if (synchronous)
    {
        ::WaitForSingleObject(m_hevtPendingWrite, SYNCHRONOUS_WRITE_TIMEOUT);
        fRet = ::GetOverlappedResult(m_hCommLink, &m_WriteOverlapped, &bytes_written, FALSE);
        if (! fRet)
        {
            WARNING_OUT(("ComPort::WriteData: purge comm"));
            ::PurgeComm(m_hCommLink, PURGE_TXABORT);
        }
        ::ResetEvent(m_WriteOverlapped.hEvent);
    }

    if (! fRet)
    {
        if (::GetLastError () == ERROR_IO_PENDING)
        {
            Write_Active = TRUE;
            *bytes_accepted = byte_count;
            Byte_Count += byte_count;
        }
        else
        {
            TRACE_OUT(("ComPort: DataRequest: Error on WriteFile = %d", ::GetLastError()));
        }
    }
    else
    {
        if (bytes_written != byte_count)
        {
            TRACE_OUT(("ComPort: DataRequest: Error on WriteFile  bytes written != bytes requested"));
        }
        *bytes_accepted = byte_count;

         /*
         **    Increment Byte_Count
         */
        Byte_Count += bytes_written;
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::RegisterHigherLayer (
 *                                    ULONG,
 *                                    PMemoryManager,
 *                                    IProtocolLayer *    higher_layer)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by an object that wants to receive the data
 *        read from the com port.
 */
ProtocolLayerError ComPort::RegisterHigherLayer(ULONG_PTR, PMemoryManager,
                                IProtocolLayer *pMux)
{
    m_pMultiplexer = pMux;
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::RemoveHigherLayer (
 *                                    USHORT)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by an object that no longer wants to receive
 *        the data from the com port.
 */
ProtocolLayerError ComPort::RemoveHigherLayer(ULONG_PTR)
{
    m_pMultiplexer = NULL;
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::PollReceiver (
 *                                    ULONG)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to take the data that we have received from
 *        the port and pass it on up to the registered layer.
 */
ProtocolLayerError ComPort::PollReceiver(void)
{
    BOOL    issue_read = FALSE;
    ULONG   bytes_accepted;
    BOOL    fRet;

    if (m_pMultiplexer == NULL || m_hCommLink == INVALID_HANDLE_VALUE)
    {
        return (PROTOCOL_LAYER_ERROR);
    }

     /*
     **    This event can occur if we have completed a read but the higher layers
     **    have not accepted all of the data.  So, before we issue another
     **    ReadFile() we are going to send the pending data on up.
     */
    if (! Read_Active)
    {
        if (m_cbRead)
        {
            m_pMultiplexer->DataIndication(m_pbReadBuffer, m_cbRead - m_nReadBufferOffset, &bytes_accepted);
            if (bytes_accepted > (m_cbRead - m_nReadBufferOffset))
            {
                ERROR_OUT(("ComPort:  PollReceiver1: ERROR: Higher layer accepted too many bytes"));
            }

            m_nReadBufferOffset += bytes_accepted;
            if (m_nReadBufferOffset == m_cbRead)
            {
                issue_read = TRUE;
                m_cbRead = 0;
                m_nReadBufferOffset = 0;
            }
        }
        else
        {
            issue_read = TRUE;
        }
    }

     /*
     **    Issue a ReadFile () and process any data received.
     */
    while (issue_read)
    {
        m_cbRead = 0;
        m_nReadBufferOffset = 0;
        ::ZeroMemory(&m_ReadOverlapped, sizeof(m_ReadOverlapped));
        m_ReadOverlapped.hEvent = m_hevtPendingRead;
        fRet = ::ReadFile(m_hCommLink, m_pbReadBuffer, m_cbReadBufferSize, &m_cbRead, &m_ReadOverlapped);
        if (! fRet)
        {
            if (::GetLastError() == ERROR_IO_PENDING)
            {
                Read_Active = TRUE;
            }
            else
            {
                WARNING_OUT(("ComPort: Error on ReadFile = %d", ::GetLastError()));
                if (Count_Errors_On_ReadFile++ == DEFAULT_COUNT_OF_READ_ERRORS)
                {
                    WARNING_OUT(("ComPort: %d Errors on ReadFile, closing the connection", Count_Errors_On_ReadFile));
                    Close();
                    return (PROTOCOL_LAYER_ERROR);
                }
            }
            issue_read = FALSE;
        }
        else
        {
            if (m_pMultiplexer != NULL)
            {
                m_pMultiplexer->DataIndication(m_pbReadBuffer, m_cbRead, &bytes_accepted);
                if (bytes_accepted > m_cbRead)
                {
                    ERROR_OUT(("ComPort:  PollReceiver: ERROR: Higher layer accepted too many bytes"));
                }
                m_nReadBufferOffset += bytes_accepted;
                if (m_nReadBufferOffset != m_cbRead)
                {
                    issue_read = FALSE;
                }
            }
            else
            {
                issue_read = FALSE;
            }
        }
    }
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::GetParameters (
 *                                    ULONG,
 *                                    USHORT *    max_packet_size,
 *                                    USHORT *    prepend,
 *                                    USHORT *    append)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by an object to determine the maximum packet
 *        size that this object expects.  It also queries the number of bytes
 *        it should skip on the front of a packet and append to the end of a
 *        packet.  The ComPort object is a stream device, so these parameters
 *        don't really matter.
 */
ProtocolLayerError ComPort::GetParameters
(
    USHORT *    max_packet_size,
    USHORT *    prepend,
    USHORT *    append
)
{
     /*
     **    max_packet_size set to 0xffff means that this object receives
     **    data in a stream format rather than a packet format.  It does
     **    group data into packets, it handles data a byte at a time.
     **    Therefore, when a higher layer issues a DataRequest() to this
     **    object, it may not accept the whole data block, it may only
     **    accept part of it.
     **
     **    prepend is set to 0 because this object does not prepend any
     **    data to the beginning of a DataRequest() packet.
     **
     **    append is set to 0 because this object does not append any
     **    data to the end of a DataRequest() packet.
     */
    *max_packet_size = 0xffff;
    *prepend = 0;
    *append = 0;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    void    ComPort::ReportInitializationFailure (
 *                        PChar    error_message)
 *
 *    Functional Description
 *        This routine simply reports an error to the user and closes the
 *        Windows comm port.  It does absolutely nothing if the Physical
 *        API is disabled.
 *
 *    Formal Parameters
 *        error_message    (i)    -    Pointer to error message
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None.
 *
 *    Caveats
 *        None
 */
void ComPort::ReportInitializationFailure(ComPortError rc)
{
    ERROR_OUT(("ComPort:: IO failure, rc=%d", rc));
}


/*
 *    BOOL    ComPort::ProcessReadEvent (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called when a READ event is actually set.  This means
 *        that the read operation has completed or an error occured.
 */
BOOL ComPort::ProcessReadEvent(void)
{
    BOOL fRet;

    if (Read_Active)
    {
        if (WAIT_OBJECT_0 == ::WaitForSingleObject(m_hevtPendingRead, 0))
        {
            fRet = GetOverlappedResult(m_hCommLink, &m_ReadOverlapped, &m_cbRead, FALSE);
            if (fRet && m_cbRead == 0)
            {
                fRet = FALSE;
            }

            Read_Active = FALSE;
            ::ResetEvent(m_hevtPendingRead);
        }
    }
    else
    {
        ::ResetEvent(m_hevtPendingRead);
    }

    return fRet;
}


/*
 *    BOOL    ComPort::ProcessWriteEvent (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called when a WRITE event is actually set.  This means
 *        that the write operation has completed or an error occured.
 */
BOOL ComPort::ProcessWriteEvent(void)
{
    ULONG  bytes_written;
    BOOL   fRet = FALSE;

    if (Write_Active)
    {
        if (WAIT_OBJECT_0 == ::WaitForSingleObject(m_hevtPendingWrite, 0))
        {
            fRet = ::GetOverlappedResult(m_hCommLink, &m_WriteOverlapped, &bytes_written, FALSE);
            if (! fRet)
            {
                DWORD dwErr = ::GetLastError();
                if (ERROR_IO_PENDING == dwErr)
                {
                    TRACE_OUT(("ProcessWriteEvent: still pending"));
                }
                else
                {
                    WARNING_OUT(("ProcessWriteEvent: ERROR = %d", dwErr));
                }
            }
            Write_Active = FALSE;
            ::ResetEvent(m_hevtPendingWrite);
        }
    }
    else
    {
        ::ResetEvent(m_hevtPendingWrite);
    }

    return fRet;
}


/*
 *    ProtocolLayerError    ComPort::DataIndication (
 *                                    LPBYTE,
 *                                    ULONG,
 *                                    PULong)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is not used.  It is only here because we inherit from
 *        ProtocolLayer.
 */
ProtocolLayerError ComPort::DataIndication(LPBYTE, ULONG, PULong)
{
    return (PROTOCOL_LAYER_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::DataRequest (
 *                                    ULONG,
 *                                    PMemory,
 *                                    PULong)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is not used.  It is only here because we inherit from
 *        ProtocolLayer.
 */
ProtocolLayerError ComPort::DataRequest(ULONG_PTR, PMemory, PULong)
{
    return (PROTOCOL_LAYER_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::PollTransmitter (
 *                                    ULONG,
 *                                    USHORT,
 *                                    USHORT *,
 *                                    USHORT *)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is not used.  It is only here because we inherit from
 *        ProtocolLayer.
 */
ProtocolLayerError ComPort::PollTransmitter(ULONG_PTR, USHORT, USHORT *, USHORT *)
{
    return (PROTOCOL_LAYER_ERROR);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\tptif.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);
/*
 *	tptif.cpp
 *
 *	Copyright (c) 1996-1997 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the implementation module for the TCP TransportInterface class.
 *		It implements the Win32 TCP transport stack.
 *		This file contains all of the public functions needed to use
 *		the TCP stack.
 *
 *		It uses owner callbacks to forward transport events upward to interested
 *		parties.  It has one default callback to handle
 *		events for unregistered transport connections (such as incoming connect
 *		indications).  It also maintains an array of callbacks so that events
 *		for a particular transport connection can be routed appropriately.
 *
 *		X.214 INTERFACE
 *	
 *		You will notice that many of the entry points to this DLL were taken
 *		from the X.214 service definition.  These entry points are consistent
 *		with the DataBeam Transport DLLs.  This gives the user application
 *		a consistent interface.
 *
 *  Protected Instance Variables:
 *		m_TrnsprtConnCallbackList2
 *			This is the dictionary containg the addresses of the callbacks for
 *			each transport connection.
 *
 *	Private Member Functions:
 *		CreateConnectionCallback
 *			This function creates a new entry in the callback list.
 *		ConnectIndication
 *			Handles TRANSPORT_CONNECT_INDICATION messages from the transport
 *			layer.
 *		ConnectConfirm
 *			Handles TRANSPORT_CONNECT_CONFIRM messages from the transport
 *			layer.
 *		DisconnectIndication
 *			Handles TRANSPORT_DISCONNECT_INDICATION messages from the transport
 *			layer.
 *		DataIndication
 *			Handles TRANSPORT_DATA_INDICATION messages from the transport
 *			layer.
 *
 *	Global Variables:
 *
 *	Transport					- Address of this object (used by tprtctrl.cpp)
 *	g_pSocketList    			- List of all active connection structures.
 *	Listen_Socket				- The listening socket number.
 *
 *	Caveats:
 *		This code is NOT portable.  It is very specific to the Windows
 *		operating system.
 *
 *	Author:
 *		Christos Tsollis
 */

/*
 *	External Interfaces
 */

#include <nmqos.h>
#include <t120qos.h>
#include <tprtntfy.h>
#include "plgxprt.h"

/* This is the number of the buckets for the socket dictionary */
#define NUMBER_OF_SOCKET_BUCKETS                8

PTransportInterface	g_Transport = NULL;
CSocketList        *g_pSocketList = NULL;   // key=socket_number, data=pSocket
SOCKET				Listen_Socket = INVALID_SOCKET;

CRITICAL_SECTION	csQOS;

// The external MCS Controller object
extern PController	g_pMCSController;
extern CPluggableTransport *g_pPluggableTransport;

/*
 *	TransportInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the class constructor.
 *
 *		Note that this version of the constructor is specific to 32-bit
 *		Windows.
 */
TransportInterface::TransportInterface (
		HANDLE						transport_transmit_event,
		PTransportInterfaceError	transport_interface_error) :
		Transport_Transmit_Event (transport_transmit_event),
		m_TrnsprtConnCallbackList2()
{
		TransportInterfaceError		tcp_error = TRANSPORT_INTERFACE_NO_ERROR;
		//WORD 						version_requested;
		//int							error;
		WSADATA						wsa_data;
		RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER);

	TRACE_OUT(("TCP Initialization..."));

	// Initialize QoS.
	InitializeCriticalSection(&csQOS);
	
    ASSERT(NULL == g_pSocketList);
	DBG_SAVE_FILE_LINE
	g_pSocketList = new CSocketList(NUMBER_OF_SOCKET_BUCKETS);
	if (g_pSocketList == NULL)
	{
		WARNING_OUT (("TransportInterface::TransportInterface:  Unable to allocate socket dictionary."));
		tcp_error = TRANSPORT_INTERFACE_INITIALIZATION_FAILED;
	}

	if (tcp_error == TRANSPORT_INTERFACE_NO_ERROR) {		
		/* WSAStartup() must be called to initialize WinSock */
		WORD version_requested = MAKEWORD (1,1);
		int error = WSAStartup (version_requested, &wsa_data);
		ASSERT(error == 0);
		if (error) {
			WARNING_OUT (("ThreadFunction: WSAStartup returned error %d", error));
			tcp_error = TRANSPORT_INTERFACE_INITIALIZATION_FAILED;
		}
		else {
			/* Print out the developer of this version of WinSock */
			TRACE_OUT (("TransportInterface::TransportInterface: WinSock implementation by %s", &wsa_data.szDescription));
		}
	}

	bInServiceContext = !!::FindAtomA("NMSRV_ATOM");

	if ( bInServiceContext ||
        (re.GetNumber(REGVAL_POL_SECURITY, DEFAULT_POL_SECURITY) != DISABLED_POL_SECURITY))
	{
		DBG_SAVE_FILE_LINE
		pSecurityInterface = new SecurityInterface(bInServiceContext);

		if ( TPRTSEC_NOERROR != pSecurityInterface->Initialize())
		{
			WARNING_OUT(("Creating security interface failed!"));
			delete pSecurityInterface;
			pSecurityInterface = NULL;
		}
	}
	else
		pSecurityInterface = NULL;

	/* Initialize the listen socket. This socket will wait for incoming calls */
	if (tcp_error == TRANSPORT_INTERFACE_NO_ERROR) {

		// Listen on standard socket
		Listen_Socket = CreateAndConfigureListenSocket();

		if ( INVALID_SOCKET == Listen_Socket ) {
			ERROR_OUT(("TransportInterface::TransportInterface: Error - could not initialize listen socket"));
			tcp_error = TRANSPORT_INTERFACE_INITIALIZATION_FAILED;
		}
	}

	*transport_interface_error = tcp_error;
}


void CloseListenSocket(void)
{
	if (Listen_Socket != INVALID_SOCKET)
    {
        TransportConnection XprtConn;
        SET_SOCKET_CONNECTION(XprtConn, Listen_Socket);
		::freeListenSocket(XprtConn);
		Listen_Socket = INVALID_SOCKET;
	}
}


/*
 *	~TransportInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the class destructor.  It unloads the DLL (if necessary).
 */
TransportInterface::~TransportInterface ()
{
    PSocket                     pSocket;

	TRACE_OUT (("Cleaning up the TCP transport..."));

	/* Delete all of the Logical Connection Structures */
    if (g_pSocketList != NULL)
	{
        ::EnterCriticalSection(&g_csTransport);
        CSocketList     Connection_List_Copy (*g_pSocketList);
        ::LeaveCriticalSection(&g_csTransport);

		while (NULL != (pSocket = Connection_List_Copy.Get()))
		{
		    // LONCHANC: cannot remove pSocket out of the list now
		    // because DisconnectRequest() uses it.

			/* Disconnect, trash packets, and delete the first connection in the list */
			::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_NONE);
		}

        ::EnterCriticalSection(&g_csTransport);
		delete g_pSocketList;
        g_pSocketList = NULL;
        ::LeaveCriticalSection(&g_csTransport);
	}

	/* Close the listening socket */
    ::CloseListenSocket();

	delete pSecurityInterface;

	/* Force Winsock to cleanup immediately */
	WSACleanup();
	
	// Clean up QoS
	DeleteCriticalSection(&csQOS);

	TRACE_OUT (("TCP Transport has been cleaned up."));
	
}

/*
 *	TransportInterfaceError 	RegisterTransportConnection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is used to register a callback for a particular
 *		transport connection.  This will usually be done for incoming
 *		connections, when you know the transport connection handle BEFORE
 *		registering the callback.
 */
TransportInterfaceError TransportInterface::RegisterTransportConnection (
								TransportConnection		XprtConn,
								PConnection				owner_object,
								BOOL					bNoNagle)
{
	TransportInterfaceError 	return_value;

	/*
	 *	Check to see if the transport connection in question exists.  If
	 *	it does, then remove it and add it again with the new owner.
	 *	If not, fail the call.
	 */
	if (m_TrnsprtConnCallbackList2.RemoveEx(XprtConn))
	{
		/*
		 *	Get the address of the associated connection callback structure.
		 *	Then put the new callback information into it.
		 */
		TRACE_OUT (("TransportInterface::RegisterTransportConnection: "
				"registering new owner"));

        m_TrnsprtConnCallbackList2.AppendEx(owner_object ? owner_object : (PConnection) LPVOID_NULL, XprtConn);

        if (IS_SOCKET(XprtConn))
        {
    		if (bNoNagle)
    		{
    			// We need to disable the Nagle algorithm
    			TRACE_OUT(("TransportInterface::RegisterTransportConnection: disabling Nagle for socket (%d, %d)", 
    						XprtConn.eType, XprtConn.nLogicalHandle));
    			::setsockopt(XprtConn.nLogicalHandle, IPPROTO_TCP, TCP_NODELAY,
    						(const char *) &bNoNagle, sizeof(BOOL));
    		}
		}
		return_value = TRANSPORT_INTERFACE_NO_ERROR;
	}
	else
	{
		/*
		 *	There is no entry in the callback list for the specified transport
		 *	connection.  Since this function is only used to replace callback
		 *	information for existing connections, it is necessary to fail the
		 *	request.
		 */
		WARNING_OUT (("TransportInterface::RegisterTransportConnection: "
				"no such connection"));
		return_value = TRANSPORT_INTERFACE_NO_SUCH_CONNECTION;
	}

	return (return_value);
}

#ifdef NM_RESET_DEVICE
/*
 *	TransportError 	ResetDevice ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function merely makes the call to the transport DLL if the
 *		library was successfully loaded.
 */
TransportError 	TransportInterface::ResetDevice (
						PChar			device_identifier)
{
	PSocket pSocket;
	PChar 	Remote_Address;

    ::EnterCriticalSection(&g_csTransport);
    CSocketList     Connection_List_Copy (*g_pSocketList);
    ::LeaveCriticalSection(&g_csTransport);

	while (NULL != (pSocket = Connection_List_Copy.Get()))
	{
		Remote_Address = pSocket->Remote_Address;
		if(Remote_Address && (strcmp(Remote_Address, device_identifier) == 0))
		{
			::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
			break;
		}
	}

	return (TRANSPORT_NO_ERROR);
}
#endif // NM_RESET_DEVICE

/*
 *	TransportError 	ConnectRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		After checking to make sure that the library was loaded properly, this
 *		routine takes the steps required to create a new transport connection.
 */
TransportError 	TransportInterface::ConnectRequest (
					TransportAddress		transport_address,
					BOOL					fSecure,
					BOOL					bNoNagle,
					PConnection				owner_object,
					PTransportConnection	pXprtConn)
{
	TransportError 			return_value;
	TransportInterfaceError	transport_interface_error;

	TRACE_OUT (("TransportInterface::ConnectRequest"));
	/*
	 *	Issue a call to the Transport's ConnectRequest API routine.  Note that
	 *	this MUST be done first since one of the return values is the
	 *	transport connection handle of the newly created connection.
	 *	Also note that this is a non-blocking call, so what we have done
	 *	is begun the process of forming a connection.  The connection
	 *	cannot be used until a connect confirm is received.
	 */
	return_value = ::ConnectRequest(transport_address, fSecure, pXprtConn);
			
	if (return_value == TRANSPORT_NO_ERROR) {
		/*
		 *	If the call to create the connection was successful, then
		 *	put a new entry into the callback list.  This entry will
		 *	contain the callback information provided as parameters to
		 *	this routine.
		 */
		transport_interface_error = CreateConnectionCallback (
					*pXprtConn, owner_object);
        if (IS_SOCKET(*pXprtConn))
        {
    		if (bNoNagle)
    		{
    			// We need to disable the Nagle algorithm
    			TRACE_OUT(("TransportInterface::ConnectRequest: disabling Nagle for socket (%d, %d)", 
    						pXprtConn->eType, pXprtConn->nLogicalHandle));
    			::setsockopt(pXprtConn->nLogicalHandle, IPPROTO_TCP, TCP_NODELAY,
    						(const char *) &bNoNagle, sizeof(BOOL));
    		}

#ifdef DEBUG
		    if (TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS == 
			    transport_interface_error) {
			    /*
			     *	The transport connection handle returned from the
			     *	transport layer is the same as one we already have
			     *	listed.  We will therefore terminate the existing
			     *	connection (since its integrity appears to have been
			     *	compromised).  We will also fail this request.
			     */
			    WARNING_OUT (("DLLTransportInterface::ConnectRequest: "
						    "ERROR - duplicate connections"));

			    // This should NOT be happenning!!!
			    ASSERT (FALSE);

		    }
		    else {
			    /*
			     *	Everything worked fine, so do nothing.
			     */
			    TRACE_OUT (("DLLTransportInterface::ConnectRequest: "
						    "callback added to list"));
		    }
#endif // DEBUG
		}
	}
	else
	{
		/*
		 *	The call to TConnectRequest failed.  Report it and let the
		 *	error fall through.
		 */
		WARNING_OUT (("DLLTransportInterface::ConnectRequest: "
					"TConnectRequest failed"));
	}

	return (return_value);
}

/*
 *	void DisconnectRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is called to break an existing transport
 *		connection.  After checking to make sure that the transport connection
 *		is valid, it passes the call onto the DLL and removes the transport
 *		connection from the local callback list.
 */
void TransportInterface::DisconnectRequest (TransportConnection	transport_connection)
{
	TRACE_OUT (("TransportInterface::DisconnectRequest"));

	if (m_TrnsprtConnCallbackList2.RemoveEx(transport_connection))
    {
		::DisconnectRequest (transport_connection, TPRT_NOTIFY_NONE);
	}
	else
    {
		TRACE_OUT (("DLLTransportInterface::DisconnectRequest: the specified connection can not be found"));
	}
}

/*
 *	BOOL GetSecurity ()
 *
 *	Public
 *
 *	Functional Description:
 */
BOOL TransportInterface::GetSecurity (TransportConnection XprtConn)
{
	PSocket			pSocket;

	if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
	{
	    BOOL fRet = (pSocket->pSC != NULL);
	    pSocket->Release();
	    return fRet;
	}
	ERROR_OUT(("GetSecurity: could not find socket"));
	return FALSE; // Err on the safe side
}

/*
 *	Void ReceiveBufferAvailable ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void TransportInterface::ReceiveBufferAvailable ()
{		
	TRACE_OUT(("TransportInterface::ReceiveBufferAvailable"));

	// Reset the controller's wait info
	g_pMCSController->HandleTransportWaitUpdateIndication(FALSE);

    TReceiveBufferAvailable();

	// Poll all the transport connections
	EnableReceiver ();
}



/*
 *	Void	ConnectIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a connect indication from the
 *		transport layer.  Normally this involves putting a new entry in the
 *		callback list, and forwarding the connect indication to the default
 *		owner object.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the new connection.  This includes: the logical handle of the new
 *			connection; and the handle of the physical connection which will
 *			carry the new connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::ConnectIndication (
				TransportConnection	transport_connection)
{
	TransportInterfaceError		transport_interface_error;
	PConnection					pConnection;

	/*
	 *	Put the new connection into the callback list.
	 */
	transport_interface_error = CreateConnectionCallback (transport_connection,
														 NULL);

	switch (transport_interface_error)
	{
		case TRANSPORT_INTERFACE_NO_ERROR:
			/*
			 *	Everything worked fine, so do forward the indication to the
			 *	default owner object.
			 */
			TRACE_OUT (("DLLTransportInterface::ConnectIndication: "
					"calling ConnectResponse."));
			::ConnectResponse (transport_connection);
			break;

		case TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS:
			/*
			 *	The transport connection handle sent by the transport layer is
			 *	the same as one we already have listed.  We will therefore
			 *	terminate the existing connection (since its integrity appears
			 *	to have been compromised).
			 */
			WARNING_OUT (("DLLTransportInterface::ConnectIndication: "
					"ERROR - duplicate connections. Connection: %d", transport_connection));
			::DisconnectRequest (transport_connection, TPRT_NOTIFY_NONE);

			/*
			 *	Get the callback information for the previously existing
			 *	connection.  Then delete it.
			 */
			if (NULL != (pConnection = m_TrnsprtConnCallbackList2.RemoveEx(transport_connection)))
            {
                if (LPVOID_NULL != (LPVOID) pConnection)
                {
        			/*
        			 *	Let the former owner of the connection know that it has been
        			 *	terminated.
        			 */
			        ULONG ulReason = TPRT_NOTIFY_NONE;
			        pConnection->HandleDisconnectIndication(transport_connection, &ulReason);
                }
                else
                {
                    ERROR_OUT(("TransportInterface::ConnectIndication: null pConnection"));
                }
            }
			break;
	}
}

/*
 *	Void	ConnectConfirm ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a connect confirm frmo the
 *		transport layer.  Assuming that the connect confirm is the result of
 *		a previously outstanding connect request. everything will be processed
 *		normally, and the confirm will forwarded to the object that originated
 *		the request.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the connection being confirmed.  This includes: the logical handle
 *			of the connection; and the handle of the physical connection which
 *			is carrying the connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::ConnectConfirm (
				TransportConnection	transport_connection)
{
	PConnection			connection;

	/*
	 *	Since a connect confirm should only result from an earlier connect
	 *	request, the transport connection handle SHOULD already be in the
	 *	callback list.  If it is, then process this confirm normally.
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.FindEx(transport_connection)))
	{
		/*
		 *	Get the address of the callback structure from the Connection List.
		 *	Then invoke the callback, passing the message and parameter to it.
		 */
		TRACE_OUT (("DLLTransportInterface::ConnectConfirm: forwarding CONNECT_CONFIRM"));

		if (LPVOID_NULL != (LPVOID) connection)
        {
			// The owner is a Connection object.
			connection->HandleConnectConfirm(transport_connection);
		}
	}
	else
	{
		/*
		 *	This transport connection handle is invalid.  It is therefore
		 *	necessary to terminate the connection, and otherwise ignore the
		 *	confirm.
		 */
		WARNING_OUT (("DLLTransportInterface::ConnectConfirm: "
			"terminating unknown connection %d", transport_connection));
		// ::DisconnectRequest (transport_connection, TPRT_NOTIFY_NONE);
	}
}

/*
 *	Void	DisconnectIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a disconnect indication from the
 *		transport layer.  If the specified transport connection exists, it will
 *		be removed, and the object that owns it will be informed of the loss.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the connection being disconnected.  This includes: the logical
 *			handle of the connection; and the handle of the physical connection
 *			which carried the connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::DisconnectIndication (
				TransportConnection			transport_connection,
				ULONG                       ulReason)
{
	PConnection			connection;

	/*
	 *	It should only be possible to receive a disconnect on a transport
	 *	connection that we already know about.  Therefore, the transport
	 *	connection handle SHOULD already be in the list.  Check this.
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.RemoveEx(transport_connection)))
	{
		/*
		 *	Get the address of the callback structure from the callback list.
		 *	Then delete it from the list.
		 */
		TRACE_OUT (("DLLTransportInterface::DisconnectIndication: "
				"forwarding DISCONNECT_INDICATION"));

        if (LPVOID_NULL != (LPVOID) connection)
        {
			// The owner is a Connection object.
			connection->HandleDisconnectIndication(transport_connection, &ulReason);
		}
		else
        {
			// The owner is the MCS Controller
			g_pMCSController->HandleTransportDisconnectIndication(transport_connection, &ulReason);
		}
	}
	else
	{
		/*
		 *	We have received a disconnect indication on an unknown transport
		 *	connection.  Ignore it.
		 */
		WARNING_OUT (("DLLTransportInterface::DisconnectIndication: "
				"disconnect on unknown connection"));
	}
}

/*
 *	TransportError	DataIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a data indication from the
 *		transport layer.  If the transport connection is properly registered,
 *		the data will be forwarded to the object that owns the connection.
 *
 *	Formal Parameters:
 *		transport_data (i)
 *			This is the address of a structure that contains information about
 *			the data in the indication.  This includes what transport
 *			connection the data was received on, as well as the address and
 *			length of the data itself.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			This indicates that the data was processed.
 *		TRANSPORT_READ_QUEUE_FULL
 *			This means that the transport layer should try resending the data
 *			during the next heartbeat.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
TransportError	TransportInterface::DataIndication (PTransportData transport_data)
{
	PConnection				connection;
	TransportError			return_value = TRANSPORT_NO_ERROR;

	/*
	 *	If the transport connection is in the callback list, then send the
	 *	data to the registered callback.  If it is not in the Connection
	 *	List, then ignore the data (we have nowhere to send it).
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.FindEx(transport_data->transport_connection)))
	{
		if (LPVOID_NULL != (LPVOID) connection)
		{
			// The owner is a Connection object.
			return_value = connection->HandleDataIndication(transport_data, 
										transport_data->transport_connection);
		}
		else
		{
			// The owner is the MCS Controller
			g_pMCSController->HandleTransportDataIndication(transport_data);
		}

		/*
		 *	If we fail to deliver the data indication, we need to set the amount
		 *	of data available to be received and notify the controller to 
		 *	retry the operation later.
		 */		
		if (TRANSPORT_NO_ERROR != return_value)
		{
			g_pMCSController->HandleTransportWaitUpdateIndication(TRUE);
		}
	}
	else
	{
		/*
		 *	We have received data on an unknown transport connection.
		 *	Ignore the indication.
		 */
		WARNING_OUT (("TransportInterface::DataIndication: data on unknown connection"));
		return_value = TRANSPORT_NO_SUCH_CONNECTION;
	}
	
	return (return_value);
}

/*
 *	Void	BufferEmptyIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a buffer-empty indication from the
 *		transport layer.  If the specified transport connection exists, the object
 *		that owns it will be notified that it can proceed sending data on the 
 *		transport connection.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the connection.  This includes: the logical
 *			handle of the connection; and the handle of the physical connection
 *			which carried the connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::BufferEmptyIndication (
				TransportConnection			transport_connection)
{
	PConnection			connection;

	/*
	 *	It should only be possible to receive a disconnect on a transport
	 *	connection that we already know about.  Therefore, the transport
	 *	connection handle SHOULD already be in the list.  Check this.
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.FindEx(transport_connection)))
	{
		/*
		 *	Get the address of the callback structure from the callback list.
		 *	Then delete it from the list.
		 */
		TRACE_OUT(("DLLTransportInterface::BufferEmptyIndication: "
				"forwarding BUFFER_EMPTY_INDICATION"));
		
		/*
		 *	Forward the disconnect indication to the owner of this transport
		 *	connection.
		 */
		if (LPVOID_NULL != (LPVOID) connection)
        {
			connection->HandleBufferEmptyIndication(transport_connection);
        }
	}
	else
	{
		/*
		 *	We have received a buffer empty indication on an unknown transport
		 *	connection.  Ignore it.
		 */
		TRACE_OUT (("TransportInterface::BufferEmptyIndication: "
				"indication on unknown connection"));
	}
}

/*
 *	TransportInterfaceError 	CreateConnectionCallback ()
 *
 *	Protected
 *
 *	Functional Description:
 *		This private member function is used to create new entries in the
 *		callback list.  Each entry consists of a pointer to a structure that
 *		contains the address of the object that "owns" the transport connection,
 *		as well as the message index to be used for the owner callbacks.
 *
 *		This routine allocates the memory used to hold the callback information,
 *		and puts it in the callback list if everything is successful.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection for which the callback information
 *			is to be associated.
 *		owner_object (i)
 *			This is the address of the object that is to receive all transport
 *			layer events for the specified transport connection.
 *
 *	Return Value:
 *		TRANSPORT_INTERFACE_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS
 *			This value indicates that the request was unsuccessful because the
 *			specified transport connection already exists in the callback list
 *			(it is an error to try and create an entry for the same transport
 *			connection more than once).
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
TransportInterfaceError TransportInterface::CreateConnectionCallback (
								TransportConnection		transport_connection,
								PConnection				owner_object)
{
	TransportInterfaceError 	return_value;

	/*
	 *	See if there is already an entry in the callback list for the specified
	 *	transport connection.  If there is, then abort this request before
	 *	doing anything.
	 */
	if (m_TrnsprtConnCallbackList2.FindEx(transport_connection) == FALSE)
	{
		/*
		 *	Put the callback information into the newly allocated
		 *	structure.  Then put the structure into the callback list.
		 */
		TRACE_OUT (("TransportInterface::CreateConnectionCallback: "
					"adding new callback object"));

        m_TrnsprtConnCallbackList2.AppendEx(owner_object ? owner_object : (PConnection) LPVOID_NULL, transport_connection);

		return_value = TRANSPORT_INTERFACE_NO_ERROR;
	}
	else
	{
		/*
		 *	There is already an entry in the callback list for the specified
		 *	transport connection.  It is therefore necessary to fail this
		 *	request.
		 */
		WARNING_OUT (("TransportInterface::CreateConnectionCallback: "
				"callback already exists"));
		return_value = TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS;
	}

	return (return_value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\user.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	user.cpp
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the User class.  Objects of this
 *		class represent the attachment between a user application and an MCS
 *		domain.  It "talks" to the application through an application interface
 *		object, which is identified to it as a constructor parameter.  Since
 *		this class inherits from CommandTarget, it can talk to the domain
 *		object using the MCS command language defined therein.  The domain
 *		object to which it must attach is another constructor parameter.
 *
 *		When one of these objects is first created, it must register its
 *		presence with both the application interface object above it, and the
 *		domain object below it.  To register with the application interface
 *		object it sends it a registration message through the owner callback.
 *		To register with the domain object, it issues an attach user request
 *		on behalf of the application that created this attachment.
 *
 *		This module contains code to perform three different tasks: accept
 *		T.122 requests and responses from the user application and forward them
 *		to the domain as MCS commands; accept MCS commands from the domain and
 *		forward them to the application as T.122 primitives; and buffer those
 *		indications and confirms until the controller allocates a time slice in
 *		which to send them.
 *
 *		T.122 requests and responses come from the application interface as
 *		public member functions whose name is prefixed with "MCS" (for example,
 *		"MCSChannelJoinRequest").  After validation, the equivalent MCS command
 *		(whose name does NOT begin with "MCS") is sent to the domain object.
 *
 *		MCS commands come from the domain object as public member functions that
 *		are inherited from CommandTarget and overridden by this class.  The
 *		names of these functions are NOT prefixed with "MCS".  Any MCS commands
 *		that do not map to (or can be converted to) T.122 primitives are simply
 *		not overridden.  The default behavior of these functions ,as defined in
 *		the CommandTarget class, is to return an error.
 *
 *		Indication and confirm primitives are buffered by objects of this class
 *		before being sent to the application.  This allows the controller more
 *		flexibility in the timing of events in the system.  This is done by
 *		allocating a structure to hold the information associated with the
 *		primitive, and then putting a pointer to that structure into a linked
 *		list.  When the command comes to flush this message queue, the
 *		primitives are sent to the application interface object through the
 *		owner callback, and the structures are released.
 *
 *	Private Instance Variables:
 *		m_pDomain
 *			This is a pointer to the domain, to which this user is (or wishes
 *			to be) attached.
 *		User_ID
 *			This is the user ID assigned to this user attachment.  This is
 *			guaranteed to be unique ONLY within this domain.  Note that a value
 *			of 0 (zero) indicates that this user is not yet attached to the
 *			domain.  This is set by a successful attach user confirm, and the
 *			user application should wait until that confirm is received before
 *			trying to invoke any other MCS services.
 *		Merge_In_Progress
 *			This is a boolean flag that indicates whether or not the attached
 *			Domain object is in the merge state.  When in the merge state it
 *			is invalid to send it any MCS commands.
 *		Deletion_Pending
 *			This is a boolean flag that indicates whether or not an internally
 *			requested deletion is pending.  This is used by the destructor to
 *			determine if a deletion was requested by the object itself, or is
 *			simply an asynchronous event.
 *		Maximum_User_Data_Length
 *			This is the maximum amount of user data that can be placed into
 *			a single MCS PDU.  This number is derived from the arbitrated
 *			maximum MCS PDU size (minus enough space for overhead bytes).
 *
 *	Private Member Functions:
 *		ValidateUserRequest
 *			This member function is called each time the user application makes
 *			a request.  It checks the current state of the system to see if
 *			conditions are such that the request can be processed at the
 *			current time.
 *		PurgeMessageQueue
 *			This member function walks through the current message queue,
 *			freeing all resources held therein.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

 #include "omcscode.h"

#define USER_MSG_BASE       WM_APP

/*
 *	bugbug:
 *	The following constant is only used to cover a bug in NM 2.0 for backward
 *	compatibility purposes.  NM 2.0 can not accept MCS data PDUs with more than
 *	4096 bytes of user data.  Because of the Max MCS PDU size we negotiate (4128),
 *	even in NM 2.0, we should have been able to send 4120 bytes.  But NM 2.0 chokes
 *	in this case.
 *	The constant should eliminated after NM 3.0.
 */
#define		BER_PROTOCOL_EXTRA_OVERHEAD		24

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CMCSCoder				*g_MCSCoder;
// The external MCS Controller object
extern PController				g_pMCSController;
// The global MCS Critical Section
extern CRITICAL_SECTION 		g_MCS_Critical_Section;
// The DLL's HINSTANCE
extern HINSTANCE 				g_hDllInst;
// Class name for windows used by MCS attachments.
static char						s_WindowClassName[CLASS_NAME_LENGTH];


// Initialization of the class's static variables.
CTimerUserList2* User::s_pTimerUserList2 = NULL;
HINSTANCE		 User::s_hInstance = NULL;

/*
 *	BOOL		InitializeClass ()
 *
 *	Public, static
 *
 *	Functional Description
 *
 *	This function initializes the class's static variables.  It is
 *	called during the MCS Controller's construction.
 */
BOOL User::InitializeClass (void)
{
		BOOL		bReturnValue;
		WNDCLASS	window_class;

	DBG_SAVE_FILE_LINE
	s_pTimerUserList2 = new CTimerUserList2();
	bReturnValue = (s_pTimerUserList2 != NULL);

	if (bReturnValue) {
		//	Construct the window class name
		wsprintf (s_WindowClassName, "MCS Window %x %x", GetCurrentProcessId(), GetTickCount());

		/*
		 *	Fill out a window class structure in preparation for registering
		 *	the window with Windows.  Note that since this is a hidden
		 *	window, most of the fields can be set to NULL or 0.
		 */
		ZeroMemory (&window_class, sizeof(WNDCLASS));
		window_class.lpfnWndProc	= (WNDPROC) UserWindowProc;
		window_class.hInstance		= s_hInstance = g_hDllInst;
		window_class.lpszClassName	= s_WindowClassName;

		/*
		 *	Register the class with Windows so that we can create a window
		 *	for use by this portal.
		 */
		if (RegisterClass (&window_class) == 0)
		{
			ERROR_OUT (("InitWindowPortals: window class registration failed. Error: %d", GetLastError()));
			bReturnValue = FALSE;
		}
	}
	else {
		ERROR_OUT(("User::InitializeClass: Failed to allocate timer dictionary."));
	}

	return bReturnValue;
}


/*
 *	void		CleanupClass ()
 *
 *	Public, static
 *
 *	Functional Description
 *
 *	This function cleans up the class's static variables.  It is
 *	called when the MCS Controller is deleted.
 */
void User::CleanupClass (void)
{
	delete s_pTimerUserList2;
	UnregisterClass (s_WindowClassName, s_hInstance);
}

/*
 *	MCSError	MCS_AttachRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This API entry point is used to attach to an existing domain.  Once
 *		attached, a user application can utilize the services of MCS.  When
 *		a user application is through with MCS, it should detach from the domain
 *		by calling MCSDetachUserRequest (see below).
 */
MCSError WINAPI MCS_AttachRequest (IMCSSap **			ppIMCSSap,
							DomainSelector		domain_selector,
							UINT,                                   // domain_selector_length
							MCSCallBack			user_callback,
							PVoid				user_defined,
							UINT				flags)
{
	MCSError				return_value = MCS_NO_ERROR;
	AttachRequestInfo		attach_request_info;
	PUser					pUser;

	TRACE_OUT(("AttachUserRequest: beginning attachment process"));
	ASSERT (user_callback);

	// Initialize the interface ptr.
	*ppIMCSSap = NULL;
	
	/*
	 *	Pack the attach parameters into a structure since they will not fit
	 *	into the one parameter we have available in the owner callback.
	 */
	attach_request_info.domain_selector = (GCCConfID *) domain_selector;
	attach_request_info.ppuser = &pUser;

	/*
	 *	Enter the critical section which protects global data.
	 */
	EnterCriticalSection (& g_MCS_Critical_Section);

	if (g_pMCSController != NULL) {

		/*
		 *	Send an attach user request message to the controller through its
		 *	owner callback function.
		 */
		return_value = g_pMCSController->HandleAppletAttachUserRequest(&attach_request_info);
		if (return_value == (ULong) MCS_NO_ERROR)
		{
			// Set the returned interface ptr
			*ppIMCSSap = (IMCSSap *) pUser;

			/*
			 *	If the request was accepted, then register
			 *	the new user attachment.  Note that there
			 *	is still no user ID associated with this
			 *	attachment, since the attach user confirm
			 *	has not yet been received.
			 */
			pUser->RegisterUserAttachment (user_callback, user_defined,
											flags);
		}
	}
	else {
		ERROR_OUT(("MCS_AttachRequest: MCS Provider is not initialized."));
		return_value = MCS_NOT_INITIALIZED;
	}
	/*
	 *	Leave the critical section before returning.
	 */
	LeaveCriticalSection (& g_MCS_Critical_Section);
	
	return (return_value);
}


/*
 *	User ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the user class.  It initializes all instance
 *		variables (mostly with passed in information).  It then registers its
 *		presence with the application interface object, so that user requests
 *		and responses will get here okay.  Finally, it issues an attach user
 *		request to the domain to start the attachment process.
 */
User::User (PDomain		pDomain,
			PMCSError	pError)
:
    CAttachment(USER_ATTACHMENT),
	m_pDomain(pDomain),
	Deletion_Pending (FALSE),
	User_ID (0),
	Merge_In_Progress (FALSE),
	m_DataPktQueue(),
	m_PostMsgPendingQueue(),
	m_DataIndMemoryBuf2(),
	CRefCount(MAKE_STAMP_ID('U','s','e','r'))
{
	DomainParameters		domain_parameters;

	g_pMCSController->AddRef();
	/*
	 * We now need to create the window that the MCS Provider
	 * will use to deliver MCS messages to the attachment.
	 * These messages are indications and confirms.
	 */
	m_hWnd = CreateWindow (s_WindowClassName,
							NULL,
							WS_POPUP,
							CW_USEDEFAULT,
							CW_USEDEFAULT,
							CW_USEDEFAULT,
							CW_USEDEFAULT,
							NULL,
							NULL,
							g_hDllInst,
							NULL);

	if (m_hWnd != NULL) {
		/*
		 *	Call the domain object to find out the current domain parameters.
		 *	From this, set the maximum user data length appropriately.
		 */
		m_pDomain->GetDomainParameters (&domain_parameters, NULL, NULL);
		Maximum_User_Data_Length = domain_parameters.max_mcspdu_size -
									(MAXIMUM_PROTOCOL_OVERHEAD_MCS +
									BER_PROTOCOL_EXTRA_OVERHEAD);
		TRACE_OUT (("User::User: "
			"maximum user data length = %ld", Maximum_User_Data_Length));

		/*
		 *	Use the specified domain parameters to set the type of encoding rules
		 *	to be used.
		 */
		ASSERT (domain_parameters.protocol_version == PROTOCOL_VERSION_PACKED);

		/*
		 *	Send an attach user request to the specified domain.
		 */
		m_pDomain->AttachUserRequest (this);
		*pError = MCS_NO_ERROR;
	}
	else {
		*pError = MCS_ALLOCATION_FAILURE;
	}
}

/*
 *	~User ()
 *
 *	Public
 *
 *	Functional Description:
 *		
 */
User::~User ()
{
	PDataPacket packet;
	while (NULL != (packet = m_PostMsgPendingQueue.Get()))
	{
		packet->Unlock();
    }

	if (m_hWnd) {
		// Destroy the window; we do not need it anymore
		DestroyWindow (m_hWnd);
	}
	g_pMCSController->Release();
}

/*
 *	MCSError	GetBuffer ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function allocates an MCS buffer for a user attachment.
 *		Because this function allocates a buffer for the user and a Memory
 *		object that immediately precedes the buffer, after the user fills in
 *		the buffer with data and gives it to MCS to send, it needs to specify the
 *		right flags in the SendData request API.
 */

MCSError User::GetBuffer (UINT	size, PVoid	*pbuffer)
{

	MCSError				return_value;
	PMemory					memory;

	EnterCriticalSection (& g_MCS_Critical_Section);
	
	/*
	 *	This request may be a retry from a previous request which
	 *	returned MCS_TRANSMIT_BUFFER_FULL.  If so, delete the associated
	 *	buffer retry info structure since resource levels will be
	 *	checked in this function anyway.
	 */
	if (m_BufferRetryInfo != NULL) {
		KillTimer (NULL, m_BufferRetryInfo->timer_id);
		s_pTimerUserList2->Remove(m_BufferRetryInfo->timer_id);
		delete m_BufferRetryInfo;
		m_BufferRetryInfo = NULL;
		
	}

	// Allocate the memory
	DBG_SAVE_FILE_LINE
	memory = AllocateMemory (NULL, size + MAXIMUM_PROTOCOL_OVERHEAD,
							 SEND_PRIORITY);
							
	LeaveCriticalSection (& g_MCS_Critical_Section);

	if (NULL != memory) {
		// the allocation succeeded.
		ASSERT ((PUChar) memory + sizeof(Memory) == memory->GetPointer());
		*pbuffer = (PVoid) (memory->GetPointer() + MAXIMUM_PROTOCOL_OVERHEAD);
		return_value = MCS_NO_ERROR;
	}
	else {
		// the allocation failed.
		TRACE_OUT (("User::GetBuffer: Failed to allocate data buffer."));
		CreateRetryTimer (size + MAXIMUM_PROTOCOL_OVERHEAD);
		return_value = MCS_TRANSMIT_BUFFER_FULL;
	}
	return (return_value);
}

/*
 *	MCSError	FreeBuffer ()
 *
 *	Public
 *
 *	Functional Description:
 */

void User::FreeBuffer (PVoid	buffer_ptr)
{
		PMemory		memory;

	ASSERT (m_fFreeDataIndBuffer == FALSE);

	/*
	 *	Attempt to find the buffer in the m_DataIndDictionary dictionary.
	 *	This is where irregular data indications go.
	 */
	if (NULL == (memory = m_DataIndMemoryBuf2.Remove(buffer_ptr)))
    {
		memory = GetMemoryObject(buffer_ptr);
    }

	// Free the memory.
	EnterCriticalSection (& g_MCS_Critical_Section);
	FreeMemory (memory);
	LeaveCriticalSection (& g_MCS_Critical_Section);
}

/*
 *	Void	CreateRetryTimer
 *
 *	Private
 *
 *	Functional Description
 *		This functions creates a timer in response to a failure to
 *		allocate memory for the send data that the user is trying to
 *		send.  The timer will fire off periodically so that this code
 *		will remember to check the memory levels and provide an
 *		MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION to the user.
 *
 *	Return Value:
 *		None.
 *
 *	Side effects:
 *		The timer is created.
 */

Void User::CreateRetryTimer (ULong size)
{
	UINT_PTR timer_id;
			
	timer_id = SetTimer (NULL, 0, TIMER_PROCEDURE_TIMEOUT, (TIMERPROC) TimerProc);
	if (timer_id != 0) {
		DBG_SAVE_FILE_LINE
		m_BufferRetryInfo = new BufferRetryInfo;

		if (m_BufferRetryInfo != NULL) {
			m_BufferRetryInfo->user_data_length = size;
			m_BufferRetryInfo->timer_id = timer_id;

			s_pTimerUserList2->Append(timer_id, this);
		}
		else {
			ERROR_OUT (("User::CreateRetryTimer: Failed to allocate BufferRetryInfo struct."));
			KillTimer (NULL, timer_id);
		}
	}
	else {
		/*
		 *	This is a bad error, The notification to the user when buffers
		 *	are available will be lost.  Hopefully, the user will try again
		 *	later.
		 */
		WARNING_OUT(("User::CreateRetryTimer: Could not SetTimer."));
	}
}

/*
 *	MCSError	ReleaseInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wishes to detach from the domain.
 *		It kicks off the process of detaching, and seeing that this object
 *		is properly deleted.
 */
MCSError	User::ReleaseInterface ()
{
	CUidList		deletion_list;
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Check to see if there is a merge operation in progress before proceeding
	 *	with the request.
	 */
	if (Merge_In_Progress == FALSE)
	{
		/*
		 *	If deletion is not already pending, then it is necessary for us
		 *	to tell the domain that we are leaving.
		 */
		if (Deletion_Pending == FALSE)
		{
			/*
			 *	If we are already attached, user ID will not be 0, and we
			 *	should send a detach user request.  If user ID IS 0, then we
			 *	are not yet attached to the domain, so a disconnect provider
			 *	ultimatum is used instead.
			 */
			if (User_ID != 0)
			{
				deletion_list.Append(User_ID);
				m_pDomain->DetachUserRequest (this,
							REASON_USER_REQUESTED, &deletion_list);
				User_ID = 0;
			}
			else
				m_pDomain->DisconnectProviderUltimatum (this,
							REASON_USER_REQUESTED);

			/*
			 *	Set the flag that will cause the object to be deleted during
			 *	the next call to FlushMessageQueue.
			 */
			Deletion_Pending = TRUE;
		}

		/*
		 *	Empty out the message queue (the application should receive no
		 *	messages once the attachment has been deleted).
		 */
		PurgeMessageQueue ();

		// Cleanup timers and retry structures;
		if (m_BufferRetryInfo != NULL) {
			s_pTimerUserList2->Remove(m_BufferRetryInfo->timer_id);
			KillTimer (NULL, m_BufferRetryInfo->timer_id);
			delete m_BufferRetryInfo;
			m_BufferRetryInfo = NULL;
		}

		return_value = MCS_NO_ERROR;

		// Release can release the MCS Controller, so, we have to exit the CS now.
		LeaveCriticalSection (& g_MCS_Critical_Section);
		
		/*
		 *	Release this object. Note that the object may be deleted
		 *	here, so, we should not access any member variables after this
		 *	call.
		 */
		Release();
	}
	else
	{
		LeaveCriticalSection (& g_MCS_Critical_Section);
		/*
		 *	This operation could not be processed at this time due to a merge
		 *	operation in progress at the local provider.
		 */
		WARNING_OUT (("User::ReleaseInterface: "
				"merge in progress"));
		return_value = MCS_DOMAIN_MERGING;
	}

	return (return_value);
}

#define CHANNEL_JOIN		0
#define CHANNEL_LEAVE		1
#define CHANNEL_CONVENE		2
#define CHANNEL_DISBAND		3

/*
 *	MCSError	ChannelJLCD ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to join/leave/convene/disband
 *		a channel.  If the user is attached to the domain, the request will be
 *		repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelJLCD (int type, ChannelID channel_id)
{
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR) {
		switch (type) {
		case CHANNEL_JOIN:
			m_pDomain->ChannelJoinRequest (this, User_ID, channel_id);
			break;
		case CHANNEL_LEAVE:
			{
				CChannelIDList	deletion_list;
				deletion_list.Append(channel_id);
				m_pDomain->ChannelLeaveRequest (this, &deletion_list);
			}
			break;
		case CHANNEL_CONVENE:
			m_pDomain->ChannelConveneRequest (this, User_ID);
			break;
		case CHANNEL_DISBAND:
			m_pDomain->ChannelDisbandRequest (this, User_ID, channel_id);
			break;
		}
	}

	LeaveCriticalSection (& g_MCS_Critical_Section);

	return (return_value);
}

/*
 *	MCSError	ChannelJoin ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to join a
 *		channel.  If the user is attached to the domain, the request will be
 *		repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelJoin (ChannelID channel_id)
{
	return (ChannelJLCD (CHANNEL_JOIN, channel_id));
}

/*
 *	MCSError	ChannelLeave ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to leave a
 *		channel.  If the user is attached to the domain, the request will be
 *		repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelLeave (ChannelID	channel_id)
{
	return (ChannelJLCD (CHANNEL_LEAVE, channel_id));
}

/*
 *	MCSError	ChannelConvene ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to convene a
 *		private channel.  If the user is attached to the domain, the request
 *		will be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelConvene ()
{
	return (ChannelJLCD (CHANNEL_CONVENE, 0));
}

/*
 *	MCSError	ChannelDisband ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to disband a
 *		private channel.  If the user is attached to the domain, the request
 *		will be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelDisband (
					ChannelID			channel_id)
{
	return (ChannelJLCD (CHANNEL_DISBAND, channel_id));
}

/*
 *	MCSError	ChannelAdmit ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to admit more
 *		users to a private channel for which it is manager.  If the user is
 *		attached to the domain, the request will be repackaged as an MCS command
 *		and sent to the domain object.
 */
MCSError	User::ChannelAdmit (
					ChannelID			channel_id,
					PUserID				user_id_list,
					UINT				user_id_count)
{
	UINT			count;
	CUidList		local_user_id_list;
	MCSError		return_value = MCS_NO_ERROR;

	/*
	 *	Verify that the value of each user ID included in the user ID list is
	 *	a valid value.  Otherwise, fail the call.
	 */
	for (count = 0; count < user_id_count; count++)
	{
		if (user_id_list[count] > 1000) {
			// add the UserID into the singly-linked list.
			local_user_id_list.Append(user_id_list[count]);
		}
		else {
			return_value = MCS_INVALID_PARAMETER;
			break;
		}
	}

	if (return_value == MCS_NO_ERROR) {

		EnterCriticalSection (& g_MCS_Critical_Section);
	
		/*
		 *	Verify that current conditions are appropriate for a request to be
		 *	accepted from a user attachment.
		 */
		return_value = ValidateUserRequest ();

		if (return_value == MCS_NO_ERROR)
		{
			m_pDomain->ChannelAdmitRequest (this, User_ID, channel_id,
												&local_user_id_list);
		}

		LeaveCriticalSection (& g_MCS_Critical_Section);
	}

	return (return_value);
}

#ifdef USE_CHANNEL_EXPEL_REQUEST
/*
 *	MCSError	MCSChannelExpelRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to expel
 *		users from a private channel for which it is manager.  If the user is
 *		attached to the domain, the request will be repackaged as an MCS command
 *		and sent to the domain object.
 */
MCSError	User::ChannelExpel (
					ChannelID			channel_id,
					PMemory				memory,
					UINT				user_id_count)
{
	UINT			count;
	CUidList		local_user_id_list;
	MCSError		return_value;
	PUserID			user_id_list = (PUserID) memory->GetPointer();

	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR)
	{
		/*
		 *	Repack the user ID list into an S-list before sending it on.
		 */
		for (count=0; count < user_id_count; count++)
			local_user_id_list.append ((DWORD) user_id_list[count]);

		m_pDomain->ChannelExpelRequest (this, User_ID, channel_id,
				&local_user_id_list);
	}

	if (return_value != MCS_DOMAIN_MERGING)
		FreeMemory (memory);

	return (return_value);
}
#endif // USE_CHANNEL_EXPEL_REQUEST

/*
 *	MCSError	SendData ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to send data
 *		on a channel.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 *
 *		Note that this version of the send data request assumes that the user
 *		data has not already been segmented.  This is the function that
 *		performs the segmentation.
 */
MCSError	User::SendData (DataRequestType		request_type,
							ChannelID			channel_id,
							Priority			priority,
							unsigned char *		user_data,
							ULong		 		user_data_length,
							SendDataFlags		flags)
{
	MCSError			return_value = MCS_NO_ERROR;
	ULong				i, request_count, user_packet_length;
	PDataPacket			packet;
	ASN1choice_t		choice;
	UINT				type;
	PUChar				data_ptr = user_data;
	PacketError			packet_error;
	Segmentation		segmentation;
	PMemory				memory;
	PDataPacket			*packets;

	/*
	 *	Calculate how many different MCS packets are going to be generated.
	 *	Remember that if the size of the request exceeds the maximum allowed
	 *	value, we will segment the data into multiple smaller pieces.
	 */
	request_count = ((user_data_length + (Maximum_User_Data_Length - 1)) /
					Maximum_User_Data_Length);

	/*
	 *	Allocate the array of PDataPackets, before we get the critical section.
	 */
	if (request_count == 1) {
		packets = &packet;
		packet = NULL;
	}
	else {
		DBG_SAVE_FILE_LINE
		packets = new PDataPacket[request_count];
		if (packets == NULL) {
			ERROR_OUT (("User::SendData: Failed to allocate packet array."));
			return_value = MCS_TRANSMIT_BUFFER_FULL;
		}
		else {
			ZeroMemory ((PVoid) packets, request_count * sizeof(PDataPacket));
		}
	}

	if (MCS_NO_ERROR == return_value) {
		// Set the choice and type variables for all the DataPackets.
		if (NORMAL_SEND_DATA == request_type) {
			choice = SEND_DATA_REQUEST_CHOSEN;
			type = MCS_SEND_DATA_INDICATION;
		}
		else {
			choice = UNIFORM_SEND_DATA_REQUEST_CHOSEN;
			type = MCS_UNIFORM_SEND_DATA_INDICATION;
		}
					
		EnterCriticalSection (& g_MCS_Critical_Section);

		/*
		 *	Verify that current conditions are appropriate for a request to be
		 *	accepted from a user attachment.
		 */
		return_value = ValidateUserRequest ();
	
		/*
		 *	Check to see if there is a merge operation in progress before proceeding
		 *	with the request.
		 */
		if (MCS_NO_ERROR == return_value) {

			/*
			 *	This request may be a retry from a previous request which
			 *	returned MCS_TRANSMIT_BUFFER_FULL.  If so, delete the associated
			 *	buffer retry info structure since resource levels will be
			 *	checked in this function anyway.
			 */
			if (m_BufferRetryInfo != NULL) {
                s_pTimerUserList2->Remove(m_BufferRetryInfo->timer_id);
				KillTimer (NULL, m_BufferRetryInfo->timer_id);
				delete m_BufferRetryInfo;
				m_BufferRetryInfo = NULL;
			}

			/*
			 *	Depending on the "flags" argument, we either have
			 *	to allocate the buffer space and copy the data into
			 *	it, or just create a Memory object for the supplied
			 *	buffer.
			 */
			if (flags != APP_ALLOCATION) {
		
				ASSERT (flags == MCS_ALLOCATION);
				/*
				 *	The buffer was allocated by MCS, thru an
				 *	MCSGetBufferRequest call.  So, the Memory object
				 *	must preceed the buffer.	
				 */
				 memory = GetMemoryObject (user_data);
				 ASSERT (SIGNATURE_MATCH(memory, MemorySignature));
			}
			else
				memory = NULL;

			/*
			 *	We now attempt to allocate all data packets at once.
			 *	We need to do that before starting to send them, because
			 *	the request has to be totally successful or totally fail.
			 *	We can not succeed in sending a part of the request.
			 */
			for (i = 0; (ULong) i < request_count; i++) {
				// take care of segmentation flags
				if (i == 0)
					// first segment
					segmentation = SEGMENTATION_BEGIN;
				else
					segmentation = 0;
				if (i == request_count - 1) {
					// last segment
					segmentation |= SEGMENTATION_END;
					user_packet_length = user_data_length - (ULong)(data_ptr - user_data);
				}
				else {
					user_packet_length = Maximum_User_Data_Length;
				}

				// Now, create the new DataPacket.
				DBG_SAVE_FILE_LINE
				packets[i] = new DataPacket (choice, data_ptr, user_packet_length,
									 (UINT) channel_id, priority,
									 segmentation, (UINT) User_ID,
									 flags, memory, &packet_error);

				// Make sure the allocation succeeded
				if ((packets[i] == NULL) || (packet_error != PACKET_NO_ERROR)) {
					/*
					 *	The allocation of the packet failed.  We must therefore
					 *	return a failure to the user application.
					 */
					WARNING_OUT (("User::SendData: data packet allocation failed"));
					return_value = MCS_TRANSMIT_BUFFER_FULL;
					break;
				}
					
				// Adjust the user data ptr
				data_ptr += Maximum_User_Data_Length;
			}

			if (return_value == MCS_NO_ERROR) {
				// We now can send the data.
				// Forward all the data packets to the appropriate places.
				for (i = 0; i < request_count; i++) {
					/*
					 *	Send the successfully created packet to the domain
					 *	for processing.
					 */
					m_pDomain->SendDataRequest (this, (UINT) type, packets[i]);

					/*
					 *	Enable the packet to free itself.  Note that it will not
					 *	actually do so until everyone that is using it is through
					 *	with it.  Also, if nobody has locked it so far,
					 *	it will be deleted.
					 */
					packets[i]->Unlock ();
				}
			}
			else {
				// some packet allocation failed
				for (i = 0; i < request_count; i++)
					delete packets[i];
			}
		}
		if (request_count > 1)
			delete [] packets;
	}

	if (MCS_TRANSMIT_BUFFER_FULL == return_value) {
		CreateRetryTimer(user_data_length + request_count * MAXIMUM_PROTOCOL_OVERHEAD);
	}
	else if (MCS_NO_ERROR == return_value) {
		FreeMemory (memory);
	}

	LeaveCriticalSection (& g_MCS_Critical_Section);
	return (return_value);
}

#define GRAB		0
#define INHIBIT		1
#define	PLEASE		2
#define RELEASE		3
#define TEST		4

/*
 *	MCSError	TokenGIRPT ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to grab/inhibit/request/release/test
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenGIRPT (int type, TokenID	token_id)
{
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR)
	{
		switch (type) {
		case GRAB:
			m_pDomain->TokenGrabRequest (this, User_ID, token_id);
			break;
		case INHIBIT:
			m_pDomain->TokenInhibitRequest (this, User_ID, token_id);
			break;
		case PLEASE:
			m_pDomain->TokenPleaseRequest (this, User_ID, token_id);
			break;
		case RELEASE:
			m_pDomain->TokenReleaseRequest (this, User_ID, token_id);
			break;
		case TEST:
			m_pDomain->TokenTestRequest (this, User_ID, token_id);
			break;
		}
	}
	LeaveCriticalSection (& g_MCS_Critical_Section);

	return (return_value);
}

/*
 *	MCSError	TokenGrab ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to grab
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenGrab (TokenID				token_id)
{
	return (TokenGIRPT (GRAB, token_id));
}

/*
 *	MCSError	TokenInhibit ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to inhibit
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenInhibit (TokenID				token_id)
{
	return (TokenGIRPT (INHIBIT, token_id));
}

/*
 *	MCSError	TokenGive ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to give away
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenGive (TokenID token_id, UserID receiver_id)
{
	MCSError		return_value;
	TokenGiveRecord TokenGiveRec;

	if (receiver_id > 1000) {
		// Fill in the TokenGive command structure.
		TokenGiveRec.uidInitiator = User_ID;
		TokenGiveRec.token_id = token_id;
		TokenGiveRec.receiver_id = receiver_id;

		EnterCriticalSection (& g_MCS_Critical_Section);
		/*
		 *	Verify that current conditions are appropriate for a request to be
		 *	accepted from a user attachment.
		 */
		return_value = ValidateUserRequest ();

		if (return_value == MCS_NO_ERROR) {	
			m_pDomain->TokenGiveRequest (this, &TokenGiveRec);
		}
		LeaveCriticalSection (& g_MCS_Critical_Section);
	}
	else {
		ERROR_OUT(("User::TokenGive: Invalid UserID for receiver."));
		return_value = MCS_INVALID_PARAMETER;
	}

	return (return_value);
}

/*
 *	MCSError	TokenGiveResponse ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to respond to
 *		a previously received token give indication.  If the user is attached to
 *		the domain, the request will be repackaged as an MCS command and sent to
 *		the domain object.
 */
MCSError	User::TokenGiveResponse (TokenID token_id, Result result)
{
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR)
	{
		m_pDomain->TokenGiveResponse (this, result, User_ID, token_id);
	}
	LeaveCriticalSection (& g_MCS_Critical_Section);

	return (return_value);
}

/*
 *	MCSError	TokenPlease ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to be given
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenPlease (TokenID				token_id)
{
	return (TokenGIRPT (PLEASE, token_id));
}

/*
 *	MCSError	TokenRelease ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to release
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenRelease (TokenID	token_id)
{
	return (TokenGIRPT (RELEASE, token_id));
}

/*
 *	MCSError	TokenTest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to test
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenTest (TokenID	token_id)
{
	return (TokenGIRPT (TEST, token_id));
}

/*
 *	MCSError	ValidateUserRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to determine if it is valid to process an incoming
 *		request at the current time.  It checks several different conditions
 *		to determine this, as follows:
 *
 *		- If there is a merge in progress, then the request is not valid.
 *		- If this user is not yet attached to a domain, then the request
 *		  is not valid.
 *		- If there are not enough objects of the Memory, Packet, or UserMessage
 *		  class to handle a reasonable request, then the request is not valid.
 *
 *		Note that the check on number of objects is not an absolute guarantee
 *		that there will be enough to handle a given request, because a request
 *		can result in MANY PDUs and user messages being generated.  For example,
 *		a single channel admit request can result in lots of channel admit
 *		indications being sent.  However, checking against a minimum number
 *		of objects can reduce the possibility of failure to be astronomically
 *		low.  And remember, even if MCS runs out of something while processing
 *		such a request, it WILL handle it properly (by cleanly destroying the
 *		user attachment or MCS connection upon which the failure occurred).  So
 *		there is no chance of MCS crashing as a result of this.
 *
 *	Caveats:
 *		None.
 */
MCSError	User::ValidateUserRequest ()
{
	MCSError		return_value = MCS_NO_ERROR;

	/*
	 *	Check to see if there is a merge operation in progress.
	 */
	if (Merge_In_Progress == FALSE)
	{
		/*
		 *	Make sure the user is attached to the domain.
		 */
		if (User_ID == 0)
		{
			/*
			 *	The user is not yet attached to the domain.  So fail the request
			 *	without passing it on to the domain object.
			 */
			TRACE_OUT (("User::ValidateUserRequest: user not attached"));
			return_value = MCS_USER_NOT_ATTACHED;
		}
	}
	else
	{
		/*
		 *	This operation could not be processed at this time due to a merge
		 *	operation in progress at the local provider.
		 *
		 *	NOTE for JASPER:
		 *	Jasper probably will need to wait on an event handle here, which will be
		 *	set when the main MCS thread receives all the merging PDUs that get us out
		 *	of the merging state.  Since the only MCS client for Jasper is the GCC,
		 *	it should be ok to block the client (GCC) while the merging goes on.
		 */
		WARNING_OUT (("User::ValidateUserRequest: merge in progress"));
		return_value = MCS_DOMAIN_MERGING;
	}

	return (return_value);
}

/*
 *	Void	RegisterUserAttachment ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method registers a user attachment with the User object.
 */
void User::RegisterUserAttachment (MCSCallBack	mcs_callback,
									PVoid		user_defined,
									UINT		flags)
{
	TRACE_OUT (("User::RegisterUserAttachment: user handle = %p", this));

	/*
	 *	Fill in all of the members of the User object.
	 */
	m_MCSCallback = mcs_callback;
	m_UserDefined = user_defined;
	m_BufferRetryInfo = NULL;
	m_fDisconnectInDataLoss = (flags & ATTACHMENT_DISCONNECT_IN_DATA_LOSS);
	m_fFreeDataIndBuffer = (flags & ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);

	// Increase the ref count to indicate that the client is now using the object.
	AddRef();
}

/*
 *	Void	SetDomainParameters ()
 *
 *	Public
 *
 *	Functional Description:
 *		This command is used to set the current value of the instance variable
 *		that holds the maximum user data field length.
 */
void	User::SetDomainParameters (
				PDomainParameters		domain_parameters)
{
	/*
	 *	Set the maximum user data length instance variable to conform to the
	 *	maximum PDU size within the attached domain (minus some overhead to
	 *	allow for protocol bytes).
	 */
	Maximum_User_Data_Length = domain_parameters->max_mcspdu_size -
								(MAXIMUM_PROTOCOL_OVERHEAD_MCS +
								BER_PROTOCOL_EXTRA_OVERHEAD);
	TRACE_OUT (("User::SetDomainParameters: "
			"maximum user data length = %ld", Maximum_User_Data_Length));

	/*
	 *	Use the specified domain parameters to set the type of encoding rules
	 *	to be used.
	 */
	ASSERT (domain_parameters->protocol_version == PROTOCOL_VERSION_PACKED);
}

/*
 *	Void	PurgeChannelsIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called during a domain merge operation when there is
 *		a conflict in the use of channels.  The former Top Provider responds
 *		by issuing this command, which causes all users of the channel to be
 *		expelled from it.  Additionally, if the channel corresponds to a user
 *		ID channel, that user is purged from the network.
 */
void	User::PurgeChannelsIndication (
				CUidList           *purge_user_list,
				CChannelIDList *)
{
	/*
	 *	Issue a DetachUserIndication to each user contained in the purge user
	 *	list.
	 */
	DetachUserIndication(REASON_PROVIDER_INITIATED, purge_user_list);
}

/*
 *	Void	DisconnectProviderUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function will be called when the domain determines the need to
 *		tear down quickly.  This call simulates the reception of a detach user
 *		indication (if the user is already attached), or an unsuccessful
 *		attach user confirm (if the user is not yet attached).  In either
 *		case, the user attachment will be eliminated by this call.
 */
void	User::DisconnectProviderUltimatum (
				Reason				reason)
{
	CUidList		deletion_list;

	if (User_ID != 0)
	{
		/*
		 *	If the user is already attached, simulate a detach user indication
		 *	on the local user ID.
		 */
		deletion_list.Append(User_ID);
		DetachUserIndication(reason, &deletion_list);
	}
	else
	{
		/*
		 *	If the user is not yet attached, simulate an unsuccessful attach
		 *	user confirm.
		 */
		AttachUserConfirm(RESULT_UNSPECIFIED_FAILURE, 0);
	}
}

/*
 *	Void	AttachUserConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to the attach user
 *		request that was sent by this object when it was first created.  This
 *		call will contain the result of that attachment operation.  If the
 *		result is successful, this call will also contain the user ID for this
 *		attachment.
 */
void	User::AttachUserConfirm (
				Result				result,
				UserID				uidInitiator)
{
	LPARAM		parameter;

	if (Deletion_Pending == FALSE)
	{
		ASSERT (User_ID == 0);
		
		/*
		 *	If the result is successful, set the user ID of this user
		 *	object to indicate its new status.
		 */
		if (result == RESULT_SUCCESSFUL)
			User_ID = uidInitiator;
		else
			Deletion_Pending = TRUE;

		parameter = PACK_PARAMETER (uidInitiator, result);

		/*
		 *	Post the user message to the application.
		 */
		if (! PostMessage (m_hWnd, USER_MSG_BASE + MCS_ATTACH_USER_CONFIRM,
							(WPARAM) this, parameter)) {
			WARNING_OUT (("User::AttachUserConfirm: Failed to post msg to application. Error: %d",
						GetLastError()));
			if (result != RESULT_SUCCESSFUL)
				Release();
		}
	}
	else {
		Release();
	}
}

/*
 *	Void	DetachUserIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain whenever a user leaves the domain
 *		(voluntarily or otherwise).  Furthermore, if a user ID in the indication
 *		is the same as the local user ID, then this user is being involuntarily
 *		detached.
 */
Void	User::DetachUserIndication (
				Reason				reason,
				CUidList           *user_id_list)
{
	UserID				uid;
	LPARAM				parameter;
	BOOL				bPostMsgResult;

	if (Deletion_Pending == FALSE)
	{
		/*
		 *	Iterate through the list of users to be deleted.
		 */
		user_id_list->Reset();
		while (NULL != (uid = user_id_list->Iterate()))
		{
			parameter = PACK_PARAMETER(uid, reason);

			/*
			 *	Post the user message to the application.
			 */
			bPostMsgResult = PostMessage (m_hWnd, USER_MSG_BASE + MCS_DETACH_USER_INDICATION,
		 								  (WPARAM) this, parameter);
			if (! bPostMsgResult) {
				WARNING_OUT (("User::DetachUserIndication: Failed to post msg to application. Error: %d",
							GetLastError()));
			}
			
			/*
			 *	If this indication is deleting this user attachment, then
			 *	set the deletion pending flag, and break out of the loop.
			 */
			if (User_ID == uid)
			{
				m_originalUser_ID = User_ID;
				User_ID = 0;
				Deletion_Pending = TRUE;
				if (! bPostMsgResult)
					Release();
				break;
			}
		}
	}
	else {
		/*
		 *	The user has already called ReleaseInterface().  If the
		 *	Indication is for this attachment, we have to release and
		 *	probably, delete the object.
		 */
		if (user_id_list->Find(User_ID)) {
			Release();
		}
	}
}

/*
 *	Void	ChannelJLCDAEConfInd ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called to post a channel confirm/indication message
 *		to the user application.  It handles ChannelJoinConfirms,
 *		ChannelLeaveIndications, ChannelConveneConfirms, ChannelDisbandIndications
 *		and ChannelExpelIndications.
 */
Void	User::ChannelConfInd (	UINT		type,
								ChannelID	channel_id,
								UINT		arg16)
{
	LPARAM		parameter;

	ASSERT (HIWORD(arg16) == 0);
	
	if (Deletion_Pending == FALSE)
	{
		parameter = PACK_PARAMETER (channel_id, arg16);

		/*
		 *	Post the user message to the application.
		 */
		if (! PostMessage (m_hWnd, USER_MSG_BASE + type,
							(WPARAM) this, parameter)) {
			WARNING_OUT (("User::ChannelConfInd: Failed to post msg to application. Type: %d. Error: %d",
						type, GetLastError()));
		}
	}
}


/*
 *	Void	ChannelJoinConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous channel
 *		join request.  This call contains the result of the join request, as
 *		well as the channel that has just been joined.
 */
Void	User::ChannelJoinConfirm (
				Result				result,
				UserID,
				ChannelID			requested_id,
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_JOIN_CONFIRM, channel_id, (UINT) result);
}


/*
 *	Void	ChannelLeaveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	User::ChannelLeaveIndication (
				Reason				reason,
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_LEAVE_INDICATION, channel_id, (UINT) reason);
}

/*
 *	Void		ChannelConveneConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous channel
 *		convene request.  This call contains the result of the request, as
 *		well as the channel that has just been convened.
 */
Void	User::ChannelConveneConfirm (
				Result				result,
				UserID,
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_CONVENE_CONFIRM, channel_id, (UINT) result);
}

/*
 *	Void		ChannelDisbandIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when MCS disbands an existing
 *		private channel.
 */
Void	User::ChannelDisbandIndication (
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_DISBAND_INDICATION, channel_id, REASON_CHANNEL_PURGED);
}

/*
 *	Void		ChannelAdmitIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when a user is admitted to a
 *		private channel.
 */
Void	User::ChannelAdmitIndication (
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList *)
{
	ChannelConfInd (MCS_CHANNEL_ADMIT_INDICATION, channel_id, (UINT) uidInitiator);
}

/*
 *	Void		ChannelExpelIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when a user is expelled from a
 *		private channel.
 */
Void	User::ChannelExpelIndication (
				ChannelID			channel_id,
				CUidList *)
{
	ChannelConfInd (MCS_CHANNEL_EXPEL_INDICATION, channel_id, REASON_USER_REQUESTED);
}

/*
 *	Void	SendDataIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when data needs to sent to the
 *		user on a channel that the user has joined.
 */
Void	User::SendDataIndication (
				UINT				message_type,
				PDataPacket			packet)
{	
	if (Deletion_Pending == FALSE)
	{
		/*
		 *	Lock the packet object to indicate that we wish to have future
		 *	access to the decoded data that it contains.  Then get the
		 *	address of the decoded data structure.
		 */
		packet->Lock ();
		packet->SetMessageType(message_type);

        // flush packets in the pending queue
    	PDataPacket pkt;
    	while (NULL != (pkt = m_PostMsgPendingQueue.PeekHead()))
    	{
    		if (::PostMessage(m_hWnd, USER_MSG_BASE + pkt->GetMessageType(),
    		                  (WPARAM) this, (LPARAM) pkt))
    		{
    		    // remove the item just posted
    		    m_PostMsgPendingQueue.Get();
    		}
    		else
    		{
    		    // fail to post pending ones, just append the new one and bail out.
    		    m_PostMsgPendingQueue.Append(packet);
    		    return;
    		}
        }

		/*
		 *	Post the user message to the application.
		 */
		if (! ::PostMessage(m_hWnd, USER_MSG_BASE + message_type,
		                    (WPARAM) this, (LPARAM) packet))
		{
		    // fail to post pending ones, just append the new one and bail out.
		    m_PostMsgPendingQueue.Append(packet);
		    return;
		}
	}
}

/*
 *	Void	TokenConfInd ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called to post a token confirm/indication message
 *		to the user application.
 */
Void	User::TokenConfInd (UINT		type,
							TokenID		token_id,
							UINT		arg16)
{
	LPARAM		parameter;

	ASSERT (HIWORD(arg16) == 0);
	
	if (Deletion_Pending == FALSE)
	{
		parameter = PACK_PARAMETER (token_id, arg16);

		/*
		 *	Post the user message to the application.
		 */
		if (! PostMessage (m_hWnd, USER_MSG_BASE + type,
							(WPARAM) this, parameter)) {
			WARNING_OUT (("User::TokenConfInd: Failed to post msg to application. Type: %d. Error: %d",
						type, GetLastError()));
		}
	}
}

/*
 *	Void	TokenGrabConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		grab request.  This call contains the result of the grab request, as
 *		well as the token that has just been grabbed.
 */
Void	User::TokenGrabConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_GRAB_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenInhibitConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		inhibit request.  This call contains the result of the inhibit request,
 *		as well as the token that has just been inhibited.
 */
Void	User::TokenInhibitConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_INHIBIT_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenGiveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when another user attempts to
 *		give this user a token.
 */
Void	User::TokenGiveIndication (
				PTokenGiveRecord	pTokenGiveRec)
{
	TokenConfInd (MCS_TOKEN_GIVE_INDICATION, pTokenGiveRec->token_id,
				  (UINT) pTokenGiveRec->uidInitiator);
}

/*
 *	Void	TokenGiveConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		give request.  This call contains the result of the give request.
 */
Void	User::TokenGiveConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_GIVE_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenPleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when a user somewhere in the
 *		domain issues a token please request for a token that is currently
 *		owned by this user.
 */
Void	User::TokenPleaseIndication (
				UserID				uidInitiator,
				TokenID				token_id)
{
	TokenConfInd (MCS_TOKEN_PLEASE_INDICATION, token_id, (UINT) uidInitiator);
}

/*
 *	Void	TokenReleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This command is called when a token is being purged from the lower
 *		domain after a new connection is established.  It causes the indication
 *		to be forwarded to the user application, letting it know that it no
 *		longer owns the token.
 */
Void	User::TokenReleaseIndication (
				Reason				reason,
				TokenID				token_id)
{
	TokenConfInd (MCS_TOKEN_RELEASE_INDICATION, token_id, (UINT) reason);
}

/*
 *	Void	TokenReleaseConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		release request.  This call contains the result of the release request,
 *		as well as the token that has just been released.
 */
Void	User::TokenReleaseConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_RELEASE_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenTestConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		test request.  This call contains the result of the test request,
 *		as well as the token that has just been tested.
 */
Void	User::TokenTestConfirm (
				UserID,
				TokenID				token_id,
				TokenStatus			token_status)
{
	TokenConfInd (MCS_TOKEN_TEST_CONFIRM, token_id, (UINT) token_status);
}

/*
 *	Void	MergeDomainIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by domain upon entering or leaving a domain
 *		merger state.
 */
Void	User::MergeDomainIndication (
				MergeStatus			merge_status)
{
	if (Deletion_Pending == FALSE)
	{
		/*
		 *	If the merge operation is starting, set a boolean flag
		 *	indicating that this object should reject all user activity.
		 *	Otherwise, reset the flag.
		 */
		if (merge_status == MERGE_DOMAIN_IN_PROGRESS)
		{
			TRACE_OUT (("User::MergeDomainIndication: entering merge state"));
			Merge_In_Progress = TRUE;
		}
		else
		{
			TRACE_OUT (("User::MergeDomainIndication: leaving merge state"));
			Merge_In_Progress = FALSE;
		}
	}
}

/*
 *	Void	PurgeMessageQueue ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called to purge all current entries from the message
 *		queue, freeing up resources correctly (to prevent leaks).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		This function should only be called in the client's thread's context.
 */
Void	User::PurgeMessageQueue ()
{
	MSG				msg;
	PDataPacket		packet;
	HWND			hWnd;

	// First, unlock the packets in the list of pending data indications
	while (NULL != (packet = m_DataPktQueue.Get()))
		packet->Unlock();

	// Keep a copy of the attachment's HWND to destroy it later.
	hWnd = m_hWnd;
	m_hWnd = NULL;
		
	/*
	 *	This loop calls PeekMessage to go through all the messages in the thread's
	 *	queue that were posted by the main MCS thread.  It removes these
	 *	messages and frees the resources that they consume.
	 */
	while (PeekMessage (&msg, hWnd, USER_MSG_BASE, USER_MSG_BASE + MCS_LAST_USER_MESSAGE,
						PM_REMOVE)) {

		if (msg.message == WM_QUIT) {
			// Repost the quit
			PostQuitMessage (0);
			break;
		}
		
		/*
		 *	If this is a data indication message, we need to unlock
		 *	the packet associated with this message.
		 */
		else if ((msg.message == USER_MSG_BASE + MCS_SEND_DATA_INDICATION) ||
			(msg.message == USER_MSG_BASE + MCS_UNIFORM_SEND_DATA_INDICATION)) {
			((PDataPacket) msg.lParam)->Unlock ();
		}
		else if (((msg.message == USER_MSG_BASE + MCS_ATTACH_USER_CONFIRM) &&
					((Result) HIWORD(msg.lParam) != RESULT_SUCCESSFUL)) ||
			((msg.message == USER_MSG_BASE + MCS_DETACH_USER_INDICATION) &&
			(m_originalUser_ID == (UserID) LOWORD(msg.lParam)))) {
			ASSERT (this == (PUser) msg.wParam);
			Release();
			break;
		}
	}

	// Destroy the window; we do not need it anymore
	DestroyWindow (hWnd);
}

void User::IssueDataIndication (
					UINT				message_type,
					PDataPacket			packet)
{
		LPARAM					parameter;
		PMemory					memory;
		BOOL					bIssueCallback = TRUE;
		BOOL					bBufferInPacket = TRUE;
		PUChar					data_ptr;
		SendDataIndicationPDU	send_data_ind_pdu;
		
	switch (packet->GetSegmentation()) {
	case SEGMENTATION_BEGIN | SEGMENTATION_END:
		parameter = (LPARAM) &(((PDomainMCSPDU) (packet->GetDecodedData()))->
							u.send_data_indication);
		data_ptr = packet->GetUserData();
		memory = packet->GetMemory();
		break;
		
	case SEGMENTATION_END:
	{
		/*
		 *	We now have to collect all the individual packets from m_DataPktQueue
		 *	that go with this MCS Data PDU and sent them as a single data indication
		 *	using a buffer large enough for all the data.
		 */
		/*
		 *	First, find out the size of the large buffer we need to allocate.
		 *	Note that we make a copy of the original m_DataPktList and operate
		 *	on the copy, since we need to remove items from the original list.
		 */
			CDataPktQueue			PktQ(&m_DataPktQueue);
			UINT					size;
			PDataPacket				data_pkt;
			PUChar					ptr;
#ifdef DEBUG
			UINT uiCount = 0;
#endif // DEBUG
		
		size = packet->GetUserDataLength();
		PktQ.Reset();
		while (NULL != (data_pkt = PktQ.Iterate()))
		{
			if (packet->Equivalent (data_pkt)) {
#ifdef DEBUG
				if (uiCount == 0) {
					ASSERT (data_pkt->GetSegmentation() == SEGMENTATION_BEGIN);
				}
				else {
					ASSERT (data_pkt->GetSegmentation() == 0);
				}
				uiCount++;
#endif // DEBUG
				size += data_pkt->GetUserDataLength();
				// Remove from the original list, since we are processing the callback.
				m_DataPktQueue.Remove(data_pkt);
			}
		}
		// Allocate the memory we need.
		DBG_SAVE_FILE_LINE
		memory = AllocateMemory (NULL, size);
		if (memory != NULL) {
			bBufferInPacket = FALSE;
			// Copy the individual indications into the large buffer.
			data_ptr = ptr = memory->GetPointer();
			PktQ.Reset();
			/*
			 *	We need to enter the MCS critical section, because
			 *	we are unlocking packets.
			 */
			EnterCriticalSection (& g_MCS_Critical_Section);
			while (NULL != (data_pkt = PktQ.Iterate()))
			{
				if (packet->Equivalent (data_pkt)) {
					size = data_pkt->GetUserDataLength();
					memcpy ((void *) ptr,
							(void *) data_pkt->GetUserData(),
							size);
					ptr += size;
					data_pkt->Unlock();
				}
			}
			// Leave the MCS critical section
			LeaveCriticalSection (& g_MCS_Critical_Section);
			
			// Copy the last indication into the large buffer.
			memcpy ((void *) ptr,
					(void *) packet->GetUserData(),
					packet->GetUserDataLength());

			/*
			 *	Prepare the SendDataIndicationPDU structure for the client.
			 *	Notice that we can use the first 8 bytes from the decoded
			 *	structure of the current "packet" to fill in the first bytes from
			 *	it.
			 */
			memcpy ((void *) &send_data_ind_pdu,
					(void *) &(((PDomainMCSPDU) (packet->GetDecodedData()))->
								u.send_data_indication), 8);
			send_data_ind_pdu.segmentation = SEGMENTATION_BEGIN | SEGMENTATION_END;
			send_data_ind_pdu.user_data.length = memory->GetLength();
			send_data_ind_pdu.user_data.value = data_ptr;
			parameter = (ULONG_PTR) &send_data_ind_pdu;
		}
		else {
			/*
			 *	We have failed to issue the data indication callback to the client.
			 *	The user attachment has been compromised.  If the attachment can not
			 *	live with this loss, we have to detach them from the conference.
			 */
			ERROR_OUT (("User::IssueDataIndication: Memory allocation failed for segmented buffer of size %d.",
						size));
			bIssueCallback = FALSE;
			
			// Clean up after the failure
			EnterCriticalSection (& g_MCS_Critical_Section);
			PktQ.Reset();
			while (NULL != (data_pkt = PktQ.Iterate()))
			{
				if (m_fDisconnectInDataLoss ||
					(packet->Equivalent (data_pkt))) {
					data_pkt->Unlock();
				}
			}
			packet->Unlock();
			LeaveCriticalSection (& g_MCS_Critical_Section);

			// Disconnect if the client wants us to.
			if (m_fDisconnectInDataLoss) {
				// Clear the list of the already-cleared pending packets. We will soon get a ReleaseInterface().
				m_DataPktQueue.Clear();
				
				ERROR_OUT(("User::IssueDataIndication: Disconnecting user because of data loss..."));
				/*
				 *	Send a detach user indication directly to the user application.
				 *	Note that this cannot go through the queue, due to the memory
				 *	failure.
				 */
				(*m_MCSCallback) (MCS_DETACH_USER_INDICATION,
								PACK_PARAMETER (User_ID, REASON_PROVIDER_INITIATED),
								m_UserDefined);

			}
		}
		break;
	}
	
	case SEGMENTATION_BEGIN:
	case 0:
		// Append the packet to the list of packets for send.
		m_DataPktQueue.Append(packet);
		bIssueCallback = FALSE;
		break;
		
	default:
		ASSERT (FALSE);
		ERROR_OUT(("User::IssueDataIndication: Processed packet with invalid segmentation field."));
		break;
	}

	if (bIssueCallback) {
		/*
		 *	If the client has advised the server not to free the data, we have to
		 *	lock the buffer.
		 */
		if (m_fFreeDataIndBuffer == FALSE) {
			if (bBufferInPacket)
				LockMemory (memory);
				
			// Enter the data indication info in a dictionary, for the Free request.
			if (GetMemoryObject(data_ptr) != memory)
            {
				m_DataIndMemoryBuf2.Append((LPVOID) data_ptr, memory);
            }
		}
		
		/*
		 *	Issue the callback. The callee can not refuse to process this.
		 */
		(*m_MCSCallback) (message_type, parameter, m_UserDefined);

		/*
		 *	If the client has advised the server to free the data indication buffer
		 *	after delivering the callback, we must do so.
		 */
		if (m_fFreeDataIndBuffer) {
			if (bBufferInPacket == FALSE)
				FreeMemory (memory);
		}

		// To unlock a packet, we need to enter the MCS CS.
		EnterCriticalSection (& g_MCS_Critical_Section);
		packet->Unlock();
		LeaveCriticalSection (& g_MCS_Critical_Section);
	}
}	
	

/*
 *	LRESULT		UserWindowProc ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the window procedure that will be used by all internally
 *		created windows.  A hidden window is created internally when the
 *		application attaches to an MCS domain.  This technique insures
 *		that callbacks are delivered to the owner in the same thread that
 *		initially created the attachment.
 */
LRESULT CALLBACK	UserWindowProc (
							HWND		window_handle,
							UINT		message,
							WPARAM		word_parameter,
							LPARAM		long_parameter)
{
		UINT		mcs_message;
		//PDataPacket	packet;
		PUser		puser;
		
	if ((message >= USER_MSG_BASE) && (message < USER_MSG_BASE + MCS_LAST_USER_MESSAGE)) {
		// This is an MCS msg going to the user application.

		// Compute the MCS msg type
		mcs_message = message - USER_MSG_BASE;

		// Retrieve the pointer to the User (interface) object.
		puser = (PUser) word_parameter;
        if (NULL != puser)
        {
    		/*
    		 *	Find out whether this is a data indication. If it is, set the
    		 *	packet variable.
    		 */
    		if ((mcs_message == MCS_SEND_DATA_INDICATION) ||
    			(mcs_message == MCS_UNIFORM_SEND_DATA_INDICATION)) {
    			puser->IssueDataIndication (mcs_message, (PDataPacket) long_parameter);
    		}
    		else {
    			/*
    			 *	Issue the callback. Notice that the callee can not refuse
    			 *	to process this.
    			 */
    			(*(puser->m_MCSCallback)) (mcs_message, long_parameter, puser->m_UserDefined);
    		}

    		/*
    		 *	We may need to release the User object.  This is the Server
    		 *	side release.
    		 */
    		if (((mcs_message == MCS_ATTACH_USER_CONFIRM) &&
    					((Result) HIWORD(long_parameter) != RESULT_SUCCESSFUL)) ||
    			((mcs_message == MCS_DETACH_USER_INDICATION) &&
    					(puser->m_originalUser_ID == (UserID) LOWORD(long_parameter)))) {
    			puser->Release();
    		}
        }
        else
        {
            ERROR_OUT(("UserWindowProc: null puser"));
        }
		return (0);
	}
	else {
		/*
		 *	Invoke the default window message handler to handle this
		 *	message.
		 */
		return (DefWindowProc (window_handle, message, word_parameter,
								long_parameter));
	}
}


/*
 *	Void	CALLBACK TimerProc (HWND, UINT, UINT, DWORD
 *
 *	Public
 *
 *	Functional Description:
 *		This is the timer procedure.  Timer messages will be routed to this
 *		function as a result of timer events which have been set up to recheck
 *		resource levels.  This would happen following a call to either
 *		MCSSendDataRequest or MCSUniformSendDataRequest which resulted in a
 *		return value of MCS_TRANSMIT_BUFFER_FULL.
 */
Void	CALLBACK TimerProc (HWND, UINT, UINT timer_id, DWORD)
{
	PUser				puser;

	/*
	 *	Enter the critical section which protects global data.
	 */
	EnterCriticalSection (& g_MCS_Critical_Section);

	/*
	 *	First, we must find which user owns this timer.  We will do this by
	 *	searching through the Static_User_List.
	 */
	if (NULL == (puser = User::s_pTimerUserList2->Find(timer_id)))
	{
		WARNING_OUT (("TimerProc: no user owns this timer - deleting timer"));
		KillTimer (NULL, timer_id);
		goto Bail;
	}

	/*
	 *	Make sure that this user is actively attached.  If not, then kill the
	 *	timer and delete the user's buffer retry info structure.
	 */
    if ((puser->User_ID == 0) || puser->Deletion_Pending)
	{
		WARNING_OUT (("TimerProc: user is not attached - deleting timer"));
		goto CleanupBail;
	}

	/*
	 *	If we don't have retryinfo just get out of here.
	 */
	 if(puser->m_BufferRetryInfo == NULL)
	 {
		WARNING_OUT (("TimerProc: user does not have buffer retry info - deleting timer"));
		goto CleanupBail;
	 }

	/*
	 *	We have identified a valid owner of this timer.
	 *	Verify that there is enough memory for the
	 *	required size before proceeding.  Note that since there
	 *	can be multiple processes allocating from the same memory
	 *	at the same time, this call does not guarantee
	 *	that that the allocations will succeed.
	 */
	if (GetFreeMemory (SEND_PRIORITY) < puser->m_BufferRetryInfo->user_data_length)
	{
		TRACE_OUT (("TimerProc: not enough memory buffers of required size"));
		goto Bail;
	}

	/*
	 *	If the routine gets this far, then an adequate level of resources
	 *	now exists.
	 */

	/*
	 *	Issue an MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION to the user.
	 */
	TRACE_OUT(("TimerProc: Delivering MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION callback."));
//	(*(puser->m_MCSCallback)) (MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION,
//								0, puser->m_UserDefined);

	
	if(!PostMessage (puser->m_hWnd, USER_MSG_BASE + MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION,(WPARAM) puser, 0))
	{
		ERROR_OUT (("TimerProc: Failed to post msg to application. Error: %d", GetLastError()));
	}


CleanupBail:
	KillTimer (NULL, timer_id);
	delete puser->m_BufferRetryInfo;
	puser->m_BufferRetryInfo = NULL;
	User::s_pTimerUserList2->Remove(timer_id);

Bail:
	// Leave the attachment's critical section
	LeaveCriticalSection (& g_MCS_Critical_Section);

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\crc.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*	crc.cpp
 *
 *	Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CRC class.
 *
 *	Private Instance Variables:
 *		CRC_Table[] 	-	Look-up table for pre-calc CRC values.
 *		CRC_Poly 		-	The algorithm's polynomial.
 *		CRC_Init 		-	Initial register value.
 *		CRC_Check_Value -	The value to compare the resulting received CRC.
 *		Invert 			-	Determines wether to invert the CRC value before 
 *							sending.
 *		CRC_Register 	-	CRC register during execution.
 *
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Marvin Nicholson
 */
#include "crc.h"



/*  CRC::CRC()
 *
 *  Public 
 *
 *	Functional Description:
 *  	The constructor fo CRC class initializes some member variables.
 */
CRC::CRC()
{

	CRC_Width = 16;    /* Width of the CRC register. */
	CRC_Poly = 0x8408; /* Polynomial used in generating the CRC. */
	CRC_Init = 0xFFFF; /* Initial value of the CRC register. */
	Invert = TRUE;     /* Enables 1's complement of CRC */

	if (Invert)
	{
       /*
        *  If using 1's complement use this value to check incoming
        *  CRC.
        */
       CRC_Check_Value = 0xF0B8;
    }
	else
	{
        /*
         *  If not inverting CRC on transmittion, use this value to
         *  check received CRC.
         */
       CRC_Check_Value = 0x0000;
    }

	CRCTableGenerator (CRC_Poly);
}


/*  CRC::~CRC()
 *
 *  Public
 *
 *	Functional Description:
 *  This is the destructor for the CRC class.
 */
CRC::~CRC()
{
}


/* ULONG CRC::OldCRCGenerator(HPUChar block_adr, ULONG block_len)
 *
 * Public
 *
 *	Functional Description:
 * 		This routine computes the CRC value using standard bit-shifting.
 */
ULONG CRC::OldCRCGenerator (
			LPBYTE block_adr,
            ULONG block_len)
{
	Int 	i;
	UChar	input_byte;
	USHORT	byte_count;

	CRC_Register = (USHORT) CRC_Init;
	byte_count = 0;
	while(byte_count < block_len)
	{
		input_byte = *(block_adr + byte_count);
		CRC_Register ^= input_byte;
		for(i=0; i<8; i++)
		{
			if(CRC_Register & 1)
			{
				CRC_Register >>= 1;
				CRC_Register ^= (USHORT) CRC_Poly;
			}
			else
				CRC_Register >>= 1;
		}
		byte_count++;
	}
	if (Invert)
		return (CRC_Register ^ 0xFFFF);
	else
		return (CRC_Register);
}


/* ULONG CRC::CRCGenerator(HPUChar block_adr, ULONG block_len)
 *
 * Public
 *
 *	Functional Descriprion:
 * 		This routine computes the CRC value using a look-up table.
 */
ULONG CRC::CRCGenerator(
			LPBYTE block_adr,
            ULONG block_len)
{

	CRC_Register = (USHORT) CRC_Init;

	while(block_len--)
	{
		CRC_Register = 
			CRC_Table[(UChar) (((UChar) CRC_Register) ^ *block_adr++)] ^ 
			(CRC_Register >> 8);
	}
	if (Invert)
		return (CRC_Register ^ 0xFFFF);
	else
		return (CRC_Register);
}


/*	
 *	USHORT CRC::CRCTableValue(
 *					Int index,
 *   	            ULONG poly)
 *
 *	Functional Description
 *		This function generates a value that goes in the CRC_Table
 *
 *	Formal Parameters
 *		index	(i)	-	Index into the table
 *		poly	(i)	-	Polynomial used to generate the value
 *
 *	Return Value
 *		Value generated.
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
USHORT CRC::CRCTableValue(
				Int index,
                ULONG poly)
{
	Int i;
	ULONG r;
	ULONG inbyte = (ULONG) index;

	r = inbyte;
	for(i=0; i<8; i++)
	{
		if (r & 1)
			r = (r >> 1) ^ poly;
		else
			r >>= 1;
	}
	return ((USHORT) r);
}


/*	
 *	void CRC::CRCTableGenerator (ULONG poly)
 *
 *	Functional Description
 *		This function generates the CRC table 
 *
 *	Formal Parameters
 *		poly	(i)	-	Polynomial used to generate the table
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
void CRC::CRCTableGenerator (ULONG poly)
{
	Int i;

	for(i=0; i<CRC_TABLE_SIZE; i++)
		CRC_Table[i] = CRCTableValue(i,poly);
}

/* BOOL CRC::CheckCRC(HPUChar block_adr, ULONG block_len)
 *
 * Public 
 *
 *	Functional Description:
 * 		This routine computes the CRC of a datablock and its associated CRC and
 * 		returns a TRUE value if the resulting CRC value is 0x0000
 * 		or 0xF0B8.
 */
BOOL CRC::CheckCRC(
				LPBYTE	block_adr,
                ULONG 	block_len)
{
	CRC_Register = (USHORT) CRC_Init;

	while(block_len--)
	{
		CRC_Register = 
			CRC_Table[(UChar) (((UChar) CRC_Register) ^ *block_adr++)] ^ 
			(CRC_Register >> 8);
	}
	if (CRC_Register == CRC_Check_Value)
		return TRUE;
	else
		return FALSE;
}


/*
 *	void	CRC::GetOverhead (
 *				USHORT	maximum_packet,
 *				USHORT *	new_maximum_packet)
 *
 * Public 
 *
 *	Functional Description:
 * 		This routine adds the number of overhead bytes generated by a CRC to
 *		the packet size passed in.
 */
void	CRC::GetOverhead (
			USHORT	maximum_packet,
			USHORT *	new_maximum_packet)
{
	*new_maximum_packet = maximum_packet + 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\comport.h ===
/*    Comport.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the interface file for the ComPort class.  This class is the
 *        interface to the Win32 Comm port.
 *
 *        If this class is instantiated in in-band call control mode, it will
 *        open the Windows port and set it up properly.  It will use the
 *        configuration data from the Configuration object.  Refer to the MCAT
 *        Developer's Toolkit Manual for a complete listing of the configurable
 *        items.
 *
 *        If this class is instantiated in out-of-band mode, it is passed a
 *        file handle.  It assumes that this port has been properly initialized.
 *        It get the configuration data that it needs from the port_configuration
 *        structure passed in.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James P. Galvin
 *        James W. Lawwill
 */
#ifndef _T123_COM_PORT_H_
#define _T123_COM_PORT_H_


 /*
 **    Return values from this class
 */
typedef enum
{
    COMPORT_NO_ERROR,
    COMPORT_INITIALIZATION_FAILED,
    COMPORT_NOT_OPEN,
    COMPORT_ALREADY_OPEN,
    COMPORT_READ_FAILED,
    COMPORT_WRITE_FAILED,
    COMPORT_CONFIGURATION_ERROR
}
    ComPortError, * PComPortError;

 /*
 **    Miscellaneous Definitions
 */
#define OUTPUT_FLOW_CONTROL     0x0001
#define INPUT_FLOW_CONTROL      0x0002

#define DEFAULT_PATH            "."
#define DEFAULT_MODEM_TYPE      ""

#define DEFAULT_COM_PORT        2

#define DEFAULT_BAUD_RATE       9600

#define DEFAULT_PARITY                          NOPARITY
#define DEFAULT_DATA_BITS                       8
#define DEFAULT_STOP_BITS                       1
#define DEFAULT_FLOW_CONTROL                    OUTPUT_FLOW_CONTROL
// #define DEFAULT_TX_BUFFER_SIZE                  0
#define DEFAULT_TX_BUFFER_SIZE                  1024
#define DEFAULT_RX_BUFFER_SIZE                  10240
#define DEFAULT_READ_INTERVAL_TIMEOUT           10
#define DEFAULT_READ_TOTAL_TIMEOUT_MULTIPLIER   0
#define DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT     100
// #define DEFAULT_INTERNAL_RX_BUFFER_SIZE         1024
#define DEFAULT_INTERNAL_RX_BUFFER_SIZE         DEFAULT_RX_BUFFER_SIZE
#define DEFAULT_COUNT_OF_READ_ERRORS            10
#define DEFAULT_BYTE_COUNT_INTERVAL             0

#define COM_TRANSMIT_BUFFER                     0x0001
#define COM_RECEIVE_BUFFER                      0x0002

#define SYNCHRONOUS_WRITE_TIMEOUT               500
#define MODEM_IDENTIFIER_STRING_LENGTH          16
#define COMPORT_IDENTIFIER_STRING_LENGTH        16


class ComPort : public IProtocolLayer
{
public:

    ComPort(TransportController    *owner_object,
            ULONG                   message_base,
            PLUGXPRT_PARAMETERS    *pParams,
            PhysicalHandle          physical_handle,
            HANDLE                  hevtClose);

    virtual ~ComPort(void);
    LONG    Release(void);

    ComPortError Open(void);
    ComPortError Close(void);
    ComPortError Reset(void);
    ComPortError ReleaseReset(void);

    ULONG GetBaudRate(void) { return Baud_Rate; }

    ProtocolLayerError  SynchronousDataRequest(
                            LPBYTE           buffer,
                            ULONG            length,
                            ULONG           *bytes_accepted);

    BOOL        ProcessReadEvent(void);
    BOOL        ProcessWriteEvent(void);

     /*
     **    Functions overridden from the ProtocolLayer object
     */
    ProtocolLayerError    DataRequest (
                            ULONG_PTR         identifier,
                            LPBYTE            buffer_address,
                            ULONG            length,
                            PULong            bytes_accepted);
    ProtocolLayerError    RegisterHigherLayer (
                            ULONG_PTR         identifier,
                            PMemoryManager    memory_manager,
                            IProtocolLayer *    higher_layer);
    ProtocolLayerError    RemoveHigherLayer (
                            ULONG_PTR         identifier);
    ProtocolLayerError    PollReceiver(void);
    ProtocolLayerError    GetParameters (
                            USHORT *            max_packet_size,
                            USHORT *            prepend,
                            USHORT *            append);
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     identifier,
                            PMemory        memory,
                            PULong         bytes_accepted);
    ProtocolLayerError    DataIndication (
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    PollTransmitter (
                            ULONG_PTR       identifier,
                            USHORT        data_to_transmit,
                            USHORT *        pending_data,
                            USHORT *        holding_data);

    PLUGXPRT_PSTN_CALL_CONTROL GetCallControlType(void) { return Call_Control_Type; }
    BOOL PerformAutomaticDisconnect(void) { return Automatic_Disconnect; }
    BOOL IsWriteActive(void) { return Write_Active; }


private:

    ProtocolLayerError  WriteData(
                            BOOL        synchronous,
                            LPBYTE      buffer_address,
                            ULONG       length,
                            PULong      bytes_accepted);

    void                ReportInitializationFailure(ComPortError);

private:

    LONG                    m_cRef;
    BOOL                    m_fClosed;
    TransportController    *m_pController; // owner object
    ULONG                   m_nMsgBase;
    BOOL                    Automatic_Disconnect;
    PLUGXPRT_PSTN_CALL_CONTROL         Call_Control_Type;
    DWORD                   Count_Errors_On_ReadFile;

    ULONG                   Baud_Rate;
    ULONG                   Tx_Buffer_Size;
    ULONG                   Rx_Buffer_Size;
    ULONG                   Byte_Count;
    ULONG                   Last_Byte_Count;

    ULONG                   m_nReadBufferOffset;
    DWORD                   m_cbRead;
    ULONG                   m_cbReadBufferSize;
    LPBYTE                  m_pbReadBuffer;

    HANDLE                  m_hCommLink;
    HANDLE                  m_hCommLink2;
    HANDLE                  m_hevtClose;
    HANDLE                  m_hevtPendingRead;
    HANDLE                  m_hevtPendingWrite;

    PEventObject            Write_Event_Object;
    PEventObject            Read_Event_Object;

    OVERLAPPED              m_WriteOverlapped;
    OVERLAPPED              m_ReadOverlapped;

    DWORD                   Event_Mask;
    BOOL                    Read_Active;
    BOOL                    Write_Active;

    IProtocolLayer         *m_pMultiplexer; // higher layer
};
typedef    ComPort *    PComPort;

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    ComPort::ComPort (
 *                PTransportResources    transport_resources,
 *                PChar                port_string,
 *                IObject *                owner_object,
 *                ULONG                message_base,
 *                BOOL            automatic_disconnect,
 *                PhysicalHandle        physical_handle);
 *
 *    Functional Description
 *        This is a constructor for the ComPort class.  It initializes internal
 *        variables from the configuration object.  It opens the Win32 comm port
 *        and initializes it properly.
 *
 *    Formal Parameters
 *        transport_resources (i) -    Pointer to TransportResources structure.
 *        port_string            (i)    -    String specifing the configuration heading
 *                                    to use.
 *        owner_object        (i)    -    Pointer to object that owns this object.
 *                                    If this object needs to contact its owner,
 *                                    it calls the OwnerCallback function.
 *        message_base        (i)    -    When this object issues an OwnerCallback,
 *                                    it should OR the message_base with the
 *                                    actual message.
 *        automatic_disconnect(i)    -    This object, at some point, will be asked
 *                                    if it should break its physical connection
 *                                    if the logical connections are broken.  The
 *                                    owner of this object is telling it how to
 *                                    respond.
 *        physical_handle        (i)    -    This is the handle associated with this
 *                                    ComPort.  When the ComPort registers an
 *                                    event to be monitored, it includes its
 *                                    physical_handle.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPort::ComPort (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                ULONG                message_base,
 *                ULONG                handle,
 *                PPortConfiguration    port_configuration,
 *                PhysicalHandle        physical_handle);
 *
 *    Functional Description
 *        This is a constructor for the ComPort class.  It initializes internal
 *        variables from the port_configuration structure.  It uses the file
 *        handle passed in and prepares to send and receive data.
 *
 *    Formal Parameters
 *        transport_resources (i) -    Pointer to TransportResources structure.
 *        owner_object        (i)    -    Pointer to object that owns this object.
 *                                    If this object needs to contact its owner,
 *                                    it calls the OwnerCallback function.
 *        message_base        (i)    -    When this object issues an OwnerCallback,
 *                                    it should OR the message_base with the
 *                                    actual message.
 *        handle                (i)    -    File handle to be used as the comm port.
 *        port_configuration    (i)    -    Pointer to PortConfiguration structure.
 *        physical_handle        (i)    -    This is the handle associated with this
 *                                    ComPort.  When the ComPort registers an
 *                                    event to be monitored, it includes its
 *                                    physical_handle.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPort::~Comport (void)
 *
 *    Functional Description
 *        This is the destructor for the Comport class. It releases all memory
 *        that was used by the class and deletes all timers
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPortError    ComPort::Open (void);
 *
 *    Functional Description
 *        This function opens the comm port and configures it with the values
 *        found in the configuration object.  It uses the Physical_API_Enabled
 *        flag in the g_TransportResource structure to determine if it needst to
 *        open the comm port.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        COM_NO_ERROR                -    Successful open and configuration
 *        COM_INITIALIZATION_FAILED    -    One of many problems could have
 *                                        occurred.  For example, the com
 *                                        port is open by another application
 *                                        or one of the parameters in the
 *                                        configuration file is improper.
 *
 *                                        When this error occurs, a callback is
 *                                        made to the user that indicates there
 *                                        is an error condition.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPortError    ComPort::Close (void);
 *
 *    Functional Description
 *        If the Physical API is not enabled, this function makes the necessary
 *        calls to close the Comm    Windows port.  It first clears the DTR signal
 *        to haugup the modem.
 *
 *        Regardless of the Physical API being enabled, it also flushes the comm
 *        buffers.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        COMPORT_NO_ERROR    -    Com Port closed successfully
 *         COMPORT_NOT_OPEN    -    Com Port is not open, we can't close it
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPortError    ComPort::Reset (void);
 *
 *    Functional Description
 *        This function clears the DTR signal on the Com port.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        COMPORT_NO_ERROR    -    Com port reset
 *         COMPORT_NOT_OPEN    -    Com port is not open, we can't access it
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPortError    ComPort::ReleaseReset (void);
 *
 *    Functional Description
 *        This function releases the previous reset.  It sets the DTR signal on
 *        the com port.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        COMPORT_NO_ERROR    -    Com port reset
 *         COMPORT_NOT_OPEN    -    Com port is not open, we can't access it
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPortError    ComPort::FlushBuffers (
 *                                USHORT    buffer_mask)
 *
 *    Functional Description
 *        This function issues the Windows cals to flush the input and/or
 *        output buffers.
 *
 *    Formal Parameters
 *        buffer_mask    -    (i)        If COM_TRANSMIT_BUFFER is set, we flush the
 *                                output buffer.
 *                                If COM_RECEIVE_BUFFER is set, we flush the
 *                                input buffer.
 *
 *    Return Value
 *        COMPORT_NO_ERROR    -    Successful operation
 *         COMPORT_NOT_OPEN    -    Com port is not open, we can't access it
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ULONG    ComPort::GetBaudRate (void);
 *
 *    Functional Description
 *        This function returns the baud rate of the port
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        Baud rate of the port.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    ComPort::SynchronousDataRequest (
 *                                    FPUChar        buffer_address,
 *                                    ULONG        length,
 *                                    FPULong        bytes_accepted)
 *
 *    Functional Description:
 *        This function is called to send data out the port in a synchronous
 *        manner.  In other words, we will not return from the function until
 *        all of the bytes are actually written to the modem or a timeout occurs.
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Address of buffer to write.
 *        length            (i)    -    Length of buffer
 *        bytes_accepted    (o)    -    Number of bytes actually written
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    Success
 *        PROTOCOL_LAYER_ERROR    -    Failure
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    BOOL    ComPort::ProcessReadEvent (void)
 *
 *    Functional Description:
 *        This function is called when a READ event is actually set.  This means
 *        that the read operation has completed or an error occured.
 *
 *    Formal Parameters
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    BOOL    ComPort::ProcessWriteEvent (
 *                            HANDLE    event);
 *
 *    Functional Description:
 *        This function is called when a WRITE event is actually set.  This means
 *        that the write operation has completed or an error occured.
 *
 *    Formal Parameters
 *        event    (i)        -    Object event that occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    BOOL    ComPort::ProcessControlEvent (void)
 *
 *    Functional Description:
 *        This function is called when a CONTROL event is actually set.  This
 *        means that the CONTROL operation has occured.  In our case the RLSD
 *        signal has changed.
 *
 *    Formal Parameters
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    DataLink::DataRequest (
 *                                    ULONG    identifier,
 *                                    LPBYTE    buffer_address,
 *                                    USHORT    length,
 *                                    USHORT *    bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Length of packet to transmit
 *        bytes_accepted    (o)    -    Number of bytes accepted by the DataLink.
 *                                This value will either be 0 or the packet
 *                                length since this layer has a packet interface.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    DataLink::RegisterHigherLayer (
 *                                    ULONG            identifier,
 *                                    PMemoryManager    memory_manager,
 *                                    IProtocolLayer *    higher_layer);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  When this object needs to send a packet up, it calls
 *        the higher_layer with a Data Indication
 *
 *    Formal Parameters
 *        identifier        (i)    -    Unique identifier of the higher layer.  If we
 *                                were doing multiplexing at this layer, this
 *                                would have greater significance.
 *        memory_manager    (i)    -    Pointer to outbound memory manager
 *        higher_layer    (i)    -    Address of higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Error occured on registration
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    DataLink::RemoveHigherLayer (
 *                                    ULONG);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove its identifier
 *        and its address.  If the higher layer removes itself from us, we have
 *        no place to send incoming data
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    DataLink::PollReceiver (
 *                                    ULONG    identifier);
 *
 *    Functional Description
 *        This function is called to give the DataLink a chance pass packets
 *        to higher layers
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    DataLink::GetParameters (
 *                                    ULONG    identifier,
 *                                    USHORT *    max_packet_size,
 *                                    USHORT *    prepend_size,
 *                                    USHORT *    append_size);
 *
 *    Functional Description:
 *        This function returns the maximum packet size that it can handle via
 *        its DataRequest() function.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Not used
 *        max_packet_size    (o)    -    Address to return max. packet size in.
 *        prepend_size    (o)    -    Return number of bytes prepended to each packet
 *        append_size        (o)    -    Return number of bytes appended to each packet
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    BOOL    ComPort::PerformAutomaticDisconnect (void)
 *
 *    Functional Description:
 *        This function returns TRUE if we want to terminate a physical connection
 *        as soon as the logical connections are disconnected.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRUE    -    If we want to drop the physical connection after all
 *                    logical connections are dropped.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    DataLink::DataRequest (
 *                                    ULONG        identifier,
 *                                    PMemory        memory,
 *                                    PULong         bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        memory            (i)    -    Pointer to memory object
 *        bytes_accepted    (o)    -    Number of bytes accepted by the DataLink.
 *                                This value will either be 0 or the packet
 *                                length since this layer has a packet interface.
 *
 *    Return Value
 *        PROTOCOL_LAYER_ERROR    -    Not supported.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    ComPort::DataIndication (
 *                                    LPBYTE        buffer_address,
 *                                    ULONG        length,
 *                                    PULong        bytes_accepted);
 *
 *    Functional Description
 *        This function will never be called.  It is only here because this
 *        class inherits from ProtocolLayer.
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        memory            (i)    -    Pointer to memory object
 *        bytes_accepted    (o)    -    Number of bytes accepted by the DataLink.
 *                                This value will either be 0 or the packet
 *                                length since this layer has a packet interface.
 *
 *    Return Value
 *        PROTOCOL_LAYER_ERROR    -    Not supported.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    ComPort::PollTransmitter (
 *                                    ULONG        identifier,
 *                                    USHORT        data_to_transmit,
 *                                    USHORT *        pending_data,
 *                                    USHORT *        holding_data);
 *
 *    Functional Description
 *        This function does nothing.
 *
 *    Formal Parameters
 *        None used.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\userdata.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);

/* 
 *	userdata.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CUserDataListContainer. CUserDataListContainer
 *		objects are used to maintain user data elements. A user data element
 *		consists of an Object Key and an optional octet string.  The Object
 *		Key data is maintained internally by this class by using an
 *		CObjectKeyContainer container.  The optional octet string data is maintained
 *		internally through the use of a Rogue Wave string container.
 *
 *	Protected Instance Variables:
 *		m_UserDataItemList
 *			List of structures used to hold the user data internally.
 *		m_pSetOfUserDataPDU
 *			Storage for the "PDU" form of the user data.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCUserData structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "userdata.h"
#include "clists.h"

USER_DATA::~USER_DATA(void)
{
	if (NULL != key)
    {
        key->Release();
    }
	delete poszOctetString;
}

/*
 *	CUserDataListContainer()
 *
 *	Public Function Description
 *		This CUserDataListContainer constructor is used to create a CUserDataListContainer object
 *		from "API" data.  The constructor immediately copies the user data 
 *		passed in as a list of "GCCUserData" structures into it's internal form
 *		where a Rogue Wave container holds the data in the form of 
 *		USER_DATA structures.
 */
CUserDataListContainer::
CUserDataListContainer(UINT cMembers, PGCCUserData *user_data_list, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('U','r','D','L')),
    m_UserDataItemList(DESIRED_MAX_USER_DATA_ITEMS),
    m_cbDataSize(0),
    m_pSetOfUserDataPDU(NULL)
{
	/*
	 * Copy the user data into the internal structures.
	 */
	*pRetCode = CopyUserDataList(cMembers, user_data_list);
}

/*
 *	CUserDataListContainer()
 *
 *	Public Function Description
 *		This CUserDataListContainer constructor is used to create a CUserDataListContainer object 
 *		from data passed in as a "PDU" SetOfUserData structure.  The user
 *		data is copied into it's internal form where a Rogue Wave container 
 *		holds the data in the form of USER_DATA structures.
 */
CUserDataListContainer::
CUserDataListContainer(PSetOfUserData set_of_user_data, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('U','r','D','L')),
    m_UserDataItemList(DESIRED_MAX_USER_DATA_ITEMS),
    m_cbDataSize(0),
    m_pSetOfUserDataPDU(NULL)
{
	/*
	 * Copy the user data into the internal structures.
	 */
	*pRetCode = UnPackUserDataFromPDU(set_of_user_data);
}

/*
 *	CUserDataListContainer()
 *
 *	Public Function Description
 *		This CUserDataListContainer copy constructor is used to create a CUserDataListContainer 
 *		object from	another CUserDataListContainer object.  The constructor immediately
 *		copies the user data passed in into it's internal form where a Rogue 
 *		Wave list holds the data in the form of USER_DATA structures.
 */
CUserDataListContainer::
CUserDataListContainer(CUserDataListContainer *user_data_list, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('U','r','D','L')),
    m_UserDataItemList(DESIRED_MAX_USER_DATA_ITEMS),
    m_cbDataSize(0),
    m_pSetOfUserDataPDU(NULL)
{
	GCCError		rc;
	USER_DATA       *user_data_info_ptr;
	USER_DATA       *lpUsrDataInfo;

	/*
	 * Set up an iterator for the internal list of "info" structures in the
	 * CUserDataListContainer object to be copied.
	 */
	user_data_list->m_UserDataItemList.Reset();

	/*
	 * Copy each USER_DATA structure contained in the CUserDataListContainer object to
	 * be copied.
	 */
	while (NULL != (lpUsrDataInfo = user_data_list->m_UserDataItemList.Iterate()))
	{
		/*
		 * Create a new USER_DATA structure to hold each element of the new
		 * CUserDataListContainer object.  Report an error if creation of this structure
		 * fails.
		 */
		DBG_SAVE_FILE_LINE
		user_data_info_ptr = new USER_DATA;
		if (user_data_info_ptr != NULL)
		{
		    user_data_info_ptr->poszOctetString = NULL;

			/*
			 * Go ahead and insert the pointer to the USER_DATA structure
			 * into the internal Rogue Wave list.
			 */
			m_UserDataItemList.Append(user_data_info_ptr);

			/*
			 * Create a new CObjectKeyContainer object to hold the "key" using the 
			 * copy constructor for the CObjectKeyContainer class.  Check to be sure
			 * construction of the object is successful.  Note that validation
			 * of the object key data is not done here since this would be done
			 * when the original CUserDataListContainer object was created.
			 */
    		DBG_SAVE_FILE_LINE
			user_data_info_ptr->key = new CObjectKeyContainer(lpUsrDataInfo->key, &rc);
			if ((NULL != user_data_info_ptr->key) && (GCC_NO_ERROR == rc))
			{
    			/*
    			 * If an octet string exists, create a new Rogue Wave string to hold
    			 * the octet string portion	of the "key" and copy the octet string 
    			 * from the old CUserDataListContainer object into the new USER_DATA 
    			 * structure.
    			 */
    			if (lpUsrDataInfo->poszOctetString != NULL)
    			{
    				if (NULL == (user_data_info_ptr->poszOctetString =
    									::My_strdupO(lpUsrDataInfo->poszOctetString)))
    				{
    					ERROR_OUT(("UserData::UserData: can't create octet string"));
    					rc = GCC_ALLOCATION_FAILURE;
    					goto MyExit;
    				}
    			}
    			else
    			{
    				ASSERT(NULL == user_data_info_ptr->poszOctetString);
    			}
			}
            else
			{
				ERROR_OUT(("UserData::UserData: Error creating new ObjectKeyData"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
		}
		else
		{
			ERROR_OUT(("UserData::UserData: can't create USER_DATA"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
	}

    rc = GCC_NO_ERROR;

MyExit:

    *pRetCode = rc;
}

/*
 *	~CUserDataListContainer()
 *
 *	Public Function Description
 *		This is the destructor for the CUserDataListContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 */
CUserDataListContainer::
~CUserDataListContainer(void)
{
	/*
	 * Free any PDU data which may have not been freed.
	 */
	if (m_pSetOfUserDataPDU)
    {
		FreeUserDataListPDU();
    }

	/*
	 * Set up an iterator to use for iterating through the internal Rogue
	 * Wave list of USER_DATA structures.
	 */
	USER_DATA  *pUserDataItem;
	m_UserDataItemList.Reset();
	while (NULL != (pUserDataItem = m_UserDataItemList.Iterate()))
	{
		/*
		 * Delete any memory being referenced in the USER_DATA structure.
		 */
		delete pUserDataItem;
	}
}


/*
 *	LockUserDataList ()
 *
 *	Public Function Description:
 *		This routine locks the user data list and determines the amount of
 *		memory referenced by the "API" user data list structures.
 */
UINT CUserDataListContainer::
LockUserDataList(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data.  Otherwise, just increment the 
	 * lock count.
	 */
	if (Lock() == 1)
	{
		USER_DATA *lpUsrDataInfo;
		/*
		 * Set aside memory to hold the pointers to the GCCUserData structures
		 * as well as the structures themselves.  The "sizeof" the structure 
		 * must be rounded to an even four-byte boundary.
		 */
		m_cbDataSize = m_UserDataItemList.GetCount() * 
				(sizeof(PGCCUserData) + ROUNDTOBOUNDARY(sizeof(GCCUserData)) );

		m_UserDataItemList.Reset();
	 	while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
		{
			/*
			 * Lock the data for the object keys, adding the amount of memory
			 * necessary to hold the object key data to the total memory size.
			 */
			m_cbDataSize += lpUsrDataInfo->key->LockObjectKeyData();

			/*
			 * Check to see if this user data element contains the optional
			 * user data octet string.  Add the space to hold it if it exists.
			 */
			if (lpUsrDataInfo->poszOctetString != NULL)
			{
				/*
				 * Since the user data structure contains a pointer to a
				 * OSTR structure, we must add the amount of memory
				 * needed to hold the structure as well as the string data.
				 */
				m_cbDataSize += ROUNDTOBOUNDARY(sizeof(OSTR));

				/*
				 * The data referenced by the octet string is just the byte
				 * length of the octet string.
				 */
				m_cbDataSize += ROUNDTOBOUNDARY(lpUsrDataInfo->poszOctetString->length);
			}
		}
	}

	return m_cbDataSize;
}

/*
 *	GetUserDataList	()
 *
 *	Public Function Description:
 *		This routine retrieves user data elements contained in the user data
 *		object and returns them in the "API" form of a list of pointers to 
 *		"GCCUserData" structures.  The number of user data elements contained 
 *		in this object is also returned.
 */
UINT CUserDataListContainer::
GetUserDataList(USHORT *number_of_members, PGCCUserData **user_data_list, LPBYTE memory)
{
	UINT			cbDataSizeToRet = 0;
	UINT			data_length = 0;
	Int				user_data_counter = 0;
	PGCCUserData	user_data_ptr;
	
	/*
	 * If the user data has been locked, fill in the output parameters and
	 * the data referenced by the pointers.  Otherwise, report that the object
	 * has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		USER_DATA  *lpUsrDataInfo;
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the number of user data entities and save a pointer to the 
		 * memory location passed in.  This is where the pointers to the 
		 * GCCUserData structures will be written.  The actual structures will 
		 * be written into memory immediately following the list of pointers.
		 */
		*number_of_members = (USHORT) m_UserDataItemList.GetCount();

		*user_data_list = (PGCCUserData *)memory;

		/*
		 * Save the amount of memory needed to hold the list of pointers
		 * as well as the actual user data structures.
		 */
		data_length = m_UserDataItemList.GetCount() * sizeof(PGCCUserData);

		/*
		 * Move the memory pointer past the list of user data pointers.  This 
		 * is where the first user data structure will be written.
		 */
		memory += data_length;

		/*
		 * Iterate through the internal list of USER_DATA structures,
		 * building "API" GCCUserData structures in memory.
		 */
		m_UserDataItemList.Reset();
		while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
		{
			/*
			 * Save the pointer to the user data structure in the list 
			 * of pointers.
			 */
			user_data_ptr = (PGCCUserData)memory;
			(*user_data_list)[user_data_counter++] = user_data_ptr;

			/*
			 * Move the memory pointer past the user data structure.  This is 
			 * where the object key data and octet string data will be written.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCUserData));

			/*
			 * Fill in the user data structure starting with the object key.
			 */
			data_length = lpUsrDataInfo->key->GetGCCObjectKeyData(&user_data_ptr->key, memory);

			/*
			 * Move the memory pointer past the object key data.  This is 
			 * where the octet string structure will be written, if it exists.
			 * If the octet string does exist, save the memory pointer in the 
			 * user data structure's octet string pointer and fill in the 
			 * elements of the octet string structure.  Otherwise, set the
			 * octet string pointer to NULL.
			 */
			memory += data_length;

			if (lpUsrDataInfo->poszOctetString == NULL)
            {
				user_data_ptr->octet_string = NULL;
            }
			else
			{
				user_data_ptr->octet_string = (LPOSTR) memory;

				/*
				 * Move the memory pointer past the octet string structure.  
				 * This is where the actual string data for the octet string 
				 * will be written.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(OSTR));

				/*
				 * Write the octet string data into memory and set the octet 
				 * string structure pointer and length.
				 */
				user_data_ptr->octet_string->length =
					lpUsrDataInfo->poszOctetString->length;
				user_data_ptr->octet_string->value = (LPBYTE)memory;

				/*
				 * Now copy the octet string data from the internal Rogue Wave
				 * string into the object key structure held in memory.
				 */		
				::CopyMemory(memory, lpUsrDataInfo->poszOctetString->value,
							lpUsrDataInfo->poszOctetString->length);

				/*
				 * Move the memory pointer past the octet string data.
				 */
				memory += ROUNDTOBOUNDARY(user_data_ptr->octet_string->length);
			}
		}
	}
	else
	{
    	*user_data_list = NULL;
		*number_of_members = 0;
		ERROR_OUT(("CUserDataListContainer::GetUserDataList: Error Data Not Locked"));
	}
	
	return cbDataSizeToRet;
}

/*
 *	UnLockUserDataList	()
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeUserDataList.  If so, the object will automatically delete
 *		itself.
 */
void CUserDataListContainer::
UnLockUserDataList(void)
{
	USER_DATA  *user_data_info_ptr;

	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock any memory locked for the CObjectKeyContainer objects in the
		 * internal USER_DATA structures.
		 */
		m_UserDataItemList.Reset();
		while (NULL != (user_data_info_ptr = m_UserDataItemList.Iterate()))
		{
			/*
			 * Unlock any CObjectKeyContainer memory being referenced in the 
			 * USER_DATA structure.
			 */
			if (user_data_info_ptr->key != NULL)
			{
				user_data_info_ptr->key->UnLockObjectKeyData ();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetUserDataPDU	()
 *
 *	Public Function Description:
 *		This routine converts the user data from it's internal form of a list
 *		of USER_DATA structures into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "SetOfUserData" structure is 
 *		returned.
 */
GCCError CUserDataListContainer::
GetUserDataPDU(PSetOfUserData *set_of_user_data)
{
	GCCError				rc = GCC_NO_ERROR;
	PSetOfUserData			new_pdu_user_data_ptr;
	PSetOfUserData			old_pdu_user_data_ptr = NULL;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (NULL == m_pSetOfUserDataPDU)
	{
		USER_DATA  *lpUsrDataInfo;

		/*
		 * Iterate through the list of USER_DATA structures, converting 
		 * each into "PDU" form and saving the pointers in the linked list of 
		 * "SetsOfUserData".
		 */
		m_UserDataItemList.Reset();
		while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_pdu_user_data_ptr = new SetOfUserData;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_pdu_user_data_ptr == NULL)
			{
				ERROR_OUT(("CUserDataListContainer::GetUserDataPDU: Allocation error, cleaning up"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}

			//
			// Ensure everything is clean.
			//
			::ZeroMemory(new_pdu_user_data_ptr, sizeof(SetOfUserData));

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfUserData created.  On subsequent loops, set
			 * the structure's "next" pointer equal to the new structure.
			 */
			if (m_pSetOfUserDataPDU == NULL)
			{
				m_pSetOfUserDataPDU = new_pdu_user_data_ptr;
			}
			else
            {
				old_pdu_user_data_ptr->next = new_pdu_user_data_ptr;
            }

			old_pdu_user_data_ptr = new_pdu_user_data_ptr;

			/*
			 * Initialize the new "next" pointer to NULL and convert the
			 * user data element.
			 */
			new_pdu_user_data_ptr->next = NULL;

			if (ConvertUserDataInfoToPDUUserData(lpUsrDataInfo, new_pdu_user_data_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("UserData::GetUserDataPDU: can't convert USER_DATA to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}

		if (GCC_NO_ERROR != rc)
		{
			FreeUserDataListPDU();
			ASSERT(NULL == m_pSetOfUserDataPDU);
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*set_of_user_data = m_pSetOfUserDataPDU;

	return rc;
}

/*
 *	FreeUserDataListPDU	()
 *
 *	Public Function Description:
 *		This routine frees any data which was allocated as a result of a call
 *		to "GetUserDataPDU" which was called in order to build up a "PDU"
 *		structure holding the user data.
 */
void CUserDataListContainer::
FreeUserDataListPDU(void)
{
	PSetOfUserData		pdu_user_data_set;
	PSetOfUserData		next_pdu_user_data_set;
	USER_DATA           *lpUsrDataInfo;

	/*
	 * Check to make sure "PDU" data has been allocated for this object.
	 */
	if (NULL != m_pSetOfUserDataPDU)
	{
		pdu_user_data_set = m_pSetOfUserDataPDU;
        m_pSetOfUserDataPDU = NULL; // so no one can use it now.

		/*
		 * Loop through the list, freeing the user data associated with 
		 * each structure contained in the list.
		 */
		while (pdu_user_data_set != NULL)
		{
			next_pdu_user_data_set = pdu_user_data_set->next;
			delete pdu_user_data_set;
			pdu_user_data_set = next_pdu_user_data_set;
		}
	}
	else
	{
		TRACE_OUT(("CUserDataListContainer::FreeUserDataListPDU: Error PDU data not allocated"));
	}

	/*
	 * Iterate through the internal list, telling each CObjectKeyContainer object
	 * to free any PDU data which it has allocated.
	 */
	m_UserDataItemList.Reset();
	while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
	{
		if (lpUsrDataInfo->key != NULL)
        {
			lpUsrDataInfo->key->FreeObjectKeyDataPDU();
        }
	}
}

/*
 *	GCCError	CopyUserDataList ( 	UINT					number_of_members,
 *									PGCCUserData	*		user_data_list)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine copies the user data passed in as "API" data into it's
 *		internal form where the Rogue Wave m_UserDataItemList holds the data
 *		in the form of USER_DATA structures.
 *
 *	Formal Parameters:
 *		number_of_members	(i) The number of elements in the user data list.
 *		user_datalist		(i)	The list holding the user data to store.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
CopyUserDataList(UINT number_of_members, PGCCUserData *user_data_list)
{
	GCCError				rc = GCC_NO_ERROR;
	USER_DATA			    *user_data_info_ptr;
	UINT					i;
	LPOSTR      			octet_string_ptr;

	/*
	 * Return an error if no user data is passed in.
	 */
	if (number_of_members == 0)
		return (GCC_BAD_USER_DATA);

	for (i = 0; i < number_of_members; i++)
	{
		/*
		 * Create a new "info" structure to hold the user data internally.
		 */
		DBG_SAVE_FILE_LINE
		user_data_info_ptr = new USER_DATA;
		if (user_data_info_ptr != NULL)
		{
		    user_data_info_ptr->poszOctetString = NULL;

			/*
			 * Create a new CObjectKeyContainer object which will be used to store
			 * the "key" portion of the object data internally.
			 */
    		DBG_SAVE_FILE_LINE
			user_data_info_ptr->key = new CObjectKeyContainer(&user_data_list[i]->key, &rc);
			if (user_data_info_ptr->key == NULL)
			{
				ERROR_OUT(("UserData::CopyUserDataList: Error creating new CObjectKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
			else if (rc != GCC_NO_ERROR)
			{
				ERROR_OUT(("UserData::CopyUserDataList: Error creating new CObjectKeyContainer - bad data"));
				goto MyExit;
    		}

			/*
			 * Store the optional user data octet string in the list.
			 */
			octet_string_ptr = user_data_list[i]->octet_string;

			if ((octet_string_ptr != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * Create a new Rogue Wave string container to hold the
				 * octet string.
				 */
				if (NULL == (user_data_info_ptr->poszOctetString = ::My_strdupO2(
									octet_string_ptr->value,
									octet_string_ptr->length)))
				{	
					ERROR_OUT(("UserData::CopyUserDataList: can't create octet string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
			{
				ASSERT(NULL == user_data_info_ptr->poszOctetString);
			}
		}
		else
		{
			ERROR_OUT(("UserData::CopyUserDataList: can't create USER_DATA"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		/*
		 * Insert the pointer to the USER_DATA structure into the Rogue Wave list.
		 */
		m_UserDataItemList.Append(user_data_info_ptr);
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete user_data_info_ptr;
    }

	return rc;
}

/*
 *	GCCError	UnPackUserDataFromPDU (PSetOfUserData		set_of_user_data)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine unpacks the user data from the "PDU" form into the
 *		internal form which is maintained as a Rogue Wave list of USER_DATA
 *		structures.
 *
 *	Formal Parameters:
 *		set_of_user_data	(i) The "PDU" user data list to copy.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
UnPackUserDataFromPDU(PSetOfUserData set_of_user_data)
{
	PSetOfUserData		pUserData;
	GCCError			rc = GCC_NO_ERROR;

    for (pUserData = set_of_user_data; NULL != pUserData; pUserData = pUserData->next)
	{ 
		/*
		 * Convert the user data elements into the internal format which
		 * is a USER_DATA structure and insert the pointers to the 
		 * USER_DATA structures into the m_UserDataItemList.
		 */  
		if (ConvertPDUDataToInternal(pUserData) != GCC_NO_ERROR)
		{
			ERROR_OUT(("CUserDataListContainer::UnPackUserDataFromPDU: Error converting PDU data to internal"));
			rc = GCC_ALLOCATION_FAILURE;
			break;
		}
	}

	return rc;
}

/*
 *	GCCError	ConvertPDUDataToInternal ( PSetOfUserData		user_data_ptr)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine converts an individual user data element from the "PDU" 
 *		structure form into	the internal form which is a USER_DATA	
 *		structure.
 *
 *	Formal Parameters:
 *		user_data_ptr		(i) The "PDU" user data list to copy.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
ConvertPDUDataToInternal(PSetOfUserData user_data_ptr)
{
	USER_DATA   		*user_data_info_ptr;
	GCCError			rc = GCC_NO_ERROR;

	DBG_SAVE_FILE_LINE
	user_data_info_ptr = new USER_DATA;
	if (user_data_info_ptr != NULL)
	{
	    user_data_info_ptr->poszOctetString = NULL;

		/*
		 * Create a new CObjectKeyContainer object which will be used to store the
		 * "key" portion of the user data internally.  If an error occurs
		 * constructing the key report it.  Otherwise, check for any user data
		 * which may need to be stored.	 Note that any error in creating the 
		 * CObjectKeyContainer object is reported as an allocation failure.  An error
		 * could occur if a bad object	key was received as PDU data but this 
		 * would have originated from some other provider since we validate all
		 * object keys created locally.  We therefore report it as an allocation
		 * failure.
		 */
		DBG_SAVE_FILE_LINE
		user_data_info_ptr->key = new CObjectKeyContainer(&user_data_ptr->user_data_element.key, &rc);
		if ((user_data_info_ptr->key == NULL) || (rc != GCC_NO_ERROR))
		{
			ERROR_OUT(("UserData::ConvertPDUDataToInternal: Error creating new CObjectKeyContainer"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
		else
		{
			/*
			 * The object key was successfully saved so store any actual user 
			 * data in the list if it is present.
			 */
			if (user_data_ptr->user_data_element.bit_mask & USER_DATA_FIELD_PRESENT)
			{
				if (NULL == (user_data_info_ptr->poszOctetString = ::My_strdupO2(
								user_data_ptr->user_data_element.user_data_field.value,
								user_data_ptr->user_data_element.user_data_field.length)))
				{	
					ERROR_OUT(("UserData::ConvertPDUDataToInternal: can't create octet string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
			{
				ASSERT(NULL == user_data_info_ptr->poszOctetString);
			}
		}

		/*
		 * Initialize the structure pointers to NULL and insert the pointer
		 * to the USER_DATA structure into the Rogue Wave list.
		 */
		m_UserDataItemList.Append(user_data_info_ptr);
	}
	else
	{
		ERROR_OUT(("UserData::ConvertPDUDataToInternal: can't create USER_DATA"));
		rc = GCC_ALLOCATION_FAILURE;
		// goto MyExit;
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete user_data_info_ptr;
    }

	return rc;
}

/*
 *	GCCError	ConvertUserDataInfoToPDUUserData (	
 *									USER_DATA		*user_data_info_ptr,
 *									PSetOfUserData		pdu_user_data_ptr)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine converts the user data from the internal form which is a 
 *		USER_DATA structure into the "PDU" structure form "SetOfUserData".
 *
 *	Formal Parameters:
 *		user_data_info_ptr	(i) The internal user data structure to convert.
 *		pdu_user_data_ptr	(o)	The structure to hold the PDU data after
 *									conversion.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	The internal key pointer was
 *												corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
ConvertUserDataInfoToPDUUserData(USER_DATA *user_data_info_ptr, PSetOfUserData pdu_user_data_ptr)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Initialize the user data bit mask to zero.
	 */
	pdu_user_data_ptr->user_data_element.bit_mask = 0;

	/*
	 * Fill in the octet string pointer and length if the octet string 
	 * exists.  Set the bit mask indicating that the string exists.
	 */
	if (user_data_info_ptr->poszOctetString != NULL)
	{
		pdu_user_data_ptr->user_data_element.user_data_field.value =
				user_data_info_ptr->poszOctetString->value;
		pdu_user_data_ptr->user_data_element.user_data_field.length =
				user_data_info_ptr->poszOctetString->length;

		pdu_user_data_ptr->user_data_element.bit_mask |= USER_DATA_FIELD_PRESENT;
	}
	
	/*
	 * Fill in the object key data.
	 */
	if (user_data_info_ptr->key != NULL)
	{
		/*
		 * Retrieve the "PDU" object key data from the internal CObjectKeyContainer
		 * object.
		 */
		if (user_data_info_ptr->key->GetObjectKeyDataPDU (
				&pdu_user_data_ptr->user_data_element.key) != GCC_NO_ERROR)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("UserData::ConvertUserDataInfoToPDUUserData: no valid UserDataInfo key"));
		rc = GCC_INVALID_PARAMETER;
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\hash2.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);
/*	hash.cpp
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the implementation of a dictionary data structure.
 *
 */


#define MyMalloc(size)	LocalAlloc (LMEM_FIXED, (size))
#define MyFree(ptr)		LocalFree ((HLOCAL) (ptr))
#define Max(a,b)		(((a) > (b)) ? (a) : (b))


/*  Function:  Constructor
 *
 *	Parameters:
 *		num_of_buckets:		Number of buckets in the dictionary
 *		dtype:				Dictionary type
 *
 *	Return value:
 *		None
 */

DictionaryClass::DictionaryClass (ULONG num_of_buckets, DictionaryType dtype) :
	Type (dtype), NumOfExternItems (0)
{
	DWORD				i;	
	PDICTIONARY_ITEM	p;	// Goes through the initially allocated dictionary items to initialize the stack

	NumOfBuckets = Max (num_of_buckets, DEFAULT_NUMBER_OF_BUCKETS);

	/* Allocate the space needed for the dictionary */
	dwNormalSize = NumOfBuckets * (4 * sizeof (PDICTIONARY_ITEM) + 3 * sizeof (DICTIONARY_ITEM));
	Buckets = (PDICTIONARY_ITEM *) MyMalloc (dwNormalSize);
	if (Buckets == NULL)
		return;

	/* Initialize the Buckets */
	for (i = 0; i < NumOfBuckets; i++)
		Buckets[i] = NULL;

	// Initialize the class iterator
	pCurrent = NULL;

	/* Initialize the Dictionary items array.
	 * This is a stack of pointers to the real dictionary items. The stack is initialized with
	 * the addresses of the dictionary items
	 */

	ItemArray = (PDICTIONARY_ITEM *) ((PBYTE) Buckets + NumOfBuckets * sizeof (PDICTIONARY_ITEM));
	ItemCount = 3 * NumOfBuckets;

	p = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
	for (i = 0; i < ItemCount; i++)
		ItemArray[i] = p++;
}


/*  Function:  Copy Constructor
 *
 *	Parameters:
 *		original:	The original dictionary to make a copy of
 *
 *	Return value:
 *		None
 *
 *	Note:
 *		This copy constructor will work ONLY for DWORD_DICTIONARY dictionaries.
 *		It will NOT work for the string dictionary types.
 */


DictionaryClass::DictionaryClass (const DictionaryClass& original)
{
	DWORD			 i;
	PDICTIONARY_ITEM p, q, r;

	NumOfBuckets = original.NumOfBuckets;
	Type = original.Type;
	NumOfExternItems = original.NumOfExternItems;

	// Allocate the space needed for the dictionary
	dwNormalSize = original.dwNormalSize;
	Buckets = (PDICTIONARY_ITEM *) MyMalloc (dwNormalSize);
	if (Buckets == NULL)
		return;

	// Initialize the class iterator
	pCurrent = NULL;

	/* Initialize the Dictionary items array */
	ItemArray = (PDICTIONARY_ITEM *) ((PBYTE) Buckets + NumOfBuckets * sizeof (PDICTIONARY_ITEM));
	ItemCount = 3 * NumOfBuckets;

	// Traverse the whole original hash sturcture to create the copy
	// p: goes through the original items
	// q: goes through current instance's items and initializes them
	// r: remembers the previous item in the new instance so that its "next" field could be set

	q = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
	for (q--, i = 0; i < NumOfBuckets; i++) {
		for (r = NULL, p = original.Buckets[i]; p != NULL; p = p->next) {
			
			// Check if there are unused items in the current dictionary
			if (ItemCount <= 0) {
				q = (PDICTIONARY_ITEM) MyMalloc (sizeof (DICTIONARY_ITEM));
				if (q == NULL)
					break;
			}
			else {
				ItemCount--;
				q++;
			}

			q->value = p->value;
			q->key = p->key;
			if (p == original.Buckets[i])
				Buckets[i] = q;
			else
				r->next = q;
			r = q;
		}

		// Set the "next" field for the last item in the bucket
		if (r == NULL)
			Buckets[i] = NULL;
		else
			r->next = NULL;
	}

	// Initialize the rest of the ItemArray array
	for (i = 0; i < ItemCount; i++)
		ItemArray[i] = q++;

}


/*  Function:  Destructor
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		None
 *
 */


DictionaryClass::~DictionaryClass ()
{
	DWORD			 i;
	DWORD_PTR  		 dwOffset;		// Offset of the dictionary item.  If the offset does not indicate
									// that the item is from the initially allocated array, it has to
									// be freed.
	PDICTIONARY_ITEM p, q;

	if (Buckets != NULL) {

		// Go through the buckets to free the non-native items
		for (i = 0; i < NumOfBuckets; i++)
			for (p = Buckets[i]; p != NULL; ) {
				if (Type >= STRING_DICTIONARY)
					MyFree (p->key);
				dwOffset = (PBYTE) p - (PBYTE) Buckets;
				if (dwOffset < dwNormalSize)
					p = p->next;
				else {
					// if the item was not allocated in the initialization, we should free it.
					q = p;
					p = p->next;	
					MyFree (q);
				}
			}
					
		MyFree (Buckets);
		Buckets = NULL;
	}
}


/*  Function:  hashFunction
 *
 *	Parameters:
 *		key:	The key value
 *
 *	Return value:
 *		An integer in the range [0..NumOfBuckets-1] that indicates the bucket used for the "key".
 *
 */


DWORD DictionaryClass::hashFunction (DWORD_PTR key)
{
	if (Type >= STRING_DICTIONARY)
		return (*((unsigned char *) key) % NumOfBuckets);
	return (DWORD)(key % NumOfBuckets);
}


/*  Function:  LengthStrcmp
 *
 *	Parameters:
 *		DictionaryKey:	Pointer to dictionary storage that keeps a length-sensitive string (which
 *						is a length followed by a string of that length.
 *		ChallengeKey:	Pointer to the length-sensitive key that is compared with the "DictionaryKey"
 *		length:			The length of the "ChallengeKey" string
 *
 *	Return value:
 *		0 if the "DictionaryKey" and "ChallengeKey" strings are the same. 1, otherwise.
 *
 *	Note:
 *		This function is only used for dictionaries of type LENGTH_STRING_DICTIONARY.
 */

int DictionaryClass::LengthStrcmp (DWORD_PTR DictionaryKey, DWORD_PTR ChallengeKey, ULONG length)
{
	ULONG					 i;
	char					*pDictionaryChar;	// Goes through the dictionary key string
	char					*pChallengeChar;	// Goes through the challenge string

	// Compare the lengths first
	if (length != * (ULONG *) DictionaryKey)
		return 1;

	// Now, compare the strings themselves
	pDictionaryChar	= (char *) (DictionaryKey + sizeof (ULONG));
	pChallengeChar = (char *) ChallengeKey;
	for (i = 0; i < length; i++)
		if (*pDictionaryChar++ != *pChallengeChar++)
			return 1;

	return 0;
}


/*  Function:  insert
 *		Inserts (key, value) pair in the dictionary
 *
 *	Parameters:
 *		new_key:	The new key that has to be inserted in the dictionary
 *		new_value:	The value associated with the "new_key"
 *		length:		Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of the new key
 *
 *	Return value:
 *		TRUE, if the operation succeeds, FALSE, otherwise.
 *
 *	Note:
 *		If the "new_key" is already in the dictionary, the (new_key, new_value) pair is NOT
 *		inserted (the dictionary remains the same), and the return value is TRUE.
 */


BOOL DictionaryClass::insert (DWORD_PTR new_key, DWORD_PTR new_value, ULONG length)
{
	PDICTIONARY_ITEM	pNewItem;			// Points to the allocated new dictionary item
	PDICTIONARY_ITEM	p;					// Goes through the bucket for the "new_key", searching for "new_key"
	DWORD				hash_val;			// The bucket ID for "new_key"
	BOOL				bIsNative = TRUE;	// TRUE, if the new allocated dictionary item is from the cache, FALSE otherwise

	if (Buckets == NULL)
		return FALSE;

	// Find if the item is already in the bucket, and if it's not, where it will get added.
	p = Buckets[hash_val = hashFunction (new_key)];

	ASSERT (hash_val < NumOfBuckets);

	if (p != NULL) {
		switch (Type) {
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (; lstrcmp ((LPCTSTR) p->key, (LPCTSTR) new_key) && p->next != NULL; p = p->next);
			if (0 == lstrcmp ((LPCTSTR) p->key, (LPCTSTR) new_key)) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (; LengthStrcmp (p->key, new_key, length) && p->next != NULL; p = p->next);
			if (0 == LengthStrcmp (p->key, new_key, length)) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		default:
			ASSERT (length == 0);
			for (; p->key != new_key && p->next != NULL; p = p->next);
			if (p->key == new_key) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		}
	}

	// Allocate the new item
	if (ItemCount > 0)
		pNewItem = ItemArray[--ItemCount];		// from the cache
	else {										// the cache is empty, we have to malloc the new item
		pNewItem = (PDICTIONARY_ITEM) MyMalloc (sizeof (DICTIONARY_ITEM));
		if (pNewItem == NULL)
			return FALSE;
		bIsNative = FALSE;
		NumOfExternItems++;
	}

	ASSERT (pNewItem != NULL);

	// Fill in the "key" field of the new item
	switch (Type) {
	case STRING_DICTIONARY:
		ASSERT (length == 0);
		pNewItem->key = (DWORD_PTR) MyMalloc ((lstrlen ((LPCTSTR) new_key) + 1) * sizeof(TCHAR));
		if (pNewItem->key == (DWORD) NULL) {
			if (bIsNative == FALSE) {
				// We have to free the allocated hash item
				MyFree (pNewItem);
				NumOfExternItems--;
			}
			else
				ItemCount++;
			return FALSE;
		}
		lstrcpy ((LPTSTR) pNewItem->key, (LPCTSTR) new_key);
		break;

	case LENGTH_STRING_DICTIONARY:
		ASSERT (length > 0);
		pNewItem->key = (DWORD_PTR) MyMalloc (sizeof (ULONG) + length * sizeof (TCHAR));
		if (pNewItem->key == (DWORD) NULL) {
			if (bIsNative == FALSE) {
				// We have to free the allocated hash item
				MyFree (pNewItem);
				NumOfExternItems--;
			}
			else
				ItemCount++;
			return FALSE;
		}
		* ((ULONG *) (pNewItem->key)) = length;
		memcpy ((void *) (pNewItem->key + sizeof (ULONG)), (void *) new_key, length * sizeof (TCHAR));
		break;

	default:
		ASSERT (length == 0);
		pNewItem->key = new_key;
		break;
	}

	// Fill in the rest of the fields of the new item
	pNewItem->value = new_value;
	pNewItem->next = NULL;

	// Insert the item in its bucket
	if (p == NULL) {
		Buckets[hash_val] = pNewItem;
		return TRUE;
	}
	p->next = pNewItem;

	return TRUE;
}


/*  Function:  remove
 *		Removes (key, value) pair from the dictionary
 *
 *	Parameters:
 *		Key:	The key that has to be removed from the dictionary
 *		length:	Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of the "Key"
 *
 *	Return value:
 *		None.
 *
 */

void DictionaryClass::remove (DWORD_PTR Key, ULONG length)
{
	PDICTIONARY_ITEM	p, q;		// They go through the dictionary items in "Key"'s bucket.
									// p: points to the current dictionary item in the bucket
									// q: points to the previous item
	DWORD				hash_val;	// The bucket ID for "Key"
	
	if (Buckets == NULL)
		return;

	// Find the item in the dictionary
	p = Buckets [hash_val = hashFunction (Key)];

	ASSERT (hash_val < NumOfBuckets);

	switch (Type) {
	case STRING_DICTIONARY:
		ASSERT (length == 0);
		for (q = NULL; p != NULL && lstrcmp ((LPCTSTR) p->key, (LPCTSTR) Key); q = p, p = p->next) ;
		break;

	case LENGTH_STRING_DICTIONARY:
		ASSERT (length > 0);
		for (q = NULL; p != NULL && LengthStrcmp (p->key, Key, length); q = p, p = p->next) ;
		break;

	default:
		ASSERT (length == 0);
		for (q = NULL; p != NULL && p->key != Key; q = p, p = p->next);
		break;
	}

	// Remove the item
	if (p == NULL)
		return;

	if (q == NULL)
		Buckets[hash_val] = p->next;
	else
		q->next = p->next;

	// Free the item found
	ASSERT (p != NULL);

	if (Type >= STRING_DICTIONARY)
		MyFree (p->key);
	hash_val = (DWORD)((PBYTE) p - (PBYTE) Buckets);
	if (hash_val < dwNormalSize)
		ItemArray[ItemCount++] = p;
	else {
		MyFree (p);
		NumOfExternItems--;
	}
}


/* Function:  find
 *		Looks up the key in the dictionary
 *
 * Parameters
 *		Key:	The key to lookup
 *		pValue: Pointer to receive the value associated with "Key"
 *				It can be NULL, if we just try to find whether "Key" is in the dictionary
 *		length:	Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of "Key"
 *
 * Return value:
 *		FALSE, if "Key" is not found in the dictionary
 *		TRUE, otherwise.
 */

BOOL DictionaryClass::find (DWORD_PTR Key, PDWORD_PTR pValue, ULONG length)
{
	PDICTIONARY_ITEM	p;		// Goes through the dictionary items in "Key"'s bucket.

	if (Buckets == NULL) {
		if (pValue != NULL)
			*pValue = 0;
		return FALSE;
	}

	// Find the item in the dictionary
	p = Buckets [hashFunction (Key)];

	switch (Type) {
	case STRING_DICTIONARY:
		ASSERT (length == 0);
		for (; p != NULL && lstrcmp ((LPCTSTR) p->key, (LPCTSTR) Key); p = p->next) ;
		break;

	case LENGTH_STRING_DICTIONARY:
		ASSERT (length > 0);
		for (; p != NULL && LengthStrcmp (p->key, Key, length); p = p->next) ;
		break;

	default:
		ASSERT (length == 0);
		for (; p != NULL && p->key != Key; p = p->next);
		break;
	}

	if (p == NULL) {
		// we did not find the "Key"
		if (pValue != NULL)
			*pValue = 0;
		return FALSE;
	}

	// "Key" was found
	if (pValue != NULL)
		*pValue = p->value;
	return TRUE;

}


/* Function:  iterate
 *		Iterates through the items of a dictionary.  It remembers where it has
 *		stopped during the last call and starts from there.
 *
 * Parameters
 *		pValue:	Pointer to DWORD that will hold the next value from the dictionary.
 *				It can be NULL.
 *		pKey:	Pointer to DWORD or unsigned short value to receive the key associated with the value.
 *				It can be NULL.
 *
 * Return value:
 *		FALSE, when we reach the end of the dictionary
 *		TRUE, otherwise.  Then, *pKey and *pValue are valid
 *
 */

BOOL DictionaryClass::iterate (PDWORD_PTR pValue, PDWORD_PTR pKey)
{

	if (Buckets == NULL)
		return FALSE;

	if (pCurrent == NULL)
		// start from the 1st item in the dictionary
		pCurrent = Buckets[ulCurrentBucket = 0];
	else
		pCurrent = pCurrent->next;

	// Advance "pCurrent" until it's not NULL, or we reach the end of the dictionary.
	for (; ulCurrentBucket < NumOfBuckets; pCurrent = Buckets[++ulCurrentBucket]) {
		if (pCurrent != NULL) {
			// we found the next item
			if (pKey)
				*pKey = pCurrent->key;
			if (pValue)
				*pValue = pCurrent->value;
			return TRUE;
		}
	}

	pCurrent = NULL;
	return FALSE;
}


/* Function:  isEmpty
 *
 * Parameters
 *		None.
 *
 * Return value:
 *		TRUE, if the dictionary is empty.  FALSE, otherwise.
 *
 */

BOOL DictionaryClass::isEmpty (void)
{
	DWORD i;

	if (Buckets == NULL)
		return TRUE;

	for (i = 0; i < NumOfBuckets; i++)
		if (Buckets[i] != NULL)
			return FALSE;

	return TRUE;
}


/* Function:  clear
 *		Clears up the dictionary.  No (key, value) pairs are left in the dictionary.
 *
 * Parameters:
 *		None.
 *
 * Return value:
 *		None.
 *
 */

void DictionaryClass::clear (void)
{

	DWORD			 i;			// Goes through the "Buckets" array
	DWORD_PTR		 dwOffset;	// The offset of a dictionary item is used to determine
								// whether it's a native item (that needs to be returned to the cache),
								// or not (and needs to be freed).
	PDICTIONARY_ITEM p, q;		// Go through the items in a bucket

	if (Buckets != NULL) {
		// Go through the buckets to free the non-native items
		for (i = 0; i < NumOfBuckets; i++) {
			for (p = Buckets[i]; p != NULL; ) {
				if (Type >= STRING_DICTIONARY)
					MyFree (p->key);

				// Compute the offset of the current dictionary item
				dwOffset = (PBYTE) p - (PBYTE) Buckets;
				if (dwOffset < dwNormalSize)
					p = p->next;
				else {
					// if the item was not allocated in the initialization, we should free it.
					q = p;
					p = p->next;	
					MyFree (q);
				}
			}
			Buckets[i] = NULL;
		}

		// Initialize the class iterator
		pCurrent = NULL;

		/* Initialize the Dictionary items array */
		ItemCount = 3 * NumOfBuckets;
		p = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
		for (i = 0; i < ItemCount; i++)
			ItemArray[i] = p++;

		NumOfExternItems = 0;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\framer.h ===
/*    Framer.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the packet frame base class.  This class defines the behavior
 *        for other packet framers that inherit from this class.  Some packet
 *        framing definitions can be found in RFC1006 and Q.922
 *    
 *    Caveats:
 *
 *    Authors:
 *        James W. Lawwill
 */

#ifndef _PACKET_FRAME_H_
#define _PACKET_FRAME_H_


typedef enum
{
    PACKET_FRAME_NO_ERROR,
    PACKET_FRAME_DEST_BUFFER_TOO_SMALL,
    PACKET_FRAME_PACKET_DECODED,
    PACKET_FRAME_ILLEGAL_FLAG_FOUND,
    PACKET_FRAME_FATAL_ERROR
}
    PacketFrameError;


class PacketFrame
{
public:

        virtual    PacketFrameError    PacketEncode (
                                        PUChar        source_address, 
                                        UShort        source_length,
                                        PUChar        dest_address,
                                        UShort        dest_length,
                                        DBBoolean    prepend_flag,
                                        DBBoolean    append_flag,
                                        PUShort        packet_size) = 0;
                                    
        virtual    PacketFrameError    PacketDecode (
                                        PUChar        source_address,
                                        UShort        source_length,
                                        PUChar        dest_address,
                                        UShort        dest_length,
                                        PUShort        bytes_accepted,
                                        PUShort        packet_size,
                                        DBBoolean    continue_packet) = 0;
        virtual    Void                GetOverhead (
                                        UShort        original_packet_size,
                                        PUShort        max_packet_size) = 0;


};
typedef    PacketFrame    *    PPacketFrame;

#endif


/*    
 *    PacketFrameError    PacketFrame::PacketEncode (
 *                                        PUChar        source_address, 
 *                                        UShort        source_length,
 *                                        PUChar        dest_address,
 *                                        UShort        dest_length,
 *                                        DBBoolean    packet_start,
 *                                        DBBoolean    packet_end,
 *                                        PUShort        packet_size) = 0;
 *
 *    Functional Description
 *        This function receives takes the source data and encodes it.
 *
 *    Formal Parameters
 *        source_address    - (i)    Address of source buffer
 *        source_length    - (i)    Length of source buffer
 *        dest_address    - (i)    Address of destination buffer.
 *        dest_length        - (i)    Length of destination buffer.
 *        packet_start    - (i)    This is the beginning of a packet.
 *        packet_end        - (i)    This is the end of a packet.
 *        packet_size        - (o)    Size of packet after encoding
 *
 *    Return Value
 *        PACKET_FRAME_NO_ERROR                -    No error
 *        PACKET_FRAME_FATAL_ERROR            -    Fatal error during encode
 *        PACKET_FRAME_DEST_BUFFER_TOO_SMALL    -    Self-explanatory
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    PacketFrameError    PacketFrame::PacketDecode (
 *                                        PUChar        source_address,
 *                                        UShort        source_length,
 *                                        PUChar        dest_address,
 *                                        UShort        dest_length,
 *                                        PUShort        bytes_accepted,
 *                                        PUShort        packet_size,
 *                                        DBBoolean    continue_packet) = 0;
 *
 *    Functional Description
 *        This function takes the stream data passed in and decodes it into a
 *        packet
 *        
 *    Formal Parameters
 *        source_address    - (i)    Address of source buffer.  If this parm is 
 *                                NULL, continue using the current address.
 *        source_length    - (i)    Length of source buffer
 *        dest_address    - (i)    Address of destination buffer.  If this address
 *                                is NULL, continue using current buffer.
 *        dest_length        - (i)    Length of destination buffer.
 *        bytes_accepted    - (o)    Number of bytes processed before return
 *        packet_size        - (o)    Size of packet after decoding
 *        continue_packet    - (i)    Restart decoding
 *
 *    Return Value
 *        PACKET_FRAME_NO_ERROR                -    No error
 *        PACKET_FRAME_FATAL_ERROR            -    Fatal error during encode
 *        PACKET_FRAME_DEST_BUFFER_TOO_SMALL    -    Self-explanatory
 *        PACKET_FRAME_PACKET_DECODED            -    Self-explanatory
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    Void    PacketFrame::GetOverhead (
 *                            UShort    original_packet_size,
 *                            PUShort    max_packet_size) = 0;
 *
 *    Functional Description
 *        This returns the new maximum packet size
 *
 *    Formal Parameters
 *        original_packet_size    - (i)
 *        max_packet_size            - (o)    new maximum packet size
 *
 *    Return Value
 *        PACKET_FRAME_NO_ERROR    -    No error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\fsdiag2.h ===
// fsdiag.h


#ifndef	_FSDIAG2_H_
#define	_FSDIAG2_H_

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>

#if defined(_DEBUG)

VOID T120DiagnosticCreate(VOID);
VOID T120DiagnosticDestroy(VOID);

#define TRACE_OUT_EX(z,s)	(MLZ_TraceZoneEnabled(z) || MLZ_TraceZoneEnabled(MLZ_FILE_ZONE))  ? (MLZ_TraceOut s) : 0

#else

#define T120DiagnosticCreate()
#define T120DiagnosticDestroy()
#define DEBUG_FILEZONE(z)

#define TRACE_OUT_EX(z,s)

#endif // _DEBUG


#ifdef _DEBUG

enum
{
    ZONE_T120_T123PSTN = BASE_ZONE_INDEX,
};

extern UINT MLZ_FILE_ZONE;

#define DEBUG_FILEZONE(z)  static UINT MLZ_FILE_ZONE = (z)

#endif // _DEBUG

#endif // _FSDIAG_


// lonchanc: this must be outside the _FSDIAG_ protection.
#if defined(_DEBUG) && defined(INIT_DBG_ZONE_DATA)

static const PSTR c_apszDbgZones[] =
{
	"T.123",				// debug zone module name
	DEFAULT_ZONES
    TEXT("T123 PSTN"),      // ZONE_T120_T123PSTN
};

UINT MLZ_FILE_ZONE = ZONE_T120_T123PSTN;

#endif // _DEBUG && INIT_DBG_ZONE_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\memmgr2.cpp ===
#include "precomp.h"
/*
 *	memmgr.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the MemoryManager class.  This
 *		file contains the code necessary to allocate and distribute memory
 *		in the form of Memory objects.
 *
 *	Protected Instance Variables:
 *		Memory_Buffer
 *			This is the base address for the large memory buffer that the
 *			Memory Manager object allocates during instantiation.  This is
 *			remembered so that the buffer can be freed when the Memory Manager
 *			object is destroyed.
 *		Memory_Information
 *			This is a pointer to the structure in memory that contains general
 *			information about the memory being managed by this object.
 *
 *	Protected Member Functions:
 *		ReleaseMemory
 *			This is a private function releases memory used by a Memory object
 *			by putting it back into the proper free stack list.
 *		CalculateMemoryBufferSize
 *		AllocateMemoryBuffer
 *		InitializeMemoryBuffer
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

DWORD MemoryManager::dwSystemPageSize = 0;

/*
 *	MemoryManager ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the default constructor for this class.  It does nothing and
 *		only exists to allow classes to derive from this one without having to
 *		invoke the defined constructor.
 */
MemoryManager::MemoryManager () :
		pExternal_Block_Information (NULL), fIsSharedMemory (TRUE),
		bAllocs_Restricted (TRUE), Max_External_Blocks (0)
{
}

/*
 *	MemoryManager ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the MemoryManager class.  It calculates
 *		how much total memory will be required to hold all the blocks
 *		asked for in the memory template array that is passed in.  It then
 *		allocates all of that memory in one operating system call.  It then
 *		builds a set of free stacks, each of which contains all the blocks
 *		of a particular size.
 */
MemoryManager::MemoryManager (
		PMemoryTemplate		memory_template,
		ULong				memory_count,
		PMemoryManagerError	memory_manager_error,
		ULong				ulMaxExternalBlocks,
		BOOL			bAllocsRestricted) :
		bAllocs_Restricted (bAllocsRestricted),
		fIsSharedMemory (FALSE), Max_External_Blocks (0)
{
	ULong		memory_buffer_size;

    *memory_manager_error = MEMORY_MANAGER_NO_ERROR;

	/*
	 *	Calculate the amount of memory required for this memory manager
	 *	(including all management structures).
	 */
	memory_buffer_size = CalculateMemoryBufferSize (memory_template,
			memory_count, NULL);

	/*
	 *	Allocate the memory buffer.
	 */
	AllocateMemoryBuffer (memory_buffer_size);

	/*
	 *	If the allocation succeeded, then initialize the memory buffer so that
	 *	it can be used.
	 */
	if (Memory_Buffer != NULL)
	{
		/*
		 *	Initialize the External block information dictionary.
		 *	This is only for allocations that do not come from preallocated
		 *	buffers.
		 */
		if (ulMaxExternalBlocks > 0) {
			pExternal_Block_Information = new BlockInformationList (ulMaxExternalBlocks / 3);

			if (NULL != pExternal_Block_Information) {
				Max_External_Blocks = ulMaxExternalBlocks;
			}
			else
			{
				/*
				 *	We were unable to allocate memory for the pre-allocated
		 		 *	memory pool.
			 	 */
				ERROR_OUT(("MemoryManager::MemoryManager: "
						"failed to allocate the external block information dictionary"));
				*memory_manager_error = MEMORY_MANAGER_ALLOCATION_FAILURE;
			}
		}

		if (*memory_manager_error != MEMORY_MANAGER_ALLOCATION_FAILURE) {
			/*
			 *	Initialize the memory buffer.  Note that no error can occur doing
			 *	this, since the allocation has already succeeded.
			 */
			InitializeMemoryBuffer (memory_template, memory_count);

			/*
			 *	Indicate that no error occured.
			 */
			TRACE_OUT(("MemoryManager::MemoryManager: allocation successful"));
			TRACE_OUT(("MemoryManager::MemoryManager: Allocated %d memory blocks", GetBufferCount()));
			*memory_manager_error = MEMORY_MANAGER_NO_ERROR;
		}
	}
	else
	{
		/*
		 *	We were unable to allocate memory for the pre-allocated
		 *	memory pool.
		 */
		ERROR_OUT(("MemoryManager::MemoryManager: allocation failed"));
		*memory_manager_error = MEMORY_MANAGER_ALLOCATION_FAILURE;
	}
}

/*
 *	~MemoryManager ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the Memory Manager class.  It frees up the
 *		memory allocated for the memory pool (if any).
 */
MemoryManager::~MemoryManager ()
{
	PBlockInformation	lpBlockInfo;
	/*
	 *	Iterate through the external block information list, deleting all
	 *	block information structures contained therein.
	 */
	if (NULL != pExternal_Block_Information)
	{
		pExternal_Block_Information->reset();
		while (pExternal_Block_Information->iterate ((PDWORD_PTR) &lpBlockInfo))
		{
			delete lpBlockInfo;
	    }

		delete pExternal_Block_Information;
	}

	/*
	 *	Free up the memory buffer (if there is one).
	 */
	if (Memory_Buffer != NULL)
	{
		LocalFree ((HLOCAL) Memory_Buffer);
		Memory_Buffer = NULL;
	}
}

/*
 *	PMemory		AllocateMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to allocate a Memory object from the Memory
 *		Manager object.
 */
PMemory		MemoryManager::AllocateMemory (
					PUChar				reference_ptr,
					ULong				length,
					MemoryLockMode		memory_lock_mode)
{
	PFreeStack			free_stack;
	ULong				count;
	PBlockNumber		block_stack;
	BlockNumber			block_number;
	PBlockInformation	block_information;
	PUChar				copy_ptr = NULL;
	PMemory				memory = NULL;

	// TRACE_OUT(("MemoryManager::AllocateMemory: Remaining %d memory blocks", GetBufferCount()));
						
	/*
	 *	If the application requests a block of size zero (0), then simply
	 *	return a NULL without allocating a block.
	 */
	if (length != 0)
	{
		/*
		 *	Walk through the free stack list look for a free stack that meets
		 *	the following two allocation criteria:
		 *
		 *	1.	It must contain blocks that are big enough to hold the
		 *		reference data.  This is why it is important for the block
		 *		sizes to be specified in ascending order in the constructor.
		 *		This code checks for a block that is big enough starting at the
		 *		beginning.  By putting them in ascending order, you are insured
		 *		that the smallest available block will be used.
		 *	2.	It must have enough free blocks left to allow the allocation.
		 *		This is where priority is used.  Right now it is very simple:
		 *		the allocation will succeed if the number of available blocks
		 *		is greater than the passed in priority (which is why a lower
		 *		number actually reflects a higher priority).
		 */
		free_stack = Free_Stack;
		for (count = 0; count < Free_Stack_Count; count++)
		{
			/*
			 *	Check and see if the blocks in this free stack are big enough
			 *	to hold the reference data.  If so, are there enough to satisfy
			 *	this allocation (taking memory priority into consideration).
			 */
			if ((length <= free_stack->block_size) &&
				(free_stack->current_block_count > 0))
			{
				/*
				 *	Calculate the address of the next available block number
				 *	within the block stack.  Then read the block number and
				 *	advance the block stack offset to point to the next block.
				 */
				block_stack = (PBlockNumber) (Memory_Buffer +
						free_stack->block_stack_offset);
				block_number = *block_stack;
				free_stack->block_stack_offset += sizeof (BlockNumber);

				/*
				 *	Calculate the address of the appropriate block information
				 *	structure.  Make sure that the lock count for the newly
				 *	allocated block is zero, and the block is not marked as
				 *	freed.
				 */
				block_information = (PBlockInformation) (Block_Information +
						(sizeof (BlockInformation) * block_number));
				ASSERT (block_information->flags & FREE_FLAG);
				block_information->length = length;
				block_information->lock_count = 0;
				block_information->flags &= (~FREE_FLAG);

				/*
				 *	Decrement the number of blocks remaining, within this free stack.
				 */
				free_stack->current_block_count--;

				/*
				 *	Calculate the address of the newly allocated block.  Then
				 *	break out of the allocation loop to go use the block.
				 */
				copy_ptr = (PUChar) (Memory_Buffer +
						block_information->block_offset);

				ASSERT(copy_ptr != Memory_Buffer);


				/*
				 *	If this is a shared memory manager, and the block is not
				 *	committed, we need to commit the block.
				 */
				if ((TRUE == fIsSharedMemory) && (0 == (block_information->flags & COMMIT_FLAG))) {

					ASSERT ((free_stack->block_size % dwSystemPageSize) == 0);
					ASSERT ((((DWORD_PTR) copy_ptr) % dwSystemPageSize) == 0);

					PUChar temp = (PUChar) VirtualAlloc ((LPVOID) copy_ptr, free_stack->block_size,
														 MEM_COMMIT, PAGE_READWRITE);
					block_information->flags |= COMMIT_FLAG;

					ASSERT (temp == copy_ptr);
					ASSERT (temp != NULL);

					if (copy_ptr != temp) {
						TRACE_OUT((">>>>>#### Copy_ptr: %p, Temp: %p, Committed?: %d",
	        					copy_ptr, temp, block_information->flags & COMMIT_FLAG));
						TRACE_OUT((">>>>>#### Size: %d, Req. length: %d",
    		    				free_stack->block_size, length));
						copy_ptr = NULL;
					}
				}
				break;
			}

			/*
			 *	Point to the next entry in the free stack list.
			 */
			free_stack++;
		}

		/*
		 *	If the memory allocation failed and it's for local memory,
		 *	attempt to allocate external memory to hold the block.
		 */
		if ((copy_ptr == NULL) &&
			((FALSE == bAllocs_Restricted) ||
			((NULL != pExternal_Block_Information) &&
			(Max_External_Blocks > pExternal_Block_Information->entries()))))
		{

			ASSERT (FALSE == fIsSharedMemory);
			/*
			 *	Try allocating from system memory.  Set the free stack to NULL
			 *	to indicate that this block did NOT come from one of our free
			 *	stacks.
			 */
			copy_ptr = (PUChar) LocalAlloc (LMEM_FIXED, length);

			if (copy_ptr != NULL)
			{
				/*
				 *	Allocate a block information structure to hold relevant
				 *	information about this externally allocated block.
				 */
				block_information = new BlockInformation;

				if (block_information != NULL)
				{
					/*
					 *	Fill in the block information structure.  Block offset
					 *	is irrelevant for an externally allocated block.  A
					 *	newly allocated block has a lock count of zero, and
					 *	is not freed.
					 */
					block_information->length = length;
					block_information->lock_count = 0;
					block_information->flags = COMMIT_FLAG;

					/*
					 *	Put the block information structure into a dictionary
					 *	for future use.  This is only necessary for externally
					 *	allocated blocks, since the block information structures
					 *	for internal blocks are in the memory buffer.
					 */
					pExternal_Block_Information->insert ((DWORD_PTR) copy_ptr, (DWORD_PTR) block_information);

					/*
					 *	Set block number to be an
					 *	invalid value to indicate that this block is NOT in
					 *	the internally managed memory buffer.
					 */
					block_number = INVALID_BLOCK_NUMBER;
				}
				else
				{
					/*
					 *	We were unable to allocate the space for the block
					 *	information structure, so we must free the externally
					 *	memory we just allocated.
					 */
					LocalFree ((HLOCAL) copy_ptr);
					copy_ptr = NULL;
				}
			}
		}

		/*
		 *	If there was a block available for the allocation, it is still
		 *	necessary to create the Memory object that will hold the block.
		 */
		if (copy_ptr != NULL)
		{
			ASSERT (block_information->flags == COMMIT_FLAG);
			/*
			 *	Create the Memory object.  If it fails, then cleanly release
			 *	the memory that was to be used for this block.
			 */
			memory = new Memory (reference_ptr, length, copy_ptr,
			    				 block_number, memory_lock_mode);

			if (memory == NULL)
			{
				/*
				 *	If the free stack for the memory is not NULL, then it is
				 *	an internally managed block.  Otherwise, this was an
				 *	externally allocated block that resulted from a critical
				 *	allocation above.
				 */
				if (INVALID_BLOCK_NUMBER != block_number)
				{
					/*
					 *	Adjust the block stack offset to point to the previous
					 *	entry in the list.  Note that it is not necessary to
					 *	put the block number into the list since it still there
					 *	from when we pulled it out above.
					 */
					free_stack->block_stack_offset -= sizeof (BlockNumber);

					/*
					 *	Indicate that the block is currently freed.  Note that
					 *	it is not necessary to calculate the address of the
					 *	block information structure since we did this above.
					 */
					block_information->flags |= FREE_FLAG;

					/*
					 *	Decrement the block counter to indicate that there
					 *	is another block in this free stack.
					 */
					free_stack->current_block_count++;
				}
				else
				{
					/*
					 *	This block was externally allocated, so it must be
					 *	externally freed.  Also eliminate the block information
					 *	structure associated with this memory block.
					 */
					pExternal_Block_Information->remove ((DWORD_PTR) copy_ptr);
					delete block_information;
					LocalFree ((HLOCAL) copy_ptr);
				}
			}
		}
	}
	else
	{
		/*
		 *	The application has attempted to allocate a block of size zero.
		 *	It is necessary to fail the request.
		 */
		ERROR_OUT(("MemoryManager::AllocateMemory: attempt to allocate zero-length block"));
	}

	/*
	 *	Decrement the number of blocks remaining
	 *	in this memory manager as a whole.
	 */
	if ((TRUE == bAllocs_Restricted) && (memory != NULL))
		Memory_Information->current_block_count--;

	return (memory);
}

/*
 *	Void	FreeMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to release a previously allocated Memory object.
 */
Void	MemoryManager::FreeMemory (
				PMemory		memory)
{
	BlockNumber			block_number;
	PBlockInformation	block_information;
	PUChar				copy_ptr;

	/*
	 *	Ask the specified memory object what block number it represents.
	 */
	block_number = memory->GetBlockNumber ();

	/*
	 *	Use the block number to determine if this is an internally
	 *	allocated memory block, or an externally allocated one.
	 */
	if (block_number != INVALID_BLOCK_NUMBER)
	{
		/*
		 *	From that, calculate the address of the block information structure.
		 */
		block_information = (PBlockInformation) (Block_Information +
				(sizeof (BlockInformation) * block_number));
	}
	else
	{
		/*
		 *	This is externally allocated memory, so it must be handled
		 *	differently.  Ask the memory block what the copy pointer is, and
		 *	use that to look up the address of the block information structure.
		 */
		copy_ptr = memory->GetPointer ();
		pExternal_Block_Information->find ((DWORD_PTR) copy_ptr, (PDWORD_PTR) &block_information);
	}

	/*
	 *	Make sure that the indicated memory block has not already been
	 *	freed.
	 */
	if ((block_information->flags & FREE_FLAG) == 0)
	{
		/*
		 *	Mark the memory block as being freed.
		 */
		block_information->flags |= FREE_FLAG;

		/*
		 *	If the lock count for this block has reached zero, we can free
		 *	the block for re-use.  We can also delete the memory object, as it
		 *	is no longer needed.
		 */
		if (block_information->lock_count == 0)
		{
			ReleaseMemory (memory);
			delete memory;
		}
		else
		{
			/*
			 *	If the lock count has not yet reached zero, check to see if the
			 *	memory object is to be deleted anyway.  If the memory lock mode
			 *	is set to "IGNORED", then delete the memory object immediately.
			 */
			if (memory->GetMemoryLockMode () == MEMORY_LOCK_IGNORED)
				delete memory;
		}
	}
	else
	{
		/*
		 *	The memory block has already been freed, so this call will be
		 *	ignored.
		 */
		ERROR_OUT(("MemoryManager::FreeMemory: memory block already freed"));
	}
}

/*
 *	PMemory		CreateMemory ()
 *
 *	Public
 *
 *	Functional Description:
 */
PMemory		MemoryManager::CreateMemory (
					BlockNumber		block_number,
					MemoryLockMode	memory_lock_mode)
{
	ULong				total_block_count = 0;
	PFreeStack			free_stack;
	ULong				count;
	PBlockInformation	block_information;
	PUChar				copy_ptr;
	PMemory				memory = NULL;

	/*
	 *	Make sure that this block number lies within the range handled by
	 *	this memory manager.
	 */
	if (block_number < Memory_Information->total_block_count)
	{
		/*
		 *	We must first walk through the free stack list to determine which
		 *	free stack the specified block is in.  Start by pointing to the
		 *	first free stack.
		 */
		free_stack = Free_Stack;
		for (count = 0; count < Free_Stack_Count; count++)
		{
			/*
			 *	Update the counter which keeps track of how many blocks are
			 *	represented by this free stack and the ones already processed.
			 *	This is used to determine if the specified block number is in
			 *	this free stack.
			 */
			total_block_count += free_stack->total_block_count;

			/*
			 *	Is the block in this free stack?
			 */
			if (block_number < total_block_count)
			{
				/*
				 *	Yes it is.  Claculate the address of the block information
				 *	structure for this block.  Then calculate the address of
				 *	the actual block based on the address of the local memory
				 *	buffer.
				 */
				block_information = (PBlockInformation) (Block_Information +
						(sizeof (BlockInformation) * block_number));
				copy_ptr = (PUChar) (Memory_Buffer +
						block_information->block_offset);
				ASSERT (block_information->flags & COMMIT_FLAG);

				/*
				 *	Create a memory object to represent this block.
				 */
				memory = new Memory (NULL, block_information->length, copy_ptr,
									 block_number, memory_lock_mode);

				if (memory == NULL)
				{
					/*
					 *	Allocation of the memory object failed, so we cannot
					 *	create a memory block at this time.
					 */
					ERROR_OUT(("MemoryManager::CreateMemory: memory object allocation failed"));
				}
				break;
			}

			/*
			 *	The block was not in the last free stack, so point to the
			 *	next one.
			 */
			free_stack++;
		}
	}
	else
	{
		/*
		 *	The specified block number is out of range for this memory manager.
		 *	The request must therefore fail.
		 */
		ERROR_OUT(("MemoryManager::CreateMemory: block number out of range"));
	}

	return (memory);
}


/*
 *	Void	LockMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to lock a Memory object.
 */
Void	MemoryManager::LockMemory (
				PMemory		memory)
{
	BlockNumber			block_number;
	PBlockInformation	block_information;
	PUChar				copy_ptr;

	/*
	 *	Ask the specified memory object what block number it represents.
	 */
	block_number = memory->GetBlockNumber ();

	/*
	 *	Use the block number to determine if this is an internally
	 *	allocated memory block, or an externally allocated one.
	 */
	if (block_number != INVALID_BLOCK_NUMBER)
	{
		/*
		 *	From that, calculate the address of the block information structure.
		 */
		block_information = (PBlockInformation) (Block_Information +
				(sizeof (BlockInformation) * block_number));
	}
	else
	{
		/*
		 *	This is externally allocated memory, so it must be handled
		 *	differently.  Ask the memory block what the copy pointer is, and
		 *	use that to look up the address of the block information structure.
		 */
		copy_ptr = memory->GetPointer ();
		pExternal_Block_Information->find ((DWORD_PTR) copy_ptr, (PDWORD_PTR) &block_information);
	}

	ASSERT (block_information->flags & COMMIT_FLAG);
	/*
	 *	Increment the lock count for the specified memory block.
	 */
	block_information->lock_count++;

}

/*
 *	Void	UnlockMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to unlock a previously locked Memory object.
 */
Void	MemoryManager::UnlockMemory (
				PMemory	memory)
{
	BlockNumber			block_number;
	PBlockInformation	block_information;
	PUChar				copy_ptr;

	/*
	 *	Ask the specified memory object what block number it represents.
	 */
	block_number = memory->GetBlockNumber ();

	/*
	 *	Use the block number to determine if this is an internally
	 *	allocated memory block, or an externally allocated one.
	 */
	if (block_number != INVALID_BLOCK_NUMBER)
	{
		/*
		 *	From that, calculate the address of the block information structure.
		 */
		block_information = (PBlockInformation) (Block_Information +
				(sizeof (BlockInformation) * block_number));
	}
	else
	{
		/*
		 *	This is externally allocated memory, so it must be handled
		 *	differently.  Ask the memory block what the copy pointer is, and
		 *	use that to look up the address of the block information structure.
		 */
		copy_ptr = memory->GetPointer ();
		pExternal_Block_Information->find ((DWORD_PTR) copy_ptr, (PDWORD_PTR) &block_information);
	}

	ASSERT (block_information->flags & COMMIT_FLAG);
	/*
	 *	Make sure that the lock isn't already zero before proceeding.
	 */
	if (block_information->lock_count > 0)
	{
		/*
		 *	Decrement the lock count for the specified memory block.
		 */
		block_information->lock_count--;

		/*
		 *	If the lock count has reached zero and the memory block is
		 *	marked as being freed, then we can free the block for re-use.
		 */
		if ((block_information->lock_count == 0) &&
				(block_information->flags & FREE_FLAG))
		{
			ReleaseMemory (memory);

			/*
			 *	We have now released the memory buffer, so we must check to
			 *	see if we are supposed to destroy the memory object itself.
			 */
			if (memory->GetMemoryLockMode () == MEMORY_LOCK_NORMAL)
				delete memory;
		}
	}
	else
	{
		/*
		 *	The specified block has a lock count of zero already, so ignore
		 *	this call.
		 */
		ERROR_OUT(("MemoryManager::UnlockMemory: memory block already unlocked"));
	}
}

/*
 *	ULong	GetBufferCount ()
 *
 *	Public
 *
 *	Functional Description:
 */
ULong	MemoryManager::GetBufferCount (
						ULong				length)
{
	PFreeStack		free_stack;
	ULong			count;
	ULong			buffer_count;

	if (FALSE == bAllocs_Restricted)
		return (LARGE_BUFFER_COUNT);

	buffer_count = Memory_Information->current_block_count;
	free_stack = Free_Stack;
	for (count = 0; count < Free_Stack_Count; count++)
	{
		/*
		 *	Check and see if the blocks in this free stack are smaller than
		 *	the specified length.  If yes, we need to deduct these buffers.
		 *	Otherwise, we can stop deducting.
		 */
		if (length > free_stack->block_size) {
			buffer_count -= free_stack->current_block_count;

			/*
			 *	Point to the next entry in the free stack list.
			 */
			free_stack++;
		}
		else
			break;
	}

	return (buffer_count);
}

/*
 *	Void	ReleaseMemory (
 *					PMemory		memory)
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to release a Memory object, and free the memory
 *		it represents back to the available pool.
 *
 *	Formal Parameters:
 *		memory
 *			This is a pointer to the Memory object being released.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	MemoryManager::ReleaseMemory (
				PMemory		memory)
{
	PFreeStack			free_stack;
	BlockNumber			block_number;
	PBlockNumber		block_stack;
	PBlockInformation	block_information;
	PUChar				copy_ptr;

	/*
	 *	Ask the specified memory object what block number it represents.
	 */
	block_number = memory->GetBlockNumber ();

	/*
	 *	Use the block number to determine if this is an internally
	 *	allocated memory block, or an externally allocated one.
	 */
	if (block_number != INVALID_BLOCK_NUMBER)
	{
		/*
		 *	From that, calculate the address of the block information structure.
		 */
		 block_information = (PBlockInformation) (Block_Information +
				(sizeof (BlockInformation) * block_number));
				
		/*
		 *	Get the address of the free stack from which this block came.
		 */
		free_stack = (PFreeStack) (Memory_Buffer + block_information->free_stack_offset);

		/*
		 *	Adjust the block stack offset to point to the previous element,
		 *	and then use it to calculate an address and put the block number
		 *	there.  This effectively "pushes" the block number onto the stack.
		 */
		free_stack->block_stack_offset -= sizeof (BlockNumber);
		block_stack = (PBlockNumber) (Memory_Buffer +
				free_stack->block_stack_offset);
		*block_stack = block_number;

		/*
		 *	Indicate that this block is freed.
		 */
		block_information->flags = FREE_FLAG | COMMIT_FLAG;

		/*
		 *	Increment the counter indicating the number of available blocks
		 *	in this free stack.
		 */
		free_stack->current_block_count++;
	}
	else
	{
		/*
		 *	Since the block was allocated from system memory, thats where it
		 *	needs to go back to.
		 */
		copy_ptr = memory->GetPointer ();
		pExternal_Block_Information->find ((DWORD_PTR) copy_ptr, (PDWORD_PTR) &block_information);
		pExternal_Block_Information->remove ((DWORD_PTR) copy_ptr);
		delete block_information;
		LocalFree ((HLOCAL) copy_ptr);
	}

	/*
	 *	Increment the number of blocks available in this memory manager as a whole.
	 */
	if (TRUE == bAllocs_Restricted)
		Memory_Information->current_block_count++;
}

/*
 *	ULong	CalculateMemoryBufferSize (
 *					PMemoryTemplate		memory_template,
 *					ULong				memory_count,
 *					ULong	*			pulCommittedBytes)
 *
 *	Protected
 *
 *	Functional Description:
 *		This member function is used to calculate how much memory will be
 *		required in order to manage the number of memory blocks specified in
 *		the passed in memory template.  Note that this total includes the size
 *		of the memory blocks as well as the amount of memory used for management
 *		functions.
 *
 *	Formal Parameters:
 *		memory_template
 *			This is an array of structures that identify the blocks to be
 *			managed by this object.
 *		memory_count
 *			This is the number of entries in the above array.
 *		pulCommittedBytes
 *			If fIsSharedMemory == FALSE, this can be NULL.  Otherwise, it is
 *			used to return the size of the total memory we need to commit
 *			when the manager is getting initialized.
 *
 *	Return Value:
 *		The required size of the memory buffer for this object.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

ULong	MemoryManager::CalculateMemoryBufferSize (
				PMemoryTemplate		memory_template,
				ULong				memory_count,
 				ULong	*			pulCommittedBytes)
{
	ULong			memory_buffer_size;
	PMemoryTemplate	pMemTemplate;
	ULong			memory_per_block;

	/*
	 *	Claculate the amount of memory that will be required to hold the
	 *	memory information structure and the free stacks.
	 */
	memory_buffer_size = (sizeof (MemoryInformation) +
			(sizeof (FreeStack) * memory_count));

	if (FALSE == fIsSharedMemory) {
		/*
		 *	Add in the amount of memory the block stacks, the block information
		 *	structures, and the memory blocks themselves will take up.
		 */
		for (pMemTemplate = memory_template; pMemTemplate - memory_template < (int) memory_count; pMemTemplate++)
		{
			/*
			 *	The amount of memory required for each managed block of memory can
			 *	be calculated as a sum of the following:
			 *
			 *	1.	sizeof (BlockNumber) - This is the amount of space taken by the
			 *			block number in the block stack.
			 *	2.	sizeof (BlockInformation) - Every managed block of memory has
			 *			a BlockInformation structure associated with it.
			 *	3.	block_size - The actual size of the block.  This is provided
			 *			in the memory template.
			 */
			memory_per_block = sizeof (BlockNumber) + sizeof (BlockInformation) +
										pMemTemplate->block_size;
			memory_buffer_size += (memory_per_block * pMemTemplate->block_count);
		}
	}

	/*
	 *	For shared memory, we need to do a few more extra things:
	 *
	 *	Blocks of size greater or equal to the system's page, need to
	 *	start on a page boundary. In addition, they can be expanded to
	 *	end at a page boundary, too.
	 */
	else {
	
			ULong	reserved_buffer_size = 0;
			ULong	temp;
			
		for (pMemTemplate = memory_template; pMemTemplate - memory_template < (int) memory_count; pMemTemplate++) {		
			if (dwSystemPageSize <= pMemTemplate->block_size) {
				pMemTemplate->block_size = EXPAND_TO_PAGE_BOUNDARY(pMemTemplate->block_size);
				reserved_buffer_size += pMemTemplate->block_count * pMemTemplate->block_size;
			}
			memory_per_block = sizeof (BlockNumber) + sizeof (BlockInformation) +
								pMemTemplate->block_size;
			memory_buffer_size += memory_per_block * pMemTemplate->block_count;
		}
		*pulCommittedBytes = memory_buffer_size - reserved_buffer_size;
		temp = EXPAND_TO_PAGE_BOUNDARY(*pulCommittedBytes);
		temp -= (*pulCommittedBytes);
		*pulCommittedBytes += temp;
		memory_buffer_size += temp;
		ASSERT (*pulCommittedBytes <= memory_buffer_size);
		ASSERT ((memory_buffer_size % dwSystemPageSize) == 0);
		ASSERT ((*pulCommittedBytes % dwSystemPageSize) == 0);
		ASSERT ((reserved_buffer_size % dwSystemPageSize) == 0);
	}

	return (memory_buffer_size);
}


/*
 *	Void	AllocateMemoryBuffer (
 *					ULong		memory_buffer_size)
 *
 *	Protected
 *
 *	Functional Description:
 *		This member function allocates the memory that is managed by an instance
 *		of MemoryManager.  It does this using the standard Malloc macro.
 *
 *	Formal Parameters:
 *		memory_buffer_size
 *			The size of the buffer to be allocated.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		The instance variable Memory_Buffer is set to the address of the
 *		allocated block of memory.  If it is NULL after the return from this
 *		call, that indicates that the memory could not be allocated.
 *
 *	Caveats:
 *		None.
 */
Void	MemoryManager::AllocateMemoryBuffer (
				ULong		memory_buffer_size)
{
	TRACE_OUT(("MemoryManager::AllocateMemoryBuffer: allocating %ld bytes", memory_buffer_size));
	if (memory_buffer_size != 0)
		Memory_Buffer = (HPUChar) LocalAlloc (LMEM_FIXED, memory_buffer_size);
	else
		Memory_Buffer = NULL;
}


/*
 *	Void	InitializeMemoryBuffer (
 *					PMemoryTemplate		memory_template,
 *					ULong				memory_count)
 *
 *	Protected
 *
 *	Functional Description:
 *		This member function is used to initialize the memory buffer for use.
 *		This primarily includes filling in the management structures that lie
 *		at the beginning of the allocated memory block, so that allocations
 *		can take place.
 *
 *	Formal Parameters:
 *		memory_template
 *			This is an array of structures that identify the blocks to be
 *			managed by this object.
 *		memory_count
 *			This is the number of entries in the above array.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

Void	MemoryManager::InitializeMemoryBuffer (
				PMemoryTemplate		memory_template,
				ULong				memory_count)
{
	ULong				block_count = 0;
	ULong				index;
	ULong				memory_information_size;
	ULong				free_stack_size;
	ULong				free_stack_offset;
	ULong				block_stack_size;
	ULong				block_information_size;
	PFreeStack			free_stack;
	PBlockNumber		block_stack;
	PBlockInformation	block_information;
	ULong				block_stack_offset;
	BlockNumber			block_number;
	ULong				block_offset;
	ULong				block_size;
	ULong				count;
	BOOL			fIsFirstTime;

	/*
	 *	Walk through the memory template calculating how many memory blocks
	 *	exist (regardless of size).
	 */
	for (index = 0; index < memory_count; index++)
		block_count += memory_template[index].block_count;

	/*
	 *	Calculate the amount of memory required to hold all the various sections
	 *	of data in the memory buffer.
	 */
	memory_information_size = sizeof (MemoryInformation);
	free_stack_size = sizeof (FreeStack) * memory_count;
	block_stack_size = sizeof (BlockNumber) * block_count;
	block_information_size = sizeof (BlockInformation) * block_count;

	/*
	 *	Initialize all elements of the memory information structure.
	 *	Note that all offsets in this structure are from the beginning of the
	 *	memory buffer.
	 */
	Memory_Information = (PMemoryInformation) Memory_Buffer;
	Memory_Information->free_stack_offset = memory_information_size;
	Memory_Information->free_stack_count = memory_count;
	Memory_Information->block_information_offset =
			memory_information_size + free_stack_size + block_stack_size;
	Memory_Information->total_block_count = block_count;
	if (TRUE == bAllocs_Restricted) {
		// The current_block_count is only needed when allocations are restricted.
		Memory_Information->current_block_count = block_count + Max_External_Blocks;
	}

	/*
	 *	Now initialize the instance variables that point to each list within
	 *	the memory buffer.  These instance variables are later used to resolve
	 *	all other offsets.
	 */
	Free_Stack = (PFreeStack) (Memory_Buffer + memory_information_size);
	Free_Stack_Count = memory_count;
	Block_Information = (Memory_Buffer +
			Memory_Information->block_information_offset);

	/*
	 *	This loop walks through the memory template array again, this time
	 *	filling in the contents of the free stacks, the blocks stacks, and
	 *	the block information structures.
	 */
	fIsFirstTime = TRUE;
	free_stack = Free_Stack;
	free_stack_offset = memory_information_size;
	block_stack_offset = memory_information_size + free_stack_size;
	block_stack = (PBlockNumber) (Memory_Buffer + block_stack_offset);
	block_information = (PBlockInformation) Block_Information;
	block_number = 0;
	block_offset = block_stack_offset + block_stack_size + block_information_size;

	for (index = 0; index < memory_count; index++)
	{
		/*
		 *	Get the block size and count from the template entry.
		 */
		block_size = memory_template[index].block_size;
		block_count = memory_template[index].block_count;

		/*
		 *	Initialize the free stack for this block size, and then point to
		 *	the next free stack in the list.
		 */
		free_stack->block_size = block_size;
		free_stack->total_block_count = block_count;
		free_stack->current_block_count = block_count;
		(free_stack++)->block_stack_offset = block_stack_offset;

		/*
		 *	Adjust the block stack offset to point to the first block number
		 *	of the next free stack (skip past all of the block numbers for
		 *	this free stack).
		 */
		block_stack_offset += (sizeof (BlockNumber) * block_count);

		/*
		 *	The following happens only once in this loop:
		 *	When the memory manager manages shared memory and
		 *	The block size becomes FOR THE 1ST TIME, bigger than
		 *	the page size, then, we need to jump to the next page
		 *	boundary.
		 */
		if ((TRUE == fIsSharedMemory) && (TRUE == fIsFirstTime)
			&& (block_size >= dwSystemPageSize)) {
			fIsFirstTime = FALSE;
			block_offset = EXPAND_TO_PAGE_BOUNDARY(block_offset);
		}
		
		/*
		 *	Initialize the block list for this block size.  Also, increment
		 *	the total number of buffers for each block that is segmented
		 *	off.
		 */
		for (count = 0; count < block_count; count++)
		{
			/*
			 *	Put the block number for this block into the current block
			 *	stack.  Increment both the block stack pointer and the block
			 *	number.
			 */
			*(block_stack++) = block_number++;

			/*
			 *	Fill in the block information structure for this block.  Then
			 *	increment the block information pointer to point to the next
			 *	entry in the list.
			 */
#ifdef _DEBUG
			if ((TRUE == fIsSharedMemory) && (block_size >= dwSystemPageSize)) {
				ASSERT ((block_size % dwSystemPageSize) == 0);
				ASSERT ((block_offset % dwSystemPageSize) == 0);
			}
#endif
			block_information->block_offset = block_offset;
			block_information->free_stack_offset = free_stack_offset;
			if ((TRUE == fIsSharedMemory) && (block_size >= dwSystemPageSize))
				block_information->flags = FREE_FLAG;
			else
				block_information->flags = FREE_FLAG | COMMIT_FLAG;
			block_information++;

			/*
			 *	Adjust the block offset to point to the next block.
			 */
			block_offset += block_size;
		}
		
		free_stack_offset += sizeof (FreeStack);
	}
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\hash2.h ===
/*	hash.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the interface to a dictionary data structure.
 *	Both the key and the value in a dictionary entry are DWORD values.  So, for example, if the
 *  value is really a pointer it has to be converted into a DWORD before being passed into a
 *  member dictionary function.
 *
 */


#ifndef _HASH2_H_
#define _HASH2_H_

#include <windows.h>

#define DEFAULT_NUMBER_OF_BUCKETS	3


typedef enum {
	DWORD_DICTIONARY,			/* The key is a 32-bit unsigned value */
	STRING_DICTIONARY,			/* The key is a NULL-terminated string that is being pointed by
								 * the "key" field in the structure below */
	LENGTH_STRING_DICTIONARY	/* The key is a string with a specific length.  The "key" field
								 * in the structure below, points to memory space containing
								 * the length and a string of that length. */
} DictionaryType;


typedef struct _dictionary_item {
	DWORD_PTR					key;	// The key value, or a pointer to a string (depending on the dictionary type)
	DWORD_PTR					value;	// This is always a 32-bit unsigned value
	struct _dictionary_item		*next;	// Pointer to the next structure in the dictionary bucket
} DICTIONARY_ITEM, *PDICTIONARY_ITEM;


class DictionaryClass
{

public:
	DictionaryClass (ULONG num_of_buckets, DictionaryType dtype = DWORD_DICTIONARY);
	DictionaryClass (const DictionaryClass& original);
	~DictionaryClass ();
	BOOL insert (DWORD_PTR new_key, DWORD_PTR new_value, ULONG length = 0);
	void remove (DWORD_PTR Key, ULONG length = 0);
	BOOL find (DWORD_PTR Key, PDWORD_PTR pValue = NULL, ULONG length = 0);
	BOOL isEmpty ();
	void clear ();
	ULONG entries () {
		return (3 * NumOfBuckets - ItemCount + NumOfExternItems);
	};
	BOOL iterate (PDWORD_PTR pValue = NULL, PDWORD_PTR pKey = NULL);
	void reset () { pCurrent = NULL; };		// Resets the dictionary iterator


private:
	DWORD hashFunction (DWORD_PTR key);
	int LengthStrcmp (DWORD_PTR DictionaryKey, DWORD_PTR ChallengeKey, ULONG length);

	ULONG				 NumOfBuckets;		// Number of dictionary buckets.  Specified during object construction.
	DWORD   			 dwNormalSize;		// Initial space allocated for the dictionary
	PDICTIONARY_ITEM	*Buckets;			// Address of the Buckets array
	PDICTIONARY_ITEM	*ItemArray;			// Pointer to the array of initially allocated dictionary items
	ULONG		 		 ItemCount;			// Number of dictionary items left in the ItemArray
	PDICTIONARY_ITEM	 pCurrent;			// Points to the current dictionary item while we iterate through the dictionary
	ULONG				 ulCurrentBucket;	// Id of the current bucket while we iterate
	DictionaryType		 Type;				// Dictionary type
	ULONG				 NumOfExternItems;	// Number of external dictionary items

};

typedef DictionaryClass * PDictionaryClass;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\memory2.h ===
/*
 *	memory.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Memory class.  Instances of this
 *		class are used to pass data around the system.
 *
 *		Each instance of this class maintains two pointers.  The first is a
 *		pointer to the reference data (or the source data) which this object
 *		is responsible for representing.  The second is a pointer to a copy
 *		buffer, which is a piece of allocated memory that a Memory object
 *		can copy the data into if necessary.
 *
 *		When a Memory object is created, both of these addresses are passed
 *		in to it.  It does not, however, copy the data from the reference
 *		buffer to the copy buffer just yet.  If anyone asks the address of the
 *		buffer, it will simply return the reference pointer.  However, the
 *		first time the buffer is locked, the data will be copied from the
 *		reference buffer to the copy buffer for safe keeping.  In essence,
 *		the lock function tells the Memory object that someone is interested
 *		in the data for longer than the reference buffer will remain valid.
 *
 *		After the object is locked, a call to retrieve a memory pointer will
 *		result in the copy pointer being returned.
 *
 *		Each time the lock function is called, a lock count is incremented.
 *		The copy operation only takes place the first time the buffer is
 *		locked, however.
 *
 *		In addition to maintaining a lock count, this object keeps a flag
 *		indicating whether or not it has been freed by the allocator.  This
 *		freeing really means that the object is enabled to be freed as soon
 *		as the lock count hits zero.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_MEMORY2_H_
#define	_MEMORY2_H_

/*
 *	FreeStack
 *	This is a list container that can be used to hold memory addresses.
 *	This structure is used to keep information about each free stack.  There
 *	is one free stack for each size block being maintained by each memory
 *	manager.
 */
typedef	struct
{
	ULong		block_size;
	ULong		total_block_count;
	ULong		current_block_count;
	ULong		block_stack_offset;
} FreeStack;
typedef	FreeStack *				PFreeStack;

/*
 *	This type is used to represent a block number in the memory manager.  This
 *	is essentially an index used to uniquely identify each block being
 *	maintained by an instance of this class.
 */
typedef	ULong					BlockNumber;
typedef	BlockNumber *			PBlockNumber;

#define	INVALID_BLOCK_NUMBER	0xffffffffL

/*
 *	This type is used to determine when a memory object should be destroyed.
 *	When a memory object is created, this field is set by the owner.  The owner
 *	can then ask for the value of this field at any time to help determine when
 *	the object should be destroyed.  Essentially, this field indicates whether
 *	the global lock count for the memory this object represents should be used
 *	to determine when this object should be destroyed.
 */
typedef	enum
{
	MEMORY_LOCK_NORMAL,
	MEMORY_LOCK_IGNORED
} MemoryLockMode;

/*
 *	This is the class definition for the Memory class.
 */
class Memory;
typedef	Memory *		PMemory;

class Memory
{
	public:
						Memory (PUChar			reference_ptr,
								ULong			length,
								PUChar			copy_ptr,
								BlockNumber		block_number,
								MemoryLockMode	memory_lock_mode);
		virtual			~Memory () { };
		PUChar			GetPointer ()
						{
							return (Copy_Ptr);
						}
		ULong			GetLength ()
						{
							return (Length);
						}
		BlockNumber		GetBlockNumber ()
						{
							return (Block_Number);
						}
		MemoryLockMode	GetMemoryLockMode ()
						{
							return (Memory_Lock_Mode);
						}

	private:

		ULong			Length;
		PUChar			Copy_Ptr;
		BlockNumber		Block_Number;
		MemoryLockMode	Memory_Lock_Mode;
};


/*
 *	Memory (
 *			PUChar		reference_ptr,
 *			ULong		length,
 *			PUChar		copy_ptr,
 *			PFreeStack	free_stack,
 *			BlockNumber	block_number)
 *
 *	Functional Description:
 *		This is the constructor for the Memory class.  All it does is
 *		initialize the instance variable with the passed in values.
 *
 *	Formal Parameters:
 *		reference_ptr (i)
 *			This is a pointer to the data that is to represented by this
 *			Memory object.
 *		length (i)
 *			This is the length of the reference buffer.
 *		copy_ptr (i)
 *			This is the address of an allocated buffer that the Memory object
 *			can use to preserve the contents of the reference buffer if a lock
 *			operation occurs.
 *		free_stack (i)
 *			This is a pointer to a list container that the allocated memory
 *			block came from.  This field is not used internally, and is only
 *			held here in order to improve the performance of the memory
 *			manager that is using Memory objects.
 *		block_number (i)
 *			This is the block number for the memory block that is represented
 *			by this object.  This field is not used internally, and is only
 *			held here in order to improve the performance of the memory
 *			manager that is using Memory objects.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Memory ()
 *
 *	Functional Description:
 *		This is the destructor for the Memory class.  It does nothing at this
 *		time.  Note that it is the responsibility of the memory manager that
 *		is using Memory objects to free up the memory.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		GetLength ()
 *
 *	Functional Description:
 *		This function retrieves the length of the data being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The length of the data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BlockNumber		GetBlockNumber ()
 *
 *	Functional Description:
 *		This function retrieves the block number of the block that is being
 *		represented by this object.  This allows the memory manager to put the
 *		memory block back into the stack very efficiently.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The block number of the internal memory block.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\memmgr2.h ===
/*
 *	memmgr.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MemoryManager class.  This class
 *		is used to efficiently manage the passing of data through a system.
 *		There are two primary techniques it uses to accomplish the goal of
 *		efficiency:
 *
 *		1.	Use of locally managed "blocked" memory.  When this class is
 *			instantiated, it allocates a large block of memory which it then
 *			chops up into various size blocks.  These blocks are then used
 *			to hold data, rather than having to do system calls every time
 *			some memory is needed.
 *
 *		2.	Use of a "copy on lock" algorithm.  When memory is first
 *			allocated, the source data is NOT yet copied to it.  Copy
 *			operations will implicitly use the reference rather than copying
 *			the data.  If the data needs to be retained longer than the
 *			expected life-span of the reference, then a Lock command can be
 *			sent to the block to cause it to be copied.
 *
 *		When an object needs to allocate memory to hold some data, it calls
 *		an allocate function within an object of this class.  Assuming that
 *		the request can be satisfied, a pointer to a Memory object is returned.
 *		This Memory object remembers two addresses: the address of the reference
 *		buffer (where the source data is); and the address of the copy buffer
 *		(which is the buffer allocated to hold the data).  As mentioned above,
 *		the data is NOT copied to the copy buffer as part of the allocation
 *		process.  The data is not copied until the Memory object is locked
 *		for the first time.
 *
 *		Objects of this class keep a list of available buffers.  There is one
 *		list for each size block that is available.  One of the constructor
 *		parameters can be used to control how much data is allocated up front,
 *		and what size blocks it is chopped up into.  This makes this class very
 *		flexible in how it can be used.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_MEMORY_MANAGER2_H_
#define	_MEMORY_MANAGER2_H_


/*
 *	These are the errors that can be returned from some of the memory manager
 *	member functions.
 */
typedef	enum
{
	MEMORY_MANAGER_NO_ERROR,
	MEMORY_MANAGER_ALLOCATION_FAILURE,
	MEMORY_MANAGER_INVALID_PARAMETER
} MemoryManagerError;
typedef	MemoryManagerError *		PMemoryManagerError;

/*
 *	An array of this structure is passed into the constructor to define the
 *	number and size of blocks to be created by this object.
 */
typedef	struct
{
	ULong		block_size;
	ULong		block_count;
} MemoryTemplate;
typedef	MemoryTemplate *			PMemoryTemplate;

/*
 *	This structure is used to maintain general information about the shared
 *	memory region that has to be shared between all users of it.
 */
typedef	struct
{
	ULong		free_stack_offset;
	ULong		free_stack_count;
	ULong		block_information_offset;
	ULong		total_block_count;
	ULong		current_block_count;
} MemoryInformation;
typedef	MemoryInformation *			PMemoryInformation;

/*
 *	This structure is used to keep information about each memory block that is
 *	being managed by an instance of this class.
 */
typedef	struct
{
	ULong		block_offset;
	ULong		length;
	ULong		free_stack_offset;
	ULong		lock_count;
	ULong		flags;
} BlockInformation;
typedef	BlockInformation *			PBlockInformation;

/*
 *	These are the masks for manipulating the flags of a BlockInformation structure
 */
#define		FREE_FLAG		0x1
#define		COMMIT_FLAG		0x2

/*
 *	The following are definitions for macros used to handle space and space
 *	requirements in relation to page boundaries in the system.
 */
#define EXPAND_TO_PAGE_BOUNDARY(p)	(((p) + dwSystemPageSize - 1) & (~ (dwSystemPageSize - 1)))

/*
 *	The following number is used when the caller asks for the number of buffers remaining
 *	within a Memory Manager where allocations are not restricted.  The intention is 
 *	that this number is very large and enough for the caller to think that all its 
 *	allocation requests will succeed.
 */
#define LARGE_BUFFER_COUNT			0x1000
 
/*
 *	These typedefs define a container that is used to hold block information
 *	structure pointers.  This is used to hold information about blocks that
 *	are externally allocated, but are managed by this class.
 */
typedef	DictionaryClass				BlockInformationList;

/*
 *	This is the class definition for the MemoryManager class.
 */
class MemoryManager
{
	public:
							MemoryManager ();
							MemoryManager (
									PMemoryTemplate		memory_template,
									ULong				memory_count,
									PMemoryManagerError	memory_manager_error,
									ULong				ulMaxExternalBlocks,
									BOOL			bAllocsRestricted = TRUE);
		virtual				~MemoryManager ();
		virtual PMemory		AllocateMemory (
									PUChar				reference_ptr,
									ULong				length,
									MemoryLockMode		memory_lock_mode =
															MEMORY_LOCK_NORMAL);
		virtual Void		FreeMemory (
									PMemory				memory);
		virtual	PMemory		CreateMemory (
									BlockNumber			block_number,
									MemoryLockMode		memory_lock_mode =
															MEMORY_LOCK_NORMAL);
		virtual Void		LockMemory (
									PMemory				memory);
		virtual Void		UnlockMemory (
									PMemory				memory);
				ULong		GetBufferCount ()
							{
								return((bAllocs_Restricted) ? Memory_Information->current_block_count : LARGE_BUFFER_COUNT);
							};
		virtual	ULong		GetBufferCount (
									ULong				length);

	private:
				Void		ReleaseMemory (
									PMemory				memory);

	protected:
				ULong		CalculateMemoryBufferSize (
									PMemoryTemplate		memory_template,
									ULong				memory_count,
 									ULong	*			pulCommittedBytes);
				Void		AllocateMemoryBuffer (
									ULong				memory_buffer_size);
				Void		InitializeMemoryBuffer (
									PMemoryTemplate		memory_template,
									ULong				memory_count);

		static DWORD			dwSystemPageSize;
		HPUChar					Memory_Buffer;
		PMemoryInformation		Memory_Information;
		PFreeStack				Free_Stack;
		ULong					Free_Stack_Count;
		HPUChar					Block_Information;
		BlockInformationList   *pExternal_Block_Information;
		ULong					Max_External_Blocks;
		BOOL				fIsSharedMemory;
		BOOL				bAllocs_Restricted;
};
typedef	MemoryManager *		PMemoryManager;

/*
 *	MemoryManager (
 *			PMemoryTemplate		memory_template,
 *			USHORT				memory_count,
 *			PMemoryManagerError	memory_manager_error)
 *
 *	Functional Description:
 *		This is the constructor for the MemoryManager class.  It uses the
 *		information in the specified memory templates to allocate a block
 *		of memory and chop it up into fixed size pieces.  It then puts
 *		these pieces into a set of free block lists, so that it can allocate
 *		memory on an as needed basis.
 *
 *	Formal Parameters:
 *		memory_template
 *			This is the base address of an array of memory template structures.
 *			Each element of this structure specifies how many blocks of a
 *			specified block size should be allocated.  The constructor scans
 *			the array, totaling the required memory, and then makes one memory
 *			allocation call.  It then chops the memory as specified by the
 *			memory templates.  It is VERY important the memory templates be
 *			specified in ascending order of block sizes.  In other words,
 *			smaller blocks should be specified first.
 *		memory_count
 *			This simply indicates how mamy memory templates there are in the
 *			list.
 *		memory_manager_error
 *			This is the return value from the constructor.  If anything besides
 *			MEMORY_MANAGER_NO_ERROR is returned, the object was not able to
 *			initialize itself properly, and should be destroyed immediately
 *			without being used.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~MemoryManager ()
 *
 *	Functional Description:
 *		This is the destructor for the MemoryManager class.  It frees up all
 *		resources being used by the Memory Manager object, including the
 *		memory block allocated to hold all user data.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PMemory			AllocateMemory (
 *							PUChar				address,
 *							ULong				length)
 *
 *	Functional Description:
 *		This function is used to allocate a piece of memory from the Memory
 *		Manager object.  Note that the return value is not a pointer to the
 *		memory, but rather, a pointer to a Memory object.  The memory object
 *		contains a buffer that is large enough to handle the reference data.
 *
 *		Note that the reference data is not automatically copied into the
 *		copy buffer of the Memory object.  This copy operation does not occur
 *		until the first time the Memory object is locked (through a Memory
 *		Manager call, as defined below).
 *
 *
 *	Formal Parameters:
 *		address
 *			This is the address of the reference data (or the source data).
 *		length
 *			This is the length of the reference data.
 *
 *	Return Value:
 *		A pointer to a Memory object if the request is successful.
 *		NULL otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			FreeMemory (
 *						PMemory		memory)
 *
 *	Functional Description:
 *		This function is used to free a previously allocated Memory object.
 *		Note that if the lock count of the Memory object is not 0 (zero), the
 *		object will not actually be freed yet.  This call merely enables the
 *		object to be freed (when the lock count does hit 0).
 *
 *		In summary, for a Memory object to actually be freed, two conditions
 *		must exist simultaneously: the Memory object must have been freed
 *		with a call to this function; and the lock count must hit zero.
 *
 *	Formal Parameters:
 *		memory
 *			This is a pointer to the Memory object being freed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			LockMemory (
 *						PMemory		memory)
 *
 *	Functional Description:
 *		This function is sued to lock an existing Memory object.  A locked
 *		Memory object will not be freed until the lock count hits zero.
 *
 *		When the lock count transitions from 0 to 1, the reference data is
 *		copied into the internal copy buffer.
 *
 *	Formal Parameters:
 *		memory
 *			This is a pointer to the Memory object being locked.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			UnlockMemory (
 *							PMemory	memory)
 *
 *	Functional Description:
 *		This function is used to unlock a Memory object that was previously
 *		locked.  Each time an object is unlocked, the lock count is decremented.
 *		When the lock count hits zero, the memory will be freed if-and-only-if
 *		the FreeMemory call has also been made.  In essence, for a Memory
 *		object to be freed, a call to FreeMemory must have been made, AND the
 *		lock count must be zero.
 *
 *	Formal Parameters:
 *		memory
 *			This is a pointer to the Memory object being unlocked.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		GetBufferCount ()
 *
 *	Functional Description:
 *		This function is used to determine the total number of available
 *		buffers that remain in the pool.  This should be used to determine
 *		general resource levels only.  It cannot be used to determine whether
 *		or not there is a buffer of a particular size.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The total number of buffers available (regardless of size).
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		GetBufferCount (
 *						ULong	buffer_size)
 *
 *	Functional Description:
 *		This function is used to determine the number of X size buffers 
 *		that remain in the pool. 
 *
 *	Formal Parameters:
 *		buffer_size
 *			The buffer size that we want to count.
 *
 *	Return Value:
 *		The number of 'buffer_size' buffers available.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\memory2.cpp ===
#include "precomp.h"
/*
 *	memory.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Memory class.  Instances of
 *		this class represent chunks of data that are passed through a system.
 *		This class is particularly useful in cases where a memory buffer
 *		needs to be used in several different places, none of which know
 *		about each other.  This is because this class encapsulates things
 *		like lock counts, which are useful for holding memory until
 *		everyone that needs it is through.
 *
 *		Note that this class does NOT do memory management.  It is told by
 *		a higher level memory manager where its buffers are, etc.  For this
 *		reason, this class does not do any platform specific calls.
 *
 *	Private Instance Variables:
 *		Length
 *			This is the length of the reference buffer.
 *		Copy_Ptr
 *			This is the address of the allocated buffer that this object
 *			uses.
 *		Free_Stack
 *			This is a pointer to the free stack list from which the copy
 *			buffer was allocated.  This is held within this object as a
 *			convenience to the memory manager, allowing it to return the
 *			buffer to the free pool more quickly and easily.
 *		Block_Number
 *			This is the block number of the memory block that this object
 *			represents.  This is held within this object as a convenience to
 *			the memory manager, allowing it to return the buffer to the free
 *			pool more quickly and easily.
 *		Memory_Lock_Mode
 *			This fields indicates whether this memory object should be destroyed
 *			only when the lock count on the memory buffer reaches zero (NORMAL),
 *			or whether its okay to destroy immediately when the memory block is
 *			freed (IGNORED).
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */



/*
 *	Memory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the Memory class.  It just initializes
 *		all instance variable, based on the passed in values.
 */
Memory::Memory (
		PUChar			reference_ptr,
		ULong			length,
		PUChar			copy_ptr,
		BlockNumber		block_number,
		MemoryLockMode	memory_lock_mode) :
				Length (length), Copy_Ptr (copy_ptr), 
				Block_Number (block_number), Memory_Lock_Mode (memory_lock_mode)
{
	/*
	 *	If the reference pointer is a valid pointer, then the pointer type
	 *	will be set to reference (indicating that the reference data has not
	 *	yet been copied).  If the reference pointer is NULL, then this is
	 *	a memory allocation with no associated reference data, so set the
	 *	pointer type to copy.
	 */
	if (reference_ptr != NULL)
		memcpy (Copy_Ptr, reference_ptr, (Int) Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <windows.h>
#include <databeam.h>

extern "C"
{
    #include "t120.h"
}
#include <memtrack.h>
#include "iplgxprt.h"
#include "fsdiag2.h"
#include "slist2.h"
#include "hash2.h"
#include "object2.h"
#include "memory2.h"  // mcattprt.h needs it
#include "memmgr2.h"
#include "mcattprt.h"
#include "imst123.h"
#include "protocol.h"
#include "timer.h"
#include "framer.h"
#include "crc.h"
#include "random.h"

class CTransportInterface;
class TransportController;
class T123;
class CLayerX224;
class CLayerSCF;
class CLayerQ922;
class Multiplexer;
class ComPort;

#include "tprtcore.h"
#include "tprtintf.h"
#include "t123.h"
#include "comport.h"


extern HINSTANCE                   g_hDllInst;
extern CTransportInterface        *g_pTransportInterface;
extern CRITICAL_SECTION            g_csPSTN;
extern Timer                      *g_pSystemTimer;
extern TransportController        *g_pController;
extern HANDLE                      g_hWorkerThread;
extern DWORD                       g_dwWorkerThreadID;
extern HANDLE                      g_hWorkerThreadEvent;
extern HANDLE                      g_hThreadTerminateEvent;
extern DictionaryClass            *g_pComPortList2;
extern SListClass                 *g_pPSTNEventList;
extern TransportCallback           g_pfnT120Notify;
extern void                       *g_pUserData;
extern BOOL                        g_fEventListChanged;


// #undef TRACE_OUT
// #define TRACE_OUT WARNING_OUT


#endif /* _PRECOMP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\object2.h ===
/*
 *    object.h
 *
 *    Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the interface file for class Object.  This class is the
 *        base class for every class in the MCS system.  It provides the
 *        behaviors that are common to all classes.
 *
 *        This class only three public member functions.  The first is a virtual
 *        destructor.  This destructor does nothing in this class, but it does
 *        virtualize the destructor for all of its descendants.  This allows
 *        an object to be deleted with a pointer to one of its base classes,
 *        while guaranteeing that all appropriate destructors get called.  This
 *        means that any object in the system can be deleted with a pointer to
 *        class Object (this is never really done).
 *
 *        The second member function is a routine that returns the name of the
 *        class.  This allows any object ask another object what the name of
 *        its class is, regardless what class of pointer the object has.  This
 *        could be used in diagnostics, for example.
 *
 *        The last common behavior is by far the most important.  This class
 *        defines a virtual function called OwnerCallback.  Since all classes
 *        in MCS inherit from this class, that means that any object in the
 *        system can potentially receive and process an OwnerCallback call.
 *
 *        Owner callbacks are used when it is necessary for an object to send
 *        messages to any object for which it doesn't know the public interface.
 *        This is most commonly the object that created it (the owner).  A good
 *        example of its use is this.  Object A creates object B.  Object B
 *        performs some operations in the system, and then determines that its
 *        work is through.  It needs to be deleted, but only object A can do that
 *        since it holds the reference to B (unless it has been passed to someone
 *        else).  Owner callbacks allows object B to send a message to object A
 *        asking to be deleted.  Class B does not have to know the public
 *        interface of class A for this to work.  It only has to know that class A
 *        inherits from class Object.
 *
 *        When a class needs to be able to send owner callbacks, these callbacks
 *        become part of the interface of the class.  In this way, these
 *        interfaces are really bi-directional.  They contain a class definition
 *        which defines what messages can be sent to an object of that class.
 *        The owner callbacks defined in the interface file show what messages
 *        can be sent from instances of the class.  When a decision is made for
 *        one class to use another, the using class needs to accept responsibility
 *        for handling any owner callbacks that the used class can generate.
 *
 *        When any class uses a class that can generate owner callbacks, the
 *        using class should override the OwnerCallback member function defined
 *        here.  Failure to handle owner callbacks that are issued by a child
 *        object is a serious design flaw.
 *
 *        This class contains a default implementation of the OwnerCallback
 *        member function.  This default implmentation merely prints an error
 *        reporting an unhandled owner callback.
 *
 *        The exact mechanics behind how the owner callbacks work is discussed
 *        below in the definition of the default handler.
 *
 *    Caveats:
 *        None.
 *
 *    Author:
 *        James P. Galvin, Jr.
 */
#ifndef    _OBJECT2_H_
#define    _OBJECT2_H_

/*
 *    This is the class definition of class Object.
 */
class IObject
{
public:

    virtual ~IObject(void) = 0;

    virtual ULONG OwnerCallback(ULONG   message,
                                void   *parameter1 = NULL,
                                void   *parameter2 = NULL,
                                void   *parameter3 = NULL)
    {
        ERROR_OUT(("IObject::OwnerCallback: unattended owner callback"));
        return 0;
    };
};


/*
 *    virtual            ~Object ()
 *
 *    Functional Description:
 *        This is Object class destructor.  It does nothing.  Its purpose is to
 *        virtualize the destructor for all derived classes.  This insures that
 *        when an object is deleted, all proper destructors get executed.
 *
 *    Formal Parameters:
 *        None.
 *
 *    Return Value:
 *        None.
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    ULong        OwnerCallback (
 *                        UShort            message,
 *                        PVoid            parameter1,
 *                        ULong            parameter2)
 *
 *    Functional Description:
 *        This is the default implementation of the owner callback function.
 *        It does nothing except to report that an owner callback was not
 *        properly handled.  This should be seen as a very serious error.
 *        When any class expects to receive owner callbacks, it should override
 *        this function, and provide real behavior.
 *
 *    Formal Parameters:
 *        message
 *            This is the message to processed.  The messages that are valid are
 *            defined as part of the public interface of the class that is
 *            issuing the owner callbacks.  These messages normally range from
 *            0 to N-1 where N is the number of valid callbacks defined.  Note
 *            that when a class needs to be able to issue owner callbacks, it
 *            is given two parameters defining the recipient.  The first is a
 *            pointer to the object (POwnerObject, typedefed above).  The
 *            second is an owner message base.  This is an offset that the
 *            sending class adds to each message that it sends.  This allows
 *            one class to be the recipient of owner callbacks from more than
 *            one class without the messages stepping on one another.  The message
 *            base is simply set to be different for each child class.
 *        parameter1
 *        parameter2
 *            These parameters vary in meaning according to the message being
 *            processed.  The meaning of the parameters is defined in the
 *            interface file of the class issuing the callback.
 *
 *    Return Value:
 *        This is a 32-bit value whose meaning varies acording to the message
 *        being processed.  As with the parameters above, the meaning of the
 *        return value is defined in the interface file of the class that is
 *        issuing the callback.
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    ULong        OwnerCallback (
 *                        UShort            message,
 *                        ULong            parameter1,
 *                        ULong            parameter2,
 *                        PVoid            parameter3)
 *
 *    Functional Description:
 *        This is the default implementation of the owner callback function.
 *        It does nothing except to report that an owner callback was not
 *        properly handled.  This should be seen as a very serious error.
 *        When any class expects to receive owner callbacks, it should override
 *        this function, and provide real behavior.
 *
 *        This function has 4 total parameters.  It differs from the other
 *        OwnerCallback function by the number of parameters it takes.  This
 *        alternative function was added because the other OwnerCallback()
 *        function did not allow enough parameter space.  Usually, in a project
 *        you will decide to use either this OwnerCallback() or the other, but
 *        not both.
 *
 *    Formal Parameters:
 *        message
 *            This is the message to processed.  The messages that are valid are
 *            defined as part of the public interface of the class that is
 *            issuing the owner callbacks.  These messages normally range from
 *            0 to N-1 where N is the number of valid callbacks defined.  Note
 *            that when a class needs to be able to issue owner callbacks, it
 *            is given two parameters defining the recipient.  The first is a
 *            pointer to the object (POwnerObject, typedefed above).  The
 *            second is an owner message base.  This is an offset that the
 *            sending class adds to each message that it sends.  This allows
 *            one class to be the recipient of owner callbacks from more than
 *            one class without the messages stepping on one another.  The message
 *            base is simply set to be different for each child class.
 *        parameter1
 *        parameter2
 *        parameter3
 *            These parameters vary in meaning according to the message being
 *            processed.  The meaning of the parameters is defined in the
 *            interface file of the class issuing the callback.
 *
 *    Return Value:
 *        This is a 32-bit value whose meaning varies acording to the message
 *        being processed.  As with the parameters above, the meaning of the
 *        return value is defined in the interface file of the class that is
 *        issuing the callback.
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\pstnfram.h ===
/*    PSTNFram.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This function encodes and decodes functions according to the encoding
 *        rules set by the T.123 communications standard for PSTN.  The standard
 *        states that a flag will precede each packet and a flag will be appended 
 *        to the end of each packet.  Therefore no flags are permitted in the body
 *        of the packet.  Flags are replaced by an ESCAPE sequence.  If an ESCAPE 
 *        byte is found in a packet, remove the ESCAPE, and negate the 6th bit of 
 *        the next byte.  
 *    
 *    Caveats:
 *        None
 *
 *    Authors:
 *        James W. Lawwill
 */

#ifndef _PSTN_FRAME_H_
#define _PSTN_FRAME_H_

#include "framer.h"

 /*
 **    Commonly used definitions
 */
#define FLAG                    0x7e
#define ESCAPE                  0x7d
#define COMPLEMENT_BIT          0x20
#define NEGATE_COMPLEMENT_BIT   0xdf


class PSTNFrame : public PacketFrame
{
public:

    PSTNFrame(void);
    virtual ~PSTNFrame(void);

        PacketFrameError    PacketEncode (
                                PUChar        source_address, 
                                UShort        source_length,
                                PUChar        dest_address,
                                UShort        dest_length,
                                DBBoolean    prepend_flag,
                                DBBoolean    append_flag,
                                PUShort        packet_size);
                                
        PacketFrameError    PacketDecode (
                                PUChar        source_address,
                                UShort        source_length,
                                PUChar        dest_address,
                                UShort        dest_length,
                                PUShort        bytes_accepted,
                                PUShort        packet_size,
                                DBBoolean    continue_packet);
        Void                GetOverhead (
                                UShort        original_packet_size,
                                PUShort        max_packet_size);


    private:
        PUChar        Source_Address;
        UShort        Source_Length;

        PUChar        Dest_Address;
        UShort        Dest_Length;

        UShort        Source_Byte_Count;
        UShort        Dest_Byte_Count;

        DBBoolean    Escape_Found;
        DBBoolean    First_Flag_Found;
};
typedef    PSTNFrame    *    PPSTNFrame;

#endif

/*    
 *    PSTNFrame::PSTNFrame (
 *                Void);
 *
 *    Functional Description
 *        This is the constructor for the PSTNFrame class.  It initializes all
 *        internal variables.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    PSTNFrame::~PSTNFrame (
 *                    Void);
 *
 *    Functional Description
 *        This is the destructor for the PSTNFrame class.  It does nothing
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    PacketFrameError    PSTNFrame::PacketEncode (
 *                                    PUChar        source_address, 
 *                                    UShort        source_length,
 *                                    PUChar        dest_address,
 *                                    UShort        dest_length,
 *                                    DBBoolean    prepend_flag,
 *                                    DBBoolean    append_flag,
 *                                    PUShort        packet_size);
 *                                    
 *
 *    Functional Description
 *        This function encodes the passed in buffer to meet the T.123 standard.
 *        
 *    Formal Parameters
 *        source_address    (i)    -    Address of the buffer to encode
 *        source_length    (i)    -    Length of the buffer to encode
 *        dest_address    (i)    -    Address of the destination buffer
 *        dest_length        (i)    -    Length of the destination buffer
 *        prepend_flag    (i)    -    DBBoolean that tells us whether or not to put
 *                                a flag at the beginning of the packet
 *        append_flag        (i)    -    DBBoolean that tells us whether or not to put
 *                                a flag at the end of the packet
 *        packet_size        (o)    -    We return this to the user to tell them the new
 *                                size of the packet
 *
 *    Return Value
 *        PACKET_FRAME_NO_ERROR                -    No error occured
 *        PACKET_FRAME_DEST_BUFFER_TOO_SMALL    -    The destination buffer passed
 *                                                in was too small
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    PacketFrameError    PSTNFrame::PacketDecode (
 *                                    PUChar        source_address,
 *                                    UShort        source_length,
 *                                    PUChar        dest_address,
 *                                    UShort        dest_length,
 *                                    PUShort        bytes_accepted,
 *                                    PUShort        packet_size,
 *                                    DBBoolean    continue_packet);
 *                                    
 *    Functional Description
 *        This function takes the input data and decodes it, looking for a
 *        T123 packet.  The user may have to call this function many times
 *        before a packet is pieced together.  If the user calls this function
 *        and and sets either soure_address or dest_address to NULL, it uses
 *        the addresses passed in, the last time this function was called.  If
 *        there is one source buffer to decode, the user can pass that address
 *        in the first time and continue calling the function with NULL as the
 *        source address until the buffer is exhausted.  The user will know the
 *        buffer is exhausted when the return code is simply PACKET_FRAME_NO_ERROR
 *        rather than PACKET_FRAME_PACKET_DECODED.
 *        
 *    Formal Parameters
 *        source_address    (i)    -    Address of the buffer to decode
 *        source_length    (i)    -    Length of the buffer to decode
 *        dest_address    (i)    -    Address of the destination buffer
 *        dest_length        (i)    -    Length of the destination buffer
 *        bytes_accepted    (o)    -    We return the number of source bytes processed
 *        packet_size        (o)    -    We return the size of the packet.  This is only
 *                                valid if the return code is 
 *                                PACKET_FRAME_PACKET_DECODED.
 *        continue_packet    (i)    -    DBBoolean, tells us if we should start by 
 *                                looking for the first flag.  If the user wants
 *                                to abort the current search, use this flag.
 *
 *    Return Value
 *        PACKET_FRAME_NO_ERROR                -    No error occured, source buffer
 *                                                exhausted
 *        PACKET_FRAME_DEST_BUFFER_TOO_SMALL    -    The destination buffer passed
 *                                                in was too small
 *        PACKET_FRAME_PACKET_DECODED            -    Decoding stopped, packet decoded
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    Void    PSTNFrame::GetOverhead (
 *                        UShort        original_packet_size,
 *                        PUShort        max_packet_size);
 *                                    
 *    Functional Description
 *        This function takes the original packet size and returns the maximum
 *        size of the packet after it has been encoded.  Worst case will be
 *        twice as big as it was with two flags.
 *        
 *    Formal Parameters
 *        original_packet_size    (i)    -    Self-explanatory
 *        max_packet_size            (o)    -    Worst case size of the packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\mplex.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    Mplex.cpp
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the Q922 multiplexer class.  This
 *        class multiplexes higher layers to a single lower layer.
 *
 *    Private Instance Variables:
 *        Q922_Layers        -        List of the higher layers we are multiplexing
 *        Owner_Object    -        Address of our owner object.
 *        m_pComPort        -        Address of our lower layer
 *        m_hCommLink-    The identifier we pass to the lower layer.  This
 *                                is how the lower layer identifies us
 *        m_nMsgBase    -        Message base we use for owner callbacks.  The
 *                                owner identifies us by the message base
 *        Maximum_Packet_Size        Maximum packet size we can send to lower layer
 *        Packet_Size        -        Maximum packet size the higher layer can send
 *                                to us
 *        Data_Request_Buffer        Buffer we use for data coming from higher layer
 *        Data_Request_Memory_Object        Memory object used for data transmission
 *        Data_Request_Length        Length of packet from higher layer
 *        Data_Request_Offset        Current offset into packet.  Maintains current
 *                                position as we send to lower layer.
 *        Data_Indication_Buffer    Buffer we use for data coming from lower layer
 *        Data_Indication_Length    Length of packet
 *        Data_Indication_Ready    Flag indicating that packet is ready to send up
 *
 *        Framer            -        Address of packet framer object
 *        CRC                -        Address of crc generator and checker
 *
 *        Decode_In_Progress        Flag telling us if we are in the middle of a
 *                                packet
 *        CRC_Size        -        Number of bytes in the CRC
 *        Disconnect        -        TRUE if a disconnect is pending
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */
#include "mplex.h"


/*
 *    Multiplexer::Multiplexer (
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                identifier,
 *                USHORT                message_base,
 *                PPacketFrame        framer,
 *                PCRC                crc,
 *                BOOL *            initialized)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initializes the Q922 multiplexer.
 */
Multiplexer::Multiplexer
(
    T123               *owner_object,
    ComPort            *comport, // lower layer
    PhysicalHandle      physical_handle,
    USHORT              message_base,
    PPacketFrame        framer,
    PCRC                crc,
    BOOL               *initialized
)
:
    Q922_Layers(TRANSPORT_HASHING_BUCKETS)
{
    TRACE_OUT(("Multiplexer::Multiplexer"));

    USHORT                overhead;
    ProtocolLayerError    error;
    USHORT                lower_layer_prepend;
    USHORT                lower_layer_append;

    *initialized = TRUE;

    m_pT123 = owner_object;
    m_pComPort = comport;
    m_hCommLink = physical_handle;
    m_nMsgBase = message_base;
    Framer = framer;
    CRC = crc;
    CRC_Size = 0;

    m_pComPort->GetParameters(
                    &Maximum_Packet_Size,
                    &lower_layer_prepend,
                    &lower_layer_append);

    if (Maximum_Packet_Size == 0xffff)
    {
         /*
         **    The lower layer is a stream device, base the higher maximum packet
         **    size on the Multiplexer max. packet size
         */
        Packet_Size = MULTIPLEXER_MAXIMUM_PACKET_SIZE;
        Maximum_Packet_Size = Packet_Size;

        if (CRC != NULL)
        {
            CRC -> GetOverhead (0, &CRC_Size);
            Maximum_Packet_Size += CRC_Size;
        }

        if (Framer != NULL)
            Framer -> GetOverhead (Maximum_Packet_Size, &Maximum_Packet_Size);
    }
    else
    {
         /*
         **    The lower layer is a packet device, determine the max. packet
         **    size of the higher layer.
         */
        overhead = 0;
        if (Framer != NULL)
            Framer -> GetOverhead (overhead, &overhead);

        if (CRC != NULL)
        {
            CRC -> GetOverhead (0, &CRC_Size);
            overhead += CRC_Size;
        }

        Packet_Size = Maximum_Packet_Size - overhead;
    }

    TRACE_OUT(("MPlex: max_packet = %d", Maximum_Packet_Size));

     /*
     **    Now we have to allocate a buffer for data going to the lower layer
     */
    if (Framer != NULL)
    {
        Data_Request_Buffer = (LPBYTE) LocalAlloc (LMEM_FIXED, Maximum_Packet_Size);
        Data_Indication_Buffer = (LPBYTE) LocalAlloc (LMEM_FIXED, Maximum_Packet_Size);
        if ((Data_Request_Buffer == NULL) ||
            (Data_Indication_Buffer == NULL))
        {
            *initialized = FALSE;
        }
    }

    Data_Request_Length = 0;
    Data_Request_Offset = 0;
    Data_Request_Memory_Object = NULL;

    Data_Indication_Length = 0;
    Data_Indication_Ready = FALSE;


    Decode_In_Progress = FALSE;
    Disconnect = FALSE;

     /*
     **    Register with the lower layer
     */
    error = m_pComPort->RegisterHigherLayer(
                            (ULONG_PTR) m_hCommLink,
                            NULL,
                            (IProtocolLayer *) this);

    if (error != PROTOCOL_LAYER_NO_ERROR)
    {
        TRACE_OUT(("Multiplexer: constructor:  Error registering with lower layer"));
    }
}


/*
 *    Multiplexer::~Multiplexer (void);
 *
 *    Public
 *
 *    Functional Description:
 *        Destructor
 */
Multiplexer::~Multiplexer (void)
{
    TRACE_OUT(("Multiplexer::~Multiplexer"));

    PMPlexStruct        lpmpStruct;
     /*
     **    Remove our reference from the lower layer
     */
    m_pComPort->RemoveHigherLayer((ULONG_PTR) m_hCommLink);

    if (Framer != NULL)
    {
        if (Data_Request_Buffer != NULL)
            LocalFree ((HLOCAL) Data_Request_Buffer);
        if (Data_Indication_Buffer != NULL)
            LocalFree ((HLOCAL) Data_Indication_Buffer);
    }
    else
    {
        if (Data_Request_Memory_Object != NULL)
        {
            if (Q922_Layers.find ((DWORD_PTR) Data_Request_DLCI, (PDWORD_PTR) &lpmpStruct))
                lpmpStruct->data_request_memory_manager->UnlockMemory (Data_Request_Memory_Object);
        }
    }

    Q922_Layers.reset();
    while (Q922_Layers.iterate((PDWORD_PTR) &lpmpStruct))
        delete lpmpStruct;

     /*
     **    Delete the Framer that was instantiated by the controller.
     */
    if (Framer != NULL)
        delete Framer;
    if (CRC != NULL)
        delete CRC;
}


/*
 *    MultiplexerError    Multiplexer::ConnectRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function simply notifies the higher layer that it is ready
 *        for operation
 */
MultiplexerError    Multiplexer::ConnectRequest (void)
{
    TRACE_OUT(("Multiplexer::ConnectRequest"));

    m_pT123->OwnerCallback(m_nMsgBase + NEW_CONNECTION);

     return (MULTIPLEXER_NO_ERROR);
}



/*
 *    MultiplexerError    Multiplexer::DisconnectRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function removes itself from the lower layer and notifies the
 *        owner.
 */
MultiplexerError    Multiplexer::DisconnectRequest (void)
{
    TRACE_OUT(("Multiplexer::DisconnectRequest"));

    if (Data_Request_Length == 0)
    {
        m_pT123->OwnerCallback(m_nMsgBase + BROKEN_CONNECTION);
    }
    Disconnect = TRUE;

    return (MULTIPLEXER_NO_ERROR);
}


/*
 *    ProtocolLayerError    Multiplexer::PollReceiver (
 *                                        ULONG)
 *
 *    Public
 *
 *    Functional Description:
 *        If this function has a packet ready to send to a higher layer, it
 *        attempts to send it.
 */
ProtocolLayerError Multiplexer::PollReceiver(void)
{
    // TRACE_OUT(("Multiplexer::PollReceiver"));

    if (Data_Indication_Ready)
    {
        SendDataToHigherLayer (
            Data_Indication_Buffer,
            Data_Indication_Length);

        Data_Indication_Ready = FALSE;
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    Multiplexer::PollTransmitter (
 *                                        ULONG)
 *
 *    Public
 *
 *    Functional Description:
 *        If we have data to send to the lower layer, we attempt to send it.
 */
ProtocolLayerError    Multiplexer::PollTransmitter (
                                    ULONG_PTR,
                                    USHORT,
                                    USHORT *,
                                    USHORT *)
{
    // TRACE_OUT(("Multiplexer::PollTransmitter"));

    ULONG                bytes_accepted;
    HPUChar                packet_address;
    ProtocolLayerError    return_value = PROTOCOL_LAYER_NO_ERROR;

    if (Data_Request_Length != 0)
    {
        if (Framer != NULL)
        {
            m_pComPort->DataRequest(
                            (ULONG_PTR) m_hCommLink,
                            Data_Request_Buffer + Data_Request_Offset,
                            Data_Request_Length - Data_Request_Offset,
                            &bytes_accepted);
        }
        else
        {
            packet_address = (HPUChar) Data_Request_Memory_Object->GetPointer ();
            m_pComPort->DataRequest(
                            (ULONG_PTR) m_hCommLink,
                            ((LPBYTE) packet_address) + Data_Request_Offset,
                            Data_Request_Length - Data_Request_Offset,
                            &bytes_accepted);
        }

         /*
         **    If the lower layer has accepted all of the packet, reset
         **    our length and offset variables
         */
        if (bytes_accepted <=
            (ULONG) (Data_Request_Length - Data_Request_Offset))
        {
            Data_Request_Offset += (USHORT) bytes_accepted;
            if (Data_Request_Offset == Data_Request_Length)
            {
                Data_Request_Offset = 0;
                Data_Request_Length = 0;
                if (Framer == NULL)
                {
                    PMPlexStruct    lpmpStruct;

                     /*
                     **    Unlock the memory object so that it can be released
                     */

                    if (Q922_Layers.find ((DWORD_PTR) Data_Request_DLCI, (PDWORD_PTR) &lpmpStruct))
                        lpmpStruct->data_request_memory_manager->UnlockMemory (Data_Request_Memory_Object);

                    Data_Request_Memory_Object = NULL;
                }

                 /*
                 **    If the Disconnect is pending, issue the callback
                 */
                if (Disconnect)
                {
                    Disconnect = FALSE;
                    m_pT123->OwnerCallback(m_nMsgBase + BROKEN_CONNECTION);
                }
            }
        }
    }
    return (return_value);
}


/*
 *    ProtocolLayerError    Multiplexer::RegisterHigherLayer (
 *                                        ULONG            identifier,
 *                                        PMemoryManager    memory_manager,
 *                                        IProtocolLayer *    q922);
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to register an identifier with a higher
 *        layer address.
 */
ProtocolLayerError    Multiplexer::RegisterHigherLayer (
                                    ULONG_PTR            identifier,
                                    PMemoryManager    memory_manager,
                                    IProtocolLayer *    q922)
{
    TRACE_OUT(("Multiplexer::RegisterHigherLayer"));

    DLCI            dlci;
    PMPlexStruct    lpmpStruct;

    dlci = (DLCI) identifier;

    if (Q922_Layers.find ((DWORD) dlci))
        return (PROTOCOL_LAYER_REGISTRATION_ERROR);

    lpmpStruct = new MPlexStruct;
    if (lpmpStruct != NULL)
    {
        Q922_Layers.insert ((DWORD_PTR) dlci, (DWORD_PTR) lpmpStruct);
        lpmpStruct -> q922 = q922;
        lpmpStruct -> data_request_memory_manager = memory_manager;
    }
    else
    {
        return (PROTOCOL_LAYER_ERROR);
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    Multiplexer::RemoveHigherLayer (
 *                                        ULONG    identifier);
 *
 *    Public
 *
 *    Functional Description:
 *        This function removes the higher layer from our list
 */
ProtocolLayerError    Multiplexer::RemoveHigherLayer (
                                    ULONG_PTR    identifier)
{
    TRACE_OUT(("Multiplexer::RemoveHigherLayer"));

    DLCI            dlci;
    PMPlexStruct    lpmpStruct;

   dlci = (DLCI) identifier;

    if (Q922_Layers.find ((DWORD_PTR) dlci, (PDWORD_PTR) &lpmpStruct) == FALSE)
        return (PROTOCOL_LAYER_REGISTRATION_ERROR);

    if (Data_Request_Memory_Object != NULL)
    {
        if (Data_Request_DLCI == dlci)
        {
             /*
             **    Unlock the memory object so that it can be released
             */
            lpmpStruct->data_request_memory_manager->UnlockMemory (Data_Request_Memory_Object);

            Data_Request_Offset = 0;
            Data_Request_Length = 0;
            Data_Request_Memory_Object = NULL;
        }
    }

    delete lpmpStruct;
    Q922_Layers.remove ((DWORD) dlci);

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    Multiplexer::GetParameters (
 *                                        ULONG,
 *                                        USHORT *    max_packet_size,
 *                                        USHORT *    prepend_bytes,
 *                                        USHORT *    append_bytes)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the maximum packet size permitted by
 *        the higher layer.
 */
ProtocolLayerError    Multiplexer::GetParameters (
                                    USHORT *    max_packet_size,
                                    USHORT *    prepend_bytes,
                                    USHORT *    append_bytes)
{
    TRACE_OUT(("Multiplexer::GetParameters"));

    *max_packet_size = Packet_Size;
    *prepend_bytes = 0;
    *append_bytes = CRC_Size;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    MultiplexerError    Multiplexer::DataRequest (
 *                                         ULONG        identifier,
 *                                        PMemory        memory,
 *                                            PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function takes the packet passed in, runs it thru the framer and
 *        CRC, and passes it to the lower layer.
 */
ProtocolLayerError    Multiplexer::DataRequest (
                                    ULONG_PTR    identifier,
                                    PMemory        memory,
                                    PULong        bytes_accepted)
{
    TRACE_OUT(("Multiplexer::DataRequest"));

    USHORT        crc;
    USHORT        pending_data;
    HPUChar        packet_address;
    ULONG        length;
    USHORT        holding_data;
    USHORT        i;
    DLCI        dlci;
    PMPlexStruct lpmpStruct;

    dlci = (DLCI) identifier;

     /*
     **    Set bytes_accepted to 0
     */
    *bytes_accepted = 0;

    if (Data_Request_Length != 0)
        return (PROTOCOL_LAYER_NO_ERROR);

     /*
     **    Get the address of the memory block
     */
    packet_address = (HPUChar) memory -> GetPointer ();
    length = memory -> GetLength ();

     /*
     **    Remove the CRC length from the total size of the packet.
     */
    length -= CRC_Size;

    if (length > Packet_Size)
    {
        TRACE_OUT(("MPLEX: DataRequest: Packet too big"));
        return (PROTOCOL_LAYER_PACKET_TOO_BIG);
    }

     /*
     **    Lock the memory object so that it won't be released
     */
    if (Q922_Layers.find ((DWORD_PTR) dlci, (PDWORD_PTR) &lpmpStruct))
         lpmpStruct->data_request_memory_manager->LockMemory (memory);

    if (CRC != NULL)
    {
         /*
         **    Generate the CRC and put it at the end of the packet.
         */
        crc = (USHORT) CRC -> CRCGenerator (
                                (LPBYTE) packet_address, length);
        for (i=0; i<CRC_Size; i++)
            *(packet_address + length + i) = (crc >> (i * 8)) & 0xff;
    }

     /*
     **    Add the CRC size to the packet length.
     */
    length += CRC_Size;

    if (Framer != NULL)
    {
         /*
         **    Use the framer to encode the packet
         */
        Framer -> PacketEncode (
                    (LPBYTE) packet_address,
                    (USHORT) length,
                    Data_Request_Buffer,
                    Maximum_Packet_Size,
                    TRUE,
                    TRUE,
                    &Data_Request_Length);

         /*
         **    If we are using a framer, we can release the memory object
         **    right now.
         */
        lpmpStruct->data_request_memory_manager->UnlockMemory (memory);
        *bytes_accepted = length;
    }
    else
    {

         /*
         **    Save the memory object and the identifier
         */
        Data_Request_DLCI = (DLCI) dlci;
        Data_Request_Memory_Object = memory;
        Data_Request_Length = (USHORT) length;
        *bytes_accepted = length;
    }

     /*
     **    Attempt to send the packet to the lower layer
     */
    PollTransmitter (
        0,
        PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA,
        &pending_data,
        &holding_data);

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    MultiplexerError    Multiplexer::DataRequest (
 *                                        ULONG,
 *                                        LPBYTE
 *                                          ULONG
 *                                            PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function takes the packet passed in, runs it thru the framer and
 *        CRC, and passes it to the lower layer.
 */
ProtocolLayerError    Multiplexer::DataRequest (
                                    ULONG_PTR,
                                    LPBYTE,
                                    ULONG,
                                    PULong        bytes_accepted)
{
    *bytes_accepted = 0;
    return (PROTOCOL_LAYER_ERROR);
}



/*
 *    ProtocolLayerError    Multiplexer::DataIndication (
 *                                        LPBYTE        buffer_address,
 *                                          ULONG        length,
 *                                            PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the lower layer when it has data
 *        ready for us.
 */
ProtocolLayerError    Multiplexer::DataIndication (
                                    LPBYTE    buffer_address,
                                    ULONG    length,
                                    PULong     bytes_accepted)
{
//    TRACE_OUT(("Multiplexer::DataIndication"));

    BOOL                process_packet = TRUE;
    USHORT                packet_size;

    LPBYTE                source_address;
    USHORT                source_length;

    LPBYTE                dest_address;
    USHORT                dest_length;
    PacketFrameError    return_value;
    BOOL                crc_valid;
    USHORT                bytes_processed;


    *bytes_accepted = 0;

    if (Framer == NULL)
    {
        *bytes_accepted = length;

         /*
         **    If the framer does NOT exist, the data is coming to us in packet
         **    format
         */
        if (CRC != NULL)
        {
            crc_valid = CRC -> CheckCRC (buffer_address, length);

            if (crc_valid == FALSE)
            {
                TRACE_OUT(("MPLEX: Invalid CRC"));
                return (PROTOCOL_LAYER_NO_ERROR);
            }
            length -= CRC_Size;
        }

        SendDataToHigherLayer (buffer_address, (USHORT) length);
    }
    else
    {
         /*
         **    A framer exists; the lower layer is giving us the data
         **    in a stream fashion
         */
        Data_Indication_Ready = FALSE;

        source_address = buffer_address;
        source_length = (USHORT) length;

        while (process_packet)
        {
            if (Decode_In_Progress)
            {
                dest_length = 0;
                dest_address = NULL;
            }
            else
            {
                dest_address = Data_Indication_Buffer;
                dest_length = Maximum_Packet_Size;
            }

             /*
             **    Pass the data to the framer to decode it.
             */
            return_value = Framer -> PacketDecode (
                                        source_address,
                                        source_length,
                                        dest_address,
                                        dest_length,
                                        &bytes_processed,
                                        &packet_size,
                                        Decode_In_Progress);

            source_address = NULL;

            switch (return_value)
            {
                case PACKET_FRAME_NO_ERROR:
                     /*
                     **    A complete packet was not found by the decoder
                     */
                    Decode_In_Progress = TRUE;
                    Data_Indication_Ready = FALSE;
                    process_packet = FALSE;
                    *bytes_accepted += bytes_processed;
                    break;

                case PACKET_FRAME_PACKET_DECODED:
                     /*
                     **    Complete packet found, check the CRC, and pass it to
                     **    the higher layer.
                     */
                    Decode_In_Progress = FALSE;
                    *bytes_accepted += bytes_processed;

                    if (CRC != NULL)
                    {
                        if (packet_size <= CRC_Size)
                            break;

                        crc_valid = CRC -> CheckCRC (
                                            Data_Indication_Buffer,
                                            packet_size);
                        if (crc_valid == FALSE)
                        {
                            TRACE_OUT(("MPLEX: Invalid CRC: packet_size = %d", packet_size));
                            break;
                        }
                        packet_size -= CRC_Size;
                    }

                    Data_Indication_Ready = TRUE;
                    Data_Indication_Length = packet_size;

                     /*
                     **    Send packet on up
                     */
                    PollReceiver();
                    break;

                case PACKET_FRAME_DEST_BUFFER_TOO_SMALL:
                     /*
                     **    The packet received is too big for our buffer.
                     **    This sometimes occurs if a trailing flag is lost
                     **    during transmission
                     */
                    TRACE_OUT(("PACKET_FRAME_DEST_BUFFER_TOO_SMALL"));
                    Decode_In_Progress = FALSE;
                    *bytes_accepted += bytes_processed;
                    break;

                case PACKET_FRAME_ILLEGAL_FLAG_FOUND:
                     /*
                     **    The packet received contained an illegal flag.
                     */
                    Decode_In_Progress = FALSE;
                    *bytes_accepted += bytes_processed;
                    break;

                case PACKET_FRAME_FATAL_ERROR:
                     /*
                     **    Incoming packets do not meet framer requirements.
                     **    Tell the owner object to break the link
                     */
                    m_pT123->OwnerCallback(m_nMsgBase + BROKEN_CONNECTION);
                    process_packet = FALSE;
                    break;

            }
        }
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    void    Multiplexer::SendDataToHigherLayer (
 *                            LPBYTE        buffer_address,
 *                            USHORT        length)
 *
 *    Functional Description
 *        This function is called to send a packet to the higher layer
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes in packet
 *
 *    Return Value
 *        TRUE     -    The packet was sent to the higher layer
 *        FALSE     -    The packet was NOT sent to the higher layer
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void Multiplexer::SendDataToHigherLayer (
                    LPBYTE    buffer_address,
                    USHORT    buffer_length)
{
    TRACE_OUT(("Multiplexer::SendDataToHigherLayer"));

    DLCI                dlci;
    ProtocolLayerError    error;
    IProtocolLayer *        q922;
    ULONG                bytes_accepted;
    PMPlexStruct        lpmpStruct;


     /*
     **    Find out who the packet is intended for
     */
    dlci = GetDLCI (buffer_address, buffer_length);

    if (Q922_Layers.find((DWORD_PTR) dlci, (PDWORD_PTR) &lpmpStruct))
    {
        q922 = lpmpStruct->q922;
        error = q922 -> DataIndication (
                            buffer_address,
                            buffer_length,
                            &bytes_accepted);

        if (error != PROTOCOL_LAYER_NO_ERROR)
        {
            ERROR_OUT(("Multiplexer: SendDataToHigherLayer: Error occured on data indication to %d", dlci));
        }
        else
        {
            if (bytes_accepted != 0)
            {
                if (bytes_accepted != buffer_length)
                {
                    ERROR_OUT((" Multiplexer: SendDataToHigherLayer:  Error: "
                        "The upper layer thinks he can accept partial packets!!!"));

                }
            }
        }
    }
    else
    {
         /*
         **    Packet can NOT be sent up, trash it.
         */
        WARNING_OUT(("MPLEX: PollReceiver: packet received with illegal DLCI = %d", dlci));
    }
    return;
}



/*
 *    DLCI    Multiplexer::GetDLCI (
 *                            LPBYTE    buffer_address,
 *                            USHORT    length)
 *
 *    Functional Description
 *        This function returns the dlci of the packet.
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes in packet
 *
 *    Return Value
 *        dlci
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
DLCI    Multiplexer::GetDLCI (
                        LPBYTE    buffer_address,
                        USHORT    buffer_size)
{
    DLCI    dlci;

    if (buffer_size < 2)
        return (ILLEGAL_DLCI);

    dlci = *(buffer_address + ADDRESS_BYTE_HIGH) & 0xfc;
    dlci <<= 2;
    dlci |= ((*(buffer_address + ADDRESS_BYTE_LOW) & 0xf0) >> 4);

    return (dlci);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\protocol.h ===
/*    ProtocolLayer.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the base class and backbone of all of the layers
 *        in a Transport Stack.  This class provides a framework for the basic
 *        operations expected by a layer in a stack.  When all layers inherit
 *        from this class, they can be linked together and none of the layers
 *        needs to know who they are connected with.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */
#ifndef _PROTOCOL_LAYER_H_
#define _PROTOCOL_LAYER_H_


typedef LEGACY_HANDLE       LogicalHandle;
typedef PHYSICAL_HANDLE     PhysicalHandle;     // hCommLink


/*
 *  TransportPriority is passed in with the TConnectRequest() call.
 *  The user can set the priority of the logical connection.  Valid
 *  priorities are 0-14.
 */
typedef ULONG           TransportPriority;

#define DEFAULT_PSTN_CALL_CONTROL       PLUGXPRT_PSTN_CALL_CONTROL_PORT_HANDLE


typedef enum
{
    PROTOCOL_LAYER_NO_ERROR,
    PROTOCOL_LAYER_REGISTRATION_ERROR,
    PROTOCOL_LAYER_PACKET_TOO_BIG,
    PROTOCOL_LAYER_ERROR
}
    ProtocolLayerError;

 /*
 **    Message structure used by some classes to hold owner callback
 **    messages.  Sometimes they are processed at later times
 */
typedef struct
{
    ULONG    message;
    void    *parameter1;
    void    *parameter2;
    void    *parameter3;
}
    MessageStruct, * PMessageStruct;


 /*
 **    These values make up the data-to-transmit mask.  We need a way to
 **    let the layers know what type of data they can transmit.  The controller
 **    will pass a mask to the layer during the PollTransmitter() call that tells
 **    the layer if it can transmit CONTROL data, USER data, or both.  The layer
 **    will return a mask telling the controller if it needs to send more
 **    CONTROL or USER data.  It will also tell the controller if it sent any
 **    data during the call.
 */
#define PROTOCOL_CONTROL_DATA           0x01
#define PROTOCOL_USER_DATA              0x02
#define PROTOCOL_USER_DATA_ONE_PACKET   0x04
#define PROTOCOL_USER_DATA_TRANSMITTED  0x08

#define DEFAULT_PRIORITY                2

 /*
 **    Messages passed in owner callbacks
 */
typedef enum
{
    NEW_CONNECTION,
    BROKEN_CONNECTION,
    REQUEST_TRANSPORT_CONNECTION,

    TPRT_CONNECT_INDICATION,
    TPRT_CONNECT_CONFIRM,
    TPRT_DISCONNECT_REQUEST,
    TPRT_DISCONNECT_INDICATION,

    NETWORK_CONNECT_INDICATION,
    NETWORK_CONNECT_CONFIRM,
    NETWORK_DISCONNECT_INDICATION,

    DATALINK_ESTABLISH_INDICATION,
    DATALINK_ESTABLISH_CONFIRM,
    DATALINK_RELEASE_INDICATION,
    DATALINK_RELEASE_CONFIRM,

    T123_FATAL_ERROR,
    T123_STATUS_MESSAGE
}
    CallbackMessage;


class IProtocolLayer : public IObject
{
public:

    virtual    ProtocolLayerError    DataRequest (
                                        ULONG_PTR     identifier,
                                        LPBYTE        buffer_address,
                                        ULONG        length,
                                        PULong        bytes_accepted) = 0;
    virtual    ProtocolLayerError    DataRequest (
                                        ULONG_PTR     identifier,
                                        PMemory        memory,
                                        PULong        bytes_accepted) = 0;
    virtual    ProtocolLayerError    DataIndication (
                                        LPBYTE        buffer_address,
                                        ULONG        length,
                                        PULong         bytes_accepted) = 0;
    virtual    ProtocolLayerError    RegisterHigherLayer (
                                        ULONG_PTR     identifier,
                                        PMemoryManager    memory_manager,
                                        IProtocolLayer *    higher_layer) = 0;
    virtual    ProtocolLayerError    RemoveHigherLayer (
                                        ULONG_PTR     identifier) = 0;
    virtual    ProtocolLayerError    PollTransmitter (
                                        ULONG_PTR     identifier,
                                        USHORT        data_to_transmit,
                                        USHORT *        pending_data,
                                        USHORT *        holding_data) = 0;
    virtual    ProtocolLayerError    PollReceiver (void) = 0;
    virtual    ProtocolLayerError    GetParameters (
                                        USHORT *        max_packet_size,
                                        USHORT *        prepend_bytes,
                                        USHORT *        append_bytes) = 0;
    virtual    BOOL            PerformAutomaticDisconnect ()
                                    {
                                        return (TRUE);
                                    };
};

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    ProtocolLayerError    ProtocolLayer::DataRequest (
 *                                        USHORT        identifier,
 *                                        LPBYTE        buffer_address,
 *                                        USHORT        length,
 *                                        USHORT *        bytes_accepted) = 0;
 *
 *    Functional Description
 *        This function is called by a higher layer to request data to be
 *        sent out.  The function returns the number of bytes accepted from
 *        the packet.  If the layer expects stream data layer, it can accept
 *        part of the packet.  If it is a packet layer, it MUST accept the
 *        full packet of none of the packet.
 *
 *    Formal Parameters
 *        identifier         - (i)    The identifying value of the higher layer
 *        buffer_address    - (i)    Address of the packet.
 *        length            - (i)    Length of the packet
 *        bytes_accepted    - (o)    Number of bytes accepted by the layer.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR            -    No error occured
 *        PROTOCOL_LAYER_ERROR            -    Generic error
 *        PROTOCOL_LAYER_PACKET_TOO_BIG    -    Packet too big
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    ProtocolLayer::DataRequest (
 *                                        USHORT        identifier,
 *                                        PMemory        memory,
 *                                        PULong        bytes_accepted) = 0;
 *
 *    Functional Description
 *        This function is called by a higher layer to request data to be
 *        sent out.  The function returns the number of bytes accepted from
 *        the packet.  If the layer expects stream data layer, it can accept
 *        part of the packet.  If it is a packet layer, it MUST accept the
 *        full packet of none of the packet.  This function does not accept a
 *        buffer address, but it accepts a memory object.  This object holds the
 *        buffer address and the length.
 *
 *    Formal Parameters
 *        identifier         - (i)    The identifying value of the higher layer
 *        memory            - (i)    Address of memory object
 *        bytes_accepted    - (o)    Number of bytes accepted by the layer.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR            -    No error occured
 *        PROTOCOL_LAYER_ERROR            -    Generic error
 *        PROTOCOL_LAYER_PACKET_TOO_BIG    -    Packet too big
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    ProtocolLayer::DataIndication (
 *                                        LPBYTE        buffer_address,
 *                                        USHORT        length,
 *                                        USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by the lower layer when it has data to pass up
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes available
 *        bytes_accepted    (o)    -    Number of bytes accepted
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    ProtocolLayer::RegisterHigherLayer (
 *                                        USHORT            identifier,
 *                                        IProtocolLayer *    higher_layer);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  In some cases, the identifier is the DLCI number in
 *        the packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *        higher_layer    (i)    -    Address of higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Illegal identifier
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    ProtocollLayer::RemoveHigherLayer (
 *                                            USHORT    identifier);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove the higher layer.
 *        If any more data is received with its identifier on it, it will be
 *        trashed.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Illegal identifier
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    ProtocolLayer::PollTransmitter (
 *                                        USHORT        identifier,
 *                                        USHORT        data_to_transmit,
 *                                        USHORT *        pending_data);
 *
 *    Functional Description
 *        This function is called to give the layer a chance transmit data
 *        in its Data_Request buffer.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Identifier to poll
 *        data_to_transmit    (i)    -    This is a mask that tells us to send Control
 *                                    data, User data, or both.  Since the
 *                                     Multiplexer does not differentiate between
 *                                    data types it transmits any data it has
 *        pending_data        (o)    -    Return value to indicat which data is left
 *                                    to be transmitted.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    ProtocolLayer::PollReceiver (
 *                                        USHORT        identifier);
 *
 *    Functional Description
 *        This function is called to give the layer a chance pass packets
 *        to higher layers
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    ProtocolLayer::GetParameters (
 *                                        USHORT        identifier,
 *                                        USHORT *        max_packet_size);
 *
 *    Functional Description
 *        This function is called to get the maximum packet size
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        max_packet_size        (o)    -    Returns the maximum packet size
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    BOOL    ProtocolLayer::PerformAutomaticDisconnect (
 *                                void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function can be used to avoid taking down DLCI0 when the number
 *        of logical connections handled by a particular stack goes to zero.
 *        This is a temporary fix that will probably change when the physical
 *        connection buildup process is handled out of band.
 *
 *    Formal Parameters
 *        none
 *
 *    Return Value
 *        TRUE -    The base class always returns TRUE.  This is the default way
 *                for a physical connection layer to work.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */


/*
 *    PChar    ProtocolLayer::GetIdentifier (
 *                            void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the identifier for the protocol layer.  If the
 *        layer does not override this call a NULL pointer will be returned.
 *
 *    Formal Parameters
 *        none
 *
 *    Return Value
 *        A pointer to the identifier of the protocol layer.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\mplex.h ===
/*    Mplex.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the multiplexer class.  It inherits from the ProtocolLayer
 *        class which means it is one of the layers in a Transport stack.  This
 *        class has these capabilities:
 *
 *            1.  It takes stream data from the lower layer and packetizes it.
 *                If the lower layer gives us data in a stream format, we run it
 *                through a packet framer to build up a packet.  This class uses
 *                a framer object passed in by the constructor.  When data is
 *                received from the lower layer, the data is given to the framer
 *                object.  The framer notifies us of a complete packet.  The
 *                framer could be any type of framer (i.e RFC1006, flagged data
 *                with bit or byte stuffing, ...).  If no framer is passed in by
 *                the constructor, we assume that the data is being received in
 *                packets.
 *
 *                A packet received from the higher layer is run through the
 *                framer to encode the data.  It is then fed to the lower layer
 *                in a stream fashion.
 *
 *            2.  It multiplexes multiple higher layers.  It currently assumes the
 *                incoming packets are in Q.922 packet format.  Each higher layer
 *                is identified by its DLCI.  This class is capable of looking at
 *                the packet and determining the DLCI and thus where to route it.
 *
 *                Since this is a multiplexer, we receive packets for many
 *                different stacks and we do not buffer them if the higher layer
 *                is not ready for them.  If it attempts to send the packet to the
 *                higher layer and it does not accept it, it may trash it.  This
 *                must be done in order to maintain the other transport
 *                connections.  If necessary, in the future, we could buffer
 *                packets at this layer.
 *
 *            3.  This class receives a CRC object during construction (if it is
 *                NULL, no CRC is necessary).  The object runs a packet thru the
 *                CRC generator and attaches it to the end of the packet.  On the
 *                reception of a packet from a lower layer, we check the CRC for
 *                validity.
 *
 *    Caveats:
 *        1.  If a framer exists, it assumes the packet is in Q.922 format
 *        2.  This class is currently Q.922 oriented as far as finding the
 *            packet identifier (DLCI).  This will be fixed in the future.
 *
 *    Authors:
 *        James W. Lawwill
 */
#ifndef _MULTIPLEXER_H_
#define _MULTIPLEXER_H_

#include "q922.h"

#define MULTIPLEXER_MAXIMUM_PACKET_SIZE     1024
#define TRANSPORT_HASHING_BUCKETS            3

 /*
 **    If the identifier (DLCI) contained by the packet is not legal, the following
 **    identifier is returned
 */
#define    ILLEGAL_DLCI    0xffff

 /*
 **    Multiplexer return codes
 */
typedef enum
{
    MULTIPLEXER_NO_ERROR
}
    MultiplexerError;

typedef struct
{
    IProtocolLayer     *q922;
    PMemoryManager      data_request_memory_manager;
}
    MPlexStruct, * PMPlexStruct;

class Multiplexer : public IProtocolLayer
{
public:

    Multiplexer(T123               *owner_object,
                ComPort            *lower_layer,
                PhysicalHandle      lower_layer_identifier,
                USHORT              message_base,
                PPacketFrame        framer,
                PCRC                crc,
                BOOL               *initialized);
    virtual ~Multiplexer(void);


    MultiplexerError    ConnectRequest (void);
    MultiplexerError    DisconnectRequest (void);


    /*
    **    Functions overridden from the ProtocolLayer object
    */
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     dlci,
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     dlci,
                            PMemory        memory,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataIndication (
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    RegisterHigherLayer (
                            ULONG_PTR        dlci,
                            PMemoryManager    memory_manager,
                            IProtocolLayer *    higher_layer);
    ProtocolLayerError    RemoveHigherLayer (
                            ULONG_PTR    dlci);
    ProtocolLayerError    PollTransmitter (
                            ULONG_PTR     dlci,
                            USHORT        data_to_transmit,
                            USHORT *        pending_data,
                            USHORT *        holding_data);
    ProtocolLayerError    PollReceiver(void);
    ProtocolLayerError    GetParameters (
                            USHORT *        max_packet_size,
                            USHORT *        prepend_bytes,
                            USHORT *        append_bytes);

private:

    void                SendDataToHigherLayer (
                            LPBYTE    buffer_address,
                            USHORT    buffer_length);
    DLCI                GetDLCI (
                            LPBYTE    buffer_address,
                            USHORT    buffer_size);

private:

    DictionaryClass     Q922_Layers;

    T123               *m_pT123; // owner object
    ComPort            *m_pComPort; // lower layer
    PhysicalHandle      m_hCommLink; // physical handle
    USHORT              m_nMsgBase;
    USHORT              Maximum_Packet_Size;
    USHORT              Packet_Size;

    LPBYTE              Data_Request_Buffer;
    PMemory             Data_Request_Memory_Object;
    DLCI                Data_Request_DLCI;
    USHORT              Data_Request_Length;
    USHORT              Data_Request_Offset;

    LPBYTE              Data_Indication_Buffer;
    USHORT              Data_Indication_Length;
    BOOL                Data_Indication_Ready;

    PPacketFrame        Framer;
    PCRC                CRC;
    USHORT              CRC_Size;

    BOOL                Decode_In_Progress;
    BOOL                Disconnect;
};

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    Multiplexer::Multiplexer (
 *                    IObject *                object_owner,
 *                       IProtocolLayer *        lower_layer,
 *                       ULONG                identifier,
 *                    USHORT                message_base,
 *                    PPacketFrame        framer,
 *                    PCRC                crc,
 *                    BOOL *                initialized);
 *
 *    Functional Description
 *        This is the constructor for the Multiplexer layer
 *
 *    Formal Parameters
 *        object_owner    - (i)    Address of owner object.
 *        lower_layer        - (i)    Address of the layer below the multiplexer
 *        identifier        - (i)    A lower layer identifier that is passed to the
 *                                lower layer with each call to it.  The
 *                                identifier tells the lower layer which "channel"
 *                                to use.
 *        message_base    - (i)    Message identifier that is passed back to the
 *                                owner object during a callback
 *        framer            - (i)    Address of a framer object
 *        crc                - (i)    Address of a crc object
 *        initialized        - (o)    Set to TRUE if the multiplexer initialized OK
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    Multiplexer::~Multiplexer (void)
 *
 *    Functional Description
 *        This is the destructor for the Multiplexer layer.  It removes itself
 *        from the lower layer and frees all buffers and filters (i.e. framer)
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    MultiplexerError    Multiplexer::ConnectRequest (void);
 *
 *    Functional Description
 *        This function issues an immediate NEW_CONNECTION message to the owner
 *        of this object.  If this was a more sophisticated layer, it would
 *        communicate with the remote multiplexer layer to establish itself.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    MultiplexerError    Multiplexer::DisconnectRequest (void);
 *
 *    Functional Description
 *        This function removes its connection with the lower layer and does
 *        a BROKEN_CONNECTION callback to the owner object
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::DataRequest (
 *                                        ULONG        identifier,
 *                                        LPBYTE        buffer_address,
 *                                        USHORT        length,
 *                                        USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Length of packet to transmit
 *        bytes_accepted    (o)    -    Number of bytes accepted by the Multiplexer.
 *                                This value will either be 0 or the packet
 *                                length since this layer is a packet to byte
 *                                converter.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::DataRequest (
 *                                        ULONG        identifier,
 *                                        PMemory        memory,
 *                                        PULong        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        memory            (o)    -    Pointer to memory object holding the packet
 *        bytes_accepted    (o)    -    Number of bytes accepted by the Multiplexer.
 *                                This value will either be 0 or the packet
 *                                length since this layer is a packet to byte
 *                                converter.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::DataIndication (
 *                                        LPBYTE        buffer_address,
 *                                        USHORT        length,
 *                                        USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by the lower layer when it has data to pass up
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes available
 *        bytes_accepted    (o)    -    Number of bytes accepted
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::RegisterHigherLayer (
 *                                        ULONG            identifier,
 *                                        IProtocolLayer *    higher_layer);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  In some cases, the identifier is the DLCI number in
 *        the packet.  If this multiplexer is being used as a stream to packet
 *        converter only, the identifer is not used and all data is passed to the
 *        higher layer.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *        higher_layer    (i)    -    Address of higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Illegal identifier
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::RemoveHigherLayer (
 *                                        ULONG    identifier);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove the higher layer.
 *        If any more data is received with its identifier on it, it will be
 *        trashed.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Illegal identifier
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::PollTransmitter (
 *                                        ULONG        identifier,
 *                                        USHORT        data_to_transmit,
 *                                        USHORT *        pending_data);
 *
 *    Functional Description
 *        This function is called to give the Multiplexer a chance transmit data
 *        in its Data_Request buffer.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        data_to_transmit    (i)    -    This is a mask that tells us to send Control
 *                                    data, User data, or both.  Since the
 *                                     Multiplexer does not differentiate between
 *                                    data types it transmits any data it has
 *        pending_data        (o)    -    Return value to indicat which data is left
 *                                    to be transmitted.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::PollReceiver (
 *                                        ULONG    identifier);
 *
 *    Functional Description
 *        This function is called to give the Multiplexer a chance pass packets
 *        to higher layers
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::GetParameters (
 *                                        ULONG        identifier,
 *                                        USHORT *        max_packet_size,
 *                                        USHORT *        prepend_bytes,
 *                                        USHORT *        append_bytes);
 *
 *    Functional Description
 *        This function is called to get the maximum packet size
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        max_packet_size        (o)    -    Returns the maximum packet size
 *        prepend_bytes        (o)    -    Returns the Number of bytes prepended by
 *                                    this layer
 *        append_bytes        (o)    -    Returns the Number of bytes appended by
 *                                    this layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\pstnfram.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*	PSTNFram.cpp
 *
 *	Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the PSTN Frame class.
 *
 *	Private Instance Variables:
 *		All of these variables are used for decoding a packet.
 *		
 *		Source_Address		-	Address of source buffer
 *		Source_Length		-	Length of source buffer
 *
 *		Dest_Address		-	Address of destination buffer
 *		Dest_Length			-	Length of destination buffer
 *
 *		Source_Byte_Count	-	Running Source byte count
 *		Dest_Byte_Count		-	Running Dest byte count
 *
 *		Escape_Found		-	TRUE if the last byte decoded was an ESCAPE
 *		First_Flag_Found	-	TRUE if the first flag has been found
 *
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		James W. Lawwill
 */
#include "pstnfram.h"


/*
 *	PSTNFrame::PSTNFrame (void)
 *
 *	Public
 *
 *	Functional Description:
 *		PSTN Framer constructor.  Initializes internal variable
 */
PSTNFrame::PSTNFrame (void)
{
	Source_Address = NULL;
	Source_Length = 0;

	Dest_Address = NULL;
	Dest_Length = 0;

	Source_Byte_Count = 0;
	Dest_Byte_Count = 0;

	Escape_Found = FALSE;

	First_Flag_Found = FALSE;
}


/*
 *	PSTNFrame::~PSTNFrame(void)
 *
 *	Public
 *
 *	Functional Description:
 *		PSTN Framer destructor.  This routine does nothing
 */
PSTNFrame::~PSTNFrame (void)
{
}


/*
 *	PacketFrameError	PSTNFrame::PacketEncode (
 *									LPBYTE		source_address, 
 *									USHORT		source_length,
 *									LPBYTE		dest_address,
 *									USHORT		dest_length,
 *									BOOL    	prepend_flag,
 *									BOOL    	append_flag,
 *									USHORT *		packet_size)
 *
 *	Public
 *
 *	Functional Description:
 *		This function takes the passed in buffer and encodes it.
 */
PacketFrameError	PSTNFrame::PacketEncode (
								LPBYTE		source_address, 
								USHORT		source_length,
								LPBYTE		dest_address,
								USHORT		dest_length,
								BOOL    	prepend_flag,
								BOOL    	append_flag,
								USHORT *		packet_size)
{
	UChar				input_byte;
	USHORT				byte_count;
	PacketFrameError	return_value = PACKET_FRAME_NO_ERROR;


	 /*
	 **	If the prepend_flag is set, attach a flag to the dest buffer
	 */
	if (prepend_flag)
	{
		*(dest_address++) = FLAG;
		*packet_size = 1;
	}
	else
		*packet_size = 0;

	byte_count = 0;

	 /*
	 **	Go thru each byte looking for a FLAG or an ESCAPE, encode this 
	 **	properly.
	 */
	while ((byte_count < source_length) && 
			(return_value == PACKET_FRAME_NO_ERROR))
	{
		input_byte = *(source_address + byte_count);

		switch (input_byte)
		{
			case FLAG:
			case ESCAPE:
				 /*
				 **	If you find a FLAG or an ESCAPE, put an ESCAPE in the 
				 **	destination buffer and negate the 6th bit of the input_byte
				 **
				 */
				if (((*packet_size) + 2) > dest_length)
				{
					return_value = PACKET_FRAME_DEST_BUFFER_TOO_SMALL;
					break;
				}
				*(dest_address++) = ESCAPE;
				*(dest_address++) = input_byte & NEGATE_COMPLEMENT_BIT;
				*packet_size = (*packet_size) +  2;
				break;

			default:
				if (((*packet_size) + 1) > dest_length)
				{
					return_value = PACKET_FRAME_DEST_BUFFER_TOO_SMALL;
					break;
				}
				*(dest_address++) = input_byte;
				*packet_size = (*packet_size) +  1;
				break;
		}
		byte_count++;
	}

	 /*
	 **	Put a FLAG on the end of the packet
	 */
	if (append_flag)
	{
		*(dest_address++) = FLAG;
		*packet_size = (*packet_size) + 1;
	}

	return (return_value);
}


/*
 *	PacketFrameError	PSTNFrame::PacketDecode (
 *									LPBYTE		source_address, 
 *									USHORT		source_length,
 *									LPBYTE		dest_address,
 *									USHORT		dest_length,
 *									USHORT *		bytes_accepted,
 *									USHORT *		packet_size,
 *									BOOL    	continue_packet)
 *
 *	Public
 *
 *	Functional Description:
 *		This function decodes the input buffer looking for a packet.
 */
PacketFrameError	PSTNFrame::PacketDecode (
									LPBYTE		source_address, 
									USHORT		source_length,
									LPBYTE		dest_address,
									USHORT		dest_length,
									USHORT *		bytes_accepted,
									USHORT *		packet_size,
									BOOL    	continue_packet)
{
	UChar				input_byte;
	PacketFrameError	return_value = PACKET_FRAME_NO_ERROR;

	*bytes_accepted = 0;
	 /*
	 **	Source address is changing
	 */
	if (source_address != NULL)
	{
		Source_Address = source_address;
		Source_Length = source_length;
		Source_Byte_Count = 0;
	}

	 /*
	 **	Destination address is changing
	 */
	if (dest_address != NULL)
	{
		Dest_Address = dest_address;
		Dest_Length = dest_length;
		Dest_Byte_Count = 0;
	}

	 /*
	 **	Continue working on this packet?
	 */
	if (continue_packet == FALSE)
		Escape_Found = FALSE;

	if (First_Flag_Found == FALSE)
	{
		 /*
		 **	Go thru the input data looking for a starting flag
		 */
		while (Source_Byte_Count < Source_Length)
		{
			if (*(Source_Address + Source_Byte_Count) == FLAG)
			{
				First_Flag_Found = TRUE;
				Source_Byte_Count++;
				*bytes_accepted += 1;
				break;
			}

			Source_Byte_Count++;
			*bytes_accepted += 1;
		}
	}
	
	 /*
	 **	Go thru the input data stream looking for a FLAG or an ESCAPE
	 */
	while ((Source_Byte_Count < Source_Length) && 
			(return_value == PACKET_FRAME_NO_ERROR))
	{
		input_byte = *(Source_Address + Source_Byte_Count);

		if (input_byte == FLAG)
		{
			 /*
			 **	End of packet found
			 */
			Escape_Found = FALSE;
			Source_Byte_Count++;
			*bytes_accepted += 1;

			 /*
			 **	If we find a FLAG but the number of bytes in the dest buffer
			 **	is 0, consider it the first flag in the packet and continue.
			 */
			if (Dest_Byte_Count == 0)
				continue;
			else
			{
				 /*
				 **	End of packet found, set the packet size and break out
				 */
				Dest_Address = NULL;
				*packet_size = Dest_Byte_Count;
				return_value = PACKET_FRAME_PACKET_DECODED;
				break;
			}
		}

		 /*
		 **	If the last byte was an ESCAPE, complement the 6th bit of the input
		 **	byte and continue
		 */
		if (Escape_Found)
		{
			input_byte ^= COMPLEMENT_BIT;
			Escape_Found = FALSE;
		}
		else
		{	
			 /*
			 **	If the input byte is the ESCAPE, set the flag and continue.
			 */
			if (input_byte == ESCAPE)
			{
				Escape_Found = TRUE;
				Source_Byte_Count++;
				*bytes_accepted += 1;
				continue;
			}
		}

		 /*
		 **	Put the input byte into our buffer.
		 */
		if (Dest_Byte_Count < Dest_Length)
		{
			*(Dest_Address + Dest_Byte_Count) = input_byte;
			Dest_Byte_Count++;
		}
		else
		{
			First_Flag_Found = FALSE;
			return_value = PACKET_FRAME_DEST_BUFFER_TOO_SMALL;
		}

		Source_Byte_Count++;
		*bytes_accepted += 1;
	}

	return (return_value);
}


/*
 *	void	PSTNFrame::GetOverhead (
 *						USHORT	original_packet_size,
 *						USHORT *	max_packet_size)
 *
 *	Public
 *
 *	Functional Description:
 *		This function gives the user some idea of the overhead added by this
 *		process.
 */
void	PSTNFrame::GetOverhead (
						USHORT	original_packet_size,
						USHORT *	max_packet_size)
{	
	 /*
	 **	The overhead produced by this framer is 2 times the original packet
	 **	size plus 2 bytes for the flags
	 */
	*max_packet_size = (original_packet_size * 2) + 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\q922.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    Q922.cpp
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the Q.922 Data Link protocol.
 *        Before diving into the code, it is recommended that you read the
 *        Q.922 protocol.
 *
 *    Private Instance Variables:
 *        m_pT123        -    Address of the owner of this object.  Used for
 *                                owner callbacks.
 *        m_pMultiplexer            -    Address of ProtocolLayer below Q922 in the
 *                                stack.
 *        Higher_Layer        -    Address of ProtocolLayer above Q922 in the
 *                                stack.
 *        m_nMsgBase        -    Message base used in owner callbacks.
 *        DLCI                -    DLCI used to identfy Q922 entities.
 *        Link_Originator        -    TRUE if we are the link originators.  If we are,
 *                                we sent out the first SABME packet.
 *        Maximum_Information_Size-
 *                                 Holds the maximum packet size that we support.
 *        SABME_Pending        -    TRUE if we need to initiate the link.
 *        Unnumbered_Acknowledge_Pending    -    TRUE if we need to send out an
 *                                            Unnumbered Ack. packet.  This is
 *                                            done in response to a SABME or DISC.
 *        DISC_Pending        -    TRUE if we need to send out a DISConnect packet.
 *        Unnumbered_PF_State    -    Holds the Poll/Final state of an unnumbered
 *                                 packet.
 *        Final_Packet        -    TRUE if the next Unnumbered Ack. sent out is
 *                                our final packet to transmit before notifying
 *                                the owner that the link is broken.
 *        Data_Indication_Size-    Number of data indication buffers available
 *        Data_Indication        -    Base address of data indication buffers
 *        Data_Indication_Head-    Head of data indication queue
 *        Data_Indication_Tail-    Tail of read data indication queue
 *        Data_Indication_Count-    Number of data indication buffers in use
 *
 *        Data_Request_Size             -    Number of data request buffers
 *        Data_Request_Total_Size      -    Number of data request buffers + maximum
 *                                        number of outstanding packets
 *        Data_Request                 -    Base address of data request buffers
 *        Data_Request_Head             -    Head of data request queue
 *        Data_Request_Tail             -    Tail of data request queue
 *        Data_Request_Count             -    Number of data request buffers in use
 *        Data_Request_Acknowledge_Tail-    Tail of the queue referring to packets
 *                                        that have been acknowledged
 *
 *        Supervisory_Write_Struct     -    Buffer used for supervisory packets
 *        Send_State_Variable            -    This is the sequence number that will
 *                                        be sent in the next information packet
 *                                        to uniquely identify the packet.  The
 *                                        number is between 0 and 127.
 *        Receive_State_Variable        -    Receive Sequence Number.  The expected
 *                                        sequence number of the next Information
 *                                        packet we receive
 *        Acknowledge_State_Variable    -    This is the sequence number that the
 *                                        remote site is expecting in our next
 *                                        information packet
 *        Own_Receiver_Busy            -    If our read buffers are full, we set
 *                                        this flag so that we send a Receiver
 *                                        Not Ready packet to the remote site
 *        Peer_Receiver_Busy            -    Remote site is not ready to receive
 *                                        Information packets
 *
 *        Command_Pending                -    When this flag is set to TRUE, we send
 *                                        a Supervisory/Command packet to the
 *                                        remote site.
 *
 *                                        We need to send a Supervisory/Command
 *                                        packet when our receiver is no longer
 *                                        busy.  This tells the remote site to
 *                                        resume sending Information packets to
 *                                        us.
 *        Poll_Pending                -    This flag tells us to send a Supervisory
 *                                        command to the remote location with the
 *                                        Poll flag set.  This tells the remote
 *                                        site to reply to this command
 *        Final_Pending                -    This flag is set when we need to reply
 *                                        to a remote command
 *        Acknowledge_Pending            -    This flag signals us to send a
 *                                        Supervisory/Response packet to the
 *                                        remote site.
 *        Reject_Pending                -    Signals us to send a Supervisory/
 *                                        Response packet to the remote site
 *                                        indicating that we missed a packet.
 *        Reject_Outstanding            -    Internal flag telling us that our Reject
 *                                        packet has been sent and don't send
 *                                        another one
 *        T200_Timeout                -    Timeout value.  If we send out a packet
 *                                        and expect a response, and T200_Timeout
 *                                        expires, we enter the TIMER_RECOVERY
 *                                        mode.
 *        T200_Handle                    -    Handle to timer event.
 *      T200_Active                    -    Flag that signals if T200 is running
 *        N200_Count                    -    Number of times T200 expires in a row
 *                                        without a response from the remote site.
 *
 *        T203_Timeout                -    Timeout value.  If we don't receive a
 *                                        packet from the remote site in T203
 *                                        time, we enter the TIMER_RECOVERY mode.
 *        T203_Handle                    -    Handle to timer event
 *      T203_Active                    -    Flag that signals if T203 is running.
 *        Maximum_T200_Timeouts        -    Maximum number of T200 timeouts before
 *                                        we consider the link unstable.
 *        Data_Link_Mode                -    Our mode of operation.
 *                                            MULTIPLE_FRAME_ESTABLISHED
 *                                            TIMER_RECOVERY
 *        Link_Stable                    -    Flag that indicates if our current
 *                                        connection is stable.  FALSE if the
 *                                        N200_Count == Maximum number of T200
 *                                        timeouts
 *        Receive_Sequence_Exception    -    Set if we receive an ILLEGAL sequence
 *                                        number
 *        Maximum_Outstanding_Packets    -    Maximum number of packets that we can
 *                                        have out on the line at a time.
 *        Outstanding_Packets            -    Actual number of packets outstanding
 *        Maximum_Outstanding_Bytes    -    Maximum number of bytes that can be
 *                                        on the line at any one time.  It is VERY
 *                                        important to note that using this as a
 *                                        limiting factor on transmission is NOT
 *                                        a protocol defined limit.  This was
 *                                        added to our Q922 because we had
 *                                        problems with some modems that were
 *                                        buffering our Tx data.  Some modems
 *                                        would buffer up to 4K of data.  This is
 *                                        unacceptable to us because our timeouts
 *                                        would expire before the data left the
 *                                        modem.  Using this parameter as a
 *                                        limiting factor validates our timer
 *                                        values.
 *        Outstanding_Bytes            -    Actual number of bytes on the line at
 *                                        the current time.
 *        Total_Retransmitted            -    Number of packets that have been
 *                                        retransmitted.
 *        Data_Request_Memory_Manager    -    Memory manager used for all DataRequests
 *        Lower_Layer_Prepend            -    Number of bytes prepended to each packet
 *                                        by the lower layer
 *        Lower_Layer_Append            -    Number of bytes appended to packet by
 *                                        the lower layer.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James P. Galvin
 *        James W. Lawwill
 */

#include "q922.h"

/*
 *    CLayerQ922::CLayerQ922 (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                USHORT                identifier,
 *                BOOL                link_originator,
 *                USHORT                data_indication_queue_siz,
 *                USHORT                data_request_queue_size,
 *                USHORT                k_factor,
 *                USHORT                max_information_size,
 *                USHORT                t200,
 *                USHORT                call_control_type,
 *                USHORT                max_outstanding_bytes,
 *                PMemoryManager        memory_manager,
 *                BOOL *                initialized)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the CLayerQ922 constructor.  This routine initializes all
 *        variables and allocates buffer space.
 */
CLayerQ922::CLayerQ922
(
    T123               *owner_object,
    Multiplexer        *pMux, // lower layer
    USHORT              message_base,
    USHORT              identifier,
    BOOL                link_originator,
    USHORT              data_indication_queue_size,
    USHORT              data_request_queue_size,
    USHORT              k_factor,
    USHORT              max_information_size,
    USHORT              t200,
    USHORT              max_outstanding_bytes,
    PMemoryManager      memory_manager,
    PLUGXPRT_PSTN_CALL_CONTROL call_control_type,
    PLUGXPRT_PARAMETERS *pParams,
    BOOL *              initialized
)
:
    m_pT123(owner_object),
    m_nMsgBase(message_base),
    m_pMultiplexer(pMux)
{
    TRACE_OUT(("CLayerQ922::CLayerQ922"));

    ProtocolLayerError    error;
    USHORT                packet_size;
    USHORT                i;

    DLCI = identifier;
    Link_Originator    = link_originator;

    Maximum_Outstanding_Packets = k_factor;
    T200_Timeout = t200;
    Maximum_Information_Size = max_information_size;
    Maximum_Outstanding_Bytes = max_outstanding_bytes;
    Data_Request_Memory_Manager = memory_manager;

    Higher_Layer = NULL;
    Data_Request = NULL;
    Data_Indication = NULL;
    Data_Indication_Buffer = NULL;
    *initialized = TRUE;

     /*
     **    Find the maximum packet size supported by the lower layer
     */
    m_pMultiplexer->GetParameters(
                    &packet_size,
                    &Lower_Layer_Prepend,
                    &Lower_Layer_Append);

    if (Maximum_Information_Size > packet_size)
        Maximum_Information_Size = packet_size;

    TRACE_OUT(("Q922: DLCI %d: Max information Size = %d", DLCI, Maximum_Information_Size));

     /*
     **    Register with the lower layer
     */
    error = m_pMultiplexer->RegisterHigherLayer(
                            identifier,
                            Data_Request_Memory_Manager,
                            (IProtocolLayer *) this);

    if (error != PROTOCOL_LAYER_NO_ERROR)
    {
        *initialized = FALSE;
        ERROR_OUT(("Q922: DLCI %d: constructor:  Error registering with lower layer", DLCI));
    }

     /*
     **    Allocation of data indication buffers.  Allocate the prescribed number
     */
    Data_Indication_Size = data_indication_queue_size;
    Data_Indication =
        (PDataQueue) LocalAlloc (LMEM_FIXED, (sizeof (DataQueue) * Data_Indication_Size));
    if (Data_Indication != NULL)
    {
        Data_Indication_Buffer = (LPBYTE)
             LocalAlloc (LMEM_FIXED, Maximum_Information_Size * Data_Indication_Size);
        if (Data_Indication_Buffer != NULL)
        {
            for (i=0; i<Data_Indication_Size; i++)
            {
                (Data_Indication + i) -> buffer_address =
                    Data_Indication_Buffer + (i * Maximum_Information_Size);
                (Data_Indication + i) -> length = 0;
            }

        }
        else
            *initialized = FALSE;
    }
    else
        *initialized = FALSE;

     /*
     **    Allocation of data request buffers.  Allocate enough buffers for
     **    outstanding buffers as well as the buffers queued for delivery.
     */
    Data_Request_Size = data_request_queue_size;
    Data_Request_Total_Size = Data_Request_Size + Maximum_Outstanding_Packets;
    Data_Request = (PMemory *)
        LocalAlloc (LMEM_FIXED, (sizeof (PMemory) * Data_Request_Total_Size));
    if (Data_Request == NULL)
        *initialized = FALSE;

     /*
     **    Allocate one buffer for Supervisory data
     */
    T200_Active = FALSE;
    T203_Active = FALSE;

     /*
     **    These veriables need to be set to 0 before we call Reset().  Reset()
     **    will attempt to free any memory block that are in the Data_Request
     **    list.  Since we are just initializing and there aren't any memory
     **    blocks in the array, there aren't any to release.
     */
    Data_Request_Head = 0;
    Data_Request_Tail = 0;
    Data_Request_Count = 0;
    Data_Request_Acknowledge_Tail = 0;

    Reset ();

    T203_Timeout = (call_control_type == PLUGXPRT_PSTN_CALL_CONTROL_MANUAL) ?
                    DEFAULT_T203_COMM_TIMEOUT : DEFAULT_T203_TIMEOUT;
    Startup_Maximum_T200_Timeouts = DEFAULT_MAXIMUM_T200_TIMEOUTS;

    if (NULL != pParams)
    {
        if (PSTN_PARAM__MAX_T200_TIMEOUT_COUNT_IN_Q922 & pParams->dwFlags)
        {
            if (Startup_Maximum_T200_Timeouts <= pParams->cMaximumT200TimeoutsInQ922)
            {
                Startup_Maximum_T200_Timeouts = pParams->cMaximumT200TimeoutsInQ922;
            }
        }
        if (PSTN_PARAM__T203_TIMEOUT_IN_Q922 & pParams->dwFlags)
        {
            if (T203_Timeout <= pParams->nT203TimeoutInQ922)
            {
                T203_Timeout = pParams->nT203TimeoutInQ922;
            }
        }
    }

#if 0
    DWORD    dwSiz = 4;
    DWORD    valType = 0;
    HKEY    hkey;
    // If we are using null modem.
    if(call_control_type == PLUGXPRT_PSTN_CALL_CONTROL_MANUAL)
    {
        //
        // Open the registry key that contains the configuration info for number of timeouts
        //
        if (RegOpenKey( HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Conferencing\\Transports\\DIRCB\0", &hkey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkey, "nTimeouts\0", 0, &valType,
                         (LPBYTE)&Startup_Maximum_T200_Timeouts, &dwSiz) != ERROR_SUCCESS || Startup_Maximum_T200_Timeouts < DEFAULT_MAXIMUM_T200_TIMEOUTS)
            {
                Startup_Maximum_T200_Timeouts = DEFAULT_MAXIMUM_T200_TIMEOUTS;
            }
            RegCloseKey(hkey);
        }
    }
#endif

    Link_Maximum_T200_Timeouts = Startup_Maximum_T200_Timeouts;

    Maximum_T200_Timeouts = Startup_Maximum_T200_Timeouts;

     /*
     **    If I am the link originator, enter the AWAITING_ESTABLISHMENT mode and
     **    send out the SABME packet.
     */
    if (Link_Originator)
    {
        SABME_Pending = TRUE;
        Unnumbered_PF_State = UNNUMBERED_PF_SET;
        Data_Link_Mode = AWAITING_ESTABLISHMENT;
    }
    else
    {
         /*
         **    If we are not the link originator, enter the TEI_ASSIGNED mode and
         **    start the T203 timer, if we don't receive a packet in X seconds,
         **    abort the operation
         */
        Data_Link_Mode = TEI_ASSIGNED;
        SABME_Pending = FALSE;
        StartTimerT203 ();
    }

    if (*initialized == FALSE)
    {
        ERROR_OUT(("Q922: DLCI %d:  Init failed", DLCI));
    }

}


/*
 *    CLayerQ922::~CLayerQ922 (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the CLayerQ922 destructor.  This routine cleans up the mess.
 */
CLayerQ922::~CLayerQ922(void)
{
    TRACE_OUT(("CLayerQ922::~CLayerQ922"));

    BOOL        queue_full;
    PMemory        memory;

    TRACE_OUT(("Q922: Destructor: DLCI = %d  Receive_Sequence_Exception = %d",
        DLCI, Receive_Sequence_Exception));
    TRACE_OUT(("Q922: Destructor: DLCI = %d  Receive_Sequence_Recovery = %d",
        DLCI, Receive_Sequence_Recovery));

    m_pMultiplexer->RemoveHigherLayer (DLCI);

    StopTimerT200 ();
    StopTimerT203 ();

    if (Data_Indication != NULL)
        LocalFree ((HLOCAL) Data_Indication);
    if (Data_Indication_Buffer != NULL)
        LocalFree ((HLOCAL) Data_Indication_Buffer);
    if (Data_Request != NULL)
    {
         /*
         **    Data_Request_Head is the head of the list,
         **    Data_Request_Acknowledge_Tail is the absolute tail of the list.
         **    If the list is full, Data_Request_Head equals
         **    Data_Request_Acknowledge_Tail.  Therefore, we have to check
         **    Data_Request_Count to see if it is full or empty.
         */
        if ((Data_Request_Head == Data_Request_Acknowledge_Tail) &&
            (Data_Request_Count != 0))
        {
            queue_full = TRUE;
        }
        else
            queue_full = FALSE;

         /*
         **    We have to unlock any memory blocks that are in use
         */
        while ((Data_Request_Head != Data_Request_Acknowledge_Tail) || queue_full)
        {
            memory = *(Data_Request + Data_Request_Acknowledge_Tail);

            Data_Request_Memory_Manager -> UnlockMemory (memory);

            if (++Data_Request_Acknowledge_Tail == Data_Request_Total_Size)
            {
                Data_Request_Acknowledge_Tail = 0;
            }

            if (queue_full)
            {
                queue_full = FALSE;
            }
        }
        LocalFree ((HLOCAL) Data_Request);
    }

}


/*
 *    CLayerQ922::Reset (void)
 *
 *    Functional Description:
 *        This function resets the link state variables.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::Reset (void)
{
    TRACE_OUT(("CLayerQ922::Reset"));

    BOOL        queue_full;
    PMemory        memory;

    Data_Indication_Head = 0;
    Data_Indication_Tail = 0;
    Data_Indication_Count = 0;

     /*
     **    Data_Request_Head is the head of the list,
     **    Data_Request_Acknowledge_Tail is the absolute tail of the list.
     **    If the list is full, Data_Request_Head equals
     **    Data_Request_Acknowledge_Tail.  Therefore, we have to check
     **    Data_Request_Count to see if it is full or empty.
     */
    if ((Data_Request_Head == Data_Request_Acknowledge_Tail) &&
        (Data_Request_Count != 0))
    {
        queue_full = TRUE;
    }
    else
        queue_full = FALSE;

     /*
     **    We have to unlock any memory blocks that are in use
     */
    while ((Data_Request_Head != Data_Request_Acknowledge_Tail) || queue_full)
    {
        memory = *(Data_Request + Data_Request_Acknowledge_Tail);

        Data_Request_Memory_Manager -> UnlockMemory (memory);

        if (++Data_Request_Acknowledge_Tail == Data_Request_Total_Size)
            Data_Request_Acknowledge_Tail = 0;

        if (queue_full)
        {
            queue_full = FALSE;
        }
    }

    Data_Request_Head = 0;
    Data_Request_Tail = 0;
    Data_Request_Count = 0;
    Data_Request_Acknowledge_Tail = 0;

    Outstanding_Packets = 0;
    Outstanding_Bytes = 0;
    Total_Retransmitted = 0;

    Send_State_Variable = 0;
    Receive_State_Variable = 0;
    Acknowledge_State_Variable = 0;

    Own_Receiver_Busy = FALSE;
    Peer_Receiver_Busy = FALSE;

    Command_Pending = FALSE;
    Poll_Pending = FALSE;
    Final_Pending = FALSE;
    Acknowledge_Pending = FALSE;
    Reject_Pending = FALSE;
    Reject_Outstanding = FALSE;

    SABME_Pending = FALSE;
    Frame_Reject_Pending = FALSE;
    Unnumbered_Acknowledge_Pending = FALSE;
    DISC_Pending = FALSE;
    Final_Packet = FALSE;
    Disconnected_Mode_Pending = FALSE;


    N200_Count = 0;
    Link_Stable = TRUE;

    Receive_Sequence_Exception = 0;
    Receive_Sequence_Recovery = 0;

    StopTimerT200 ();
    StopTimerT203 ();
}


/*
 *    DataLinkError    CLayerQ922::ReleaseRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function sets the necessary flags to terminate the link
 */
DataLinkError    CLayerQ922::ReleaseRequest (void)
{
    TRACE_OUT(("CLayerQ922::ReleaseRequest"));

    if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
        (Data_Link_Mode == TIMER_RECOVERY))
    {
         /*
         **    Queue up the DISC_Pending flag to send out a DISC packet
         */
        DISC_Pending = TRUE;
        Unnumbered_PF_State = UNNUMBERED_PF_SET;
        Data_Link_Mode = AWAITING_RELEASE;

        StopTimerT200 ();
        StopTimerT203 ();
    }
    else
    {
        m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_CONFIRM,
                               (void *) DLCI, (void *) DATALINK_NORMAL_DISCONNECT);
    }

    return (DATALINK_NO_ERROR);
}


/*
 *    DataLinkError    CLayerQ922::DataIndication (
 *                                LPBYTE        packet_address,
 *                                ULONG        buffer_size,
 *                                PULong        packet_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the lower layer when it has a packet to
 *        pass to us.
 */
ProtocolLayerError    CLayerQ922::DataIndication (
                                LPBYTE        packet_address,
                                ULONG        packet_length,
                                PULong        bytes_accepted)
{
    TRACE_OUT(("CLayerQ922::DataIndication"));

    BOOL        packet_processed = TRUE;

     /*
     **    The packet MUST be at least UNNUMBERED_HEADER_SIZE or it is
     **    invalid
     */
    if (packet_length < UNNUMBERED_HEADER_SIZE)
    {
        *bytes_accepted = packet_length;
        return (PROTOCOL_LAYER_NO_ERROR);
    }

    if (*(packet_address + CONTROL_BYTE_HIGH) & SUPERVISORY_FRAME_BIT)
    {
        if (*(packet_address + CONTROL_BYTE_HIGH) & UNNUMBERED_FRAME_BIT)
        {
             /*
             **    This packet is an unnumbered packet
             */
            switch (*(packet_address + CONTROL_BYTE_HIGH) &
                        UNNUMBERED_COMMAND_MASK)
            {
                case SABME:
                    ProcessSABME (
                        packet_address,
                        (USHORT) packet_length);
                    break;

                case UNNUMBERED_ACKNOWLEDGE:
                    ProcessUnnumberedAcknowledge (
                        packet_address,
                        (USHORT) packet_length);
                    break;

                case FRAME_REJECT:
                    ProcessFrameReject (
                        packet_address,
                        (USHORT) packet_length);
                    break;

                case DISCONNECTED_MODE:
                    ProcessDisconnectMode (
                        packet_address,
                        (USHORT) packet_length);
                    break;

                case DISC:
                    ProcessDISC (
                        packet_address,
                        (USHORT) packet_length);
                    break;

                default:
                    ERROR_OUT(("Q922: DLCI %d:  DataIndication: Illegal Packet: = %d",
                        DLCI, (*(packet_address + CONTROL_BYTE_HIGH) & UNNUMBERED_COMMAND_MASK)));
                    break;
            }
        }
        else
        {
             /*
             **    It is only legal to process supervisory frames if we
             **    are in the MULTIPLE_FRAME_ESTABLISHED or TIMER_RECOVERY
             **    modes
             */
            if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
                (Data_Link_Mode == TIMER_RECOVERY))
            {
                switch (*(packet_address + CONTROL_BYTE_HIGH) &
                            SUPERVISORY_COMMAND_MASK)
                {
                    case RECEIVER_READY:
                        ProcessReceiverReady (
                            packet_address,
                            (USHORT) packet_length);
                        break;

                    case RECEIVER_NOT_READY:
                        ProcessReceiverNotReady (
                            packet_address,
                            (USHORT) packet_length);
                        break;

                    case REJECT:
                        ProcessReject (
                            packet_address,
                            (USHORT) packet_length);
                        break;
                }
            }
            else
            {
                ERROR_OUT(("Q922:  DLCI %d: Supervisory packet received in illegal DataLink Mode", DLCI));
#ifdef _MCATIPX
                if (Data_Link_Mode != AWAITING_RELEASE)
                {
                     /*
                     ** This is necessary on an IPX network to notify the remote
                     **    site that this unit is no longer in the conference.  If
                     **    the previous conference ended without going through the
                     **    proper disconnect sequence, the remote site may continue
                     **    to send frames to this site.  In which case, we need to
                     **    notify the remote site that the conference is no longer
                     **    active.  We are doing this by sending out a DISC frame.
                     **    The Q.921 specification does not address this situation.
                     */
                    DISC_Pending = TRUE;
                    Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                }
#endif
            }
        }
    }
    else
    {
         /*
         **    It is only legal to process Information frames if we
         **    are in the MULTIPLE_FRAME_ESTABLISHED or TIMER_RECOVERY
         **    modes
         */
        if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
            (Data_Link_Mode == TIMER_RECOVERY))
        {
            packet_processed = ProcessInformationFrame (
                                packet_address,
                                (USHORT) packet_length);
        }
        else
        {
            ERROR_OUT(("Q922:  DLCI %d: Information packet received in illegal DataLink Mode", DLCI));
#ifdef _MCATIPX
            if (Data_Link_Mode != AWAITING_RELEASE)
            {
                 /*
                 ** This is necessary on an IPX network to notify the remote
                 **    site that this unit is no longer in the conference.  If
                 **    the previous conference ended without going through the
                 **    proper disconnect sequence, the remote site may continue
                 **    to send frames to this site.  In which case, we need to
                 **    notify the remote site that the conference is no longer
                 **    active.  We are doing this by sending out a DISC frame.
                 **    The Q.921 specification does not address this situation.
                 */
                DISC_Pending = TRUE;
                Unnumbered_PF_State = UNNUMBERED_PF_RESET;
            }
#endif
        }
    }

     /*
     **    After we receive a packet we should start the T203 timer
     **    unless the T200 timer was started during the processing of
     **    the packet
     */
    if  (((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
        (Data_Link_Mode == TIMER_RECOVERY)) &&
        (T200_Active == FALSE) &&
        (DLCI == 0))
    {
        StartTimerT203 ();
    }

    if (packet_processed)
    {
        if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
            (Data_Link_Mode == TIMER_RECOVERY))
        {
            N200_Count = 0;
        }
        *bytes_accepted = packet_length;
    }
    else
        *bytes_accepted = 0;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerQ922::PollTransmitter (
 *                                    ULONG,
 *                                    USHORT    data_to_transmit,
 *                                    USHORT *    pending_data,
 *                                    USHORT *    holding_data);
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to give us a chance to transmit packets.
 *        The data_to_transmit mask tells us which data to transmit, either
 *        control or user data.
 */
ProtocolLayerError    CLayerQ922::PollTransmitter (
                                ULONG_PTR,
                                USHORT    data_to_transmit,
                                USHORT *    pending_data,
                                USHORT *    holding_data)
{
    // TRACE_OUT(("CLayerQ922::PollTransmitter"));

    *pending_data = 0;

     /*
     **    If we are permitted to transmit data, call ProcessWriteQueue ()
     */
    if ((data_to_transmit & PROTOCOL_CONTROL_DATA) ||
        (data_to_transmit & PROTOCOL_USER_DATA))
    {
        ProcessWriteQueue (data_to_transmit);
    }

     /*
     **    We have to set the pending data variable to reflect which data
     **    we still need to send out
     */
    if (Data_Request_Count != 0)
        *pending_data |= PROTOCOL_USER_DATA;

    if (Poll_Pending || Final_Pending || Command_Pending ||
        (Reject_Pending && (Own_Receiver_Busy == FALSE)) ||
        Acknowledge_Pending || SABME_Pending ||
        Unnumbered_Acknowledge_Pending || Frame_Reject_Pending ||
        DISC_Pending)
    {
        *pending_data |= PROTOCOL_CONTROL_DATA;
    }

    *holding_data = Outstanding_Packets;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    DataLinkError    CLayerQ922::DataRequest (
 *                                ULONG,
 *                                PMemory        memory,
 *                                PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the higher layer to send a packet to the
 *        remote site.
 */
ProtocolLayerError    CLayerQ922::DataRequest (
                                ULONG_PTR,
                                PMemory        memory,
                                PULong        bytes_accepted)
{
    TRACE_OUT(("CLayerQ922::DataRequest"));

    PMemory   * data_request;
    USHORT        trash_word;
    ULONG        packet_length;
    ULONG        information_size;

    *bytes_accepted = 0;

    packet_length = memory -> GetLength ();

     /*
     **    Determine the actual information length
     */
    information_size =
        packet_length - Lower_Layer_Prepend -
        Lower_Layer_Append - DATALINK_PACKET_OVERHEAD;

     /*
     **    See if the information content is too big.
     */
    if (information_size > Maximum_Information_Size)
    {
        TRACE_OUT(("Q922: DLCI %d: DataRequest: Requested packet = %d, max = %d",
            DLCI, information_size, Maximum_Information_Size));
        return (PROTOCOL_LAYER_PACKET_TOO_BIG);
    }

    if (Data_Request_Count < Data_Request_Size)
    {
         /*
         **    Set write_queue to the correct location
         */
        data_request = Data_Request + Data_Request_Head;
        *data_request = memory;

         /*
         **    Lock the memory object so that it won't be released
         */
        Data_Request_Memory_Manager -> LockMemory (memory);
        if (++Data_Request_Head == Data_Request_Total_Size)
            Data_Request_Head = 0;
        Data_Request_Count++;

        *bytes_accepted = packet_length;

         /*
         **    If the higher layer got permission to send data to me, I will
         **    attempt to send it on out
         */
        PollTransmitter (
            0,
            PROTOCOL_USER_DATA | PROTOCOL_CONTROL_DATA,
            &trash_word,
            &trash_word);
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    DataLinkError    CLayerQ922::DataRequest (
 *                                ULONG,
 *                                PMemory        memory,
 *                                PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the higher layer to send a packet to the
 *        remote site.  This type of data passing is NOT supported by this
 *        layer.
 */
ProtocolLayerError    CLayerQ922::DataRequest (
                                ULONG_PTR,
                                LPBYTE,
                                ULONG,
                                PULong    bytes_accepted)
{
    *bytes_accepted = 0;
    return (PROTOCOL_LAYER_ERROR);
}



/*
 *    ProtocolLayerError    CLayerQ922::PollReceiver (
 *                                    ULONG)
 *
 *    Public
 *
 *    Functional Description
 *        This function is called to give us a chance to send packets to the
 *        higher layer
 */
ProtocolLayerError CLayerQ922::PollReceiver(void)
{
    ULONG        bytes_accepted;
    PDataQueue    data_indication;

     /*
     **    If I have any packet in my receive buffers that
     **    need to go to higher layers, send them now
     */
    while (Data_Indication_Count != 0)
    {
        data_indication = Data_Indication + Data_Indication_Tail;
        if (Higher_Layer == NULL)
            break;
        Higher_Layer -> DataIndication (
                            data_indication -> buffer_address,
                            data_indication -> length,
                            &bytes_accepted);

        if (bytes_accepted == (data_indication -> length))
        {
            if (++Data_Indication_Tail == Data_Indication_Size)
                Data_Indication_Tail = 0;
            Data_Indication_Count--;

             /*
             **    If we had been in a Receiver Busy mode, exit it
             */
            if (Own_Receiver_Busy)
            {
                Own_Receiver_Busy = FALSE;
                Command_Pending = TRUE;
            }
        }
        else
            break;
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    void    CLayerQ922::ProcessWriteQueue (
 *                        USHORT    data_to_transmit)
 *
 *    Functional Description
 *        This function determines which type of data needs to be sent out, and
 *        sends it.
 *
 *    Formal Parameters
 *        data_to_transmit    (i)    -    Mask telling us which data is allowed to be
 *                                    transmitted
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessWriteQueue (
                    USHORT    data_to_transmit)
{
    // TRACE_OUT(("CLayerQ922::ProcessWriteQueue"));

    BOOL        continue_loop = TRUE;

    while (continue_loop)
    {
        switch (Data_Link_Mode)
        {
            case AWAITING_RELEASE:
            case TEI_ASSIGNED:
            case AWAITING_ESTABLISHMENT:
                if (SABME_Pending || DISC_Pending || Unnumbered_Acknowledge_Pending ||
                    Disconnected_Mode_Pending || Frame_Reject_Pending)
                {
                    continue_loop = TransmitUnnumberedFrame ();
                }
                else
                {
                    continue_loop = FALSE;
                }
                break;

            default:
                if (Poll_Pending)
                {
                    continue_loop = TransmitSupervisoryFrame (COMMAND_FRAME, PF_SET);
                }
                else if (Final_Pending)
                {
                    continue_loop = TransmitSupervisoryFrame (RESPONSE_FRAME, PF_SET);
                }
                else if (Command_Pending)
                {
                    continue_loop = TransmitSupervisoryFrame (COMMAND_FRAME, PF_RESET);
                }
                else if (Reject_Pending && (Own_Receiver_Busy == FALSE))
                {
                    continue_loop = TransmitSupervisoryFrame (RESPONSE_FRAME, PF_RESET);
                }
                else if (Unnumbered_Acknowledge_Pending || Frame_Reject_Pending)
                {
                    continue_loop = TransmitUnnumberedFrame ();
                }
                else if ((data_to_transmit & PROTOCOL_USER_DATA) &&
                        (Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) &&
                        (Data_Request_Count != 0) &&
                        (Outstanding_Packets < Maximum_Outstanding_Packets) &&
                        (Outstanding_Bytes < Maximum_Outstanding_Bytes) &&
                        (Peer_Receiver_Busy == FALSE))
                {
                    continue_loop = TransmitInformationFrame ();
                }
                else if (Acknowledge_Pending)
                {
                    continue_loop = TransmitSupervisoryFrame (RESPONSE_FRAME, PF_RESET);
                }
                else
                {
                    continue_loop = FALSE;
                }

                if (continue_loop)
                {
                    if ((T200_Active == FALSE) && (DLCI == 0))
                        StartTimerT203 ();
                }
                break;
        }
    }
}


/*
 *    BOOL        CLayerQ922::TransmitUnnumberedFrame ()
 *
 *    Functional Description
 *        This function builds an unnumbered packet and attempts to send it out.
 *        The only packets that can be sent by this function are SABME, DISC, and
 *        an Unnumbered Acknowledge.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRUE            -    If a packet was transmitted
 *        FALSE            -    If a packet was not transmitted
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
BOOL        CLayerQ922::TransmitUnnumberedFrame ()
{
    TRACE_OUT(("CLayerQ922::TransmitUnnumberedFrame"));

    LPBYTE        packet_address;
    UChar        command;
    ULONG        bytes_written;
    PMemory        memory;
    USHORT        total_length;
    UChar        frame_type;

     /*
     **    Use the Supervisory Buffer to transmit the packet
     */
    total_length = UNNUMBERED_HEADER_SIZE + Lower_Layer_Prepend +
                    Lower_Layer_Append;

    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);

    if (memory == NULL)
        return (FALSE);
    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    if (SABME_Pending)
    {
        TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Transmitting SABME", DLCI));
        command = SABME;
        frame_type = COMMAND_FRAME;
    }
    else if (DISC_Pending)
    {
        TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Transmitting DISC", DLCI));
        command = DISC;
        frame_type = COMMAND_FRAME;
    }
    else if (Unnumbered_Acknowledge_Pending)
    {
        TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Transmitting UNNUMBERED_ACKNOWLEDGE", DLCI));
        command = UNNUMBERED_ACKNOWLEDGE;
        frame_type = RESPONSE_FRAME;
    }
    else if (Disconnected_Mode_Pending)
    {
        TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Transmitting DISCONNECTED_MODE", DLCI));
        command = DISCONNECTED_MODE;
        frame_type = RESPONSE_FRAME;
    }
    else if (Frame_Reject_Pending)
    {
        TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Transmitting FRAME_REJECT", DLCI));
        command = FRAME_REJECT;
        frame_type = RESPONSE_FRAME;
    }
    else
    {
        ERROR_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Illegally called function", DLCI));
    }

     /*
     **    Assemble the packet for transmission
     */
    *(packet_address + ADDRESS_BYTE_HIGH) =
        (ADDRESS_HIGH(DLCI)) | frame_type | ADDRESS_MSB;
    *(packet_address + ADDRESS_BYTE_LOW)  = (ADDRESS_LOW(DLCI)) | ADDRESS_LSB;
    *(packet_address + CONTROL_BYTE_HIGH) =
        command | Unnumbered_PF_State | 0x03;

     /*
     **    Attempt to send the packet to the lower layer
     */
    m_pMultiplexer->DataRequest(DLCI, memory, (PULong) &bytes_written);
    Data_Request_Memory_Manager -> FreeMemory (memory);

    if (bytes_written == total_length)
    {
        if (SABME_Pending)
        {
             /*
             **    Start the T200 timer after the SABME has been sent
             */
            StartTimerT200 ();
            SABME_Pending = FALSE;
        }
        else if (DISC_Pending)
        {
            TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedPacket DISC sent", DLCI));

             /*
             **    Start the T200 timer after the DISC has been sent
             */
            DISC_Pending = FALSE;
            StartTimerT200 ();
            Data_Link_Mode = AWAITING_RELEASE;
        }
        else if (Unnumbered_Acknowledge_Pending)
        {
            Unnumbered_Acknowledge_Pending = FALSE;

            TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedAck ack sent", DLCI));

             /*
             **    An Unnumbered Ack packet can be sent in response to two packets,
             **    the SABME or DISC.  If it is in response to a DISC, the
             **    Final_Packet flag is set to TRUE.  Therefore, we need to notify
             **    the owner that the link is terminated.
             */
            if (Final_Packet)
            {
                Final_Packet = FALSE;
                TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedAck: Issuing Release Indication", DLCI));
                m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                       (void *) DLCI, (void *) DATALINK_NORMAL_DISCONNECT);
            }
            else
            {
                 /*
                 **    Callback to the controller to let it know that the link is
                 **    established
                 */
                if ((Data_Link_Mode == TEI_ASSIGNED) ||
                    (Data_Link_Mode == AWAITING_ESTABLISHMENT))
                {
                    Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_ESTABLISH_INDICATION,
                                           (void *) DLCI);
                    Maximum_T200_Timeouts = Link_Maximum_T200_Timeouts;

                    if (DLCI == 0)
                        StartTimerT203 ();
                }
                else if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
                    (Data_Link_Mode == TIMER_RECOVERY))
                {
                    if (DLCI == 0)
                        StartTimerT203 ();
                }
            }
        }
        else if (Disconnected_Mode_Pending)
        {
            TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedPacket Disconnected Mode sent", DLCI));
            Disconnected_Mode_Pending = FALSE;
        }
        else if (Frame_Reject_Pending)
        {
            TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedPacket Frame Reject sent", DLCI));
            Frame_Reject_Pending = FALSE;
            m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                   (void *) DLCI, (void *) DATALINK_RECEIVE_SEQUENCE_EXCEPTION);
        }
        return (TRUE);
    }
    else
        return (FALSE);
}


/*
 *    void    CLayerQ922::TransmitSupervisoryFrame (
 *                        UChar    frame_type,
 *                        UChar    poll_final_bit)
 *
 *    Functional Description
 *        This function builds a Supervisory frame based on the
 *        current state of the protocol and the passed-in parameters.
 *
 *    Formal Parameters
 *        frame_type        -    (i)        The frame type can be either COMMAND_FRAME
 *                                    or RESPONSE_FRAME
 *        poll_final_bit    -    (i)        This flag is set in the packet to signal
 *                                    the remote site to respond to this packet.
 *
 *    Return Value
 *        TRUE            -    If a packet was actually transmitted
 *        FALSE            -    If a packet was not transmitted
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
BOOL        CLayerQ922::TransmitSupervisoryFrame (
                        UChar    frame_type,
                        UChar    poll_final_bit)
{
    TRACE_OUT(("CLayerQ922::TransmitSupervisoryFrame"));

    LPBYTE        packet_address;
    UChar        command;
    ULONG        bytes_written;
    USHORT        total_length;
    PMemory        memory;

     /*
     **    Transmit the packet using the Supervisory buffer
     */
    total_length = DATALINK_PACKET_OVERHEAD + Lower_Layer_Prepend +
                    Lower_Layer_Append;

     /*
     **    Get a memory object from the memory manager
     */
    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);
    if (memory == NULL)
        return (FALSE);
    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    if (Own_Receiver_Busy)
    {
        TRACE_OUT(("CLayerQ922::TransmitSupervisoryFrame: RECEIVER_NOT_READY"));
        command = RECEIVER_NOT_READY;
    }
    else if (Reject_Pending)
    {
        TRACE_OUT(("CLayerQ922::TransmitSupervisoryFrame: REJECT"));
        command = REJECT;
    }
    else
    {
        TRACE_OUT(("CLayerQ922::TransmitSupervisoryFrame: RECEIVER_READY"));
        command = RECEIVER_READY;
    }

     /*
     **    Set up the header including the Receive_State_Variable which
     **    indicates the next packet we expect to receive.
     */
    *(packet_address + ADDRESS_BYTE_HIGH) =
        (ADDRESS_HIGH(DLCI)) | frame_type | ADDRESS_MSB;
    *(packet_address + ADDRESS_BYTE_LOW)  = (ADDRESS_LOW(DLCI)) | ADDRESS_LSB;
    *(packet_address + CONTROL_BYTE_HIGH) = CONTROL_MSB | command;
    *(packet_address + CONTROL_BYTE_LOW) =
        (Receive_State_Variable << 1) | poll_final_bit;

     /*
     **    Send the packet to the lower layer
     */
    m_pMultiplexer->DataRequest(DLCI, memory, (PULong) &bytes_written);
    Data_Request_Memory_Manager -> FreeMemory (memory);

    if (bytes_written == total_length)
    {

        if (command == REJECT)
            Reject_Pending = FALSE;

        if (frame_type == COMMAND_FRAME)
        {
            Command_Pending = FALSE;

            if (poll_final_bit == PF_SET)
            {
                Poll_Pending = FALSE;

                 /*
                 **    If we are currently in a TIMER_RECOVERY mode, we
                 **    need to continue to set the T200 timer to make sure
                 **    that they receive this packet.
                 */
                if (Data_Link_Mode == TIMER_RECOVERY)
                    StartTimerT200 ();
            }
        }
        else
        {
            if (poll_final_bit == PF_SET)
                Final_Pending = FALSE;
        }
        Acknowledge_Pending = FALSE;
        return (TRUE);
    }
    else
        return (FALSE);
}


/*
 *    void    CLayerQ922::TransmitInformationFrame (void)
 *
 *    Functional Description
 *        This function builds an Information frame from its data request buffer.
 *        If applicable, it starts the T200 timer.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRUE            -    If a packet was actually transmitted
 *        FALSE            -    If a packet was not transmitted
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
BOOL        CLayerQ922::TransmitInformationFrame (void)
{
    TRACE_OUT(("CLayerQ922::TransmitInformationFrame"));

    PMemory     *    data_request;
    LPBYTE        packet_address;
    ULONG        total_length;
    PMemory        memory;
    ULONG        bytes_written;


     /*
     **    Get the address of the next memory object
     */
    data_request = Data_Request + Data_Request_Tail;
    memory = *data_request;
    packet_address = memory -> GetPointer ();
    total_length = memory -> GetLength ();
    packet_address += Lower_Layer_Prepend;

     /*
     **    Set up the packet header
     */
    *(packet_address + ADDRESS_BYTE_HIGH) =
        (ADDRESS_HIGH(DLCI)) | COMMAND_FRAME | ADDRESS_MSB;
    *(packet_address + ADDRESS_BYTE_LOW)  = (ADDRESS_LOW(DLCI)) | ADDRESS_LSB;
    *(packet_address + CONTROL_BYTE_HIGH) = (Send_State_Variable << 1);
    *(packet_address + CONTROL_BYTE_LOW) = (Receive_State_Variable << 1);

     /*
     **    Send packet to lower layer
     */
    m_pMultiplexer->DataRequest(DLCI, memory, (PULong) &bytes_written);
    if (bytes_written == total_length)
    {
        if (++Data_Request_Tail == Data_Request_Total_Size)
            Data_Request_Tail = 0;
        Data_Request_Count--;

        Outstanding_Packets++;
        Outstanding_Bytes += (USHORT) total_length;

         /*
         **    If this is the packet that the remote site is expecting,
         **    start the T200 timeout.
         */
        if (Send_State_Variable == Acknowledge_State_Variable)
            StartTimerT200 ();
        Send_State_Variable = ((Send_State_Variable + 1) % SEQUENCE_MODULUS);

        Acknowledge_Pending = FALSE;
        return (TRUE);
    }
    else
        return (FALSE);
}


/*
 *    void    CLayerQ922::ProcessSABME (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length);
 *
 *    Functional Description
 *        This function decodes the SABME packet received from the remote
 *        site.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        Puts us in AWAITING_ESTABLISHMENT mode
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessSABME (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessSABME"));

    BOOL            command_frame;
    BOOL            poll_final_bit;
    USHORT            status;

    if (packet_length != UNNUMBERED_HEADER_SIZE)
    {
        TRACE_OUT(("Q922: DLCI %d: SABME received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParseUnnumberedPacketHeader (
                packet_address,
                &command_frame,
                &poll_final_bit);

     /*
     **    The SABME packet can ONLY be a COMMAND, it can not be a RESPONSE
     */
    if (command_frame == FALSE)
    {
        TRACE_OUT(("Q922: DLCI %d: SABME RESPONSE received: Illegal packet", DLCI));
        return;
    }

    if (status == DATALINK_NO_ERROR)
    {
        switch (Data_Link_Mode)
        {
            case TEI_ASSIGNED:
            case AWAITING_ESTABLISHMENT:
                 /*
                 **    If we are already in this mode, remain here and respond with
                 **    an unnumbered ack packet.
                 */
                Reset ();
                Unnumbered_Acknowledge_Pending = TRUE;
                if (poll_final_bit)
                    Unnumbered_PF_State = UNNUMBERED_PF_SET;
                else
                    Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                break;

            case MULTIPLE_FRAME_ESTABLISHED:
            case TIMER_RECOVERY:
                if (Send_State_Variable == Acknowledge_State_Variable)
                {
                    TRACE_OUT(("Q922: DLCI %d: ProcessSABME: in MULTIPLE_FRAME mode: Able to recover", DLCI));
                    Send_State_Variable = 0;
                    Receive_State_Variable = 0;
                    Acknowledge_State_Variable = 0;
                    StopTimerT200 ();

                    Unnumbered_Acknowledge_Pending = TRUE;
                    if (poll_final_bit)
                        Unnumbered_PF_State = UNNUMBERED_PF_SET;
                    else
                        Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                }
                else
                {
                    TRACE_OUT(("Q922: DLCI %d: ProcessSABME: Illegal packet mode = %d", DLCI, Data_Link_Mode));
                    Data_Link_Mode = TEI_ASSIGNED;
                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                           (void *) DLCI, (void *) DATALINK_ILLEGAL_PACKET_RECEIVED);
                }
                break;

            case AWAITING_RELEASE:
                Disconnected_Mode_Pending = TRUE;
                if (poll_final_bit)
                    Unnumbered_PF_State = UNNUMBERED_PF_SET;
                else
                    Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                break;
        }
    }
}


/*
 *    void    CLayerQ922::ProcessUnnumberAcknowledge (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length);
 *
 *    Functional Description
 *        This function decodes an unnumbered acknowledge packet.  This packet is
 *        received in response to a SABME or DISC packet that we sent out.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessUnnumberedAcknowledge (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessUnnumberedAcknowledge"));

    BOOL            command_frame;
    BOOL            poll_final_bit;
    ULONG_PTR            disconnect_reason;
    USHORT            status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length != UNNUMBERED_HEADER_SIZE)
    {
        ERROR_OUT(("Q922: DLCI %d: Unnumbered ACK received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParseUnnumberedPacketHeader (
                packet_address,
                &command_frame,
                &poll_final_bit);

     /*
     **    Unnumbered Ack packet can ONLY be a RESPONSE, it can not be a COMMAND
     */
    if (command_frame)
    {
        ERROR_OUT(("Q922: DLCI %d: Unnumbered Ack COMMAND received: Illegal packet", DLCI));
        return;
    }

    if (status == DATALINK_NO_ERROR)
    {
        switch (Data_Link_Mode)
        {
            case AWAITING_ESTABLISHMENT:
                if (poll_final_bit)
                {
                     /*
                     **    If we are awaiting establishment and we receive a UA
                     **    to our SABME, enter the MULTIPLE_FRAME_ESTABLISHED mode.
                     */
                    Reset ();
                    Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
                    Maximum_T200_Timeouts = Link_Maximum_T200_Timeouts;

                    StopTimerT200 ();
                    if (DLCI == 0)
                        StartTimerT203 ();

                     /*
                     **    Callback to the controller
                     */
                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_ESTABLISH_CONFIRM,
                                           (void *) DLCI);
                }
                break;

            case AWAITING_RELEASE:
                if (Unnumbered_Acknowledge_Pending == FALSE)
                {
                    TRACE_OUT(("Q922: DLCI %d: ProcessUnnumberedAck: Issuing Release Indication", DLCI));
                    if (Receive_Sequence_Exception != 0)
                        disconnect_reason = DATALINK_RECEIVE_SEQUENCE_EXCEPTION;
                    else
                        disconnect_reason = DATALINK_NORMAL_DISCONNECT;

                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_CONFIRM,
                                           (void *) DLCI, (void *) disconnect_reason);
                }
                StopTimerT200 ();
                break;

            case TEI_ASSIGNED:
                TRACE_OUT(("Q922: DLCI %d: Illegal Unnumbered Ack", DLCI));
                m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                       (void *) DLCI, (void *) DATALINK_ILLEGAL_PACKET_RECEIVED);
                break;

            case MULTIPLE_FRAME_ESTABLISHED:
            case TIMER_RECOVERY:
                WARNING_OUT(("Q922: DLCI %d: ProcessUnnumberedAcknowledge: Illegal packet", DLCI));
                break;
        }
    }
}


/*
 *    void    CLayerQ922::ProcessDisconnectMode (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length);
 *
 *    Functional Description
 *        This function decodes a Disconnect Mode packet.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessDisconnectMode (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessDisconnectMode"));

    BOOL        command_frame;
    BOOL        poll_final_bit;
    USHORT        status;

    if (packet_length != UNNUMBERED_HEADER_SIZE)
    {
        TRACE_OUT(("Q922: DLCI %d: Unnumbered ACK received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParseUnnumberedPacketHeader (
                packet_address, &command_frame, &poll_final_bit);

     /*
     **    DM packet can ONLY be a RESPONSE, it can not be a COMMAND
     */
    if (command_frame)
    {
        TRACE_OUT(("Q922: DLCI %d: DM COMMAND received: Illegal packet", DLCI));
        return;
    }

    if (status == DATALINK_NO_ERROR)
    {
        switch (Data_Link_Mode)
        {
            case AWAITING_ESTABLISHMENT:
                if (poll_final_bit && Link_Originator)
                {
                    Reset ();
                    Data_Link_Mode = TEI_ASSIGNED;

                    StopTimerT200 ();

                     /*
                     **    Callback to the controller
                     */
                    TRACE_OUT(("Q922: DLCI %d: ProcessDisconnectMode: Releasing connection", DLCI));
                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                           (void *) DLCI, (void *) DATALINK_NORMAL_DISCONNECT);
                }
                break;

            case AWAITING_RELEASE:
                if (poll_final_bit)
                {
                    Reset ();
                    Data_Link_Mode = TEI_ASSIGNED;

                    StopTimerT200 ();

                     /*
                     **    Callback to the controller
                     */
                    TRACE_OUT(("Q922: DLCI %d: ProcessDisconnectMode: A_R: Releasing connection", DLCI));
                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_CONFIRM,
                                           (void *) DLCI, (void *) DATALINK_NORMAL_DISCONNECT);
                }
                break;

            case TEI_ASSIGNED:
                break;

            case MULTIPLE_FRAME_ESTABLISHED:
            case TIMER_RECOVERY:
                TRACE_OUT(("Q922: DLCI %d: ProcessDM:  Illegal packet", DLCI));
                m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                       (void *) DLCI, (void *) DATALINK_ILLEGAL_PACKET_RECEIVED);
                break;
        }
    }
}


/*
 *    void    CLayerQ922::ProcessDISC (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length);
 *
 *    Functional Description
 *        This function decodes a DISC packet.  We respond to this packet with
 *        an Unnumbered Ack packet.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessDISC (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessDISC"));

    BOOL        command_frame;
    BOOL        poll_final_bit;
    USHORT        status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length != UNNUMBERED_HEADER_SIZE)
    {
        TRACE_OUT(("Q922: DLCI %d: DISC received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    TRACE_OUT(("Q922: DLCI %d:  DISCONNECT received", DLCI));
    status = ParseUnnumberedPacketHeader (
                packet_address, &command_frame, &poll_final_bit);

     /*
     **    The DISC packet can ONLY be a COMMAND, it can not be a RESPONSE
     */
    if (command_frame == FALSE)
    {
        TRACE_OUT(("Q922: DLCI %d: DISC RESPONSE received: Illegal packet", DLCI));
        return;
    }

    if (status == DATALINK_NO_ERROR)
    {
        switch (Data_Link_Mode)
        {
            case TEI_ASSIGNED:
            case AWAITING_ESTABLISHMENT:
                Disconnected_Mode_Pending = TRUE;
                if (poll_final_bit)
                    Unnumbered_PF_State = UNNUMBERED_PF_SET;
                else
                    Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                break;

            case AWAITING_RELEASE:
                Unnumbered_Acknowledge_Pending = TRUE;
                Final_Packet = TRUE;
                Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                break;

            case MULTIPLE_FRAME_ESTABLISHED:
            case TIMER_RECOVERY:
                Unnumbered_Acknowledge_Pending = TRUE;
                Final_Packet = TRUE;
                Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                break;
        }
    }
}


/*
 *    void    CLayerQ922::ProcessFrameReject (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length);
 *
 *    Functional Description
 *        This function decodes the Frame Reject packet.  We currently don't fully
 *        support this packet.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessFrameReject (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessFrameReject"));

    BOOL        command_frame;
    BOOL        poll_final_bit;
    USHORT        status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length < UNNUMBERED_HEADER_SIZE)
    {
        ERROR_OUT(("Q922: DLCI %d: Frame Reject received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParseUnnumberedPacketHeader (
                packet_address, &command_frame, &poll_final_bit);

     /*
     **    The FRMR packet can ONLY be a RESPONSE, it can not be a COMMAND
     */
    if (command_frame)
    {
        ERROR_OUT(("Q922: DLCI %d: FRMR COMMAND received: Illegal packet", DLCI));
        return;
    }

    if (status == DATALINK_NO_ERROR)
    {
        switch (Data_Link_Mode)
        {
            case TEI_ASSIGNED:
            case AWAITING_ESTABLISHMENT:
            case AWAITING_RELEASE:
            case MULTIPLE_FRAME_ESTABLISHED:
            case TIMER_RECOVERY:
                ERROR_OUT(("Q922: DLCI %d ProcessFrameReject:  Illegal packet", DLCI));

                m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                       (void *) DLCI, (void *) DATALINK_ILLEGAL_PACKET_RECEIVED);
                break;
        }
    }
}


/*
 *    void    CLayerQ922::ProcessReceiverReady (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length)
 *
 *    Functional Description
 *        This function decodes the Receiver Ready packet that is in the
 *        input buffer.  From the packet, we get the packet sequence
 *        number that the remote site is expecting.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessReceiverReady (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessReceiverReady"));

    BOOL        command_frame;
    UChar        receive_sequence_number;
    BOOL        poll_final_bit;
    USHORT        status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length != DATALINK_PACKET_OVERHEAD)
    {
        ERROR_OUT(("Q922: DLCI %d: Receiver Ready received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParsePacketHeader (
                packet_address,
                packet_length,
                &command_frame,
                &receive_sequence_number,
                &poll_final_bit);

    if (status == DATALINK_NO_ERROR)
    {
        if (command_frame && poll_final_bit)
        {
            Final_Pending = TRUE;
        }

        Peer_Receiver_Busy = FALSE;

         /*
         **    If the remote site is expecting a packet sequence number
         **    that is not equal to our Acknowledge_State_Variable,
         **    update it
         */
        if (Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED)
        {
            if (Acknowledge_State_Variable != receive_sequence_number)
            {
                UpdateAcknowledgeState (receive_sequence_number);

                 /*
                 **    If we have received the last acknowledge,
                 **    stop the T200 timer
                 */
                if (Acknowledge_State_Variable == Send_State_Variable)
                    StopTimerT200 ();
                else
                    StartTimerT200 ();
            }
        }
        else
        {
             /*
             **    If we are in TIMER_RECOVERY mode, update the
             **    Acknowledge_State_Variable and resend the packets
             **    that need to be sent.
             */
            UpdateAcknowledgeState (receive_sequence_number);

            if ((command_frame == FALSE) && poll_final_bit)
            {
                ResetSendState ();

                StopTimerT200 ();

                if (Data_Link_Mode != AWAITING_RELEASE)
                    Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
            }
        }
    }
    else
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessReceiverReady: Error Processing packet", DLCI));
    }
}


/*
 *    void    CLayerQ922::ProcessReceiverNotReady (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length)
 *
 *    Functional Description
 *        This function decodes the Receiver Not Ready packet that
 *        is in the input buffer.  This packet notifies us that the
 *        remote site does not have room for Information packets.
 *        As a result of this packet, we won't send any more packets
 *        until the remote site sends us a Receiver Ready packet.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessReceiverNotReady (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessReceiverNotReady"));

    BOOL        command_frame;
    UChar        receive_sequence_number;
    BOOL        poll_final_bit;
    USHORT        status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length != DATALINK_PACKET_OVERHEAD)
    {
        TRACE_OUT(("Q922: DLCI %d: Receiver Not Ready received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParsePacketHeader (
                packet_address,
                packet_length,
                &command_frame,
                &receive_sequence_number,
                &poll_final_bit);

    if (status == DATALINK_NO_ERROR)
    {
        if (command_frame && poll_final_bit)
        {
            Final_Pending = TRUE;
        }

         /*
         **    Set the Peer_Receiver_Busy flag so that we don't send
         **    out any information packets.
         */
        Peer_Receiver_Busy = TRUE;

        UpdateAcknowledgeState (receive_sequence_number);

        if (Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED)
            StartTimerT200 ();
        else
        {
             /*
             **    If we are in TIMER_RECOVERY state, exit TIMER_RECOVERY
             **    state and update the acknowledge state.
             */
            if ((command_frame == FALSE) && poll_final_bit)
            {
                ResetSendState ();

                StartTimerT200 ();

                if (Data_Link_Mode != AWAITING_RELEASE)
                    Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
            }
        }
    }
    else
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessNotReceiverReady: Error Processing packet", DLCI));
    }
}


/*
 *    void    CLayerQ922::ProcessReject (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length)
 *
 *    Functional Description
 *        This function decodes the Receiver Reject packet that
 *        is in the input buffer.  This packet indicates that the
 *        remote site needs us to retransmit some packets.  It sends
 *        the next packet sequence number that it expects.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessReject (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessReject"));

    BOOL        command_frame;
    UChar        receive_sequence_number;
    BOOL        poll_final_bit;
    USHORT        status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length != DATALINK_PACKET_OVERHEAD)
    {
        ERROR_OUT(("Q922: DLCI %d: REJECT received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParsePacketHeader (
                packet_address,
                packet_length,
                &command_frame,
                &receive_sequence_number,
                &poll_final_bit);

    if (status == DATALINK_NO_ERROR)
    {
        if (command_frame && poll_final_bit)
        {
            Final_Pending = TRUE;
        }

        Peer_Receiver_Busy = FALSE;

         /*
         **    Update the Acknowledge_State_Variable and prepare to
         **    resend the packets that weren't acknowledged.
         */
        UpdateAcknowledgeState (receive_sequence_number);

        if (Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED)
        {
            ResetSendState ();

            StopTimerT200 ();
        }
        else
        {
            if ((command_frame == FALSE) && poll_final_bit)
            {
                ResetSendState ();

                StopTimerT200 ();

                if (Data_Link_Mode != AWAITING_RELEASE)
                    Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
            }
        }
    }
    else
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessReject: Error Processing packet", DLCI));
    }
}


/*
 *    BOOL        CLayerQ922::ProcessInformationFrame (
 *                            LPBYTE    packet_address,
 *                            USHORT    packet_length)
 *
 *    Functional Description
 *        This function processes the information packet.  It checks
 *        to see if it has the expected sequence number.  If it does,
 *        it puts it into the queue which will be read by the user.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        TRUE        -    If the packet was processed
 *        FALSE        -    If the packet was not processed
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
BOOL        CLayerQ922::ProcessInformationFrame (
                        LPBYTE    packet_address,
                        USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessInformationFrame"));

    BOOL            command_frame;
    UChar            receive_sequence_number;
    BOOL            poll_final_bit;
    USHORT            status;
    PDataQueue        read_queue;
    UChar            send_sequence_number;

    BOOL            packet_accepted;
    ULONG            bytes_accepted;

    if (packet_length < DATALINK_PACKET_OVERHEAD)
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessInformationFrame: Invalid packet length = %d",
            DLCI, packet_length-DATALINK_PACKET_OVERHEAD));
        return (FALSE);
    }

    if (packet_length > (DATALINK_PACKET_OVERHEAD + Maximum_Information_Size))
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessInformationFrame:  Invalid information length = %d",
            DLCI, packet_length - DATALINK_PACKET_OVERHEAD));
        return (FALSE);
    }

     /*
     **    If there isn't a place to put the packet, return FALSE
     */
    if ((Data_Indication_Count == Data_Indication_Size) ||
        Own_Receiver_Busy || (Higher_Layer == NULL))
    {
        return (FALSE);
    }

    status = ParsePacketHeader (
                packet_address,
                packet_length,
                &command_frame,
                &receive_sequence_number,
                &poll_final_bit);

    if (status == DATALINK_NO_ERROR)
    {
        if (poll_final_bit && command_frame)
        {
            Final_Pending = TRUE;
        }

        if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) &&
                (Peer_Receiver_Busy == FALSE))
        {
             /*
             **    If the remote site does NOT acknowledge the last packet
             **    that we sent out, Update the Acknowledge State variable
             **    by calling UpdateAcknowledgeState()
             */
            if (Acknowledge_State_Variable != receive_sequence_number)
            {
                UpdateAcknowledgeState (receive_sequence_number);

                 /*
                 **    If the received acknowledge, reflects the last
                 **    packet transmitted, stop the T200 timer.
                 */
                if (Acknowledge_State_Variable == Send_State_Variable)
                    StopTimerT200 ();
                else
                    StartTimerT200 ();
            }
        }
        else
        {
             /*
             **    If this is an I-Frame RESPONSE, exit the TIMER_RECOVERY
             **    state
             */
            UpdateAcknowledgeState (receive_sequence_number);

            if ((Data_Link_Mode == TIMER_RECOVERY) && (command_frame == FALSE)
                && poll_final_bit)
            {
                ResetSendState();

                Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
                StopTimerT200 ();
            }
        }


        send_sequence_number = (*(packet_address + CONTROL_BYTE_HIGH) >> 1);

         /*
         **    If this is the packet that we are waiting for,
         **    give it to the Transport Layer.
         */
        if (send_sequence_number == Receive_State_Variable)
        {
             /*
             **    Try to send the packet to the higher layer,
             **    if it accepts it, we won't have to copy it.
             */
            packet_accepted = FALSE;
            if (Data_Indication_Count == 0)
            {
                Higher_Layer -> DataIndication (
                                packet_address + DATALINK_PACKET_OVERHEAD,
                                packet_length - DATALINK_PACKET_OVERHEAD,
                                &bytes_accepted);
                if (bytes_accepted ==
                    (ULONG) (packet_length - DATALINK_PACKET_OVERHEAD))
                {
                    packet_accepted = TRUE;
                }
            }

             /*
             **    If the higher layer did not accept it, copy it into our
             **    Data Indication queue.
             */
            if (packet_accepted == FALSE)
            {
                read_queue = Data_Indication + Data_Indication_Head;
                memcpy ((PVoid) read_queue->buffer_address,
                        (PVoid) (packet_address + DATALINK_PACKET_OVERHEAD),
                        packet_length - DATALINK_PACKET_OVERHEAD);
                read_queue->length = packet_length-DATALINK_PACKET_OVERHEAD;

                if (++Data_Indication_Head == Data_Indication_Size)
                    Data_Indication_Head = 0;
                if (++Data_Indication_Count == Data_Indication_Size)
                {
                    Own_Receiver_Busy = TRUE;
                    TRACE_OUT(("Q922: DLCI %d: Own Receiver Busy", DLCI));
                }
            }

            Receive_State_Variable =
                ((Receive_State_Variable + 1) % SEQUENCE_MODULUS);

            Acknowledge_Pending = TRUE;
            Reject_Outstanding = FALSE;
        }
        else
        {
             /*
             **    If we were not expecting this packet, send a REJECT
             **    packet to the remote site.
             */
            if (Reject_Outstanding == FALSE)
            {
                Reject_Pending = TRUE;
                Reject_Outstanding = TRUE;
            }
        }
    }
    else
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessInformation: Error Processing packet", DLCI));
    }

    return (TRUE);
}


/*
 *    DataLinkError    CLayerQ922::ParsePacketHeader (
 *                                LPBYTE        packet_address,
 *                                USHORT        packet_length,
 *                                BOOL *        command_frame,
 *                                LPBYTE        receive_sequence_number,
 *                                BOOL *        poll_final_bit)
 *
 *    Functional Description
 *        This function decodes the packet header looking for three
 *        things:
 *
 *            1.  Is the packet a command frame?
 *            2.  What is the sequence number in the packet?
 *            3.  Does the packet require a respones?
 *
 *    Formal Parameters
 *        packet_address            -    (i)    Address of the new packet
 *        packet_length            -    (i)    Length of the new packet
 *        command_frame            -    (o)    Address of variable, it is set to TRUE
 *                                        if it is a COMMAND frame and FALSE if
 *                                        it is a RESPONSE frame
 *        receive_sequence_number    -    (o)    Address of variable, it holds the
 *                                        sequence number in the packet
 *        poll_final_bit            -    (o)    Address of variable, it is set to TRUE
 *                                        if we need to respond to the packet and
 *                                        FALSE if we don't
 *
 *    Return Value
 *        DATALINK_RECEIVE_SEQUENCE_VIOLATION    -
 *        DATALINK_NO_ERROR                    -
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
DataLinkError    CLayerQ922::ParsePacketHeader (
                            LPBYTE        packet_address,
#ifdef _DEBUG
                            USHORT        packet_length,
#else
                            USHORT,
#endif
                            BOOL *        command_frame,
                            LPBYTE        receive_sequence_number,
                            BOOL *        poll_final_bit)
{
    TRACE_OUT(("CLayerQ922::ParsePacketHeader"));

    DataLinkError    return_value = DATALINK_NO_ERROR;
    UChar            receive_sequence;
    UChar            send_state_sequence;

    if (*(packet_address + ADDRESS_BYTE_HIGH) & COMMAND_BIT)
        *command_frame = FALSE;
    else
        *command_frame = TRUE;

    *receive_sequence_number = (*(packet_address + CONTROL_BYTE_LOW) >> 1);

    if (*(packet_address + CONTROL_BYTE_LOW) & POLL_FINAL_BIT)
        *poll_final_bit = TRUE;
    else
        *poll_final_bit = FALSE;

    if (*receive_sequence_number < Acknowledge_State_Variable)
        receive_sequence = *receive_sequence_number + SEQUENCE_MODULUS;
    else
        receive_sequence = *receive_sequence_number;
    if (Send_State_Variable < Acknowledge_State_Variable)
        send_state_sequence = Send_State_Variable + SEQUENCE_MODULUS;
    else
        send_state_sequence = Send_State_Variable;

     /*
     **    Illegal Condition:  The remote site is acknowledging a
     **        packet that is not in the range of transmitted packets
     */
    if (receive_sequence > send_state_sequence)
    {
        TRACE_OUT(("Q922: DLCI %d: ParsePacketHeader:  Receive Sequence Exception: length = %d", DLCI, packet_length));
        TRACE_OUT(("Q922: ParsePacketHeader:  receive_sequence = %d", receive_sequence));
        TRACE_OUT(("Q922: ParsePacketHeader:  send_state_sequence = %d", send_state_sequence));
        TRACE_OUT(("Q922: ParsePacketHeader:  Acknowledge_State_Var = %d", Acknowledge_State_Variable));
        TRACE_OUT(("Q922: ParsePacketHeader:  Send_State_Variable = %d", Send_State_Variable));
        TRACE_OUT(("Q922: ParsePacketHeader: in-packet receive_sequence = %d", *receive_sequence_number));
        TRACE_OUT(("Q922: ParsePacketHeader: Data_Request_Count = %d", Data_Request_Count));

         /*
         **    The following piece of code checks the receive sequence number
         **    against our send state sequence number + the number of packets
         **    queued for transmission.  We are doing this to recover from one
         **    of two things:
         **
         **        1.  The T200 timeout value is not long enough.
         **        2.  This Q922 object is not able to check its input
         **            buffers quickly enough to respond to the remote site's
         **            command.  If the machine is overloaded with work to
         **            process, this error can occur.
         **
         **    We are checking to see if we are receiving an acknowledge
         **    for a packet that we have already transmitted once.  When we
         **    are in this out-of-sync state, it is possible to transmit an
         **    information packet, timeout, and receive a supervisory packet
         **    that does not acknowledge the last packet.  As a consequence,
         **    we reset our Send_State_Variable, so that we have no knowledge
         **    of transmitting the information packet.  We then may receive
         **    an acknowledge for the information packet, but we don't realize
         **    that we ever transmitted it.  This results in a Receive Sequence
         **    Exception.
         **
         **    To guard against this, we are checking to see if this acknowledge
         **    COULD be valid.  If it could be valid, we are processing it
         **    normally except for the receive sequence value.  We are setting
         **    the receive_sequence_number to that last good acknowledgement and
         **    we will eventually re-transmit the packet.  We also send up a
         **    warning to the node controller.
         **
         **    If the acknowledge is not possibly in our range of packets, we
         **    treat it as a real Receive Sequence Exception and break the link.
         */
        if (receive_sequence <= (send_state_sequence + Data_Request_Count))
        {
            *receive_sequence_number = Acknowledge_State_Variable;
            Receive_Sequence_Recovery++;

            TRACE_OUT(("Q922: ParsePacketHeader:  Attempting recovery from this exception"));
            TRACE_OUT(("Q922: ParsePacketHeader:  Recovery = %d", Receive_Sequence_Recovery));

             /*
             **    Let the user know that there is a problem
             */
            m_pT123->OwnerCallback(m_nMsgBase + T123_STATUS_MESSAGE,
                                   (void *) DLCI, (void *) DATALINK_TIMING_ERROR);
        }
        else
        {
            TRACE_OUT(("Q922: ParsePacketHeader:  CAN NOT recover from this exception"));
            Receive_Sequence_Exception++;
            DISC_Pending = TRUE;
            Unnumbered_PF_State = UNNUMBERED_PF_RESET;
            return_value = DATALINK_RECEIVE_SEQUENCE_VIOLATION;
        }
    }

    return (return_value);
}


/*
 *    DataLinkError    CLayerQ922::ParseUnnumberedPacketHeader (
 *                                BOOL *        command_frame,
 *                                LPBYTE        receive_sequence_number,
 *                                BOOL *        poll_final_bit)
 *
 *    Functional Description
 *        This function decodes the packet header looking for three
 *        things:
 *
 *            1.  Is the packet a command frame?
 *            2.  What is the sequence number in the packet?
 *            3.  Does the packet require a respone?
 *
 *    Formal Parameters
 *        command_frame            -    (o)    Address of variable, it is set to TRUE
 *                                        if it is a COMMAND frame and FALSE if
 *                                        it is a RESPONSE frame
 *        receive_sequence_number    -    (o)    Address of variable, it holds the
 *                                        sequence number in the packet
 *        poll_final_bit            -    (o)    Address of variable, it is set to TRUE
 *                                        if we need to respond to the packet and
 *                                        FALSE if we don't
 *
 *    Return Value
 *        DATALINK_RECEIVE_SEQUENCE_VIOLATION    -
 *        DATALINK_NO_ERROR                    -
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
DataLinkError    CLayerQ922::ParseUnnumberedPacketHeader (
                            LPBYTE        packet_address,
                            BOOL *        command_frame,
                            BOOL *        poll_final_bit)
{
    TRACE_OUT(("CLayerQ922::ParseUnnumberedPacketHeader"));

    if (*(packet_address + ADDRESS_BYTE_HIGH) & COMMAND_BIT)
        *command_frame = FALSE;
    else
        *command_frame = TRUE;

    if (*(packet_address + CONTROL_BYTE_HIGH) & UNNUMBERED_PF_SET)
        *poll_final_bit = TRUE;
    else
        *poll_final_bit = FALSE;

    return (DATALINK_NO_ERROR);
}


/*
 *    void    CLayerQ922::UpdateAcknowledgeState (
 *                        UChar    sequence_number)
 *
 *    Functional Description
 *        This function updates Acknowledge_State_Variable.  The parameter
 *        passed in is the sequence number of a packet that the remote site has
 *        successfully received.  By receiving this sequence number, we can
 *        remove the packet from our write queue as well as any packet that
 *        was transmitted before that packet.
 *
 *    Formal Parameters
 *        sequence_number    -    (i)    Sequence number of packet successfully
 *                                received by the remote site.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::UpdateAcknowledgeState (
                    UChar    sequence_number)
{
    TRACE_OUT(("CLayerQ922::UpdateAcknowledgeState"));

    UChar        packets_acknowledged;
    USHORT        count;
    PMemory        memory;
    ULONG        total_length;

    if (Acknowledge_State_Variable != sequence_number)
    {
         /*
         **    Find the number of packets acknowledged by this sequence
         **    number.  If the remote site receives X packets successfully,
         **    the next time the remote site transmits, it will send out an
         **    acknowledge for the LAST packet received.  All packets
         **    received before it are acknowledged by default.
         */
        if (sequence_number < Acknowledge_State_Variable)
        {
            packets_acknowledged = ((sequence_number + SEQUENCE_MODULUS) -
                    Acknowledge_State_Variable);
        }
        else
        {
            packets_acknowledged =
                (sequence_number - Acknowledge_State_Variable);
        }

         /*
         **    Go thru each of the packets acknowledged and Unlock the memory
         **    object associated with it.  This will free the memory.
         */
        for (count=0; count < packets_acknowledged; count++)
        {
            memory = *(Data_Request + Data_Request_Acknowledge_Tail);
            total_length = memory -> GetLength ();

            Outstanding_Packets--;
            Outstanding_Bytes -= (USHORT) total_length;

            Data_Request_Memory_Manager -> UnlockMemory (memory);

            if (++Data_Request_Acknowledge_Tail == Data_Request_Total_Size)
                Data_Request_Acknowledge_Tail = 0;
        }

        Acknowledge_State_Variable = sequence_number;
    }
}


/*
 *    void    CLayerQ922::ResetSendState (void)
 *
 *    Functional Description
 *        This function is called when we need to retransmit packets.
 *        The Send_State_Variable is reset to equal the
 *        Acknowledge_State_Variable.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ResetSendState (void)
{
    TRACE_OUT(("CLayerQ922::ResetSendState"));

     /*
     **    Reset the Send_State_Variable so that we resend packets.
     */
    if (Send_State_Variable != Acknowledge_State_Variable)
    {
        Total_Retransmitted += (DWORD) Outstanding_Packets;
        TRACE_OUT(("Q922: DLCI %d: retransmitting %d packets -- Total = %ld",
                DLCI, Outstanding_Packets, Total_Retransmitted));

        Data_Request_Tail = Data_Request_Acknowledge_Tail;
        Data_Request_Count += Outstanding_Packets;

        Outstanding_Packets = 0;
        Outstanding_Bytes = 0;

        Send_State_Variable = Acknowledge_State_Variable;
    }
}


/*
 *    void    CLayerQ922::StartTimerT200 (void)
 *
 *    Functional Description
 *        This function starts the T200 timer.  This timer us started when
 *        we send a packet and expect a response.  If the response is not
 *        received within the T200 time span.  The timer expires and we
 *        enter a TIMER_RECOVERY state.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::StartTimerT200 (void)
{
    TRACE_OUT(("CLayerQ922::StartTimerT200"));

    if (T200_Active)
    {
        StopTimerT200 ();
    }

    if (T203_Active)
    {
        StopTimerT203 ();
    }

    T200_Handle = g_pSystemTimer->CreateTimerEvent(T200_Timeout,
                                                   TIMER_EVENT_ONE_SHOT,
                                                   this,
                                                   (PTimerFunction) &CLayerQ922::T200Timeout);

    T200_Active = TRUE;
}


/*
 *    void    CLayerQ922::StopTimerT200 (void)
 *
 *    Functional Description
 *        This function stops the T200 timer.  If we receive a response
 *        to a packet before the T200 timer expires, this function is
 *        called.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::StopTimerT200 (void)
{
    TRACE_OUT(("CLayerQ922::StopTimerT200"));

    if (T200_Active)
    {
        if (g_pSystemTimer->DeleteTimerEvent(T200_Handle) != TIMER_NO_ERROR)
        {
            TRACE_OUT(("Q922: StopTimerT200: DLCI %d: Illegal Timer handle = %d", DLCI, T200_Handle));
        }
        T200_Active = FALSE;
    }
}


/*
 *    void    CLayerQ922::T200Timeout (
 *                        TimerEventHandle)
 *
 *    Functional Description
 *        This function is called by the timer class when the T200
 *        timer expires.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void CLayerQ922::T200Timeout(TimerEventHandle)
{
    TRACE_OUT(("CLayerQ922::T200Timeout"));

    BOOL send_disconnect = FALSE;

    T200_Active = FALSE;
    N200_Count++;

    TRACE_OUT(("Q922::T200Timeout: %d DLCI: Timer Recovery: N200_Count = %x", DLCI, N200_Count));

    if ((Maximum_T200_Timeouts != 0xffff) &&
        (N200_Count >= Maximum_T200_Timeouts))
    {
        Link_Stable = FALSE;
        send_disconnect = TRUE;
    }

    switch  (Data_Link_Mode)
     {
        case TEI_ASSIGNED:
            break;

        case AWAITING_ESTABLISHMENT:
            if (! Link_Stable)
            {
                break;
            }
            if (Link_Originator)
            {
                SABME_Pending = TRUE;
                Unnumbered_PF_State = UNNUMBERED_PF_SET;
            }
            break;

        case AWAITING_RELEASE:
            if (Final_Packet)
            {
                send_disconnect = TRUE;
            }
            else
            {
                if (! Link_Stable)
                {
                    send_disconnect = TRUE;
                }
                else
                {
                    DISC_Pending = TRUE;
                    Unnumbered_PF_State = UNNUMBERED_PF_SET;
                }
            }
            break;

        default:
            if (! Link_Stable)
            {
                TRACE_OUT(("Q922: DLCI %d T200 Timeout: Broken Connection", DLCI));
                Reset ();
                Data_Link_Mode = TEI_ASSIGNED;
            }
            else
            {
                Data_Link_Mode = TIMER_RECOVERY;
                Poll_Pending = TRUE;
                StartTimerT200 ();
            }
    }

     /*
     **    Notify the owner that the link is unstable
     */
    if (send_disconnect)
    {
        m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                               (void *) DLCI, (void *) DATALINK_REMOTE_SITE_TIMED_OUT);
    }
}


/*
 *    void    CLayerQ922::StartTimerT203 (void)
 *
 *    Functional Description
 *        This function starts the T203 timer.  This function is called
 *        when the T200 timer is not active.  The T203 timer expires
 *        when we don't receive a packet from the remote site in T203
 *        seconds.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::StartTimerT203 (void)
{
    TRACE_OUT(("CLayerQ922::StartTimerT203"));

    if (T203_Timeout == 0)
    {
        return;
    }

    if (T203_Active)
    {
        StopTimerT203 ();
    }

    T203_Handle = g_pSystemTimer->CreateTimerEvent(
                    T203_Timeout, TIMER_EVENT_ONE_SHOT, this,
                    (PTimerFunction) &CLayerQ922::T203Timeout);

    T203_Active = TRUE;
}


/*
 *    void    CLayerQ922::StopTimerT203 (void)
 *
 *    Functional Description
 *        This function stops the T203 timer.  If we receive a packet
 *        while the T203 packet is active, this function is called.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::StopTimerT203 (void)
{
    TRACE_OUT(("CLayerQ922::StopTimerT203"));

    if (T203_Active)
    {
        g_pSystemTimer->DeleteTimerEvent(T203_Handle);
        T203_Active = FALSE;
    }
}


/*
 *    void    CLayerQ922::T203Timeout (
 *                        TimerEventHandle)
 *
 *    Functional Description
 *        This function is called by the timer class when the T203
 *        timer expires.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::T203Timeout (TimerEventHandle)
{
    TRACE_OUT(("CLayerQ922::T203Timeout"));

    T203_Active = FALSE;

    if (Data_Link_Mode == TEI_ASSIGNED)
    {
        TRACE_OUT(("Q922: DLCI %d: T203 Timeout: Releasing connection", DLCI));
        m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                               (void *) DLCI, (void *) DATALINK_REMOTE_SITE_TIMED_OUT);
        return;
    }

    StartTimerT200 ();

    Data_Link_Mode = TIMER_RECOVERY;
    Poll_Pending = TRUE;
}

/*
 *    ProtocolLayerError    CLayerQ922::GetParameters (
 *                                    USHORT,
 *                                    USHORT *    max_packet_size,
 *                                    USHORT *    prepend,
 *                                    USHORT *    append)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the maximum packet size permitted by
 *        the higher layer.
 */
ProtocolLayerError    CLayerQ922::GetParameters (
                                USHORT *    packet_size,
                                USHORT *    prepend,
                                USHORT *    append)
{
    TRACE_OUT(("CLayerQ922::GetParameters"));

    *prepend = DATALINK_PACKET_OVERHEAD + Lower_Layer_Prepend;
    *append = Lower_Layer_Append;
    *packet_size = Maximum_Information_Size;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerQ922::RegisterHigherLayer (
 *                                    USHORT,
 *                                    PMemoryManager,
 *                                    IProtocolLayer *    higher_layer);
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to register an identifier with a higher
 *        layer address.
 */
ProtocolLayerError    CLayerQ922::RegisterHigherLayer (
                                ULONG_PTR,
                                PMemoryManager,
                                IProtocolLayer *    higher_layer)
{
    TRACE_OUT(("CLayerQ922::RegisterHigherLayer"));

    Higher_Layer = higher_layer; // CLayerSCF or CLayerX224
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerQ922::RemoveHigherLayer (
 *                                    USHORT);
 *
 *    Public
 *
 *    Functional Description:
 *        This function removes the higher layer from our list
 */
ProtocolLayerError    CLayerQ922::RemoveHigherLayer (
                                ULONG_PTR)
{
    TRACE_OUT(("CLayerQ922::RemoveHigherLayer"));

    Higher_Layer = NULL;
    return (PROTOCOL_LAYER_NO_ERROR);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\q922.h ===
/*    Q922.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the interface file for the Q.922 data link protocol.
 *        This class handles all error correction over the link.  It also insures
 *        that all packets are sequenced properly.  Its lower layer receives
 *        packets in raw Q922 format.  It is responsible for framing and error
 *        detecting the packets.  Q922 passes packets to its higher layer that
 *        have been sequenced properly.
 *
 *        Q.922 is a full duplex protocol .
 *
 *        This class assumes that the layers above and below it have packet input
 *        and output interfaces.
 *
 *        Read the Q.922 specification before diving into the code.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James P. Galvin
 *        James W. Lawwill
 */

#ifndef _Q922_H_
#define _Q922_H_

 /*
 **    Possible error conditions from this layer
 */
typedef enum
{
    DATALINK_NO_ERROR,
    DATALINK_READ_QUEUE_EMPTY,
    DATALINK_WRITE_QUEUE_FULL,
    DATALINK_RECEIVE_SEQUENCE_VIOLATION
}
    DataLinkError, * PDataLinkError;

 /*
 **    The data link layer can be in the following modes
 */
typedef enum
{
    TEI_ASSIGNED,
    AWAITING_ESTABLISHMENT,
    MULTIPLE_FRAME_ESTABLISHED,
    AWAITING_RELEASE,
    TIMER_RECOVERY
}
    DataLinkMode, * PDataLinkMode;

 /*
 **    Q922 Disconnect Types
 */
typedef enum
{
    DATALINK_NORMAL_DISCONNECT,
    DATALINK_ILLEGAL_PACKET_RECEIVED,
    DATALINK_RECEIVE_SEQUENCE_EXCEPTION,
    DATALINK_REMOTE_SITE_TIMED_OUT
}
    DataLinkDisconnectType, * PDataLinkDisconnectType;

 /*
 **    Q922 Status messages
 */
typedef enum
{
    DATALINK_TIMING_ERROR
}
    DataLinkStatusMessage, * PDataLinkStatusMessage;

 /*
 **    Default packet size
 */
#define    DATALINK_OUTPUT_MAXIMUM_PACKET_SIZE    1024

 /*
 **    Transmit and receive packets are managed via the DataQueue structure
 */
typedef struct
{
    LPBYTE    buffer_address;
    USHORT    length;
}
    DataQueue, * PDataQueue;


 /*
 **    In this implementation of Q922, the DLCI is 10 bits.
 **    For this reason, we will make it a USHORT
 */
typedef    USHORT    DLCI;


 /*
 **    Q922 definitions
 */
#define COMMAND_BIT                     0x02
#define POLL_FINAL_BIT                  0x01

#define RESPONSE_FRAME                  COMMAND_BIT
#define COMMAND_FRAME                   0x00

#define PF_RESET                        0x00
#define PF_SET                          POLL_FINAL_BIT

#define UNNUMBERED_PF_RESET             0x00
#define UNNUMBERED_PF_SET               0x10

#define ADDRESS_BYTE_HIGH               0
#define ADDRESS_BYTE_LOW                1
#define CONTROL_BYTE_HIGH               2
#define CONTROL_BYTE_LOW                3

#define ADDRESS_MSB                     0x00
#define ADDRESS_LSB                     0x01
#define CONTROL_MSB                     0x01
#define ADDRESS_HIGH(X)                 ((X >> 2) & 0xfc)
#define ADDRESS_LOW(X)                  ((X & 0x0f) << 4)

#define UNNUMBERED_HEADER_SIZE          3

#define SUPERVISORY_FRAME_BIT           0x01
#define SUPERVISORY_COMMAND_MASK        0x0c

#define RECEIVER_READY                  0x00
#define RECEIVER_NOT_READY              0x04
#define REJECT                          0x08

#define UNNUMBERED_FRAME_BIT            0x02
#define UNNUMBERED_COMMAND_MASK         0xec

#define SABME                           0x6c
#define UNNUMBERED_ACKNOWLEDGE          0x60
#define FRAME_REJECT                    0x84
#define DISCONNECTED_MODE               0x0c
#define DISC                            0x40

#define SEQUENCE_MODULUS                128
#define RECEIVE_SEQUENCE_VIOLATION      1

 /*
 **    DATALINK_MAXIMUM_PACKET_SIZE = User data + overhead
 */
#define DATALINK_MAXIMUM_PACKET_SIZE    1024

 /*
 **    The maximum Q922 packet overhead is 4 bytes
 */
#define DATALINK_PACKET_OVERHEAD        4

 /*
 **    Default timeouts
 */
#define DEFAULT_T203_COMM_TIMEOUT       600
#define DEFAULT_T203_TIMEOUT            30000
#define DEFAULT_MAXIMUM_T200_TIMEOUTS   5


class CLayerQ922 : public IProtocolLayer
{
public:

    CLayerQ922(
        T123                 *owner_object,
        Multiplexer          *lower_layer,
        USHORT                message_base,
        USHORT                identifier,
        BOOL                  link_originator,
        USHORT                data_indication_queue_size,
        USHORT                data_request_queue_size,
        USHORT                k_factor,
        USHORT                max_packet_size,
        USHORT                t200,
        USHORT                max_outstanding_bytes,
        PMemoryManager        memory_manager,
        PLUGXPRT_PSTN_CALL_CONTROL,
        PLUGXPRT_PARAMETERS *,
        BOOL *                initialized);

    virtual ~CLayerQ922(void);

    DataLinkError    ReleaseRequest (void);

     /*
     **    Functions overridden from the ProtocolLayer object
     */
    ProtocolLayerError    DataRequest (
                            ULONG_PTR    identifier,
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataRequest (
                            ULONG_PTR    identifier,
                            PMemory        memory,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataIndication (
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    RegisterHigherLayer (
                            ULONG_PTR         identifier,
                            PMemoryManager    dr_memory_manager,
                            IProtocolLayer *    higher_layer);
    ProtocolLayerError    RemoveHigherLayer (
                            ULONG_PTR    identifier);
    ProtocolLayerError    PollTransmitter (
                            ULONG_PTR    identifier,
                            USHORT    data_to_transmit,
                            USHORT *    pending_data,
                            USHORT *    holding_data);
    ProtocolLayerError    PollReceiver(void);
    ProtocolLayerError    GetParameters (
                            USHORT *    max_packet_size,
                            USHORT *    prepend_size,
                            USHORT *    append_size);

private:

    void            ProcessReadQueue (void);
    void            ProcessWriteQueue (
                        USHORT    data_to_transmit);
    BOOL             TransmitSupervisoryFrame (
                        UChar    frame_type,
                        UChar    poll_final_bit);
    BOOL             TransmitInformationFrame (void);
    BOOL              TransmitUnnumberedFrame (void);

    void            ProcessReceiverReady (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessReceiverNotReady (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessReject (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    BOOL             ProcessInformationFrame (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    DataLinkError    ParsePacketHeader (
                        LPBYTE        packet_address,
                        USHORT        packet_length,
                        BOOL *         command_frame,
                        LPBYTE        receive_sequence_number,
                        BOOL *         poll_final_bit);

    void            ProcessSABME (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessFrameReject (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessUnnumberedAcknowledge (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessDisconnectMode (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessDISC (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    DataLinkError    ParseUnnumberedPacketHeader (
                        LPBYTE        packet_address,
                        BOOL *         command_frame,
                        BOOL *         poll_final_bit);

    void            UpdateAcknowledgeState (
                        UChar    sequence_number);
    void            ResetSendState (
                        void);

    void            StartTimerT200 (void);
    void            StopTimerT200 (void);
    void            T200Timeout (
                        TimerEventHandle);

    void            StartTimerT203 (void);
    void            StopTimerT203 (void);
    void            T203Timeout (
                        TimerEventHandle);

    void              Reset (void);

private:

    T123               *m_pT123; // owner object
    Multiplexer        *m_pMultiplexer; // lower layer
    IProtocolLayer     *Higher_Layer;
    USHORT              m_nMsgBase;
    DLCI                DLCI;
    BOOL                Link_Originator;
    USHORT              Maximum_Information_Size;
    BOOL                SABME_Pending;
    BOOL                Unnumbered_Acknowledge_Pending;
    BOOL                DISC_Pending;
    BOOL                Disconnected_Mode_Pending;
    BOOL                Frame_Reject_Pending;
    USHORT              Unnumbered_PF_State;
    BOOL                Final_Packet;

    USHORT              Data_Indication_Size;
    PDataQueue          Data_Indication;
    LPBYTE              Data_Indication_Buffer;
    USHORT              Data_Indication_Head;
    USHORT              Data_Indication_Tail;
    USHORT              Data_Indication_Count;

    USHORT              Data_Request_Size;
    USHORT              Data_Request_Total_Size;
    PMemory            *Data_Request;
    USHORT              Data_Request_Head;
    USHORT              Data_Request_Tail;
    USHORT              Data_Request_Count;
    USHORT              Data_Request_Acknowledge_Tail;
    PMemoryManager      Data_Request_Memory_Manager;
    USHORT              Lower_Layer_Prepend;
    USHORT              Lower_Layer_Append;

    PMemory             Supervisory_Write_Struct;
    LPBYTE              Supervisory_Write_Buffer;

    UChar               Send_State_Variable;
    UChar               Receive_State_Variable;
    UChar               Acknowledge_State_Variable;

    BOOL                Own_Receiver_Busy;
    BOOL                Peer_Receiver_Busy;

    BOOL                Command_Pending;
    BOOL                Poll_Pending;
    BOOL                Final_Pending;
    BOOL                Acknowledge_Pending;
    BOOL                Reject_Pending;
    BOOL                Reject_Outstanding;

    ULONG               T200_Timeout;
    TimerEventHandle    T200_Handle;
    BOOL                T200_Active;
    ULONG               N200_Count;
    ULONG               Maximum_T200_Timeouts;
    ULONG               Startup_Maximum_T200_Timeouts;
    ULONG               Link_Maximum_T200_Timeouts;

    ULONG               T203_Timeout;
    TimerEventHandle    T203_Handle;
    BOOL                T203_Active;

    DataLinkMode        Data_Link_Mode;
    BOOL                Link_Stable;

    USHORT              Receive_Sequence_Exception;
    USHORT              Receive_Sequence_Recovery;

    USHORT              Maximum_Outstanding_Packets;
    USHORT              Outstanding_Packets;
    USHORT              Maximum_Outstanding_Bytes;
    USHORT              Outstanding_Bytes;
    ULONG               Total_Retransmitted;
};

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    CLayerQ922::CLayerQ922 (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                USHORT                identifier,
 *                BOOL                 link_originator,
 *                USHORT                data_indication_queue_siz,
 *                USHORT                data_request_queue_size,
 *                USHORT                k_factor,
 *                USHORT                max_information_size,
 *                USHORT                t200,
 *                USHORT                max_outstanding_bytes,
 *                PMemoryManager        memory_manager,
 *                BOOL *                 initialized)
 *
 *    Functional Description
 *        This is the constructor for the Q.922 data link layer.  It prepares
 *        for communications by allocating buffers and setting its internal
 *        buffers properly.  It also registers itself with its lower layer.
 *
 *    Formal Parameters
 *        transport_resources    (i)    -    Pointer to TransportResources structure.
 *        owner_object    (i)    -    Address of the object that owns us.  This
 *                                address is used for owner callbacks.
 *        lower_layer        (i)    -    Address of the layer below us.  We pass packets
 *                                to this layer and receive packets from it.
 *        message_base    (i)    -    Message base used in owner callbacks.
 *        identifier        (i)    -    Identifier of this object.  It is passed to the
 *                                lower layer along with our address, to identify
 *                                us.
 *        link_originator    (i)    -    TRUE if this object should initiate a link.
 *        data_indication_queue_size    (i)    -    Number of queues available for
 *                                reception of data from the lower layer
 *        data_request_queue_size (i)    -    Number of queues available for
 *                                transmission of data to the lower layer.
 *        k_factor        (i) -    Number of outstanding packets allowed.
 *        max_information_size (i)    -    Max. number of bytes in the information
 *                                part of a packet
 *        t200            (i)    -    T200 timeout
 *        max_outstanding_bytes    (i)    -    Maximum number of outstanding bytes at
 *                                any one time
 *        initialized        (o)    -    BOOL      returned to user telling him if the
 *                                object initialized o.k.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    CLayerQ922::~CLayerQ922 (void);
 *
 *    Functional Description
 *        This is the destructor for the Q.922 data link layer.  It destroys
 *        the read and write buffers.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    DataLinkError    CLayerQ922::ReleaseRequest (void);
 *
 *    Functional Description
 *        This function is called to terminate a connection.  When this function
 *        is called we queue up a DISC packet to be sent to the remote site.
 *        When we receive an Unnumbered Ack packet, we notify the owner object
 *        that the link is terminated
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    CLayerQ922::DataRequest (
 *                                    ULONG        identifier,
 *                                    PMemory        memory,
 *                                    PULong        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.  The packet is held in a memory object.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        memory            (i)    -    Memory object containing packet.
 *        bytes_accepted    (o)    -    Number of bytes accepted by the CLayerQ922.
 *                                This value will either be 0 or the packet
 *                                length since this layer has a packet interface.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerQ922::DataRequest (
 *                                    ULONG    identifier,
 *                                    LPBYTE    buffer_address,
 *                                    USHORT    length,
 *                                    USHORT *    bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Length of packet to transmit
 *        bytes_accepted    (o)    -    Number of bytes accepted by the CLayerQ922.
 *                                This value will either be 0 or the packet
 *                                length since this layer has a packet interface.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    CLayerQ922::DataIndication (
 *                                    LPBYTE    buffer_address,
 *                                    USHORT    length,
 *                                    USHORT *    bytes_accepted);
 *
 *    Functional Description
 *        This function is called by the lower layer when it has data to pass up
 *        to us.  This layer assumes that the data coming to us is in packet
 *        format.
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes available
 *        bytes_accepted    (o)    -    Number of bytes accepted
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerQ922::RegisterHigherLayer (
 *                                    ULONG            identifier,
 *                                    PMemoryManager    memory_manager,
 *                                    IProtocolLayer *    higher_layer);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  When this object needs to send a packet up, it calls
 *        the higher_layer with a Data Indication
 *
 *    Formal Parameters
 *        identifier        (i)    -    Unique identifier of the higher layer.  If we
 *                                were doing multiplexing at this layer, this
 *                                would have greater significance.
 *        memory_manager    (i)    -    Pointer to outbound memory manager
 *        higher_layer    (i)    -    Address of higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Error occured on registration
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerQ922::RemoveHigherLayer (
 *                                    ULONG);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove its identifier
 *        and its address.  If the higher layer removes itself from us, we have
 *        no place to send incoming data
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    CLayerQ922::PollTransmitter (
 *                                    ULONG,
 *                                    USHORT    data_to_transmit,
 *                                    USHORT *    pending_data,
 *                                    USHORT *    holding_data);
 *
 *    Functional Description
 *        This function is called to give the CLayerQ922 a chance to transmit data
 *        in its Data_Request buffer.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        data_to_transmit    (i)    -    This is a mask that tells us to send Control
 *                                    data, User data, or both.
 *        pending_data        (o)    -    Return value to indicate which data is left
 *                                    to be transmitted.
 *        holding_data        (o)    -    Returns the number of packets currently
 *                                    outstanding.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    CLayerQ922::PollReceiver (
 *                                    ULONG    identifier);
 *
 *    Functional Description
 *        This function is called to give the CLayerQ922 a chance pass packets
 *        to higher layers
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    CLayerQ922::GetParameters (
 *                                    ULONG    identifier,
 *                                    USHORT *    max_packet_size,
 *                                    USHORT *    prepend_size,
 *                                    USHORT *    append_size);
 *
 *    Functional Description:
 *        This function returns the maximum packet size that it can handle via
 *        its DataRequest() function.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Not used
 *        max_packet_size    (o)    -    Address to return max. packet size in.
 *        prepend_size    (o)    -    Return number of bytes prepended to each packet
 *        append_size        (o)    -    Return number of bytes appended to each packet
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\scf.h ===
/*    SCF.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class represents the Network layer in the T.123 Transport stack.
 *        This layer communicates over the DataLink layer (DLCI 0).  It sends the
 *        necessary packets to start a connection.  It is also responsible for
 *        disconnecting the connection.
 *
 *        During arbitration of a connection, SCF arbitrates priority and DataLink
 *        parameters.  SCF instantiates a SCFCall object for each active logical
 *        connection.  Remotely initiated calls are placed in the
 *        Remote_Call_Reference array while locally initiated calls are kept in
 *        the Call_Reference array.
 *
 *        This class inherits from ProtocolLayer although it assumes that it does
 *        not have a higher layer to pass packets to.  The T.123 document is clear
 *        about that during the user data transmission, this layer has no purpose.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */

#ifndef _SCF_H_
#define _SCF_H_

#include "q922.h"
#include "scfcall.h"

 /*
 **    SCF Errors
 */
typedef enum
{
    SCF_NO_ERROR,
    SCF_NO_SUCH_DLCI,
    SCF_CONNECTION_FULL,
    SCF_MEMORY_ALLOCATION_ERROR
}
    SCFError;


#define TRANSPORT_HASHING_BUCKETS   3

 /*
 **    Offsets into packet
 */
#define PROTOCOL_DISCRIMINATOR      0
#define LENGTH_CALL_REFERENCE       1
#define CALL_REFERENCE_VALUE        2

 /*
 **    Supported commands
 */
#define NO_PACKET               0x00
#define CONNECT                 0x07
#define CONNECT_ACKNOWLEDGE     0x0f
#define SETUP                   0x05
#define RELEASE_COMPLETE        0x5a

 /*
 **    Unsupported commands as stated by T.123
 */
#define RELEASE             0x4d
#define ALERTING            0x01
#define CALL_PROCEEDING     0x02
#define PROGRESS            0x03
#define DISCONNECT          0x45
#define SEGMENT             0x40
#define STATUS              0x5d
#define STATUS_ENQUIRY      0x55

 /*
 **    Packet Elements, not all of these are supported.
 */
#define BEARER_CAPABILITY               0x04
#define DLCI_ELEMENT                    0x19
#define END_TO_END_DELAY                0x42
#define LINK_LAYER_CORE_PARAMETERS      0x48
#define LINK_LAYER_PROTOCOL_PARAMETERS  0x49
#define X213_PRIORITY                   0x50
#define CALLING_PARTY_SUBADDRESS        0x6d
#define CALLED_PARTY_SUBADDRESS         0x71
#define CAUSE                           0x08

#define EXTENSION                       0x80

 /*
 **    Remote Call Reference
 */
#define REMOTE_CALL_REFERENCE           0x80

 /*
 **    Bearer Capability definitions
 */
#define CODING_STANDARD                     0
#define INFORMATION_TRANSFER_CAPABILITY     0x08
#define TRANSFER_MODE                       0x20
#define LAYER_2_IDENT                       0x40
#define USER_INFORMATION_LAYER_2            0x0e

 /*
 **    DLCI element
 */
#define PREFERRED_EXCLUSIVE         0x40

 /*
 **    Link Layer Core Parameters
 */
#define FMIF_SIZE                   0x09
#define THROUGHPUT                  0x0a
#define MINIMUM_THROUGHPUT          0x0b
#define COMMITTED_BURST_SIZE        0x0d
#define EXCESS_BURST_SIZE           0x0e

 /*
 **    Link Layer Protocol Parameters
 */
#define TRANSMIT_WINDOW_SIZE_IDENTIFIER     0x07
#define RETRANSMISSION_TIMER_IDENTIFIER     0x09

 /*
 **    Q.850 Error messages, these are the only 2 errors we currently support
 */
#define    REQUESTED_CHANNEL_UNAVAILABLE    0x2c
#define NORMAL_USER_DISCONNECT              0x1f

 /*
 **    Single Octet information elements
 */
#define    SINGLE_OCTET_ELEMENT_MASK        0x80
#define    Q931_PROTOCOL_DISCRIMINATOR      0x08
#define    CALL_REFERENCE_ORIGINATOR        0x80
#define    CALL_ORIGINATOR_MASK             0x7f

 /*
 **    T303 is the timeout allowed from the time we send the SETUP until we receive
 **    a response
 */
#define DEFAULT_T303_TIMEOUT            30000
 /*
 **    T313 is the timeout allowed from the time we send the CONNECT until we
 **    receive a response
 */
#define DEFAULT_T313_TIMEOUT            30000



class CLayerSCF : public IProtocolLayer
{
public:

    CLayerSCF(
        T123               *owner_object,
        CLayerQ922         *lower_layer,
        USHORT              message_base,
        USHORT              identifier,
        BOOL                link_originator,
        PDataLinkParameters datalink,
        PMemoryManager      memory_manager,
        BOOL *              initialized);

    virtual ~CLayerSCF(void);

    SCFError        ConnectRequest (
                        DLCI                dlci,
                        TransportPriority    priority);
    SCFError        DisconnectRequest (
                        DLCI    dlci);
    SCFError        ConnectResponse (
                        CallReference    call_reference,
                        DLCI            dlci,
                        BOOL        valid_dlci);

     /*
     **    Functions overridden from the ProtocolLayer object
     */
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     identifier,
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     identifier,
                            PMemory        memory,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataIndication (
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    RegisterHigherLayer (
                            ULONG_PTR         identifier,
                            PMemoryManager    dr_memory_manager,
                            IProtocolLayer *    higher_layer);
    ProtocolLayerError    RemoveHigherLayer (
                            ULONG_PTR    identifier);
    ProtocolLayerError    PollTransmitter (
                            ULONG_PTR     identifier,
                            USHORT        data_to_transmit,
                            USHORT *        pending_data,
                            USHORT *        holding_data);
    ProtocolLayerError    PollReceiver(void);
    ProtocolLayerError    GetParameters (
                            USHORT *        max_packet_size,
                            USHORT *        prepend,
                            USHORT *        append);

    ULONG OwnerCallback(ULONG, void *p1 = NULL, void *p2 = NULL, void *p3 = NULL);

private:

    CallReference        GetNextCallReference (void);

    void                ProcessMessages (void);

private:

    DictionaryClass       Remote_Call_Reference;
    DictionaryClass       Call_Reference;
    DictionaryClass       DLCI_List;
    SListClass            Message_List;

    T123                 *m_pT123; // owner object
    CLayerQ922           *m_pQ922; // lower layer
    USHORT                m_nMsgBase;
    USHORT                Identifier;
    USHORT                Link_Originator;
    USHORT                Maximum_Packet_Size;
    DataLinkParameters    DataLink_Struct;
    PMemoryManager        Data_Request_Memory_Manager;
    USHORT                Lower_Layer_Prepend;
    USHORT                Lower_Layer_Append;
    USHORT                Call_Reference_Base;
};
typedef    CLayerSCF *        PSCF;

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    CLayerSCF::CLayerSCF (
 *            PTransportResources    transport_resources,
 *            IObject *                owner_object,
 *            IProtocolLayer *        lower_layer,
 *            USHORT                message_base,
 *            USHORT                identifier,
 *            BOOL            link_originator,
 *            PChar                config_file,
 *            PDataLinkParameters    datalink,
 *            PMemoryManager        memory_manager,
 *            BOOL *            initialized);
 *
 *    Functional Description
 *        This is the constructor for the SCF Network layer.  It registers itself
 *        with the lower so that incoming data will be received properly.
 *
 *    Formal Parameters
 *        transport_resources    (i) -    Pointer to TransportResources structure.
 *        owner_object    (i) -    Address of the object that owns this object
 *        lower_layer        (i) -    Address of the layer below us.
 *        message_base    (i) -    Message base used in owner callbacks.
 *        identifier        (i) -    This objects identification number.  Passed to
 *                                lower layer to identify us (DLCI 0).
 *        link_originator    (i) -    BOOL, TRUE if we started the link
 *        config_file        (i) -    Address of the configuration path string
 *        datalink        (i) -    Address structure holding the DataLink
 *                                arbitratable parameters.
 *        memory_manager    (i) -    Address of the memory manager
 *        initialized        (o) -    Address of BOOL, we set it to TRUE if it
 *                                worked
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    CLayerSCF::~CLayerSCF (void);
 *
 *    Functional Description
 *        This is the destructor for the SCF Network layer.  We do our
 *        cleanup in here
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    SCFError    CLayerSCF::ConnectRequest (
 *                        DLCI    dlci,
 *                        USHORT    priority)
 *
 *    Functional Description
 *        This function initiates a connection with the remote site.  As a result,
 *        we will create a SCFCall and tell it to initiate a connection.
 *
 *    Formal Parameters
 *        dlci        (i) -    Proposed DLCI for the connection
 *        priority    (i) -    Proposed priority for the connection
 *
 *    Return Value
 *        SCF_NO_ERROR    -    No erroro occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    SCFError    CLayerSCF::DisconnectRequest (
 *                        DLCI    dlci);
 *
 *    Functional Description
 *        This function starts the disconnect process.
 *
 *    Formal Parameters
 *        dlci        (i) -    DLCI to disconnect.
 *
 *    Return Value
 *        SCF_NO_ERROR        -    No error occured
 *        SCF_NO_SUCH_DLCI    -    Invalid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    SCFError    CLayerSCF::ConnectResponse (
 *                        CallReference    call_reference,
 *                        DLCI            dlci,
 *                        BOOL        valid_dlci);
 *
 *    Functional Description
 *        This function is called by a higher layer to confirm a connection.  If
 *        the remote site initiates a connection with us, we issue a
 *        NETWORK_CONNECT_INDICATION to the owner object. It responds with this
 *        call to confirm or deny the suggested dlci.
 *
 *    Formal Parameters
 *        call_reference    (i) -    Call reference ID, passed to owner in
 *                                NETWORK_CONNECT_INDICATION
 *        dlci            (i) -    Referenced DLCI
 *        valid_dlci        (i) -    TRUE if the requested DLCI is valid
 *
 *    Return Value
 *        SCF_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::DataRequest (
 *                                ULONG        identifier,
 *                                LPBYTE        buffer_address,
 *                                USHORT        length,
 *                                USHORT *    bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.  For the SCF, this functio is not used
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Length of packet to transmit
 *        bytes_accepted    (o)    -    Number of bytes accepted by the Multiplexer.
 *                                This value will either be 0 or the packet
 *                                length since this layer is a packet to byte
 *                                converter.
 *
 *    Return Value
 *        PROTOCOL_LAYER_ERROR
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::DataRequest (
 *                                ULONG,
 *                                PMemory,
 *                                USHORT *)
 *
 *    Functional Description
 *        This function is not used.
 *
 *    Formal Parameters
 *        No parameters used
 *
 *    Return Value
 *        PROTOCOL_LAYER_ERROR
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::DataIndication (
 *                                        LPBYTE        buffer_address,
 *                                        USHORT        length,
 *                                        USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by the lower layer when it has data to pass up
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes available
 *        bytes_accepted    (o)    -    Number of bytes accepted
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::RegisterHigherLayer (
 *                                        ULONG            identifier,
 *                                        IProtocolLayer *    higher_layer);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  In some cases, the identifier is the DLCI number in
 *        the packet.  If this multiplexer is being used as a stream to packet
 *        converter only, the identifer is not used and all data is passed to the
 *        higher layer.  This is a NULL function by SCF
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *        higher_layer    (i)    -    Address of higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No higher layer allowed
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::RemoveHigherLayer (
 *                                ULONG    identifier);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove the higher layer.
 *        If any more data is received with its identifier on it, it will be
 *        trashed.  This is a NULL function for SCF
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    No higher layer allowed
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::PollTransmitter (
 *                                ULONG        identifier,
 *                                USHORT        data_to_transmit,
 *                                USHORT *        pending_data,
 *                                USHORT *        holding_data);
 *
 *    Functional Description
 *        This function is called to give SCF a chance transmit data
 *        in its Data_Request buffer.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        data_to_transmit    (i)    -    This is a mask that tells us to send Control
 *                                    data, User data, or both.  Since the
 *                                     SCF does not differentiate between
 *                                    data types it transmits any data it has
 *        pending_data        (o)    -    Return value to indicat which data is left
 *                                    to be transmitted.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::PollReceiver (
 *                                ULONG    identifier);
 *
 *    Functional Description
 *        This function is called to give SCF a chance pass packets
 *        to higher layers.  It is not used in SCF.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::GetParameters (
 *                                ULONG        identifier,
 *                                USHORT *        max_packet_size,
 *                                USHORT *        prepend,
 *                                USHORT *        append);
 *
 *    Functional Description
 *        This function is called to get the maximum packet size.  This function
 *        is not used in SCF.  It is here because we inherit from ProtocolLayer
 *        and this is a pure virtual function in that class.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        max_packet_size        (o)    -    Returns the maximum packet size
 *        prepend                (o)    -    Number of bytes prepended to a packet
 *        append                (o)    -    Number of bytes appended to a packet
 *
 *    Return Value
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Function can not be called
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\scfcall.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);
/*    SCFCall.cpp
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class is instantiated by the SCF class.  For each call that the
 *        local site or remote site initiates, a SCFCall object is instantiated.
 *        SCF can can manage 254 different calls simultaneously.  For each call
 *        there is a specific Q.933 based protocol that must occur to make the
 *        connection valid.  This object sends and receives the Q.933 packets.
 *
 *    Private Instance Variables:
 *        m_pSCF            -    Address of the owner of this object
 *        Lower_Layer                -    Address of the layer below this layer
 *        m_nMsgBase            -    The owner of this object gives it a base
 *                                    number to use for OwnerCallbacks ()
 *        Maximum_Packet_Size        -    Maximum transmittable packet size
 *        Packet_Pending            -    Tells which packet is to be transmitted 
 *                                    next.
 *        Link_Originator            -    TRUE is this site initiated the call
 *
 *        Write_Buffer            -    Address of write buffer
 *        Send_Priority            -    TRUE if we are suppose to respond to the
 *                                    priority requested by the remote site
 *
 *        Call_Reference            -    Call reference number of this call.
 *        DLCI                    -    Holds the suggested and confirmed DLCI for
 *                                    this call.
 *        Priority                -    Holds the suggested and confirmed priority
 *                                    for this call.
 *
 *        State                    -    Holds the current state of the call.
 *        Release_Cause            -    Reason the the breakup of the link.
 *        Default_Priority        -    Default priority of a non-specified call.
 *
 *        T303_Timeout            -    T303 timeout value.
 *        T303_Handle                -    System timer handle to T303 timer
 *        T303_Active                -    TRUE if the timer is currently active
 *        T303_Count                -    Number of T303 Timeouts
 *
 *        T313_Timeout            -    T313 timeout value
 *        T313_Handle                -    System timer handle to T313 timer
 *        T313_Active                -    TRUE if the timer is currently active.
 * 
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */
#include "scf.h"
#include "scfcall.h"


/*
 *    SCFCall::SCFCall (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                PDataLinkParameters    datalink_struct,
 *                PMemoryManager        data_request_memory_manager,
 *                BOOL *            initialized)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the SCFCall constructor.  This routine initializes all
 *        variables and allocates write buffer space.
 */
SCFCall::SCFCall (
            CLayerSCF            *owner_object,
            IProtocolLayer *        lower_layer,
            USHORT                message_base,
            PDataLinkParameters    datalink_struct,
            PMemoryManager        data_request_memory_manager,
            BOOL *            initialized)
{
    TRACE_OUT(("SCFCall::SCFCall"));

    m_pSCF = owner_object;
    Lower_Layer = lower_layer;
    m_nMsgBase = message_base;
    Data_Request_Memory_Manager = data_request_memory_manager;
    *initialized = TRUE;

    DataLink_Struct.k_factor = datalink_struct->k_factor;
    DataLink_Struct.default_k_factor = datalink_struct->default_k_factor;
    DataLink_Struct.n201 = datalink_struct->n201;
    DataLink_Struct.default_n201 = datalink_struct->default_n201;

     /*
     **    T200 is represented in milliseconds, we need to convert it to 
     **    tenths of seconds.
     */
    DataLink_Struct.t200 = datalink_struct->t200 / 100;
    DataLink_Struct.default_t200 = datalink_struct->default_t200 / 100;

    Lower_Layer -> GetParameters (
                    &Maximum_Packet_Size,
                    &Lower_Layer_Prepend,
                    &Lower_Layer_Append);

    Packet_Pending = NO_PACKET;
    Link_Originator = FALSE;
    State = NOT_CONNECTED;
    Received_Priority = FALSE;
    Received_K_Factor = FALSE;
    Received_N201 = FALSE;
    Received_T200 = FALSE;
    DLC_Identifier = 0;

    T303_Active = FALSE;
    T313_Active = FALSE;
    
     /*
     **    Get configuration data
     */
    T303_Timeout = DEFAULT_T303_TIMEOUT;
    T313_Timeout = DEFAULT_T313_TIMEOUT;
    Default_Priority = DEFAULT_PRIORITY;
}


/*
 *    SCFCall::~SCFCall (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the SCFCall destructor.  This routine cleans up the mess
 */
SCFCall::~SCFCall (void)
{
    if (T303_Active)
    {
        StopTimerT303 ();
    }

    if (T313_Active)
    {
        StopTimerT313 ();
    }
}


/*
 *    SCFCall::ConnectRequest (
 *                CallReference    call_reference,
 *                DLCI            dlci,
 *                USHORT            priority)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called when SCF wants to initiate a call.
 *        As a result, we queue a SETUP command to be sent out.
 */
SCFCallError    SCFCall::ConnectRequest(
                            CallReference        call_reference,
                            DLCI                dlci,
                            TransportPriority    priority)
{
    TRACE_OUT(("SCFCall::ConnectRequest"));
    Call_Reference = call_reference;
    DLC_Identifier = dlci;
    Priority = priority;
    Link_Originator = TRUE;

    if (State == NOT_CONNECTED)
        Packet_Pending = SETUP;

    return (SCFCALL_NO_ERROR);
}



/*
 *    SCFCallError    SCFCall::ConnectResponse (
 *                                BOOL        valid_dlci)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called in response to a NETWORK_CONNECT_INDICATION
 *        callback to the owner of this object.  Previously, the remote site
 *        sent us a SETUP packet with a suggested DLCI.  This DLCI is sent to 
 *        the owner in the NETWORK_CONNECT_INDICATION call.  The owner calls
 *        this function with a BOOL    , telling us if the DLCI was valid.
 */
SCFCallError    SCFCall::ConnectResponse (
                            BOOL        valid_dlci)
{
    TRACE_OUT(("SCFCall::ConnectResponse"));
    if (valid_dlci)
    {
         /*
         **    This DLCI can be used in a link.  If the remote site did not
         **    request a priority, we set it to Default_Priority
         */
        if (Priority == 0xffff)
            Priority = Default_Priority;

        Packet_Pending = CONNECT;

    }
    else
    {
         /*
         **    Queue up a RELEASE COMPLETE packet
         */
        Packet_Pending = RELEASE_COMPLETE;
        Release_Cause = REQUESTED_CHANNEL_UNAVAILABLE;
    }

    return (SCFCALL_NO_ERROR);
}



/*
 *    SCFCallError    SCFCall::DisconnectRequest ()
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called when the SCF wants to terminate the call
 */
SCFCallError SCFCall::DisconnectRequest ()
{
    TRACE_OUT(("SCFCall::DisconnectRequest"));
     /*
     **    Queue up the Release Complete
     */
    if (State != NOT_CONNECTED)
    {
        Packet_Pending = RELEASE_COMPLETE;
        Release_Cause = NORMAL_USER_DISCONNECT;
    }

    return (SCFCALL_NO_ERROR);
}



/*
 *    BOOL        SCFCall::ProcessSetup (
 *                             CallReference    call_reference,
 *                             LPBYTE            packet_address,
 *                             USHORT            packet_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes an incoming SETUP packet
 */
BOOL     SCFCall::ProcessSetup (
                    CallReference    call_reference,
                    LPBYTE            packet_address,
                    USHORT            packet_length)
{
    USHORT                    length;
    BOOL                    packet_successful;
    USHORT                    remainder_length;
    USHORT                    n201;
    USHORT                    k_factor;
    USHORT                    t200;
    NetworkConnectStruct    connect_struct;

    TRACE_OUT(("SCFCall::ProcessSetup"));

    if (State != NOT_CONNECTED)
        return (FALSE);

    Call_Reference = call_reference;
    packet_successful = TRUE;
    remainder_length = packet_length;

     /*
     **    Bearer capability element
     */
    if (*(packet_address++) != BEARER_CAPABILITY)
        return (FALSE);
    remainder_length--;

    length = *(packet_address++);
    remainder_length--;
    if (length != 3)
        return (FALSE);

     /*
     **    Verify that the Bearer Capability is correct
     */    
    if (*(packet_address) != 
        (EXTENSION | CODING_STANDARD | INFORMATION_TRANSFER_CAPABILITY))
    {
        return (FALSE);
    }
    if (*(packet_address + 1) != (EXTENSION | TRANSFER_MODE))
    {
        return (FALSE);
    }
    if (*(packet_address + 2) != 
        (EXTENSION | LAYER_2_IDENT | USER_INFORMATION_LAYER_2))
    {
        return (FALSE);
    }
    packet_address += length;
    remainder_length -= length;

     /*
     **    DLCI element
     */
    if (*(packet_address++) != DLCI_ELEMENT)
        return (FALSE);
    remainder_length--;

    length = *(packet_address++);
    if (length != 2)
        return (FALSE);
    remainder_length--;
    
     /*
     **    If the Preferred/Exclusive bit is set, its illegal
     */
    if (((*(packet_address) & PREFERRED_EXCLUSIVE) == PREFERRED_EXCLUSIVE) ||
        ((*(packet_address + 1) & EXTENSION) == 0))
    {
        return (FALSE);
    }
    
    DLC_Identifier = (*(packet_address) & 0x3f) << 4;
    DLC_Identifier |= ((*(packet_address + 1) & 0x78) >> 3);

    packet_address += length;
    remainder_length -= length;

    Priority = 0xffff;

     /*
     **    Go thru each of the elements and decode them
     */
    while (remainder_length)
    {
        switch (*(packet_address++))
        {
            case X213_PRIORITY:
                length = *(packet_address++);
                remainder_length--;
                if (((*(packet_address) & EXTENSION) == 1) ||
                    ((*(packet_address + 1) & EXTENSION) == 0))
                {
                    ERROR_OUT(("SCFCall: ProcessSetup: SETUP packet: Illegal X.213 priority"));
                    return (FALSE);
                }
                Priority = (*packet_address & 0x0f);
                packet_address += length;
                remainder_length -= length;
                Received_Priority = TRUE;
                break;

            case LINK_LAYER_CORE_PARAMETERS:
                length = *(packet_address++);
                remainder_length -= (length + 1);
                while (length)
                {
                    switch (*(packet_address++))
                    {
                        case FMIF_SIZE:
                             /*
                             **    N201 is a Q922 parameter.  It is the number of 
                             **    maximum information bytes in a packet
                             */
                            n201 = 
                                ((*packet_address << 7) | 
                                (*(packet_address + 1) & 0x7f));
                            if ((*(packet_address+1) & EXTENSION) == EXTENSION)
                            {
                                length -= 2;
                                packet_address += 2;
                            }
                            else
                            {
                                packet_address += 4;
                                length -= 4;
                            }

                             /*
                             **    If the requested n201 value is less than our
                             **    value, it will be our new N201, otherwise send
                             **    our N201 back as the arbitrated value.
                             */
                            if (n201 < DataLink_Struct.n201)
                                DataLink_Struct.n201 = n201;
                            Received_N201 = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessSetup: n201 = %d", DataLink_Struct.n201));
                            break;

                        default:
                            while ((*(packet_address++) & EXTENSION) == 0)
                                length--;
                            length--;
                            break;
                    }
                    length--;
                }
                break;

            case LINK_LAYER_PROTOCOL_PARAMETERS:
                length = *(packet_address++);
                remainder_length -= (length + 1);
                while (length)
                {
                    switch (*(packet_address++))
                    {
                        case TRANSMIT_WINDOW_SIZE_IDENTIFIER:
                             /*
                             **    The Window size is the maximum number of 
                             **    outstanding packets at any one time
                             */
                            k_factor = *packet_address & 0x7f;
                            packet_address++;
                            length--;

                             /*
                             **    If the requested k_factor value is less than our
                             **    value, it will be our new k_factor, otherwise 
                             **    send our k_factor back as the arbitrated value.
                             */
                            if (k_factor < DataLink_Struct.k_factor)
                                DataLink_Struct.k_factor = k_factor;
                            Received_K_Factor = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessSetup: k_factor = %d", DataLink_Struct.k_factor));
                            break;

                        case RETRANSMISSION_TIMER_IDENTIFIER:
                             /*
                             **    t200 is the timeout value before retransmission
                             */
                            t200 = ((*packet_address << 7) | 
                                    (*(packet_address + 1) & 0x7f));
                            packet_address += 2;
                            length -= 2;

                             /*
                             **    If the requested t200 value is too small, 
                             **    value, it will be our new T200, otherwise 
                             **    send our T200 back as the arbitrated value.
                             */
                            if (t200 > DataLink_Struct.t200)
                                DataLink_Struct.t200 = t200;
                            Received_T200 = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessSetup: t200 = %d", DataLink_Struct.t200));
                            break;

                        default:
                            while ((*(packet_address++) & EXTENSION) == 0)
                                length--;
                            length--;
                            break;
                    }
                    length--;
                }
                break;

            case END_TO_END_DELAY:
            case CALLING_PARTY_SUBADDRESS:
            case CALLED_PARTY_SUBADDRESS:
            default:
                TRACE_OUT(("SCFCall: ProcessSetup: SETUP packet: Option 0x%x"
                    "requested, but not supported", *(packet_address-1)));
                length = *(packet_address);

                packet_address += (length + 1);
                remainder_length -= (length + 1);
                break;
        }
        remainder_length--;
    }
    if (Received_N201 == FALSE)
        DataLink_Struct.n201 = DataLink_Struct.default_n201;
    if (Received_K_Factor == FALSE)
        DataLink_Struct.k_factor = DataLink_Struct.default_k_factor;
    if (Received_T200 == FALSE)
        DataLink_Struct.t200 = DataLink_Struct.default_t200;

    if (packet_successful)
    {
         /*
         **    If the packet was successfully decoded, tell the owner the requested
         **    DLCI and priority.
         */
        connect_struct.dlci = DLC_Identifier;
        connect_struct.priority = Priority;
        connect_struct.datalink_struct = &DataLink_Struct;

         /*
         **    Convert t200 into milliseconds
         */
        DataLink_Struct.t200 *= 100;
        m_pSCF->OwnerCallback(m_nMsgBase + NETWORK_CONNECT_INDICATION, 0, 0, &connect_struct);
        DataLink_Struct.t200 /= 100;
    }
                                
    return (packet_successful);
}


/*
 *    BOOL        SCFCall::ProcessConnect (
 *                             LPBYTE        packet_address,
 *                             USHORT        packet_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes an incoming CONNECT packet
 */
BOOL     SCFCall::ProcessConnect (
                    LPBYTE        packet_address,
                    USHORT        packet_length)
{
    TRACE_OUT(("SCFCall::ProcessConnect"));

    BOOL        packet_successful;
    USHORT        length;
    DLCI        exclusive_dlci;
    USHORT        remainder_length;
    USHORT        k_factor;
    USHORT        t200;
    
    if (State != SETUP_SENT)
    {
        ERROR_OUT(("SCFCall: ProcessConnect: Call in wrong state"));
        return (FALSE);
    }

    remainder_length = packet_length;
    packet_successful = TRUE;

     /*
     **    DLCI element
     */
    if (*(packet_address++) != DLCI_ELEMENT)
    {
        ERROR_OUT(("SCFCall: ProcessConnect: DLCI_ELEMENT not in packet"));
        return (FALSE);
    }
    remainder_length--;

    length = *(packet_address++);
    if (length != 2)
    {
        ERROR_OUT(("SCFCall: ProcessConnect: DLCI length must be 2"));
        return (FALSE);
    }
    remainder_length--;
    
     /*
     **    If the Preferred/Exclusive bit is not set, its illegal
     */
    if (((*(packet_address) & PREFERRED_EXCLUSIVE) == 0) ||
        ((*(packet_address + 1) & EXTENSION) == 0))
    {
        ERROR_OUT(("SCFCall:  CONNECT: Illegal DLCI"));
        return (FALSE);
    }
    
     /*
     **    Get the DLCI
     */
    exclusive_dlci = (*(packet_address) & 0x3f) << 4;
    exclusive_dlci |= ((*(packet_address + 1) & 0x78) >> 3);

    packet_address += length;
    remainder_length -= length;

     /*
     **    Go thru each of the elements and decode them
     */
    while (remainder_length != 0)
    {
        switch (*(packet_address++))
        {
            case X213_PRIORITY:
                length = *(packet_address++);
                remainder_length--;
                if ((*(packet_address) & EXTENSION) == 0)
                {
                    ERROR_OUT(("SCFCall: DataIndication: CONNECT packet: Illegal X.213 priority"));
                    return (FALSE);
                }
                Priority = (*packet_address & 0x0f);
                packet_address += length;
                remainder_length -= length;
                break;

            case LINK_LAYER_CORE_PARAMETERS:
                length = *(packet_address++);
                remainder_length -= (length + 1);
                while (length)
                {
                    switch (*(packet_address++))
                    {
                        case FMIF_SIZE:
                             /*
                             **    FMIF_Size is the max. number of bytes allowed in
                             **    a information packet
                             */
                            DataLink_Struct.n201 = 
                                ((*packet_address << 7) | 
                                (*(packet_address + 1) & 0x7f));
                            if ((*(packet_address+1) & EXTENSION) == EXTENSION)
                            {
                                length -= 2;
                                packet_address += 2;
                            }
                            else
                            {
                                packet_address += 4;
                                length -= 4;
                            }

                            Received_N201 = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessConnect: n201 = %d", DataLink_Struct.n201));
                            break;

                        default:
                            while ((*(packet_address++) & EXTENSION) == 0)
                                length--;
                            length--;
                            break;
                    }
                    length--;
                }
                break;

            case LINK_LAYER_PROTOCOL_PARAMETERS:
                length = *(packet_address++);
                remainder_length -= (length + 1);
                while (length)
                {
                    switch (*(packet_address++))
                    {
                        case TRANSMIT_WINDOW_SIZE_IDENTIFIER:
                             /*
                             **    The Window size is the maximum number of 
                             **    outstanding packets at any one time
                             */
                            k_factor = *packet_address & 0x7f;
                            packet_address++;
                            length--;

                            DataLink_Struct.k_factor = k_factor;
                            Received_K_Factor = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessConnect: k_factor = %d", DataLink_Struct.k_factor));
                            break;

                        case RETRANSMISSION_TIMER_IDENTIFIER:
                             /*
                             **    t200 is the timeout value before retransmission
                             */
                            t200 = ((*packet_address << 7) | 
                                    (*(packet_address + 1) & 0x7f));
                            packet_address += 2;
                            length -= 2;

                            DataLink_Struct.t200 = t200;
                            Received_T200 = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessConnect: t200 = %d", DataLink_Struct.t200));
                            break;

                        default:
                            while ((*(packet_address++) & EXTENSION) == 0)
                                length--;
                            length--;
                            break;
                    }
                    length--;
                }
                break;

            case END_TO_END_DELAY:
            case CALLING_PARTY_SUBADDRESS:
            case CALLED_PARTY_SUBADDRESS:
            default:
                TRACE_OUT(("SCFCall: DataIndication: CONNECT packet: Option "
                    "requested, but not supported", *(packet_address-1)));
                length = *(packet_address++);
                remainder_length--;

                packet_address += length;
                remainder_length -= length;
                break;
        }
        remainder_length--;
    }

    if (Received_N201 == FALSE)
        DataLink_Struct.n201 = DataLink_Struct.default_n201;
    if (Received_K_Factor == FALSE)
        DataLink_Struct.k_factor = DataLink_Struct.default_k_factor;
    if (Received_T200 == FALSE)
        DataLink_Struct.t200 = DataLink_Struct.default_t200;

     /*
     **    If the packet was successfully decoded, queue up the CONNECT ACK
     */
    if (packet_successful)
    {
        Packet_Pending = CONNECT_ACKNOWLEDGE;
        StopTimerT303 ();
    }

    return (packet_successful);
}


/*
 *    BOOL        SCFCall::ProcessConnectAcknowledge (
 *                             LPBYTE,
 *                             USHORT)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes an incoming CONNECT ACK packet
 *
 */
BOOL        SCFCall::ProcessConnectAcknowledge (
                        LPBYTE,
                        USHORT)
{
    TRACE_OUT(("SCFCall::ProcessConnectAcknowledge"));

    if (State != CONNECT_SENT)
        return (FALSE);

    StopTimerT313 ();

    return (TRUE);
}


/*
 *    BOOL        SCFCall::ProcessReleaseComplete (
 *                             LPBYTE        packet_address,
 *                             USHORT)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes an incoming RELEASE COMPLETE
 */
BOOL        SCFCall::ProcessReleaseComplete (
                        LPBYTE    packet_address,
                        USHORT)
{
    TRACE_OUT(("SCFCall::ProcessReleaseComplete"));

    USHORT    cause;

    if (State == NOT_CONNECTED)
        return (FALSE);

    if (*(packet_address++) == CAUSE)
    {
        packet_address++;
        if ((*(packet_address++) & EXTENSION) == 0)
            packet_address++;

        cause = *(packet_address++) & (~EXTENSION);
        TRACE_OUT(("SCFCall: Disconnect: cause = %d", cause));
    }

    State = NOT_CONNECTED;

     /*
     **    Tell the owner about the Disconnection
     */
    m_pSCF->OwnerCallback(m_nMsgBase + NETWORK_DISCONNECT_INDICATION,
                          (void *) DLC_Identifier,
                          (void *) (ULONG_PTR)(((Link_Originator << 16) | cause)));
    return (TRUE);
}


/*
 *    void    SCFCall::PollTransmitter (
 *                        USHORT        data_to_transmit,
 *                        USHORT *    pending_data);
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to transmit any queued up packets
 */
void    SCFCall::PollTransmitter (
                    USHORT    data_to_transmit,
                    USHORT *    pending_data)
{
    // TRACE_OUT(("SCFCall::PollTransmitter"));

    NetworkConnectStruct    connect_struct;

    if (data_to_transmit & PROTOCOL_CONTROL_DATA)
    {
        switch (Packet_Pending)
        {
        case SETUP:
            SendSetup ();
            break;

        case CONNECT:
            SendConnect ();
            break;

        case CONNECT_ACKNOWLEDGE:
            SendConnectAcknowledge ();
            if (Packet_Pending != CONNECT_ACKNOWLEDGE)
            {
                 /*
                 **    If the CONNECT ACK packet was sent, notify the owner
                 */
                connect_struct.dlci = DLC_Identifier;
                connect_struct.priority = Priority;
                connect_struct.datalink_struct = &DataLink_Struct;

                 /*
                 **    Convert t200 to milliseconds
                 */
                DataLink_Struct.t200 *= 100;
                m_pSCF->OwnerCallback(m_nMsgBase + NETWORK_CONNECT_CONFIRM, 0, 0, &connect_struct);
                DataLink_Struct.t200 /= 100;
            }
            break;

        case RELEASE_COMPLETE:
            SendReleaseComplete ();
            if (Packet_Pending != RELEASE_COMPLETE)
            {
                 /*
                 **    If the RELEASE COMPLETE packet was sent, notify 
                 **    the owner
                 */
                m_pSCF->OwnerCallback(m_nMsgBase + NETWORK_DISCONNECT_INDICATION,
                                      (void *) DLC_Identifier,
                                      (void *) ((((ULONG_PTR) Link_Originator) << 16) | Release_Cause));
            }
            break;
        }
            
        if (Packet_Pending != NO_PACKET)
            *pending_data = PROTOCOL_CONTROL_DATA;
        else
            *pending_data = 0;
    }

    return;
}


/*    
 *    void    SCFCall::SendSetup (void);
 *
 *    Functional Description
 *        This function attempts to send out a SETUP packet.  The T303 timer
 *        is started.  If a CONNECT is not received before the timer expires,
 *        we terminate the link.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        If this function is able to send a SETUP packet to the lower layer,
 *        it sets the Packet_Pending variable to NO_PACKET
 *
 *    Caveats
 *        None
 */
void    SCFCall::SendSetup (void)
{
    TRACE_OUT(("SCFCall::SendSetup"));

    LPBYTE    packet_address;
    ULONG    bytes_accepted;
    USHORT    total_length;
    PMemory    memory;

    total_length = SETUP_PACKET_SIZE + Lower_Layer_Prepend +
                    Lower_Layer_Append;

    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);
    if (memory == NULL)
        return;

    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    *(packet_address++) = Q931_PROTOCOL_DISCRIMINATOR;
    *(packet_address++) = 1;
    *(packet_address++) = (UChar) Call_Reference;
    *(packet_address++) = SETUP;

     /*
     **    Bearer Capability
     */
    *(packet_address++) = BEARER_CAPABILITY;
    *(packet_address++) = 3;
    *(packet_address++) = 
        EXTENSION | CODING_STANDARD | INFORMATION_TRANSFER_CAPABILITY;
    *(packet_address++) = EXTENSION | TRANSFER_MODE;
    *(packet_address++) = EXTENSION | LAYER_2_IDENT | USER_INFORMATION_LAYER_2;
    
     /*
     **    DLCI
     */
    *(packet_address++) = DLCI_ELEMENT;
    *(packet_address++) = 2;
    *(packet_address++) = (DLC_Identifier >> 4);
    *(packet_address++) = EXTENSION | ((DLC_Identifier & 0x0f) << 3);

     /*
     **    Link Layer Core Parameters
     */
    *(packet_address++) = LINK_LAYER_CORE_PARAMETERS;
    *(packet_address++) = 3;
    *(packet_address++) = FMIF_SIZE;
    *(packet_address++) = (DataLink_Struct.n201 >> 7);
    *(packet_address++) = EXTENSION | (DataLink_Struct.n201 & 0x7f);

     /*
     **    Link Layer Protocol Parameters
     */
    *(packet_address++) = LINK_LAYER_PROTOCOL_PARAMETERS;
    *(packet_address++) = 5;
    *(packet_address++) = TRANSMIT_WINDOW_SIZE_IDENTIFIER;
    *(packet_address++) = EXTENSION | DataLink_Struct.k_factor;
    *(packet_address++) = RETRANSMISSION_TIMER_IDENTIFIER;
    *(packet_address++) = (DataLink_Struct.t200 >> 7) & 0x7f;
    *(packet_address++) = EXTENSION | (DataLink_Struct.t200 & 0x7f);

     /*
     **    X.213 Priority
     */
    *(packet_address++) = X213_PRIORITY;
    *(packet_address++) = 2;
    *(packet_address++) = (UChar) Priority;

     /*
     **    The next byte contains the lowest priority acceptable, 0
     */
    *(packet_address++) = EXTENSION | 0;

     /*
     **    Attempt to send the packet down
     */
    Lower_Layer -> DataRequest (
                            0,
                            memory,
                            &bytes_accepted);
    if (bytes_accepted == total_length)
    {
        T303_Count = 0;
        Packet_Pending = NO_PACKET;
        State = SETUP_SENT;
        StartTimerT303 ();
    }
    Data_Request_Memory_Manager -> FreeMemory (memory);
}


/*    
 *    void    SCFCall::SendConnect (void);
 *
 *    Functional Description
 *        This function attempts to send out a CONNECT packet.  The T313 timer
 *        is started.  If a CONNECT ACK is not received before the timer expires,
 *        we terminate the link. 
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        If this function is able to send a CONNECT packet to the lower layer,
 *        it sets the Packet_Pending variable to NO_PACKET
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::SendConnect (void)
{
    TRACE_OUT(("SCFCall::SendConnect"));

    LPBYTE        packet_address;
    LPBYTE        length_address;
    ULONG        bytes_accepted;
    USHORT        total_length;
    PMemory        memory;

    total_length = CONNECT_PACKET_BASE_SIZE + Lower_Layer_Prepend +
                    Lower_Layer_Append;

    if (Received_N201)
        total_length += 5;

    if (Received_K_Factor || Received_T200)
    {
        total_length += 2;

        if (Received_K_Factor)
            total_length += 2;
        if (Received_T200)
            total_length += 3;
    }
    if (Received_Priority)
        total_length += 3;

     /*
     **    Prepare the CONNECT command and send it to the lower layer
     */
    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);
    if (memory == NULL)
        return;

    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    *(packet_address++) = Q931_PROTOCOL_DISCRIMINATOR;
    *(packet_address++) = 1;
    *(packet_address++) = REMOTE_CALL_REFERENCE | Call_Reference;
    *(packet_address++) = CONNECT;

     /*
     **    DLCI
     */
    *(packet_address++) = DLCI_ELEMENT;
    *(packet_address++) = 2;
    *(packet_address++) = PREFERRED_EXCLUSIVE | (DLC_Identifier >> 4);
    *(packet_address++) = EXTENSION | ((DLC_Identifier & 0x0f) << 3);

    if (Received_N201)
    {
         /*
         **    Link Layer Core Parameters
         */
        *(packet_address++) = LINK_LAYER_CORE_PARAMETERS;
        *(packet_address++) = 3;
        *(packet_address++) = FMIF_SIZE;
        *(packet_address++) = (DataLink_Struct.n201 >> 7);
        *(packet_address++) = EXTENSION | (DataLink_Struct.n201 & 0x7f);
    }
    else
        DataLink_Struct.n201 = DataLink_Struct.default_n201;


    if (Received_K_Factor || Received_T200)
    {
         /*
         **    Link Layer Protocol Parameters
         */
        *(packet_address++) = LINK_LAYER_PROTOCOL_PARAMETERS;
        length_address = packet_address;
        *(packet_address++) = 0;
        if (Received_K_Factor)
        {
            *length_address += 2;
            *(packet_address++) = TRANSMIT_WINDOW_SIZE_IDENTIFIER;
            *(packet_address++) = EXTENSION | DataLink_Struct.k_factor;
        }
        if (Received_T200)
        {
            *length_address += 3;
            *(packet_address++) = RETRANSMISSION_TIMER_IDENTIFIER;
            *(packet_address++) = (DataLink_Struct.t200 >> 7) & 0x7f;
            *(packet_address++) = EXTENSION | (DataLink_Struct.t200 & 0x7f);
        }
    }
    if (Received_K_Factor == FALSE)
        DataLink_Struct.k_factor = DataLink_Struct.default_k_factor;
    if (Received_T200 == FALSE)
        DataLink_Struct.t200 = DataLink_Struct.default_t200;

    if (Received_Priority)
    {
         /*
         **    X.213 Priority
         */
        *(packet_address++) = X213_PRIORITY;
        *(packet_address++) = 1;
        *(packet_address++) = (BYTE) (EXTENSION | Priority);
    }
    
     /*
     **    Attempt to send the packet to the lower layer
     */
    Lower_Layer -> DataRequest (
                    0,
                    memory,
                    &bytes_accepted);
    if (bytes_accepted == total_length)
    {
        StartTimerT313 ();
        Packet_Pending = NO_PACKET;
        State = CONNECT_SENT;
    }
    Data_Request_Memory_Manager -> FreeMemory (memory);
}


/*    
 *    void    SCFCall::SendConnectAcknowledge (void);
 *
 *    Functional Description
 *        This function attempts to send out a CONNECT ACKNOWLEDGE packet
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        If this function is able to send the packet to the lower layer,
 *        it sets the Packet_Pending variable to NO_PACKET
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::SendConnectAcknowledge (void)
{
    TRACE_OUT(("SCFCall::SendConnectAcknowledge"));

    LPBYTE        packet_address;
    USHORT        total_length;
    PMemory        memory;
    ULONG        bytes_accepted;

    total_length = CONNECT_ACK_PACKET_SIZE + Lower_Layer_Prepend +
                    Lower_Layer_Append;
     /*
     **    Prepare the command and send it to the lower layer
     */
    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);
    if (memory == NULL)
        return;

    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    *(packet_address++) = Q931_PROTOCOL_DISCRIMINATOR;
    *(packet_address++) = 1;
    *(packet_address++) = (UChar) Call_Reference;
    *(packet_address++) = CONNECT_ACKNOWLEDGE;

    Lower_Layer -> DataRequest (
                    0,
                    memory,
                    &bytes_accepted);
    if (bytes_accepted == total_length)
    {
        State = CALL_ESTABLISHED;
        Packet_Pending = NO_PACKET;
    }
    Data_Request_Memory_Manager -> FreeMemory (memory);
}


/*    
 *    void    SCFCall::SendReleaseComplete (void);
 *
 *    Functional Description
 *        This function attempts to send out a RELEASE COMPLETE packet
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        If this function is able to send a RELEASE COMPLETE packet to the lower
 *        layer, it sets the Packet_Pending variable to NO_PACKET
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::SendReleaseComplete (void)
{
    TRACE_OUT(("SCFCall::SendReleaseComplete"));

    LPBYTE    packet_address;
    ULONG    bytes_accepted;
    USHORT    total_length;
    PMemory    memory;

    total_length = RELEASE_COMPLETE_PACKET_SIZE + Lower_Layer_Prepend +
                    Lower_Layer_Append;
     /*
     **    Prepare the command and send it to the lower layer
     */
    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);
    if (memory == NULL)
        return;

    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    *(packet_address++) = Q931_PROTOCOL_DISCRIMINATOR;
    *(packet_address++) = 1;
    if (Link_Originator)
        *(packet_address++) = (UChar) Call_Reference;
    else
        *(packet_address++) = 0x80 | Call_Reference;
    *(packet_address++) = RELEASE_COMPLETE;


     /*
     **    Append the CAUSE for the link breakup
     */
    *(packet_address++) = CAUSE;
    *(packet_address++) = 2;    
    *(packet_address++) = EXTENSION;
    *(packet_address++) = EXTENSION | Release_Cause;

    Lower_Layer -> DataRequest (
                    0,
                    memory,
                    &bytes_accepted);
    if (bytes_accepted == total_length)
    {
        State = NOT_CONNECTED;
        Packet_Pending = NO_PACKET;
    }
    Data_Request_Memory_Manager -> FreeMemory (memory);
}


/*    
 *    void    SCFCall::StartTimerT303 (void);
 *
 *    Functional Description
 *        This function Starts the T303 Timer.  This is started when we send
 *        out the SETUP packet.  It is stopped when we receive a CONNECT
 *        packet.  If it expires we terminate the link.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void SCFCall::StartTimerT303 (void)
{
    TRACE_OUT(("SCFCall::StartTimerT303"));

    if (T303_Active)
        StopTimerT303 ();

    T303_Handle = g_pSystemTimer->CreateTimerEvent(
                    T303_Timeout,
                    TIMER_EVENT_ONE_SHOT,
                    this,
                    (PTimerFunction) &SCFCall::T303Timeout);

    T303_Active = TRUE;

}


/*    
 *    void    SCFCall::StopTimerT303 (void);
 *
 *    Functional Description
 *        This function stops the T303 Timer.  This is called when we receive
 *        the CONNECT packet.  As a result, we stop the timer.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::StopTimerT303 (void)
{
    TRACE_OUT(("SCFCall::StopTimerT303"));

    if (T303_Active)
    {
        g_pSystemTimer->DeleteTimerEvent(T303_Handle);
        T303_Active = FALSE;
    }
}


/*    
 *    void    SCFCall::T303Timeout (
 *                        TimerEventHandle);
 *
 *    Functional Description
 *        This function is called by the System timer when the T303 timeout
 *        expires.  As a result, we terminate the link.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::T303Timeout (
                    TimerEventHandle)
{
    TRACE_OUT(("SCFCall: T303Timeout"));

    if (T303_Count >= 1)
        State = NOT_CONNECTED;

    T303_Count++;

    Packet_Pending = RELEASE_COMPLETE;
    Release_Cause = NORMAL_USER_DISCONNECT;
}


/*    
 *    void    SCFCall::StartTimerT313 (void);
 *
 *    Functional Description
 *        This function Starts the T313 Timer.  This is started when we send
 *        out the CONNECT packet.  It is stopped when we receive a CONNECT ACK
 *        packet.  If it expires we terminate the link.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::StartTimerT313 (void)
{
    TRACE_OUT(("SCFCall: StartTimerT313"));

    if (T313_Active)
        StopTimerT313 ();

    T313_Handle = g_pSystemTimer->CreateTimerEvent(
                    T313_Timeout, 
                    TIMER_EVENT_ONE_SHOT,
                    this,
                    (PTimerFunction) &SCFCall::T313Timeout);

    T313_Active = TRUE;
}


/*    
 *    void    SCFCall::StopTimerT313 (void);
 *
 *    Functional Description
 *        This function stops the T313 Timer.  This is called when we receive
 *        the CONNECT ACK packet.  As a result, we stop the timer.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::StopTimerT313 (void)
{
    TRACE_OUT(("SCFCall: StopTimerT313"));

    if (T313_Active)
    {
        g_pSystemTimer->DeleteTimerEvent(T313_Handle);
        T313_Active = FALSE;
    }
}


/*    
 *    void    SCFCall::T313Timeout (
 *                        TimerEventHandle);
 *
 *    Functional Description
 *        This function is called by the System timer when the T313 timeout
 *        expires.  As a result, we terminate the link.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::T313Timeout (
                    TimerEventHandle)
{
    TRACE_OUT(("SCFCall: T313Timeout"));

    State = NOT_CONNECTED;
    Packet_Pending = RELEASE_COMPLETE;
    Release_Cause = NORMAL_USER_DISCONNECT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\scf.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    SCF.cpp
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the CLayerSCF class
 *
 *    Private Instance Variables:
 *        Remote_Call_Reference    -    List of active SCFCalls initiated by the
 *                                    remote site
 *        Call_Reference            -    List of active SCFCalls initiated locally
 *        DLCI_List                -    This list matches DLCIs to SCFCalls, its
 *                                    only real purpose is for DisconnectRequest()
 *        Message_List            -    List of OwnerCallback messages that can't
 *                                    be processed immediately.
 *        m_pT123            -    Address of owner object
 *        m_pQ922                -    Address of lower layer
 *        m_nMsgBase            -    Message base passed in by owner.  Used in
 *                                    OwnerCallback
 *        Identifier                -    Identifier passed to lower layer
 *        Link_Originator            -    TRUE if we initiated the connection
 *        Maximum_Packet_Size        -    Maximum packet size transmittable
 *        DataLink_Struct            -    Address of structure holding DataLink parms
 *        Data_Request_Memory_Manager    -    Address of memory manager
 *        Lower_Layer_Prepend        -    Holds number of bytes prepended to packet
 *                                    by the lower layer
 *        Lower_Layer_Append        -    Holds number of bytes appended to packet by
 *                                    the lower layer
 *        Call_Reference_Base        -    This value holds the next call reference
 *                                    number.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */
#include "scf.h"


/*
 *    CLayerSCF::CLayerSCF (
 *            PTransportResources    transport_resources,
 *            IObject *                owner_object,
 *            IProtocolLayer *        lower_layer,
 *            USHORT                message_base,
 *            USHORT                identifier,
 *            BOOL                link_originator,
 *            PChar                config_file)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the CLayerSCF constructor.  This routine initializes all
 *        variables and allocates buffer space.
 */
CLayerSCF::CLayerSCF
(
    T123                   *owner_object,
    CLayerQ922             *pQ922, // lower layer
    USHORT                  message_base,
    USHORT                  identifier,
    BOOL                    link_originator,
    PDataLinkParameters     datalink_struct,
    PMemoryManager          data_request_memory_manager,
    BOOL  *                 initialized
)
:
    Remote_Call_Reference (TRANSPORT_HASHING_BUCKETS),
    Call_Reference (TRANSPORT_HASHING_BUCKETS),
    DLCI_List (TRANSPORT_HASHING_BUCKETS),
    m_pT123(owner_object),
    m_nMsgBase(message_base),
    m_pQ922(pQ922)
{
    ProtocolLayerError    error;

    TRACE_OUT(("CLayerSCF::CLayerSCF"));

    Link_Originator    = (USHORT)link_originator;
    Identifier = identifier;
    Data_Request_Memory_Manager = data_request_memory_manager;
    Call_Reference_Base = 1;
    *initialized = TRUE;


     /*
     **    Fill in the DataLink_Struct with the proposed values and the default
     **    values
     */
    DataLink_Struct.k_factor = datalink_struct -> k_factor;
    DataLink_Struct.default_k_factor = datalink_struct -> default_k_factor;
    DataLink_Struct.n201 = datalink_struct -> n201;
    DataLink_Struct.default_n201 = datalink_struct -> default_n201;
    DataLink_Struct.t200 = datalink_struct -> t200;
    DataLink_Struct.default_t200 = datalink_struct -> default_t200;

     /*
     **    Find the maximum packet size
     */
    m_pQ922->GetParameters(
                    &Maximum_Packet_Size,
                    &Lower_Layer_Prepend,
                    &Lower_Layer_Append);

     /*
     **    Register with the lower layer
     */
    error = m_pQ922->RegisterHigherLayer(
                            Identifier,
                            Data_Request_Memory_Manager,
                            (IProtocolLayer *) this);

    if (error != PROTOCOL_LAYER_NO_ERROR)
    {
        ERROR_OUT(("Multiplexer: constructor:  Error registering with lower layer"));
        *initialized = FALSE;
    }
}


/*
 *    CLayerSCF::~CLayerSCF (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the CLayerSCF destructor.  This routine cleans up everything.
 */
CLayerSCF::~CLayerSCF (void)
{
    TRACE_OUT(("CLayerSCF::~CLayerSCF"));

    PMessageStruct    message;
    PSCFCall        lpSCFCall;

    m_pQ922->RemoveHigherLayer(Identifier);

     /*
     **    Delete all locally initiated calls
     */
    Call_Reference.reset();
    while (Call_Reference.iterate ((PDWORD_PTR) &lpSCFCall))
    {
        delete lpSCFCall;
    }

     /*
     **    Delete all remotely initiated calls
     */
    Remote_Call_Reference.reset();
    while (Remote_Call_Reference.iterate ((PDWORD_PTR) &lpSCFCall))
    {
        delete lpSCFCall;
    }

     /*
     **    Delete all passive owner callbacks
     */
    Message_List.reset();
    while (Message_List.iterate ((PDWORD_PTR) &message))
    {
        delete message;
    }
}


/*
 *    CLayerSCF::ConnectRequest (
 *            DLCI                dlci,
 *            TransportPriority    priority)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initiates a connection with the remote site.  As a result,
 *        we will create a SCFCall and tell it to initiate a connection.
 */
SCFError    CLayerSCF::ConnectRequest (
                    DLCI                dlci,
                    TransportPriority    priority)

{
    TRACE_OUT(("CLayerSCF::ConnectRequest"));

    BOOL            initialized;
    CallReference    call_reference;
    SCFError        return_value = SCF_NO_ERROR;
    PSCFCall        lpSCFCall;


     /*
     **    Get the next valid local call reference value.
     */
    call_reference = GetNextCallReference ();

    if (call_reference == 0)
        return (SCF_CONNECTION_FULL);

     /*
     **    Create an SCFCall object to handle this call reference
     */
    DBG_SAVE_FILE_LINE
    lpSCFCall= new SCFCall(this,
                            m_pQ922,
                            call_reference << 8,
                            &DataLink_Struct,
                            Data_Request_Memory_Manager,
                            &initialized);

    if (lpSCFCall != NULL)
    {
        if (initialized)
        {
            Call_Reference.insert ((DWORD_PTR) call_reference, (DWORD_PTR) lpSCFCall);
             /*
             **    Register the DLCI and the call reference
             */
            DLCI_List.insert ((DWORD_PTR) dlci, (DWORD_PTR) lpSCFCall);

            lpSCFCall->ConnectRequest (call_reference, dlci, priority);
        }
        else
        {
            delete lpSCFCall;
            return_value = SCF_MEMORY_ALLOCATION_ERROR;
        }
    }
    else
    {
        return_value = SCF_MEMORY_ALLOCATION_ERROR;
    }

    return (return_value);
}


/*
 *    CLayerSCF::ConnectResponse (
 *            CallReference    call_reference,
 *            DLCI            dlci,
 *            BOOL            valid_dlci)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the CLayerSCF destructor.  This routine cleans up everything.
 */
SCFError    CLayerSCF::ConnectResponse (
                    CallReference    call_reference,
                    DLCI            dlci,
                    BOOL            valid_dlci)

{
    TRACE_OUT(("CLayerSCF::ConnectResponse"));

    PSCFCall        lpSCFCall = NULL;

    if (valid_dlci)
    {
        if (Remote_Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &lpSCFCall))
            DLCI_List.insert ((DWORD_PTR) dlci, (DWORD_PTR) lpSCFCall);
    }

	if(NULL != lpSCFCall)
	{
    	lpSCFCall->ConnectResponse (valid_dlci);
	    return (SCF_NO_ERROR);
    }
    return (SCF_NO_SUCH_DLCI);


}


/*
 *    SCFError    CLayerSCF::DisconnectRequest (
 *                        DLCI    dlci)
 *
 *    Public
 *
 *    Functional Description:
 *        This function calls the SCFCall associated with the DLCI and starts
 *        the disconnect operation
 */
SCFError    CLayerSCF::DisconnectRequest (
                    DLCI    dlci)

{
    TRACE_OUT(("CLayerSCF::DisconnectRequest"));

    PSCFCall        lpSCFCall;

    if (DLCI_List.find ((DWORD_PTR) dlci, (PDWORD_PTR) &lpSCFCall) == FALSE)
        return (SCF_NO_SUCH_DLCI);

    lpSCFCall->DisconnectRequest ();

    return (SCF_NO_ERROR);
}


/*
 *    SCFError    CLayerSCF::DataIndication (
 *                        LPBYTE        packet_address,
 *                        ULONG        buffer_size,
 *                        PULong        packet_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the lower layer when it has received a
 *        packet for us to process.
 */
ProtocolLayerError    CLayerSCF::DataIndication (
                            LPBYTE        packet_address,
                            ULONG        packet_length,
                            PULong        bytes_accepted)
{
    TRACE_OUT(("CLayerSCF::DataIndication"));

    BOOL            legal_packet;
    CallReference    call_reference;
    USHORT            length_call_reference;
    USHORT            message_type;
    PSCFCall        call;
    USHORT            remainder_length;
    USHORT            local;
    BOOL            initialized;


    remainder_length = (USHORT) packet_length;
    *bytes_accepted = packet_length;

    if (*(packet_address+PROTOCOL_DISCRIMINATOR) != Q931_PROTOCOL_DISCRIMINATOR)
        return (PROTOCOL_LAYER_NO_ERROR);

     /*
     **    Get the call reference value
     */
    call_reference = *(packet_address + CALL_REFERENCE_VALUE);
    if (call_reference == 0)
    {
        ERROR_OUT(("CLayerSCF: DataIndication: illegal call reference value = 0"));
        return (PROTOCOL_LAYER_NO_ERROR);
    }

    length_call_reference = *(packet_address + LENGTH_CALL_REFERENCE);
    packet_address += CALL_REFERENCE_VALUE + length_call_reference;
    remainder_length -= (CALL_REFERENCE_VALUE + length_call_reference);


     /*
     **    Get the message type
     */
    message_type = *(packet_address++);
    remainder_length--;

    switch (message_type)
    {
        case SETUP:
             /*
             **    If the call reference is already active, return error
             */
            if (Remote_Call_Reference.find ((DWORD) call_reference))
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  SETUP: call reference is already active"));
                break;
            }

            if ((call_reference & CALL_REFERENCE_ORIGINATOR) == 1)
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  SETUP: call reference Originator bit is set incorrectly"));
                break;
            }

             /*
             **    This is a new call reference, create a new SCFCall to handle
             **    the call.  Since the remote site initiated the call, put this
             **    reference in the Remote array
             */
            call= new SCFCall(this,
                                m_pQ922,
                                (call_reference << 8),
                                &DataLink_Struct,
                                Data_Request_Memory_Manager,
                                &initialized);

            if (call != NULL)
            {
                if (initialized)
                {

                    Remote_Call_Reference.insert ((DWORD_PTR) call_reference, (DWORD_PTR) call);
                     /*
                     **    Allow the call to process the SETUP command
                     */
                    legal_packet = call->ProcessSetup (call_reference, packet_address, remainder_length);

                     /*
                     **    If the packet was illegal, remove the reference
                     */
                    if (legal_packet == FALSE) {
                        delete call;
                        Remote_Call_Reference.remove ((DWORD) call_reference);
                    }
                }
                else
                {
                    delete call;
                }
            }
            break;


        case CONNECT:
             /*
             **    The call originator bit must be set to signify that we are
             **    the originators of the call
             */
            if ((call_reference & CALL_REFERENCE_ORIGINATOR) == 0)
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  CONNECT: call reference Originator bit is set incorrectly"));
                break;
            }

             /*
             **    If the call reference is not already active, return error
             */
            call_reference &= CALL_ORIGINATOR_MASK;
            if (Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  CONNECT: call reference is not already active = %x", call_reference));
                break;
            }

            call->ProcessConnect (packet_address, remainder_length);
            break;

        case CONNECT_ACKNOWLEDGE:
             /*
             **    If the call reference is already active, return error
             */
            if (Remote_Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  CONNECT_ACK: call reference is not active"));
                break;
            }

             /*
             **    The call originator bit should NOT be set
             */
            if ((call_reference & CALL_REFERENCE_ORIGINATOR) == 1)
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  CONNECT_ACK: call reference Originator bit is set incorrectly"));
                break;
            }

            call->ProcessConnectAcknowledge (packet_address, remainder_length);
            break;

        case RELEASE_COMPLETE:
            local = call_reference & CALL_REFERENCE_ORIGINATOR;
            call_reference &= CALL_ORIGINATOR_MASK;

             /*
             **    If the call is local, check the Call_Reference list for validity
             */
            if (local)
            {
                if (Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
                {
                    TRACE_OUT(("CLayerSCF: DataIndication:  RELEASE_COMPLETE: call reference is not already active"));
                    break;
                }
            }
            else
            {
                 /*
                 **    If the call is remote, check the Call_Reference list for
                 **    validity
                 */
                if (Remote_Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
                {
                    TRACE_OUT(("CLayerSCF: DataIndication:  RELEASE_COMPLETE: call reference is not already active"));
                    break;
                }
            }

            call -> ProcessReleaseComplete (packet_address, remainder_length);
            ProcessMessages ();
            break;

        case DISCONNECT:
        case RELEASE:
        case STATUS:
        case STATUS_ENQUIRY:
            TRACE_OUT(("CLayerSCF:DataIndication: Illegal command received = %x", message_type));

            local = call_reference & CALL_REFERENCE_ORIGINATOR;
            call_reference &= CALL_ORIGINATOR_MASK;

             /*
             **    If the call is local, check the Call_Reference list for validity
             */
            if (local)
            {
                if (Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
                    break;
            }
            else
            {
                 /*
                 **    If the call is remote, check the Call_Reference list for
                 **    validity
                 */
                if (Remote_Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
                    break;
            }

            call -> DisconnectRequest ();
            break;

        default:
            ERROR_OUT(("CLayerSCF:DataIndication: Unrecognized command received = %x", message_type));
            break;
    }
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerSCF::PollTransmitter (
 *                                ULONG,
 *                                USHORT    data_to_transmit,
 *                                USHORT *    pending_data,
 *                                USHORT *)
 *
 *    Public
 *
 *    Functional Description:
 *        This function should be called frequently to allow the SCF calls to
 *        transmit packets.
 */
ProtocolLayerError    CLayerSCF::PollTransmitter (
                                ULONG_PTR,
                                USHORT    data_to_transmit,
                                USHORT *    pending_data,
                                USHORT *)
{
    // TRACE_OUT(("CLayerSCF::PollTransmitter"));

    USHORT            local_pending_data;
    PSCFCall        lpSCFCall;

    *pending_data = 0;

     /*
     **    Go through each of the locally originated calls and attempt to transmit
     **    data.
     */
    Call_Reference.reset();
    while (Call_Reference.iterate ((PDWORD_PTR) &lpSCFCall))
    {
        lpSCFCall->PollTransmitter (data_to_transmit, &local_pending_data);
        *pending_data |= local_pending_data;
    }


     /*
     **    Go through each of the remotely originated calls and attempt to transmit
     **    data.
     */
    Remote_Call_Reference.reset();
    while (Remote_Call_Reference.iterate ((PDWORD_PTR) &lpSCFCall))
    {
        lpSCFCall-> PollTransmitter (data_to_transmit, &local_pending_data);
        *pending_data |= local_pending_data;
    }

    ProcessMessages ();

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    SCFError    CLayerSCF::DataRequest (
 *                        ULONG,
 *                        LPBYTE,
 *                        ULONG,
 *                        PULong)
 *
 *    Public
 *
 *    Functional Description:
 *        This function can not be called.  This layer does not permit data
 *        requests from higher layers.
 */
ProtocolLayerError    CLayerSCF::DataRequest (
                            ULONG_PTR,
                            LPBYTE,
                            ULONG,
                            PULong)
{
    return (PROTOCOL_LAYER_ERROR);
}

/*
 *    SCFError    CLayerSCF::DataRequest (
 *                        ULONG,
 *                        PMemory,
 *                        USHORT *)
 *
 *    Public
 *
 *    Functional Description:
 *        This function can not be called.  This layer does not permit data
 *        requests from higher layers.
 */
ProtocolLayerError    CLayerSCF::DataRequest (
                            ULONG_PTR,
                            PMemory,
                            PULong)
{
    return (PROTOCOL_LAYER_ERROR);
}


/*
 *    void    CLayerSCF::PollReceiver (
 *                    ULONG)
 *
 *    Public
 *
 *    Functional Description
 *        This function only checks its passive callback list.  If this function
 *        had a higher layer that it was passing data too, it would do that.  But
 *        since it has no higher layer, it doesn't do much.
 */
ProtocolLayerError CLayerSCF::PollReceiver(void)
{
    ProcessMessages ();

    return (PROTOCOL_LAYER_NO_ERROR);
}



/*
 *    CallReference    CLayerSCF::GetNextCallReference ()
 *
 *    Functional Description
 *        This function searches the local call reference list for a valid call
 *        reference number.  If it can not find one, it returns 0.  Valid call
 *        references are 1-127.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Call reference value
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
USHORT    CLayerSCF::GetNextCallReference ()
{
    USHORT    call_reference;

    if (Call_Reference.entries() == 127)
        return (0);

    call_reference = Call_Reference_Base;
    Call_Reference_Base++;
    if (Call_Reference_Base == 128)
        Call_Reference_Base = 1;

    while (Call_Reference.find ((DWORD) call_reference))
    {
        call_reference++;
        if (call_reference == 128)
            call_reference = 1;
    }

    return (call_reference);
}


/*
 *    ULONG    CLayerSCF::OwnerCallback (
 *                    USHORT    message,
 *                    ULONG    parameter1,
 *                    ULONG    parameter2,
 *                    PVoid    parameter3)
 *
 *    Functional Description
 *        This function is called by the SCFCall objects when they need to
 *        communicate a message to us.  If the message can not be processed
 *        immediately, it is saved in a message structure and processed at a
 *        later time.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Message dependent
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
ULONG CLayerSCF::OwnerCallback
(
    ULONG       message,
    void       *parameter1,
    void       *parameter2,
    void       *parameter3
)
{
    TRACE_OUT(("CLayerSCF::OwnerCallback"));

    ULONG                   actual_message;
    CallReference           call_reference;
    PMessageStruct          passive_message;
    PNetworkConnectStruct   connect_struct;
    PSCFCall                lpSCFCall;

     /*
     **    The upper byte of the message is the call reference message that it
     **    represents
     */
    call_reference = (CallReference) (message >> 8);
    actual_message = message & 0xff;

    switch (actual_message)
    {
    case NETWORK_CONNECT_CONFIRM:

         /*
         **    A CONNECT_CONFIRM message is returned by the SCFCall when a call
         **    that we originated, has been established.  We register the
         **    SCFCall with the DLCI and call the owner object.
         */
        connect_struct = (PNetworkConnectStruct) parameter3;
        connect_struct -> call_reference = call_reference;

        if (Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &lpSCFCall))
        {
            DLCI_List.insert ((DWORD_PTR) connect_struct->dlci, (DWORD_PTR) lpSCFCall);
        }

        m_pT123->OwnerCallback(m_nMsgBase + actual_message, 0, 0, parameter3);
        break;

    case NETWORK_CONNECT_INDICATION:
         /*
         **    A CONNECT_INDICATION message is returned by the SCFCall when the
         **    remote SCF wants to create a new call.  We will call the owner
         **    of this object to see if he will accept the DLCI requested.
         */
        connect_struct = (PNetworkConnectStruct) parameter3;
        connect_struct -> call_reference = call_reference;

        m_pT123->OwnerCallback(m_nMsgBase + actual_message, 0, 0, parameter3);
        break;

    case NETWORK_DISCONNECT_INDICATION:
         /*
         **    This message is received from the SCFCall when one side wants
         **    to terminate the call.  We treat this message differently than
         **    the other messages because it involves the deletion of an
         **    SCFCall object.  Don't forget, if we delete the object and then
         **    return to it at the end of this procedure, a GPF could occur.
         */
        DBG_SAVE_FILE_LINE
        passive_message = new MessageStruct;
        if (NULL != passive_message)
        {
            passive_message -> message = message;
            passive_message -> parameter1 = parameter1;
            passive_message -> parameter2 = parameter2;
            passive_message -> parameter3 = parameter3;
            Message_List.append ((DWORD_PTR) passive_message);
        }
        else
        {
            ERROR_OUT(("CLayerSCF::OwnerCallback: cannot allocate MessageStruct"));
        }
        break;

    default:
        ERROR_OUT(("CLayerSCF: Illegal message: %x", actual_message));
        break;
    }
    return (0);
}


/*
 *    ProtocolLayerError    CLayerSCF::GetParameters (
 *                            USHORT,
 *                            USHORT *,
 *                            USHORT *,
 *                            USHORT *)
 *
 *    Public
 *
 *    Functional Description
 *        This function is not valid in this layer.  It must exist because this
 *        class inherits from inherits from ProtocolLayer and it is a pure virtual
 *        function.
 */
ProtocolLayerError    CLayerSCF::GetParameters (
                            USHORT *,
                            USHORT *,
                            USHORT *)
{
    return (PROTOCOL_LAYER_REGISTRATION_ERROR);
}


/*
 *    ProtocolLayerError    CLayerSCF::RegisterHigherLayer (
 *                                USHORT,
 *                                PMemoryManager,
 *                                IProtocolLayer *)
 *
 *    Public
 *
 *    Functional Description
 *        This function is not valid in this layer.  It must exist because this
 *        class inherits from inherits from ProtocolLayer and it is a pure virtual
 *        function.
 */
ProtocolLayerError    CLayerSCF::RegisterHigherLayer (
                            ULONG_PTR,
                            PMemoryManager,
                            IProtocolLayer *)
{
    return (PROTOCOL_LAYER_REGISTRATION_ERROR);
}


/*
 *    ProtocolLayerError    CLayerSCF::RemoveHigherLayer (
 *                                USHORT)
 *
 *    Public
 *
 *    Functional Description
 *        This function is not valid in this layer.  It must exist because this
 *        class inherits from inherits from ProtocolLayer and it is a pure virtual
 *        function.
 */
ProtocolLayerError    CLayerSCF::RemoveHigherLayer (
                            ULONG_PTR)
{
    return (PROTOCOL_LAYER_REGISTRATION_ERROR);
}


/*
 *    void CLayerSCF::ProcessMessages ()
 *
 *    Functional Description
 *        This function is called periodically to check its passive messages.
 *        Passive messages occur when the SCF gets a callback but can't process
 *        it immediately.  Therefore, it puts the message and its parameters in
 *        a structure and saves the message for later.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Message dependent
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void CLayerSCF::ProcessMessages ()
{
    // TRACE_OUT(("CLayerSCF::ProcessMessages"));

    PMessageStruct    message;
    CallReference     call_reference;
    ULONG             actual_message;
    USHORT            call_originator;
    USHORT            cause;
    DLCI              dlci;
    BOOL              call_reference_valid;
    void             *parameter1;
    void             *parameter2;
    PSCFCall          lpSCFCall;

     /*
     **    Go thru each message in the list
     */
    while (Message_List.isEmpty() == FALSE)
    {
         /*
         **    Remote the first message from the list
         */
        message = (PMessageStruct) Message_List.get ();

        call_reference = (CallReference) ((message -> message) >> 8);
        actual_message = (message -> message) & 0xff;
        parameter1 = message -> parameter1;
        parameter2 = message -> parameter2;

        switch (actual_message)
        {
        case NETWORK_DISCONNECT_INDICATION:
             /*
             **    This message is received from the SCFCall when one side
             **    wants to terminate the call.  We treat this message
             **    differently than the other messages because it involves the
             **    deletion of an SCFCall object.
             */
            dlci = (DLCI) parameter1;
            call_originator = (USHORT) (((ULONG_PTR) parameter2) >> 16);
            cause = (USHORT) ((ULONG_PTR) parameter2) & 0xffff;

             /*
             **    dlci is 0 if the SCFCall was never assigned a DLCI by the
             **    remote site.
             */
            if (dlci != 0)
                DLCI_List.remove ((DWORD) dlci);

             /*
             **    If the SCFCall was the call originator, its reference is
             **    in Call_Reference, otherwise it is in Remote_Call_Reference.
             **
             **    Check the Call_Reference list to make sure that the
             **    call_reference is valid.  The way passive owner callbacks
             **    work, it is possible to receive a DISCONNECT for a callback
             **    that was already disconnected.
             */
            call_reference_valid = FALSE;
            if (call_originator)
            {
                if (Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &lpSCFCall))
                {
                    delete lpSCFCall;
                    Call_Reference.remove ((DWORD) call_reference);
                    call_reference_valid = TRUE;
                }
            }
            else
            {
                if (Remote_Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &lpSCFCall))
                {
                    delete lpSCFCall;
                    Remote_Call_Reference.remove ((DWORD_PTR) call_reference);
                    call_reference_valid = TRUE;
                }
            }

            if (call_reference_valid)
            {
                 /*
                 **    If the cause of the disconnect was because the Requested
                 **    channel was unavailable, we will tell the owner of this
                 **    layer to retry the connection.
                 */
                if (cause == REQUESTED_CHANNEL_UNAVAILABLE)
                {
                    parameter2 = (void *) ((((ULONG_PTR) call_originator) << 16) | TRUE);
                }
                else
                {
                    parameter2 = (void *) ((((ULONG_PTR) call_originator) << 16) | FALSE);
                }

                 /*
                 **    Let the owner of this object know that a disconnect has
                 **    occured.
                 */
                m_pT123->OwnerCallback(m_nMsgBase + NETWORK_DISCONNECT_INDICATION,
                                       parameter1, parameter2);
            }
            break;
        }

         /*
         **    Delete the message structure
         */
        delete message;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\slist2.h ===
/*	slist.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the interface to a single linked list data structure.
 *	The values in a list are DWORD values.  So, for example, if the
 *  value is really a pointer, it has to be converted into a DWORD before being passed into a
 *  member list function.
 *
 */

#ifndef _SINGLE_LIST2_H_
#define _SINGLE_LIST2_H_

#include <windows.h>


#define DEFAULT_NUMBER_OF_ITEMS			15


class SListClass
{

public:
	SListClass (DWORD num_of_items = DEFAULT_NUMBER_OF_ITEMS);
	~SListClass ();
	void append (DWORD_PTR new_key);
	BOOL find (DWORD_PTR Key);
	DWORD_PTR read (DWORD index = 0);
	DWORD_PTR get ();
	DWORD_PTR removeLast ();
	BOOL iterate (DWORD_PTR *pKey);
	void prepend (DWORD_PTR new_key);
	void remove (DWORD_PTR Key);

	void reset () {	CurrOffset = 0xFFFFFFFF; };		// resets the list iterator
	DWORD entries () { return NumOfEntries; };		
													// returns the number of entries in the list
	void clear () { NumOfEntries = 0; HeadOffset = 0; CurrOffset = 0xFFFFFFFF; };
													// clears up the list. The list contains no values afterwards.
	BOOL isEmpty () { return ((NumOfEntries == 0) ? TRUE : FALSE); };

private:
	DWORD				NumOfEntries;	// current # of entries in the list
	DWORD				MaxEntries;		// max # of entries that the array can hold
	DWORD_PTR			*Entries;		// Circular array of entries
	DWORD				HeadOffset;		// Offset of the 1st entry in the circular array
	DWORD				CurrOffset;		// Iterator value

	BOOL Expand (void);
};

typedef SListClass * PSListClass;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\scfcall.h ===
/*    SCFCall.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class is instantiated to represent a call under the SCF.  
 *        Each call is identified by a call reference value.  This class
 *        sends and receives the packets necessary to negotiate a connection.
 *    
 *    Caveats:
 *
 *    Authors:
 *        James W. Lawwill
 */


#ifndef _SCFCall_H_
#define _SCFCall_H_

#include "q922.h"
#include "scf.h"

#define    SETUP_PACKET_SIZE                29
#define    CONNECT_PACKET_BASE_SIZE        8
#define    CONNECT_ACK_PACKET_SIZE            4
#define    RELEASE_COMPLETE_PACKET_SIZE    8

 /*
 **    A CallReference is a number that represents a network request.
 */
typedef    USHORT    CallReference;

 /*
 **    DataLink Parameters that can be negotiated by the SCF
 */
typedef struct
{
    USHORT    k_factor;
    USHORT    n201;
    USHORT    t200;
    USHORT    default_k_factor;
    USHORT    default_n201;
    USHORT    default_t200;
} DataLinkParameters;
typedef    DataLinkParameters *    PDataLinkParameters;

 /*
 **    Structure passed during Connect Callbacks
 */
typedef struct
{
    DLCI                dlci;
    TransportPriority    priority;
    CallReference        call_reference;
    PDataLinkParameters    datalink_struct;
}    NetworkConnectStruct;
typedef    NetworkConnectStruct    *    PNetworkConnectStruct;

 /*
 **    States that the call can be in
 */
typedef enum 
{
    NOT_CONNECTED,
    SETUP_SENT,
    CONNECT_SENT,
    CALL_ESTABLISHED
}    SCFCallState;


 /*
 **    Error values
 */
typedef enum 
{
    SCFCALL_NO_ERROR
}     SCFCallError;

class SCFCall : public IObject
{
public:

    SCFCall (
        CLayerSCF            *owner_object,
        IProtocolLayer *        lower_layer,
        USHORT                message_base,
        PDataLinkParameters   datalink_parameters,
        PMemoryManager        memory_manager,
        BOOL *            initialized);
    ~SCFCall (void);

         /*
         **    This routine gives us a slice of time to transmit packets
         */
        void                PollTransmitter (
                                USHORT    data_to_transmit,
                                USHORT *    pending_data);

         /*
         **    Link establishment
         */
        SCFCallError        ConnectRequest (
                                CallReference        call_reference,
                                DLCI                dlci,
                                TransportPriority    priority);
        SCFCallError        ConnectResponse (
                                BOOL    valid_dlci);
        SCFCallError        DisconnectRequest (void);

         /*
         **    Packet processing
         */
        BOOL            ProcessSetup (
                                CallReference    call_reference,
                                LPBYTE            packet_address,
                                USHORT            packet_length);
        BOOL            ProcessConnect (
                                LPBYTE    packet_address,
                                USHORT    packet_length);
        BOOL            ProcessConnectAcknowledge (
                                LPBYTE    packet_address,
                                USHORT    packet_length);
        BOOL            ProcessReleaseComplete (
                                LPBYTE    packet_address,
                                USHORT    packet_length);

    private:
        void            SendSetup (void);
        void            SendConnect (void);
        void            SendReleaseComplete (void);
        void            SendConnectAcknowledge (void);


        void            StartTimerT313 (void);
        void            StopTimerT313 (void);
        void            T313Timeout (
                            TimerEventHandle);
        void            StartTimerT303 (void);
        void            StopTimerT303 (void);
        void            T303Timeout (
                            TimerEventHandle);

        CLayerSCF           *m_pSCF;
        IProtocolLayer *        Lower_Layer;
        USHORT                m_nMsgBase;
        USHORT                Packet_Pending;
        BOOL            Link_Originator;
        DataLinkParameters    DataLink_Struct;
        USHORT                Maximum_Packet_Size;
        USHORT                Lower_Layer_Prepend;
        USHORT                Lower_Layer_Append;

        BOOL            Received_Priority;
        BOOL            Received_K_Factor;
        BOOL            Received_N201;
        BOOL            Received_T200;
        PMemoryManager        Data_Request_Memory_Manager;

        CallReference        Call_Reference;
        DLCI                DLC_Identifier;
        TransportPriority    Priority;
        TransportPriority    Default_Priority;

        SCFCallState        State;
        USHORT                Release_Cause;

        ULONG                T303_Timeout;
        TimerEventHandle    T303_Handle;
        BOOL            T303_Active;
        USHORT                T303_Count;

        ULONG                T313_Timeout;        
        TimerEventHandle    T313_Handle;
        BOOL            T313_Active;

};
typedef    SCFCall *        PSCFCall;

#endif


/*
 *    Documentation for Public class members
 */

/*    
 *    SCFCall::SCFCall (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                PChar                config_file,
 *                PDataLinkParameters    datalink_parameters,
 *                PMemoryManager        memory_manager,
 *                BOOL *            initialized);
 *
 *    Functional Description
 *        This is the constructor for the SCFCall class.
 *
 *    Formal Parameters
 *        transport_resources    (i)    -    Pointer to TransportResources structure.
 *        owner_object    (i)    -    Address of the owner object
 *        lower_layer        (i)    -    Address of our lower layer
 *        message_base    (i)    -    Message base used in owner callbacks
 *        config_file        (i)    -    Address of configuration file path
 *        datalink_parameters    (i)    -    Address of structure containing datalink
 *                                    parameters that will be arbitrated
 *        memory_manager    (i)    -    Address of memory manager
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    SCFCall::~SCFCall ();
 *
 *    Functional Description
 *        Destructor
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    void    SCFCall::PollTransmitter (
 *                        USHORT    data_to_transmit,
 *                        USHORT *    pending_data);
 *
 *    Functional Description
 *        This function gives the class a time slice to transmit data
 *
 *    Formal Parameters
 *        data_to_transmit    (i)    -    Flags representing data to transmit
 *        pending_data        (o)    -    Return flags of data transmitted
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    SCFCallError    SCFCall::ConnectRequest (
 *                                CallReference    call_reference,
 *                                DLCI            dlci,
 *                                USHORT            priority);
 *
 *    Functional Description
 *        This function informs us to initiate a connection with the remote
 *        SCF.  As a result of this, we send a SETUP packet to the remote
 *        machine
 *
 *    Formal Parameters
 *        call_reference        (i)    -    Unique value that differentiates our
 *                                    call from other calls.  This value goes in
 *                                    all Q.933 packets.
 *        dlci                (i)    -    Suggested dlci value.
 *        priority            (i)    -    Suggested priority in the range of 0 to 14.
 *                                    14 is the highest priority
 *
 *    Return Value
 *        SCFCALL_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    SCFCallError    SCFCall::ConnectResponse (
 *                                BOOL    valid_dlci);
 *
 *    Functional Description
 *        This function is called in response to a NETWORK_CONNECT_INDICATION
 *        callback to the owner of this object.  Previously, the remote site
 *        sent us a SETUP packet with a suggested DLCI.  This DLCI is sent to 
 *        the owner in the NETWORK_CONNECT_INDICATION call.  The owner calls
 *        this function with a BOOL, telling us if the DLCI was valid.
 *
 *    Formal Parameters
 *        valid_dlci        (i)    -    This is set to TRUE if the user wants to accept
 *                                this call and use the suggested DLCI, FALSE 
 *                                if not.
 *
 *    Return Value
 *        SCFCALL_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    SCFCallError    SCFCall::DisconnectRequest (
 *                                void);
 *
 *    Functional Description
 *        This function is called to release the call.  In response to this 
 *        function, we send out a RELEASE COMPLETE packet to the remote site.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        SCFCALL_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    BOOL    SCFCall::ProcessSetup (
 *                            CallReference    call_reference,
 *                            LPBYTE            packet_address,
 *                            USHORT            packet_length);
 *
 *    Functional Description
 *        This function is called when we have a SETUP packet to decode.
 *
 *    Formal Parameters
 *        call_reference    (i)    -    The call reference attached to the packet.
 *        packet_address    (i)    -    Address of the SETUP packet
 *        packet_length    (i)    -    Length of the passed in packet.
 *
 *    Return Value
 *        TRUE        -    Valid packet
 *        FALSE        -    The packet was not a valid Q.933 SETUP packet or
 *                        the packet was not expected
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    BOOL    SCFCall::ProcessConnect (
 *                            LPBYTE    packet_address,
 *                            USHORT    packet_length);
 *
 *    Functional Description
 *        This function is called when we have a CONNECT packet to decode.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of the CONNECT packet
 *        packet_length    (i)    -    Length of the passed in packet.
 *
 *    Return Value
 *        TRUE        -    Valid packet
 *        FALSE        -    The packet was not a valid Q.933 CONNECT packet or
 *                        the packet was not expected
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    BOOL    SCFCall::ProcessConnectAcknowledge (
 *                            LPBYTE    packet_address,
 *                            USHORT    packet_length);
 *
 *    Functional Description
 *        This function is called when we have a CONNECT ACK packet to decode.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of the CONNECT ACK packet
 *        packet_length    (i)    -    Length of the passed in packet.
 *
 *    Return Value
 *        TRUE        -    Valid packet
 *        FALSE        -    The packet was not a valid Q.933 CONNECT ACK packet
 *                        or the packet was not expected.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    BOOL    SCFCall::ProcessReleaseComplete (
 *                            LPBYTE    packet_address,
 *                            USHORT    packet_length);
 *
 *    Functional Description
 *        This function is called when we have a RELEASE COMPLETE packet to 
 *        decode.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of the CONNECT ACK packet
 *        packet_length    (i)    -    Length of the passed in packet.
 *
 *    Return Value
 *        TRUE        -    Valid packet
 *        FALSE        -    The packet was not a valid Q.933 CONNECT ACK packet
 *                        or the packet was not expected.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\slist2.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*	slist.cpp
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the implementation of a linked list data structure.
 *
 */


#define MyMalloc(size)	LocalAlloc (LMEM_FIXED, (size))
#define MyFree(ptr)		LocalFree ((HLOCAL) (ptr))
#define Max(a,b)		(((a) > (b)) ? (a) : (b))

/*  Function:  Constructor
 *
 *	Parameters:
 *		ltype:			List type
 *		num_of_items:	Size of the list's cache
 *
 *	Return value:
 *		None
 */

SListClass::SListClass (DWORD num_of_items)
{

	MaxEntries = Max (num_of_items, DEFAULT_NUMBER_OF_ITEMS);

	// Allocate the block of items (which, hopefully, will be the last one)
	Entries = (DWORD_PTR *) MyMalloc (MaxEntries * sizeof (DWORD_PTR));

	// Initialize the private member variables
	NumOfEntries = 0;
	HeadOffset = 0;
	CurrOffset = 0xFFFFFFFF;

}


/*  Function:  Destructor
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		None
 *
 */

SListClass::~SListClass (void)
{
	if (Entries != NULL)
		MyFree (Entries);
}


/*  Function:  Expand
 *		This private member function, expands the storage array of a list.  It doubles its size.
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		TRUE, if the expansion was successful.  FALSE, otherwise.
 *
 */

BOOL SListClass::Expand (void)
{
	DWORD_PTR	*OldEntries;	// Keeps a copy of the old array of values.
	DWORD		 dwTemp;		// Temporary DWORD value

	if (Entries == NULL) {
		// the list is empty; we try to allocate space anyway.
		Entries = (DWORD_PTR *) MyMalloc (MaxEntries * sizeof (DWORD_PTR));
		if (Entries == NULL)
			return FALSE;
		return TRUE;
	}
		
	ASSERT (Entries != NULL);

	// The current array of entries is full, so we need to allocate a bigger one
	// The new array has twice the size of the old one
	OldEntries = Entries;
	Entries = (DWORD_PTR *) MyMalloc ((MaxEntries << 1) * sizeof (DWORD_PTR));
	if (Entries == NULL) {
		// we failed; we have to return
		Entries = OldEntries;
		return FALSE;
	}

	// copy the old entries into the new array, starting from the beginning
	dwTemp = MaxEntries - HeadOffset;
	memcpy ((void *) Entries, (void *) (OldEntries + HeadOffset), dwTemp * sizeof (DWORD));
	memcpy ((void *) (Entries + dwTemp), (void *) OldEntries, HeadOffset * sizeof (DWORD));

	// Free the old array of entries
	MyFree (OldEntries);

	// Set the instance variables
	MaxEntries <<= 1;
	HeadOffset = 0;
	return TRUE;
}


/*  Function:  append
 *		Inserts a value at the end of a list.
 *
 *	Parameters:
 *		new_key:	The new value that has to be inserted in the list
 *
 *	Return value:
 *		None.
 *
 */


void SListClass::append (DWORD_PTR new_key)
{
	DWORD_PTR		dwTemp;

	if (Entries == NULL || NumOfEntries >= MaxEntries)
		if (! Expand ())
			return;

	ASSERT (Entries != NULL);
	ASSERT (NumOfEntries < MaxEntries);

	dwTemp = HeadOffset + (NumOfEntries++);
	if (dwTemp >= MaxEntries)
		dwTemp -= MaxEntries;
	Entries[dwTemp] = new_key;
}


/*  Function:  prepend
 *		Inserts a value at the beginning of a list.
 *
 *	Parameters:
 *		new_key:	The new value that has to be inserted in the list
 *
 *	Return value:
 *		None.
 *
 */

void SListClass::prepend (DWORD_PTR new_key)
{
	if (Entries == NULL || NumOfEntries >= MaxEntries)
		if (! Expand ())
			return;

	ASSERT (Entries != NULL);
	ASSERT (NumOfEntries < MaxEntries);

	NumOfEntries++;
	if (HeadOffset == 0)
		HeadOffset = MaxEntries - 1;
	else
		HeadOffset--;
	Entries[HeadOffset] = new_key;
}


/*  Function:  find
 *		Looks up a value in a DWORD_LIST list.
 *
 *	Parameters:
 *		Key:	The value to look up
 *
 *	Return value:
 *		TRUE, if "Key" is found in the list. FALSE, otherwise.
 *
 */

BOOL SListClass::find (DWORD_PTR Key)
{
	DWORD	i;
	DWORD_PTR *pItem;	// Goes through the items in the list.

	for (i = 0, pItem = Entries + HeadOffset; i < NumOfEntries; i++) {
		if (Key == *pItem)
			return TRUE;

		// Advance the "pItem" pointer
		if ((DWORD) (++pItem - Entries) >= MaxEntries)
			pItem = Entries;
	}
	return FALSE;
}


/*  Function:  read
 *		Reads an item from the list. The list item is not removed from the list.
 *
 *	Parameters:
 *		index:	Index of the item to be read. 0 is the index of the 1st list item.
 *				NumOfEntries - 1 is the last valid index.
 *
 *	Return value:
 *		The value at the index-th entry in the list. If the index is invalid, 0.
 *
 */

DWORD_PTR SListClass::read (DWORD index)
{
	DWORD	dwTemp;

	if (index >= NumOfEntries)
		return 0;

	dwTemp = HeadOffset + index;
	if (dwTemp >= MaxEntries)
		dwTemp -= MaxEntries;

	return (Entries[dwTemp]);
}


/*  Function:  remove
 *		Removes a value from the list
 *
 *	Parameters:
 *		Key:	The value that has to be removed from the DWORD_LIST list
 *
 *	Return value:
 *		None.
 *
 */

void SListClass::remove (DWORD_PTR Key)
{
	DWORD	i, dwTemp;
	DWORD_PTR *pItem;		// Goes through the list items

	for (i = 0, pItem = Entries + HeadOffset; i < NumOfEntries; i++) {
		if (Key == *pItem) {
			// we found the "Key"; to remove it, we move the last value into its place.
			dwTemp = HeadOffset + (--NumOfEntries);
			if (dwTemp >= MaxEntries)
				dwTemp -= MaxEntries;
			*pItem = Entries[dwTemp];
			return;
		}

		// Advance the "pItem" pointer
		if ((DWORD) (++pItem - Entries) >= MaxEntries)
			pItem = Entries;	
	}
}


/*  Function:  get
 *		Reads and removes the 1st item from the list.
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		The value at the 1st entry in the list. If the list is empty, 0.
 *
 */

DWORD_PTR SListClass::get (void)
{
	DWORD_PTR	return_value = 0;

	if (NumOfEntries > 0) {
		return_value = Entries[HeadOffset];
		NumOfEntries--;
		if (++HeadOffset >= MaxEntries)
			HeadOffset = 0;
	}
	return return_value;
}


/*  Function:  removeLast
 *		Reads and removes the last item from the list
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		The value at the last entry in the list. If the list is empty, 0.
 *
 */

DWORD_PTR SListClass::removeLast (void)
{
	DWORD_PTR	return_value = 0;
	DWORD	dwTemp;

	if (NumOfEntries > 0) {
		dwTemp = HeadOffset + (--NumOfEntries);
		if (dwTemp >= MaxEntries)
			dwTemp -= MaxEntries;
		return_value = Entries[dwTemp];
	}
	return return_value;
}


/* Function:  iterate
 *		Iterates through the items of a list.  It remembers where it has
 *		stopped during the last call and starts from there.
 *
 * Parameters
 *		pKey:	Pointer to DWORD or unsigned short value to receive the next item's value.
 *				It can be NULL.
 *
 * Return value:
 *		FALSE, when we reach the end of the dictionary
 *		TRUE, otherwise.  Then, *pKey is valid
 *
 */

BOOL SListClass::iterate (DWORD_PTR *pKey)
{
	DWORD		dwTemp;

	if (NumOfEntries <= 0)
		return FALSE;

	if (CurrOffset == 0xFFFFFFFF) {
		// start from the beginning
		CurrOffset = 0;
	}
	else {
		if (++CurrOffset >= NumOfEntries) {
			// reset the iterator
			CurrOffset = 0xFFFFFFFF;
			return FALSE;
		}
	}

	dwTemp = CurrOffset + HeadOffset;
	if (dwTemp >= MaxEntries)
		dwTemp -= MaxEntries;

	*pKey = Entries[dwTemp];
	
	return TRUE;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\t123.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    T123.cpp
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the T123 class.
 *
 *        Beware::
 *            When we refer to a Transport in this class, we are
 *            talking about X224/Class 0.
 *
 *            When we refer to a DataLink in this class, we are
 *            talking about the Q922 Layer.
 *
 *    Private Instance Variables:
 *        Logical_Connection_List    -    This list uses the logical_handle as the
 *                                key and a DLCI as the value.  From the DLCI we
 *                                can determine the specifics about the logical
 *                                connection
 *        DLCI_List            -    This list uses a DLCI as the key and a
 *                                DLCIStruct as the value.  The DLCIStruct holds
 *                                all of the important information about the
 *                                DLCI connection
 *        Message_List        -    List used to hold owner callback information
 *                                that can not be processed immediately.
 *        DataLink_List        -    This is a list of all the DataLink connections.
 *                                We keep a seperate list so that during the
 *                                PollTransmitter() call, we can round-robin thru
 *                                the list, giving each DataLink a chance to
 *                                transmit.
 *        Transport_Priority_List-    This is a prioritized list of DLCIs
 *                                    During PollTransmitter() we    process the
 *                                    logical connections in priority order.
 *
 *        m_pController        -    Address of the owner object
 *        Link_Originator        -    TRUE if we originated the physical connection
 *        m_nMsgBase        -    Message base used in the owner callback.
 *        Identifier            -    Identifier to be passed back in the owner
 *                                callback
 *        m_pSCF        -    Address of the network layer associated with
 *                                this T123 stack.
 *        m_pQ922        -    Address of DataLink Layer associated with the
 *                                Network Layer (DLCI 0).
 *        m_pMultiplexer    -    Address of Multiplexer layer
 *        m_pComPort        -    Address of physical layer
 *        m_hCommLink        -    Physical handle used to access the physical
 *                                layer.
 *        DataLink_Struct        -    Holds default Q922 values.
 *        Data_Request_Memory_Manager    -    Holds the memory manager for the DLCI0
 *                                DataLink.
 *        Random                -    Random number generator
 *        Disconnect_Requested-    TRUE, if the user has requested that the
 *                                complete stack be taken down.
 *
 *
 *    Caveats:
 *        None
 *
 *    Author:
 *        James W. Lawwill
 */
#include "t123.h"
#include "pstnfram.h"
#include "crc.h"

#define    PSTN_DATALINK_MAX_OUTSTANDING_BYTES    1024
#define    TRANSPORT_DEFAULT_PDU_SIZE            128
#define    DEFAULT_PSTN_N201                     260
#define    TRANSPORT_MAXIMUM_USER_DATA_SIZE    256
#define    NETWORK_RETRIES                        20
#define    NUMBER_8K_BLOCKS                    1
#define    NUMBER_64_BYTE_BLOCKS                64
#define    DEFAULT_MAXIMUM_OUTSTANDING_PACKETS    20
#define DEFAULT_T200_TIMEOUT                3000
#define DEFAULT_T200_COMM_TIMEOUT            500


/*
 *    T123::T123 (
 *            PTransportResources    transport_resources,
 *            IObject *                owner_object,
 *            USHORT                message_base,
 *            BOOL                link_originator,
 *            IProtocolLayer *        physical_layer,
 *            PhysicalHandle        physical_handle,
 *            BOOL *                t123_initialized)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the T123 constructor.  It instantiates the multiplexer.
 */
T123::T123
(
    TransportController    *owner_object,
    USHORT                  message_base,
    BOOL                    link_originator,
    ComPort                *comport, // physical layer
    PhysicalHandle          hCommLink, // physical handle
    PLUGXPRT_PARAMETERS    *pParams,
    BOOL *                  t123_initialized
)
:
    Logical_Connection_List (TRANSPORT_HASHING_BUCKETS),
    DLCI_List (TRANSPORT_HASHING_BUCKETS),
    DataLink_List (),
    m_pController(owner_object),
    m_nMsgBase(message_base),
    m_hCommLink(hCommLink),
    m_pComPort(comport)
{
    TRACE_OUT(("T123::T123"));

    PPacketFrame    framer;
    PCRC            crc;
    BOOL            initialized;
    DWORD            i;

    // SDK parameters
    if (NULL != pParams)
    {
        m_fValidSDKParams = TRUE;
        m_SDKParams = *pParams;
    }
    else
    {
        m_fValidSDKParams = FALSE;
        ::ZeroMemory(&m_SDKParams, sizeof(m_SDKParams));
    }

    // initialize priority list
    for (i = 0; i < NUMBER_OF_PRIORITIES; i++)
    {
        DBG_SAVE_FILE_LINE
        Logical_Connection_Priority_List[i] = new SListClass;
    }

    Link_Originator = link_originator;
    Disconnect_Requested = FALSE;

    m_pSCF = NULL;
    m_pQ922 = NULL;
    Data_Request_Memory_Manager = NULL;
    m_pMultiplexer = NULL;
    *t123_initialized = TRUE;

    DataLink_Struct.default_k_factor = DEFAULT_MAXIMUM_OUTSTANDING_PACKETS;
    DataLink_Struct.default_n201 = DEFAULT_PSTN_N201;
    ULONG baud_rate = m_pComPort->GetBaudRate();
    DataLink_Struct.default_t200 = ((m_pComPort->GetCallControlType() == PLUGXPRT_PSTN_CALL_CONTROL_MANUAL) ?
                                    ((baud_rate  < CBR_2400 ) ?
                                    DEFAULT_T200_COMM_TIMEOUT << 4 : DEFAULT_T200_COMM_TIMEOUT ): DEFAULT_T200_TIMEOUT);

    TRACE_OUT(("T123: Defaults: k = %d  n201 = %d  t200 = %d",
        DataLink_Struct.default_k_factor,
        DataLink_Struct.default_n201,
        DataLink_Struct.default_t200));

    DataLink_Struct.k_factor = DEFAULT_MAXIMUM_OUTSTANDING_PACKETS;
    DataLink_Struct.n201 =     DEFAULT_PSTN_N201;
    DataLink_Struct.t200 =     DataLink_Struct.default_t200;

     /*
     **    Create the CRC object and pass it to the Multiplexer.
     **    Create a framer and send it to the Multiplexer.
     */
    DBG_SAVE_FILE_LINE
    crc = new CRC ();
    if (crc != NULL)
    {
        DBG_SAVE_FILE_LINE
        framer = (PPacketFrame) new PSTNFrame ();
        if (framer != NULL)
        {
            DBG_SAVE_FILE_LINE
            m_pMultiplexer = new Multiplexer(
                                        this,
                                        m_pComPort,
                                        m_hCommLink,
                                        MULTIPLEXER_LAYER_MESSAGE_BASE,
                                        framer,
                                        crc,
                                        &initialized);
            if (m_pMultiplexer != NULL && initialized)
            {
                 /*
                 **    Notify the Multiplexer layer to start a connection
                 */
                m_pMultiplexer->ConnectRequest();
            }
            else
            {
                 /*
                 **    To get here, either the m_pMultiplexer == NULL or
                 **    initialized == FALSE
                 */
                if (m_pMultiplexer != NULL)
                {
                    delete m_pMultiplexer;
                    m_pMultiplexer = NULL;
                }
                else
                {
                    delete crc;
                    delete framer;
                }
                *t123_initialized = FALSE;
            }
        }
        else
        {
            delete crc;
            *t123_initialized = FALSE;
        }
    }
    else
    {
        *t123_initialized = FALSE;
    }
}


/*
 *    T123::~T123 (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the destructor for the T123 object.  It releases all memory
 */
T123::~T123 (void)
{
    TRACE_OUT(("T123::~T123"));

    DWORD            i;

     /*
     **    Reset deletes all DataLink, Network, and Transport objects associated
     **    with this stack.
     */
    Reset ();

     /*
     **    Go thru the Message list and delete all passive owner callback messages
     */
    while (Message_List.isEmpty () == FALSE)
    {
        delete (PMessageStruct) Message_List.get ();
    }

     /*
     **    Delete the multiplexer layer
     */
    delete m_pMultiplexer;

    TRACE_OUT(("T123: Destructor"));

    for (i = 0; i < NUMBER_OF_PRIORITIES; i++)
        delete Logical_Connection_Priority_List[i];
}


/*
 *    TransportError    T123::ConnectRequest (
 *                            LogicalHandle        logical_handle,
 *                            TransportPriority    priority)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the function that initiates a logical connection with the
 *        remote site.
 */
TransportError    T123::ConnectRequest (
                        LogicalHandle        logical_handle,
                        TransportPriority    priority)
{
    TRACE_OUT(("T123::ConnectRequest"));

    PDLCIStruct        dlci_struct;
    DLCI            dlci;
    SCFError        network_error;
    TransportError    transport_error = TRANSPORT_NO_ERROR;

     /*
     **    Get a proposed DLCI for the connection
     */
    dlci = GetNextDLCI ();

     /*
     **    Add the new connection to the Logical_Connection_List
     */
    Logical_Connection_List.insert (logical_handle, (DWORD) dlci);

     /*
     **    Add the proposed DLCI to the DLCI_List
     **    Initialize all of the items in the DLCI structure
     */
    DBG_SAVE_FILE_LINE
    dlci_struct = new DLCIStruct;
    if (dlci_struct != NULL)
    {
        DLCI_List.insert ((DWORD_PTR) dlci, (DWORD_PTR) dlci_struct);
        dlci_struct -> link_originator = TRUE;
        dlci_struct -> x224 = NULL;  // X.224
        dlci_struct -> q922 = NULL; // Q.922
        dlci_struct -> priority = priority;
        dlci_struct -> connect_requested = FALSE;
        dlci_struct -> disconnect_requested = FALSE;
        dlci_struct -> data_request_memory_manager = NULL;
        dlci_struct -> network_retries = 0;
    }
    else
    {
         /*
         **    Remove this entry and send a message to the owner
         */
        NetworkDisconnectIndication (dlci, TRUE, FALSE);
        return (TRANSPORT_MEMORY_FAILURE);
    }

     /*
     **    If the Network Layer exists, issue a connect request
     **
     **    If the Network Layer does not exist yet, the connection will be
     **    requested at a later time.
     */
    if (m_pSCF != NULL)
    {
         /*
         **    Mark this DLCI as already submitting its ConnectRequest()
         */
        dlci_struct -> connect_requested = TRUE;
        network_error = m_pSCF->ConnectRequest(dlci, priority);
        if (network_error != SCF_NO_ERROR)
        {
             /*
             **    Remove this entry and send a message to the owner
             */
            NetworkDisconnectIndication (dlci, TRUE, FALSE);

            if (network_error == SCF_MEMORY_ALLOCATION_ERROR)
                return (TRANSPORT_MEMORY_FAILURE);
            else
                return (TRANSPORT_CONNECT_REQUEST_FAILED);
        }
    }

     /*
     **    Process any passive owner callbacks that may have occured
     */
    ProcessMessages ();

    return (transport_error);
}


/*
 *    TransportError    T123::ConnectResponse (
 *                            LogicalHandle    logical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called in response to TPRT_CONNECT_INDICATION that we
 *        issued to the controller.  By making this call, the controller is
 *        accepting the incoming call.
 */
TransportError    T123::ConnectResponse (
                        LogicalHandle    logical_handle)
{
    TRACE_OUT(("T123::ConnectResponse"));

    PDLCIStruct            dlci_struct;
    TransportError        return_value;
    DWORD_PTR             dwTempDLCI;

     /*
     **    Verify that this connection exists and is ready for data
     */
    if (Logical_Connection_List.find (logical_handle, &dwTempDLCI) == FALSE)
        return (TRANSPORT_NO_SUCH_CONNECTION);

     /*
     **    Get the Transport address from the DLCI_List and relay the call
     */
    DLCI_List.find (dwTempDLCI, (PDWORD_PTR) &dlci_struct);
    if (dlci_struct->x224 != NULL)
        return_value = dlci_struct->x224->ConnectResponse();
    else
        return_value = TRANSPORT_CONNECT_REQUEST_FAILED;

     /*
     **    Process any passive owner callbacks that may have been received
     */
    ProcessMessages ();
    return (return_value);
}


/*
 *    TransportError    T123::DisconnectRequest (
 *                            LogicalHandle    logical_handle,
 *                            BOOL            trash_packets)
 *
 *    Public
 *
 *    Functional Description:
 *        This function terminates the user's logical connection.
 */
TransportError    T123::DisconnectRequest (
                        LogicalHandle    logical_handle,
                        UINT_PTR            trash_packets)
{
    TRACE_OUT(("T123::DisconnectRequest"));

    Short        priority;
    DLCI        dlci;
    PDLCIStruct    dlci_struct;
    DWORD_PTR    dw_dlci;

    TRACE_OUT(("T123: DisconnectRequest: logical_handle = %d", logical_handle));

     /*
     **    If the logical_handle == INVALID_LOGICAL_HANDLE, the user is
     **    telling us to disconnect all logical connections including DLCI 0.
     */
    if (logical_handle == INVALID_LOGICAL_HANDLE)
    {
        Disconnect_Requested = TRUE;

        if (m_pQ922 != NULL)
            m_pQ922->ReleaseRequest();
        else
        {
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                INVALID_LOGICAL_HANDLE,
                                m_hCommLink,
                                &Disconnect_Requested);
        }

         /*
         **    For each priority level, clear the Priority list
         */
        for (priority=(NUMBER_OF_PRIORITIES - 1); priority>=0; priority--)
            Logical_Connection_Priority_List[priority]->clear ();

         /*
         **    Clear the Logical_Connection_List and DataLink_List
         */
        Logical_Connection_List.clear ();
        DataLink_List.clear ();

         /*
         **    Go thru each Transport and DataLink layer (excluding DLCI 0) and
         **    delete them.  Delete the DLCIStruct.  Finally, clear the list.
         */
        DLCI_List.reset();
        while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct))
        {
            delete dlci_struct -> x224;
            if (dlci_struct -> q922 != NULL)
            {
                delete dlci_struct -> q922;
                delete dlci_struct -> data_request_memory_manager;
            }
            delete dlci_struct;
        }
        DLCI_List.clear ();
        return (TRANSPORT_NO_ERROR);
    }

     /*
     **    Start breaking down the link from the Transport Layer down
     */
    if (Logical_Connection_List.find (logical_handle, &dw_dlci) == FALSE)
        return (TRANSPORT_NO_SUCH_CONNECTION);

    DLCI_List.find (dw_dlci, (PDWORD_PTR) &dlci_struct);
    dlci = (DLCI) dw_dlci;

     /*
     **    It is illegal for the user to ask us to preserve the user data when
     **    a Transport Layer doesn't even exist yet.
     */
    if ((trash_packets == FALSE) && ((dlci_struct -> x224) == NULL))
    {
        trash_packets = TRUE;
    }

    if (trash_packets)
    {
         /*
         **    If the Transport object exists, delete it and remove it from our
         **    lists.  It is no longer valid.
         */
        if ((dlci_struct -> x224) != NULL)
        {
            delete dlci_struct -> x224;
            dlci_struct -> x224 = NULL;
            Logical_Connection_Priority_List[dlci_struct->priority]->remove (dlci);
        }

         /*
         **    If the DataLink object exists, delete it and remove it from our
         **    lists.  It is no longer valid.
         */
        if (dlci_struct -> q922 != NULL)
        {
            delete dlci_struct -> q922;
            delete dlci_struct -> data_request_memory_manager;
            dlci_struct -> data_request_memory_manager = NULL;
            dlci_struct -> q922 = NULL;
            DataLink_List.remove (dlci);
        }

         /*
         **    If the Network Layer exists, issue a disconnect
         **
         **    The Logical Connection has been removed from every list except the
         **    Logical_Connection_List and the DLCI_List.  When we get the
         **    NETWORK_DISCONNECT_INDICATION from the Network layer, we will
         **    complete this operation.
         */
        if (m_pSCF != NULL)
        {
            m_pSCF->DisconnectRequest(dlci);
        }
        else
        {
             /*
             **    If the Network Layer does not exist yet, remove the logical
             **    connection from our Transport List and from the DLCI_List
             */
            Logical_Connection_List.remove (logical_handle);
            delete dlci_struct;
            DLCI_List.remove (dw_dlci);
        }
    }
    else
    {
         /*
         **    This mode requires us to terminate the connection after all user
         **    data has been successfully sent to the remote side.
         */
        if ((dlci_struct != NULL) && (dlci_struct -> x224 != NULL))
        {
            dlci_struct->x224->ShutdownReceiver ();
            dlci_struct->x224->ShutdownTransmitter ();
            dlci_struct->disconnect_requested = TRUE;
        }
    }

    return (TRANSPORT_NO_ERROR);
}


/*
 *    TransportError    T123::DataRequest (
 *                            LogicalHandle    logical_handle,
 *                            LPBYTE            user_data,
 *                            ULONG            user_data_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is used to send a data packet to the remote site.
 */
TransportError    T123::DataRequest (
                        LogicalHandle    logical_handle,
                        LPBYTE            user_data,
                        ULONG            user_data_length)
{
    TRACE_OUT(("T123::DataRequest"));

    CLayerX224         *x224;
    ULONG               bytes_accepted;
    PDLCIStruct         dlci_struct;
    DWORD_PTR           dw_dlci;
    TransportError      return_value;

     /*
     **    Verify that this connection exists and is ready for data
     */
    if (Logical_Connection_List.find (logical_handle, &dw_dlci) == FALSE)
        return (TRANSPORT_NO_SUCH_CONNECTION);

     /*
     **    Get the DLCI structure associated with this logical connection
     */
    DLCI_List.find (dw_dlci, (PDWORD_PTR) &dlci_struct);

     /*
     **    Attempt to send that data to the Transport Layer
     */
    x224 = dlci_struct -> x224;
    if (x224 == NULL)
        return (TRANSPORT_NOT_READY_TO_TRANSMIT);

     /*
     **    Pass the data to the Transport object for transmission
     */
    return_value =  x224 -> DataRequest (
                            0, user_data, user_data_length, &bytes_accepted);

     /*
     **    If it didn't accept the packet, its buffers must be full
     */
    if (bytes_accepted != user_data_length)
        return_value = TRANSPORT_WRITE_QUEUE_FULL;

    return (return_value);
}


/*
 *    void    T123::EnableReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function enables the receiver so that packets can be passed to the
 *        user application.
 */
void T123::EnableReceiver (void)
{
    TRACE_OUT(("T123::EnableReceiver"));

    PDLCIStruct        dlci_struct;

    DLCI_List.reset();
    while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct))
    {
        if (dlci_struct->x224 != NULL)
        {
            dlci_struct->x224->EnableReceiver ();
        }
    }

    return;
}


/*
 *    TransportError    T123::PurgeRequest (
 *                            LogicalHandle    logical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function notifies the X224 layer to purge all outbound packets.
 */
TransportError    T123::PurgeRequest (
                        LogicalHandle    logical_handle)
{
    TRACE_OUT(("T123::PurgeRequest"));

    DWORD_PTR      dw_dlci;
    PDLCIStruct    dlci_struct;

     /*
     **    Verify that this connection exists and is ready for data
     */
    if (Logical_Connection_List.find (logical_handle, &dw_dlci) == FALSE)
        return (TRANSPORT_NO_SUCH_CONNECTION);

     /*
     **    Get the DLCI structure associated with this logical connection
     */
    DLCI_List.find (dw_dlci, (PDWORD_PTR) &dlci_struct);

     /*
     **    If the Transport layer == NULL, the stack is not completely up yet
     */
    if ((dlci_struct -> x224) == NULL)
        return (TRANSPORT_NOT_READY_TO_TRANSMIT);

    dlci_struct->x224->PurgeRequest ();

    return (TRANSPORT_NO_ERROR);
}


/*
 *    void    T123::PollReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function gives each of the layers a chance to process incoming
 *        data and pass it to their higher layers.
 *
 *        We start this process by calling the higher layers first so that they
 *        can empty buffers that the lower layers may need.
 */
ULONG T123::PollReceiver (void)
{
    // TRACE_OUT(("T123::PollReceiver"));

    PDLCIStruct            dlci_struct;
    IProtocolLayer *        protocol_layer;
    ULONG                return_error = FALSE;

    if (m_pSCF != NULL)
    {
        m_pSCF->PollReceiver();
    }

    if (m_pQ922 != NULL)
    {
        m_pQ922->PollReceiver();
    }

     /*
     **    Go through each of the Transport and Datalink layers and give them
     **    a chance to pass data up the line
     */
    DLCI_List.reset();
    while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct))
    {
        protocol_layer = dlci_struct -> x224;
        if (protocol_layer != NULL)
            protocol_layer -> PollReceiver();

        protocol_layer = dlci_struct -> q922;
        if (protocol_layer != NULL)
            protocol_layer -> PollReceiver();
    }

    if (m_pMultiplexer != NULL)
    {
        m_pMultiplexer->PollReceiver();
    }

     /*
     **    The Physical Layer is the only layer that has a handle associated
     **    with it.
     */
    if (m_pComPort != NULL)
    {
        if (m_pComPort->PollReceiver() == PROTOCOL_LAYER_ERROR)
        {
            return_error = PROTOCOL_LAYER_ERROR;
        }
    }


     /*
     **    Go back through the Transport layers and allow them to issue
     **    TRANSPORT_BUFFER_AVAILABLE_INDICATIONs to the user.  This will refill
     **    the input buffers.
     */
    DLCI_List.reset ();
    while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct))
    {
        if (dlci_struct -> x224 != NULL)
            (dlci_struct -> x224) -> CheckUserBuffers ();
    }

     /*
     **    Process any passive owner callbacks that may have come in
     */
    ProcessMessages ();
    return(return_error);
}


/*
 *    void    T123::PollTransmitter (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function gives each of the layers a chance to transmit data
 *
 *        We poll the transmitters in reverse order from the PollReceiver() call.
 *        We start at the lower layers and let them empty their buffers before we
 *        go to the higher layers.  This should give the higher layers a better
 *        opportunity to get their packets sent down.
 *
 *        We treat the DataLink layers differently than all other layers.  They
 *        must send out control and user data.  If they don't get a chance to
 *        send out their control data, the remote side will eventually hangup on
 *        them.  Therefore we give each DataLink layer a chance to send its
 *        control data before any DataLink can send out user data.  The only
 *        exception to this is the DataLink 0 (DLCI 0).  It actaully sends out
 *        very little user data.A
 *
 *        After all of the control data is sent out, we go thru the Datalink
 *        Layers based on the priority given to the Transport Layer.  Higher
 *        priority Transport Layers get to send their data out first.  If there
 *        any room left, the lower layers get to send their data.  We round-robin
 *        thru the Transports of equal priority
 */
void T123::PollTransmitter (void)
{
    // TRACE_OUT(("T123::PollTransmitter"));

    PDLCIStruct        dlci_struct;
    DWORD_PTR          dlci;
    IProtocolLayer *    protocol_layer;

    USHORT            data_to_transmit;
    USHORT            data_pending;
    USHORT            datalink_data_to_transmit;
    USHORT            datalink_data_pending;
    USHORT            holding_data;
    Short            priority;

     /*
     **    Since we are going to call the Physical and Multiplexer layers, set
     **    the data_to_transmit to both types of data
     */
    data_to_transmit = PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA;
    datalink_data_to_transmit = PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA;

    if (m_pComPort != NULL)
    {
        m_pComPort->PollTransmitter(
                            (ULONG_PTR) m_hCommLink,
                            data_to_transmit,
                            &data_pending,
                            &holding_data);
    }

    if (m_pMultiplexer != NULL)
    {
        m_pMultiplexer->PollTransmitter(
                                0,
                                data_to_transmit,
                                &data_pending,
                                &holding_data);
    }

     /*
     **    The SCF Datalink Layer is the highest priority
     */
    if (m_pQ922 != NULL)
    {
        m_pQ922->PollTransmitter(
                            0,
                            datalink_data_to_transmit,
                            &datalink_data_pending,
                            &holding_data);

         /*
         **    If this DataLink returns and still has data that needs to go out,
         **    we won't let the other DataLinks transmit any data at all.
         */
        if ((datalink_data_pending & PROTOCOL_USER_DATA) ||
            (datalink_data_pending & PROTOCOL_CONTROL_DATA))
                datalink_data_to_transmit = 0;
    }

    if (m_pSCF != NULL)
    {
        m_pSCF->PollTransmitter(
                            0,
                            data_to_transmit,
                            &data_pending,
                            &holding_data);
        if (data_pending & PROTOCOL_USER_DATA)
            datalink_data_to_transmit = PROTOCOL_CONTROL_DATA;
    }

     /*
     **    Go thru each of the DataLinks giving them a chance to send out control
     **    data.  At the end of the iterator, we take the first entry and put it
     **    at the end of the list.  This gives all DataLinks a chance to send out
     **    control data.  This does not guarantee that each DataLink will get
     **    equal treatment.
     */
    if (datalink_data_to_transmit & PROTOCOL_CONTROL_DATA)
    {
         /*
         **    Go through the DataLink layers to transmit control
         */
        DataLink_List.reset();
        while (DataLink_List.iterate (&dlci))
        {
            DLCI_List.find (dlci, (PDWORD_PTR) &dlci_struct);
            dlci_struct->q922->PollTransmitter(0,
                                               PROTOCOL_CONTROL_DATA,
                                               &datalink_data_pending,
                                               &holding_data);
            if (datalink_data_pending & PROTOCOL_CONTROL_DATA)
                datalink_data_to_transmit = PROTOCOL_CONTROL_DATA;
        }

        if (DataLink_List.entries() > 1)
        {
            DataLink_List.append (DataLink_List.get ());
        }
    }

     /*
     **    Go thru each of the priorities, Issuing PollTransmitter() calls.
     **
     **    This loop allows the DataLink and Transport to send out User or
     **    Control data.
     */
    if (datalink_data_to_transmit & PROTOCOL_USER_DATA)
    {
        for (priority=(NUMBER_OF_PRIORITIES - 1); priority>=0; priority--)
        {
            if (Logical_Connection_Priority_List[priority]->isEmpty ())
                continue;

             /*
             **    Go thru each priority level
             */
            Logical_Connection_Priority_List[priority]->reset();
            while (Logical_Connection_Priority_List[priority]->iterate (&dlci))
            {
                DLCI_List.find (dlci, (PDWORD_PTR) &dlci_struct);

                protocol_layer = dlci_struct -> x224;
                if (protocol_layer == NULL)
                    continue;

                 /*
                 **    Allow the DataLink to transmit first, followed by the
                 **    Transport
                 */
                dlci_struct->q922->PollTransmitter(
                                    0,
                                    PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA,
                                    &datalink_data_pending,
                                    &holding_data);

                protocol_layer -> PollTransmitter (
                                    0,
                                    PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA,
                                    &data_pending,
                                    &holding_data);

                 /*
                 **    The Disconnect_Requested flag is set to TRUE if someone
                 **    wants to break the TC but transmit all data in the queue
                 */
                if ((dlci_struct -> disconnect_requested))
                {
                     /*
                     **    Re-call the DataLink layer to see if the Transport
                     **    layer put any data in it to be transmitted.
                     */
                    dlci_struct->q922->PollTransmitter(
                                    0,
                                    PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA,
                                    &datalink_data_pending,
                                    &holding_data);

                     /*
                     **    If the DataLink layer has no data to transmit and it
                     **    is not holding any packets to be acknowledged,
                     **    disconnect the TC.
                     */
                    if ((datalink_data_pending == 0) && (holding_data == 0))
                    {
                        dlci_struct -> disconnect_requested = FALSE;
                        m_pSCF->DisconnectRequest ((DLCI) dlci);
                    }
                }

            }
             /*
             **    Change the order of the list at this priority level
             */
            Logical_Connection_Priority_List[priority]->append (
                                            Logical_Connection_Priority_List[priority]->get ());
        }
    }

     /*
     **    Process any passive owner callbacks
     */
    ProcessMessages ();
}


/*
 *    ULONG    T123::OwnerCallback (
 *                    USHORT    message,
 *                    ULONG    parameter1,
 *                    ULONG    parameter2,
 *                    PVoid    parameter3)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the owner callback function.  Layers owned by this layer can
 *        issue an owner callback to this object when a significant event occurs.
 */
ULONG T123::OwnerCallback
(
    ULONG       layer_message,
    void       *parameter1,
    void       *parameter2,
    void       *parameter3
)
{
    TRACE_OUT(("T123::OwnerCallback"));

    ULONG           message;
    PMessageStruct  passive_message;
    ULONG           return_value = 0;

    message = layer_message & MESSAGE_MASK;

    switch (message)
    {
    case NETWORK_CONNECT_INDICATION:
         /*
         **    This message comes from the Network Layer when the remote site
         **    has requested a logical connection.
         **
         **    We will check the requested dlci to make sure it is valid.
         **    We will make a ConnectResponse() call to the Network layer to
         **    let it know.
         */
        NetworkConnectIndication ((PNetworkConnectStruct) parameter3);
        break;

    case NETWORK_CONNECT_CONFIRM:
         /*
         **    This message is issued from the Network Layer.  The
         **    ConnectRequest() call we made to the layer has resulted in
         **    a new DLCI (permission to create a new logical connection)
         */
        NetworkConnectConfirm ((PNetworkConnectStruct) parameter3);
        break;

    case DATALINK_ESTABLISH_CONFIRM:
    case DATALINK_ESTABLISH_INDICATION:
         /*
         **    These messages come from the DataLink layer when a connection
         **    has been established.  If the DLCI returned is 0, this signifies
         **    that we need to create a Network Layer, otherwise we need to
         **    create a Transport Layer.
         */
        DataLinkEstablish ((DLCI) parameter1);
        break;

     /*
     **    Transport messages
     */
    case TPRT_CONNECT_CONFIRM:
         /*
         **    This message is received from the Transport Layer to confirm
         **    that the Transport Layer (that we initiated) is up and running
         **
         **    We notify the owner object that the connection is now valid.
         */
        m_pController->OwnerCallback(m_nMsgBase + TPRT_CONNECT_CONFIRM,
                                     parameter1);
        break;

    case TPRT_CONNECT_INDICATION:
         /*
         **    This message is received from the Transport Layer to confirm
         **    that the Transport Layer (that the remote site initiated) is
         **    up.
         **
         **    We notify the owner object that the connection is up.
         */
        m_pController->OwnerCallback(m_nMsgBase + TPRT_CONNECT_INDICATION,
                                     parameter1);
        break;

    case NEW_CONNECTION:
         /*
         **    Multiplexer is initiated and ready, create a DataLink to sit
         **    on top of this layer.  The Link_Originator flag tells the
         **    DataLink whether to start link establishment
         */
        NewConnection ();
        break;

    case BROKEN_CONNECTION:
    case TPRT_DISCONNECT_INDICATION:
    case NETWORK_DISCONNECT_INDICATION:
    case DATALINK_RELEASE_INDICATION:
    case DATALINK_RELEASE_CONFIRM:
         /*
         **    These messages need to be processed at a later time.
         */
        DBG_SAVE_FILE_LINE
        passive_message = new MessageStruct;
        if (NULL != passive_message)
        {
            passive_message -> message = layer_message;
            passive_message -> parameter1 = parameter1;
            passive_message -> parameter2 = parameter2;
            passive_message -> parameter3 = parameter3;
            Message_List.append ((DWORD_PTR) passive_message);
        }
        else
        {
            ERROR_OUT(("T123::OwnerCallback: cannot allocate MessageStruct"));
        }
        break;

    case T123_STATUS_MESSAGE:
        TRACE_OUT(("T123: OwnerCallback: T123_STATUS_MESSAGE"));
        switch ((UINT)((UINT_PTR)(parameter2)))
        {
        case DATALINK_TIMING_ERROR:
            ERROR_OUT(("T123: OwnerCallback: DATALINK_TIMING_ERROR"));
            break;

        default:
            ERROR_OUT(("T123: OwnerCallback: Illegal status message = %ld", (UINT)((UINT_PTR)parameter2)));
            break;
        }
        break;

    default:
        ERROR_OUT(("T123: OwnerCallback: Illegal message = %lx", message));
        break;
    }

    return (return_value);
}


/*
 *    void    Controller::ProcessMessages (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes the passive owner callbacks.
 */
void    T123::ProcessMessages (void)
{
    // TRACE_OUT(("T123::ProcessMessages"));

    ULONG                    message;
    PMessageStruct           message_struct;
    void                    *parameter1;
    void                    *parameter2;

    LogicalHandle            logical_handle;
    DLCI                     dlci;
    USHORT                   link_originator;
    USHORT                   retry;
    DataLinkDisconnectType   error;

     /*
     **    Go thru the Message List processing the messages until the messages
     **    are gone
     */
    while (! Message_List.isEmpty())
    {
        message_struct = (PMessageStruct) Message_List.get();
        message = (message_struct -> message) & MESSAGE_MASK;
        parameter1 = message_struct -> parameter1;
        parameter2 = message_struct -> parameter2;

        switch (message)
        {
         /*
         **    DataLink messages
         */
        case DATALINK_RELEASE_INDICATION:
        case DATALINK_RELEASE_CONFIRM:
             /*
             **    These messages occur when the DataLink has broken the link
             */
            dlci = (DLCI) parameter1;
            error = (DataLinkDisconnectType) (UINT_PTR) parameter2;

            DataLinkRelease (dlci, error);
            break;

         /*
         **    Network messages
         */
        case NETWORK_DISCONNECT_INDICATION:
             /*
             **    The Network Layer issues this message when it needs to
             **    terminate a logical connection
             */
            dlci = (DLCI) parameter1;
            link_originator = (USHORT) (((UINT_PTR) parameter2) >> 16);
            retry = (USHORT) ((UINT_PTR) parameter2) & 0xffff;

            NetworkDisconnectIndication (dlci, link_originator, retry);
            break;

        case TPRT_DISCONNECT_INDICATION:
             /*
             **    If the Transport is breaking the connection, the
             **    Connect arbitration must not have worked.  Issue a
             **    DisconnectRequest() to ourselves with the logical
             **    connection
             **
             **    parameter1 = logical connection
             */
            TRACE_OUT(("T123: ProcessMessages: TPRT_DISCONNECT_INDICATION from X224"));
            logical_handle = (LogicalHandle) parameter1;
            DisconnectRequest (logical_handle, TRUE);
            break;

        case BROKEN_CONNECTION:
             /*
             **    This message is issued by the Multiplexer when its
             **    disconnect is completed.  When this occurs, we notify the
             **    owner that the T123 stack is terminating.
             */
            TRACE_OUT(("t123: BROKEN_CONNECTION from MPLEX"));
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                INVALID_LOGICAL_HANDLE,
                                m_hCommLink,
                                &Disconnect_Requested);
            break;
        }

         /*
         **    Delete the message and remove it from the list
         */
        delete message_struct;
        Message_List.remove ((DWORD_PTR) message_struct);
    }
}


/*
 *    DLCI    T123::GetNextDLCI (void)
 *
 *    Functional Description
 *        This function searches the DLCI list for the first available DLCI.  The
 *        T123 spec. allows DLCIs between a specified range.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Valid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
DLCI    T123::GetNextDLCI (void)
{
    DLCI    dlci;

    dlci = (DLCI) ((GetTickCount() % (HIGHEST_DLCI_VALUE + 1 - LOWEST_DLCI_VALUE)) + LOWEST_DLCI_VALUE);

    while(1)
    {
        if(DLCI_List.find ((DWORD) dlci) == FALSE)
            break;
        if (++dlci > HIGHEST_DLCI_VALUE)
            dlci = LOWEST_DLCI_VALUE;
    }

    return (dlci);
}


/*
 *    void    T123::Reset (void)
 *
 *    Functional Description
 *        This function deletes all Transport Layers, DataLink Layers and
 *        Network Layers that are active.  It clears our lists and puts us
 *        in a reset state.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Valid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::Reset (void)
{
    TRACE_OUT(("T123::Reset"));

    TRACE_OUT(("T123::Reset network layer = %lx", m_pSCF));

    Short    priority;
    PDLCIStruct dlci_struct;

     /*
     **    Delete the Network Layer if it exists
     */
    delete m_pSCF;
    m_pSCF = NULL;

     /*
     **    Delete the DLCI 0  DataLink Layer, if it exists
     */
    delete m_pQ922;
    m_pQ922 = NULL;

    delete Data_Request_Memory_Manager;
    Data_Request_Memory_Manager = NULL;


     /*
     **    For each priority level, clear the Priority list
     */
    for (priority=(NUMBER_OF_PRIORITIES - 1); priority>=0; priority--)
        Logical_Connection_Priority_List[priority]->clear ();

     /*
     **    Clear the Logical_Connection_List and DataLink_List
     */
    Logical_Connection_List.clear ();
    DataLink_List.clear ();

     /*
     **    Go thru each Transport and DataLink layer (excluding DLCI 0) and delete
     **    them.  Delete the DLCIStruct.  Finally, clear the list
     */
    DLCI_List.reset();
    while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct))
    {
        delete dlci_struct->x224;
        if (dlci_struct->q922 != NULL)
        {
            delete dlci_struct->q922;
            delete dlci_struct->data_request_memory_manager;
        }

        delete dlci_struct;
    }
    DLCI_List.clear ();

}


/*
 *    void    T123::NetworkDisconnectIndication (
 *                    DLCI        dlci,
 *                    BOOL        link_originator,
 *                    BOOL        retry)
 *
 *    Functional Description
 *        This function is called when we receive a NETWORK_DISCONNECT_INDICATION
 *        message from the SCF Layer.  It removes the TC and if no TCs remain, it
 *        tears down the stack
 *
 *    Formal Parameters
 *        dlci                (i)    -    Connection identifier
 *        link_originiator    (i)    -    TRUE, if this side originated the logical
 *                                    connection
 *        retry                (i)    -    TRUE, if we should retry the connection.
 *
 *    Return Value
 *        void
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::NetworkDisconnectIndication (
                DLCI        dlci,
                BOOL        link_originator,
                BOOL        retry)
{
    TRACE_OUT(("T123::NetworkDisconnectIndication"));

    DLCI            new_dlci;
    LogicalHandle    logical_handle;
    BOOL            transport_found;
    PDLCIStruct        lpdlciStruct;
    DWORD_PTR        dwTemp_dlci;


    TRACE_OUT(("T123: NetworkDisconnectIndication"));

    if (DLCI_List.find ((DWORD_PTR) dlci, (PDWORD_PTR) &lpdlciStruct) == FALSE)
        return;

     /*
     **    if dlci equals 0, a connection was requested by the remote
     **    site but the connection was not fully established.  This object
     **    will not do anything about it.  It only recognizes that it
     **    occured.
     */
    transport_found = FALSE;
    if (dlci != 0)
    {
        Logical_Connection_List.reset();
        while (Logical_Connection_List.iterate(&dwTemp_dlci, (PDWORD_PTR) &logical_handle))
        {
            if (dlci == (DLCI) dwTemp_dlci)
            {
                 /*
                 **    It is VERY important to check the link_originator flag,
                 **    otherwise we may break the wrong connection
                 */
                if (link_originator == lpdlciStruct-> link_originator)
                {
                    transport_found = TRUE;
                    break;
                }
            }
        }
    }

     /*
     **    retry is set to TRUE if during the request for this new
     **    connection, the remote site refused our DLCI selection.
     **    This is not a major error, we will request another
     **    connection using another DLCI.
     */
    TRACE_OUT(("retry = %d link_originator = %d retries = %d",
        retry, link_originator, lpdlciStruct->network_retries));

    if (retry && link_originator &&
        (lpdlciStruct->network_retries < NETWORK_RETRIES))
    {
        lpdlciStruct->network_retries++;

         /*
         **    Get another DLCI and replace the old dlci in the
         **    Logical_Connection_List.  Add the new DLCI to the DLCI_List
         **    and remove the old one.
         */
        new_dlci = GetNextDLCI ();
        Logical_Connection_List.insert (logical_handle, (DWORD_PTR) new_dlci);
        DLCI_List.insert ((DWORD_PTR) new_dlci, (DWORD_PTR) lpdlciStruct);
        DLCI_List.remove ((DWORD_PTR) dlci);

         /*
         **    Issue another ConnectRequest to the Network Layer.
         */
        m_pSCF->ConnectRequest(new_dlci, lpdlciStruct->priority);
    }
    else
    {
         /*
         **    If a transport was found in our list and we don't want
         **    to retry the connection, delete the Transport and
         **    DataLink and remove them from our lists
         */
        if (transport_found)
        {
            if (lpdlciStruct != NULL)
            {
                delete lpdlciStruct -> x224;
                lpdlciStruct->x224 = NULL;

                delete lpdlciStruct->q922;
                lpdlciStruct->q922 = NULL;

                delete lpdlciStruct->data_request_memory_manager;
                lpdlciStruct->data_request_memory_manager = NULL;

                 /*
                 **    Remove the logical connection from the lists
                 */
                Logical_Connection_Priority_List[lpdlciStruct->priority]->remove (dlci);
                DataLink_List.remove (dlci);

                delete lpdlciStruct;
            }

            Logical_Connection_List.remove (logical_handle);
            DLCI_List.remove ((DWORD) dlci);

             /*
             **    Notify the owner object that the logical
             **    connection is no longer valid.
             */
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                (void *) logical_handle,
                                m_hCommLink);
        }


         /*
         **    This check determines if we will automatically tear down the
         **    T.120 stack if the logical connection count reaches zero.
         */
        if (m_pComPort->PerformAutomaticDisconnect())
        {
            TRACE_OUT(("T123: NetworkDisconnectIndication: Perform Auto Disconnect"));
             /*
             **    If there aren't any more Logical Connections and I
             **    was the link originator, initiate a Release Request to
             **    the DataLink of DLCI 0
             */
            if (Logical_Connection_List.isEmpty() && Link_Originator)
            {
                delete m_pSCF;
                m_pSCF = NULL;

                if (m_pQ922 != NULL)
                {
                    m_pQ922->ReleaseRequest();
                }
                else
                {
                    m_pController->OwnerCallback(
                                    m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                    INVALID_LOGICAL_HANDLE,
                                    m_hCommLink,
                                    &Disconnect_Requested);
                }
            }
        }
    }
}


/*
 *    void    T123::DataLinkRelease (
 *                    DLCI            dlci,
 *                    DisconnectType    error)
 *
 *    Functional Description
 *        This function is called when we receive a DATALINK_RELEASE message
 *        message from the DataLink Layer.  As a result we may disconnect a
 *        logical connection or (if it is DLCI 0) the whole stack.
 *
 *    Formal Parameters
 *        dlci                (i)    -    Connection identifier
 *        error                (i)    -    error type
 *
 *    Return Value
 *        Valid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::DataLinkRelease (
                DLCI                    dlci,
                DataLinkDisconnectType    disconnect_type)
{
    TRACE_OUT(("T123::DataLinkRelease"));

    BOOL            transport_found;
    LogicalHandle    logical_handle;
    USHORT            message;

    TRACE_OUT(("T123: DataLinkRelease: DLCI = %d", dlci));

     /*
     **    If DLCI 0 is terminating, all Transports and DataLinks must
     **    be terminated
     */
    if (dlci == 0)
    {
         /*
         **    If the DataLink broke the connection because of a
         **    Fatal Error, issue an immediate TPRT_DISCONNECT_INDICATION
         **    to the owner object.  This may cause the owner object
         **    to delete us immediately.  If the error is not Fatal
         **    disconnect the Multiplexer so that it can send out
         **    its remaining data
         */
        if (disconnect_type != DATALINK_NORMAL_DISCONNECT)
        {
             /*
             **    This function deletes all of the DataLinks,
             **    Network Layers, and Transports.
             */
            Reset ();

             /*
             **    Notify the owner that DLCI 0 is terminating
             */
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                INVALID_LOGICAL_HANDLE,
                                m_hCommLink,
                                &Disconnect_Requested);
        }
        else
        {
             /*
             **    If the error is not Fatal, let the Multiplexer
             **    complete its transmission.
             */
            m_pMultiplexer->DisconnectRequest();
        }
    }
    else
    {
        DWORD_PTR    dwTemp_dlci;

         /*
         **    The DataLink associated with a Transport is terminating
         */
        if (DLCI_List.find ((DWORD) dlci) == FALSE)
            return;

        transport_found = FALSE;

         /*
         **    Find the logical connection associated with this DLCI
         */
        Logical_Connection_List.reset();
        while (Logical_Connection_List.iterate(&dwTemp_dlci, (PDWORD_PTR) &logical_handle) == TRUE)
        {
            if (dlci == (DLCI) dwTemp_dlci)
            {
                transport_found = TRUE;
                break;
            }
        }

        if (transport_found)
            DisconnectRequest (logical_handle, TRUE);
    }
}


/*
 *    void    T123::NewConnection (void)
 *
 *    Functional Description
 *        This function is called when we receive a NEW_CONNECTION message from
 *        the Multiplexer Layer.  It instantiates a DataLink Layer to serve
 *        the SCF.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Valid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::NewConnection (void)
{
    TRACE_OUT(("T123::NewConnection"));

    USHORT                max_outstanding_bytes;
    BOOL                initialized;
    MemoryTemplate        memory_template[2];
    MemoryManagerError    memory_manager_error;

    memory_template[0].block_size = 128;
    memory_template[0].block_count = 4;

    DBG_SAVE_FILE_LINE
    Data_Request_Memory_Manager = new MemoryManager (
                                        memory_template,
                                        1,
                                        &memory_manager_error,
                                        9,
                                        TRUE);

    if ((Data_Request_Memory_Manager != NULL) &&
        (memory_manager_error != MEMORY_MANAGER_NO_ERROR))
    {
        delete Data_Request_Memory_Manager;
        Data_Request_Memory_Manager = NULL;
    }

    if (Data_Request_Memory_Manager != NULL)
    {
        max_outstanding_bytes = PSTN_DATALINK_MAX_OUTSTANDING_BYTES;


        DBG_SAVE_FILE_LINE
        m_pQ922 = new CLayerQ922(this,
                                m_pMultiplexer,
                                DATALINK_LAYER_MESSAGE_BASE,
                                0,
                                Link_Originator,
                                4,
                                4,
                                DataLink_Struct.default_k_factor,
                                DataLink_Struct.default_n201,
                                DataLink_Struct.default_t200,
                                max_outstanding_bytes,
                                Data_Request_Memory_Manager,
                                m_pComPort->GetCallControlType(),
                                m_fValidSDKParams ? &m_SDKParams : NULL,
                                &initialized);
        if (m_pQ922 == NULL)
        {
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                INVALID_LOGICAL_HANDLE,
                                m_hCommLink,
                                &Disconnect_Requested);

        }
        else if (initialized == FALSE)
        {
            delete m_pQ922;
            m_pQ922 = NULL;
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                INVALID_LOGICAL_HANDLE,
                                m_hCommLink,
                                &Disconnect_Requested);
        }
    }
    else
    {
        TRACE_OUT(("T123: Allocation of memory manager failed"));
        m_pController->OwnerCallback(
                            m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                            INVALID_LOGICAL_HANDLE,
                            m_hCommLink,
                            &Disconnect_Requested);
    }
}


/*
 *    void    T123::NetworkConnectIndication (
 *                    PNetworkConnectStruct    connect_struct)
 *
 *    Functional Description
 *        This function is called when we receive a NETWORK_CONNECT_INDICATION
 *        message from the SCF Layer.  It instantiates a DataLink Layer to serve
 *        the new TC.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Valid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::NetworkConnectIndication (
                PNetworkConnectStruct    connect_struct)

{
    TRACE_OUT(("T123::NetworkConnectIndication"));

    USHORT              blocks;
    CLayerQ922         *q922;
    BOOL                initialized;
    PMemoryManager      data_request_memory_manager;
    BOOL                valid_dlci;
    PDLCIStruct         dlci_struct;
    USHORT              max_outstanding_bytes;
    MemoryTemplate      memory_template[2];
    MemoryManagerError  memory_manager_error;
    ULONG               max_transport_tpdu_size;

     /*
     **    See if the DLCI is already being used elsewhere.  If it is,
     **    set valid_dlci to FALSE and call ConnectResponse().  If it is
     **    not, put the DLCI in out DLCI_List
     */
    if (DLCI_List.find ((DWORD) (connect_struct->dlci)))
        valid_dlci = FALSE;
    else
    {
        DBG_SAVE_FILE_LINE
        dlci_struct = new DLCIStruct;
        if (dlci_struct != NULL)
        {
            DLCI_List.insert ((DWORD_PTR) (connect_struct->dlci), (DWORD_PTR) dlci_struct);
            dlci_struct -> link_originator = FALSE;
            dlci_struct -> x224 = NULL; // X.224
            dlci_struct -> q922 = NULL; // Q.922
            dlci_struct -> disconnect_requested = FALSE;
            dlci_struct -> data_request_memory_manager = NULL;
            dlci_struct -> network_retries = 0;
            dlci_struct -> priority = connect_struct->priority;

             /*
             **    Connect_Requested does not mean tha we issued a
             **    ConnectRequest() to the Network Layer.  It means that the
             **    Network Layer is aware of the connection.
             */
            dlci_struct -> connect_requested = TRUE;
            valid_dlci = TRUE;
        }
        else
        {
            valid_dlci = FALSE;
        }
    }

    if (valid_dlci)
    {
         /*
         **    Create a DataLink that will service this Transport Layer
         */
        max_transport_tpdu_size = CLayerX224::GetMaxTPDUSize (
                            (ULONG) (connect_struct->datalink_struct) -> n201);

        blocks = (USHORT) (MAXIMUM_USER_DATA_SIZE /
            (max_transport_tpdu_size - DATA_PACKET_HEADER_SIZE)) + 1;

         /*
         **    Allow for one extra block so that a HIGH_PRIORITY memory
         **    allocation can get as many blocks as it needs to hold the
         **    MAXIMUM_USER_DATA_SIZE packet.
         */
        blocks++;

        TRACE_OUT(("T123: NCIndication: max_tpdu = %d",max_transport_tpdu_size));

         /*
         **    Allow for X 8K blocks
         */
        blocks *= NUMBER_8K_BLOCKS;

         /*
         **    The '2' in the following statement is for the CRC added by the
         **    multiplexer.
         */
        memory_template[0].block_size = max_transport_tpdu_size +
                                        DATALINK_PACKET_OVERHEAD +
                                        2;
        memory_template[0].block_count = blocks;
        memory_template[1].block_size = 64;
        memory_template[1].block_count = NUMBER_64_BYTE_BLOCKS;

        DBG_SAVE_FILE_LINE
        data_request_memory_manager = new MemoryManager (
                                            memory_template,
                                            2,
                                            &memory_manager_error,
                                            33,
                                            TRUE);

        if ((data_request_memory_manager != NULL) &&
            (memory_manager_error != MEMORY_MANAGER_NO_ERROR))
        {
            delete data_request_memory_manager;
            data_request_memory_manager = NULL;
        }

        if (data_request_memory_manager != NULL)
        {

            dlci_struct->priority = connect_struct -> priority;
            dlci_struct->data_request_memory_manager = data_request_memory_manager;

            max_outstanding_bytes = PSTN_DATALINK_MAX_OUTSTANDING_BYTES;

            DBG_SAVE_FILE_LINE
            q922 =  new CLayerQ922(this,
                                    m_pMultiplexer,
                                    DATALINK_LAYER_MESSAGE_BASE,
                                    connect_struct->dlci,
                                    dlci_struct->link_originator,
                                    1,
                                    4,
                                    (connect_struct->datalink_struct)->k_factor,
                                    (connect_struct->datalink_struct)->n201,
                                    (connect_struct->datalink_struct)->t200,
                                    max_outstanding_bytes,
                                    data_request_memory_manager,
                                    m_pComPort->GetCallControlType(),
                                    m_fValidSDKParams ? &m_SDKParams : NULL,
                                    &initialized);
            if (q922 != NULL)
            {

                if (initialized)
                {
                     /*
                     **    Add it to the DataLink list
                     */
                    dlci_struct->q922 = q922;
                    DataLink_List.append (connect_struct->dlci);
                }
                else
                {
                    delete q922;
                    delete data_request_memory_manager;
                    DLCI_List.remove ((DWORD) connect_struct->dlci);
                    valid_dlci = FALSE;
                }
            }
            else
            {
                delete data_request_memory_manager;
                DLCI_List.remove ((DWORD) connect_struct -> dlci);
                valid_dlci = FALSE;
            }
        }
        else
        {
            ERROR_OUT(("t123: Unable to allocate memory manager"));
            valid_dlci = FALSE;
            DLCI_List.remove ((DWORD) connect_struct -> dlci);
        }
    }

     /*
     **    Contact the Network Layer with a response
     */
    m_pSCF->ConnectResponse(
                        connect_struct -> call_reference,
                        connect_struct -> dlci,
                        valid_dlci);

}


/*
 *    void    T123::NetworkConnectConfirm (
 *                    PNetworkConnectStruct    connect_struct)
 *
 *    Functional Description
 *        This function is called when we receive a NETWORK_CONFIRM message
 *        from the SCF Layer.  It instantiates a DataLink Layer to serve the
 *        new logical connection.
 *
 *    Formal Parameters
 *        connect_struct    (i)    -    Address of connect struct.  It holds the DLCI
 *                                and priority.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::NetworkConnectConfirm (
                PNetworkConnectStruct    connect_struct)
{
    TRACE_OUT(("T123::NetworkConnectConfirm"));

    DLCI                dlci;
    USHORT              blocks;
    CLayerQ922         *q922;
    BOOL                initialized;
    PMemoryManager      data_request_memory_manager;
    MemoryTemplate      memory_template[2];
    MemoryManagerError  memory_manager_error;
    USHORT              max_outstanding_bytes;
    ULONG               max_transport_tpdu_size;
    PDLCIStruct         dlci_struct;


    max_transport_tpdu_size = CLayerX224::GetMaxTPDUSize (
                                (ULONG) (connect_struct->datalink_struct) -> n201);

    blocks = (USHORT) (MAXIMUM_USER_DATA_SIZE /
        (max_transport_tpdu_size - DATA_PACKET_HEADER_SIZE)) + 1;

    TRACE_OUT(("T123:  NCConfirm: max_tpdu = %d", max_transport_tpdu_size));

     /*
     **    Allow for one extra block so that a HIGH_PRIORITY memory
     **    allocation can get as many blocks as it needs to hold the
     **    MAXIMUM_USER_DATA_SIZE packet.
     */
    blocks++;

     /*
     **    Allow for X 8K blocks
     */
    blocks *= NUMBER_8K_BLOCKS;

     /*
     **    Figure out the maximum packet size; The '2' is for the CRC appended
     **    to the end of a packet.
     */
    memory_template[0].block_size = max_transport_tpdu_size +
                                    DATALINK_PACKET_OVERHEAD +
                                    2;
    memory_template[0].block_count = blocks;
    memory_template[1].block_size = 64;
    memory_template[1].block_count = NUMBER_64_BYTE_BLOCKS;

    DBG_SAVE_FILE_LINE
    data_request_memory_manager = new MemoryManager (
                                        memory_template,
                                        2,
                                        &memory_manager_error,
                                        33,
                                        TRUE);

    if ((data_request_memory_manager != NULL) &&
        (memory_manager_error != MEMORY_MANAGER_NO_ERROR))
    {
        delete data_request_memory_manager;
        data_request_memory_manager = NULL;
    }

    if (data_request_memory_manager != NULL)
    {

        dlci = connect_struct -> dlci;

        DLCI_List.find ((DWORD_PTR) dlci, (PDWORD_PTR) &dlci_struct);
        dlci_struct->data_request_memory_manager = data_request_memory_manager;

         /*
         **    The DLCI is already entered in our DLCI list, set the priority
         **    and create a DataLink for it.
         */
        dlci_struct->q922 = NULL;
        dlci_struct->priority = connect_struct->priority;

        max_outstanding_bytes =    PSTN_DATALINK_MAX_OUTSTANDING_BYTES;

        DBG_SAVE_FILE_LINE
        q922 = new CLayerQ922(this,
                                m_pMultiplexer,
                                DATALINK_LAYER_MESSAGE_BASE,
                                dlci,
                                dlci_struct->link_originator,
                                1,
                                4,
                                (connect_struct->datalink_struct)->k_factor,
                                (connect_struct->datalink_struct)->n201,
                                (connect_struct->datalink_struct)->t200,
                                max_outstanding_bytes,
                                data_request_memory_manager,
                                m_pComPort->GetCallControlType(),
                                m_fValidSDKParams ? &m_SDKParams : NULL,
                                &initialized);
        if (q922 != NULL)
        {
            if (initialized)
            {
                dlci_struct->q922 = q922;
                DataLink_List.append (dlci);
            }
            else
            {
                delete q922;
                delete data_request_memory_manager;
                m_pSCF->DisconnectRequest(dlci);
            }
        }
        else
        {
            delete data_request_memory_manager;
            m_pSCF->DisconnectRequest(dlci);
        }
    }
}


/*
 *    void    T123::DataLinkEstablish (
 *                    DLCI    dlci)
 *
 *    Functional Description
 *        This function is called when we receive a DATALINK_ESTABLISH message
 *        from a DataLink Layer.  Depending on which DataLink is successfully up,
 *        it creates the layer on top of it.
 *
 *    Formal Parameters
 *        dlci        (i)    -    DLCI value
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::DataLinkEstablish (DLCI    dlci)
{
    TRACE_OUT(("T123::DataLinkEstablish, dlci=%d", dlci));

    BOOL                initialized;
    BOOL                transport_found;
    PDLCIStruct            dlci_struct;
    LogicalHandle        logical_handle;
    TransportPriority    priority;
    DWORD_PTR            dwTemp_dlci;

    if (dlci == 0)
    {
        DBG_SAVE_FILE_LINE
        m_pSCF = new CLayerSCF(this,
                                m_pQ922,
                                NETWORK_LAYER_MESSAGE_BASE,
                                0,
                                Link_Originator,
                                &DataLink_Struct,
                                Data_Request_Memory_Manager,
                                &initialized);
        if (m_pSCF == NULL)
        {
            m_pQ922->ReleaseRequest();
            return;
        }
        else if (initialized == FALSE)
        {
            delete m_pSCF;
            m_pQ922->ReleaseRequest();
            return;
        }

         /*
         **    Go thru the Transport list and attempt connections
         ** for all Transport requests that we have received
         */
        DLCI_List.reset();
        while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct, &dwTemp_dlci))
        {
            dlci = (DLCI) dwTemp_dlci;
             /*
             **    The Link_Originator is set to TRUE if the
             **    ConnectRequest() function was called.  We have to check
             **    the Connect_Requested variable to see if we have
             **    already made the request to the Network Layer.
             */
            if (dlci_struct->link_originator
                && (dlci_struct->connect_requested == FALSE))
            {
                dlci_struct -> connect_requested = TRUE;
                m_pSCF->ConnectRequest(dlci, dlci_struct -> priority);
            }
        }
    }
    else
    {
         /*
         **    If DLCI != 0, this is a DataLink for a Transport Layer
         */
        transport_found = FALSE;

         /*
         **    Go thru each of the Transports to find the one associated
         **    with the DLCI.
         */
        Logical_Connection_List.reset();
        while (Logical_Connection_List.iterate((PDWORD_PTR) &dwTemp_dlci, (PDWORD_PTR) &logical_handle))
        {
            if (dlci == (DLCI) dwTemp_dlci)
            {
                transport_found = TRUE;
                break;
            }
        }

         /*
         **    If we go thru the list and don't find the logical
         **    connection we have to request a new logical connection
         **    handle from the controller.
         */
        if (transport_found == FALSE)
        {
            logical_handle = (LogicalHandle) m_pController->OwnerCallback(
                                    m_nMsgBase + REQUEST_TRANSPORT_CONNECTION,
                                    m_hCommLink,
                                    0,
                                    NULL);
            if (logical_handle != INVALID_LOGICAL_HANDLE)
            {
                 /*
                 **    Set the Logical_Connection_List appropriately
                 */
                Logical_Connection_List.insert (logical_handle, (DWORD) dlci);
            }
            else
            {
                m_pSCF->DisconnectRequest(dlci);
                return;
            }
        }

         /*
         **    Create a Transport Layer to go with the DataLink layer.
         */
        DLCI_List.find ((DWORD_PTR) dlci, (PDWORD_PTR) &dlci_struct);
        DBG_SAVE_FILE_LINE
        dlci_struct->x224 = new CLayerX224 (
                    this,
                    dlci_struct->q922,
                    TRANSPORT_LAYER_MESSAGE_BASE,
                    logical_handle,
                    0,
                    1,
                    TRANSPORT_DEFAULT_PDU_SIZE,
                    dlci_struct -> data_request_memory_manager,
                    &initialized);

        if (dlci_struct->x224 != NULL)
        {
            if (initialized)
            {
                 /*
                 **    Put the dlci in the Priority list
                 */
                priority = dlci_struct->priority;
                Logical_Connection_Priority_List[priority]->append ((DWORD) dlci);

                 /*
                 **    If transport_found == TRUE, we must have initiated
                 **    the request for this logical connection, so issue
                 **    the ConnectRequest() to the Transport Layer.
                 */
                if (transport_found)
                {
                    dlci_struct->x224->ConnectRequest ();
                }
            }
            else
            {
                m_pSCF->DisconnectRequest (dlci);
            }
        }
        else
        {
            m_pSCF->DisconnectRequest (dlci);
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\t123.h ===
/*    T123.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class controlls the T123 stack associated with a particular 
 *        physical connection.  
 *
 *        This class builds a T123 PSTN stack. The physical layer is passed in via
 *        the constructor.  During the constructor, we instantiate a multiplexer.
 *        This multiplexer will allow us to mux multiple DataLink layers to the 
 *        same physical address.  For this particular physical connection (PSTN) 
 *        the Multiplexer adds a CRC to the packet and frames it before passing
 *        it to the physical layer.  On the receive side, it frames the incoming
 *        stream data and packetizes it.  It also checks the CRC for validity.
 *        The Multiplexer receives data from its higher layer 
 *        (DataLink) in packet form.  When the Multiplexer passes data to its 
 *        lower layer, it passes it in stream form.  The Multiplexer is
 *        configured to be a multi-DataLink entity.  Since it does handle multiple
 *        DataLinks, it can NOT buffer data on the receive side.  If one 
 *        particular DataLink is backed up, it can NOT hold the other DataLinks 
 *        up.  If it can not pass a packet up immediately, it will trash it. 
 *
 *        After the Multiplexer issues a callback to us to us it is ready, we 
 *        will create a DataLink Layer to service the Network layer.  The DataLink
 *        Layer is based on the Q.922 standard.  The DLCI associated with this 
 *        DataLink is 0.  Its Lower Layer is the Multiplexer.  Its Higher Layer is
 *        the SCF Layer.
 *
 *        The SCF Layer is the Network Layer.  It is responsible for 
 *        arbitrating the DLCI and parameters used in other transport 
 *        connections.  It has no responsibilities once the connection is up.  If
 *        this class receives a ConnectRequest() from the user, it issues a 
 *        ConnectRequest() to the SCF Layer.  SCF will notify us when the 
 *        connection is up.
 *        
 *        When the SCF notifies us that a new connection exists, we create a 
 *        DataLink Layer that services the new Transport Connection.  This 
 *        DataLink Layer uses our Multiplexer as its Lower Layer.
 *
 *        When the DataLink Layer is up and operational, it notifies us.  At this
 *        point, we create an X224 Layer to interface with the user.  The X224 
 *        Layer interfaces with the DataLink Layer to send data.  It also 
 *        interfaces with the user to pass data on up.
 *
 *    Caveats:
 *        None.
 *
 *    Author:
 *        James W. Lawwill
 */
#ifndef _T123_H_
#define _T123_H_

#include "scf.h"
#include "q922.h"
#include "mplex.h"
#include "x224.h"

 /*
 **    Layer Numbers
 */
#define PHYSICAL_LAYER          1
#define MULTIPLEXER_LAYER       2    // This is a DataBeam-specific layer
#define DATALINK_LAYER          3
#define NETWORK_LAYER           4
#define TRANSPORT_LAYER         5



 /* 
 **    Layer Message Bases
 */
#define PHYSICAL_LAYER_MESSAGE_BASE     0x0000
#define MULTIPLEXER_LAYER_MESSAGE_BASE  0x1000
#define DATALINK_LAYER_MESSAGE_BASE     0x2000
#define NETWORK_LAYER_MESSAGE_BASE      0x3000
#define TRANSPORT_LAYER_MESSAGE_BASE    0x4000
#define LAYER_MASK                      0x7000
#define MESSAGE_MASK                    0x0fff

 /*
 **    Maximum number of priorities
 */
// #define    NUMBER_OF_PRIORITIES         15
#define    NUMBER_OF_PRIORITIES         4
#define    LOWEST_DLCI_VALUE            16
#define    HIGHEST_DLCI_VALUE           991

#define    INVALID_LOGICAL_HANDLE       0

 /*
 **    Each DLCI has this structure associated with it.
 */
typedef struct
{
    BOOL                link_originator;
    CLayerX224         *x224; // transport_layer
    CLayerQ922         *q922; // datalink_layer
    TransportPriority   priority;
    BOOL                disconnect_requested;
    BOOL                connect_requested;
    PMemoryManager      data_request_memory_manager;
    USHORT              network_retries;
}
    DLCIStruct, *PDLCIStruct;


class T123
{
public:

    T123(TransportController   *owner_object,
        USHORT                  message_base,
        BOOL                    link_originator,
        ComPort                *physical_layer,
        PhysicalHandle          physical_handle,
        PLUGXPRT_PARAMETERS    *pParams,
        BOOL *                  t123_initialized);

    virtual ~T123(void);

     /*
     **    Functions related to making and breaking a linkg
     */
    TransportError    ConnectRequest (
                        LogicalHandle        logical_handle,
                        TransportPriority    priority);
    TransportError    ConnectResponse (
                        LogicalHandle    logical_handle);
    TransportError    DisconnectRequest (
                        LogicalHandle    logical_handle,
                        UINT_PTR            trash_packets);
    TransportError    DataRequest (
                        LogicalHandle    logical_handle,
                        LPBYTE            user_data,
                        ULONG            user_data_length);
    TransportError    PurgeRequest (
                        LogicalHandle    logical_handle);
    void            EnableReceiver (void);

    ULONG            PollReceiver (void);
    void            PollTransmitter (void);

    ULONG OwnerCallback(ULONG, void *p1 = NULL, void *p2 = NULL, void *p3 = NULL);

private:

    void            Reset (void);
    DLCI            GetNextDLCI (void);
    void            ProcessMessages (void);
    void            NetworkDisconnectIndication (
                        DLCI        dlci,
                        BOOL        link_originator,
                        BOOL        retry);
    void            DataLinkRelease (
                        DLCI    dlci,
                        DataLinkDisconnectType    error);
    void            NewConnection (void);
    void            NetworkConnectIndication (
                        PNetworkConnectStruct    connect_struct);
    void            NetworkConnectConfirm (
                        PNetworkConnectStruct    connect_struct);
    void            DataLinkEstablish (
                        DLCI    dlci);
private:

    BOOL                        m_fValidSDKParams;
    PLUGXPRT_PARAMETERS         m_SDKParams;

    DictionaryClass         Logical_Connection_List;
    DictionaryClass         DLCI_List;
    SListClass              Message_List;
    SListClass              DataLink_List;
    SListClass             *Logical_Connection_Priority_List[NUMBER_OF_PRIORITIES];
    
    TransportController    *m_pController;
    BOOL                    Link_Originator;
    USHORT                  m_nMsgBase;

    CLayerSCF              *m_pSCF; // network layer
    CLayerQ922             *m_pQ922; // data link layer
    Multiplexer            *m_pMultiplexer; // multiplexer layer
    ComPort                *m_pComPort; // physical layer
    PhysicalHandle          m_hCommLink;
    DataLinkParameters      DataLink_Struct;
    PMemoryManager          Data_Request_Memory_Manager;
#ifdef USE_RANDOM_CLASS
    PRandomNumberGenerator  Random;
#endif
    BOOL                    Disconnect_Requested;
};
typedef    T123 *        PT123;

#endif


/*
 *    Documentation for Public class members
 */

/*    
 *    T123::T123 (
 *            PTransportResources    transport_resources,
 *            IObject *                owner_object,
 *            USHORT                message_base,
 *            BOOL                link_originator,
 *            IProtocolLayer *        physical_layer,
 *            PhysicalHandle        physical_handle,
 *            BOOL *                initialized);
 *
 *    Functional Description
 *        This is the constructor for the T123 class.  It prepares for new
 *        connections.
 *
 *    Formal Parameters
 *        transport_resources    (i)    -    Address of resources structure.
 *        owner_object        (i)    -    Address of owner object.  Used for owner
 *                                    callbacks.
 *        message_base        (i)    -    Message base used with owner callbacks.
 *        link_originator        (i)    -    TRUE if we actually originated the 
 *                                    connection
 *        physical_layer        (i)    -    Pointer to physical layer
 *        physical_handle        (i)    -    Identifier that needs to be passed to the
 *                                    physical layer to identify the connection
 *        initialized            (o)    -    TRUE if the object initialized OK.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    T123::~T123 (void)
 *
 *    Functional Description
 *        This is the T123 destructor.  It removes all active connections
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    TransportError    T123::ConnectRequest (
 *                            LogicalHandle        logical_handle
 *                            TransportPriority    priority);
 *
 *    Functional Description
 *        This function initiates a logical connection.  
 *
 *    Formal Parameters
 *        logical_handle            (i)    -    Handle assocaiated with the 
 *                                        logical connection
 *        priority                (i)    -    Requested priority of the connection.
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR        -    No Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    TransportError    T123::ConnectResponse (
 *                            LogicalHandle    logical_handle)
 *
 *    Functional Description
 *        This function is called in response to TRANSPORT_CONNECT_INDICATION 
 *        message that was sent the owner.  By making this call, the owner is 
 *        accepting the connection.
 *
 *    Formal Parameters
 *        logical_handle    (i)    -    Logical connection handle
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                    -    No Error
 *        TRANSPORT_CONNECT_RESPONSE_FAILURE    -    Function not valid
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    TransportError    T123::DisconnectRequest (
 *                            LogicalHandle    logical_handle,
 *                            BOOL            trash_packets);
 *
 *    Functional Description
 *        This function terminates the transport connection.  The user will 
 *        receive a TRANSPORT_DISCONNECT_INDICATION message when the connection
 *        is terminated
 *
 *        If the logical_handle equals INVALID_LOGICAL_HANDLE, the user is 
 *        telling us to take down all logical connections and ultimately the 
 *        physical connection.
 *
 *    Formal Parameters
 *        logical_handle         - (i)  Logical connection number to terminate
 *        trash_packets         - (i)  BOOL    , set to TRUE if we are to trash
 *                                   the packets in the output buffer.
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Transport connection does not exist
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    TransportError    T123::DataRequest (
 *                            LogicalHandle    logical_handle,
 *                            LPBYTE            user_data,
 *                            ULONG            user_data_length);
 *
 *    Functional Description
 *        This function is used to send a data packet to the remote location.
 *        We simply pass this packet to the X224 object associated with the 
 *        transport connection.
 *
 *    Formal Parameters
 *        logical_handle          - (i)  Transport connection number
 *        user_data              - (i)  Address of data to send
 *        user_data_length      - (i)  Length of data to send
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Logical connection does not exist
 *        TRANSPORT_WRITE_QUEUE_FULL        -    Transport write queues are already
 *                                            full.
 *        TRANSPORT_NOT_READY_TO_TRANSMIT    -    The transport layer is in the 
 *                                            process of building or breaking
 *                                            down the transport stack and is
 *                                            not ready for user data.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    TransportError    T123::PurgeRequest (
 *                            LogicalHandle    logical_handle)
 *
 *    Functional Description
 *        This function purges the outbound packets for the logical connection.
 *
 *    Formal Parameters
 *        logical_handle - (i)  Transport connection number
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Logical connection does not exist
 *
 *    Side Effects
 *        None
 */

/*    
 *    TransportError    T123::EnableReceiver (void);
 *
 *    Functional Description
 *        This function is called to enable TRANSPORT_DATA_INDICATION callbacks 
 *        to the user application.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *
 *    Side Effects
 *        None
 */

/*    
 *    void    T123::PollReceiver (void);
 *
 *    Functional Description
 *        This function gives the T123 stack a chance to receive packets from 
 *        the remote site.  During this call, we may be making user callbacks to
 *        pass the data on up.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    void    T123::PollTransmitter (void);
 *
 *    Functional Description
 *        This function gives the T123 stack a chance to transmit data to the 
 *        remote site.  
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    ULONG    T123::OwnerCallback (
 *                    USHORT    layer_message,
 *                    ULONG    parameter1,
 *                    ULONG    parameter2,
 *                    PVoid    parameter3);
 *
 *    Functional Description
 *        This function is the owner callback function.  If any of the layers
 *        owned by this object want to send us a message, they make an owner
 *        callback.  During instantiation of these lower layers, we pass them our
 *        address.  They can call us with significant messages.
 *
 *    Formal Parameters
 *        layer_message    (i)    -    Layer-specific message
 *        parameter1        (i)    -    Message-specific parameter
 *        parameter2        (i)    -    Message-specific parameter
 *        parameter3        (i)    -    Message-specific parameter
 *
 *    Return Value
 *        Message specific
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\tmemory2.h ===
/*    TMemory2.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is a memory class used  to manage a memory buffer.  During 
 *        instantiation, a buffer is allocated and a prepend value is passed in.
 *        The prepend value is used during the Append() call.  All Append() calls
 *        are appended after the prepend value.  A running length is also 
 *        maintained.  This class is good to use if you are going to build up a 
 *        packet over time.
 *
 *        If a packet overruns the max. buffer size, a new buffer is allocated and
 *        used.
 *    
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */

#ifndef _TMEMORY2_
#define _TMEMORY2_

#define    MAXIMUM_NUMBER_REALLOC_FAILURES    10

typedef    enum
{
    TMEMORY_NO_ERROR,
    TMEMORY_NONFATAL_ERROR,
    TMEMORY_FATAL_ERROR,
    TMEMORY_NO_DATA
}
    TMemoryError, * PTMemoryError;

class TMemory
{
public:
                        TMemory (
                            ULong            total_length,
                            UShort            prepend_space,
                            PTMemoryError    error);
                        ~TMemory (
                            Void);

        TMemoryError    Append (
                            HPUChar    address,
                            ULong    length);
        TMemoryError    GetMemory (
                            HPUChar    *     address,
                            FPULong        length);
        Void            Reset (
                            Void);

    private:
        ULong        Default_Buffer_Size;
        HPUChar        Base_Buffer;
        HPUChar        Auxiliary_Buffer;
        ULong        Length;
        DBBoolean    Auxiliary_Buffer_In_Use;
        UShort        Prepend_Space;
        UShort        Fatal_Error_Count;
};
typedef    TMemory *        PTMemory;

#endif

/*
 *    Documentation for Public class members
 */

/*
 *    TMemory::TMemory (
 *                ULong            total_length,
 *                UShort            prepend_space,
 *                PTMemoryError    error);
 *
 *    Functional Description:
 *        This is the constructor for the TMemory class.
 *
 *    Formal Parameters:
 *        total_length    (i)    -    Length of the default buffer
 *        prepend_space    (i)    -    Space to leave blank in the buffer
 *        error            (o)    -    Returns an error value
 *
 *    Return Value:
 *        None.
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    TMemory::TMemory (
 *                Void)
 *
 *    Functional Description:
 *        This is the destructor for the object.
 *
 *    Formal Parameters:
 *        None.
 *
 *    Return Value:
 *        None.
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    TMemoryError    TMemory::Append (
 *                                HPUChar    address,
 *                                ULong    length);
 *
 *    Functional Description:
 *        This function appends the buffer passed in to the internal buffer.
 *
 *    Formal Parameters:
 *        address            (i)    -    Address of buffer
 *        length            (i)    -    Length of buffer
 *
 *    Return Value:
 *        TMEMORY_NO_ERROR        -    No error
 *        TMEMORY_FATAL_ERROR        -    Fatal error occured, can't alloc a buffer
 *        TMEMORY_NONFATAL_ERROR    -    Buffer was not copied but it was not a 
 *                                    fatal error
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    TMemoryError    TMemory::GetMemory (
 *                                HPUChar    *     address,
 *                                FPULong        length);
 *
 *    Functional Description:
 *        This function returns the address and used length of our internal buffer
 *
 *    Formal Parameters:
 *        address            (o)    -    Address of our internal buffer
 *        length            (i)    -    Length of buffer
 *
 *    Return Value:
 *        TMEMORY_NO_ERROR        -    No error
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    Void    TMemory::Reset (
 *                        Void)
 *
 *    Functional Description:
 *        This function resets the memory object.  All data in the object is lost
 *
 *    Formal Parameters:
 *        None
 *
 *    Return Value:
 *        None
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\timer.h ===
/*    Timer.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class maintains the current time and dispathes function calls
 *        when timers expire.  If a routine wants to be called in X amount of
 *        time, it creates a timer event with this class.  When the time expires,
 *        the function is called.  If the user wants to cancel the timer before
 *        it expires, he can use the DeleteTimerEvent() function.
 *
 *        When a person creates a timer event, one of the parameters is the 
 *        control flags.  The user can set the flag so that the event is a
 *        one-time thing or a constant event that occurs every X milliseconds.
 *
 *        This timer has a millisecond granularity.  The time passed into the
 *        CreateEventTimer() function is assumed to be in milliseconds.
 *
 *        The ProcessTimerEvents() function must be called frequently and 
 *        regularly so that the timeouts occur promptly.
 *
 *    Caveats:
 *        None.
 *
 *    Author:
 *        James P. Galvin
 *        James W. Lawwill
 */
#ifndef _TIMER_
#define _TIMER_

/*
**    Possible Error values
*/
typedef    enum
{
    TIMER_NO_ERROR,
    TIMER_NO_TIMERS_AVAILABLE,
    TIMER_NO_TIMER_MEMORY,
    TIMER_INVALID_TIMER_HANDLE
}
    TimerError, * PTimerError;

/*
**    These defines are used in the control_flags variable in the TimerEvent
**    structure.  TIMER_EVENT_IN_USE is a flag used internal to the timer
**    procedure.  TIMER_EVENT_ONE_SHOT can be passed in by the user to 
**    signify that the timer should only occur once.
*/
#define TIMER_EVENT_IN_USE          0x0001
#define TIMER_EVENT_ONE_SHOT        0x0002

#define TRANSPORT_HASHING_BUCKETS   3

typedef USHORT               TimerEventHandle;
typedef TimerEventHandle    *PTimerEventHandle;

typedef void (IObject::*PTimerFunction) (TimerEventHandle);

/*
**    Each timer event has a TimerEvent structure associated with it.
*/
typedef struct TimerEventStruct
{
    TimerEventHandle    event_handle;
    ULong               timer_duration;
    ULong               total_duration;
    IObject            *object_ptr;
    PTimerFunction      timer_func_ptr;
    USHORT              control_flags;
    TimerEventStruct   *next_timer_event;
    TimerEventStruct   *previous_timer_event;
}
    TimerEvent, * PTimerEvent;

class    Timer
{
    public:
                            Timer (
                                    Void);
                            ~Timer (
                                    Void);
        TimerEventHandle    CreateTimerEvent (
                                    ULong            timer_duration,
                                    USHORT            control_flags,
                                    IObject *            object_ptr,
                                    PTimerFunction    timer_function);
        TimerError            DeleteTimerEvent (
                                    TimerEventHandle    timer_event);
        Void                ProcessTimerEvents (
                                    Void);

    private:
        USHORT                Maximum_Timer_Events;
        USHORT                Timer_Event_Count;
        SListClass            Timer_Event_Free_Stack;
        PTimerEvent            First_Timer_Event_In_Chain;
        DWORD                Last_Timer_Value;
        DictionaryClass        Timer_List;
};
typedef    Timer *        PTimer;

extern PTimer        System_Timer;

#define InstallTimerEvent(duration, control, func) \
    (g_pSystemTimer->CreateTimerEvent((duration),(control),this,(PTimerFunction)(func)))

#endif

/*
 *    Timer (Void)
 *
 *    Functional Description:
 *        This is the constructor for the timer class.  This procedure gets
 *        thc current Windows system time.
 *        
 *    Formal Parameters:
 *        None
 *
 *    Return Value:
 *        None
 *
 *    Side Effects:
 *        None
 *
 *    Caveats:
 *        None
 */

/*
 *    ~Timer (Void)
 *
 *    Functional Description:
 *        This is the destructor for the timer class.  This routine frees all
 *        memory associated with timer events.
 *        
 *    Formal Parameters:
 *        None
 *
 *    Return Value:
 *        None
 *
 *    Side Effects:
 *        None
 *
 *    Caveats:
 *        None
 */

/*
 *    TimerEventHandle    CreateTimerEvent (
 *                            ULong            timer_duration,
 *                            USHORT            control_flags,
 *                            IObject *            object_ptr,
 *                            PTimerFunction    timer_function);
 *
 *    Functional Description:
 *        This routine is called to create a timer event.  The routine stores the
 *        information passed-in in a TimerEvent structure.  When the timer expires
 *        the function will be called.
 *        
 *    Formal Parameters:
 *        timer_duration    -    (i)        Amount of time to wait before calling the 
 *                                    function.  The granularity of the timer
 *                                    is milliseconds.
 *        control_flags    -    (i)        This is a USHORT but currently we only 
 *                                    look at one of the bits.  The 
 *                                    TIMER_EVENT_ONE_SHOT can be passed-in by
 *                                    the user if they only want this timeout
 *                                    to occur once.  If this value is 0, the
 *                                    event will occur time after time.
 *        object_ptr        -    (i)        This is the data address of the object.  It
 *                                    is the 'this' pointer of the calling object.
 *        timer_function    -    (i)        This is the address of the function to 
 *                                    call after the timer expires.
 *
 *    Return Value:
 *        TimerEventHandle    -    This is a handle to the timer event.  If you
 *                                need to delete the timer event, pass this 
 *                                handle to the DeleteTimer() function.  A NULL
 *                                handle is returned if the create failed.
 *
 *    Side Effects:
 *        None
 *
 *    Caveats:
 *        None
 */

/*
 *    TimerError    DeleteTimerEvent (TimerEventHandle    timer_event)
 *
 *    Functional Description:
 *        This routine is called by the user to delete a timer event that is 
 *        currently active.  
 *        
 *    Formal Parameters:
 *        timer_event        -    (i)        Handle to a timer event 
 *
 *    Return Value:
 *        TIMER_NO_ERROR                -    Successful Delete
 *        TIMER_NO_TIMER_MEMORY        -    The timer_event can't exist because
 *                                        there was never any Timer memory
 *        TIMER_INVALID_TIMER_HANDLE    -    timer_event is not in our list 
 *                                        of timers
 *
 *    Side Effects:
 *        None
 *
 *    Caveats:
 *        None
 */

/*
 *    Void    ProcessTimerEvents (Void)
 *
 *    Functional Description:
 *        This routine MUST be called frequently and regularly so that we can
 *        manage our timers.  This function gets the current system time and
 *        goes through each of the timers to see which have expired.  If a timer
 *        has expired, we call the function associated with it.  Upon return,
 *        if the timer was marked as a one-shot event, we remove it from our
 *        list of timers.
 *        
 *    Formal Parameters:
 *        None
 *
 *    Return Value:
 *        None
 *
 *    Side Effects:
 *        None
 *
 *    Caveats:
 *        None
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\timer.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    Timer.cpp
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the Timer class
 *
 *    Private Instance Variables:
 *        Maximum_Timer_Events            -    Maximum number of timers maintained
 *                                            by this class
 *        Timer_Memory                    -    Base address of our TimerEvent
 *                                            structure memory
 *        Timer_Event_Table                -    Address of first structure in
 *                                            Timer_Memory
 *        Timer_Event_Count                -    Number of timers active
 *        Timer_Event_Free_Stack            -    Holds numbers of available timers
 *        First_Timer_Event_In_Chain        -    Number of first timer in the chain
 *        Last_Timer_Value                -    Last time that we got from Windows
 *        Timer_Info                        -    Windows structure that holds the
 *                                            current time.
 *
 *    Caveats:
 *        None
 *
 *    Author:
 *        James P. Galvin
 *        James W. Lawwill
 */
#include <windowsx.h>
#include "timer.h"


/*
 *    Timer (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the constructor for the timer class.  This procedure gets
 *        thc current Windows system time.
 */
Timer::Timer (void) :
        Timer_List (TRANSPORT_HASHING_BUCKETS),
        Timer_Event_Free_Stack ()
{
     /*
     **     Get the current time from Windows
     */
    Last_Timer_Value = GetTickCount ();
    Maximum_Timer_Events = 0;
    Timer_Event_Count = 0;
    First_Timer_Event_In_Chain=NULL;
}


/*
 *    ~Timer (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the destructor for the timer class.  This routine frees all
 *        memory associated with timer events.
 */
Timer::~Timer (void)
{
    PTimerEvent        lpTimerEv;

    Timer_List.reset();
    while (Timer_List.iterate ((PDWORD_PTR) &lpTimerEv))
        delete lpTimerEv;
}


/*
 *    TimerEventHandle    Timer::CreateTimerEvent (
 *                                 ULONG            timer_duration,
 *                                USHORT            control_flags,
 *                                IObject *            object_ptr,
 *                                PTimerFunction    timer_func_ptr)
 *
 *    Public
 *
 *    Functional Description:
 *        This routine is called to create a timer event.  The routine stores the
 *        information passed-in in a TimerEvent structure.  When the timer expires
 *        the function will be called.
 *
 */
TimerEventHandle Timer::CreateTimerEvent
(
    ULONG               timer_duration,
    USHORT              control_flags,
    IObject            *object_ptr,
    PTimerFunction      timer_func_ptr
)
{
    TimerEventHandle    timer_event=NULL;
    PTimerEvent            next_timer_event;
    PTimerEvent            timer_event_ptr;

     /*
     **    Get the current time from Windows
     */
    Last_Timer_Value = GetTickCount ();

    if (Maximum_Timer_Events > Timer_Event_Count)
    {
          /*
          ** Get the next available handle from the free stack
          */
        timer_event = (TimerEventHandle) Timer_Event_Free_Stack.get();
        Timer_Event_Count++;
    }
    else
    {
         /*
         **    Assign the timer event counter to the handle
         */
        timer_event = ++Timer_Event_Count;
        Maximum_Timer_Events++;
    }
     /*
     **    If this is the first event to be created, keep track of it
     **    so when we iterate through the list, we will know where to
     **    start.
     */
    timer_event_ptr = new TimerEvent;
    if (First_Timer_Event_In_Chain == NULL)
    {
        First_Timer_Event_In_Chain = timer_event_ptr;
        next_timer_event = NULL;
    }
    else
    {
        next_timer_event = First_Timer_Event_In_Chain;
        First_Timer_Event_In_Chain -> previous_timer_event =
            timer_event_ptr;

    }
    First_Timer_Event_In_Chain = timer_event_ptr;
    Timer_List.insert ((DWORD_PTR) timer_event, (DWORD_PTR) timer_event_ptr);
     /*
     **    Fill in the TimerEvent structure
     */
    timer_event_ptr->event_handle=timer_event;
    timer_event_ptr->timer_duration = timer_duration;
    timer_event_ptr->total_duration = timer_duration;
    timer_event_ptr->object_ptr = object_ptr;
    timer_event_ptr->timer_func_ptr = timer_func_ptr;
    timer_event_ptr->control_flags = control_flags | TIMER_EVENT_IN_USE;
    timer_event_ptr->next_timer_event = next_timer_event;
    timer_event_ptr->previous_timer_event = NULL;

    return (timer_event);
}


/*
 *    TimerError    Timer::DeleteTimerEvent (TimerEventHandle    timer_event)
 *
 *    Public
 *
 *    Functional Description:
 *        This routine is called by the user to delete a timer event that is
 *        currently active.
 */
TimerError    Timer::DeleteTimerEvent (TimerEventHandle    timer_event)
{
    TimerError        return_value;
    PTimerEvent        timer_event_ptr;
    PTimerEvent        previous_timer_event_ptr;
    PTimerEvent        next_timer_event_ptr;

    if (Timer_List.find ((DWORD_PTR) timer_event, (PDWORD_PTR) &timer_event_ptr) == FALSE)
        return_value = TIMER_INVALID_TIMER_HANDLE;
    else
    {
        Timer_List.remove ((DWORD) timer_event);
        if (!(timer_event_ptr->control_flags & TIMER_EVENT_IN_USE))
            return_value = TIMER_INVALID_TIMER_HANDLE;
        else
        {
            if (timer_event_ptr->previous_timer_event == NULL)
                First_Timer_Event_In_Chain =
                        timer_event_ptr->next_timer_event;
            else
            {
                previous_timer_event_ptr =
                        timer_event_ptr->previous_timer_event;
                previous_timer_event_ptr->next_timer_event =
                        timer_event_ptr->next_timer_event;
            }
            if (timer_event_ptr->next_timer_event != NULL)
            {
                next_timer_event_ptr =
                        timer_event_ptr->next_timer_event;
                next_timer_event_ptr->previous_timer_event =
                        timer_event_ptr->previous_timer_event;
            }
            delete timer_event_ptr;
            Timer_Event_Free_Stack.append ((DWORD) timer_event);
            --Timer_Event_Count;

            return_value = TIMER_NO_ERROR;
        }
    }
    return (return_value);
}


/*
 *    void    Timer::ProcessTimerEvents (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This routine MUST be called frequently and regularly so that we can
 *        manage our timers.  This function gets the current system time and
 *        goes through each of the timers to see which have expired.  If a timer
 *        has expired, we call the function associated with it.  Upon return,
 *        if the timer was marked as a one-shot event, we remove it from our
 *        list of timers.
 */
void    Timer::ProcessTimerEvents (void)
{
    TimerEventHandle    timer_event;
    TimerEventHandle    next_timer_event;
    PTimerEvent            timer_event_ptr;
    IObject *                object_ptr;
    PTimerFunction        timer_func_ptr;
    ULONG                timer_increment;
    DWORD                timer_value;


    if (!First_Timer_Event_In_Chain)
        return;

     /*
     **    Get the current time
     */
    timer_value = GetTickCount ();
    timer_increment = timer_value - Last_Timer_Value;
    Last_Timer_Value = timer_value;

    next_timer_event = First_Timer_Event_In_Chain->event_handle;

     /*
     **    Go through each of the timer events to see if they have expired
     */
    while (Timer_List.find ((DWORD_PTR) next_timer_event, (PDWORD_PTR) &timer_event_ptr))
    {
        timer_event = timer_event_ptr->event_handle;
         /*
         **    Has the timer expired?
         */
        if (timer_event_ptr->timer_duration <= timer_increment)
        {
            object_ptr = timer_event_ptr->object_ptr;
            timer_func_ptr = timer_event_ptr->timer_func_ptr;

             /*
             **    Call the function before deleting...
             ** otherwise the function could manipulate the list
             ** and we wouldn't know if the one we're pointing to
             **    is still valid
             */
            (object_ptr->*timer_func_ptr) (timer_event);
             //     Get the next timer_event_handle
            if (timer_event_ptr->next_timer_event)
                next_timer_event = timer_event_ptr->next_timer_event->event_handle;
            else
                next_timer_event = NULL;
            if (timer_event_ptr->control_flags & TIMER_EVENT_ONE_SHOT)
                DeleteTimerEvent (timer_event);
            else
                timer_event_ptr->timer_duration =
                        timer_event_ptr->total_duration;
        }
        else
        {
             // Get the next timer_event_handle
            if (timer_event_ptr->next_timer_event)
                next_timer_event = timer_event_ptr->next_timer_event->event_handle;
            else
                next_timer_event = NULL;
            timer_event_ptr->timer_duration -= timer_increment;
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\tprtcore.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    TransportController.cpp
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the TransportController class
 *
 *    Private Instance Variables:
 *        Logical_Connection_List        -    This list uses the LogicalHandle
 *                                as a key and a pointer to a
 *                                TransportConnectionStruct as the value.  This
 *                                structure holds all of the pertinent information
 *                                about the connection.
 *        Protocol_Stacks        -    This list uses the physical handle as a key and
 *                                a pointer to a pointer to a object as the value.
 *                                Sometimes we need to find the T123 object
 *                                associated with a physical handle
 *        Message_List        -    Owner callback calls are placed in this list if
 *                                we can not process them immediately.
 *        Controller            -    Address of the PSTNController
 *        Emergency_Shutdown    -    Set to TRUE if we have encountered a situation
 *                                where the integrity of the Transport has been
 *                                compromised.  As a result, all connections will
 *                                be purged.
 *        Poll_Active            -    Set to TRUE while we are in a PollReceiver() or
 *                                PollTransmitter() call.  This solves our re-
 *                                entrancy problems.
 *
 *    Caveats:
 *        None
 *
 *    Author:
 *        James W. Lawwill
 */
#include "tprtcore.h"


/*
 *    TransportController::TransportController (
 *                            PTransportResources    transport_resources)
 *
 *    Public
 *
 *    Functional Description:
 *        TransportController constructor.  We instantiate the PSTNController
 *        and initialize the T123 class.
 */
TransportController::TransportController(void)
:
    Protocol_Stacks (TRANSPORT_HASHING_BUCKETS),
    Logical_Connection_List (TRANSPORT_HASHING_BUCKETS)
{
    TRACE_OUT(("TransportController::TransportController"));

    Emergency_Shutdown = FALSE;
    Poll_Active = FALSE;
}


/*
 *    TransportController::~TransportController (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the TransportController destructor.  All allocated memory is
 *        released and all lists are cleared
 */
TransportController::~TransportController (void)
{
    TRACE_OUT(("TransportController::~TransportController"));

    Reset (FALSE);
}


TransportError TransportController::CreateTransportStack
(
    BOOL                fCaller,
    HANDLE              hCommLink,
    HANDLE              hevtClose,
    PLUGXPRT_PARAMETERS *pParams
)
{
    TRACE_OUT(("TransportController::CreateTransportStack"));

    DBG_SAVE_FILE_LINE
    ComPort *comport = new ComPort(this, PHYSICAL_LAYER_MESSAGE_BASE,
                                   pParams,
                                   hCommLink,
                                   hevtClose);
    if (NULL != comport)
    {
        TransportError rc = CreateT123Stack(hCommLink, fCaller, comport, pParams);
        if (TRANSPORT_NO_ERROR == rc)
        {
            ComPortError cperr = comport->Open();
            if (COMPORT_NO_ERROR == cperr)
            {
                return TRANSPORT_NO_ERROR;
            }
        }

        ERROR_OUT(("TransportController::CreateTransportStack: cannot open comm port"));
        return TRANSPORT_INITIALIZATION_FAILED;
    }

    ERROR_OUT(("TransportController::CreateTransportStack: cannot allocate ComPort"));
    return TRANSPORT_MEMORY_FAILURE;
}


TransportError TransportController::CloseTransportStack
(
    HANDLE          hCommLink
)
{
    TRACE_OUT(("TransportController::CloseTransportStack"));

     /*
     **    If for some reason we get an error on the ConnectRequest(),
     **    take the physical connection down.
     */
    T123 *t123 = NULL;
    if (Protocol_Stacks.find((DWORD_PTR) hCommLink, (PDWORD_PTR) &t123))
    {
        RemoveLogicalConnections (hCommLink);

         /*
         **    Remove the T123 object from the lists and
         **    delete the object
         */
        Transmitter_List.remove((DWORD_PTR) t123);
        Protocol_Stacks.remove((DWORD_PTR) hCommLink);
        delete t123;
    }

    // find the physical layer through the physical handle
    ComPort *comport;
    if (! g_pComPortList2->find((DWORD_PTR) hCommLink, (PDWORD_PTR) &comport))
    {
        WARNING_OUT(("TransportController::CloseTransportStack: cannot find comport for hCommLink=%d", hCommLink));
        return TRANSPORT_PHYSICAL_LAYER_NOT_FOUND;
    }
    ASSERT(NULL != comport);

    // close and delete the device
    // g_pComPortList2->remove((DWORD) hCommLink); // removed in handling "delete event"
    comport->Release();

    return TRANSPORT_NO_ERROR;
}


/*
 *    TransportError    TransportController::ConnectRequest (
 *                                    TransportAddress        transport_address,
 *                                    TransportPriority        transport_priority,
 *                                    LogicalHandle *           logical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initiates a connection.  It passes the transport address
 *        to the PSTN Controller.  It will either deny the request or accept the
 *        request and call us back when the physical connection is established.
 *
 *        We return the transport connection handle in the logical_handle
 *        address.  Although we return this transport number to the user, it
 *        is not ready for data transfer until the user receives the
 *        TRANSPORT_CONNECT_INDICATION message via the callback.  At that point,
 *        the logical connection is up and running.
 */
TransportError TransportController::ConnectRequest
(
    LogicalHandle      *logical_handle,
    HANDLE              hCommLink,          // physical handle
    TransportPriority   transport_priority
)
{
    TRACE_OUT(("TransportController::CreateConnection"));

    *logical_handle = GetNextLogicalHandle();
    if (INVALID_LOGICAL_HANDLE == *logical_handle)
    {
        ERROR_OUT(("TransportController::ConnectRequest: cannot allocate logical handle"));
        return TRANSPORT_MEMORY_FAILURE;
    }

    // find the physical layer through the physical handle
    ComPort *comport;
    if (! g_pComPortList2->find((DWORD_PTR) hCommLink, (PDWORD_PTR) &comport))
    {
        ERROR_OUT(("TransportController::ConnectRequest: cannot find comport for hCommLink=%d", hCommLink));
        return TRANSPORT_PHYSICAL_LAYER_NOT_FOUND;
    }
    ASSERT(NULL != comport);

     /*
     **    Register the connection handle in out Logical_Connection_List. After the
     **    physical connection is established, we will create a T123 object
     ** and request a logical connection to the remote site.
     **
     **    This structure contains the information necessary to maintain the
     ** logical connection.
     **
     **    The t123_connection_requested is set to TRUE when we have issued
     **    a ConnectRequest() to the T123 object for this logical connection.
     */
    DBG_SAVE_FILE_LINE
    PLogicalConnectionStruct pConn = new LogicalConnectionStruct;
    if (pConn == NULL)
    {
        ERROR_OUT(("TransportController::ConnectRequest: cannot to allocate LogicalConnectionStruct"));
        return (TRANSPORT_MEMORY_FAILURE);
    }

    pConn->fCaller = TRUE;
    pConn->comport = comport;
    pConn->t123 = NULL;
    pConn->t123_connection_requested = FALSE;
    pConn->t123_disconnect_requested = FALSE;
    pConn->priority = transport_priority;
    pConn->hCommLink = hCommLink;
    Logical_Connection_List.insert((DWORD_PTR) *logical_handle, (DWORD_PTR) pConn);

    return NewConnection(hCommLink, TRUE, comport);
}


/*
 *    TransportError    TransportController::ConnectResponse (
 *                                            LogicalHandle    logical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the user in response to a
 *        TRANSPORT_CONNECT_INDICATION callback from us.  By making this call the
 *        user is accepting the call.  If the user does not want to accept the
 *        he should call DisconnectRequest ();
 */
TransportError TransportController::ConnectResponse
(
    LogicalHandle       logical_handle
)
{
    TRACE_OUT(("TransportController::ConnectResponse"));

    PLogicalConnectionStruct   pConn;
    PT123                      t123;

     /*
     **    If this is an invalid handle, return error
     */
    if (! Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn))
        return (TRANSPORT_NO_SUCH_CONNECTION);

    t123 = pConn -> t123;

     /*
     **    If the user calls this function before the T123 object is created, that
     **    is an error
     */
    return (t123 != NULL) ? t123->ConnectResponse(logical_handle) : TRANSPORT_NO_SUCH_CONNECTION;
}


/*
 *    TransportError    TransportController::DisconnectRequest (
 *                                            LogicalHandle    logical_handle,
 *                                            BOOL            trash_packets)
 *
 *    Public
 *
 *    Functional Description:
 *        This function issues a Disconnect request to the T123 object (if it
 *        exists).  If T123 does not exist, it hangs up the physical connection.
 */
TransportError TransportController::DisconnectRequest
(
    LogicalHandle       logical_handle,
    UINT_PTR                trash_packets
)
{
    TRACE_OUT(("TransportController::DisconnectRequest"));

    PhysicalHandle              physical_handle;
    PLogicalConnectionStruct    pConn;
    BOOL                        transport_found;
    PT123                       t123;
    PMessageStruct              passive_message;
    TransportError              rc = TRANSPORT_NO_ERROR;

     /*
     **    If the logical connection handle is not registered, return error
     */
    if (Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn) == FALSE)
        return (TRANSPORT_NO_SUCH_CONNECTION);

    TRACE_OUT(("TPRTCTRL: DisconnectRequest for logical handle %d", logical_handle));

     /*
     **    Calling this function during a callback from this transport
     **    is a re-entrancy problem.  In this case, we add a message to
     **    our Message_List and process the request later.
     */
    if (! Poll_Active)
    {
         /*
         **    We set the t123_disconnect_requested to TRUE at this point so
         **    that when we get the TPRT_DISCONNECT_INDICATION message back
         **    from the t123 object, we will know who originated the
         **    operation.  If we originated the operation locally, we do not
         **    issue a TRANSPORT_DISCONNECT_INDICATION to the user.
         */
        pConn -> t123_disconnect_requested = TRUE;

         /*
         **    If a T123 object is associated with this object, issue a disconnect
         */
        t123 = pConn -> t123;
        if (t123 != NULL)
        {
            t123 -> DisconnectRequest (logical_handle, trash_packets);
        }
        else
        {
             /*
             **    This occurs if the user wants to terminate the connection
             **    before it comes all the way up
             **
             **    Remove the transport connection handle from the
             **    Logical_Connection_List
             */
            Logical_Connection_List.remove (logical_handle);
            delete pConn;
        }
    }
    else
    {
         /*
         **    If we are in the middle of a PollReceiver() or PollTransmitter(),
         **    and this function is being called  during a callback from this
         **    transport, save the message and process it later.
         */
        DBG_SAVE_FILE_LINE
        passive_message = new MessageStruct;
        if (passive_message != NULL)
        {
            passive_message -> message = TPRT_DISCONNECT_REQUEST;
            passive_message -> parameter1 = (void *) logical_handle;
            passive_message -> parameter2 = (void *) trash_packets;
            Message_List.append ((DWORD_PTR) passive_message);
        }
        else
        {
            ERROR_OUT(("TransportController::DisconnectRequest: cannot allocate MessageStruct"));
            rc = TRANSPORT_MEMORY_FAILURE;
        }
    }

    return rc;
}


/*
 *    TransportError    TransportController::EnableReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function allows data packets to be sent to the user application.
 *        Prior to this call, we must have sent a data packet to the user and
 *        the user must not have been able to accept it.  When this happens, the
 *        user must issue this call to re-enable TRANSPORT_DATA_INDICATIONs.
 *        callbacks.
 */
void TransportController::EnableReceiver(void)
{
    TRACE_OUT(("TransportController::EnableReceiver"));

    PT123                       t123;
    PLogicalConnectionStruct    pConn;

     /*
     **    Go through each of the Transports and enable the receivers
     */
    Logical_Connection_List.reset();
    while (Logical_Connection_List.iterate((PDWORD_PTR) &pConn))
    {
        t123 = pConn -> t123;

         /*
         **    If the protocol stack pointer is set to NULL, then we have not
         **    realized that the socket is up and functional.
         */
        if (t123 != NULL)
        {
            t123 -> EnableReceiver ();
        }
    }
}


/*
 *    TransportError    TransportController::DataRequest (
 *                                            LogicalHandle    logical_handle,
 *                                            LPBYTE            user_data,
 *                                            ULONG            user_data_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is used to send a data packet to the remote site.
 *        This function passes the request to the T123 stack associated with
 *        the transport connection handle
 */
TransportError TransportController::DataRequest
(
    LogicalHandle       logical_handle,
    LPBYTE              user_data,
    ULONG               user_data_length
)
{
    TRACE_OUT(("TransportController::DataRequest"));

    PLogicalConnectionStruct    pConn;
    PT123                       t123;

     /*
     **    Verify that this connection exists and is ready for data
     */
    if (! Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn))
    {
        WARNING_OUT(("TPRTCTRL: DataRequest: Illegal logical_handle"));
        return (TRANSPORT_NO_SUCH_CONNECTION);
    }

     /*
     **    Attempt to send that data to the T123 Layer
     */
    t123 = pConn -> t123;
    return (t123 != NULL) ? t123->DataRequest(logical_handle, user_data, user_data_length) :
                            TRANSPORT_NOT_READY_TO_TRANSMIT;
}


/*
 *    TransportError    TransportController::PurgeRequest (
 *                                            LogicalHandle    logical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to remove data from our output queues.  The
 *        user application usually calls this to speed up the disconnect process.
 */
TransportError TransportController::PurgeRequest
(
    LogicalHandle       logical_handle
)
{
    TRACE_OUT(("TransportController::PurgeRequest"));

    PLogicalConnectionStruct    pConn;
    PT123                       t123;

     /*
     **    If the transport connection handle is not registered, return error
     */
    if (! Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn))
        return (TRANSPORT_NO_SUCH_CONNECTION);

    t123 = pConn -> t123;
    return (t123 != NULL) ? t123->PurgeRequest(logical_handle) : TRANSPORT_NO_ERROR;
}


/*
 *    void    TransportController::PollReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to give us a chance to process incoming data
 */
void TransportController::PollReceiver(void)
{
    // TRACE_OUT(("TransportController::PollReceiver"));

    PT123    t123;

    if (! Poll_Active)
    {
        ProcessMessages ();
        Poll_Active = TRUE;

        if (! Transmitter_List.isEmpty())
        {
            Transmitter_List.reset();
            while (Transmitter_List.iterate((PDWORD_PTR) &t123))
            {
                t123-> PollReceiver ();
            }

              /*
             **    The following code removes the first t123 object from the
             **    list and puts it at the end of the list.  This attempts to
             **    give the t123 objects equal access to the user application.
             **    If we did not do this, one t123 object would always be able
             **    to send its data to the user application and other t123
             **    objects would be locked out.
             */
            Transmitter_List.append (Transmitter_List.get ());
        }
        Poll_Active = FALSE;
    }
}


/*
 *    void    TransportController::PollReceiver (
 *                                    PhysicalHandle    physical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function gives the t123 object associated with this physical
 *        handle a chance to process incoming data.
 */
void TransportController::PollReceiver
(
    PhysicalHandle          physical_handle
)
{
    // TRACE_OUT(("TransportController::PollReceiver"));

    PT123    t123;

    if (! Poll_Active)
    {
        ProcessMessages ();
        Poll_Active = TRUE;

         /*
         **    See if there is a t123 object associated with this
         **    physical handle
         */
        if (Protocol_Stacks.find((DWORD_PTR) physical_handle, (PDWORD_PTR) &t123))
        {
            if (t123->PollReceiver() == PROTOCOL_LAYER_ERROR)
            {
                Transmitter_List.remove((DWORD_PTR) t123);
                Protocol_Stacks.remove((DWORD_PTR) physical_handle);
                delete t123;
            }
        }

        Poll_Active = FALSE;
    }
}


/*
 *    void    TransportController::PollTransmitter (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes output data to remote sites.  This
 *        function MUST be called on a REGULAR and FREQUENT basis so that
 *        we can maintain the physical connections in a timely manner.
 */
void TransportController::PollTransmitter(void)
{
    // TRACE_OUT(("TransportController::PollTransmitter"));

    if (! Poll_Active)
    {
        PT123        t123;

        Poll_Active = TRUE;

         /*
         **    Allow each t123 object to transmit any data it has available.
         */
        Transmitter_List.reset();
        while (Transmitter_List.iterate ((PDWORD_PTR) &t123))
        {
            t123->PollTransmitter ();
        }

        Poll_Active = FALSE;
        ProcessMessages ();
    }
}


/*
 *    void    TransportController::PollTransmitter (
 *                                    PhysicalHandle    physical_handle)
 *
 *    Public
 *
 *    Functional Description:
 */
void TransportController::PollTransmitter
(
    PhysicalHandle          physical_handle
)
{
    // TRACE_OUT(("TransportController::PollTransmitter"));

    PT123    t123;

    if (! Poll_Active)
    {
        Poll_Active = TRUE;

         /*
         **    See if there is a t123 object associated with this
         **    physical handle
         */
        if (Protocol_Stacks.find((DWORD_PTR) physical_handle, (PDWORD_PTR) &t123))
        {
            t123->PollTransmitter();
        }

        Poll_Active = FALSE;
        ProcessMessages ();
    }
}


/*
 *    PhysicalHandle    TransportController::GetPhysicalHandle (
 *                        LogicalHandle    logical_handle);
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the physical handle associated with the
 *        logical handle.
 */
PhysicalHandle    TransportController::GetPhysicalHandle (
                                        LogicalHandle    logical_handle)
{
    TRACE_OUT(("TransportController::GetPhysicalHandle"));

    PhysicalHandle              physical_handle;
    PLogicalConnectionStruct    pConn;

    if (Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn))
    {
        physical_handle = pConn -> hCommLink;
    }
    else
    {
        physical_handle = 0;
    }

    return (physical_handle);
}


/*
 *    ULONG    TransportController::OwnerCallback (
 *                                    CallbackMessage    message,
 *                                    ULONG            parameter1,
 *                                    ULONG            parameter2,
 *                                    PVoid            parameter3)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the PSTNController and the T123 object(s).
 *        This function is called when a significant event occurs.  This gives the
 *        lower objects the ability to communicate with the higher layer.
 */
ULONG_PTR TransportController::OwnerCallback
(
    ULONG       message,
    void       *parameter1,
    void       *parameter2,
    void       *parameter3
)
{
    TRACE_OUT(("TransportController::OwnerCallback"));

    PMessageStruct              passive_message;
    LogicalHandle               logical_handle;
    PLogicalConnectionStruct    pConn;
    LegacyTransportID           transport_identifier;
    ULONG_PTR                   return_value = 0;
    PT123                       t123;

    message = message - TRANSPORT_CONTROLLER_MESSAGE_BASE;

    switch (message)
    {
    case TPRT_CONNECT_INDICATION:
         /*
         **    The TPRT_CONNECT_INDICATION message comes from a T123
         **    object when the remote site is attempting to make a
         **    logical connection with    us.  We issue a callback to the
         **    user to notify him of the request
         */

        // LONCHANC: we automatically accept the call
        ConnectResponse((LogicalHandle) parameter1);

        transport_identifier.logical_handle = (LogicalHandle) parameter1;

        if (Logical_Connection_List.find((DWORD_PTR) parameter1, (PDWORD_PTR) &pConn))
        {
            transport_identifier.hCommLink = pConn->hCommLink;
        }
        else
        {
            transport_identifier.hCommLink = NULL;
        }

        TRACE_OUT(("TPRTCTRL: CONNECT_INDICATION: physical_handle = %d",
            transport_identifier.hCommLink));

        ::NotifyT120(TRANSPORT_CONNECT_INDICATION, &transport_identifier);
        break;

    case TPRT_CONNECT_CONFIRM:
         /*
         **    The TPRT_CONNECT_CONFIRM message comes from a T123 object
         **    when a logical connection that we requested is up and
         **    running.  We notify the user of this by issuing a callback.
         */
        transport_identifier.logical_handle = (LogicalHandle) parameter1;

        if (Logical_Connection_List.find((DWORD_PTR) parameter1, (PDWORD_PTR) &pConn))
        {
            transport_identifier.hCommLink = pConn->hCommLink;
        }
        else
        {
            transport_identifier.hCommLink = NULL;
        }

        TRACE_OUT(("TPRTCTRL: CONNECT_CONFIRM: physical_handle = %d",
            transport_identifier.hCommLink));

        ::NotifyT120(TRANSPORT_CONNECT_CONFIRM, &transport_identifier);
        break;

    case REQUEST_TRANSPORT_CONNECTION:
         /*
         **    This message is issued when a T123 object is making a new
         **    logical connection and needs a new logical handle.
         **
         **    If we return INVALID_LOGICAL_HANDLE, we wer not able to
         **    get a handle.
         */
        logical_handle = GetNextLogicalHandle();
        if (logical_handle == INVALID_LOGICAL_HANDLE)
        {
            return_value = INVALID_LOGICAL_HANDLE;
            break;
        }

         /*
         **    Register the new transport connection handle in the
         **    Logical_Connection_List
         **
         **    Parameter1 holds the physical handle
         */
        DBG_SAVE_FILE_LINE
        pConn = new LogicalConnectionStruct;
        if (pConn != NULL)
        {
            Logical_Connection_List.insert (logical_handle, (DWORD_PTR) pConn);
            pConn->fCaller = FALSE;
            pConn->hCommLink = (PhysicalHandle) parameter1;
            Protocol_Stacks.find((DWORD_PTR) parameter1, (PDWORD_PTR) &t123);
            pConn -> t123 = t123;

             /*
             **    Set the t123_connection_requested to TRUE.  We didn't
             **    actually make a ConnectRequest() but the T123 object does
             **    know about the connection
             */
            pConn -> t123_connection_requested = TRUE;
            pConn -> t123_disconnect_requested = FALSE;
            return_value = logical_handle;
        }
        else
        {
            TRACE_OUT(("TPRTCTRL: Unable to allocate memory "
                "for connection"));
            return_value = INVALID_LOGICAL_HANDLE;
        }
        break;

     /*
     **    The following messages can NOT be processed during the callback.
     **    They are passive messages, that is they must be saved and
     **    processed at a later time.   The BROKEN_CONNECTION and
     **    TPRT_DISCONNECT_INDICATION messages involve destroying t123
     **    objects.  If we deleted an object here and then returned to
     **    the object, this would cause a GPF.  Therefore these messages
     **    are processed later.
     **
     **    The NEW_CONNECTION callback is processed later because we want
     **    to process certain messages in the order they were received.  If
     **    we received a NEW_CONNECTION followed by a BROKEN_CONNECTION
     **    followed by a NEW_CONNECTION, and we only processed the
     **    NEW_CONNECTION messages as they were received, it would really
     **    confuse the code.
     */
    case TPRT_DISCONNECT_INDICATION:
    case BROKEN_CONNECTION:
        DBG_SAVE_FILE_LINE
        passive_message = new MessageStruct;
        if (passive_message != NULL)
        {
            passive_message -> message = message;
            passive_message -> parameter1 = parameter1;
            passive_message -> parameter2 = parameter2;
            passive_message -> parameter3 = parameter3;
            Message_List.append ((DWORD_PTR) passive_message);
        }
        else
        {
            ERROR_OUT(("TPRTCTRL: TPRT_DISCONNECT_INDICATION: cannot allocate MessageStruct"));
            Emergency_Shutdown = TRUE;
        }
        break;

    case NEW_CONNECTION:
          /*
         ** If we can not allocate the memory needed to store this
         **    message, we need to return a non-zero value to the
         **    calling routine.
         */
        DBG_SAVE_FILE_LINE
        passive_message = new MessageStruct;
        if (passive_message != NULL)
        {
            passive_message -> message = message;
            passive_message -> parameter1 = parameter1;
            passive_message -> parameter2 = parameter2;
            passive_message -> parameter3 = parameter3;
                Message_List.append ((DWORD_PTR) passive_message);
        }
        else
        {
            ERROR_OUT(("TPRTCTRL: NEW_CONNECTION: cannot allocate MessageStruct"));
            return_value = 1;
        }
        break;

    default:
        ERROR_OUT(("TPRTCTRL: OwnerCallback: Illegal message = %lx", message));
        break;
    }
    return (return_value);
}


/*
 *    void TransportController::ProcessMessages (void)
 *
 *    Functional Description
 *        This function is called periodically to process any passive owner
 *        callbacks.  If an owner callback can not be processed immediately,
 *        it is put into the Message_List and processed at a later time.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void TransportController::ProcessMessages(void)
{
    // TRACE_OUT(("TransportController::ProcessMessages"));

    ULONG                       message;
    PMessageStruct              message_struct;
    IProtocolLayer             *physical_layer;
    void                       *parameter1;
    void                       *parameter2;
    void                       *parameter3;

    LogicalHandle               logical_handle;
    PLogicalConnectionStruct    pConn;
    PhysicalHandle              physical_handle;
    BOOL                        save_message = FALSE;
    LegacyTransportID           transport_identifier;
    PT123                       t123;
    BOOL                        link_originator;
    BOOL                        disconnect_requested;
    ComPort                    *comport;

     /*
     **    This routine can not be called during a callback from this transport.
     **    In other words this code is not re-entrant.
     */
    if (Poll_Active)
        return;

     /*
     **    Emergency_Shutdown can occur if we unsuccessfully attempt to allocate
     **    memory.  In this situation, we shutdown the entire Transport
     */
    if (Emergency_Shutdown)
    {
        Reset (TRUE);
        Emergency_Shutdown = FALSE;
    }

     /*
     **    Go thru the Message_List until it is empty or until a message
     **    can not be processed.
     */
    while ((! Message_List.isEmpty ()) && (! save_message))
    {
         /*
         **    Look at the first message in the Message_List.
         */
        message_struct = (PMessageStruct) Message_List.read ();
        message = (message_struct -> message) - TRANSPORT_CONTROLLER_MESSAGE_BASE;
        parameter1 = message_struct -> parameter1;
        parameter2 = message_struct -> parameter2;
        parameter3 = message_struct -> parameter3;

        switch (message)
        {
        case NEW_CONNECTION:
            ASSERT(0); // impossible
             /*
             **    This message is issued by the PSTNController to notify us
             **    a new physical connection exists or that a previously
             **    requested connection is going to be muxed over a
             **    currently active physical connection
             **
             **    Parameter1 is the physical handle
             **    Parameter2 is a BOOL     used to tell us if
             **    Parameter3 is the address of the physical layer handling
             **    this connection.
             */
            physical_handle = (PhysicalHandle) parameter1;
            link_originator = (BOOL) (DWORD_PTR)parameter2;
            comport = (ComPort *) parameter3;

            TRACE_OUT(("TPRTCTRL: ProcessMessage NEW_CONNECTION: Physical: handle = %ld", physical_handle));

            if (TRANSPORT_NO_ERROR != NewConnection(physical_handle, link_originator, comport))
            {
                save_message = TRUE;
            }
            break;

        case BROKEN_CONNECTION:
            ASSERT(0); // impossible
             /*
             **    This message is issued by the PSTNController when a
             **    physical connection has been broken.
             **
             **    parameter1 = physical_handle
             */
            physical_handle = (PhysicalHandle) parameter1;

            TRACE_OUT(("TPRTCTRL: BROKEN_CONNECTION: phys_handle = %lx", physical_handle));

             /*
             **    RemoveLogicalConnections() terminates all logical
             **    connections associated with this physical handle.
             **    There may be logical connections in our list even
             **    though a T123 does not exist for the physical handle
             */
            TRACE_OUT(("TPRTCTRL: RemoveLogicalConnections: phys_handle = %lx", physical_handle));
            RemoveLogicalConnections (physical_handle);

             /*
             **    Check to see if there is a t123 stack associated
             **    with this physical handle.
             */
            if (Protocol_Stacks.find((DWORD_PTR) physical_handle, (PDWORD_PTR) &t123))
            {
                 /*
                 **    Remove the T123 protocol stacks from our lists and
                 **    delete it.
                 */
                Transmitter_List.remove((DWORD_PTR) t123);
                Protocol_Stacks.remove((DWORD_PTR) physical_handle);
                delete t123;
            }
            break;

        case TPRT_DISCONNECT_REQUEST:
             /*
             **    This message occurs when a DisconnectRequest() was received
             **    during a PollReceiver() call.  We can NOT process the
             **    DisconnectRequest() during our callback to the user
             **    application, but we can queue the message and process it
             **    now
             */
            DisconnectRequest((LogicalHandle) parameter1, (BOOL) (DWORD_PTR)parameter2);
            break;

        case TPRT_DISCONNECT_INDICATION:
             /*
             **    This message is received from a T123 object when a logical
             **    connection is terminated.  If the logical connection
             **    handle passed in parameter1 is INVALID_LOGICAL_HANDLE,
             **    the T123 object is telling us to terminate it.
             **
             **    parameter1 = logical_handle
             **    parameter2 = physical_handle
             **    parameter3 = BOOL     - TRUE if we requested this
             **                 disconnection.
             */
            logical_handle = (LogicalHandle) parameter1;
            physical_handle = (PhysicalHandle) parameter2;

             /*
             **    Check the physical_handle to make sure it is valid
             */
            if (! Protocol_Stacks.find((DWORD_PTR) physical_handle, (PDWORD_PTR) &t123))
            {
                ERROR_OUT(("TPRTCTRL: ProcessMessages: DISCONNECT_IND **** Illegal Physical Handle = %ld", physical_handle));
                break;
            }

             /*
             **    If the logical_handle is INVALID_LOGICAL_HANDLE, the
             **    T123 object is telling us to delete it.
             */
            if (logical_handle == INVALID_LOGICAL_HANDLE)
            {
                TRACE_OUT(("TPRTCTRL: Protocol stack deleted - phys handle = %ld", physical_handle));

                 /*
                 **    Find out the value of parameter3 before we
                 **    delete the t123 object.
                 */
                disconnect_requested = *((BOOL *) parameter3);

                 /*
                 **    Call RemoveLogicalConnections() to remove all logical
                 **    connections associated with this physical handle.
                 */
                RemoveLogicalConnections (physical_handle);

                 /*
                 **    Remove the T123 object from the lists and delete the
                 **    object
                 */
                Transmitter_List.remove((DWORD_PTR) t123);
                Protocol_Stacks.remove((DWORD_PTR) physical_handle);
                delete t123;
            }
            else
            if (Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn))
            {
                 /*
                 **    This specifies that a logical connection needs to be
                 ** removed.  We remove it from the Logical_Connection_List
                 **    and notify the user of the disconnection
                 */
                Logical_Connection_List.remove (logical_handle);

                if (! pConn->t123_disconnect_requested)
                {
                    transport_identifier.logical_handle = logical_handle;
                    transport_identifier.hCommLink = physical_handle;

                    ::NotifyT120(TRANSPORT_DISCONNECT_INDICATION, &transport_identifier);
                }
                delete pConn;
            }
            break;

        default:
            ERROR_OUT(("TPRTCTRL: ProcessMessages: Illegal message = %lx", message));
            break;
        }

         /*
         **    If save_message is TRUE, the message needs to be re-processed at a
         **    later time.
         */
        if (! save_message)
        {
            delete ((PMessageStruct) Message_List.get ());
        }
    }
}


/*
 *    void    TransportController::Reset (
 *                                    BOOL        notify_user)
 *
 *    Functional Description
 *        This function deletes all stacks and TCs.  If the notify_user flag is
 *        set to TRUE, it makes a callback to the user.
 *
 *    Formal Parameters
 *        notify_user        (i)    -    Notify User flag
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void TransportController::Reset
(
    BOOL            notify_user
)
{
    TRACE_OUT(("TransportController::Reset"));

    LogicalHandle               logical_handle;
    PMessageStruct              message_struct;
    LegacyTransportID           transport_identifier;
    PhysicalHandle              physical_handle;
    PLogicalConnectionStruct    pConn;
    PT123                       t123;

    TRACE_OUT(("TPRTCTRL: reset: notify_user = %d", notify_user));

     /*
     **    Delete all of the stacks
     */
    Protocol_Stacks.reset();
    while (Protocol_Stacks.iterate((PDWORD_PTR) &t123))
    {
        delete t123;
    }

    Protocol_Stacks.clear ();
    Transmitter_List.clear ();

     /*
     **    Empty the message list
     */
    while (! Message_List.isEmpty ())
    {
        delete ((PMessageStruct) Message_List.get ());
    }

     /*
     **    Empty the Logical_Connection_List
     */
    Logical_Connection_List.reset();
    while (Logical_Connection_List.iterate((PDWORD_PTR) &pConn, (PDWORD_PTR) &logical_handle))
    {
        if (pConn != NULL)
        {
            physical_handle = pConn->hCommLink;
            delete pConn;
        }
        else
        {
            physical_handle = 0;
        }

        if (notify_user)
        {
            transport_identifier.logical_handle = logical_handle;
            transport_identifier.hCommLink = physical_handle;

            ::NotifyT120(TRANSPORT_DISCONNECT_INDICATION, &transport_identifier);
        }
    }
    Logical_Connection_List.clear ();
}


/*
 *    BOOL        TransportController::NewConnection (
 *                                        PhysicalHandle    physical_handle,
 *                                        BOOL             link_originator,
 *                                        IProtocolLayer *    physical_layer)
 *
 *    Functional Description
 *        This function is called when a new physical connection is created.  It
 *        creates a T123 object if necessary.
 *
 *    Formal Parameters
 *        physical_handle    (i)    -    physical handle of the new physical connection
 *        link_originator    (i)    -    TRUE if we initiated the connection.
 *        physical_layer    (i)    -    Address of the physical layer.
 *
 *    Return Value
 *        TRUE, if the new connection was successfully executed.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
TransportError TransportController::CreateT123Stack
(
    PhysicalHandle      hCommLink,
    BOOL                link_originator, // fCaller
    ComPort            *comport,
    PLUGXPRT_PARAMETERS *pParams
)
{
    TRACE_OUT(("TransportController::CreateT123Stack"));

    TransportError rc = TRANSPORT_NO_ERROR;

     /*
     **    Do we need to create a new t123 stack for this physical connection.
     */
    T123 *t123 = NULL;
    if (! Protocol_Stacks.find((DWORD_PTR) hCommLink, (PDWORD_PTR) &t123))
    {
        BOOL initialized;
        DBG_SAVE_FILE_LINE
        t123 = new T123(this,
                        TRANSPORT_CONTROLLER_MESSAGE_BASE,
                        link_originator,
                        comport,
                        hCommLink,
                        pParams,
                        &initialized);
        if (t123 != NULL && initialized)
        {
             /*
             **    Put the T123 object into the Protocol_Stacks
             **    and Transmitter_List arrays
             */
            Protocol_Stacks.insert((DWORD_PTR) hCommLink, (DWORD_PTR) t123);
            Transmitter_List.append((DWORD_PTR) t123);
        }
        else
        {
            ERROR_OUT(("TPRTCTRL: CreateT123Stack: cannot allocate T123"));
            delete t123;
            rc = TRANSPORT_MEMORY_FAILURE;
        }
    }

    return rc;
}


TransportError TransportController::NewConnection
(
    PhysicalHandle      hCommLink,
    BOOL                link_originator,
    ComPort            *comport
)
{
    TRACE_OUT(("TransportController::NewConnection"));

    LogicalHandle               logical_handle;
    PLogicalConnectionStruct    pConn;
    BOOL                        initialized;
    T123                       *t123;
    TransportError              rc;

    if (! Protocol_Stacks.find((DWORD_PTR) hCommLink, (PDWORD_PTR) &t123))
    {
        ERROR_OUT(("TransportController::NewConnection: cannot find T123 stack, hCommLink=%d", hCommLink));
        return TRANSPORT_NO_T123_STACK;
    }

     /*
     **    Go through each of the logical connections to find the
     **    ones that are waiting for this physical connection to be
     **    established.  The PSTNController object issues a
     **    NEW_CONNECTION callback for each logical connection that
     **    needs to be initiated.
     */
    Logical_Connection_List.reset();
    while (Logical_Connection_List.iterate((PDWORD_PTR) &pConn, (PDWORD_PTR) &logical_handle))
    {
         /*
         **    Compare the physical handles, if they are the same,
         **    check to see if this logical connection has already issued
         **    a ConnectRequest() to the T123 object.
         */
        if (hCommLink == pConn->hCommLink)
        {
             /*
             **    See if this connection has already issued a ConnectRequest
             */
            if (! pConn->t123_connection_requested)
            {
                 /*
                 **    Fill in the transport structure.
                 */
                pConn->t123 = t123;
                pConn->comport = comport;
                pConn->t123_connection_requested = TRUE;

                 /*
                 **    Issue a Connect Request to the T123 object
                 */
                rc = t123->ConnectRequest(logical_handle, pConn->priority);

                 /*
                 **    If for some reason we get an error on the ConnectRequest(),
                 **    take the physical connection down.
                 */
                if (rc != TRANSPORT_NO_ERROR)
                {
                    RemoveLogicalConnections (hCommLink);

                     /*
                     **    Remove the T123 object from the lists and
                     **    delete the object
                     */
                    Transmitter_List.remove((DWORD_PTR) t123);
                    Protocol_Stacks.remove((DWORD_PTR) hCommLink);
                    delete t123;
                }
            }
        }
    }

    return TRANSPORT_NO_ERROR;
}


/*
 *    LogicalHandle TransportController::GetNextLogicalHandle (void);
 *
 *    Functional Description
 *        This function returns an available logical handle
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        The next available logical handle
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
LogicalHandle TransportController::GetNextLogicalHandle (void)
{
    LogicalHandle    logical_handle = 1;

     /*
     **    Go thru the Logical_Connection_list, looking for the first
     **    available entry
     */
    while (Logical_Connection_List.find (logical_handle) &&
           (logical_handle != INVALID_LOGICAL_HANDLE))
    {
        logical_handle++;
    }

    return (logical_handle);
}


/*
 *    void    TransportController::RemoveLogicalConnections (
 *                                    PhysicalHandle    physical_handle)
 *
 *    Functional Description
 *        This function removes all logical connections associated with the
 *        passed in physical handle
 *
 *    Formal Parameters
 *        physical_handle    (i)    -    PSTNController generated physical handle
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void TransportController::RemoveLogicalConnections
(
    PhysicalHandle          physical_handle
)
{
    TRACE_OUT(("TransportController::RemoveLogicalConnections"));

    LogicalHandle               logical_handle;
    PLogicalConnectionStruct    pConn;
    LegacyTransportID           transport_identifier;

     /*
     **    Go thru each logical connection to see if it is associated with the
     **    specified physical handle.
     */
    Logical_Connection_List.reset();
    while (Logical_Connection_List.iterate((PDWORD_PTR) &pConn, (PDWORD_PTR) &logical_handle))
    {
         /*
         **    If the physical handle is used by the logical connection,
         **    delete the structure and remove it from the Logical_Connection_List
         */
        if (physical_handle == pConn->hCommLink)
        {
            Logical_Connection_List.remove(logical_handle);

             /*
             **    Notify the user that the logical connection is no longer valid
             **    If the user had previously issued a DisconnectRequest(), don't
             **    issue the TRANSPORT_DISCONNECT_INDICATION callback.  The user
             **    isn't expecting a callback.
             */
            if (! pConn->t123_disconnect_requested)
            {
                transport_identifier.logical_handle = logical_handle;
                transport_identifier.hCommLink = physical_handle;

                ::NotifyT120(TRANSPORT_DISCONNECT_INDICATION, &transport_identifier);
            }
            delete pConn;

             /*
             **    Since we removed an entry from the Logical_Connection_List,
             **    reset the iterator.
             */
            Logical_Connection_List.reset ();
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\tprtcore.h ===
/*    TransportController.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the Transport Controller file for the MCATPSTN DLL.
 *
 *        This DLL instantiates a PSTNController which controls the
 *        making and breaking of connections.  This routine also constructs and
 *        destructs T123 stacks.  When the physical layer creates or detects a
 *        connection this class is notified.  It then instantiates a T123 object
 *        which sets up a T123 stack to control this physical connection.  The
 *        T123 stace notifies this controller when a connection is up and running.
 *        It also notifies this controller if the link is broken for some reason.
 *        As a result, this controller notifies the user of the new or broken
 *        connection.
 *
 *        When the user wants to make a data request of a specific transport
 *        connection, this controller maps the connection id to a T123 stack.  The
 *        data request is passed on to that stack.  Data Indications are passed
 *        to the user by the T123 stack.  The controller does not need to know
 *        about these and lets the T123 stack handle them.
 *
 *    POLLING THE DLL:
 *        This stack is maintained by the Poll calls (PollTransmitter() and
 *        PollReceiver()).  During these calls we transmit and receive
 *        packets with the remote sites.  It is extremely important that
 *        this DLL receive a time slice from the CPU on a regular and
 *        frequent basis.  This will give us the time we need to properly
 *        maintain the link.  If these calls are not used in a frequent and
 *        regular basis, the communications link will be unproductive and
 *        could eventually be lost.
 *
 *    USER CALLBACKS:
 *        The user communicates with this DLL by making calls directly to the
 *        DLL.  The DLL communicates with the user by issuing callbacks.
 *        The TInitialize() call accepts as a parameter, a callback address and
 *        a user defined variable.  When a significant event occurs in the DLL,
 *        the DLL will jump to the callback address.  The first parameter of
 *        the callback is the message.  This could be a
 *        TRANSPORT_CONNECT_INDICATION, TRANSPORT_DISCONNECT_INDICATION, or any
 *        number of significant events.  The second parameter is a message
 *        specific parameter.  The third parameter is the user defined variable
 *        that was passed in during the TInitialize() function.  See the
 *        mcattprt.h interface file for a complete description of the callback
 *        messages.
 *
 *    MAKING A CALL:
 *        After the initialization has been done, the user will eventually,
 *        want to attempt a connection.  The user issues a TConnectRequest() call
 *        with the PSTN address of the remote location.   The connection request
 *        is passed on to the PSTNcontroller.  It eventually issues a callback to
 *        the this controller to say that the connection was successful and passes
 *        up the address of the physical layer.  If the physical handle passed up
 *        by the PSTNController is a new handle, we create a T123 object, and
 *        issue a ConnectRequest() to it.  The T123 object creates a T.123
 *        compliant stack and notifies the Controller when it is up and running.
 *        If the handle passed up from the PSTNController is currently associated
 *        with an already active T123 object, we simply make a ConnectRequest()
 *        call to the T123 object so that it will create another logical
 *        connection over    the same physical connection.
 *
 *    RECEIVING A CALL:
 *        If we receive a call from a remote location, the PSTNController notifies
 *        us that a new connection is being attempted.  We then create a new
 *        T123 stack associated with the physical connection.  The T123 stack
 *        will notify us if new a Transport Connection id need to be generated.
 *        It will also notify us when the Transport Connection is up and running.
 *
 *    SENDING PACKETS:
 *        To send data to the remote location, use the DataRequest() function
 *        call.  This controller will pass the packet to the T123 stack that it is
 *        associated with.  The send may actually occur after the call has
 *        returned to the user.
 *
 *    RECEIVING PACKETS:
 *        The user receives packets by DATA_INDICATION callbacks.  When the
 *        user makes PollReceiver() calls, the Transport Layer checks its input
 *        buffers for packets.  If a packet is found, we issue a DATA_INDICATION
 *        callback to the user with the Transport Connection handle, the address
 *        of the packet, and the packet length.
 *
 *    DISCONNECTING A TRANSPORT:
 *        To disconnect a transport connection, use the DisconnectRequest()
 *        function.  After the link has been brought down, we perform a
 *        callback to the user to verify the disconnect.
 *
 *    Caveats:
 *        None.
 *
 *    Author:
 *        James W. Lawwill
 *
 */
#ifndef    _TRANSPORT_CONTROLLER_
#define    _TRANSPORT_CONTROLLER_

#include "t123.h"

#define TRANSPORT_CONTROLLER_MESSAGE_BASE    0



 /*
 **    Each Logical Connection has a LogicalConnectionStruct associated
 **    with it.
 **
 **    physical_layer                -    Pointer to physical layer associated with
 **                                    this logical connection.
 **    physical_handle                -    Each physical connection has a
 **                                    physical_handle associated with it.
 **    protocol_stack                -    The T123 object associated with it.
 **    priority                    -    Priority of the logical connection
 **    t123_connection_requested    -    TRUE if this logical connection has issued
 **                                    a ConnectRequest() to the t123 object.
 **    t123_disconnect_requested    -    TRUE if this logical connection has issued
 **                                    a DiconnectRequest() to the t123 object.
 */
typedef struct
{
    BOOL                fCaller;
    ComPort            *comport;    // physical layer
    PhysicalHandle      hCommLink;  // physical handle
    T123               *t123;       // protocal stack
    TransportPriority   priority;
    BOOL                t123_connection_requested;
    BOOL                t123_disconnect_requested;
}
    LogicalConnectionStruct, * PLogicalConnectionStruct;


class TransportController
{
public:

    TransportController(void);
    ~TransportController (void);

         /*
         **    Functions related making and breaking a link
         */
        TransportError CreateTransportStack(
                            BOOL            fCaller,
                            HANDLE          hCommLink,
                            HANDLE          hevtClose,
                            PLUGXPRT_PARAMETERS *);
        TransportError CloseTransportStack(
                            HANDLE          hCommLink);
        TransportError ConnectRequest (
                            LogicalHandle      *logical_handle,
                            HANDLE              hCommLink,
                            TransportPriority   transport_priority = DEFAULT_PRIORITY);
        TransportError ConnectResponse (
                            LogicalHandle    logical_handle);
        TransportError DisconnectRequest (
                            LogicalHandle    logical_handle,
                            UINT_PTR            trash_packet);

         /*
         **    This function is used to send a data packet
         */
        TransportError DataRequest (
                            LogicalHandle    logical_handle,
                            LPBYTE            user_data,
                            ULONG            user_data_length);
        TransportError PurgeRequest (
                            LogicalHandle    logical_handle);
        void           EnableReceiver (void);

         /*
         **    These four functions are the heartbeat of the DLL.  Transmission
         **    and reception of data occur during these calls.
         */
        void           PollReceiver(void);
        void           PollReceiver(PhysicalHandle);
        void           PollTransmitter(void);
        void           PollTransmitter(PhysicalHandle);

         /*
         **    Miscellaneous utilities
         */
        TransportError ProcessCommand (
                            USHORT    message,
                            PVoid    input_structure,
                            PVoid    output_structure);

         /*
         **    Callback used by the PSTNController and the T123 objects
         */
        ULONG_PTR OwnerCallback(ULONG, void *p1 = NULL, void *p2 = NULL, void *p3 = NULL);

        PhysicalHandle GetPhysicalHandle (
                            LogicalHandle    logical_handle);

private:

        LogicalHandle  GetNextLogicalHandle (void);
        void           ProcessMessages (void);
        void           RemoveLogicalConnections (
                                PhysicalHandle    physical_handle);
        void           Reset (
                                BOOL        notify_user);
        TransportError NewConnection (
                                PhysicalHandle   physical_handle,
                                BOOL             link_originator,
                                ComPort         *physical_layer);
        TransportError CreateT123Stack(
                                PhysicalHandle      hCommLink,
                                BOOL                link_originator, // fCaller
                                ComPort            *comport,
                                PLUGXPRT_PARAMETERS *pParams);

private:

         /*
         **    This is a list of the physical connections we currently have.
         **    It is associated with a structure that holds each layer in
         **    the stack(s).
         */
    DictionaryClass         Protocol_Stacks; // list of T123 objects
    DictionaryClass         Logical_Connection_List;
    SListClass              Transmitter_List;
    SListClass              Message_List;

    BOOL                    Emergency_Shutdown;
    BOOL                    Poll_Active;
};

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    TransportController::TransportController (
 *                            PTransportResources    transport_resources);
 *
 *    Functional Description
 *        This is the Transport Controller constructor.  This routine instantiates
 *        a PSTNController() and routes calls to the proper location.
 *
 *    Formal Parameters
 *        transport_resources        - (i)    This is the address TransportResources
 *                                        structure.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportController::~TransportController (void)
 *
 *    Functional Description
 *        This is the TransportController destructor.  It deletes the
 *        PSTNController and any T123 objects that are alive.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::ConnectRequest (
 *                                        TransportAddress    transport_address,
 *                                        TransportPriority    transport_priority,
 *                                        LogicalHandle        *logical_handle);
 *
 *    Functional Description
 *        This function initiates a connection.  It calls the PSTNController with
 *        the transport_address so that it can start the connection procedure.
 *        When this routine returns, it does NOT mean that a connection exists.
 *        It means that a connection is in progress and will eventually be
 *        completed when the user receives a TRANSPORT_CONNECT_CONFIRM or
 *        TRANSPORT_DISCONNECT_INDICATION.
 *
 *    Formal Parameters
 *        transport_address    - (i)    Address of ascii string containing the
 *                                    telephone number or physical handle.
 *        transport_priority    - (i)    Requested priority of the connection.
 *                                    This value can be 0-14 inclusive.
 *        logical_handle        - (o)    Address of transport connection.  We return
 *                                    a unique transport connection number as the
 *                                    result of a successful dial operation.
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                    -    No Error
 *        TRANSPORT_NO_CONNECTION_AVAILABLE    -    No resources for the connection
 *        TRANSPORT_CONNECT_REQUEST_FAILED    -    Unable to reach the address
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::ConnectResponse (
 *                                            LogicalHandle    logical_handle);
 *
 *    Functional Description
 *        This function is called in response to a TRANSPORT_CONNECT_INDICATION
 *        callback.  The user should call this function or the
 *        DisconnectRequest() function if that don't want the logical connection.
 *
 *    Formal Parameters
 *        logical_handle        - (i)    Logical handle that we are responding to.
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Transport connection does not exist
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::DisconnectRequest (
 *                                            LogicalHandle    logical_handle);
 *
 *    Functional Description
 *        This function terminates the user's transport connection.  The user
 *        will receive a DISCONNECT_INDICATION when the connection is broken.
 *        If we are multiplexing multiple connections over the same physical
 *        connection, we will not break the physical comm. link until the last
 *        connection is broken.
 *
 *    Formal Parameters
 *        logical_handle         - (i)  Transport connection number to terminate
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Transport connection does not exist
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::DataRequest (
 *                                            LogicalHandle    logical_handle,
 *                                            LPBYTE            user_data,
 *                                            ULONG            user_data_length);
 *
 *    Functional Description
 *        This function is used to send a data packet to the remote location.
 *
 *    Formal Parameters
 *        logical_handle          - (i)  Transport connection number
 *        user_data              - (i)  Address of data to send
 *        user_data_length      - (i)  Length of data to send
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Transport connection does not exist
 *        TRANSPORT_PACKET_TOO_LARGE        -    Packet is bigger than acceptable
 *                                            size
 *        TRANSPORT_WRITE_QUEUE_FULL        -    Transport write queues are already
 *                                            full.
 *        TRANSPORT_NOT_READY_TO_TRANSMIT    -    The transport layer is in the
 *                                            process of building or breaking
 *                                            down the transport stack and is
 *                                            not ready for user data.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        The maximum size of a packet is 8192 bytes.
 */

/*
 *    void    TransportController::EnableReceiver (void);
 *
 *    Functional Description
 *        This function is called by the user application to notify us that
 *        it is ready for more data.  We only receive this call if we had
 *        previously attempted a TRANSPORT_DATA_INDICATION and it was rejected.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::PurgeRequest (
 *                                            LogicalHandle    logical_handle)
 *
 *    Functional Description
 *        This function is used purge outbound packets
 *
 *    Formal Parameters
 *        logical_handle - (i)  Transport connection number
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Transport connection does not exist
 *
 *    Side Effects
 *        None
 */

/*
 *    void    TransportController::PollReceiver (void);
 *
 *    Functional Description
 *        This function gives the DLL a chance to take the data received and
 *        pass it to the user.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    TransportController::PollReceiver (
 *                                    PhysicalHandle    physical_handle)
 *
 *    Functional Description
 *        This function calls the T123 stack associated with the physical
 *        handle.
 *
 *    Formal Parameters
 *        physical_handle    (i)        -    Handle of the T123 stack that we need
 *                                    to maintain.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    TransportController::PollTransmitter (void);
 *
 *    Functional Description
 *        This function processes output data to remote locations.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    TransportController::PollTransmitter (
 *                                    PhysicalHandle    physical_handle)
 *
 *    Functional Description
 *        This function calls the T123 stack associated with the physical
 *        handle.
 *
 *    Formal Parameters
 *        physical_handle    (i)        -    Handle of the T123 stack that we need
 *                                    to maintain.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::ProcessCommand (
 *                                            USHORT    message,
 *                                            PVoid    input_structure,
 *                                            PVoid    output_structure)
 *
 *    Functional Description
 *        This function passes in a command and command-specific parameters.
 *
 *    Formal Parameters
 *        message          - (i)  Message to execute
 *        input_structure  - (i)  Pointer to data type related to message
 *        output_structure - (o)  Pointer to data type related to message
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR        -    No Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TPhysicalError    TransportController::PhysicalConnectRequest (
 *                                        ULONG            connect_type,
 *                                        PVoid            connect_parameter,
 *                                        PVoid            physical_configuration,
 *                                         PPhysicalHandle    physical_handle);
 *
 *    Functional Description
 *        This function initiates a physical connection.
 *
 *    Formal Parameters
 *        connect_type             -    (i)    Type of connection to make
 *        connect_parameter          -    (i) Pointer to parameter associated with
 *                                        connect_type.
 *        physical_configuration     -    (i) Pointer to configuration structure.
 *        physical_handle         -    (o) Pointer to PhysicalHandle.
 *
 *    Return Value
 *        TPHYSICAL_NO_ERROR        -    No error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TPhysicalError    TransportController::PhysicalListen (
 *                                    ULONG                listen_type,
 *                                    PVoid                listen_parameter,
 *                                    PVoid                physical_configuration,
 *                                    PPhysicalHandle        physical_handle);
 *
 *    Functional Description
 *        This function initiates a physical connection listen.
 *
 *    Formal Parameters
 *        listen_type             -    (i)    Type of connection to make
 *        listen_parameter          -    (i) Pointer to parameter associated with
 *                                        listen_type.
 *        physical_configuration     -    (i) Pointer to configuration structure.
 *        physical_handle         -    (o) Pointer to PhysicalHandle.
 *
 *    Return Value
 *        TPHYSICAL_NO_ERROR        -    No error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TPhysicalError    TransportController::PhysicalUnlisten (
 *                                            PhysicalHandle    physical_handle);
 *
 *    Functional Description
 *        This function takes a physical connection out of the listen mode.
 *
 *    Formal Parameters
 *        physical_handle -    (i) physical handle
 *
 *    Return Value
 *        TPHYSICAL_NO_ERROR        -    No error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TPhysicalError    TransportController::PhysicalDisconnectRequest (
 *                                    PhysicalHandle            physical_handle,
 *                                    PhysicalDisconnectMode    disconnect_mode);
 *
 *    Functional Description
 *        This function disconnects a physical connection.  Depending on the
 *        disconnect_mode, the port may be released to the user.  If the
 *        mode is TPHYSICAL_NOWAIT, the port is released when the function
 *        returns.  Otherwise, it is released when the
 *        TPHYSICAL_DISCONNECT_CONFIRM callback is issued.
 *
 *    Formal Parameters
 *        physical_handle -    (i) physical handle
 *        disconnect_mode -    (i) TPHYSICAL_WAIT, if you want to shutdown cleanly.
 *                                TPHYSICAL_NOWAIT, if you want to do a hard
 *                                shutdown of the physical connection.
 *
 *    Return Value
 *        TPHYSICAL_NO_ERROR        -    No error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ULONG    TransportController::OwnerCallback (
 *                                    USHORT    layer_message,
 *                                    ULONG    parameter1,
 *                                    ULONG    parameter2,
 *                                    PVoid    parameter3);
 *
 *    Functional Description
 *        This is the owner callback function.  This function is called by
 *        objects that are owned by the TransportController.  This is basically
 *        their way of communicating with the TransportController.  When the
 *        controller calls an object (i.e. PSTNController or a T123 object), it
 *        can call the owner back with message it wants processed.  This is a
 *        little tricky but it works well.
 *
 *    Formal Parameters
 *        command_string - (i)  String containing the operation to perform.  It
 *                              also contains any parameters that are necessary
 *                              for the function.
 *        parameter1         - (i)  Message specific parameter
 *        parameter2         - (i)  Message specific parameter
 *        parameter3         - (i)  Message specific parameter
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR        -    No Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\tmemory.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    TMemory.cpp
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation of the TMemory class.
 *
 *    Private Instance Variables:
 *        Default_Buffer_Size            -    Static buffer size
 *        Base_Buffer                    -    Address of static buffer
 *        Auxiliary_Buffer            -    Address of auxiliary buffer, if needed
 *        Length                        -    Current number of bytes in buffer
 *        Auxiliary_Buffer_In_Use        -    TRUE if we are using the aux. buffer
 *        Prepend_Space                -    Amount of space to leave open at 
 *                                        beginning of buffer
 *        Fatal_Error_Count            -    Number of times we have attempted to 
 *                                        allocate a buffer and failed
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */

#include "tmemory2.h"



/*
 *    TMemory::TMemory (
 *                ULONG            total_size,
 *                USHORT            prepend_space,
 *                PTMemoryError    error)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the TMemory constructor.
 */
TMemory::TMemory (
            ULONG            total_size,
            USHORT            prepend_space,
            PTMemoryError    error)
{
    *error = TMEMORY_NO_ERROR;

    Fatal_Error_Count = 0;
    Prepend_Space = prepend_space;
    Default_Buffer_Size = total_size;
    Base_Buffer = NULL;
    Length = Prepend_Space;
    Auxiliary_Buffer = NULL;
    Auxiliary_Buffer_In_Use = FALSE;

     /*
     **    Attempt to allocate our internal buffer
     */
    Base_Buffer = (FPUChar) LocalAlloc (LMEM_FIXED, total_size);
    if (Base_Buffer == NULL)
    {
        ERROR_OUT(("TMemory: Constructor: Error allocating memory"));
        *error = TMEMORY_FATAL_ERROR;
    }
}


/*
 *    TMemory::~TMemory (
 *                void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the TMemory class destructor
 */
TMemory::~TMemory (
            void)
{
    if (Base_Buffer != NULL)
        LocalFree ((HLOCAL) Base_Buffer);

    if (Auxiliary_Buffer != NULL)
        LocalFree ((HLOCAL) Auxiliary_Buffer);
}


/*
 *    void    TMemory::Reset (
 *                        void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function resets the current buffer pointers and frees the
 *        Auxiliary buffer (if used)
 */
void    TMemory::Reset (
                    void)
{
    if (Auxiliary_Buffer_In_Use)
    {
        Auxiliary_Buffer_In_Use = FALSE;
        LocalFree ((HLOCAL) Auxiliary_Buffer);
        Auxiliary_Buffer = NULL;
    }
    Length = Prepend_Space;
}


/*
 *    TMemoryError    TMemory::Append (
 *                                HPUChar        address,
 *                                ULONG        length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function appends the buffer passed in, to our internal buffer
 */
TMemoryError    TMemory::Append (
                            HPUChar        address,
                            ULONG        length)
{
    TMemoryError    error = TMEMORY_NO_ERROR;
    FPUChar            new_address;

    if (Auxiliary_Buffer_In_Use == FALSE)
    {
         /*
         **    If the proposed buffer length is > our default buffer size,
         **    allocate an auxiliary buffer
         */
        if ((Length + length) > Default_Buffer_Size)
        {
            Auxiliary_Buffer = (HPUChar) LocalAlloc (LMEM_FIXED, Length + length);
            if (Auxiliary_Buffer == NULL)
            {
                if (Fatal_Error_Count++ >= MAXIMUM_NUMBER_REALLOC_FAILURES)
                    error = TMEMORY_FATAL_ERROR;
                else
                    error = TMEMORY_NONFATAL_ERROR;
            }
            else
            {
                Fatal_Error_Count = 0;

                 /*
                 **    Copy our current data into the auxiliary buffer
                 */
                memcpy (Auxiliary_Buffer, Base_Buffer, Length);
                memcpy (Auxiliary_Buffer + Length, address, length);
                Length += length;
                Auxiliary_Buffer_In_Use = TRUE;
            }
        }
        else
        {
            memcpy (Base_Buffer + Length, address, length);
            Length += length;
        }
    }
    else
    {
        new_address = (FPUChar) LocalReAlloc ((HLOCAL) Auxiliary_Buffer, 
                                        Length + length, LMEM_MOVEABLE);
        if (new_address == NULL)
        {
             /*
             **    If we have attempted to allocate a buffer before and failed
             **    we will eventually return a FATAL ERROR
             */
            if (Fatal_Error_Count++ >= MAXIMUM_NUMBER_REALLOC_FAILURES)
                error = TMEMORY_FATAL_ERROR;
            else
                error = TMEMORY_NONFATAL_ERROR;
        }
        else
        {
            Fatal_Error_Count = 0;

            Auxiliary_Buffer = new_address;
            memcpy (Auxiliary_Buffer + Length, address, length);
            Length += length;
        }
    }

    return (error);
}


/*
 *    TMemoryError    TMemory::GetMemory (
 *                            HPUChar    *    address,
 *                            FPULong        length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the address and used length of our internal buffer
 */
TMemoryError    TMemory::GetMemory (
                            HPUChar    *    address,
                            FPULong        length)
{

    if (Auxiliary_Buffer_In_Use)
        *address = (FPUChar) Auxiliary_Buffer;
    else
        *address = (FPUChar) Base_Buffer;
    *length = Length;

    return (TMEMORY_NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\tprtintf.h ===
#ifndef	_PSTN_TRANSPORT_INTERFACE_
#define	_PSTN_TRANSPORT_INTERFACE_

extern DictionaryClass    *g_pComPortList2;
extern SListClass         *g_pPSTNEventList;

// #include "wincfg.h"

typedef	enum
{
	READ_EVENT,
	WRITE_EVENT,
	CONTROL_EVENT
}
    WIN32Event;

typedef struct
{
	HANDLE			event;
	WIN32Event		event_type;
	BOOL            delete_event;
	PhysicalHandle	hCommLink; // physical handle
	ComPort        *comport;  // phsyical layer
}
    EventObject, * PEventObject;



class CTransportInterface : public ILegacyTransport
{
public:

    CTransportInterface(TransportError *);
    ~CTransportInterface(void);

    STDMETHODIMP_(void) ReleaseInterface(void);

    STDMETHODIMP_(TransportError) TInitialize(TransportCallback, void *user_defined);
    STDMETHODIMP_(TransportError) TCleanup(void);
    STDMETHODIMP_(TransportError) TCreateTransportStack(THIS_ BOOL fCaller, HANDLE hCommLink, HANDLE hevtClose, PLUGXPRT_PARAMETERS *pParams);
    STDMETHODIMP_(TransportError) TCloseTransportStack(THIS_ HANDLE hCommLink);
    STDMETHODIMP_(TransportError) TConnectRequest(LEGACY_HANDLE *, HANDLE hCommLink);
    STDMETHODIMP_(TransportError) TDisconnectRequest(LEGACY_HANDLE, BOOL trash_packets);
    STDMETHODIMP_(TransportError) TDataRequest(LEGACY_HANDLE, LPBYTE pbData, ULONG cbDataSize);
    STDMETHODIMP_(TransportError) TReceiveBufferAvailable(void);
    STDMETHODIMP_(TransportError) TPurgeRequest(LEGACY_HANDLE);
    STDMETHODIMP_(TransportError) TEnableReceiver(void);

private:

    LONG            m_cUsers;
};


extern ULONG NotifyT120(ULONG msg, void *lParam);


#endif	_PSTN_TRANSPORT_INTERFACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\tprtintf.cpp ===
#include "precomp.h"

/*    tprtintf.cpp
 *
 *  Copyright (c) 1996 by Microsoft Corporation
 *
 *    Abstract:
 *        This is the implementation file for the Win32 PSTN transport stack.
 *        This file contains all of the public functions needed to use
 *        the PSTN stack.  Transprt.cpp really performs three functions:
 *
 *            1.  Since this is a Win32 DLL, it provides a C to C++ conversion
 *                layer.  The functions called by the user are not processed
 *                in this file, they are passed on down to the C++ object that
 *                handles it (g_pController).  If we supplied a C++
 *                interface to the user, it would force the user to use C++ and
 *                it would force them to use a C++ compiler that used the same
 *                name-mangling algorithm as our compiler(s).
 *
 *            2.  It holds the code that acts as the administrator for the PSTN
 *                thread.  This is a fairly straightforward piece of code that
 *                is explained later in this comment block.
 *
 *            3.  This file provides thread synchronization to the underlying
 *                code by protecting it with a CRITICAL_SECTION.  This prevents
 *                multiple threads from executing the code at the same time.
 *
 *
 *
 *        CREATING A SECONDARY "PSTN" THREAD
 *
 *        Since this is a Win32 DLL, we create a seperate thread to maintain the
 *        PSTN DLL.  During initialization of the DLL, we create the secondary or
 *        PSTN thread which runs in response to timeouts and system events.  It
 *        uses the WaitForMultipleObjects() system call to wait for events that
 *        need to be processed.
 *
 *        This DLL is event driven.  When a new com port is opened and
 *        initialized, it uses Win32 event objects to signal significant events.
 *        Three events that can occur are read events, write events, and control
 *        events.  An example of a control event is a change in the carrier
 *        detect signal.
 *
 *        When the ComPort object initializes an event object, it registers the
 *        object with the PSTN thread, by placing it in the PSTN Event_List.  It
 *        not only registers the event, but also all of the data needed to
 *        identify the event.  The following structure must be filled out by the
 *        ComPort for each event that it registers.
 *            struct
 *            {
 *                HANDLE            event;                // event object
 *                WIN32Event        event_type;            // READ, WRITE, CONTROL
 *                BOOL              delete_event;        // FLAG, delete it?
 *                PhysicalHandle    physical_handle;    // Handle associated with
 *                                                    // ComPort
 *                IObject *            physical_layer;        // this pointer of comport
 *            } EventObject;
 *
 *        When an event occurs, the PSTN thread makes a call directly to the
 *        ComPort object to notify it.  If the event that occured was a WRITE
 *        event, we also issue a PollTransmitter() function call to the
 *        g_pController object so that it can transmit more data.
 *
 *        If a READ event occurs, we call the ComPort object directly to notify
 *        it that the event occurred.  We then issue a PollReceiver() function
 *        call to the g_pController object so that we can process the
 *        received data.  We then issue a PollTransmitter() to the
 *        g_pController object.  Logically, this doesn't make much sense,
 *        but if you study the Q922 code, you'll see that we sometimes don't
 *        transmit data until we receive notification that previously transmitted
 *        data was successfully transmitted.
 *
 *        If a CONTROL event occurs, we call the ComPort object directly to
 *        notify it that the event occurred.  We then issue a PollReceiver()
 *        function call to the g_pController object so that the CONTROL
 *        event will be processed.
 *
 *
 *
 *        X.214 INTERFACE
 *
 *        You will notice that many of the entry points to this DLL were taken
 *        from the X.214 service definition.  These entry points are consistent
 *        between all DataBeam Transport DLLs.  This gives the user application
 *        a consistent interface.
 *
 *
 *        PHYSICAL API
 *
 *        Some of the entry points to this DLL are specific to the creation
 *        and use of LOGICAL connections, and some of the entry points are
 *        specific to the creation and deletion of PHYSICAL connections.  The
 *        out-of-band physical API is new as of version 2.0 and provides the
 *        user with an optional way of making PHYSICAL connections.  In earlier
 *        versions of the Transport stacks, there was no Physical API and PHYSICAL
 *        connections were made in-band using the TConnectRequest() and
 *        TDisconnectRequest() calls.  This form of call control is still
 *        supported in this version.
 *
 *        Although the user can use out-of-band (PHYSICAL call control) and
 *        in-band call control, the DLL must be put in one mode or the other.
 *        The DLL can NOT function in both modes simultaneously.  The user
 *        determines the DLL's mode of operation by the calls it makes to it.
 *        If the user makes the TPhysicalInitialize() function call to the DLL
 *        before it issues the TInitialize() function call, the DLL is in the
 *        out-of-band call control mode.  If the user only makes the TInitialize()
 *        function call, by default the DLL will be in the in-band call control
 *        mode.
 *
 *        If MCS will be using this DLL, it makes the TInitialize() function call.
 *        Therefore, if the user wants to use the out-of-band call control mode,
 *        it should call TPhysicalInitialize() before it initializes MCS.
 *
 *
 *    Static Variables:
 *        Static_Instance_Handle       - Instance handle passed to the DLL when it
 *                                     is started.  The instance handle is used
 *                                     for Win32 system calls.
 *        g_pController               - This is a pointer to the controller that
 *                                     maintains the T123 stacks.
 *        m_cUsers                   - This is incremented each time someone
 *                                     calls the TInitialize function.  It is
 *                                     decremented each time someone calls the
 *                                      TCleanup function.  When this value
 *                                     reaches 0, we destroy the transport
 *                                     controller.
 *        g_hWorkerThread            - This global variable keeps the handle of
 *                                     the thread we spawn on initialization.
 *        g_dwWorkerThreadID           - Thread identifier
 *        g_hWorkerThreadEvent       - This is an event object that is used to
 *                                     synchronize actions between the 2 threads.
 *        g_hThreadTerminateEvent    - This event is used to signal the PSTN
 *                                     thread that it needs to terminate.
 *        ComPort_List                - This is a list of the ComPort objects
 *                                     serviced by this DLL.
 *                                     class.
 *        Number_Of_Diagnostic_Users - This variable keeps up with the number of
 *                                     people using who called T120DiagnosticCreate.
 *                                     We won't delete the Diagnostic class until
 *                                     an equal number of people call
 *                                     T120DiagnosticDestroy.
 *
 */

/*
**    External Interfaces
*/

#include "tprtintf.h"
#include "comport.h"

#define TPRTINTF_MAXIMUM_WAIT_OBJECTS    (1 + 16)

 /*
 **    Global variables used within the C to C++ converter.
 */
HINSTANCE                   g_hDllInst = NULL;
CTransportInterface        *g_pTransportInterface = NULL;
CRITICAL_SECTION            g_csPSTN;
Timer                      *g_pSystemTimer = NULL;
TransportController        *g_pController = NULL;
HANDLE                      g_hWorkerThread = NULL;
DWORD                       g_dwWorkerThreadID = 0;
HANDLE                      g_hWorkerThreadEvent= NULL;
HANDLE                      g_hThreadTerminateEvent = NULL;
DictionaryClass            *g_pComPortList2 = NULL;
SListClass                 *g_pPSTNEventList = NULL;
TransportCallback           g_pfnT120Notify = NULL;
void                       *g_pUserData = NULL;
BOOL                        g_fEventListChanged = FALSE;

 /*
 **    The following defines the MCATPSTN User window class name.
 **    This name must be unique, system wide.
 */

#define MCATPSTN_USER_WINDOW_CLASS_NAME    "NMPSTN USER Message Window"

 /*
 /*
 **    Timer duration.  We will poll the DLL every X milliseconds.  During
 **    this time, we can do any maintenance that is necessary
 */
#define    MCATPSTN_TIMER_DURATION        250

 /*
 **    These are prototypes
 */
DWORD T123_WorkerThreadProc(DWORD *);


/*
 *    BOOL    WINAPI    DllMain (
 *                        HINSTANCE    instance_handle,
 *                        DWORD        reason,
 *                        LPVOID)
 *
 *    Functional Description:
 *        This routine is the DLL startup routine.  It is analagous to the
 *        constructor of a class.  It is called by Windows when the DLL is
 *        loaded and when other significant events occur.
 */
#ifdef _DEBUG

#define INIT_DBG_ZONE_DATA
#include "fsdiag2.h"

#endif /* _DEBUG */


BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD reason, LPVOID)
{
    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        g_hDllInst = hDllInst;
        ::DisableThreadLibraryCalls(hDllInst);
        #ifdef _DEBUG
    	MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
				(sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
        #endif
        DBG_INIT_MEMORY_TRACKING(hDllInst);
        ::InitializeCriticalSection(&g_csPSTN);
        break;

    case DLL_PROCESS_DETACH:
        ::DeleteCriticalSection(&g_csPSTN);
        DBG_CHECK_MEMORY_TRACKING(hDllInst);
        #ifdef _DEBUG
    	MLZ_DbgDeInit();
        #endif
        break;
    }

    return TRUE;
}


TransportError WINAPI T123_CreateTransportInterface(ILegacyTransport **pp)
{
    TransportError rc;

    if (NULL != pp)
    {
        *pp = NULL;

        if (NULL == g_pTransportInterface)
        {
            rc = TRANSPORT_MEMORY_FAILURE;

            DBG_SAVE_FILE_LINE
            g_pTransportInterface = new CTransportInterface(&rc);
            if (NULL != g_pTransportInterface && TRANSPORT_NO_ERROR == rc)
            {
                *pp = (ILegacyTransport *) g_pTransportInterface;
                return TRANSPORT_NO_ERROR;
            }

            delete g_pTransportInterface;
            g_pTransportInterface = NULL;
            return rc;
        }

        ASSERT(0);
        return TRANSPORT_ALREADY_INITIALIZED;
    }

    return TRANSPORT_INVALID_PARAMETER;
}


CTransportInterface::CTransportInterface(TransportError *rc)
:
    m_cUsers(0)
{
    g_hWorkerThread = NULL;
    g_dwWorkerThreadID = 0;

    g_pfnT120Notify = NULL;
    g_pUserData = NULL;

    g_fEventListChanged = FALSE;

    DBG_SAVE_FILE_LINE
    g_pSystemTimer = new Timer;
    ASSERT(NULL != g_pSystemTimer);

    DBG_SAVE_FILE_LINE
    g_hWorkerThreadEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    ASSERT(NULL != g_hWorkerThreadEvent);

    DBG_SAVE_FILE_LINE
    g_hThreadTerminateEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
    ASSERT(NULL != g_hThreadTerminateEvent);

    DBG_SAVE_FILE_LINE
    g_pComPortList2 = new DictionaryClass(TRANSPORT_HASHING_BUCKETS);
    ASSERT(NULL != g_pComPortList2);

    DBG_SAVE_FILE_LINE
    g_pPSTNEventList = new SListClass;
    ASSERT(NULL != g_pPSTNEventList);

    *rc = (g_pSystemTimer &&
           g_hWorkerThreadEvent &&
           g_hThreadTerminateEvent &&
           g_pComPortList2 &&
           g_pPSTNEventList)
          ?
           TRANSPORT_NO_ERROR :
           TRANSPORT_INITIALIZATION_FAILED;
    ASSERT(TRANSPORT_NO_ERROR == *rc);
}


CTransportInterface::~CTransportInterface(void)
{
    if (m_cUsers > 0)
    {
        // TCleanup() was not properly called enough times in the process.
        // Force final cleanup.
        m_cUsers = 1;
        TCleanup();
    }

    delete g_pSystemTimer;
    g_pSystemTimer = NULL;

    delete g_pComPortList2;
    g_pComPortList2 = NULL;

    delete g_pPSTNEventList;
    g_pPSTNEventList = NULL;

    g_pfnT120Notify = NULL;
    g_pUserData = NULL;

    if (NULL != g_hWorkerThreadEvent)
    {
        ::CloseHandle(g_hWorkerThreadEvent);
        g_hWorkerThreadEvent = NULL;
    }

    if (NULL != g_hThreadTerminateEvent)
    {
        ::CloseHandle(g_hThreadTerminateEvent);
        g_hThreadTerminateEvent = NULL;
    }

    if (NULL != g_hWorkerThread)
    {
        ::CloseHandle(g_hWorkerThread);
        g_hWorkerThread = NULL;
    }
}


void CTransportInterface::ReleaseInterface(void)
{
    delete this;
}



/*
 *    TransportError APIENTRY    TInitialize (
 *                                TransportCallback    transport_callback,
 *                                PVoid                user_defined)
 *
 *    Functional Description:
 *        This function must be called by the user of the Transport
 *        stack.  The PSTN thread is started.
 *
 *    Caveats:
 *        If this function is successful, the user must also call the
 *        TCleanup() function when he is finished with the DLL.
 */
TransportError CTransportInterface::TInitialize
(
    TransportCallback    transport_callback,
    void                *user_defined
)
{
    TransportError rc = TRANSPORT_NO_ERROR;

    if (! m_cUsers)
    {
        g_pfnT120Notify = transport_callback;
        g_pUserData = user_defined;

         /*
         **    At this point, we need to create another thread that will
         **    maintain this DLL.
         */
        g_hWorkerThread = ::CreateThread(
                            NULL, 0, (LPTHREAD_START_ROUTINE) T123_WorkerThreadProc,
                            NULL, 0, &g_dwWorkerThreadID);
        if (NULL != g_hWorkerThread)
        {
            if (::SetThreadPriority(g_hWorkerThread, THREAD_PRIORITY_ABOVE_NORMAL) == FALSE)
            {
                WARNING_OUT(("SetThreadPriority ERROR: = %d", ::GetLastError()));
            }

             /*
             **    Wait for the secondary thread to notify us that initialization is
             **    complete
             */
            ::WaitForSingleObject(g_hWorkerThreadEvent, 30000); // 30 seconds

             /*
             **    If g_pController == NULL, initialization FAILED.  We use
             **    this variable to signal us regarding the status of the secondary
             **    thread.
             */
            if (NULL == g_pController)
            {
                ERROR_OUT(("TInitialize: Unable to initialize transport"));
                rc = TRANSPORT_INITIALIZATION_FAILED;
            }
        }
        else
        {
            rc = TRANSPORT_INITIALIZATION_FAILED;
        }
    }

    if (TRANSPORT_NO_ERROR == rc)
    {
        m_cUsers++;
    }

    return rc;
}


/*
 *    TransportError TCleanup (void)
 *
 *    Functional Description:
 *        This function is called to release all system resources that
 *        were used during the life of the DLL.
 *
 *    Caveats:
 *        This function should only be called if the user had previously
 *        called the TInitialize() function.
 */
TransportError CTransportInterface::TCleanup(void)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        if (--m_cUsers == 0)
        {
             /*
             **    Set the g_hThreadTerminateEvent to notify the PSTN thread
             **    that it should terminate operations.
             */
            ::SetEvent(g_hThreadTerminateEvent);

             /*
             **    Wait for the PSTN thread to notify us that cleanup is
             **    complete
             */
            if (g_hWorkerThreadEvent != NULL)
            {
                // WaitForSingleObject (g_hWorkerThreadEvent, INFINITE);
                ::WaitForSingleObject(g_hWorkerThreadEvent, 30000); // 30 seconds
                g_hWorkerThreadEvent = NULL;

                //
                //  Relinquish the remainder of our time slice, to allow trasnsport thread to exit.
                //
                Sleep(0);
            }
        }

        rc = TRANSPORT_NO_ERROR;
    }

    return rc;
}


TransportError CTransportInterface::TCreateTransportStack
(
    BOOL                fCaller,
    HANDLE              hCommLink,
    HANDLE              hevtClose,
    PLUGXPRT_PARAMETERS *pParams
)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            rc = g_pController->CreateTransportStack(fCaller, hCommLink, hevtClose, pParams);
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


TransportError CTransportInterface::TCloseTransportStack
(
    HANDLE          hCommLink
)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            rc = g_pController->CloseTransportStack(hCommLink);
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


/*
 *    TransportError APIENTRY        TConnectRequest (
 *                                    TransportAddress    transport_address,
 *                                    TransportPriority    transport_priority,
 *                                    LogicalHandle        *logical_handle)
 *
 *    Functional Description:
 *        This function starts the process of building a transport connection.
 *        It uses the transport_address and attempts to make a connection to it.
 *
 *        If the DLL is set up for in-band call control, the DLL will choose a
 *        modem and attempt a connection.  After the physical connection is up,
 *        it will create a logical connection that the user application can use.
 *
 *        If the DLL is set up for out-of-band call control, the transport address
 *        is actually an ascii string that represents a DLL generated
 *        physicalhandle.  This call can only be made in response to a successful
 *        TPhysicalConnectRequest() function.  The TPhysicalConnectRequest() call
 *        returns a PhysicalHandle that the user must convert to ascii and pass
 *        back to the DLL via this call.  Although this is very ugly, we did this
 *        for a reason.  We added the out-of-band call control API to the
 *        transports but we did not want to change GCC or MCS to do it.  GCC and
 *        MCS already expected an ascii string as the transport address.  In the
 *        future, look for this to change in MCS and GCC.
 */
TransportError CTransportInterface::TConnectRequest
(
    LEGACY_HANDLE          *logical_handle,
    HANDLE                  hCommLink
)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            rc = g_pController->ConnectRequest(logical_handle, hCommLink);
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


/*
 *    TransportError APIENTRY    TDisconnectRequest (
 *                                LogicalHandle    logical_handle,
 *                                BOOL             trash_packets)
 *
 *    Functional Description:
 *        This function breaks a logical connection.  This is also an X.214
 *        primitive.  Since the DLL may have packets queued up for transmission
 *        for this logical connection, the trash_packets parameter determines
 *        whether the DLL should trash those packets before disconnecting the
 *        logical connection.
 */
TransportError CTransportInterface::TDisconnectRequest
(
    LEGACY_HANDLE       logical_handle,
    BOOL                trash_packets
)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            rc = g_pController->DisconnectRequest(logical_handle, trash_packets);
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


/*
 *    TransportError APIENTRY    TDataRequest (
 *                                LogicalHandle    logical_handle,
 *                                LPBYTE            user_data,
 *                                ULONG            user_data_length)
 *
 *    Functional Description:
 *        This function takes the data passed in and attempts to send it
 *        to the remote site.
 */
TransportError CTransportInterface::TDataRequest
(
    LEGACY_HANDLE    logical_handle,
    LPBYTE           user_data,
    ULONG            user_data_length
)
{
    TransportError    rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);

        if (NULL != g_pController)
        {
            rc = g_pController->DataRequest(logical_handle, user_data, user_data_length);
             /*
             **    If the packet was accepted, we need to issue a
             **    PollTransmitter() to flush the packet out.  Otherwise,
             **    we will have a latency problem.
             */
            if (TRANSPORT_NO_ERROR == rc)
            {
                ComPort *comport;
                PhysicalHandle physical_handle = g_pController->GetPhysicalHandle(logical_handle);
                if (g_pComPortList2->find((DWORD_PTR) physical_handle, (PDWORD_PTR) &comport))
                {
                    if (! comport->IsWriteActive())
                    {
                        g_pController->PollTransmitter(physical_handle);
                    }
                }
            }
        }

        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


/*
 *    TransportError APIENTRY    TReceiveBufferAvailable (void)
 *
 *    Functional Description:
 *        This function informs the transport to enable packet transfer from the
 *        Transport to the user application.  This function makes a call to
 *        'Enable' the receiver and then it issues a PollReceiver() to actually
 *        allow any pending packets to be sent on up to the user.
 */
TransportError CTransportInterface::TReceiveBufferAvailable(void)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);

        if (NULL != g_pController)
        {
            g_pController->EnableReceiver();
            g_pController->PollReceiver();

             /*
             **    We are doing a PollTransmitter() here to allow
             **    the Q922 object to exit the 'receiver not ready' mode.
             **    If MCS had been rejecting packets, and now it is accepting
             **    packets, we need to let the remote site know that it
             **    can re-start its transmitter.
             */
            g_pController->PollTransmitter();
        }

        ::LeaveCriticalSection(&g_csPSTN);

        rc = TRANSPORT_NO_ERROR;
    }

    return rc;
}


/*
 *    TransportError APIENTRY    TPurgeRequest (
 *                                LogicalHandle    logical_handle)
 *
 *    Functional Description:
 *        This function purges all of the outbound packets for the given
 *        logical connection.
 */
TransportError CTransportInterface::TPurgeRequest
(
    LEGACY_HANDLE       logical_handle
)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            rc = g_pController->PurgeRequest(logical_handle);
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


TransportError CTransportInterface::TEnableReceiver(void)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            g_pController->EnableReceiver();
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return TRANSPORT_NO_ERROR;
}


/*
 *    DWORD    T123_WorkerThreadProc (LPDWORD)
 *
 *    Functional Description:
 *        This function is the PSTN thread.  It maintains the DLL.
 */
DWORD T123_WorkerThreadProc(DWORD *)
{
    PEventObject        event_struct;
    BOOL                fContinue = TRUE;
    HANDLE              aEvents[TPRTINTF_MAXIMUM_WAIT_OBJECTS];
    ULONG               cEvents;
    ULONG               last_time_polled;
    ULONG               current_time;

    g_fEventListChanged = FALSE;

     /*
     **    Create the one and only instance of the Transport Controller
     **    to be in charge of this DLL.  Once it is created, all other
     **    primitives are routed to it.
     */
    DBG_SAVE_FILE_LINE
    g_pController = new TransportController();
    if (g_pController == NULL)
    {
        ERROR_OUT(("PSTN_WorkerThreadProc: cannot allocate TransportController"));
        ::SetEvent(g_hWorkerThreadEvent);
        return TRANSPORT_INITIALIZATION_FAILED;
    }

     /*
     **    The DLL needs to be polled every X milliseconds.  We do this
     **    by checking the system clock and if X milliseconds have elapsed
     **    since the last DLL poll, we do it again.  This line of code is
     **    actually initializing the timer.
     */
    last_time_polled = ::GetTickCount();

     /*
     **    Notify the primary thread that we are up
     */
    ::SetEvent(g_hWorkerThreadEvent);


// THREAD LOOP

     /*
     **    This while loop is the heart of the PSTN thread.  We use the
     **    WaitForMultipleObjects() function to wake up our thread when a
     **    significant event occurs OR when a timeout occurs.
     **
     **    There are four different types of event objects that can occur
     **    that will wake up the thread.
     **
     **        1.  The primary thread sets the g_hThreadTerminateEvent object.
     **        2.  Read event from the ComPort object.  If a read of a comm port
     **            completes or times out, the event object is set
     **        3.  Write event from the ComPort object.  If a write on a comm
     **            port completes or times out.
     **        4.  Control event from the ComPort object.  If the carrier detect
     **            signal changes.
     **
     ** Also, the thread will continue running if the MCATPSTN_TIMER_DURATION
     **    expires
     **
     **
     **    A ComPort object can add event objects to our PSTN Event_List at any
     **    time.  When they are added to the Event_List, we add them to the
     **    local aEvents and the WaitForMultipleObjects() function waits
     **    for them.
     **
     **    This approach works very well except that the WaitForMultipleObjects()
     **    function can only handle TPRTINTF_MAXIMUM_WAIT_OBJECTS at a time.  Currently,
     **    this #define is set to 64 by the Windows 95 operating system.  Since
     **    each ComPort uses 3 event objects, this limits us to a maximum of
     **    21 active ports.
     */
    aEvents[0] = g_hThreadTerminateEvent;
    cEvents = 1;

    while (fContinue)
    {
         /*
         **    Wait for an event to occur or for the timeout to expire
         */
         DWORD dwRet = ::WaitForMultipleObjects(cEvents, aEvents, FALSE, MCATPSTN_TIMER_DURATION);

         /*
         **    We MUST enter this critical section of code and lock out the
         **    primary thread from enterring it.  Both threads executing this
         **    code could be disasterous
         */
        ::EnterCriticalSection(&g_csPSTN);

        if (dwRet == WAIT_FAILED)
        {
            fContinue = FALSE;
            break;
        }
        else
        if (dwRet == WAIT_TIMEOUT)
        {
            if (cEvents > 1)
            {
                last_time_polled = ::GetTickCount();
                g_pController->PollReceiver();
                g_pController->PollTransmitter();
                g_pSystemTimer->ProcessTimerEvents();
            }
        }
        else
        {
             /*
             **    Determine which object has signalled us
             */
            ULONG dwIdx = dwRet - WAIT_OBJECT_0;
            if (dwIdx > cEvents)
            {
                ERROR_OUT(("ThreadFunc: Invalid object signalled = %d", dwIdx));
            }
            else
            {
                 /*
                 **    If the object that signalled us is index 0, it is the
                 **    terminate thread object.
                 */
                if (! dwIdx)
                {
                    TRACE_OUT(("ThreadFunc: Terminating thread"));
                    fContinue = FALSE;
                }
                else
                {
                    dwIdx--;
                    event_struct = (PEventObject) g_pPSTNEventList->read((USHORT) dwIdx);
                    if (NULL != event_struct)
                    {
                         /*
                         **    Check the delete_event, if it is set, we need to
                         **    terminate the event.
                         **
                         **    By design, other objects throughout the DLL create
                         **    the events, and this function deletes them.  If the
                         **    creating function deleted them, we could be waiting
                         **    on an event that gets deleted.  That has the potential
                         **    of being messy.
                         */
                        if (event_struct->delete_event)
                        {
                             /*
                             **    Remove the ComPort from our list
                             */
                            ComPort *comport = NULL;
                            if (g_pComPortList2->find((DWORD_PTR) event_struct->hCommLink, (PDWORD_PTR) &comport))
                            {
                                g_pComPortList2->remove((DWORD_PTR) event_struct->hCommLink);
                                comport->Release();
                            }

                             /*
                             **    Close the event
                             */
                            ::CloseHandle(event_struct->event);

                             /*
                             **    Remove the event from our list
                             */
                            g_pPSTNEventList->remove((DWORD_PTR) event_struct);
                            delete event_struct;

                            g_fEventListChanged = TRUE;
                        }
                        else
                        {
                            ComPort *comport = event_struct->comport;
                             /*
                             **    Switch on the event_type to determine the
                             **    operation that needs to take place
                             */
                            switch (event_struct->event_type)
                            {
                            case READ_EVENT:
                                comport->ProcessReadEvent();

                                 /*
                                 **    If a READ event occurred, we need to issue
                                 **    a PollReceiver() and then issue a
                                 **    PollTransmitter().  We issue the
                                 **    PollTransmitter() because the PollReceiver()
                                 **    may have freed up space for us to send out
                                 **    data.
                                 */
                                g_pController->PollReceiver(event_struct->hCommLink);
                                g_pController->PollTransmitter(event_struct->hCommLink);
                                break;

                            case WRITE_EVENT:
                                 /*
                                 **    If a WRITE_EVENT occurs, this means that
                                 **    space has become available to transmit more
                                 **    data.
                                 */
                                comport->ProcessWriteEvent();
                                g_pController->PollTransmitter(event_struct->hCommLink);
                                break;

                            case CONTROL_EVENT:
                                 /*
                                 ** The CONTROL events are particular to the
                                 **    ComPort object.  A change in the CD signal
                                 **    could be a CONTROL event.
                                 */
                                g_pController->PollReceiver(event_struct->hCommLink);
                                break;

                            default:
                                ERROR_OUT(("ThreadFunc:  Illegal event type = %d", event_struct->event_type));
                                break;
                            } // switch
                        }
                    } // if event_struct
                }
            }

             /*
             **    Check to see if enough time has elapsed since the last time we
             **    polled the DLL to do it again.
             */
            if (cEvents > 1)
            {
                current_time = ::GetTickCount();
                if ((current_time - last_time_polled) >= MCATPSTN_TIMER_DURATION)
                {
                    last_time_polled = current_time;

                    g_pController->PollReceiver();
                    g_pController->PollTransmitter();
                    g_pSystemTimer->ProcessTimerEvents();
                }
            }
        }


         /*
         **    This Event_List_Changed will only be set to TRUE if we need to
         **    update our event list
         */
        if (g_fEventListChanged)
        {
            aEvents[0] = g_hThreadTerminateEvent;
            cEvents = 1;

            if (g_pPSTNEventList->entries() > (TPRTINTF_MAXIMUM_WAIT_OBJECTS - 1))
            {
                ERROR_OUT(("ThreadFunc:  ERROR:  Number of event objects = %d",
                    g_pPSTNEventList->entries() + 1));
            }

             /*
             **    Go thru the Event_List and create a new aEvents.
             */
            g_pPSTNEventList->reset();
            while (g_pPSTNEventList->iterate((PDWORD_PTR) &event_struct))
            {
                aEvents[cEvents] = event_struct -> event;
                cEvents++;

                 /*
                 **    Add the physical_handle to the ComPort_List
                 */
                if (event_struct->event_type == WRITE_EVENT)
                {
                    if (! g_pComPortList2->find((DWORD_PTR) event_struct->hCommLink))
                    {
                        g_pComPortList2->insert((DWORD_PTR) event_struct->hCommLink,
                                                (DWORD_PTR) event_struct->comport);
                    }
                }
            }
            g_fEventListChanged = FALSE;
        }

        ::LeaveCriticalSection(&g_csPSTN);
    } // while


// CLEANUP THE THREAD RESOURCES
    delete g_pController;
    g_pController = NULL;

     /*
     **    Delete all of the event objects
     */
    g_pPSTNEventList->reset();
    while (g_pPSTNEventList->iterate((PDWORD_PTR) &event_struct))
    {
        ::CloseHandle(event_struct->event);
        delete event_struct;
    }

     /*
     **    Notify the primary thread that we are up
     */
    ::SetEvent(g_hWorkerThreadEvent);

    return (0);
}



ULONG NotifyT120(ULONG msg, void *param)
{
    if (NULL != g_pfnT120Notify)
    {
        return (*g_pfnT120Notify) (msg, param, g_pUserData);
    }
    return 0;
}


IObject::~IObject(void) { }


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\x224.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    X224.cpp
 *
 *    Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *
 *    Private Instance Variables:
 *        Default_PDU_Size             -    Default PDU size, if no arb. is done
 *        Data_Request_Memory_Manager -    Memory manager
 *        Lower_Layer_Prepend            -    Number of bytes prepended to packet by
 *                                        lower layer
 *        Lower_Layer_Append            -    Number of bytes appended to packet byt
 *                                        lower layer
 *        Shutdown_Receiver            -    TRUE if we aren't to receive any more
 *                                        packets from the lower layer
 *        Shutdown_Transmitter        -    TRUE if we aren't to transmit any more
 *                                        packets
 *        Data_Request_Queue            -    Queue that keeps the pending user data
 *                                        requests
 *        Data_Indication_Queue        -    Queue that holds the pending user data
 *                                        indications
 *        Data_Indication_Memory_Pool    -    List that holds available data
 *                                        indication buffers.
 *
 *        Active_Data_Indication        -    Address of packet structure.  This
 *                                        packet holds the current data indication
 *                                        that we are reassembling
 *        m_pT123                -    Address of owner object.  Used for
 *                                        callbacks
 *        m_pQ922                    -    Address of lower layer.
 *        m_nMsgBase                -    Message base to be used for owner
 *                                        callbacks
 *        Maximum_PDU_Size            -    Max. PDU size
 *        Arbitrated_PDU_Size            -    Max. arbitrated packet size.
 *        Identifier                    -    Identifier passed to lower layer to
 *                                        register ourselves.
 *        Data_Indication_Queue_Size    -    Number of data indications we will
 *                                        buffer
 *        Data_Indication_Reassembly_Active    -    Flag set if we are in the middle
 *                                        of a packet reassembly.
 *        State                        -    Holds the current state of the object
 *        Packet_Pending                -    Tells which packet will be sent next.
 *        Reject_Cause                -    The reason why the error packet was sent
 *        Packet_Size_Respond            -    Set to TRUE if we are to send a TPDU
 *                                        size element in the CC packet
 *        Error_Buffer                -    Address of error buffer.
 *        Error_Buffer_Length            -    Length of error buffer.
 *
 *        m_nLocalLogicalHandle    -    Local transport connection id.
 *        m_nRemoteLogicalHandle    -    Remote transport connection id.
 *         User_Data_Pending            -    Set to the size of the last packet that
 *                                        the user attempted to pass to us, that
 *                                        we couldn't accept because we ran out
 *                                        of memory.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */

#include <windowsx.h>
#include "x224.h"



/*
 *    CLayerX224::CLayerX224 (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                USHORT                logical_handle,
 *                USHORT                identifier,
 *                USHORT                data_indication_queue_size,
 *                USHORT                default_PDU_size,
 *                PMemoryManager        dr_memory_manager,
 *                BOOL *            initialization_success)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the Transport constructor.  This routine initializes all
 *        variables and allocates the buffers needed to operate.
 */
CLayerX224::CLayerX224
(
    T123               *owner_object,
    CLayerQ922         *pQ922, // lower layer
    USHORT              message_base,
    LogicalHandle       logical_handle,
    ULONG               identifier,
    USHORT              data_indication_queue_size,
    USHORT              default_PDU_size,
    PMemoryManager      dr_memory_manager,
    BOOL               *initialization_success
)
:
    m_pT123(owner_object),
    m_nMsgBase(message_base),
    m_pQ922(pQ922)
{
    TRACE_OUT(("CLayerX224::CLayerX224"));

    ProtocolLayerError    error;

    m_nLocalLogicalHandle = logical_handle;
    Identifier = identifier;
    Default_PDU_Size = default_PDU_size;
    Data_Request_Memory_Manager = dr_memory_manager;
    *initialization_success = TRUE;

    Shutdown_Receiver = FALSE;
    Shutdown_Transmitter = FALSE;
    Reject_Cause = 0;


     /*
     **    Find the maximum packet size
     */
    m_pQ922->GetParameters(
                    &Maximum_PDU_Size,
                    &Lower_Layer_Prepend,
                    &Lower_Layer_Append);

    Arbitrated_PDU_Size = Default_PDU_Size;

     /*
     **    Figure out what our largest PDU could be.  We will use this value to
     **    arbitrate the maximum PDU size.
     */
    Maximum_PDU_Size = (USHORT)GetMaxTPDUSize (Maximum_PDU_Size);

     /*
     **    Register with the lower layer, so we can send and receive packets.
     */
    error = m_pQ922->RegisterHigherLayer(
                            identifier,
                            Data_Request_Memory_Manager,
                            (IProtocolLayer *) this);

    if (error != PROTOCOL_LAYER_NO_ERROR)
    {
        ERROR_OUT(("X224: constructor:  Error registering with lower layer"));
        *initialization_success = FALSE;
    }

     /*
     **    Prepare for buffer allocation
     */
    Data_Indication_Queue_Size = data_indication_queue_size;
    Error_Buffer = NULL;

     /*
     **    Set member variables appropriately
     */
    Active_Data_Indication = NULL;
    Data_Indication_Reassembly_Active = FALSE;
    Packet_Pending = TRANSPORT_NO_PACKET;
    User_Data_Pending = 0;

    m_nRemoteLogicalHandle = 0;
    Packet_Size_Respond = FALSE;

    if (*initialization_success == FALSE)
        State = FAILED_TO_INITIALIZE;
    else
        State = NO_CONNECTION;
}


/*
 *    CLayerX224::~CLayerX224 (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the Transport destructor.  This routine cleans up everything.
 */
CLayerX224::~CLayerX224(void)
{
    TRACE_OUT(("CLayerX224::~CLayerX224"));

    PMemory     lpMemory;
    PTMemory    lptMem;
     /*
     **    Notify the lower layer that we are terminating
     */
    m_pQ922->RemoveHigherLayer(Identifier);

     /*
     **    Go thru the data request queue and delete the structures held in the
     **    queue.
     */
    Data_Request_Queue.reset();
    while (Data_Request_Queue.iterate ((PDWORD_PTR) &lpMemory))
    {
        Data_Request_Memory_Manager-> FreeMemory (lpMemory);
    }

     /*
     **    Go thru the data indication queue and delete the structures held in the
     **    queue.
     */
    Data_Indication_Queue.reset();
    while (Data_Indication_Queue.iterate ((PDWORD_PTR) &lptMem))
        delete lptMem;

     /*
     **    Go thru the data request free structure pool and delete the structures
     **    held in the    pool.
     */
    Data_Indication_Memory_Pool.reset();
    while (Data_Indication_Memory_Pool.iterate ((PDWORD_PTR) &lptMem))
        delete lptMem;

     /*
     **    If there is a data indication active, delete that structure.
     */
    delete Active_Data_Indication;

     /*
     **    If the error buffer holds a packet, delete it
     */
    delete [] Error_Buffer;

    return;
}


/*
 *    TransportError    CLayerX224::ConnectRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initiates a connect request.
 */
TransportError    CLayerX224::ConnectRequest (void)
{
    TRACE_OUT(("CLayerX224::ConnectRequest"));

    if (State != NO_CONNECTION)
    {
        ERROR_OUT(("Transport: Illegal ConnectRequest packet"));
        return (TRANSPORT_CONNECT_REQUEST_FAILED);
    }

    Packet_Pending = CONNECTION_REQUEST_PACKET;
    return (TRANSPORT_NO_ERROR);
}


/*
 *    TransportError    CLayerX224::ShutdownReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function stops us from receiving any more packets from the lower
 *        layer
 */
void    CLayerX224::ShutdownReceiver (void)
{
    TRACE_OUT(("CLayerX224::ShutdownReceiver"));

    Shutdown_Receiver = TRUE;
}


/*
 *    TransportError    CLayerX224::EnableReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function permits us to send packets to the user application.
 */
void    CLayerX224::EnableReceiver (void)
{
    TRACE_OUT(("CLayerX224::EnableReceiver"));

    Shutdown_Receiver = FALSE;
}


/*
 *    TransportError    CLayerX224::ShutdownTransmitter (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function keeps us from transmitting any more packets
 */
void    CLayerX224::ShutdownTransmitter (void)
{
    TRACE_OUT(("CLayerX224::ShutdownTransmitter"));

    Shutdown_Transmitter = TRUE;
}


/*
 *    TransportError    CLayerX224::PurgeRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function removes all packets from out output queue that aren't
 *        active
 */
void    CLayerX224::PurgeRequest (void)
{
    TRACE_OUT(("CLayerX224::PurgeRequest"));

    DWORD    entries;
    DWORD    keep_counter = 0;
    PMemory    memory;
    LPBYTE    packet_address;
    DWORD    i;

    if (Data_Request_Queue.isEmpty() == FALSE)
    {
        entries = Data_Request_Queue.entries ();

         /*
         **    Go thru packets looking for the last PDU in the SDU
         */
        Data_Request_Queue.reset();
        while (Data_Request_Queue.iterate ((PDWORD_PTR) &memory))
        {
            keep_counter++;
            packet_address = memory -> GetPointer ();
            if (*(packet_address + 2) == EOT_BIT)
                break;
        }

        TRACE_OUT(("PurgeRequest: Removing %d packets", entries-keep_counter));
        for (i=keep_counter; i<entries; i++)
        {
            Data_Request_Memory_Manager->FreeMemory ((PMemory) Data_Request_Queue.removeLast ());
        }
    }
    return;
}


/*
 *    TransportError    CLayerX224::ConnectResponse (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initiates a connect response.
 */
TransportError    CLayerX224::ConnectResponse (void)
{
    TRACE_OUT(("CLayerX224::ConnectResponse"));

    if (State != RECEIVED_CONNECT_REQUEST_PACKET)
    {
        ERROR_OUT(("Transport: Illegal ConnectResponse packet"));
        return (TRANSPORT_CONNECT_RESPONSE_FAILED);
    }

    Packet_Pending = CONNECTION_CONFIRM_PACKET;
    return (TRANSPORT_NO_ERROR);
}


/*
 *    TransportError    CLayerX224::DisconnectRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initiates a disconnect request.
 */
TransportError    CLayerX224::DisconnectRequest (void)
{
    TRACE_OUT(("CLayerX224::DisconnectRequest"));

    if (State == SENT_CONNECT_REQUEST_PACKET)
    {
         /*
         **    The connection is being rejected, send out the DISCONNECT
         **    packet and wait for termination
         */
        Packet_Pending = DISCONNECT_REQUEST_PACKET;
    }
    else
    {
         /*
         **    Normal disconnects don't send any notification to the remote site.
         **    It depends on the Network layer to terminate the link.
         */
        m_pQ922->RemoveHigherLayer(Identifier);

        m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                               (void *) m_nLocalLogicalHandle);
    }

    return (TRANSPORT_NO_ERROR);
}


/*
 *    TransportError    CLayerX224::DataIndication (
 *                                LPBYTE        packet_address,
 *                                ULONG        buffer_size,
 *                                PULong        packet_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the lower layer when it has a packet for us.
 */
ProtocolLayerError    CLayerX224::DataIndication (
                                LPBYTE        packet_address,
                                ULONG        packet_length,
                                PULong        bytes_accepted)
{
    TRACE_OUT(("CLayerX224::DataIndication"));

    ULONG            remainder_length;
    USHORT            class_request;
    USHORT            packet_type;
    USHORT            length;
    USHORT            destination_reference;
    LegacyTransportData    transport_data;
    BOOL            packet_accepted;
    ULONG            user_accepted;
    UChar            eot;
    PTMemory        packet;
    TMemoryError    packet_error;
    LPBYTE            temp_address;
    BOOL            use_default_PDU_size;


    *bytes_accepted = 0;
    packet_accepted = FALSE;

     /*
     ** If the receiver is shutdown, don't accept any data
     */
    if (Shutdown_Receiver)
        return (PROTOCOL_LAYER_NO_ERROR);

     /*
     **    The packet must be at least 2 bytes long
     */
    if (packet_length < 2)
    {
        ERROR_OUT(("X224: DataIndication:  Invalid packet received from lower layer: length = %d", packet_length));
        return (PROTOCOL_LAYER_NO_ERROR);
    }

    remainder_length = packet_length;
    temp_address = packet_address;
    packet_address++;
    packet_type = *(packet_address++) & TPDU_CODE_MASK;
    remainder_length -= 2;

    switch (packet_type)
    {
        case CONNECTION_REQUEST_PACKET:
            packet_accepted = TRUE;

             /*
             **    There should be at least 5 bytes remaining in this packet
             */
            if (remainder_length < 5)
            {
                ERROR_OUT(("X224: DataIndication: CR: Invalid packet received from lower layer: length = %d", packet_length));
                break;
            }

             /*
             **    Increment the packet address by 2 to get past the DST_REF
             */
            packet_address += 2;
            m_nRemoteLogicalHandle = *(packet_address++);
            m_nRemoteLogicalHandle <<= 8;
            m_nRemoteLogicalHandle |= *(packet_address++);
            remainder_length -= 4;

             /*
             **    Look at the class request to make sure it is 0
             */
            class_request = *(packet_address++) >> 4;
            remainder_length -= 1;
            if (class_request != 0)
            {
                ERROR_OUT(("X224: DataIndication: CR packet: Illegal class request"));
                ErrorPacket (
                    temp_address,
                    (USHORT) (packet_length - remainder_length));
                break;
            }
            use_default_PDU_size = TRUE;

            while (remainder_length != 0)
            {
                switch (*(packet_address++))
                {
                    case TPDU_SIZE:
                        length = *(packet_address++);
                        remainder_length -= 1;
                        if (length != 1)
                        {
                            TRACE_OUT(("X224: DataIndication: CR packet: Illegal TPDU_Size length"));

                            ErrorPacket (
                                temp_address,
                                (USHORT) (packet_length - remainder_length));
                            break;
                        }

                         /*
                         **    Figure out the actual PDU size
                         */
                        Arbitrated_PDU_Size = (1 << *(packet_address++));
                        remainder_length -= 1;
                        TRACE_OUT(("X224: CR_Packet: Packet size = %d", Arbitrated_PDU_Size));
                        if (Arbitrated_PDU_Size > Maximum_PDU_Size)
                        {
                            Packet_Size_Respond = TRUE;
                            Arbitrated_PDU_Size = Maximum_PDU_Size;
                        }
                        if (AllocateBuffers() == FALSE)
                        {
                            m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                                   (void *) m_nLocalLogicalHandle);
                        }
                        use_default_PDU_size = FALSE;
                        break;

                    default:
                        ERROR_OUT(("X224: DataIndication: CR packet Unsupported parameter 0x%x", *(packet_address - 1)));
                        length = *(packet_address++);
                        remainder_length--;

                        packet_address += length;
                        remainder_length -= length;
                        break;
                }
                remainder_length--;
            }

             /*
             **    If the initiator wants to use the default PDU size, we need to
             **    check the default size with the Max. size to make sure it is
             **    valid for us.
             */
            if (use_default_PDU_size)
            {
                if (Default_PDU_Size > Maximum_PDU_Size)
                {
                    Packet_Size_Respond = TRUE;
                    Arbitrated_PDU_Size = Maximum_PDU_Size;
                }
                if (AllocateBuffers() == FALSE)
                {
                    m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                           (void *) m_nLocalLogicalHandle);
                }
            }

            State = RECEIVED_CONNECT_REQUEST_PACKET;

             /*
             **    Notify the owner that the remote site wants to start a
             **    connection
             */
            m_pT123->OwnerCallback(m_nMsgBase + TPRT_CONNECT_INDICATION,
                                   (void *) m_nLocalLogicalHandle);
            TRACE_OUT(("X224: DataInd: ConnectRequest: max pkt = %d", Arbitrated_PDU_Size));
            break;

        case CONNECTION_CONFIRM_PACKET:
            packet_accepted = TRUE;

             /*
             **    There should be at least 5 bytes remaining in this packet
             */
            if (remainder_length < 5)
            {
                ERROR_OUT(("X224: DataIndication: CC: Invalid packet received from lower layer: length = %d",
                        packet_length));
                break;
            }

            destination_reference = *(packet_address++);
            destination_reference <<= 8;
            destination_reference |= *(packet_address++);
            remainder_length -= 2;
            if (destination_reference != m_nLocalLogicalHandle)
            {
                ERROR_OUT(("X224: DataIndication: CC packet: DST-REF incorrect"));
                ErrorPacket (
                    temp_address,
                    (USHORT) (packet_length - remainder_length));
                break;
            }

            m_nRemoteLogicalHandle = *(packet_address++);
            m_nRemoteLogicalHandle <<= 8;
            m_nRemoteLogicalHandle |= *(packet_address++);

            class_request = *(packet_address++) >> 4;
            remainder_length -= 3;
            if (class_request != 0)
            {
                ERROR_OUT(("X224: DataIndication: CR packet: Illegal class request"));
                ErrorPacket (
                    temp_address,
                    (USHORT) (packet_length - remainder_length));
                break;
            }
            use_default_PDU_size = TRUE;

            while (remainder_length != 0)
            {
                switch (*(packet_address++))
                {
                    case TPDU_SIZE:
                        length = *(packet_address++);
                        remainder_length -= 1;
                        if (length != 1)
                        {
                            ERROR_OUT(("X224: DataIndication: CR packet: Illegal TPDU_Size length"));

                            ErrorPacket (
                                temp_address,
                                (USHORT) (packet_length - remainder_length));
                        }
                        Arbitrated_PDU_Size = (1 << *(packet_address++));
                        remainder_length -= 1;
                        TRACE_OUT(("X224: CC_Packet: Packet size = %d", Arbitrated_PDU_Size));
                        use_default_PDU_size = FALSE;

                         /*
                         **    Allocate the buffers
                         */
                        if (AllocateBuffers() == FALSE)
                        {
                            m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                                   (void *) m_nLocalLogicalHandle);
                        }
                        break;

                    default:
                        ERROR_OUT(("X224: DataIndication: CC packet Unsupported parameter"));
                        length = *(packet_address++);
                        remainder_length--;

                        packet_address += length;
                        remainder_length -= length;
                        break;
                }
                remainder_length--;
            }
            if (use_default_PDU_size)
            {
                if (AllocateBuffers () == FALSE)
                {
                    m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                           (void *) m_nLocalLogicalHandle);
                }
            }

            State = CONNECTION_ACTIVE;

             /*
             **    Notify the owner that the connect request has been confirmed
             */
            m_pT123->OwnerCallback(m_nMsgBase + TPRT_CONNECT_CONFIRM,
                                   (void *) m_nLocalLogicalHandle);
            TRACE_OUT(("X224: DataInd: ConnectConfirm max pkt = %d", Arbitrated_PDU_Size));
            break;

        case DISCONNECT_REQUEST_PACKET:
            TRACE_OUT(("X224: DataIndication: Disconnect req. received"));

             /*
             **    Notify the owner that a disconnect has been requested.  This
             **    message is only valid during establishment of the connection.
             */
            m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                   (void *) m_nLocalLogicalHandle);
            packet_accepted = TRUE;
            break;

        case ERROR_PACKET:
            TRACE_OUT(("X224: DataIndication: ERROR REQUEST received"));

             /*
             **    Notify the owner that the remote site has detected an error in
             **    one of our packets.
             */
            m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                   (void *) m_nLocalLogicalHandle);
            packet_accepted = TRUE;
            break;

        case DATA_PACKET:
            if ((Data_Indication_Reassembly_Active == FALSE) &&
                Data_Indication_Memory_Pool.isEmpty())
            {
                break;
            }

            packet_accepted = TRUE;

             /*
             **    There should be at least 1 bytes remaining in this packet
             */
            if (remainder_length < 1)
            {
                ERROR_OUT(("X224: DataIndication: DATA: Invalid packet "
                    "received from lower layer: length = %d", packet_length));
                break;
            }

            eot = *(packet_address++);
            remainder_length--;

             /*
             **    The EOT_BIT is set if this is the last TPDU of the TSDU
             */
            if ((eot & EOT_BIT) == EOT_BIT)
            {
                if (Data_Indication_Reassembly_Active == FALSE)
                {
                     /*
                     **    If the remote site has passed us an empty packet,
                     **    just return
                     */
                    if (remainder_length == 0)
                        break;

                     /*
                     **    If this is a single packet and there aren't any
                     **    other packets preceeding it, try to send it to the
                     **    user without copying it into our own buffers
                     */
                    if (Data_Indication_Queue.isEmpty())
                    {
                        transport_data.logical_handle = m_nLocalLogicalHandle;
                        transport_data.pbData = packet_address;
                        transport_data.cbDataSize = remainder_length;

                         /*
                         **    Issue the user callback to give the user the data.
                         */
                        user_accepted = ::NotifyT120(TRANSPORT_DATA_INDICATION, &transport_data);

                         /*
                         **    If the user appliction does NOT accept the packet
                         **    shutdown the receiver and wait for the user
                         **    to re-enable it.
                         */
                        if (user_accepted == TRANSPORT_NO_ERROR)
                            break;
                        else
                            Shutdown_Receiver = TRUE;
                    }

                     /*
                     **    Put the packet into the DataIndication queue
                     */
                    packet = (PTMemory) Data_Indication_Memory_Pool.get ();
                    packet_error = packet->Append (packet_address, remainder_length);
                    switch (packet_error)
                    {
                        case TMEMORY_NO_ERROR:
                            Data_Indication_Queue.append ((DWORD_PTR) packet);
                            break;

                        case TMEMORY_NONFATAL_ERROR:
                        case TMEMORY_FATAL_ERROR:
                            packet_accepted = FALSE;
                            break;
                    }
                }
                else
                {
                     /*
                     **    Add this PDU to the currently active SDU
                     */
                    packet_error = Active_Data_Indication -> Append (
                                    packet_address,
                                    remainder_length);

                    switch (packet_error)
                    {
                        case TMEMORY_NO_ERROR:
                            Data_Indication_Reassembly_Active = FALSE;
                            Data_Indication_Queue.append ((DWORD_PTR) Active_Data_Indication);
                            Active_Data_Indication = NULL;

                             /*
                             **    Call PollReceiver (), it will attempt to pass
                             **    the packet on up to the user.
                             */
                            PollReceiver();
                            break;

                        case TMEMORY_NONFATAL_ERROR:
                        case TMEMORY_FATAL_ERROR:
                            packet_accepted = FALSE;
                            break;
                    }
                }
            }
            else
            {
                 /*
                 **    If the remote site is passing us a zero-length packet,
                 **    just return
                 */
                if (remainder_length == 0)
                    break;

                 /*
                 **    This is NOT the last packet in the incoming SDU, copy it
                 **    into the data indication buffer and wait for the next packet
                 */
                if (Data_Indication_Reassembly_Active == FALSE)
                {
                    Data_Indication_Reassembly_Active = TRUE;
                    Active_Data_Indication = (PTMemory) Data_Indication_Memory_Pool.get ();
                }

                packet_error = Active_Data_Indication -> Append (
                                                            packet_address,
                                                            remainder_length);
                switch (packet_error)
                {
                    case TMEMORY_NO_ERROR:
                        break;

                    case TMEMORY_NONFATAL_ERROR:
                    case TMEMORY_FATAL_ERROR:
                        packet_accepted = FALSE;
                        break;
                }
            }
            break;

        default:
            ERROR_OUT(("X224: Illegal packet"));
            break;
    }

    if (packet_accepted)
        *bytes_accepted = packet_length;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::PollTransmitter (
 *                                    ULONG,
 *                                    USHORT,
 *                                    USHORT *    pending_data,
 *                                    USHORT *)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called periodically to give X224 a chance to transmit
 *        data.
 */
ProtocolLayerError    CLayerX224::PollTransmitter (
                                ULONG_PTR,
                                USHORT,
                                USHORT *    pending_data,
                                USHORT *)
{
    // TRACE_OUT(("CLayerX224::PollTransmitter"));

    LPBYTE        packet_address;
    ULONG        bytes_accepted;
    USHORT        counter;
    USHORT        packet_size;
    ULONG        total_length;
    USHORT        packet_length;
    PMemory        memory;
    BOOL        continue_loop = TRUE;

    while (continue_loop)
    {
        switch (Packet_Pending)
        {
            case CONNECTION_REQUEST_PACKET:
                 /*
                 **    Add up the packet length, don't forget the 1 byte
                 **    for the Length Indicator
                 */
                total_length =
                    CONNECT_REQUEST_HEADER_SIZE +
                    TPDU_ARBITRATION_PACKET_SIZE +
                    1 +
                    Lower_Layer_Prepend +
                    Lower_Layer_Append;

                memory = Data_Request_Memory_Manager -> AllocateMemory (
                                            NULL,
                                            total_length);
                if (memory == NULL)
                {
                    continue_loop = FALSE;
                    break;
                }

                packet_address = memory -> GetPointer ();
                packet_address += Lower_Layer_Prepend;

                *(packet_address++) =
                    CONNECT_REQUEST_HEADER_SIZE +
                    TPDU_ARBITRATION_PACKET_SIZE;
                *(packet_address++) = CONNECTION_REQUEST_PACKET;

                 /*
                 **    The following 2 bytes are the destination reference
                 */
                *(packet_address++) = 0;
                *(packet_address++) = 0;
                *(packet_address++) = (BYTE)(m_nLocalLogicalHandle >> 8);
                *(packet_address++) = (BYTE)(m_nLocalLogicalHandle & 0xff);

                 /*
                 **    The following byte is the Class/Options
                 */
                *(packet_address++) = 0;

                 /*
                 **    Add TPDU arbitration data
                 */
                *(packet_address++) = TPDU_SIZE;
                *(packet_address++) = 1;

                 /*
                 **    Code our maximum PDU size into the X224 scheme
                 */
                Arbitrated_PDU_Size = Maximum_PDU_Size;
                packet_size = Arbitrated_PDU_Size;
                counter = 0;
                while (packet_size > 1)
                {
                    packet_size >>= 1;
                    counter++;
                }
                *(packet_address++) = (unsigned char) counter;


                 /*
                 **    Attempt to send the packet to the lower layer
                 */
                m_pQ922->DataRequest(Identifier, memory, &bytes_accepted);

                 /*
                 **    We assume that the lower layer has a packet input
                 **    interface, if it does not, there has been a major error.
                 */
                if (bytes_accepted == total_length)
                {
                    Packet_Pending = TRANSPORT_NO_PACKET;
                    State = SENT_CONNECT_REQUEST_PACKET;
                }
                else
                    continue_loop = FALSE;

                Data_Request_Memory_Manager -> FreeMemory (memory);
                break;

            case CONNECTION_CONFIRM_PACKET:
                packet_length = CONNECT_CONFIRM_HEADER_SIZE;
                if (Packet_Size_Respond)
                    packet_length += TPDU_ARBITRATION_PACKET_SIZE;

                total_length = packet_length +
                                1 +
                                Lower_Layer_Prepend +
                                Lower_Layer_Append;

                memory = Data_Request_Memory_Manager -> AllocateMemory (
                                            NULL,
                                            total_length);
                if (memory == NULL)
                {
                    continue_loop = FALSE;
                    break;
                }

                packet_address = memory -> GetPointer ();
                packet_address += Lower_Layer_Prepend;

                 /*
                 **    Build the packet
                 */
                *(packet_address++) = (UChar) packet_length;
                *(packet_address++) = CONNECTION_CONFIRM_PACKET;
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle >> 8);
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle & 0xff);
                *(packet_address++) = (BYTE)(m_nLocalLogicalHandle >> 8);
                *(packet_address++) = (BYTE)(m_nLocalLogicalHandle & 0xff);

                 /*
                 **    Set the Class/Options to 0
                 */
                *(packet_address++) = 0;

                 /*
                 **    Packet_Size_Respond is TRUE if we are suppose to respond
                 **    to the TPDU element in the Connect Request packet
                 */
                if (Packet_Size_Respond)
                {
                     /*
                     **    Add TPDU arbitration data
                     */
                    *(packet_address++) = TPDU_SIZE;
                    *(packet_address++) = 1;
                    packet_size = Arbitrated_PDU_Size;
                    counter = 0;
                    while (packet_size > 1)
                    {
                        packet_size >>= 1;
                        counter++;
                    }
                    *(packet_address++) = (unsigned char) counter;
                }

                 /*
                 **    Attempt to send the packet to the lower layer
                 */
                m_pQ922->DataRequest(Identifier, memory, &bytes_accepted);

                if (bytes_accepted == total_length)
                {
                    Packet_Pending = TRANSPORT_NO_PACKET;
                    State = CONNECTION_ACTIVE;
                }
                else
                    continue_loop = FALSE;
                Data_Request_Memory_Manager -> FreeMemory (memory);
                break;

            case DISCONNECT_REQUEST_PACKET:
                 /*
                 **    Add 1 to the length for the Length Indicator
                 */
                total_length = DISCONNECT_REQUEST_HEADER_SIZE +
                                1 +
                                Lower_Layer_Prepend +
                                Lower_Layer_Append;

                memory = Data_Request_Memory_Manager -> AllocateMemory (
                                            NULL,
                                            total_length);
                if (memory == NULL)
                {
                    continue_loop = FALSE;
                    break;
                }

                packet_address = memory -> GetPointer ();
                packet_address += Lower_Layer_Prepend;

                TRACE_OUT(("X224: Sending Disconnect Request Packet"));
                *(packet_address++) = DISCONNECT_REQUEST_HEADER_SIZE;
                *(packet_address++) = DISCONNECT_REQUEST_PACKET;
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle >> 8);
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle & 0xff);

                 /*
                 **    Set the source reference to 0,  this packet will only
                 **    be sent as a refusal to a Connect Request, therefore
                 **    this value should be 0
                 */
                *(packet_address++) = 0;
                *(packet_address++) = 0;
                *(packet_address++) = DISCONNECT_REASON_NOT_SPECIFIED;

                 /*
                 **    Attempt to send packet to lower layer
                 */
                m_pQ922->DataRequest(Identifier, memory, &bytes_accepted);

                if (bytes_accepted == total_length)
                {
                    Packet_Pending = TRANSPORT_NO_PACKET;
                    State = SENT_DISCONNECT_REQUEST_PACKET;
                }
                continue_loop = FALSE;
                Data_Request_Memory_Manager -> FreeMemory (memory);
                break;

            case ERROR_PACKET:
                TRACE_OUT(("X224: Sending Error Packet"));
                total_length = ERROR_HEADER_SIZE +
                                Error_Buffer_Length +
                                1 +
                                2 +
                                Lower_Layer_Prepend +
                                Lower_Layer_Append;

                memory = Data_Request_Memory_Manager -> AllocateMemory (
                                            NULL,
                                            total_length);
                if (memory == NULL)
                {
                    continue_loop = FALSE;
                    break;
                }

                packet_address = memory -> GetPointer ();
                packet_address += Lower_Layer_Prepend;


                *(packet_address++) =
                    ERROR_HEADER_SIZE + Error_Buffer_Length;
                *(packet_address++) = ERROR_PACKET;
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle >> 8);
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle & 0xff);
                *(packet_address++) = Reject_Cause;

                *(packet_address++) = INVALID_TPDU;
                *(packet_address++) = (UChar) Error_Buffer_Length;
                memcpy (packet_address, Error_Buffer, Error_Buffer_Length);

                 /*
                 **    Attempt to send packet to lower layer
                 */
                m_pQ922->DataRequest(Identifier, memory, &bytes_accepted);

                if (bytes_accepted == total_length)
                {
                    delete [] Error_Buffer;
                    Error_Buffer = NULL;

                    Packet_Pending = TRANSPORT_NO_PACKET;
                    State = SENT_CONNECT_REQUEST_PACKET;
                }
                else
                    continue_loop = FALSE;
                Data_Request_Memory_Manager -> FreeMemory (memory);
                break;

            case TRANSPORT_NO_PACKET:
                if (Data_Request_Queue.isEmpty() == FALSE)
                {
                     /*
                     **    Get the next packet from the queue
                     */
                    memory = (PMemory) Data_Request_Queue.read ();
                    total_length = memory -> GetLength ();

                    m_pQ922->DataRequest(Identifier, memory, &bytes_accepted);

                    if (bytes_accepted == total_length)
                    {
                        Data_Request_Queue.get ();
                        Data_Request_Memory_Manager -> FreeMemory (memory);
                    }
                    else
                        continue_loop = FALSE;
                }
                else
                    continue_loop = FALSE;
                break;
        }
    }

    if (Data_Request_Queue.isEmpty())
        *pending_data = 0;
    else
        *pending_data = PROTOCOL_USER_DATA;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    TransportError    CLayerX224::DataRequest (
 *                                ULONG,
 *                                LPBYTE    packet_address,
 *                                USHORT    packet_length,
 *                                USHORT *    bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function takes a packet from the user and queues it for
 *        transmission.
 */
ProtocolLayerError    CLayerX224::DataRequest (
                                ULONG_PTR,
                                LPBYTE        packet_address,
                                ULONG        packet_length,
                                PULong        bytes_accepted)
{
    TRACE_OUT(("CLayerX224::DataRequest"));

    ULONG                total_packet_size;
    ULONG                packet_size;
    DataRequestQueue    temporary_queue;
    PMemory                memory;
    BOOL                packet_failed = FALSE;
    LPBYTE                address;

    *bytes_accepted = 0;

    if (Shutdown_Transmitter)
        return (PROTOCOL_LAYER_NO_ERROR);

    total_packet_size = packet_length;

     /*
     **    Create enough PDUs to hold the packet.  We don't actually copy the
     **    packet into the new buffers until we know that we can get enough
     **    space.
     */
    while (total_packet_size != 0)
    {
        if (total_packet_size >
            (ULONG) (Arbitrated_PDU_Size - DATA_PACKET_HEADER_SIZE))
        {
            packet_size = Arbitrated_PDU_Size - DATA_PACKET_HEADER_SIZE;
        }
        else
            packet_size = total_packet_size;

        total_packet_size -= packet_size;

        memory = Data_Request_Memory_Manager -> AllocateMemory (
                                    NULL,
                                    packet_size +
                                        DATA_PACKET_HEADER_SIZE +
                                        Lower_Layer_Prepend +
                                        Lower_Layer_Append);
        if (memory == NULL)
        {
            packet_failed = TRUE;
            break;
        }

        temporary_queue.append ((DWORD_PTR) memory);
    }


     /*
     **    If we were unable to allocate memory for the packet, release the memory
     **    that we did allocate.
     */
    if (packet_failed)
    {
        temporary_queue.reset();
        while (temporary_queue.iterate ((PDWORD_PTR) &memory))
        {
            Data_Request_Memory_Manager->FreeMemory (memory);
        }

         /*
         **    Set the User_Data_Pending flag to the packet_length so we can
         **    notify the user when buffer space is available.
         */
        User_Data_Pending = packet_length;
    }
    else
    {
        User_Data_Pending = 0;

        total_packet_size = packet_length;

         /*
         **    Go thru each of the PDUs and actually create them.
         */
        temporary_queue.reset();
        while (temporary_queue.iterate ((PDWORD_PTR) &memory))
        {
            if (total_packet_size >
                (ULONG) (Arbitrated_PDU_Size - DATA_PACKET_HEADER_SIZE))
            {
                packet_size = Arbitrated_PDU_Size - DATA_PACKET_HEADER_SIZE;
            }
            else
                packet_size = total_packet_size;

            address = memory -> GetPointer ();

            memcpy (
                address + DATA_PACKET_HEADER_SIZE + Lower_Layer_Prepend,
                packet_address + (USHORT) (packet_length - total_packet_size),
                packet_size);

            total_packet_size -= packet_size;

             /*
             **    This is the header for a data packet
             */
            address += Lower_Layer_Prepend;
            *address = 2;
            *(address + 1) = DATA_PACKET;
            if (total_packet_size == 0)
                *(address + 2) = EOT_BIT;
            else
                *(address + 2) = 0;

             /*
             **    Load the memory object into the queue
             */
            Data_Request_Queue.append ((DWORD_PTR) memory);
        }
        *bytes_accepted = packet_length;
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::DataRequest (
 *                                    ULONG,
 *                                    PMemory,
 *                                    USHORT *        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function takes a packet from the user and queues it for
 *        transmission.
 */
ProtocolLayerError    CLayerX224::DataRequest (
                                ULONG_PTR,
                                PMemory,
                                PULong        bytes_accepted)
{
    *bytes_accepted = 0;

    return (PROTOCOL_LAYER_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::PollReceiver (
 *                                    ULONG)
 *
 *    Public
 *
 *    Functional Description:
 *        This function should be called periodically to allow us to send received
 *        packets to the user.
 */
ProtocolLayerError CLayerX224::PollReceiver(void)
{
    // TRACE_OUT(("CLayerX224::PollReceiver"));

    LegacyTransportData    transport_data;
    ULONG            packet_accepted;
    PTMemory        packet;
    HPUChar            packet_address;
    ULONG            packet_length;

    if (Shutdown_Receiver)
        return (PROTOCOL_LAYER_NO_ERROR);

     /*
     **    If I have any packets in my receive buffers that
     **    need to go to higher layers, do it now
     */
    while (Data_Indication_Queue.isEmpty () == FALSE)
    {
        packet = (PTMemory) Data_Indication_Queue.read ();
        packet -> GetMemory (
                    &packet_address,
                    &packet_length);
        transport_data.logical_handle = m_nLocalLogicalHandle;
        transport_data.pbData = (LPBYTE) packet_address;
        transport_data.cbDataSize = packet_length;

        packet_accepted = ::NotifyT120(TRANSPORT_DATA_INDICATION, &transport_data);

         /*
         **    If the user returns anything but TRANSPORT_NO_ERROR, it could not
         **    accept the packet.  We will try to send the packet again later.
         */
        if (packet_accepted == TRANSPORT_NO_ERROR)
        {
            Data_Indication_Queue.get ();
            packet -> Reset ();
            Data_Indication_Memory_Pool.append ((DWORD_PTR) packet);
        }
        else
        {
             /*
             **    If the user appliction does NOT accept the packet
             **    shutdown the receiver and wait for the user to re-enable it.
             */
            Shutdown_Receiver = TRUE;
            break;
        }
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::GetParameters (
 *                                    ULONG,
 *                                    USHORT *    packet_size)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the maximum allowable TSDU.
 */
ProtocolLayerError    CLayerX224::GetParameters (
                                USHORT *,
                                USHORT *,
                                USHORT *)
{
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::RegisterHigherLayer (
 *                                    ULONG,
 *                                    PMemoryManager,
 *                                    IProtocolLayer *)
 *
 *    Public
 *
 *    Functional Description:
 *        This function does nothing.  The only reason it is here is because this
 *        class inherits from ProtocolLayer and this function is pure virtual in
 *        that class.
 */
ProtocolLayerError    CLayerX224::RegisterHigherLayer (
                                ULONG_PTR,
                                PMemoryManager,
                                IProtocolLayer *)
{
    return (PROTOCOL_LAYER_REGISTRATION_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::RemoveHigherLayer (
 *                                    ULONG)
 *
 *    Public
 *
 *    Functional Description:
 *        This function does nothing.  The only reason it is here is because this
 *        class inherits from ProtocolLayer and this function is pure virtual in
 *        that class.
 */
ProtocolLayerError    CLayerX224::RemoveHigherLayer (
                                ULONG_PTR)
{
    return (PROTOCOL_LAYER_REGISTRATION_ERROR);
}


/*
 *    BOOL        CLayerX224::AllocateBuffers ()
 *
 *    Functional Description
 *        This function allocates the data request and data indication buffers.
 *        and sets up the memory pools necessary.  It also sets up the Control
 *        buffer for control packets.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
BOOL        CLayerX224::AllocateBuffers ()
{
    TRACE_OUT(("CLayerX224::AllocateBuffers"));

    PTMemory        packet;
    USHORT            i;
    ULONG            total_packet_size;
    TMemoryError    error;

    total_packet_size = MAXIMUM_USER_DATA_SIZE;
    for (i=0; i<Data_Indication_Queue_Size; i++)
    {
        DBG_SAVE_FILE_LINE
        packet = new TMemory (
                        total_packet_size,
                        0,
                        &error);

        if (error == TMEMORY_NO_ERROR)
            Data_Indication_Memory_Pool.append ((DWORD_PTR) packet);
        else
            return (FALSE);
    }

    return (TRUE);
}


/*
 *    void    CLayerX224::ErrorPacket (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length)
 *
 *    Functional Description
 *        This function stores the packet into our own error buffer and prepares
 *        to send it out
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerX224::ErrorPacket (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerX224::ErrorPacket"));

    DBG_SAVE_FILE_LINE
    Error_Buffer = new BYTE[packet_length];
    if (NULL != Error_Buffer)
    {
        Error_Buffer_Length = packet_length;

        memcpy (Error_Buffer, packet_address, packet_length);

        Packet_Pending = ERROR_PACKET;
    }
}


/*
 *    void    CLayerX224::CheckUserBuffers ()
 *
 *    Public
 *
 *    Functional Description:
 *        This function issues TRANSPORT_BUFFER_AVAILABLE_INDICATIONs to the
 *        user if available.
 */
void    CLayerX224::CheckUserBuffers ()
{
    // TRACE_OUT(("CLayerX224::CheckUserBuffers"));

    ULONG    user_data_size;
    ULONG    buffer_size;
    ULONG    full_size_buffers_needed;
    ULONG    full_size_buffer_count;
    ULONG    partial_buffer_size;
    ULONG    partial_buffer_count;


    if (User_Data_Pending == 0)
        return;

     /*
     **    Determine the user data size in a packet, then determine
     **    how many buffers will be needed to accept that packet.
     */
    user_data_size = Arbitrated_PDU_Size - DATA_PACKET_HEADER_SIZE;
    full_size_buffers_needed = User_Data_Pending / user_data_size;

     /*
     **    Find out how many full size buffers are available
     */
    if (full_size_buffers_needed != 0)
    {
         /*
         **    Increment full_size_buffers_needed to account for our priority
         **    value.
         */
        buffer_size =
            Arbitrated_PDU_Size + Lower_Layer_Prepend + Lower_Layer_Append;

        full_size_buffer_count = Data_Request_Memory_Manager ->
                                    GetBufferCount (buffer_size);
        if (full_size_buffer_count < full_size_buffers_needed)
            return;
    }

    partial_buffer_size = User_Data_Pending % user_data_size;
    if (partial_buffer_size != 0)
    {
        if ((full_size_buffers_needed == 0) ||
            (full_size_buffer_count == full_size_buffers_needed))
        {
            buffer_size = partial_buffer_size +
                            DATA_PACKET_HEADER_SIZE +
                            Lower_Layer_Prepend +
                            Lower_Layer_Append;

            partial_buffer_count = Data_Request_Memory_Manager ->
                                    GetBufferCount (buffer_size);

            if (full_size_buffers_needed == 0)
            {
                if (partial_buffer_count == 0)
                    return;
            }
            else
            {
                if ((partial_buffer_count == full_size_buffer_count) ||
                    (partial_buffer_count == 0))
                {
                    return;
                }
            }
        }
    }

    User_Data_Pending = 0;

    ::NotifyT120(TRANSPORT_BUFFER_EMPTY_INDICATION, (void *) m_nLocalLogicalHandle);

    return;
}


/*
 *    static    ULONG    CLayerX224::GetMaxTPDUSize (
 *                                ULONG    max_lower_layer_pdu)
 *
 *    Public
 *
 *    Functional Description:
 *        This function accepts a value for the lower layer max. PDU size
 *        and returns the max. PDU size that this Transport can support
 *        based on it.  X224 only suports max PDU sizes of 128, 256, 512,
 *        1024, and 2048.  So, if the max_lower_layer_pdu is 260, the
 *        Transport can only have a max pdu size of 256.
 */
ULONG    CLayerX224::GetMaxTPDUSize (
                    ULONG    max_lower_layer_pdu)
{
    TRACE_OUT(("CLayerX224::GetMaxTPDUSize"));

    ULONG    max_tpdu_size;

    if (max_lower_layer_pdu < 256)
        max_tpdu_size = 128;
    else if (max_lower_layer_pdu < 512)
        max_tpdu_size = 256;
    else if (max_lower_layer_pdu < 1024)
        max_tpdu_size = 512;
    else if (max_lower_layer_pdu < 2048)
        max_tpdu_size = 1024;
    else
        max_tpdu_size = 2048;

    return (max_tpdu_size);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\cb32stub\cb32stub.cpp ===
// File: cb32stub.cpp

#include <windows.h>
#include <tchar.h>
#include "SDKInternal.h"

#ifdef _DEBUG
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPSTR lpCmdLine, int nCmdShow)
#else  // _DEBUG
int __cdecl main()
#endif // _DEBUG
{
	CoInitialize(NULL);

	IInternalConfExe* pConf = NULL;

	if(SUCCEEDED(CoCreateInstance(CLSID_NmManager, NULL, CLSCTX_LOCAL_SERVER, IID_IInternalConfExe, reinterpret_cast<void**>(&pConf))))
	{
		pConf->LaunchApplet(NM_APPID_CHAT, NULL);
		pConf->Release();
	}
	
	CoUninitialize();

	#ifndef _DEBUG
		ExitProcess(0);
	#endif

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst123\x224.h ===
/*    X224.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class represents the X.224 class 0 Transport functionality.  This
 *        is the highest layer in the T.123 specification.  This layer is unique
 *        in that it has direct access to the User.  When data packets are
 *        received from the remote site and reassembled by this class, they are
 *        passed on to the user via a callback.
 *
 *        This class has only limited functionality.  It basically has a simple
 *        link establishment procedure (which includes arbitration of maximum PDU
 *        size).  It is then responsible for transmitting and receiving user data.
 *        Its maximum TSDU size is 8K, and its TPDU size can range from 128 bytes
 *        to 2K.  Its TSDU size is larger than its TPDU size, it must be able to
 *        segment and reassemble the user packet.
 *
 *        This layer ASSUMES that its lower layer has a packet interface rather
 *        than a stream interface.
 *
 *        This layer ASSUMES that the disconnect of a call is handled by the
 *        Network layer (as specified in the X.224 class 0 document).
 *
 *        Prior knowledge of the X.224 class 0 specification would help the user
 *        understand the code.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */

#ifndef _X224_H_
#define _X224_H_

#include "tmemory2.h"

 /*
 **    The following, are states that the class can be in.
 */
typedef enum
{
    NO_CONNECTION,
    SENT_CONNECT_REQUEST_PACKET,
    SENT_CONNECT_CONFIRM_PACKET,
    SENT_DISCONNECT_REQUEST_PACKET,
    SENT_ERROR_PACKET,
    CONNECTION_ACTIVE,
    RECEIVED_CONNECT_REQUEST_PACKET,
    FAILED_TO_INITIALIZE
}
    X224State;


#define TRANSPORT_HASHING_BUCKETS   3

 /*
 **    Packet types
 */
#define TPDU_CODE_MASK              0xf0
#define TRANSPORT_NO_PACKET         0x00
#define CONNECTION_REQUEST_PACKET   0xe0
#define CONNECTION_CONFIRM_PACKET   0xd0
#define DISCONNECT_REQUEST_PACKET   0x80
#define ERROR_PACKET                0x70
#define DATA_PACKET                 0xf0

#define TSAP_CALLING_IDENTIFIER     0xc1
#define TSAP_CALLED_IDENTIFIER      0xc2
#define TPDU_SIZE                   0xc0

 /*
 **    These defines are used for the ERROR packet
 */
#define INVALID_TPDU            0xc1

 /*
 **    Packet size codes
 */
#define PACKET_SIZE_128         0x07
#define PACKET_SIZE_256         0x08
#define PACKET_SIZE_512         0x09
#define PACKET_SIZE_1024        0x0a
#define PACKET_SIZE_2048        0x0b

 /*
 **    Miscellaneous definitions
 */
#define MAXIMUM_USER_DATA_SIZE              8192
#define DATA_PACKET_HEADER_SIZE             3
#define EOT_BIT                             0x80
#define CONNECT_REQUEST_HEADER_SIZE         6
#define CONNECT_CONFIRM_HEADER_SIZE         6
#define DISCONNECT_REQUEST_HEADER_SIZE      6
#define ERROR_HEADER_SIZE                   6
#define TPDU_ARBITRATION_PACKET_SIZE        3
#define DISCONNECT_REASON_NOT_SPECIFIED     0


typedef SListClass    DataRequestQueue;
typedef SListClass    PacketQueue;


class CLayerX224 : public IProtocolLayer
{
public:

    CLayerX224(
        T123               *owner_object,
        CLayerQ922         *lower_layer,
        USHORT              message_base,
        LogicalHandle       logical_handle,
        ULONG               identifier,
        USHORT              data_indication_queue_size,
        USHORT              default_PDU_size,
        PMemoryManager      dr_memory_manager,
        BOOL               *initialization_success);

     virtual ~CLayerX224(void);

     /*
     **    Making and breaking links
     */
    TransportError    ConnectRequest (void);
    TransportError    ConnectResponse (void);
    TransportError    DisconnectRequest (void);

     /*
     **    Functions overridden from the ProtocolLayer object
     */
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     identifier,
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataRequest (
                            ULONG_PTR    identifier,
                            PMemory,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataIndication (
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    RegisterHigherLayer (
                            ULONG_PTR,
                            PMemoryManager,
                            IProtocolLayer *);
    ProtocolLayerError    RemoveHigherLayer (
                            ULONG_PTR);
    ProtocolLayerError    PollTransmitter (
                            ULONG_PTR     identifier,
                            USHORT        data_to_transmit,
                            USHORT *    pending_data,
                            USHORT *    holding_data);
    ProtocolLayerError    PollReceiver(void);
    ProtocolLayerError    GetParameters (
                            USHORT *,
                            USHORT *,
                            USHORT *);

    void                ShutdownReceiver (void);
    void                EnableReceiver (void);
    void                ShutdownTransmitter (void);
    void                PurgeRequest (void);
    void                CheckUserBuffers (void);
static    ULONG                GetMaxTPDUSize (
                            ULONG    max_lower_layer_pdu);

private:

    BOOL                AllocateBuffers (void);
    void                ErrorPacket (
                            LPBYTE    packet_address,
                            USHORT    packet_length);
private:

    DataRequestQueue    Data_Request_Queue;
    PacketQueue         Data_Indication_Queue;
    PacketQueue         Data_Indication_Memory_Pool;

    PTMemory            Active_Data_Indication;
    T123               *m_pT123; // owner object
    CLayerQ922         *m_pQ922; // lower layer;
    USHORT              m_nMsgBase;
    USHORT              Default_PDU_Size;
    USHORT              Maximum_PDU_Size;
    USHORT              Arbitrated_PDU_Size;
    ULONG               Identifier;
    PMemoryManager      Data_Request_Memory_Manager;
    USHORT              Lower_Layer_Prepend;
    USHORT              Lower_Layer_Append;
    ULONG               User_Data_Pending;

    USHORT              Data_Indication_Queue_Size;
    BOOL                Data_Indication_Reassembly_Active;

    X224State           State;
    USHORT              Packet_Pending;
    UChar               Reject_Cause;
    BOOL                Packet_Size_Respond;
    BOOL                Shutdown_Receiver;
    BOOL                Shutdown_Transmitter;

    LPBYTE              Error_Buffer;
    USHORT              Error_Buffer_Length;

    LogicalHandle       m_nLocalLogicalHandle;
    LogicalHandle       m_nRemoteLogicalHandle;
};

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    Transport::Transport (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                USHORT                logical_handle,
 *                USHORT                identifier,
 *                USHORT                data_request_queue_size,
 *                USHORT                data_indication_queue_size,
 *                USHORT                default_PDU_size,
 *                PMemoryManager        dr_memory_manager,
 *                BOOL  *               initialization_success);
 *
 *    Functional Description
 *        This is the class constructor.  During construction, this object
 *        registers itself with its lower layer and allocates buffer space for
 *        sending and receiving data.
 *
 *    Formal Parameters
 *        transport_resources    (i)    -    Pointer to TransportResources structure.
 *        owner_object        (i) -    Address of owner object.  We use this
 *                                    address for owner callbacks.
 *        lower_layer            (i) -    Address of the lower layer that we will use
 *                                    for data reception and transmission.  This
 *                                    layer must inherit from ProtocolLayer.
 *        message_base        (i) -    Message base for messages used for owner
 *                                    callbacks.
 *        logical_handle         (i) -    This identification must be passed back to
 *                                    the owner during owner callbacks to identify
 *                                    itself.
 *        identifier             (i) -    This identifier is passed to the lower layer
 *                                    to identify itself (in case the lower layer
 *                                    is doing multiplexing.
 *        data_request_queue_size    (i) -    Number of buffers to be used for data
 *                                        requests from user.
 *        data_indication_queue_size    (i) -    Number of buffers to be used for
 *                                            data requests from user.
 *        default_PDU_size    (i) -    If the remote site does not support packet
 *                                    size arbitration, this is the default
 *        dr_memory_manager    (i) -    Data Request memory manager
 *        initialization_success    (o) -    Return TRUE if initialization was
 *                                        successful
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    Transport::~Transport (void)
 *
 *    Functional Description
 *        This is the destructor for the class.  It does all cleanup
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    TransportError    Transport::ConnectRequest (void);
 *
 *    Functional Description
 *        This function is called to initiate the connection.  As a result the
 *        owner will either receive a TRANSPORT_CONNECT_CONFIRM or a
 *        TRANSPORT_DISCONNECT_INDICATION message on completion of arbitration.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR    -    No error occured
 *        TRANSPORT_ERROR        -    Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    TransportError    Transport::ConnectResponse (void);
 *
 *    Functional Description
 *        This function is called in response to a TRANSPORT_CONNECT_INDICATION
 *        message issued by this class.  By calling this function, the user is
 *        accepting the transport connection.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR    -    No error occured
 *        TRANSPORT_ERROR        -    Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    TransportError    Transport::DisconnectRequest (void);
 *
 *    Functional Description
 *        This function is called in response to a TRANSPORT_CONNECT_INDICATION
 *        message issued by this class.  By calling this function, the user is
 *        not accepting the transport connection.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR    -    No error occured
 *        TRANSPORT_ERROR        -    Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Transport::DataRequest (
 *                                    USHORT        identifier,
 *                                    LPBYTE        buffer_address,
 *                                    USHORT        length,
 *                                    USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Length of packet to transmit
 *        bytes_accepted    (o)    -    Number of bytes accepted by the Transport.
 *                                This value will either be 0 or the packet
 *                                length since this layer is a packet to byte
 *                                converter.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Transport::DataIndication (
 *                                    LPBYTE        buffer_address,
 *                                    USHORT        length,
 *                                    USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by the lower layer when it has data to pass up
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes available
 *        bytes_accepted    (o)    -    Number of bytes accepted
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Transport::RegisterHigherLayer (
 *                                    USHORT,
 *                                    IProtocolLayer *);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  This function is not used by this class.  It is only
 *        in here because this class inherits from ProtocolLayer and this function
 *        is a pure virtual function.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Transport::RemoveHigherLayer (
 *                                    USHORT);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove its identifier
 *        and its address.  This function is not used by this class.  It is only
 *        in here because this class inherits from ProtocolLayer and this function
 *        is a pure virtual function.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    Transport::PollTransmitter (
 *                                        USHORT,
 *                                        USHORT        data_to_transmit,
 *                                        USHORT *        pending_data,
 *                                        USHORT *)
 *
 *    Functional Description
 *        This function is called to give the Transport a chance transmit data
 *        in its Data_Request buffer.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        data_to_transmit    (i)    -    This is a mask that tells us to send Control
 *                                    data, User data, or both.  Since the
 *                                     Transport does not differentiate between
 *                                    data types it transmits any data it has
 *        pending_data        (o)    -    Return value to indicate which data is left
 *                                    to be transmitted.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Transport::PollReceiver (
 *                                    USHORT    identifier);
 *
 *    Functional Description
 *        This function is called to give the Transport a chance pass packets
 *        to higher layers
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    Transport::GetParameters (
 *                                    USHORT    identifier,
 *                                    USHORT *    max_packet_size,
 *                                    USHORT *    prepend,
 *                                    USHORT *    append);
 *
 *    Functional Description:
 *        This function is not used by this class.  It is only in here because
 *        this class inherits from ProtocolLayer and this function
 *        is a pure virtual function.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    Transport::ShutdownReceiver ();
 *
 *    Functional Description:
 *        This function tells the object to stop accepting packets from the
 *        lower layer
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    Transport::EnableReceiver (void);
 *
 *    Functional Description:
 *        This function tells the object to start sending packets up to the user
 *        again.  If the X224 object ever issues a DATA_INDICATION and it fails,
 *        we shutdown the receiver.  We wait for this call to be issued before
 *        we start sending up packets again.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    Transport::ShutdownTransmitter (void);
 *
 *    Functional Description:
 *        This function tells the object to stop accepting packets from
 *        higher layers.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    Transport::PurgeRequest (void);
 *
 *    Functional Description:
 *        This function removes all packets from the Transport's outbound queue
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    Transport::CheckUserBuffers (void);
 *
 *    Functional Description:
 *        This function determines if the user has recently failed to pass a
 *        packet down to the Transport because we didn't have enough memory
 *        available to handle it.  If he did and we NOW have space for that
 *        packet, we will issue a TRANSPORT_BUFFER_EMPTY_INDICATION callback
 *        to the user, to notify him that we can accept it.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    static    ULONG    Transport::GetMaxTPDUSize (
 *                                ULONG    max_lower_layer_pdu)
 *
 *    Public
 *
 *    Functional Description:
 *        This function accepts a value for the lower layer max. PDU size
 *        and returns the max. PDU size that this Transport can support
 *        based on it.  X224 only suports max PDU sizes of 128, 256, 512,
 *        1024, and 2048.  So, if the max_lower_layer_pdu is 260, the
 *        Transport can only have a max pdu size of 256.
 *
 *    Formal Parameters
 *        max_lower_layer_pdu        -    Since we pass data to the lower layer,
 *                                    we must conform to its max packet size.
 *
 *    Return Value
 *        The largest TPDU that we will send based on the max_lower_layer_pdu.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\adlkup.cpp ===
#include "precomp.h"
#include <mapix.h>
#include "wabutil.h"
#include "AdLkup.h"
#include "MapiInit.h"

// From Platform SDK AddrLkup.c


////////////////////////////////////////////////////////////////////////////
/*
    This function was ripped out from the source for AdrLkup.lib
        because it is the only function that we use from that lib, and linking
        to it required linking to MAPI32.lib as well as C-RunTime LIBs.
*/
////////////////////////////////////////////////////////////////////////////

//$--HrFindExchangeGlobalAddressList-------------------------------------------------
// Returns the entry ID of the global address list container in the address
// book.
// -----------------------------------------------------------------------------
HRESULT HrFindExchangeGlobalAddressList( // RETURNS: return code
    IN LPADRBOOK  lpAdrBook,        // address book pointer
    OUT ULONG *lpcbeid,             // pointer to count of bytes in entry ID
    OUT LPENTRYID *lppeid)          // pointer to entry ID pointer
{
    HRESULT         hr                  = NOERROR;
    ULONG           ulObjType           = 0;
    ULONG           i                   = 0;
    LPMAPIPROP      lpRootContainer     = NULL;
    LPMAPITABLE     lpContainerTable    = NULL;
    LPSRowSet       lpRows              = NULL;
    ULONG           cbContainerEntryId  = 0;
    LPENTRYID       lpContainerEntryId  = NULL;
    LPSPropValue    lpCurrProp          = NULL;
    SRestriction    SRestrictAnd[2]     = {0};
    SRestriction    SRestrictGAL        = {0};
    SPropValue      SPropID             = {0};
    SPropValue      SPropProvider       = {0};
    BYTE            muid[]              = MUIDEMSAB;

    SizedSPropTagArray(1, rgPropTags) =
    {
        1, 
        {
            PR_ENTRYID,
        }
    };

    if(FAILED(hr))
        return(hr);

    *lpcbeid = 0;
    *lppeid  = NULL;

    // Open the root container of the address book
    hr = (lpAdrBook)->OpenEntry(
        0,
        NULL,
        NULL,
        MAPI_DEFERRED_ERRORS, 
        &ulObjType,
        (LPUNKNOWN FAR *)&lpRootContainer);

    if(FAILED(hr))
    {
        goto cleanup;
    }

    if(ulObjType != MAPI_ABCONT)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the hierarchy table of the root container
    hr = (((LPABCONT)lpRootContainer))->GetHierarchyTable(
                MAPI_DEFERRED_ERRORS|CONVENIENT_DEPTH,
                &lpContainerTable);

    if(FAILED(hr))
    {
        goto cleanup;
    }

    // Restrict the table to the global address list (GAL)
    // ---------------------------------------------------

    // Initialize provider restriction to only Exchange providers

    SRestrictAnd[0].rt                          = RES_PROPERTY;
    SRestrictAnd[0].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[0].res.resProperty.ulPropTag   = PR_AB_PROVIDER_ID;
    SPropProvider.ulPropTag                     = PR_AB_PROVIDER_ID;

    SPropProvider.Value.bin.cb                  = 16;
    SPropProvider.Value.bin.lpb                 = (LPBYTE)muid;
    SRestrictAnd[0].res.resProperty.lpProp      = &SPropProvider;

    // Initialize container ID restriction to only GAL container

    SRestrictAnd[1].rt                          = RES_PROPERTY;
    SRestrictAnd[1].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[1].res.resProperty.ulPropTag   = PR_EMS_AB_CONTAINERID;
    SPropID.ulPropTag                           = PR_EMS_AB_CONTAINERID;
    SPropID.Value.l                             = 0;
    SRestrictAnd[1].res.resProperty.lpProp      = &SPropID;

    // Initialize AND restriction 
    
    SRestrictGAL.rt                             = RES_AND;
    SRestrictGAL.res.resAnd.cRes                = 2;
    SRestrictGAL.res.resAnd.lpRes               = &SRestrictAnd[0];

    // Restrict the table to the GAL - only a single row should remain

    // Get the row corresponding to the GAL

	//
	//  Query all the rows
	//

	hr = lpfnHrQueryAllRows(
	        lpContainerTable,
		    (LPSPropTagArray)&rgPropTags,
		    &SRestrictGAL,
		    NULL,
		    0,
		    &lpRows);

    if(FAILED(hr) || (lpRows == NULL) || (lpRows->cRows != 1))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the entry ID for the GAL

    lpCurrProp = &(lpRows->aRow[0].lpProps[0]);

    if(lpCurrProp->ulPropTag == PR_ENTRYID)
    {
        cbContainerEntryId = lpCurrProp->Value.bin.cb;
        lpContainerEntryId = (LPENTRYID)lpCurrProp->Value.bin.lpb;
    }
    else
    {
        hr = EDK_E_NOT_FOUND;
        goto cleanup;
    }

    hr = lpfnMAPIAllocateBuffer(cbContainerEntryId, (LPVOID *)lppeid);

    if(FAILED(hr))
    {
        *lpcbeid = 0;
        *lppeid = NULL;
    }
    else
    {
        CopyMemory(
            *lppeid,
            lpContainerEntryId,
            cbContainerEntryId);

        *lpcbeid = cbContainerEntryId;
    }

cleanup:

    lpRootContainer -> Release();
    lpContainerTable -> Release();
    lpfnFreeProws( lpRows );
    
    if(FAILED(hr))
    {
        lpfnMAPIFreeBuffer(*lppeid);

        *lpcbeid = 0;
        *lppeid = NULL;
    }
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\adlkup.h ===
#ifndef __AdLkup_h__
#define __AdLkup_h__


////////////////////////////////////////////////////////////////////////////
/*
    This function was ripped out from the source for AdrLkup.lib
        because it is the only function that we use from that lib, and linking
        to it required linking to MAPI32.lib as well as C-RunTime LIBs.
*/
////////////////////////////////////////////////////////////////////////////

//$--HrFindExchangeGlobalAddressList-------------------------------------------------
// Returns the entry ID of the global address list container in the address
// book.
// -----------------------------------------------------------------------------
HRESULT HrFindExchangeGlobalAddressList( // RETURNS: return code
    IN LPADRBOOK  lpAdrBook,        // address book pointer
    OUT ULONG *lpcbeid,             // pointer to count of bytes in entry ID
    OUT LPENTRYID *lppeid);         // pointer to entry ID pointer






////////////////////////////////////////////////////////////////////////////
/*

    The following constants were ripped out from various header files from
        the platform SDK because including the actual headers pulled in a bunch
        of stuff that we didn't care about.  Because there are so few dependencies
        it was better to just grab the constants...
*/
////////////////////////////////////////////////////////////////////////////

 // From platform SDK _entryid.h

/*
 *  The EMS ABPs MAPIUID
 *
 *  This MAPIUID must be unique (see the Service Provider Writer's Guide on
 *  Constructing Entry IDs)
 */
#define MUIDEMSAB {0xDC, 0xA7, 0x40, 0xC8, 0xC0, 0x42, 0x10, 0x1A, \
		       0xB4, 0xB9, 0x08, 0x00, 0x2B, 0x2F, 0xE1, 0x82}




// From platform SDK EdkCode.h

// Every HRESULT is built from a serverity value, a facility
// value and an error code value.

#define FACILITY_EDK    11          // EDK facility value

// Pairs of EDK error codes and the HRESULTs built from them.
// EDK functions always return HRESULTs.  Console applications
// return exit codes via the _nEcFromHr function.

#define EC_EDK_E_NOT_FOUND          0x0001
#define EDK_E_NOT_FOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_NOT_FOUND)



// This is taken from emsabTag.h
#define PR_EMS_AB_CONTAINERID                PROP_TAG( PT_LONG,    0xFFFD)


#endif // __AdLkup_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\appcollection.cpp ===
#include "precomp.h"
#include "AppCollection.h"
#include "confroom.h"
#include "EnumVar.h"

//////////////////////////////////////////////////////////
// Construction/destruction/initialization
//////////////////////////////////////////////////////////

CSharableAppCollection::CSharableAppCollection()
: m_pList(NULL)
{
	DBGENTRY(CSharableAppCollection::CSharableAppCollection);
	
	DBGEXIT(CSharableAppCollection::CSharableAppCollection);
}

CSharableAppCollection::~CSharableAppCollection()
{
	DBGENTRY(CSharableAppCollection::~CSharableAppCollection);
	
	if(m_pList)
	{
		FreeShareableApps(m_pList);
	}

	DBGEXIT(CSharableAppCollection::~CSharableAppCollection);
}

//static 
HRESULT CSharableAppCollection::CreateInstance(IAS_HWND_ARRAY* pList, ISharableAppCollection **ppSharebleAppCollection)
{
	DBGENTRY(HRESULT CSharableAppCollection::CreateInstance);
	HRESULT hr = S_OK;

	if(pList)
	{	
		CComObject<CSharableAppCollection>* p = NULL;
		p = new CComObject<CSharableAppCollection>(NULL);
		if(p)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hr = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if(hr == S_OK)
			{
				hr = p->QueryInterface(IID_ISharableAppCollection, reinterpret_cast<void**>(ppSharebleAppCollection));
				p->m_pList = pList;
			}

			if(FAILED(hr))		
			{
				delete p;
				*ppSharebleAppCollection = NULL;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT(CSharableAppCollection::CreateInstance);
	return hr;
}

//////////////////////////////////////////////////////////
// ISharableAppCollection
//////////////////////////////////////////////////////////
STDMETHODIMP CSharableAppCollection::get_Item(VARIANT Index, DWORD* pSharableAppHWND)
{
	DBGENTRY(CSharableAppCollection::get_Item);
	HRESULT hr = S_OK;

	USES_CONVERSION;

	if(m_pList)
	{
		if(pSharableAppHWND)
		{
			switch(Index.vt)
			{
				case VT_BSTR:
					*pSharableAppHWND = reinterpret_cast<long>(_GetHWNDFromName(OLE2T(Index.bstrVal)));
					break;

				case VT_I2:
					if(static_cast<UINT>(Index.iVal) < m_pList->cEntries)
					{
						*pSharableAppHWND = reinterpret_cast<long>(m_pList->aEntries[Index.iVal].hwnd);
					}
					else
					{
						hr = E_INVALIDARG;
					}
					break;

				case VT_I4:
					if(static_cast<UINT>(Index.lVal) < m_pList->cEntries)
					{
						*pSharableAppHWND = reinterpret_cast<long>(m_pList->aEntries[Index.lVal].hwnd);
					}
					else
					{
						hr = E_INVALIDARG;
					}
					break;

				default:
					hr = E_INVALIDARG;
			}
		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CSharableAppCollection::get_Item,hr);
	return hr;
}

STDMETHODIMP CSharableAppCollection::_NewEnum(IUnknown** ppunk)
{
	DBGENTRY(CSharableAppCollection::_NewEnum);
	HRESULT hr = S_OK;

	if(m_pList)
	{
		SAFEARRAY* psa;
		SAFEARRAYBOUND rgsabound[1];
		rgsabound[0].lLbound = 0;
		rgsabound[0].cElements = m_pList->cEntries;

		psa = SafeArrayCreate(VT_I4, m_pList->cEntries, rgsabound);
		if(psa)
		{
			for(UINT i = 0; i < m_pList->cEntries; ++i)
			{
				CComVariant var(reinterpret_cast<long>(m_pList->aEntries[i].hwnd));
				long ix[1] = {i};
				SafeArrayPutElement(psa, ix, &var);
			}

			CEnumVariant* pEnumVar = NULL;
			hr = CEnumVariant::Create(psa, m_pList->cEntries, &pEnumVar);
			if(SUCCEEDED(hr))
			{
				hr = pEnumVar->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(ppunk));
			}

			SafeArrayDestroy(psa);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	DBGEXIT_HR(CSharableAppCollection::_NewEnum,hr);
	return hr;

}

STDMETHODIMP CSharableAppCollection::get_Count(LONG * pnCount)
{
	DBGENTRY(CSharableAppCollection::get_Count);
	HRESULT hr = S_OK;

	if(m_pList)
	{
		if(pnCount)
		{
			*pnCount = m_pList->cEntries;
		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CSharableAppCollection::get_Count,hr);
	return hr;
}


//////////////////////////////////////////////////////////
// Helper Fns
//////////////////////////////////////////////////////////
HWND CSharableAppCollection::_GetHWNDFromName(LPCTSTR pcsz)
{
	HWND hWnd = NULL;

	if(m_pList)
	{
		int cch = lstrlen(pcsz) + 1;
		LPTSTR pszTmp = new TCHAR[cch];
		if(pszTmp)
		{
			for(UINT i = 0; i < m_pList->cEntries; ++i)
			{
				HWND hWndCur = m_pList->aEntries[i].hwnd;
				if(::GetWindowText(hWndCur , pszTmp, cch))
				{
						// If the window text is the same, just return the hwnd
					if(!lstrcmp(pcsz, pszTmp))
					{
						hWnd = hWndCur;
						break;
					}
				}
			}

			delete [] pszTmp;
		}
	}

	return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\appcollection.h ===
#ifndef __AppCollection_h__
#define __AppCollection_h__

#include "NetMeeting.h"
#include "ias.h"

class ATL_NO_VTABLE CSharableAppCollection :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ISharableAppCollection, &IID_ISharableAppCollection, &LIBID_NetMeetingLib>
{

protected:

IAS_HWND_ARRAY* m_pList;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CSharableAppCollection)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSharableAppCollection)
	COM_INTERFACE_ENTRY(ISharableAppCollection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//////////////////////////////////////////////////////////
// Construction/destruction/initialization
//////////////////////////////////////////////////////////

CSharableAppCollection();
~CSharableAppCollection();

static HRESULT CreateInstance(IAS_HWND_ARRAY* pList, ISharableAppCollection **ppSharebleAppCollection);

//////////////////////////////////////////////////////////
// ISharableAppCollection
//////////////////////////////////////////////////////////
	STDMETHOD(get_Item)(VARIANT Index, DWORD* pSharableAppHWND);
	STDMETHOD(_NewEnum)(IUnknown** ppunk);
    STDMETHOD(get_Count)(LONG * pnCount);

//////////////////////////////////////////////////////////
// Helper Fns
//////////////////////////////////////////////////////////
HWND _GetHWNDFromName(LPCTSTR pcsz);

};

#endif // __AppCollection_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\atlexemodule.cpp ===
#include "precomp.h"
#include "Conf.h"
#include "confpolicies.h"
#include "AtlExeModule.h"
#include "NmManager.h"
#include "NmApp.h"

// This is slightly modified from the code that AtlAppWizard generates for local servers


CExeModule::CExeModule()
: m_dwThreadID( 0 ),
  m_hResourceModule( NULL ),
  m_bInitControl(FALSE),
  m_bVisible(FALSE),
  m_bDisableH323(FALSE),
  m_bDisableInitialILSLogon(FALSE)
{
	DBGENTRY(CExeModule::CExeModule);

	DBGEXIT(CExeModule::CExeModule);
}

LONG CExeModule::Unlock()
{
	DBGENTRY(CExeModule::Unlock);
	
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
		if (ConfPolicies::RunWhenWindowsStarts())
		{
			// we may want to make sure that there is no conference
			// if there is,we should probably bring up the UI
		}
		else
		{
			if( !IsUIVisible() )
			{
				CmdShutdown();
			}
		}
    }

	DBGEXIT_INT(CExeModule::Unlock,l);
    return l;
}


BOOL CExeModule::IsUIActive()
{
	return !InitControlMode() &&
		(0 == CNmManagerObj::GetManagerCount(NM_INIT_OBJECT)) && 
		(IsUIVisible() ||
		 (0 == CNmManagerObj::GetManagerCount(NM_INIT_BACKGROUND)) &&
		 (0 == CNetMeetingObj::GetObjectCount()));
}

// Declare the _Module
CExeModule _Module;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\audioctl.cpp ===
// File: audioctl.cpp

#include "precomp.h"
#include "resource.h"
#include "audioctl.h"
#include "mixer.h"
#include "confpolicies.h"

CAudioControl::CAudioControl(HWND hwnd) :
	m_pRecMixer(NULL),
	m_pSpkMixer(NULL),
	m_fMicMuted(FALSE),
	m_fSpkMuted(FALSE),
	m_pChannelMic(NULL),
	m_pChannelSpk(NULL),
	m_pAudioEvent(NULL),
	m_dwRecordDevice(0),
	m_dwPlaybackDevice(0),
	m_dwSilenceLevel(DEFAULT_MICROPHONE_SENSITIVITY * 10),
	m_hwndParent(hwnd)
{
	m_dwMicVolume.leftVolume	= 0xFFFFFFFF,
	m_dwMicVolume.rightVolume	= 0xFFFFFFFF;
	m_dwSpkVolume.leftVolume	= 0xFFFFFFFF;
	m_dwSpkVolume.rightVolume	= 0xFFFFFFFF;
	m_dwSpkVolumeOld.leftVolume	= 0xFFFFFFFF;
	m_dwSpkVolumeOld.rightVolume	= 0xFFFFFFFF;

	LoadSettings();
	OnDeviceChanged();
	OnAGC_Changed();
	OnSilenceLevelChanged();
}

CAudioControl::~CAudioControl()
{
	SaveSettings();

	// restore speaker volume
	if (m_pSpkMixer && (m_dwSpkVolumeOld.leftVolume <= 0x0000ffff || m_dwSpkVolumeOld.rightVolume <= 0x0000ffff))
	{
		m_pSpkMixer->SetVolume(&m_dwSpkVolumeOld);
	}


	delete m_pRecMixer;
	delete m_pSpkMixer;

	if (NULL != m_pChannelMic)
	{
		m_pChannelMic->Release();
	}
	if (NULL != m_pChannelSpk)
	{
		m_pChannelSpk->Release();
	}
}

/****************************************************************************
*
*    CLASS:    CAudioControl
*
*    MEMBER:   OnChannelChanged()
*
*    PURPOSE:  Tracks audio channel changes
*
****************************************************************************/

void CAudioControl::OnChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	INmChannelAudio* pChannelAudio;
	if (SUCCEEDED(pChannel->QueryInterface(IID_INmChannelAudio, (void**)&pChannelAudio)))
	{
		if (S_OK == pChannelAudio->IsActive())
		{
			if (S_OK == pChannelAudio->IsIncoming())
			{
				if (NULL == m_pChannelSpk)
				{
					m_pChannelSpk = pChannelAudio;
					m_pChannelSpk->AddRef();
					m_pChannelSpk->SetProperty(NM_AUDPROP_PAUSE, m_fSpkMuted);
					m_pChannelSpk->SetProperty(NM_AUDPROP_WAVE_DEVICE, m_dwPlaybackDevice);
				}
			}
			else
			{
				if (NULL == m_pChannelMic)
				{
					m_pChannelMic = pChannelAudio;
					m_pChannelMic->AddRef();
					m_pChannelMic->SetProperty(NM_AUDPROP_PAUSE, m_fMicMuted);
					m_pChannelMic->SetProperty(NM_AUDPROP_LEVEL, m_dwSilenceLevel);
					m_pChannelMic->SetProperty(NM_AUDPROP_WAVE_DEVICE, m_dwRecordDevice);
					m_pChannelMic->SetProperty(NM_AUDPROP_AUTOMIX, m_fAutoMix);
				}
			}
		}
		else
		{
			if (S_OK == pChannelAudio->IsIncoming())
			{
				// were done with the speaker channel
				if (pChannelAudio == m_pChannelSpk)
				{
					m_pChannelSpk->Release();
					m_pChannelSpk = NULL;
				}
			}
			else
			{
				// were done with the speaker channel
				if (pChannelAudio == m_pChannelMic)
				{
					m_pChannelMic->Release();
					m_pChannelMic = NULL;
				}
			}
		}
		pChannelAudio->Release();
	}
}

/****************************************************************************
*
*    CLASS:    CAudioControl
*
*    MEMBER:   RefreshMixer()
*
*    PURPOSE:  Refreshes all controls that are mixer dependent
*
****************************************************************************/

void CAudioControl::RefreshMixer()
{
	if (NULL != m_pSpkMixer)
	{
		MIXVOLUME dwVol;
		BOOL fValid;
		fValid = m_pSpkMixer->GetVolume(&dwVol);

		if (fValid && (dwVol.leftVolume != m_dwSpkVolume.leftVolume || dwVol.rightVolume != m_dwSpkVolume.rightVolume))
		{
			m_dwSpkVolume.leftVolume = dwVol.leftVolume;
			m_dwSpkVolume.rightVolume = dwVol.rightVolume;

			if (NULL != m_pAudioEvent)
			{
				m_pAudioEvent->OnLevelChange(TRUE /* fSpeaker */, max(m_dwSpkVolume.leftVolume , m_dwSpkVolume.rightVolume));
			}
		}
	}
	
	if (NULL != m_pRecMixer)
	{
		BOOL fChanged = FALSE;
		
		MIXVOLUME dwMainVol = {0,0};
		BOOL fValidMain = m_pRecMixer->GetMainVolume(&dwMainVol);
		
		MIXVOLUME dwMicVol = {0,0};
		BOOL fValidMic = m_pRecMixer->GetSubVolume(&dwMicVol);
		
		if (fValidMain && (m_dwMicVolume.leftVolume != dwMainVol.leftVolume || m_dwMicVolume.rightVolume != dwMainVol.rightVolume))
		{
			m_dwMicVolume.leftVolume = dwMainVol.leftVolume;
			m_dwMicVolume.rightVolume = dwMainVol.rightVolu